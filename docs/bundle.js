/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/.registry.npmjs.org/animejs/3.0.1/node_modules/animejs/lib/anime.es.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/animejs/3.0.1/node_modules/animejs/lib/anime.es.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*
 * anime.js v3.0.1
 * (c) 2019 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */

// Defaults

var defaultInstanceSettings = {
  update: null,
  begin: null,
  loopBegin: null,
  changeBegin: null,
  change: null,
  changeComplete: null,
  loopComplete: null,
  complete: null,
  loop: 1,
  direction: 'normal',
  autoplay: true,
  timelineOffset: 0
};

var defaultTweenSettings = {
  duration: 1000,
  delay: 0,
  endDelay: 0,
  easing: 'easeOutElastic(1, .5)',
  round: 0
};

var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective'];

// Caching

var cache = {
  CSS: {},
  springs: {}
};

// Utils

function minMax(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

function stringContains(str, text) {
  return str.indexOf(text) > -1;
}

function applyArguments(func, args) {
  return func.apply(null, args);
}

var is = {
  arr: function (a) { return Array.isArray(a); },
  obj: function (a) { return stringContains(Object.prototype.toString.call(a), 'Object'); },
  pth: function (a) { return is.obj(a) && a.hasOwnProperty('totalLength'); },
  svg: function (a) { return a instanceof SVGElement; },
  inp: function (a) { return a instanceof HTMLInputElement; },
  dom: function (a) { return a.nodeType || is.svg(a); },
  str: function (a) { return typeof a === 'string'; },
  fnc: function (a) { return typeof a === 'function'; },
  und: function (a) { return typeof a === 'undefined'; },
  hex: function (a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a); },
  rgb: function (a) { return /^rgb/.test(a); },
  hsl: function (a) { return /^hsl/.test(a); },
  col: function (a) { return (is.hex(a) || is.rgb(a) || is.hsl(a)); },
  key: function (a) { return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes'; }
};

// Easings

function parseEasingParameters(string) {
  var match = /\(([^)]+)\)/.exec(string);
  return match ? match[1].split(',').map(function (p) { return parseFloat(p); }) : [];
}

// Spring solver inspired by Webkit Copyright Â© 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js

function spring(string, duration) {

  var params = parseEasingParameters(string);
  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
  var velocity =  minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

  function solver(t) {
    var progress = duration ? (duration * t) / 1000 : t;
    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a + b * progress) * Math.exp(-progress * w0);
    }
    if (t === 0 || t === 1) { return t; }
    return 1 - progress;
  }

  function getDuration() {
    var cached = cache.springs[string];
    if (cached) { return cached; }
    var frame = 1/6;
    var elapsed = 0;
    var rest = 0;
    while(true) {
      elapsed += frame;
      if (solver(elapsed) === 1) {
        rest++;
        if (rest >= 16) { break; }
      } else {
        rest = 0;
      }
    }
    var duration = elapsed * frame * 1000;
    cache.springs[string] = duration;
    return duration;
  }

  return duration ? solver : getDuration;

}

// Elastic easing adapted from jQueryUI http://api.jqueryui.com/easings/

function elastic(amplitude, period) {
  if ( amplitude === void 0 ) amplitude = 1;
  if ( period === void 0 ) period = .5;

  var a = minMax(amplitude, 1, 10);
  var p = minMax(period, .1, 2);
  return function (t) {
    return (t === 0 || t === 1) ? t : 
      -a * Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2) * Math.asin(1 / a))) * (Math.PI * 2)) / p);
  }
}

// Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function

function steps(steps) {
  if ( steps === void 0 ) steps = 10;

  return function (t) { return Math.round(t * steps) * (1 / steps); };
}

// BezierEasing https://github.com/gre/bezier-easing

var bezier = (function () {

  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1 }
  function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1 }
  function C(aA1)      { return 3.0 * aA1 }

  function calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT }
  function getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1) }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX, currentT, i = 0;
    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) { aB = currentT; } else { aA = currentT; }
    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);
    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < 4; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0.0) { return aGuessT; }
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }

  function bezier(mX1, mY1, mX2, mY2) {

    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) { return; }
    var sampleValues = new Float32Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {

      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;

      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= 0.001) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }

    }

    return function (x) {
      if (mX1 === mY1 && mX2 === mY2) { return x; }
      if (x === 0 || x === 1) { return x; }
      return calcBezier(getTForX(x), mY1, mY2);
    }

  }

  return bezier;

})();

var penner = (function () {

  var names = ['Quad', 'Cubic', 'Quart', 'Quint', 'Sine', 'Expo', 'Circ', 'Back', 'Elastic'];

  // Approximated Penner equations http://matthewlein.com/ceaser/

  var curves = {
    In: [
      [0.550, 0.085, 0.680, 0.530], /* inQuad */
      [0.550, 0.055, 0.675, 0.190], /* inCubic */
      [0.895, 0.030, 0.685, 0.220], /* inQuart */
      [0.755, 0.050, 0.855, 0.060], /* inQuint */
      [0.470, 0.000, 0.745, 0.715], /* inSine */
      [0.950, 0.050, 0.795, 0.035], /* inExpo */
      [0.600, 0.040, 0.980, 0.335], /* inCirc */
      [0.600,-0.280, 0.735, 0.045], /* inBack */
      elastic /* inElastic */
    ],
    Out: [
      [0.250, 0.460, 0.450, 0.940], /* outQuad */
      [0.215, 0.610, 0.355, 1.000], /* outCubic */
      [0.165, 0.840, 0.440, 1.000], /* outQuart */
      [0.230, 1.000, 0.320, 1.000], /* outQuint */
      [0.390, 0.575, 0.565, 1.000], /* outSine */
      [0.190, 1.000, 0.220, 1.000], /* outExpo */
      [0.075, 0.820, 0.165, 1.000], /* outCirc */
      [0.175, 0.885, 0.320, 1.275], /* outBack */
      function (a, p) { return function (t) { return 1 - elastic(a, p)(1 - t); }; } /* outElastic */
    ],
    InOut: [
      [0.455, 0.030, 0.515, 0.955], /* inOutQuad */
      [0.645, 0.045, 0.355, 1.000], /* inOutCubic */
      [0.770, 0.000, 0.175, 1.000], /* inOutQuart */
      [0.860, 0.000, 0.070, 1.000], /* inOutQuint */
      [0.445, 0.050, 0.550, 0.950], /* inOutSine */
      [1.000, 0.000, 0.000, 1.000], /* inOutExpo */
      [0.785, 0.135, 0.150, 0.860], /* inOutCirc */
      [0.680,-0.550, 0.265, 1.550], /* inOutBack */
      function (a, p) { return function (t) { return t < .5 ? elastic(a, p)(t * 2) / 2 : 1 - elastic(a, p)(t * -2 + 2) / 2; }; } /* inOutElastic */
    ]
  };

  var eases = { 
    linear: [0.250, 0.250, 0.750, 0.750]
  };

  var loop = function ( coords ) {
    curves[coords].forEach(function (ease, i) {
      eases['ease'+coords+names[i]] = ease;
    });
  };

  for (var coords in curves) loop( coords );

  return eases;

})();

function parseEasings(easing, duration) {
  if (is.fnc(easing)) { return easing; }
  var name = easing.split('(')[0];
  var ease = penner[name];
  var args = parseEasingParameters(easing);
  switch (name) {
    case 'spring' : return spring(easing, duration);
    case 'cubicBezier' : return applyArguments(bezier, args);
    case 'steps' : return applyArguments(steps, args);
    default : return is.fnc(ease) ? applyArguments(ease, args) : applyArguments(bezier, ease);
  }
}

// Strings

function selectString(str) {
  try {
    var nodes = document.querySelectorAll(str);
    return nodes;
  } catch(e) {
    return;
  }
}

// Arrays

function filterArray(arr, callback) {
  var len = arr.length;
  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
  var result = [];
  for (var i = 0; i < len; i++) {
    if (i in arr) {
      var val = arr[i];
      if (callback.call(thisArg, val, i, arr)) {
        result.push(val);
      }
    }
  }
  return result;
}

function flattenArray(arr) {
  return arr.reduce(function (a, b) { return a.concat(is.arr(b) ? flattenArray(b) : b); }, []);
}

function toArray(o) {
  if (is.arr(o)) { return o; }
  if (is.str(o)) { o = selectString(o) || o; }
  if (o instanceof NodeList || o instanceof HTMLCollection) { return [].slice.call(o); }
  return [o];
}

function arrayContains(arr, val) {
  return arr.some(function (a) { return a === val; });
}

// Objects

function cloneObject(o) {
  var clone = {};
  for (var p in o) { clone[p] = o[p]; }
  return clone;
}

function replaceObjectProps(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o1) { o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p]; }
  return o;
}

function mergeObjects(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o2) { o[p] = is.und(o1[p]) ? o2[p] : o1[p]; }
  return o;
}

// Colors

function rgbToRgba(rgbValue) {
  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
  return rgb ? ("rgba(" + (rgb[1]) + ",1)") : rgbValue;
}

function hexToRgba(hexValue) {
  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var hex = hexValue.replace(rgx, function (m, r, g, b) { return r + r + g + g + b + b; } );
  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  var r = parseInt(rgb[1], 16);
  var g = parseInt(rgb[2], 16);
  var b = parseInt(rgb[3], 16);
  return ("rgba(" + r + "," + g + "," + b + ",1)");
}

function hslToRgba(hslValue) {
  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
  var h = parseInt(hsl[1], 10) / 360;
  var s = parseInt(hsl[2], 10) / 100;
  var l = parseInt(hsl[3], 10) / 100;
  var a = hsl[4] || 1;
  function hue2rgb(p, q, t) {
    if (t < 0) { t += 1; }
    if (t > 1) { t -= 1; }
    if (t < 1/6) { return p + (q - p) * 6 * t; }
    if (t < 1/2) { return q; }
    if (t < 2/3) { return p + (q - p) * (2/3 - t) * 6; }
    return p;
  }
  var r, g, b;
  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return ("rgba(" + (r * 255) + "," + (g * 255) + "," + (b * 255) + "," + a + ")");
}

function colorToRgb(val) {
  if (is.rgb(val)) { return rgbToRgba(val); }
  if (is.hex(val)) { return hexToRgba(val); }
  if (is.hsl(val)) { return hslToRgba(val); }
}

// Units

function getUnit(val) {
  var split = /([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
  if (split) { return split[2]; }
}

function getTransformUnit(propName) {
  if (stringContains(propName, 'translate') || propName === 'perspective') { return 'px'; }
  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) { return 'deg'; }
}

// Values

function getFunctionValue(val, animatable) {
  if (!is.fnc(val)) { return val; }
  return val(animatable.target, animatable.id, animatable.total);
}

function getAttribute(el, prop) {
  return el.getAttribute(prop);
}

function convertPxToUnit(el, value, unit) {
  var valueUnit = getUnit(value);
  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) { return value; }
  var cached = cache.CSS[value + unit];
  if (!is.und(cached)) { return cached; }
  var baseline = 100;
  var tempEl = document.createElement(el.tagName);
  var parentEl = (el.parentNode && (el.parentNode !== document)) ? el.parentNode : document.body;
  parentEl.appendChild(tempEl);
  tempEl.style.position = 'absolute';
  tempEl.style.width = baseline + unit;
  var factor = baseline / tempEl.offsetWidth;
  parentEl.removeChild(tempEl);
  var convertedUnit = factor * parseFloat(value);
  cache.CSS[value + unit] = convertedUnit;
  return convertedUnit;
}

function getCSSValue(el, prop, unit) {
  if (prop in el.style) {
    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
    return unit ? convertPxToUnit(el, value, unit) : value;
  }
}

function getAnimationType(el, prop) {
  if (is.dom(el) && !is.inp(el) && (getAttribute(el, prop) || (is.svg(el) && el[prop]))) { return 'attribute'; }
  if (is.dom(el) && arrayContains(validTransforms, prop)) { return 'transform'; }
  if (is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) { return 'css'; }
  if (el[prop] != null) { return 'object'; }
}

function getElementTransforms(el) {
  if (!is.dom(el)) { return; }
  var str = el.style.transform || '';
  var reg  = /(\w+)\(([^)]*)\)/g;
  var transforms = new Map();
  var m; while (m = reg.exec(str)) { transforms.set(m[1], m[2]); }
  return transforms;
}

function getTransformValue(el, propName, animatable, unit) {
  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
  var value = getElementTransforms(el).get(propName) || defaultVal;
  if (animatable) {
    animatable.transforms.list.set(propName, value);
    animatable.transforms['last'] = propName;
  }
  return unit ? convertPxToUnit(el, value, unit) : value;
}

function getOriginalTargetValue(target, propName, unit, animatable) {
  switch (getAnimationType(target, propName)) {
    case 'transform': return getTransformValue(target, propName, animatable, unit);
    case 'css': return getCSSValue(target, propName, unit);
    case 'attribute': return getAttribute(target, propName);
    default: return target[propName] || 0;
  }
}

function getRelativeValue(to, from) {
  var operator = /^(\*=|\+=|-=)/.exec(to);
  if (!operator) { return to; }
  var u = getUnit(to) || 0;
  var x = parseFloat(from);
  var y = parseFloat(to.replace(operator[0], ''));
  switch (operator[0][0]) {
    case '+': return x + y + u;
    case '-': return x - y + u;
    case '*': return x * y + u;
  }
}

function validateValue(val, unit) {
  if (is.col(val)) { return colorToRgb(val); }
  var originalUnit = getUnit(val);
  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
  return unit && !/\s/g.test(val) ? unitLess + unit : unitLess;
}

// getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getCircleLength(el) {
  return Math.PI * 2 * getAttribute(el, 'r');
}

function getRectLength(el) {
  return (getAttribute(el, 'width') * 2) + (getAttribute(el, 'height') * 2);
}

function getLineLength(el) {
  return getDistance(
    {x: getAttribute(el, 'x1'), y: getAttribute(el, 'y1')}, 
    {x: getAttribute(el, 'x2'), y: getAttribute(el, 'y2')}
  );
}

function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos;
  for (var i = 0 ; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);
    if (i > 0) { totalLength += getDistance(previousPos, currentPos); }
    previousPos = currentPos;
  }
  return totalLength;
}

function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
}

// Path animation

function getTotalLength(el) {
  if (el.getTotalLength) { return el.getTotalLength(); }
  switch(el.tagName.toLowerCase()) {
    case 'circle': return getCircleLength(el);
    case 'rect': return getRectLength(el);
    case 'line': return getLineLength(el);
    case 'polyline': return getPolylineLength(el);
    case 'polygon': return getPolygonLength(el);
  }
}

function setDashoffset(el) {
  var pathLength = getTotalLength(el);
  el.setAttribute('stroke-dasharray', pathLength);
  return pathLength;
}

// Motion path

function getParentSvgEl(el) {
  var parentEl = el.parentNode;
  while (is.svg(parentEl)) {
    parentEl = parentEl.parentNode;
    if (!is.svg(parentEl.parentNode)) { break; }
  }
  return parentEl;
}

function getParentSvg(pathEl, svgData) {
  var svg = svgData || {};
  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
  var rect = parentSvgEl.getBoundingClientRect();
  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
  var width = rect.width;
  var height = rect.height;
  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
  return {
    el: parentSvgEl,
    viewBox: viewBox,
    x: viewBox[0] / 1,
    y: viewBox[1] / 1,
    w: width / viewBox[2],
    h: height / viewBox[3]
  }
}

function getPath(path, percent) {
  var pathEl = is.str(path) ? selectString(path)[0] : path;
  var p = percent || 100;
  return function(property) {
    return {
      property: property,
      el: pathEl,
      svg: getParentSvg(pathEl),
      totalLength: getTotalLength(pathEl) * (p / 100)
    }
  }
}

function getPathProgress(path, progress) {
  function point(offset) {
    if ( offset === void 0 ) offset = 0;

    var l = progress + offset >= 1 ? progress + offset : 0;
    return path.el.getPointAtLength(l);
  }
  var svg = getParentSvg(path.el, path.svg);
  var p = point();
  var p0 = point(-1);
  var p1 = point(+1);
  switch (path.property) {
    case 'x': return (p.x - svg.x) * svg.w;
    case 'y': return (p.y - svg.y) * svg.h;
    case 'angle': return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
  }
}

// Decompose value

function decomposeValue(val, unit) {
  var rgx = /-?\d*\.?\d+/g;
  var value = validateValue((is.pth(val) ? val.totalLength : val), unit) + '';
  return {
    original: value,
    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
    strings: (is.str(val) || unit) ? value.split(rgx) : []
  }
}

// Animatables

function parseTargets(targets) {
  var targetsArray = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets))) : [];
  return filterArray(targetsArray, function (item, pos, self) { return self.indexOf(item) === pos; });
}

function getAnimatables(targets) {
  var parsed = parseTargets(targets);
  return parsed.map(function (t, i) {
    return {target: t, id: i, total: parsed.length, transforms: { list: getElementTransforms(t) } };
  });
}

// Properties

function normalizePropertyTweens(prop, tweenSettings) {
  var settings = cloneObject(tweenSettings);
  // Override duration if easing is a spring
  if (/^spring/.test(settings.easing)) { settings.duration = spring(settings.easing); }
  if (is.arr(prop)) {
    var l = prop.length;
    var isFromTo = (l === 2 && !is.obj(prop[0]));
    if (!isFromTo) {
      // Duration divided by the number of tweens
      if (!is.fnc(tweenSettings.duration)) { settings.duration = tweenSettings.duration / l; }
    } else {
      // Transform [from, to] values shorthand to a valid tween value
      prop = {value: prop};
    }
  }
  var propArray = is.arr(prop) ? prop : [prop];
  return propArray.map(function (v, i) {
    var obj = (is.obj(v) && !is.pth(v)) ? v : {value: v};
    // Default delay value should only be applied to the first tween
    if (is.und(obj.delay)) { obj.delay = !i ? tweenSettings.delay : 0; }
    // Default endDelay value should only be applied to the last tween
    if (is.und(obj.endDelay)) { obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0; }
    return obj;
  }).map(function (k) { return mergeObjects(k, settings); });
}


function flattenKeyframes(keyframes) {
  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) { return Object.keys(key); })), function (p) { return is.key(p); })
  .reduce(function (a,b) { if (a.indexOf(b) < 0) { a.push(b); } return a; }, []);
  var properties = {};
  var loop = function ( i ) {
    var propName = propertyNames[i];
    properties[propName] = keyframes.map(function (key) {
      var newKey = {};
      for (var p in key) {
        if (is.key(p)) {
          if (p == propName) { newKey.value = key[p]; }
        } else {
          newKey[p] = key[p];
        }
      }
      return newKey;
    });
  };

  for (var i = 0; i < propertyNames.length; i++) loop( i );
  return properties;
}

function getProperties(tweenSettings, params) {
  var properties = [];
  var keyframes = params.keyframes;
  if (keyframes) { params = mergeObjects(flattenKeyframes(keyframes), params); }
  for (var p in params) {
    if (is.key(p)) {
      properties.push({
        name: p,
        tweens: normalizePropertyTweens(params[p], tweenSettings)
      });
    }
  }
  return properties;
}

// Tweens

function normalizeTweenValues(tween, animatable) {
  var t = {};
  for (var p in tween) {
    var value = getFunctionValue(tween[p], animatable);
    if (is.arr(value)) {
      value = value.map(function (v) { return getFunctionValue(v, animatable); });
      if (value.length === 1) { value = value[0]; }
    }
    t[p] = value;
  }
  t.duration = parseFloat(t.duration);
  t.delay = parseFloat(t.delay);
  return t;
}

function normalizeTweens(prop, animatable) {
  var previousTween;
  return prop.tweens.map(function (t) {
    var tween = normalizeTweenValues(t, animatable);
    var tweenValue = tween.value;
    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
    var toUnit = getUnit(to);
    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
    var previousValue = previousTween ? previousTween.to.original : originalValue;
    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
    var fromUnit = getUnit(from) || getUnit(originalValue);
    var unit = toUnit || fromUnit;
    if (is.und(to)) { to = previousValue; }
    tween.from = decomposeValue(from, unit);
    tween.to = decomposeValue(getRelativeValue(to, from), unit);
    tween.start = previousTween ? previousTween.end : 0;
    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
    tween.easing = parseEasings(tween.easing, tween.duration);
    tween.isPath = is.pth(tweenValue);
    tween.isColor = is.col(tween.from.original);
    if (tween.isColor) { tween.round = 1; }
    previousTween = tween;
    return tween;
  });
}

// Tween progress

var setProgressValue = {
  css: function (t, p, v) { return t.style[p] = v; },
  attribute: function (t, p, v) { return t.setAttribute(p, v); },
  object: function (t, p, v) { return t[p] = v; },
  transform: function (t, p, v, transforms, manual) {
    transforms.list.set(p, v);
    if (p === transforms.last || manual) {
      var str = '';
      transforms.list.forEach(function (value, prop) { str += prop + "(" + value + ") "; });
      t.style.transform = str;
    }
  }
};

// Set Value helper

function setTargetsValue(targets, properties) {
  var animatables = getAnimatables(targets);
  animatables.forEach(function (animatable) {
    for (var property in properties) {
      var value = getFunctionValue(properties[property], animatable);
      var target = animatable.target;
      var valueUnit = getUnit(value);
      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
      var unit = valueUnit || getUnit(originalValue);
      var to = getRelativeValue(validateValue(value, unit), originalValue);
      var animType = getAnimationType(target, property);
      setProgressValue[animType](target, property, to, animatable.transforms, true);
    }
  });
}

// Animations

function createAnimation(animatable, prop) {
  var animType = getAnimationType(animatable.target, prop.name);
  if (animType) {
    var tweens = normalizeTweens(prop, animatable);
    var lastTween = tweens[tweens.length - 1];
    return {
      type: animType,
      property: prop.name,
      animatable: animatable,
      tweens: tweens,
      duration: lastTween.end,
      delay: tweens[0].delay,
      endDelay: lastTween.endDelay
    }
  }
}

function getAnimations(animatables, properties) {
  return filterArray(flattenArray(animatables.map(function (animatable) {
    return properties.map(function (prop) {
      return createAnimation(animatable, prop);
    });
  })), function (a) { return !is.und(a); });
}

// Create Instance

function getInstanceTimings(animations, tweenSettings) {
  var animLength = animations.length;
  var getTlOffset = function (anim) { return anim.timelineOffset ? anim.timelineOffset : 0; };
  var timings = {};
  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration; })) : tweenSettings.duration;
  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.delay; })) : tweenSettings.delay;
  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration - anim.endDelay; })) : tweenSettings.endDelay;
  return timings;
}

var instanceID = 0;

function createNewInstance(params) {
  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
  var properties = getProperties(tweenSettings, params);
  var animatables = getAnimatables(params.targets);
  var animations = getAnimations(animatables, properties);
  var timings = getInstanceTimings(animations, tweenSettings);
  var id = instanceID;
  instanceID++;
  return mergeObjects(instanceSettings, {
    id: id,
    children: [],
    animatables: animatables,
    animations: animations,
    duration: timings.duration,
    delay: timings.delay,
    endDelay: timings.endDelay
  });
}

// Core

var activeInstances = [];
var pausedInstances = [];
var raf;

var engine = (function () {
  function play() { 
    raf = requestAnimationFrame(step);
  }
  function step(t) {
    var activeInstancesLength = activeInstances.length;
    if (activeInstancesLength) {
      var i = 0;
      while (i < activeInstancesLength) {
        var activeInstance = activeInstances[i];
        if (!activeInstance.paused) {
          activeInstance.tick(t);
        } else {
          var instanceIndex = activeInstances.indexOf(activeInstance);
          if (instanceIndex > -1) {
            activeInstances.splice(instanceIndex, 1);
            activeInstancesLength = activeInstances.length;
          }
        }
        i++;
      }
      play();
    } else {
      raf = cancelAnimationFrame(raf);
    }
  }
  return play;
})();

function handleVisibilityChange() {
  if (document.hidden) {
    activeInstances.forEach(function (ins) { return ins.pause(); });
    pausedInstances = activeInstances.slice(0);
    activeInstances = [];
  } else {
    pausedInstances.forEach(function (ins) { return ins.play(); });
  }
}

if (typeof document !== 'undefined') {
  document.addEventListener('visibilitychange', handleVisibilityChange);
}

// Public Instance

function anime(params) {
  if ( params === void 0 ) params = {};


  var startTime = 0, lastTime = 0, now = 0;
  var children, childrenLength = 0;
  var resolve = null;

  function makePromise(instance) {
    var promise = window.Promise && new Promise(function (_resolve) { return resolve = _resolve; });
    instance.finished = promise;
    return promise;
  }

  var instance = createNewInstance(params);
  var promise = makePromise(instance);

  function toggleInstanceDirection() {
    var direction = instance.direction;
    if (direction !== 'alternate') {
      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
    }
    instance.reversed = !instance.reversed;
    children.forEach(function (child) { return child.reversed = instance.reversed; });
  }

  function adjustTime(time) {
    return instance.reversed ? instance.duration - time : time;
  }

  function resetTime() {
    startTime = 0;
    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
  }

  function seekCild(time, child) {
    if (child) { child.seek(time - child.timelineOffset); }
  }

  function syncInstanceChildren(time) {
    if (!instance.reversePlayback) {
      for (var i = 0; i < childrenLength; i++) { seekCild(time, children[i]); }
    } else {
      for (var i$1 = childrenLength; i$1--;) { seekCild(time, children[i$1]); }
    }
  }

  function setAnimationsProgress(insTime) {
    var i = 0;
    var animations = instance.animations;
    var animationsLength = animations.length;
    while (i < animationsLength) {
      var anim = animations[i];
      var animatable = anim.animatable;
      var tweens = anim.tweens;
      var tweenLength = tweens.length - 1;
      var tween = tweens[tweenLength];
      // Only check for keyframes if there is more than one tween
      if (tweenLength) { tween = filterArray(tweens, function (t) { return (insTime < t.end); })[0] || tween; }
      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
      var strings = tween.to.strings;
      var round = tween.round;
      var numbers = [];
      var toNumbersLength = tween.to.numbers.length;
      var progress = (void 0);
      for (var n = 0; n < toNumbersLength; n++) {
        var value = (void 0);
        var toNumber = tween.to.numbers[n];
        var fromNumber = tween.from.numbers[n] || 0;
        if (!tween.isPath) {
          value = fromNumber + (eased * (toNumber - fromNumber));
        } else {
          value = getPathProgress(tween.value, eased * toNumber);
        }
        if (round) {
          if (!(tween.isColor && n > 2)) {
            value = Math.round(value * round) / round;
          }
        }
        numbers.push(value);
      }
      // Manual Array.reduce for better performances
      var stringsLength = strings.length;
      if (!stringsLength) {
        progress = numbers[0];
      } else {
        progress = strings[0];
        for (var s = 0; s < stringsLength; s++) {
          var a = strings[s];
          var b = strings[s + 1];
          var n$1 = numbers[s];
          if (!isNaN(n$1)) {
            if (!b) {
              progress += n$1 + ' ';
            } else {
              progress += n$1 + b;
            }
          }
        }
      }
      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
      anim.currentValue = progress;
      i++;
    }
  }

  function setCallback(cb) {
    if (instance[cb] && !instance.passThrough) { instance[cb](instance); }
  }

  function countIteration() {
    if (instance.remaining && instance.remaining !== true) {
      instance.remaining--;
    }
  }

  function setInstanceProgress(engineTime) {
    var insDuration = instance.duration;
    var insDelay = instance.delay;
    var insEndDelay = insDuration - instance.endDelay;
    var insTime = adjustTime(engineTime);
    instance.progress = minMax((insTime / insDuration) * 100, 0, 100);
    instance.reversePlayback = insTime < instance.currentTime;
    if (children) { syncInstanceChildren(insTime); }
    if (!instance.began && instance.currentTime > 0) {
      instance.began = true;
      setCallback('begin');
      setCallback('loopBegin');
    }
    if (insTime <= insDelay && instance.currentTime !== 0) {
      setAnimationsProgress(0);
    }
    if ((insTime >= insEndDelay && instance.currentTime !== insDuration) || !insDuration) {
      setAnimationsProgress(insDuration);
    }
    if (insTime > insDelay && insTime < insEndDelay) {
      if (!instance.changeBegan) {
        instance.changeBegan = true;
        instance.changeCompleted = false;
        setCallback('changeBegin');
      }
      setCallback('change');
      setAnimationsProgress(insTime);
    } else {
      if (instance.changeBegan) {
        instance.changeCompleted = true;
        instance.changeBegan = false;
        setCallback('changeComplete');
      }
    }
    instance.currentTime = minMax(insTime, 0, insDuration);
    if (instance.began) { setCallback('update'); }
    if (engineTime >= insDuration) {
      lastTime = 0;
      countIteration();
      if (instance.remaining) {
        startTime = now;
        setCallback('loopComplete');
        setCallback('loopBegin');
        if (instance.direction === 'alternate') { toggleInstanceDirection(); }
      } else {
        instance.paused = true;
        if (!instance.completed) {
          instance.completed = true;
          setCallback('loopComplete');
          setCallback('complete');
          if (!instance.passThrough && 'Promise' in window) {
            resolve();
            promise = makePromise(instance);
          }
        }
      }
    }
  }

  instance.reset = function() {
    var direction = instance.direction;
    instance.passThrough = false;
    instance.currentTime = 0;
    instance.progress = 0;
    instance.paused = true;
    instance.began = false;
    instance.changeBegan = false;
    instance.completed = false;
    instance.changeCompleted = false;
    instance.reversePlayback = false;
    instance.reversed = direction === 'reverse';
    instance.remaining = instance.loop;
    children = instance.children;
    childrenLength = children.length;
    for (var i = childrenLength; i--;) { instance.children[i].reset(); }
    if (instance.reversed && instance.loop !== true || (direction === 'alternate' && instance.loop === 1)) { instance.remaining++; }
    setAnimationsProgress(0);
  };

  // Set Value helper

  instance.set = function(targets, properties) {
    setTargetsValue(targets, properties);
    return instance;
  };

  instance.tick = function(t) {
    now = t;
    if (!startTime) { startTime = now; }
    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
  };

  instance.seek = function(time) {
    setInstanceProgress(adjustTime(time));
  };

  instance.pause = function() {
    instance.paused = true;
    resetTime();
  };

  instance.play = function() {
    if (!instance.paused) { return; }
    if (instance.completed) { instance.reset(); }
    instance.paused = false;
    activeInstances.push(instance);
    resetTime();
    if (!raf) { engine(); }
  };

  instance.reverse = function() {
    toggleInstanceDirection();
    resetTime();
  };

  instance.restart = function() {
    instance.reset();
    instance.play();
  };

  instance.reset();

  if (instance.autoplay) { instance.play(); }

  return instance;

}

// Remove targets from animation

function removeTargetsFromAnimations(targetsArray, animations) {
  for (var a = animations.length; a--;) {
    if (arrayContains(targetsArray, animations[a].animatable.target)) {
      animations.splice(a, 1);
    }
  }
}

function removeTargets(targets) {
  var targetsArray = parseTargets(targets);
  for (var i = activeInstances.length; i--;) {
    var instance = activeInstances[i];
    var animations = instance.animations;
    var children = instance.children;
    removeTargetsFromAnimations(targetsArray, animations);
    for (var c = children.length; c--;) {
      var child = children[c];
      var childAnimations = child.animations;
      removeTargetsFromAnimations(targetsArray, childAnimations);
      if (!childAnimations.length && !child.children.length) { children.splice(c, 1); }
    }
    if (!animations.length && !children.length) { instance.pause(); }
  }
}

// Stagger helpers

function stagger(val, params) {
  if ( params === void 0 ) params = {};

  var direction = params.direction || 'normal';
  var easing = params.easing ? parseEasings(params.easing) : null;
  var grid = params.grid;
  var axis = params.axis;
  var fromIndex = params.from || 0;
  var fromFirst = fromIndex === 'first';
  var fromCenter = fromIndex === 'center';
  var fromLast = fromIndex === 'last';
  var isRange = is.arr(val);
  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
  var val2 = isRange ? parseFloat(val[1]) : 0;
  var unit = getUnit(isRange ? val[1] : val) || 0;
  var start = params.start || 0 + (isRange ? val1 : 0);
  var values = [];
  var maxValue = 0;
  return function (el, i, t) {
    if (fromFirst) { fromIndex = 0; }
    if (fromCenter) { fromIndex = (t - 1) / 2; }
    if (fromLast) { fromIndex = t - 1; }
    if (!values.length) {
      for (var index = 0; index < t; index++) {
        if (!grid) {
          values.push(Math.abs(fromIndex - index));
        } else {
          var fromX = !fromCenter ? fromIndex%grid[0] : (grid[0]-1)/2;
          var fromY = !fromCenter ? Math.floor(fromIndex/grid[0]) : (grid[1]-1)/2;
          var toX = index%grid[0];
          var toY = Math.floor(index/grid[0]);
          var distanceX = fromX - toX;
          var distanceY = fromY - toY;
          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
          if (axis === 'x') { value = -distanceX; }
          if (axis === 'y') { value = -distanceY; }
          values.push(value);
        }
        maxValue = Math.max.apply(Math, values);
      }
      if (easing) { values = values.map(function (val) { return easing(val / maxValue) * maxValue; }); }
      if (direction === 'reverse') { values = values.map(function (val) { return axis ? (val < 0) ? val * -1 : -val : Math.abs(maxValue - val); }); }
    }
    var spacing = isRange ? (val2 - val1) / maxValue : val1;
    return start + (spacing * (Math.round(values[i] * 100) / 100)) + unit;
  }
}

// Timeline

function timeline(params) {
  if ( params === void 0 ) params = {};

  var tl = anime(params);
  tl.duration = 0;
  tl.add = function(instanceParams, timelineOffset) {
    var tlIndex = activeInstances.indexOf(tl);
    var children = tl.children;
    if (tlIndex > -1) { activeInstances.splice(tlIndex, 1); }
    function passThrough(ins) { ins.passThrough = true; }
    for (var i = 0; i < children.length; i++) { passThrough(children[i]); }
    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
    insParams.targets = insParams.targets || params.targets;
    var tlDuration = tl.duration;
    insParams.autoplay = false;
    insParams.direction = tl.direction;
    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
    passThrough(tl);
    tl.seek(insParams.timelineOffset);
    var ins = anime(insParams);
    passThrough(ins);
    children.push(ins);
    var timings = getInstanceTimings(children, params);
    tl.delay = timings.delay;
    tl.endDelay = timings.endDelay;
    tl.duration = timings.duration;
    tl.seek(0);
    tl.reset();
    if (tl.autoplay) { tl.play(); }
    return tl;
  };
  return tl;
}

anime.version = '3.0.1';
anime.speed = 1;
anime.running = activeInstances;
anime.remove = removeTargets;
anime.get = getOriginalTargetValue;
anime.set = setTargetsValue;
anime.convertPx = convertPxToUnit;
anime.path = getPath;
anime.setDashoffset = setDashoffset;
anime.stagger = stagger;
anime.timeline = timeline;
anime.easing = parseEasings;
anime.penner = penner;
anime.random = function (min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; };

/* harmony default export */ __webpack_exports__["default"] = (anime);


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/autolinker/0.15.3/node_modules/autolinker/dist/Autolinker.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/autolinker/0.15.3/node_modules/autolinker/dist/Autolinker.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
  if (true) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return (root['Autolinker'] = factory());
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(this, function () {

/*!
 * Autolinker.js
 * 0.15.3
 *
 * Copyright(c) 2015 Gregory Jacobs <greg@greg-jacobs.com>
 * MIT Licensed. http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/gregjacobs/Autolinker.js
 */
/**
 * @class Autolinker
 * @extends Object
 * 
 * Utility class used to process a given string of text, and wrap the URLs, email addresses, and Twitter handles in 
 * the appropriate anchor (&lt;a&gt;) tags to turn them into links.
 * 
 * Any of the configuration options may be provided in an Object (map) provided to the Autolinker constructor, which
 * will configure how the {@link #link link()} method will process the links.
 * 
 * For example:
 * 
 *     var autolinker = new Autolinker( {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *     
 *     var html = autolinker.link( "Joe went to www.yahoo.com" );
 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
 * 
 * 
 * The {@link #static-link static link()} method may also be used to inline options into a single call, which may
 * be more convenient for one-off uses. For example:
 * 
 *     var html = Autolinker.link( "Joe went to www.yahoo.com", {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
 * 
 * 
 * ## Custom Replacements of Links
 * 
 * If the configuration options do not provide enough flexibility, a {@link #replaceFn} may be provided to fully customize
 * the output of Autolinker. This function is called once for each URL/Email/Twitter handle match that is encountered.
 * 
 * For example:
 * 
 *     var input = "...";  // string with URLs, Email Addresses, and Twitter Handles
 *     
 *     var linkedText = Autolinker.link( input, {
 *         replaceFn : function( autolinker, match ) {
 *             console.log( "href = ", match.getAnchorHref() );
 *             console.log( "text = ", match.getAnchorText() );
 *         
 *             switch( match.getType() ) {
 *                 case 'url' : 
 *                     console.log( "url: ", match.getUrl() );
 *                     
 *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {
 *                         var tag = autolinker.getTagBuilder().build( match );  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes
 *                         tag.setAttr( 'rel', 'nofollow' );
 *                         tag.addClass( 'external-link' );
 *                         
 *                         return tag;
 *                         
 *                     } else {
 *                         return true;  // let Autolinker perform its normal anchor tag replacement
 *                     }
 *                     
 *                 case 'email' :
 *                     var email = match.getEmail();
 *                     console.log( "email: ", email );
 *                     
 *                     if( email === "my@own.address" ) {
 *                         return false;  // don't auto-link this particular email address; leave as-is
 *                     } else {
 *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)
 *                     }
 *                 
 *                 case 'twitter' :
 *                     var twitterHandle = match.getTwitterHandle();
 *                     console.log( twitterHandle );
 *                     
 *                     return '<a href="http://newplace.to.link.twitter.handles.to/">' + twitterHandle + '</a>';
 *             }
 *         }
 *     } );
 * 
 * 
 * The function may return the following values:
 * 
 * - `true` (Boolean): Allow Autolinker to replace the match as it normally would.
 * - `false` (Boolean): Do not replace the current match at all - leave as-is.
 * - Any String: If a string is returned from the function, the string will be used directly as the replacement HTML for
 *   the match.
 * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify an HTML tag before writing out its HTML text.
 * 
 * @constructor
 * @param {Object} [config] The configuration options for the Autolinker instance, specified in an Object (map).
 */
var Autolinker = function( cfg ) {
	Autolinker.Util.assign( this, cfg );  // assign the properties of `cfg` onto the Autolinker instance. Prototype properties will be used for missing configs.
};


Autolinker.prototype = {
	constructor : Autolinker,  // fix constructor property
	
	/**
	 * @cfg {Boolean} urls
	 * 
	 * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.
	 */
	urls : true,
	
	/**
	 * @cfg {Boolean} email
	 * 
	 * `true` if email addresses should be automatically linked, `false` if they should not be.
	 */
	email : true,
	
	/**
	 * @cfg {Boolean} twitter
	 * 
	 * `true` if Twitter handles ("@example") should be automatically linked, `false` if they should not be.
	 */
	twitter : true,
	
	/**
	 * @cfg {Boolean} newWindow
	 * 
	 * `true` if the links should open in a new window, `false` otherwise.
	 */
	newWindow : true,
	
	/**
	 * @cfg {Boolean} stripPrefix
	 * 
	 * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped from the beginning of URL links' text, 
	 * `false` otherwise.
	 */
	stripPrefix : true,
	
	/**
	 * @cfg {Number} truncate
	 * 
	 * A number for how many characters long URLs/emails/twitter handles should be truncated to inside the text of 
	 * a link. If the URL/email/twitter is over this number of characters, it will be truncated to this length by 
	 * adding a two period ellipsis ('..') to the end of the string.
	 * 
	 * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file' truncated to 25 characters might look
	 * something like this: 'yahoo.com/some/long/pat..'
	 */
	truncate : undefined,
	
	/**
	 * @cfg {String} className
	 * 
	 * A CSS class name to add to the generated links. This class will be added to all links, as well as this class
	 * plus url/email/twitter suffixes for styling url/email/twitter links differently.
	 * 
	 * For example, if this config is provided as "myLink", then:
	 * 
	 * - URL links will have the CSS classes: "myLink myLink-url"
	 * - Email links will have the CSS classes: "myLink myLink-email", and
	 * - Twitter links will have the CSS classes: "myLink myLink-twitter"
	 */
	className : "",
	
	/**
	 * @cfg {Function} replaceFn
	 * 
	 * A function to individually process each URL/Email/Twitter match found in the input string.
	 * 
	 * See the class's description for usage.
	 * 
	 * This function is called with the following parameters:
	 * 
	 * @cfg {Autolinker} replaceFn.autolinker The Autolinker instance, which may be used to retrieve child objects from (such
	 *   as the instance's {@link #getTagBuilder tag builder}).
	 * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which can be used to retrieve information about the
	 *   {@link Autolinker.match.Url URL}/{@link Autolinker.match.Email email}/{@link Autolinker.match.Twitter Twitter}
	 *   match that the `replaceFn` is currently processing.
	 */
	
	
	/**
	 * @private
	 * @property {Autolinker.htmlParser.HtmlParser} htmlParser
	 * 
	 * The HtmlParser instance used to skip over HTML tags, while finding text nodes to process. This is lazily instantiated
	 * in the {@link #getHtmlParser} method.
	 */
	htmlParser : undefined,
	
	/**
	 * @private
	 * @property {Autolinker.matchParser.MatchParser} matchParser
	 * 
	 * The MatchParser instance used to find URL/email/Twitter matches in the text nodes of an input string passed to
	 * {@link #link}. This is lazily instantiated in the {@link #getMatchParser} method.
	 */
	matchParser : undefined,
	
	/**
	 * @private
	 * @property {Autolinker.AnchorTagBuilder} tagBuilder
	 * 
	 * The AnchorTagBuilder instance used to build the URL/email/Twitter replacement anchor tags. This is lazily instantiated
	 * in the {@link #getTagBuilder} method.
	 */
	tagBuilder : undefined,
	
	
	/**
	 * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML. 
	 * Does not link URLs found within HTML tags.
	 * 
	 * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result
	 * will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
	 * 
	 * This method finds the text around any HTML elements in the input `textOrHtml`, which will be the text that is processed.
	 * Any original HTML elements will be left as-is, as well as the text that is already wrapped in anchor (&lt;a&gt;) tags.
	 * 
	 * @param {String} textOrHtml The HTML or text to link URLs, email addresses, and Twitter handles within (depending on if
	 *   the {@link #urls}, {@link #email}, and {@link #twitter} options are enabled).
	 * @return {String} The HTML, with URLs/emails/Twitter handles automatically linked.
	 */
	link : function( textOrHtml ) {
		var htmlParser = this.getHtmlParser(),
		    htmlNodes = htmlParser.parse( textOrHtml ),
		    anchorTagStackCount = 0,  // used to only process text around anchor tags, and any inner text/html they may have
		    resultHtml = [];
		
		for( var i = 0, len = htmlNodes.length; i < len; i++ ) {
			var node = htmlNodes[ i ],
			    nodeType = node.getType(),
			    nodeText = node.getText();
			
			if( nodeType === 'element' ) {
				// Process HTML nodes in the input `textOrHtml`
				if( node.getTagName() === 'a' ) {
					if( !node.isClosing() ) {  // it's the start <a> tag
						anchorTagStackCount++;
					} else {   // it's the end </a> tag
						anchorTagStackCount = Math.max( anchorTagStackCount - 1, 0 );  // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0
					}
				}
				resultHtml.push( nodeText );  // now add the text of the tag itself verbatim
				
			} else if( nodeType === 'entity' ) {
				resultHtml.push( nodeText );  // append HTML entity nodes (such as '&nbsp;') verbatim
				
			} else {
				// Process text nodes in the input `textOrHtml`
				if( anchorTagStackCount === 0 ) {
					// If we're not within an <a> tag, process the text node to linkify
					var linkifiedStr = this.linkifyStr( nodeText );
					resultHtml.push( linkifiedStr );
					
				} else {
					// `text` is within an <a> tag, simply append the text - we do not want to autolink anything 
					// already within an <a>...</a> tag
					resultHtml.push( nodeText );
				}
			}
		}
		
		return resultHtml.join( "" );
	},
	
	
	/**
	 * Process the text that lies in between HTML tags, performing the anchor tag replacements for matched 
	 * URLs/emails/Twitter handles, and returns the string with the replacements made. 
	 * 
	 * This method does the actual wrapping of URLs/emails/Twitter handles with anchor tags.
	 * 
	 * @private
	 * @param {String} str The string of text to auto-link.
	 * @return {String} The text with anchor tags auto-filled.
	 */
	linkifyStr : function( str ) {
		return this.getMatchParser().replace( str, this.createMatchReturnVal, this );
	},
	
	
	/**
	 * Creates the return string value for a given match in the input string, for the {@link #processTextNode} method.
	 * 
	 * This method handles the {@link #replaceFn}, if one was provided.
	 * 
	 * @private
	 * @param {Autolinker.match.Match} match The Match object that represents the match.
	 * @return {String} The string that the `match` should be replaced with. This is usually the anchor tag string, but
	 *   may be the `matchStr` itself if the match is not to be replaced.
	 */
	createMatchReturnVal : function( match ) {
		// Handle a custom `replaceFn` being provided
		var replaceFnResult;
		if( this.replaceFn ) {
			replaceFnResult = this.replaceFn.call( this, this, match );  // Autolinker instance is the context, and the first arg
		}
		
		if( typeof replaceFnResult === 'string' ) {
			return replaceFnResult;  // `replaceFn` returned a string, use that
			
		} else if( replaceFnResult === false ) {
			return match.getMatchedText();  // no replacement for the match
			
		} else if( replaceFnResult instanceof Autolinker.HtmlTag ) {
			return replaceFnResult.toString();
		
		} else {  // replaceFnResult === true, or no/unknown return value from function
			// Perform Autolinker's default anchor tag generation
			var tagBuilder = this.getTagBuilder(),
			    anchorTag = tagBuilder.build( match );  // returns an Autolinker.HtmlTag instance
			
			return anchorTag.toString();
		}
	},
	
	
	/**
	 * Lazily instantiates and returns the {@link #htmlParser} instance for this Autolinker instance.
	 * 
	 * @protected
	 * @return {Autolinker.htmlParser.HtmlParser}
	 */
	getHtmlParser : function() {
		var htmlParser = this.htmlParser;
		
		if( !htmlParser ) {
			htmlParser = this.htmlParser = new Autolinker.htmlParser.HtmlParser();
		}
		
		return htmlParser;
	},
	
	
	/**
	 * Lazily instantiates and returns the {@link #matchParser} instance for this Autolinker instance.
	 * 
	 * @protected
	 * @return {Autolinker.matchParser.MatchParser}
	 */
	getMatchParser : function() {
		var matchParser = this.matchParser;
		
		if( !matchParser ) {
			matchParser = this.matchParser = new Autolinker.matchParser.MatchParser( {
				urls : this.urls,
				email : this.email,
				twitter : this.twitter,
				stripPrefix : this.stripPrefix
			} );
		}
		
		return matchParser;
	},
	
	
	/**
	 * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it
	 * if it does not yet exist.
	 * 
	 * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that 
	 * Autolinker would normally generate, and then allow for modifications before returning it. For example:
	 * 
	 *     var html = Autolinker.link( "Test google.com", {
	 *         replaceFn : function( autolinker, match ) {
	 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance
	 *             tag.setAttr( 'rel', 'nofollow' );
	 *             
	 *             return tag;
	 *         }
	 *     } );
	 *     
	 *     // generated html:
	 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
	 * 
	 * @return {Autolinker.AnchorTagBuilder}
	 */
	getTagBuilder : function() {
		var tagBuilder = this.tagBuilder;
		
		if( !tagBuilder ) {
			tagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder( {
				newWindow   : this.newWindow,
				truncate    : this.truncate,
				className   : this.className
			} );
		}
		
		return tagBuilder;
	}

};


/**
 * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML. 
 * Does not link URLs found within HTML tags.
 * 
 * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result
 * will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
 * 
 * Example:
 * 
 *     var linkedText = Autolinker.link( "Go to google.com", { newWindow: false } );
 *     // Produces: "Go to <a href="http://google.com">google.com</a>"
 * 
 * @static
 * @param {String} textOrHtml The HTML or text to find URLs, email addresses, and Twitter handles within (depending on if
 *   the {@link #urls}, {@link #email}, and {@link #twitter} options are enabled).
 * @param {Object} [options] Any of the configuration options for the Autolinker class, specified in an Object (map).
 *   See the class description for an example call.
 * @return {String} The HTML text, with URLs automatically linked
 */
Autolinker.link = function( textOrHtml, options ) {
	var autolinker = new Autolinker( options );
	return autolinker.link( textOrHtml );
};


// Autolinker Namespaces
Autolinker.match = {};
Autolinker.htmlParser = {};
Autolinker.matchParser = {};
/*global Autolinker */
/*jshint eqnull:true, boss:true */
/**
 * @class Autolinker.Util
 * @singleton
 * 
 * A few utility methods for Autolinker.
 */
Autolinker.Util = {
	
	/**
	 * @property {Function} abstractMethod
	 * 
	 * A function object which represents an abstract method.
	 */
	abstractMethod : function() { throw "abstract"; },
	
	
	/**
	 * Assigns (shallow copies) the properties of `src` onto `dest`.
	 * 
	 * @param {Object} dest The destination object.
	 * @param {Object} src The source object.
	 * @return {Object} The destination object (`dest`)
	 */
	assign : function( dest, src ) {
		for( var prop in src ) {
			if( src.hasOwnProperty( prop ) ) {
				dest[ prop ] = src[ prop ];
			}
		}
		
		return dest;
	},
	
	
	/**
	 * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.
	 * 
	 * @param {Function} superclass The constructor function for the superclass.
	 * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the
	 *   special property `constructor`, which will be used as the new subclass's constructor function.
	 * @return {Function} The new subclass function.
	 */
	extend : function( superclass, protoProps ) {
		var superclassProto = superclass.prototype;
		
		var F = function() {};
		F.prototype = superclassProto;
		
		var subclass;
		if( protoProps.hasOwnProperty( 'constructor' ) ) {
			subclass = protoProps.constructor;
		} else {
			subclass = function() { superclassProto.constructor.apply( this, arguments ); };
		}
		
		var subclassProto = subclass.prototype = new F();  // set up prototype chain
		subclassProto.constructor = subclass;  // fix constructor property
		subclassProto.superclass = superclassProto;
		
		delete protoProps.constructor;  // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there
		Autolinker.Util.assign( subclassProto, protoProps );
		
		return subclass;
	},
	
	
	/**
	 * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the
	 * end of the string (by default, two periods: '..'). If the `str` length does not exceed 
	 * `len`, the string will be returned unchanged.
	 * 
	 * @param {String} str The string to truncate and add an ellipsis to.
	 * @param {Number} truncateLen The length to truncate the string at.
	 * @param {String} [ellipsisChars=..] The ellipsis character(s) to add to the end of `str`
	 *   when truncated. Defaults to '..'
	 */
	ellipsis : function( str, truncateLen, ellipsisChars ) {
		if( str.length > truncateLen ) {
			ellipsisChars = ( ellipsisChars == null ) ? '..' : ellipsisChars;
			str = str.substring( 0, truncateLen - ellipsisChars.length ) + ellipsisChars;
		}
		return str;
	},
	
	
	/**
	 * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).
	 * 
	 * @param {Array} arr The array to find an element of.
	 * @param {*} element The element to find in the array, and return the index of.
	 * @return {Number} The index of the `element`, or -1 if it was not found.
	 */
	indexOf : function( arr, element ) {
		if( Array.prototype.indexOf ) {
			return arr.indexOf( element );
			
		} else {
			for( var i = 0, len = arr.length; i < len; i++ ) {
				if( arr[ i ] === element ) return i;
			}
			return -1;
		}
	},
	
	
	
	/**
	 * Performs the functionality of what modern browsers do when `String.prototype.split()` is called
	 * with a regular expression that contains capturing parenthesis.
	 * 
	 * For example:
	 * 
	 *     // Modern browsers: 
	 *     "a,b,c".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]
	 *     
	 *     // Old IE (including IE8):
	 *     "a,b,c".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]
	 *     
	 * This method emulates the functionality of modern browsers for the old IE case.
	 * 
	 * @param {String} str The string to split.
	 * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting
	 *   character(s) will be spliced into the array, as in the "modern browsers" example in the 
	 *   description of this method. 
	 *   Note #1: the supplied regular expression **must** have the 'g' flag specified.
	 *   Note #2: for simplicity's sake, the regular expression does not need 
	 *   to contain capturing parenthesis - it will be assumed that any match has them.
	 * @return {String[]} The split array of strings, with the splitting character(s) included.
	 */
	splitAndCapture : function( str, splitRegex ) {
		if( !splitRegex.global ) throw new Error( "`splitRegex` must have the 'g' flag set" );
		
		var result = [],
		    lastIdx = 0,
		    match;
		
		while( match = splitRegex.exec( str ) ) {
			result.push( str.substring( lastIdx, match.index ) );
			result.push( match[ 0 ] );  // push the splitting char(s)
			
			lastIdx = match.index + match[ 0 ].length;
		}
		result.push( str.substring( lastIdx ) );
		
		return result;
	}
	
};
/*global Autolinker */
/*jshint boss:true */
/**
 * @class Autolinker.HtmlTag
 * @extends Object
 * 
 * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.
 * 
 * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use
 * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.
 * 
 * ## Examples
 * 
 * Example instantiation:
 * 
 *     var tag = new Autolinker.HtmlTag( {
 *         tagName : 'a',
 *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },
 *         innerHtml : 'Google'
 *     } );
 *     
 *     tag.toString();  // <a href="http://google.com" class="external-link">Google</a>
 *     
 *     // Individual accessor methods
 *     tag.getTagName();                 // 'a'
 *     tag.getAttr( 'href' );            // 'http://google.com'
 *     tag.hasClass( 'external-link' );  // true
 * 
 * 
 * Using mutator methods (which may be used in combination with instantiation config properties):
 * 
 *     var tag = new Autolinker.HtmlTag();
 *     tag.setTagName( 'a' );
 *     tag.setAttr( 'href', 'http://google.com' );
 *     tag.addClass( 'external-link' );
 *     tag.setInnerHtml( 'Google' );
 *     
 *     tag.getTagName();                 // 'a'
 *     tag.getAttr( 'href' );            // 'http://google.com'
 *     tag.hasClass( 'external-link' );  // true
 *     
 *     tag.toString();  // <a href="http://google.com" class="external-link">Google</a>
 *     
 * 
 * ## Example use within a {@link Autolinker#replaceFn replaceFn}
 * 
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( autolinker, match ) {
 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text
 *             tag.setAttr( 'rel', 'nofollow' );
 *             
 *             return tag;
 *         }
 *     } );
 *     
 *     // generated html:
 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
 *     
 *     
 * ## Example use with a new tag for the replacement
 * 
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( autolinker, match ) {
 *             var tag = new Autolinker.HtmlTag( {
 *                 tagName : 'button',
 *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },
 *                 innerHtml : 'Load URL: ' + match.getAnchorText()
 *             } );
 *             
 *             return tag;
 *         }
 *     } );
 *     
 *     // generated html:
 *     //   Test <button title="Load URL: http://google.com">Load URL: google.com</button>
 */
Autolinker.HtmlTag = Autolinker.Util.extend( Object, {
	
	/**
	 * @cfg {String} tagName
	 * 
	 * The tag name. Ex: 'a', 'button', etc.
	 * 
	 * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toString}
	 * is executed.
	 */
	
	/**
	 * @cfg {Object.<String, String>} attrs
	 * 
	 * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the
	 * values are the attribute values.
	 */
	
	/**
	 * @cfg {String} innerHtml
	 * 
	 * The inner HTML for the tag. 
	 * 
	 * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym 
	 * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}
	 * if you prefer, but this one is recommended.
	 */
	
	/**
	 * @cfg {String} innerHTML
	 * 
	 * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version
	 * for acronym names.
	 */
	
	
	/**
	 * @protected
	 * @property {RegExp} whitespaceRegex
	 * 
	 * Regular expression used to match whitespace in a string of CSS classes.
	 */
	whitespaceRegex : /\s+/,
	
	
	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration properties for this class, in an Object (map)
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
		
		this.innerHtml = this.innerHtml || this.innerHTML;  // accept either the camelCased form or the fully capitalized acronym
	},
	
	
	/**
	 * Sets the tag name that will be used to generate the tag with.
	 * 
	 * @param {String} tagName
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setTagName : function( tagName ) {
		this.tagName = tagName;
		return this;
	},
	
	
	/**
	 * Retrieves the tag name.
	 * 
	 * @return {String}
	 */
	getTagName : function() {
		return this.tagName || "";
	},
	
	
	/**
	 * Sets an attribute on the HtmlTag.
	 * 
	 * @param {String} attrName The attribute name to set.
	 * @param {String} attrValue The attribute value to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setAttr : function( attrName, attrValue ) {
		var tagAttrs = this.getAttrs();
		tagAttrs[ attrName ] = attrValue;
		
		return this;
	},
	
	
	/**
	 * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.
	 * 
	 * @param {String} name The attribute name to retrieve.
	 * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.
	 */
	getAttr : function( attrName ) {
		return this.getAttrs()[ attrName ];
	},
	
	
	/**
	 * Sets one or more attributes on the HtmlTag.
	 * 
	 * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setAttrs : function( attrs ) {
		var tagAttrs = this.getAttrs();
		Autolinker.Util.assign( tagAttrs, attrs );
		
		return this;
	},
	
	
	/**
	 * Retrieves the attributes Object (map) for the HtmlTag.
	 * 
	 * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.
	 */
	getAttrs : function() {
		return this.attrs || ( this.attrs = {} );
	},
	
	
	/**
	 * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.
	 * 
	 * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setClass : function( cssClass ) {
		return this.setAttr( 'class', cssClass );
	},
	
	
	/**
	 * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.
	 * 
	 * @param {String} cssClass One or more space-separated CSS classes to add.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	addClass : function( cssClass ) {
		var classAttr = this.getClass(),
		    whitespaceRegex = this.whitespaceRegex,
		    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
		    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
		    newClasses = cssClass.split( whitespaceRegex ),
		    newClass;
		
		while( newClass = newClasses.shift() ) {
			if( indexOf( classes, newClass ) === -1 ) {
				classes.push( newClass );
			}
		}
		
		this.getAttrs()[ 'class' ] = classes.join( " " );
		return this;
	},
	
	
	/**
	 * Convenience method to remove one or more CSS classes from the HtmlTag.
	 * 
	 * @param {String} cssClass One or more space-separated CSS classes to remove.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	removeClass : function( cssClass ) {
		var classAttr = this.getClass(),
		    whitespaceRegex = this.whitespaceRegex,
		    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
		    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
		    removeClasses = cssClass.split( whitespaceRegex ),
		    removeClass;
		
		while( classes.length && ( removeClass = removeClasses.shift() ) ) {
			var idx = indexOf( classes, removeClass );
			if( idx !== -1 ) {
				classes.splice( idx, 1 );
			}
		}
		
		this.getAttrs()[ 'class' ] = classes.join( " " );
		return this;
	},
	
	
	/**
	 * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when
	 * there are multiple.
	 * 
	 * @return {String}
	 */
	getClass : function() {
		return this.getAttrs()[ 'class' ] || "";
	},
	
	
	/**
	 * Convenience method to check if the tag has a CSS class or not.
	 * 
	 * @param {String} cssClass The CSS class to check for.
	 * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.
	 */
	hasClass : function( cssClass ) {
		return ( ' ' + this.getClass() + ' ' ).indexOf( ' ' + cssClass + ' ' ) !== -1;
	},
	
	
	/**
	 * Sets the inner HTML for the tag.
	 * 
	 * @param {String} html The inner HTML to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setInnerHtml : function( html ) {
		this.innerHtml = html;
		
		return this;
	},
	
	
	/**
	 * Retrieves the inner HTML for the tag.
	 * 
	 * @return {String}
	 */
	getInnerHtml : function() {
		return this.innerHtml || "";
	},
	
	
	/**
	 * Override of superclass method used to generate the HTML string for the tag.
	 * 
	 * @return {String}
	 */
	toString : function() {
		var tagName = this.getTagName(),
		    attrsStr = this.buildAttrsStr();
		
		attrsStr = ( attrsStr ) ? ' ' + attrsStr : '';  // prepend a space if there are actually attributes
		
		return [ '<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>' ].join( "" );
	},
	
	
	/**
	 * Support method for {@link #toString}, returns the string space-separated key="value" pairs, used to populate 
	 * the stringified HtmlTag.
	 * 
	 * @protected
	 * @return {String} Example return: `attr1="value1" attr2="value2"`
	 */
	buildAttrsStr : function() {
		if( !this.attrs ) return "";  // no `attrs` Object (map) has been set, return empty string
		
		var attrs = this.getAttrs(),
		    attrsArr = [];
		
		for( var prop in attrs ) {
			if( attrs.hasOwnProperty( prop ) ) {
				attrsArr.push( prop + '="' + attrs[ prop ] + '"' );
			}
		}
		return attrsArr.join( " " );
	}
	
} );
/*global Autolinker */
/*jshint sub:true */
/**
 * @protected
 * @class Autolinker.AnchorTagBuilder
 * @extends Object
 * 
 * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is found.
 * 
 * Normally this class is instantiated, configured, and used internally by an {@link Autolinker} instance, but may 
 * actually be retrieved in a {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag} instances
 * which may be modified before returning from the {@link Autolinker#replaceFn replaceFn}. For example:
 * 
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( autolinker, match ) {
 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance
 *             tag.setAttr( 'rel', 'nofollow' );
 *             
 *             return tag;
 *         }
 *     } );
 *     
 *     // generated html:
 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
 */
Autolinker.AnchorTagBuilder = Autolinker.Util.extend( Object, {
	
	/**
	 * @cfg {Boolean} newWindow
	 * @inheritdoc Autolinker#newWindow
	 */
	
	/**
	 * @cfg {Number} truncate
	 * @inheritdoc Autolinker#truncate
	 */
	
	/**
	 * @cfg {String} className
	 * @inheritdoc Autolinker#className
	 */
	
	
	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
	},
	
	
	/**
	 * Generates the actual anchor (&lt;a&gt;) tag to use in place of the matched URL/email/Twitter text,
	 * via its `match` object.
	 * 
	 * @param {Autolinker.match.Match} match The Match instance to generate an anchor tag from.
	 * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.
	 */
	build : function( match ) {
		var tag = new Autolinker.HtmlTag( {
			tagName   : 'a',
			attrs     : this.createAttrs( match.getType(), match.getAnchorHref() ),
			innerHtml : this.processAnchorText( match.getAnchorText() )
		} );
		
		return tag;
	},
	
	
	/**
	 * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;) tag being generated.
	 * 
	 * @protected
	 * @param {"url"/"email"/"twitter"} matchType The type of match that an anchor tag is being generated for.
	 * @param {String} href The href for the anchor tag.
	 * @return {Object} A key/value Object (map) of the anchor tag's attributes. 
	 */
	createAttrs : function( matchType, anchorHref ) {
		var attrs = {
			'href' : anchorHref  // we'll always have the `href` attribute
		};
		
		var cssClass = this.createCssClass( matchType );
		if( cssClass ) {
			attrs[ 'class' ] = cssClass;
		}
		if( this.newWindow ) {
			attrs[ 'target' ] = "_blank";
		}
		
		return attrs;
	},
	
	
	/**
	 * Creates the CSS class that will be used for a given anchor tag, based on the `matchType` and the {@link #className}
	 * config.
	 * 
	 * @private
	 * @param {"url"/"email"/"twitter"} matchType The type of match that an anchor tag is being generated for.
	 * @return {String} The CSS class string for the link. Example return: "myLink myLink-url". If no {@link #className}
	 *   was configured, returns an empty string.
	 */
	createCssClass : function( matchType ) {
		var className = this.className;
		
		if( !className ) 
			return "";
		else
			return className + " " + className + "-" + matchType;  // ex: "myLink myLink-url", "myLink myLink-email", or "myLink myLink-twitter"
	},
	
	
	/**
	 * Processes the `anchorText` by truncating the text according to the {@link #truncate} config.
	 * 
	 * @private
	 * @param {String} anchorText The anchor tag's text (i.e. what will be displayed).
	 * @return {String} The processed `anchorText`.
	 */
	processAnchorText : function( anchorText ) {
		anchorText = this.doTruncate( anchorText );
		
		return anchorText;
	},
	
	
	/**
	 * Performs the truncation of the `anchorText`, if the `anchorText` is longer than the {@link #truncate} option.
	 * Truncates the text to 2 characters fewer than the {@link #truncate} option, and adds ".." to the end.
	 * 
	 * @private
	 * @param {String} text The anchor tag's text (i.e. what will be displayed).
	 * @return {String} The truncated anchor text.
	 */
	doTruncate : function( anchorText ) {
		return Autolinker.Util.ellipsis( anchorText, this.truncate || Number.POSITIVE_INFINITY );
	}
	
} );
/*global Autolinker */
/**
 * @private
 * @class Autolinker.htmlParser.HtmlParser
 * @extends Object
 * 
 * An HTML parser implementation which simply walks an HTML string and returns an array of 
 * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.
 * 
 * Autolinker uses this to only link URLs/emails/Twitter handles within text nodes, effectively ignoring / "walking
 * around" HTML tags.
 */
Autolinker.htmlParser.HtmlParser = Autolinker.Util.extend( Object, {
	
	/**
	 * @private
	 * @property {RegExp} htmlRegex
	 * 
	 * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and
	 * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.
	 * 
	 * Capturing groups:
	 * 
	 * 1. The "!DOCTYPE" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.
	 * 2. If it is an end tag, this group will have the '/'.
	 * 3. The tag name for all tags (other than the &lt;!DOCTYPE&gt; tag)
	 */
	htmlRegex : (function() {
		var tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,
		    attrNameRegex = /[^\s\0"'>\/=\x01-\x1F\x7F]+/,   // the unicode range accounts for excluding control chars, and the delete char
		    attrValueRegex = /(?:"[^"]*?"|'[^']*?'|[^'"=<>`\s]+)/, // double quoted, single quoted, or unquoted attribute values
		    nameEqualsValueRegex = attrNameRegex.source + '(?:\\s*=\\s*' + attrValueRegex.source + ')?';  // optional '=[value]'
		
		return new RegExp( [
			// for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">) 
			'(?:',
				'<(!DOCTYPE)',  // *** Capturing Group 1 - If it's a doctype tag
					
					// Zero or more attributes following the tag name
					'(?:',
						'\\s+',  // one or more whitespace chars before an attribute
						
						// Either:
						// A. attr="value", or 
						// B. "value" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">) 
						'(?:', nameEqualsValueRegex, '|', attrValueRegex.source + ')',
					')*',
				'>',
			')',
			
			'|',
			
			// All other HTML tags (i.e. tags that are not <!DOCTYPE>)
			'(?:',
				'<(/)?',  // Beginning of a tag. Either '<' for a start tag, or '</' for an end tag. 
				          // *** Capturing Group 2: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.
			
					// *** Capturing Group 3 - The tag name
					'(' + tagNameRegex.source + ')',
					
					// Zero or more attributes following the tag name
					'(?:',
						'\\s+',                // one or more whitespace chars before an attribute
						nameEqualsValueRegex,  // attr="value" (with optional ="value" part)
					')*',
					
					'\\s*/?',  // any trailing spaces and optional '/' before the closing '>'
				'>',
			')'
		].join( "" ), 'gi' );
	} )(),
	
	/**
	 * @private
	 * @property {RegExp} htmlCharacterEntitiesRegex
	 *
	 * The regular expression that matches common HTML character entities.
	 * 
	 * Ignoring &amp; as it could be part of a query string -- handling it separately.
	 */
	htmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,
	
	
	/**
	 * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes} to represent
	 * the HTML structure of the input string. 
	 * 
	 * @param {String} html The HTML to parse.
	 * @return {Autolinker.htmlParser.HtmlNode[]}
	 */
	parse : function( html ) {
		var htmlRegex = this.htmlRegex,
		    currentResult,
		    lastIndex = 0,
		    textAndEntityNodes,
		    nodes = [];  // will be the result of the method
		
		while( ( currentResult = htmlRegex.exec( html ) ) !== null ) {
			var tagText = currentResult[ 0 ],
			    tagName = currentResult[ 1 ] || currentResult[ 3 ],  // The <!DOCTYPE> tag (ex: "!DOCTYPE"), or another tag (ex: "a" or "img") 
			    isClosingTag = !!currentResult[ 2 ],
			    inBetweenTagsText = html.substring( lastIndex, currentResult.index );
			
			// Push TextNodes and EntityNodes for any text found between tags
			if( inBetweenTagsText ) {
				textAndEntityNodes = this.parseTextAndEntityNodes( inBetweenTagsText );
				nodes.push.apply( nodes, textAndEntityNodes );
			}
			
			// Push the ElementNode
			nodes.push( this.createElementNode( tagText, tagName, isClosingTag ) );
			
			lastIndex = currentResult.index + tagText.length;
		}
		
		// Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.
		if( lastIndex < html.length ) {
			var text = html.substring( lastIndex );
			
			// Push TextNodes and EntityNodes for any text found between tags
			if( text ) {
				textAndEntityNodes = this.parseTextAndEntityNodes( text );
				nodes.push.apply( nodes, textAndEntityNodes );
			}
		}
		
		return nodes;
	},
	
	
	/**
	 * Parses text and HTML entity nodes from a given string. The input string should not have any HTML tags (elements)
	 * within it.
	 * 
	 * @private
	 * @param {String} text The text to parse.
	 * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to represent the 
	 *   {@link Autolinker.htmlParser.TextNode TextNodes} and {@link Autolinker.htmlParser.EntityNode EntityNodes} found.
	 */
	parseTextAndEntityNodes : function( text ) {
		var nodes = [],
		    textAndEntityTokens = Autolinker.Util.splitAndCapture( text, this.htmlCharacterEntitiesRegex );  // split at HTML entities, but include the HTML entities in the results array
		
		// Every even numbered token is a TextNode, and every odd numbered token is an EntityNode
		// For example: an input `text` of "Test &quot;this&quot; today" would turn into the 
		//   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]
		for( var i = 0, len = textAndEntityTokens.length; i < len; i += 2 ) {
			var textToken = textAndEntityTokens[ i ],
			    entityToken = textAndEntityTokens[ i + 1 ];
			
			if( textToken ) nodes.push( this.createTextNode( textToken ) );
			if( entityToken ) nodes.push( this.createEntityNode( entityToken ) );
		}
		return nodes;
	},
	
	
	/**
	 * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.
	 * 
	 * @private
	 * @param {String} tagText The full text of the tag (element) that was matched, including its attributes.
	 * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would be passed to this method as "img".
	 * @param {Boolean} isClosingTag `true` if it's a closing tag, false otherwise.
	 * @return {Autolinker.htmlParser.ElementNode}
	 */
	createElementNode : function( tagText, tagName, isClosingTag ) {
		return new Autolinker.htmlParser.ElementNode( {
			text    : tagText,
			tagName : tagName.toLowerCase(),
			closing : isClosingTag
		} );
	},
	
	
	/**
	 * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.
	 * 
	 * @private
	 * @param {String} text The text that was matched for the HTML entity (such as '&amp;nbsp;').
	 * @return {Autolinker.htmlParser.EntityNode}
	 */
	createEntityNode : function( text ) {
		return new Autolinker.htmlParser.EntityNode( { text: text } );
	},
	
	
	/**
	 * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.
	 * 
	 * @private
	 * @param {String} text The text that was matched.
	 * @return {Autolinker.htmlParser.TextNode}
	 */
	createTextNode : function( text ) {
		return new Autolinker.htmlParser.TextNode( { text: text } );
	}
	
} );
/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.htmlParser.HtmlNode
 * 
 * Represents an HTML node found in an input string. An HTML node is one of the following:
 * 
 * 1. An {@link Autolinker.htmlParser.ElementNode ElementNode}, which represents HTML tags.
 * 2. A {@link Autolinker.htmlParser.TextNode TextNode}, which represents text outside or within HTML tags.
 * 3. A {@link Autolinker.htmlParser.EntityNode EntityNode}, which represents one of the known HTML
 *    entities that Autolinker looks for. This includes common ones such as &amp;quot; and &amp;nbsp;
 */
Autolinker.htmlParser.HtmlNode = Autolinker.Util.extend( Object, {
	
	/**
	 * @cfg {String} text (required)
	 * 
	 * The original text that was matched for the HtmlNode. 
	 * 
	 * - In the case of an {@link Autolinker.htmlParser.ElementNode ElementNode}, this will be the tag's
	 *   text.
	 * - In the case of a {@link Autolinker.htmlParser.TextNode TextNode}, this will be the text itself.
	 * - In the case of a {@link Autolinker.htmlParser.EntityNode EntityNode}, this will be the text of
	 *   the HTML entity.
	 */
	text : "",
	
	
	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
	},

	
	/**
	 * Returns a string name for the type of node that this class represents.
	 * 
	 * @abstract
	 * @return {String}
	 */
	getType : Autolinker.Util.abstractMethod,
	
	
	/**
	 * Retrieves the {@link #text} for the HtmlNode.
	 * 
	 * @return {String}
	 */
	getText : function() {
		return this.text;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.ElementNode
 * @extends Autolinker.htmlParser.HtmlNode
 * 
 * Represents an HTML element node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 * 
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.
 */
Autolinker.htmlParser.ElementNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {
	
	/**
	 * @cfg {String} tagName (required)
	 * 
	 * The name of the tag that was matched.
	 */
	tagName : '',
	
	/**
	 * @cfg {Boolean} closing (required)
	 * 
	 * `true` if the element (tag) is a closing tag, `false` if its an opening tag.
	 */
	closing : false,

	
	/**
	 * Returns a string name for the type of node that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'element';
	},
	

	/**
	 * Returns the HTML element's (tag's) name. Ex: for an &lt;img&gt; tag, returns "img".
	 * 
	 * @return {String}
	 */
	getTagName : function() {
		return this.tagName;
	},
	
	
	/**
	 * Determines if the HTML element (tag) is a closing tag. Ex: &lt;div&gt; returns
	 * `false`, while &lt;/div&gt; returns `true`.
	 * 
	 * @return {Boolean}
	 */
	isClosing : function() {
		return this.closing;
	}
	
} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.EntityNode
 * @extends Autolinker.htmlParser.HtmlNode
 * 
 * Represents a known HTML entity node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 * Ex: '&amp;nbsp;', or '&amp#160;' (which will be retrievable from the {@link #getText} method.
 * 
 * Note that this class will only be returned from the HtmlParser for the set of checked HTML entity nodes 
 * defined by the {@link Autolinker.htmlParser.HtmlParser#htmlCharacterEntitiesRegex}.
 * 
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.
 */
Autolinker.htmlParser.EntityNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {
	
	/**
	 * Returns a string name for the type of node that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'entity';
	}
	
} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.TextNode
 * @extends Autolinker.htmlParser.HtmlNode
 * 
 * Represents a text node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 * 
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.
 */
Autolinker.htmlParser.TextNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {
	
	/**
	 * Returns a string name for the type of node that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'text';
	}
	
} );
/*global Autolinker */
/**
 * @private
 * @class Autolinker.matchParser.MatchParser
 * @extends Object
 * 
 * Used by Autolinker to parse {@link #urls URLs}, {@link #emails email addresses}, and {@link #twitter Twitter handles}, 
 * given an input string of text.
 * 
 * The MatchParser is fed a non-HTML string in order to search out URLs, email addresses and Twitter handles. Autolinker
 * first uses the {@link HtmlParser} to "walk around" HTML tags, and then the text around the HTML tags is passed into
 * the MatchParser in order to find the actual matches.
 */
Autolinker.matchParser.MatchParser = Autolinker.Util.extend( Object, {
	
	/**
	 * @cfg {Boolean} urls
	 * 
	 * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.
	 */
	urls : true,
	
	/**
	 * @cfg {Boolean} email
	 * 
	 * `true` if email addresses should be automatically linked, `false` if they should not be.
	 */
	email : true,
	
	/**
	 * @cfg {Boolean} twitter
	 * 
	 * `true` if Twitter handles ("@example") should be automatically linked, `false` if they should not be.
	 */
	twitter : true,
	
	/**
	 * @cfg {Boolean} stripPrefix
	 * 
	 * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped from the beginning of URL links' text
	 * in {@link Autolinker.match.Url URL matches}, `false` otherwise.
	 * 
	 * TODO: Handle this before a URL Match object is instantiated.
	 */
	stripPrefix : true,
	
	
	/**
	 * @private
	 * @property {RegExp} matcherRegex
	 * 
	 * The regular expression that matches URLs, email addresses, and Twitter handles.
	 * 
	 * This regular expression has the following capturing groups:
	 * 
	 * 1. Group that is used to determine if there is a Twitter handle match (i.e. \@someTwitterUser). Simply check for its 
	 *    existence to determine if there is a Twitter handle match. The next couple of capturing groups give information 
	 *    about the Twitter handle match.
	 * 2. The whitespace character before the \@sign in a Twitter handle. This is needed because there are no lookbehinds in
	 *    JS regular expressions, and can be used to reconstruct the original string in a replace().
	 * 3. The Twitter handle itself in a Twitter match. If the match is '@someTwitterUser', the handle is 'someTwitterUser'.
	 * 4. Group that matches an email address. Used to determine if the match is an email address, as well as holding the full 
	 *    address. Ex: 'me@my.com'
	 * 5. Group that matches a URL in the input text. Ex: 'http://google.com', 'www.google.com', or just 'google.com'.
	 *    This also includes a path, url parameters, or hash anchors. Ex: google.com/path/to/file?q1=1&q2=2#myAnchor
	 * 6. Group that matches a protocol URL (i.e. 'http://google.com'). This is used to match protocol URLs with just a single
	 *    word, like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
	 * 7. A protocol-relative ('//') match for the case of a 'www.' prefixed URL. Will be an empty string if it is not a 
	 *    protocol-relative match. We need to know the character before the '//' in order to determine if it is a valid match
	 *    or the // was in a string we don't want to auto-link.
	 * 8. A protocol-relative ('//') match for the case of a known TLD prefixed URL. Will be an empty string if it is not a 
	 *    protocol-relative match. See #6 for more info. 
	 */
	matcherRegex : (function() {
		var twitterRegex = /(^|[^\w])@(\w{1,15})/,              // For matching a twitter handle. Ex: @gregory_jacobs
		    
		    emailRegex = /(?:[\-;:&=\+\$,\w\.]+@)/,             // something@ for email addresses (a.k.a. local-part)
		    
		    protocolRegex = /(?:[A-Za-z][-.+A-Za-z0-9]+:(?![A-Za-z][-.+A-Za-z0-9]+:\/\/)(?!\d+\/?)(?:\/\/)?)/,  // match protocol, allow in format "http://" or "mailto:". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match "link:"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)
		    wwwRegex = /(?:www\.)/,                             // starting with 'www.'
		    domainNameRegex = /[A-Za-z0-9\.\-]*[A-Za-z0-9\-]/,  // anything looking at all like a domain, non-unicode domains, not ending in a period
		    tldRegex = /\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\b/,   // match our known top level domains (TLDs)
		    
		    // Allow optional path, query string, and hash anchor, not ending in the following characters: "?!:,.;"
		    // http://blog.codinghorror.com/the-problem-with-urls/
		    urlSuffixRegex = /[\-A-Za-z0-9+&@#\/%=~_()|'$*\[\]?!:,.;]*[\-A-Za-z0-9+&@#\/%=~_()|'$*\[\]]/;
		
		return new RegExp( [
			'(',  // *** Capturing group $1, which can be used to check for a twitter handle match. Use group $3 for the actual twitter handle though. $2 may be used to reconstruct the original string in a replace() 
				// *** Capturing group $2, which matches the whitespace character before the '@' sign (needed because of no lookbehinds), and 
				// *** Capturing group $3, which matches the actual twitter handle
				twitterRegex.source,
			')',
			
			'|',
			
			'(',  // *** Capturing group $4, which is used to determine an email match
				emailRegex.source,
				domainNameRegex.source,
				tldRegex.source,
			')',
			
			'|',
			
			'(',  // *** Capturing group $5, which is used to match a URL
				'(?:', // parens to cover match for protocol (optional), and domain
					'(',  // *** Capturing group $6, for a protocol-prefixed url (ex: http://google.com)
						protocolRegex.source,
						domainNameRegex.source,
					')',
					
					'|',
					
					'(?:',  // non-capturing paren for a 'www.' prefixed url (ex: www.google.com)
						'(.?//)?',  // *** Capturing group $7 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character
						wwwRegex.source,
						domainNameRegex.source,
					')',
					
					'|',
					
					'(?:',  // non-capturing paren for known a TLD url (ex: google.com)
						'(.?//)?',  // *** Capturing group $8 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character
						domainNameRegex.source,
						tldRegex.source,
					')',
				')',
				
				'(?:' + urlSuffixRegex.source + ')?',  // match for path, query string, and/or hash anchor - optional
			')'
		].join( "" ), 'gi' );
	} )(),
	
	/**
	 * @private
	 * @property {RegExp} charBeforeProtocolRelMatchRegex
	 * 
	 * The regular expression used to retrieve the character before a protocol-relative URL match.
	 * 
	 * This is used in conjunction with the {@link #matcherRegex}, which needs to grab the character before a protocol-relative
	 * '//' due to the lack of a negative look-behind in JavaScript regular expressions. The character before the match is stripped
	 * from the URL.
	 */
	charBeforeProtocolRelMatchRegex : /^(.)?\/\//,
	
	/**
	 * @private
	 * @property {Autolinker.MatchValidator} matchValidator
	 * 
	 * The MatchValidator object, used to filter out any false positives from the {@link #matcherRegex}. See
	 * {@link Autolinker.MatchValidator} for details.
	 */
	
	
	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
	
		this.matchValidator = new Autolinker.MatchValidator();
	},
	
	
	/**
	 * Parses the input `text` to search for URLs/emails/Twitter handles, and calls the `replaceFn`
	 * to allow replacements of the matches. Returns the `text` with matches replaced.
	 * 
	 * @param {String} text The text to search and repace matches in.
	 * @param {Function} replaceFn The iterator function to handle the replacements. The function takes a
	 *   single argument, a {@link Autolinker.match.Match} object, and should return the text that should
	 *   make the replacement.
	 * @param {Object} [contextObj=window] The context object ("scope") to run the `replaceFn` in.
	 * @return {String}
	 */
	replace : function( text, replaceFn, contextObj ) {
		var me = this;  // for closure
		
		return text.replace( this.matcherRegex, function( matchStr, $1, $2, $3, $4, $5, $6, $7, $8 ) {
			var matchDescObj = me.processCandidateMatch( matchStr, $1, $2, $3, $4, $5, $6, $7, $8 );  // "match description" object
			
			// Return out with no changes for match types that are disabled (url, email, twitter), or for matches that are 
			// invalid (false positives from the matcherRegex, which can't use look-behinds since they are unavailable in JS).
			if( !matchDescObj ) {
				return matchStr;
				
			} else {
				// Generate replacement text for the match from the `replaceFn`
				var replaceStr = replaceFn.call( contextObj, matchDescObj.match );
				return matchDescObj.prefixStr + replaceStr + matchDescObj.suffixStr;
			}
		} );
	},
	
	
	/**
	 * Processes a candidate match from the {@link #matcherRegex}. 
	 * 
	 * Not all matches found by the regex are actual URL/email/Twitter matches, as determined by the {@link #matchValidator}. In
	 * this case, the method returns `null`. Otherwise, a valid Object with `prefixStr`, `match`, and `suffixStr` is returned.
	 * 
	 * @private
	 * @param {String} matchStr The full match that was found by the {@link #matcherRegex}.
	 * @param {String} twitterMatch The matched text of a Twitter handle, if the match is a Twitter match.
	 * @param {String} twitterHandlePrefixWhitespaceChar The whitespace char before the @ sign in a Twitter handle match. This 
	 *   is needed because of no lookbehinds in JS regexes, and is need to re-include the character for the anchor tag replacement.
	 * @param {String} twitterHandle The actual Twitter user (i.e the word after the @ sign in a Twitter match).
	 * @param {String} emailAddressMatch The matched email address for an email address match.
	 * @param {String} urlMatch The matched URL string for a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match
	 *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
	 * @param {String} wwwProtocolRelativeMatch The '//' for a protocol-relative match from a 'www' url, with the character that 
	 *   comes before the '//'.
	 * @param {String} tldProtocolRelativeMatch The '//' for a protocol-relative match from a TLD (top level domain) match, with 
	 *   the character that comes before the '//'.
	 *   
	 * @return {Object} A "match description object". This will be `null` if the match was invalid, or if a match type is disabled.
	 *   Otherwise, this will be an Object (map) with the following properties:
	 * @return {String} return.prefixStr The char(s) that should be prepended to the replacement string. These are char(s) that
	 *   were needed to be included from the regex match that were ignored by processing code, and should be re-inserted into 
	 *   the replacement stream.
	 * @return {String} return.suffixStr The char(s) that should be appended to the replacement string. These are char(s) that
	 *   were needed to be included from the regex match that were ignored by processing code, and should be re-inserted into 
	 *   the replacement stream.
	 * @return {Autolinker.match.Match} return.match The Match object that represents the match that was found.
	 */
	processCandidateMatch : function( 
		matchStr, twitterMatch, twitterHandlePrefixWhitespaceChar, twitterHandle, 
		emailAddressMatch, urlMatch, protocolUrlMatch, wwwProtocolRelativeMatch, tldProtocolRelativeMatch
	) {
		// Note: The `matchStr` variable wil be fixed up to remove characters that are no longer needed (which will 
		// be added to `prefixStr` and `suffixStr`).
		
		var protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,
		    match,  // Will be an Autolinker.match.Match object
		    
		    prefixStr = "",       // A string to use to prefix the anchor tag that is created. This is needed for the Twitter handle match
		    suffixStr = "";       // A string to suffix the anchor tag that is created. This is used if there is a trailing parenthesis that should not be auto-linked.
		    
		
		// Return out with `null` for match types that are disabled (url, email, twitter), or for matches that are 
		// invalid (false positives from the matcherRegex, which can't use look-behinds since they are unavailable in JS).
		if(
			( twitterMatch && !this.twitter ) || ( emailAddressMatch && !this.email ) || ( urlMatch && !this.urls ) ||
			!this.matchValidator.isValidMatch( urlMatch, protocolUrlMatch, protocolRelativeMatch ) 
		) {
			return null;
		}
		
		// Handle a closing parenthesis at the end of the match, and exclude it if there is not a matching open parenthesis
		// in the match itself. 
		if( this.matchHasUnbalancedClosingParen( matchStr ) ) {
			matchStr = matchStr.substr( 0, matchStr.length - 1 );  // remove the trailing ")"
			suffixStr = ")";  // this will be added after the generated <a> tag
		}
		
		
		if( emailAddressMatch ) {
			match = new Autolinker.match.Email( { matchedText: matchStr, email: emailAddressMatch } );
			
		} else if( twitterMatch ) {
			// fix up the `matchStr` if there was a preceding whitespace char, which was needed to determine the match 
			// itself (since there are no look-behinds in JS regexes)
			if( twitterHandlePrefixWhitespaceChar ) {
				prefixStr = twitterHandlePrefixWhitespaceChar;
				matchStr = matchStr.slice( 1 );  // remove the prefixed whitespace char from the match
			}
			match = new Autolinker.match.Twitter( { matchedText: matchStr, twitterHandle: twitterHandle } );
			
		} else {  // url match
			// If it's a protocol-relative '//' match, remove the character before the '//' (which the matcherRegex needed
			// to match due to the lack of a negative look-behind in JavaScript regular expressions)
			if( protocolRelativeMatch ) {
				var charBeforeMatch = protocolRelativeMatch.match( this.charBeforeProtocolRelMatchRegex )[ 1 ] || "";
				
				if( charBeforeMatch ) {  // fix up the `matchStr` if there was a preceding char before a protocol-relative match, which was needed to determine the match itself (since there are no look-behinds in JS regexes)
					prefixStr = charBeforeMatch;
					matchStr = matchStr.slice( 1 );  // remove the prefixed char from the match
				}
			}
			
			match = new Autolinker.match.Url( {
				matchedText : matchStr,
				url : matchStr,
				protocolUrlMatch : !!protocolUrlMatch,
				protocolRelativeMatch : !!protocolRelativeMatch,
				stripPrefix : this.stripPrefix
			} );
		}
		
		return {
			prefixStr : prefixStr,
			suffixStr : suffixStr,
			match     : match
		};
	},
	
	
	/**
	 * Determines if a match found has an unmatched closing parenthesis. If so, this parenthesis will be removed
	 * from the match itself, and appended after the generated anchor tag in {@link #processTextNode}.
	 * 
	 * A match may have an extra closing parenthesis at the end of the match because the regular expression must include parenthesis
	 * for URLs such as "wikipedia.com/something_(disambiguation)", which should be auto-linked. 
	 * 
	 * However, an extra parenthesis *will* be included when the URL itself is wrapped in parenthesis, such as in the case of
	 * "(wikipedia.com/something_(disambiguation))". In this case, the last closing parenthesis should *not* be part of the URL 
	 * itself, and this method will return `true`.
	 * 
	 * @private
	 * @param {String} matchStr The full match string from the {@link #matcherRegex}.
	 * @return {Boolean} `true` if there is an unbalanced closing parenthesis at the end of the `matchStr`, `false` otherwise.
	 */
	matchHasUnbalancedClosingParen : function( matchStr ) {
		var lastChar = matchStr.charAt( matchStr.length - 1 );
		
		if( lastChar === ')' ) {
			var openParensMatch = matchStr.match( /\(/g ),
			    closeParensMatch = matchStr.match( /\)/g ),
			    numOpenParens = ( openParensMatch && openParensMatch.length ) || 0,
			    numCloseParens = ( closeParensMatch && closeParensMatch.length ) || 0;
			
			if( numOpenParens < numCloseParens ) {
				return true;
			}
		}
		
		return false;
	}
	
} );
/*global Autolinker */
/*jshint scripturl:true */
/**
 * @private
 * @class Autolinker.MatchValidator
 * @extends Object
 * 
 * Used by Autolinker to filter out false positives from the {@link Autolinker#matcherRegex}.
 * 
 * Due to the limitations of regular expressions (including the missing feature of look-behinds in JS regular expressions),
 * we cannot always determine the validity of a given match. This class applies a bit of additional logic to filter out any
 * false positives that have been matched by the {@link Autolinker#matcherRegex}.
 */
Autolinker.MatchValidator = Autolinker.Util.extend( Object, {
	
	/**
	 * @private
	 * @property {RegExp} invalidProtocolRelMatchRegex
	 * 
	 * The regular expression used to check a potential protocol-relative URL match, coming from the 
	 * {@link Autolinker#matcherRegex}. A protocol-relative URL is, for example, "//yahoo.com"
	 * 
	 * This regular expression checks to see if there is a word character before the '//' match in order to determine if 
	 * we should actually autolink a protocol-relative URL. This is needed because there is no negative look-behind in 
	 * JavaScript regular expressions. 
	 * 
	 * For instance, we want to autolink something like "Go to: //google.com", but we don't want to autolink something 
	 * like "abc//google.com"
	 */
	invalidProtocolRelMatchRegex : /^[\w]\/\//,
	
	/**
	 * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'
	 * 
	 * @private
	 * @property {RegExp} hasFullProtocolRegex
	 */
	hasFullProtocolRegex : /^[A-Za-z][-.+A-Za-z0-9]+:\/\//,
	
	/**
	 * Regex to find the URI scheme, such as 'mailto:'.
	 * 
	 * This is used to filter out 'javascript:' and 'vbscript:' schemes.
	 * 
	 * @private
	 * @property {RegExp} uriSchemeRegex
	 */
	uriSchemeRegex : /^[A-Za-z][-.+A-Za-z0-9]+:/,
	
	/**
	 * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')
	 * 
	 * @private
	 * @property {RegExp} hasWordCharAfterProtocolRegex
	 */
	hasWordCharAfterProtocolRegex : /:[^\s]*?[A-Za-z]/,
	
	
	/**
	 * Determines if a given match found by {@link Autolinker#processTextNode} is valid. Will return `false` for:
	 * 
	 * 1) URL matches which do not have at least have one period ('.') in the domain name (effectively skipping over 
	 *    matches like "abc:def"). However, URL matches with a protocol will be allowed (ex: 'http://localhost')
	 * 2) URL matches which do not have at least one word character in the domain name (effectively skipping over
	 *    matches like "git:1.0").
	 * 3) A protocol-relative url match (a URL beginning with '//') whose previous character is a word character 
	 *    (effectively skipping over strings like "abc//google.com")
	 * 
	 * Otherwise, returns `true`.
	 * 
	 * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match
	 *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
	 * @param {String} protocolRelativeMatch The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding
	 *   character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character
	 *   preceding the '//'.
	 * @return {Boolean} `true` if the match given is valid and should be processed, or `false` if the match is invalid and/or 
	 *   should just not be processed.
	 */
	isValidMatch : function( urlMatch, protocolUrlMatch, protocolRelativeMatch ) {
		if(
			( protocolUrlMatch && !this.isValidUriScheme( protocolUrlMatch ) ) ||
			this.urlMatchDoesNotHaveProtocolOrDot( urlMatch, protocolUrlMatch ) ||       // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')
			this.urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch, protocolUrlMatch ) ||  // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like "git:1.0"
			this.isInvalidProtocolRelativeMatch( protocolRelativeMatch )                 // A protocol-relative match which has a word character in front of it (so we can skip something like "abc//google.com")
		) {
			return false;
		}
		
		return true;
	},
	
	
	/**
	 * Determines if the URI scheme is a valid scheme to be autolinked. Returns `false` if the scheme is 
	 * 'javascript:' or 'vbscript:'
	 * 
	 * @private
	 * @param {String} uriSchemeMatch The match URL string for a full URI scheme match. Ex: 'http://yahoo.com' 
	 *   or 'mailto:a@a.com'.
	 * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.
	 */
	isValidUriScheme : function( uriSchemeMatch ) {
		var uriScheme = uriSchemeMatch.match( this.uriSchemeRegex )[ 0 ].toLowerCase();
		
		return ( uriScheme !== 'javascript:' && uriScheme !== 'vbscript:' );
	},
	
	
	/**
	 * Determines if a URL match does not have either:
	 * 
	 * a) a full protocol (i.e. 'http://'), or
	 * b) at least one dot ('.') in the domain name (for a non-full-protocol match).
	 * 
	 * Either situation is considered an invalid URL (ex: 'git:d' does not have either the '://' part, or at least one dot
	 * in the domain name. If the match was 'git:abc.com', we would consider this valid.)
	 * 
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match
	 *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
	 * @return {Boolean} `true` if the URL match does not have a full protocol, or at least one dot ('.') in a non-full-protocol
	 *   match.
	 */
	urlMatchDoesNotHaveProtocolOrDot : function( urlMatch, protocolUrlMatch ) {
		return ( !!urlMatch && ( !protocolUrlMatch || !this.hasFullProtocolRegex.test( protocolUrlMatch ) ) && urlMatch.indexOf( '.' ) === -1 );
	},
	
	
	/**
	 * Determines if a URL match does not have at least one word character after the protocol (i.e. in the domain name).
	 * 
	 * At least one letter character must exist in the domain name after a protocol match. Ex: skip over something 
	 * like "git:1.0"
	 * 
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to
	 *   know whether or not we have a protocol in the URL string, in order to check for a word character after the protocol
	 *   separator (':').
	 * @return {Boolean} `true` if the URL match does not have at least one word character in it after the protocol, `false`
	 *   otherwise.
	 */
	urlMatchDoesNotHaveAtLeastOneWordChar : function( urlMatch, protocolUrlMatch ) {
		if( urlMatch && protocolUrlMatch ) {
			return !this.hasWordCharAfterProtocolRegex.test( urlMatch );
		} else {
			return false;
		}
	},
	
	
	/**
	 * Determines if a protocol-relative match is an invalid one. This method returns `true` if there is a `protocolRelativeMatch`,
	 * and that match contains a word character before the '//' (i.e. it must contain whitespace or nothing before the '//' in
	 * order to be considered valid).
	 * 
	 * @private
	 * @param {String} protocolRelativeMatch The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding
	 *   character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character
	 *   preceding the '//'.
	 * @return {Boolean} `true` if it is an invalid protocol-relative match, `false` otherwise.
	 */
	isInvalidProtocolRelativeMatch : function( protocolRelativeMatch ) {
		return ( !!protocolRelativeMatch && this.invalidProtocolRelMatchRegex.test( protocolRelativeMatch ) );
	}

} );
/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.match.Match
 * 
 * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a 
 * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.
 * 
 * For example:
 * 
 *     var input = "...";  // string with URLs, Email Addresses, and Twitter Handles
 *     
 *     var linkedText = Autolinker.link( input, {
 *         replaceFn : function( autolinker, match ) {
 *             console.log( "href = ", match.getAnchorHref() );
 *             console.log( "text = ", match.getAnchorText() );
 *         
 *             switch( match.getType() ) {
 *                 case 'url' : 
 *                     console.log( "url: ", match.getUrl() );
 *                     
 *                 case 'email' :
 *                     console.log( "email: ", match.getEmail() );
 *                     
 *                 case 'twitter' :
 *                     console.log( "twitter: ", match.getTwitterHandle() );
 *             }
 *         }
 *     } );
 *     
 * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.
 */
Autolinker.match.Match = Autolinker.Util.extend( Object, {
	
	/**
	 * @cfg {String} matchedText (required)
	 * 
	 * The original text that was matched.
	 */
	
	
	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
	},

	
	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @abstract
	 * @return {String}
	 */
	getType : Autolinker.Util.abstractMethod,
	
	
	/**
	 * Returns the original text that was matched.
	 * 
	 * @return {String}
	 */
	getMatchedText : function() {
		return this.matchedText;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @abstract
	 * @return {String}
	 */
	getAnchorHref : Autolinker.Util.abstractMethod,
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @abstract
	 * @return {String}
	 */
	getAnchorText : Autolinker.Util.abstractMethod

} );
/*global Autolinker */
/**
 * @class Autolinker.match.Email
 * @extends Autolinker.match.Match
 * 
 * Represents a Email match found in an input string which should be Autolinked.
 * 
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Email = Autolinker.Util.extend( Autolinker.match.Match, {
	
	/**
	 * @cfg {String} email (required)
	 * 
	 * The email address that was matched.
	 */
	

	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'email';
	},
	
	
	/**
	 * Returns the email address that was matched.
	 * 
	 * @return {String}
	 */
	getEmail : function() {
		return this.email;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'mailto:' + this.email;
	},
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorText : function() {
		return this.email;
	}
	
} );
/*global Autolinker */
/**
 * @class Autolinker.match.Twitter
 * @extends Autolinker.match.Match
 * 
 * Represents a Twitter match found in an input string which should be Autolinked.
 * 
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Twitter = Autolinker.Util.extend( Autolinker.match.Match, {
	
	/**
	 * @cfg {String} twitterHandle (required)
	 * 
	 * The Twitter handle that was matched.
	 */
	

	/**
	 * Returns the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'twitter';
	},
	
	
	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getTwitterHandle : function() {
		return this.twitterHandle;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'https://twitter.com/' + this.twitterHandle;
	},
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorText : function() {
		return '@' + this.twitterHandle;
	}
	
} );
/*global Autolinker */
/**
 * @class Autolinker.match.Url
 * @extends Autolinker.match.Match
 * 
 * Represents a Url match found in an input string which should be Autolinked.
 * 
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Url = Autolinker.Util.extend( Autolinker.match.Match, {
	
	/**
	 * @cfg {String} url (required)
	 * 
	 * The url that was matched.
	 */
	
	/**
	 * @cfg {Boolean} protocolUrlMatch (required)
	 * 
	 * `true` if the URL is a match which already has a protocol (i.e. 'http://'), `false` if the match was from a 'www' or
	 * known TLD match.
	 */
	
	/**
	 * @cfg {Boolean} protocolRelativeMatch (required)
	 * 
	 * `true` if the URL is a protocol-relative match. A protocol-relative match is a URL that starts with '//',
	 * and will be either http:// or https:// based on the protocol that the site is loaded under.
	 */
	
	/**
	 * @cfg {Boolean} stripPrefix (required)
	 * @inheritdoc Autolinker#stripPrefix
	 */
	

	/**
	 * @private
	 * @property {RegExp} urlPrefixRegex
	 * 
	 * A regular expression used to remove the 'http://' or 'https://' and/or the 'www.' from URLs.
	 */
	urlPrefixRegex: /^(https?:\/\/)?(www\.)?/i,
	
	/**
	 * @private
	 * @property {RegExp} protocolRelativeRegex
	 * 
	 * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes
	 * of {@link #getAnchorText}. A protocol-relative URL is, for example, "//yahoo.com"
	 */
	protocolRelativeRegex : /^\/\//,
	
	/**
	 * @private
	 * @property {Boolean} protocolPrepended
	 * 
	 * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the
	 * {@link #url} did not have a protocol)
	 */
	protocolPrepended : false,
	

	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'url';
	},
	
	
	/**
	 * Returns the url that was matched, assuming the protocol to be 'http://' if the original
	 * match was missing a protocol.
	 * 
	 * @return {String}
	 */
	getUrl : function() {
		var url = this.url;
		
		// if the url string doesn't begin with a protocol, assume 'http://'
		if( !this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended ) {
			url = this.url = 'http://' + url;
			
			this.protocolPrepended = true;
		}
		
		return url;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorHref : function() {
		var url = this.getUrl();
		
		return url.replace( /&amp;/g, '&' );  // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html 
	},
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorText : function() {
		var anchorText = this.getUrl();
		
		if( this.protocolRelativeMatch ) {
			// Strip off any protocol-relative '//' from the anchor text
			anchorText = this.stripProtocolRelativePrefix( anchorText );
		}
		if( this.stripPrefix ) {
			anchorText = this.stripUrlPrefix( anchorText );
		}
		anchorText = this.removeTrailingSlash( anchorText );  // remove trailing slash, if there is one
		
		return anchorText;
	},
	
	
	// ---------------------------------------
	
	// Utility Functionality
	
	/**
	 * Strips the URL prefix (such as "http://" or "https://") from the given text.
	 * 
	 * @private
	 * @param {String} text The text of the anchor that is being generated, for which to strip off the
	 *   url prefix (such as stripping off "http://")
	 * @return {String} The `anchorText`, with the prefix stripped.
	 */
	stripUrlPrefix : function( text ) {
		return text.replace( this.urlPrefixRegex, '' );
	},
	
	
	/**
	 * Strips any protocol-relative '//' from the anchor text.
	 * 
	 * @private
	 * @param {String} text The text of the anchor that is being generated, for which to strip off the
	 *   protocol-relative prefix (such as stripping off "//")
	 * @return {String} The `anchorText`, with the protocol-relative prefix stripped.
	 */
	stripProtocolRelativePrefix : function( text ) {
		return text.replace( this.protocolRelativeRegex, '' );
	},
	
	
	/**
	 * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.
	 * 
	 * @private
	 * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing
	 *   slash ('/') that may exist.
	 * @return {String} The `anchorText`, with the trailing slash removed.
	 */
	removeTrailingSlash : function( anchorText ) {
		if( anchorText.charAt( anchorText.length - 1 ) === '/' ) {
			anchorText = anchorText.slice( 0, -1 );
		}
		return anchorText;
	}
	
} );
return Autolinker;

}));


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/animations.css":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/animations.css ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/*\r\n==============================================\r\nCSS3 ANIMATION CHEAT SHEET\r\n==============================================\r\n\r\nMade by Justin Aguilar\r\n\r\nwww.justinaguilar.com/animations/\r\n\r\nQuestions, comments, concerns, love letters:\r\njustin@justinaguilar.com\r\n==============================================\r\n*/\r\n\r\n/*\r\n==============================================\r\nslideDown\r\n==============================================\r\n*/\r\n\r\n\r\n.slideDown{\r\n\tanimation-name: slideDown;\r\n\t-webkit-animation-name: slideDown;\r\n\r\n\tanimation-duration: 1s;\r\n\t-webkit-animation-duration: 1s;\r\n\r\n\tanimation-timing-function: ease;\r\n\t-webkit-animation-timing-function: ease;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes slideDown {\r\n\t0% {\r\n\t\ttransform: translateY(-100%);\r\n\t}\r\n\t50%{\r\n\t\ttransform: translateY(8%);\r\n\t}\r\n\t65%{\r\n\t\ttransform: translateY(-4%);\r\n\t}\r\n\t80%{\r\n\t\ttransform: translateY(4%);\r\n\t}\r\n\t95%{\r\n\t\ttransform: translateY(-2%);\r\n\t}\r\n\t100% {\r\n\t\ttransform: translateY(0%);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes slideDown {\r\n\t0% {\r\n\t\t-webkit-transform: translateY(-100%);\r\n\t}\r\n\t50%{\r\n\t\t-webkit-transform: translateY(8%);\r\n\t}\r\n\t65%{\r\n\t\t-webkit-transform: translateY(-4%);\r\n\t}\r\n\t80%{\r\n\t\t-webkit-transform: translateY(4%);\r\n\t}\r\n\t95%{\r\n\t\t-webkit-transform: translateY(-2%);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: translateY(0%);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nslideUp\r\n==============================================\r\n*/\r\n\r\n\r\n.slideUp{\r\n\tanimation-name: slideUp;\r\n\t-webkit-animation-name: slideUp;\r\n\r\n\tanimation-duration: 1s;\r\n\t-webkit-animation-duration: 1s;\r\n\r\n\tanimation-timing-function: ease;\r\n\t-webkit-animation-timing-function: ease;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes slideUp {\r\n\t0% {\r\n\t\ttransform: translateY(100%);\r\n\t}\r\n\t50%{\r\n\t\ttransform: translateY(-8%);\r\n\t}\r\n\t65%{\r\n\t\ttransform: translateY(4%);\r\n\t}\r\n\t80%{\r\n\t\ttransform: translateY(-4%);\r\n\t}\r\n\t95%{\r\n\t\ttransform: translateY(2%);\r\n\t}\r\n\t100% {\r\n\t\ttransform: translateY(0%);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes slideUp {\r\n\t0% {\r\n\t\t-webkit-transform: translateY(100%);\r\n\t}\r\n\t50%{\r\n\t\t-webkit-transform: translateY(-8%);\r\n\t}\r\n\t65%{\r\n\t\t-webkit-transform: translateY(4%);\r\n\t}\r\n\t80%{\r\n\t\t-webkit-transform: translateY(-4%);\r\n\t}\r\n\t95%{\r\n\t\t-webkit-transform: translateY(2%);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: translateY(0%);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nslideLeft\r\n==============================================\r\n*/\r\n\r\n\r\n.slideLeft{\r\n\tanimation-name: slideLeft;\r\n\t-webkit-animation-name: slideLeft;\r\n\r\n\tanimation-duration: 1s;\r\n\t-webkit-animation-duration: 1s;\r\n\r\n\tanimation-timing-function: ease-in-out;\r\n\t-webkit-animation-timing-function: ease-in-out;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes slideLeft {\r\n\t0% {\r\n\t\ttransform: translateX(150%);\r\n\t}\r\n\t50%{\r\n\t\ttransform: translateX(-8%);\r\n\t}\r\n\t65%{\r\n\t\ttransform: translateX(4%);\r\n\t}\r\n\t80%{\r\n\t\ttransform: translateX(-4%);\r\n\t}\r\n\t95%{\r\n\t\ttransform: translateX(2%);\r\n\t}\r\n\t100% {\r\n\t\ttransform: translateX(0%);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes slideLeft {\r\n\t0% {\r\n\t\t-webkit-transform: translateX(150%);\r\n\t}\r\n\t50%{\r\n\t\t-webkit-transform: translateX(-8%);\r\n\t}\r\n\t65%{\r\n\t\t-webkit-transform: translateX(4%);\r\n\t}\r\n\t80%{\r\n\t\t-webkit-transform: translateX(-4%);\r\n\t}\r\n\t95%{\r\n\t\t-webkit-transform: translateX(2%);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: translateX(0%);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nslideRight\r\n==============================================\r\n*/\r\n\r\n\r\n.slideRight{\r\n\tanimation-name: slideRight;\r\n\t-webkit-animation-name: slideRight;\r\n\r\n\tanimation-duration: 1s;\r\n\t-webkit-animation-duration: 1s;\r\n\r\n\tanimation-timing-function: ease-in-out;\r\n\t-webkit-animation-timing-function: ease-in-out;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes slideRight {\r\n\t0% {\r\n\t\ttransform: translateX(-150%);\r\n\t}\r\n\t50%{\r\n\t\ttransform: translateX(8%);\r\n\t}\r\n\t65%{\r\n\t\ttransform: translateX(-4%);\r\n\t}\r\n\t80%{\r\n\t\ttransform: translateX(4%);\r\n\t}\r\n\t95%{\r\n\t\ttransform: translateX(-2%);\r\n\t}\r\n\t100% {\r\n\t\ttransform: translateX(0%);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes slideRight {\r\n\t0% {\r\n\t\t-webkit-transform: translateX(-150%);\r\n\t}\r\n\t50%{\r\n\t\t-webkit-transform: translateX(8%);\r\n\t}\r\n\t65%{\r\n\t\t-webkit-transform: translateX(-4%);\r\n\t}\r\n\t80%{\r\n\t\t-webkit-transform: translateX(4%);\r\n\t}\r\n\t95%{\r\n\t\t-webkit-transform: translateX(-2%);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: translateX(0%);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nslideExpandUp\r\n==============================================\r\n*/\r\n\r\n\r\n.slideExpandUp{\r\n\tanimation-name: slideExpandUp;\r\n\t-webkit-animation-name: slideExpandUp;\r\n\r\n\tanimation-duration: 1.6s;\r\n\t-webkit-animation-duration: 1.6s;\r\n\r\n\tanimation-timing-function: ease-out;\r\n\t-webkit-animation-timing-function: ease -out;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes slideExpandUp {\r\n\t0% {\r\n\t\ttransform: translateY(100%) scaleX(0.5);\r\n\t}\r\n\t30%{\r\n\t\ttransform: translateY(-8%) scaleX(0.5);\r\n\t}\r\n\t40%{\r\n\t\ttransform: translateY(2%) scaleX(0.5);\r\n\t}\r\n\t50%{\r\n\t\ttransform: translateY(0%) scaleX(1.1);\r\n\t}\r\n\t60%{\r\n\t\ttransform: translateY(0%) scaleX(0.9);\r\n\t}\r\n\t70% {\r\n\t\ttransform: translateY(0%) scaleX(1.05);\r\n\t}\r\n\t80%{\r\n\t\ttransform: translateY(0%) scaleX(0.95);\r\n\t}\r\n\t90% {\r\n\t\ttransform: translateY(0%) scaleX(1.02);\r\n\t}\r\n\t100%{\r\n\t\ttransform: translateY(0%) scaleX(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes slideExpandUp {\r\n\t0% {\r\n\t\t-webkit-transform: translateY(100%) scaleX(0.5);\r\n\t}\r\n\t30%{\r\n\t\t-webkit-transform: translateY(-8%) scaleX(0.5);\r\n\t}\r\n\t40%{\r\n\t\t-webkit-transform: translateY(2%) scaleX(0.5);\r\n\t}\r\n\t50%{\r\n\t\t-webkit-transform: translateY(0%) scaleX(1.1);\r\n\t}\r\n\t60%{\r\n\t\t-webkit-transform: translateY(0%) scaleX(0.9);\r\n\t}\r\n\t70% {\r\n\t\t-webkit-transform: translateY(0%) scaleX(1.05);\r\n\t}\r\n\t80%{\r\n\t\t-webkit-transform: translateY(0%) scaleX(0.95);\r\n\t}\r\n\t90% {\r\n\t\t-webkit-transform: translateY(0%) scaleX(1.02);\r\n\t}\r\n\t100%{\r\n\t\t-webkit-transform: translateY(0%) scaleX(1);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nexpandUp\r\n==============================================\r\n*/\r\n\r\n\r\n.expandUp{\r\n\tanimation-name: expandUp;\r\n\t-webkit-animation-name: expandUp;\r\n\r\n\tanimation-duration: 0.7s;\r\n\t-webkit-animation-duration: 0.7s;\r\n\r\n\tanimation-timing-function: ease;\r\n\t-webkit-animation-timing-function: ease;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes expandUp {\r\n\t0% {\r\n\t\ttransform: translateY(100%) scale(0.6) scaleY(0.5);\r\n\t}\r\n\t60%{\r\n\t\ttransform: translateY(-7%) scaleY(1.12);\r\n\t}\r\n\t75%{\r\n\t\ttransform: translateY(3%);\r\n\t}\r\n\t100% {\r\n\t\ttransform: translateY(0%) scale(1) scaleY(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes expandUp {\r\n\t0% {\r\n\t\t-webkit-transform: translateY(100%) scale(0.6) scaleY(0.5);\r\n\t}\r\n\t60%{\r\n\t\t-webkit-transform: translateY(-7%) scaleY(1.12);\r\n\t}\r\n\t75%{\r\n\t\t-webkit-transform: translateY(3%);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: translateY(0%) scale(1) scaleY(1);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nfadeIn\r\n==============================================\r\n*/\r\n\r\n.fadeIn{\r\n\tanimation-name: fadeIn;\r\n\t-webkit-animation-name: fadeIn;\r\n\r\n\tanimation-duration: 1.5s;\r\n\t-webkit-animation-duration: 1.5s;\r\n\r\n\tanimation-timing-function: ease-in-out;\r\n\t-webkit-animation-timing-function: ease-in-out;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes fadeIn {\r\n\t0% {\r\n\t\ttransform: scale(0);\r\n\t\topacity: 0.0;\r\n\t}\r\n\t60% {\r\n\t\ttransform: scale(1.1);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scale(0.9);\r\n\t\topacity: 1;\r\n\t}\r\n\t100% {\r\n\t\ttransform: scale(1);\r\n\t\topacity: 1;\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes fadeIn {\r\n\t0% {\r\n\t\t-webkit-transform: scale(0);\r\n\t\topacity: 0.0;\r\n\t}\r\n\t60% {\r\n\t\t-webkit-transform: scale(1.1);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scale(0.9);\r\n\t\topacity: 1;\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scale(1);\r\n\t\topacity: 1;\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nexpandOpen\r\n==============================================\r\n*/\r\n\r\n\r\n.expandOpen{\r\n\tanimation-name: expandOpen;\r\n\t-webkit-animation-name: expandOpen;\r\n\r\n\tanimation-duration: 1.2s;\r\n\t-webkit-animation-duration: 1.2s;\r\n\r\n\tanimation-timing-function: ease-out;\r\n\t-webkit-animation-timing-function: ease-out;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes expandOpen {\r\n\t0% {\r\n\t\ttransform: scale(1.8);\r\n\t}\r\n\t50% {\r\n\t\ttransform: scale(0.95);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scale(1.05);\r\n\t}\r\n\t90% {\r\n\t\ttransform: scale(0.98);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scale(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes expandOpen {\r\n\t0% {\r\n\t\t-webkit-transform: scale(1.8);\r\n\t}\r\n\t50% {\r\n\t\t-webkit-transform: scale(0.95);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scale(1.05);\r\n\t}\r\n\t90% {\r\n\t\t-webkit-transform: scale(0.98);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scale(1);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nbigEntrance\r\n==============================================\r\n*/\r\n\r\n\r\n.bigEntrance{\r\n\tanimation-name: bigEntrance;\r\n\t-webkit-animation-name: bigEntrance;\r\n\r\n\tanimation-duration: 1.6s;\r\n\t-webkit-animation-duration: 1.6s;\r\n\r\n\tanimation-timing-function: ease-out;\r\n\t-webkit-animation-timing-function: ease-out;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes bigEntrance {\r\n\t0% {\r\n\t\ttransform: scale(0.3) rotate(6deg) translateX(-30%) translateY(30%);\r\n\t\topacity: 0.2;\r\n\t}\r\n\t30% {\r\n\t\ttransform: scale(1.03) rotate(-2deg) translateX(2%) translateY(-2%);\r\n\t\topacity: 1;\r\n\t}\r\n\t45% {\r\n\t\ttransform: scale(0.98) rotate(1deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t60% {\r\n\t\ttransform: scale(1.01) rotate(-1deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t75% {\r\n\t\ttransform: scale(0.99) rotate(1deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t90% {\r\n\t\ttransform: scale(1.01) rotate(0deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t100% {\r\n\t\ttransform: scale(1) rotate(0deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes bigEntrance {\r\n\t0% {\r\n\t\t-webkit-transform: scale(0.3) rotate(6deg) translateX(-30%) translateY(30%);\r\n\t\topacity: 0.2;\r\n\t}\r\n\t30% {\r\n\t\t-webkit-transform: scale(1.03) rotate(-2deg) translateX(2%) translateY(-2%);\r\n\t\topacity: 1;\r\n\t}\r\n\t45% {\r\n\t\t-webkit-transform: scale(0.98) rotate(1deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t60% {\r\n\t\t-webkit-transform: scale(1.01) rotate(-1deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t75% {\r\n\t\t-webkit-transform: scale(0.99) rotate(1deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t90% {\r\n\t\t-webkit-transform: scale(1.01) rotate(0deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scale(1) rotate(0deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nhatch\r\n==============================================\r\n*/\r\n\r\n.hatch{\r\n\tanimation-name: hatch;\r\n\t-webkit-animation-name: hatch;\r\n\r\n\tanimation-duration: 2s;\r\n\t-webkit-animation-duration: 2s;\r\n\r\n\tanimation-timing-function: ease-in-out;\r\n\t-webkit-animation-timing-function: ease-in-out;\r\n\r\n\ttransform-origin: 50% 100%;\r\n\t-ms-transform-origin: 50% 100%;\r\n\t-webkit-transform-origin: 50% 100%;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes hatch {\r\n\t0% {\r\n\t\ttransform: rotate(0deg) scaleY(0.6);\r\n\t}\r\n\t20% {\r\n\t\ttransform: rotate(-2deg) scaleY(1.05);\r\n\t}\r\n\t35% {\r\n\t\ttransform: rotate(2deg) scaleY(1);\r\n\t}\r\n\t50% {\r\n\t\ttransform: rotate(-2deg);\r\n\t}\r\n\t65% {\r\n\t\ttransform: rotate(1deg);\r\n\t}\r\n\t80% {\r\n\t\ttransform: rotate(-1deg);\r\n\t}\r\n\t100% {\r\n\t\ttransform: rotate(0deg);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes hatch {\r\n\t0% {\r\n\t\t-webkit-transform: rotate(0deg) scaleY(0.6);\r\n\t}\r\n\t20% {\r\n\t\t-webkit-transform: rotate(-2deg) scaleY(1.05);\r\n\t}\r\n\t35% {\r\n\t\t-webkit-transform: rotate(2deg) scaleY(1);\r\n\t}\r\n\t50% {\r\n\t\t-webkit-transform: rotate(-2deg);\r\n\t}\r\n\t65% {\r\n\t\t-webkit-transform: rotate(1deg);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: rotate(-1deg);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: rotate(0deg);\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n==============================================\r\nbounce\r\n==============================================\r\n*/\r\n\r\n\r\n.bounce{\r\n\tanimation-name: bounce;\r\n\t-webkit-animation-name: bounce;\r\n\r\n\tanimation-duration: 1.6s;\r\n\t-webkit-animation-duration: 1.6s;\r\n\r\n\tanimation-timing-function: ease;\r\n\t-webkit-animation-timing-function: ease;\r\n\r\n\ttransform-origin: 50% 100%;\r\n\t-ms-transform-origin: 50% 100%;\r\n\t-webkit-transform-origin: 50% 100%;\r\n}\r\n\r\n@keyframes bounce {\r\n\t0% {\r\n\t\ttransform: translateY(0%) scaleY(0.6);\r\n\t}\r\n\t60%{\r\n\t\ttransform: translateY(-100%) scaleY(1.1);\r\n\t}\r\n\t70%{\r\n\t\ttransform: translateY(0%) scaleY(0.95) scaleX(1.05);\r\n\t}\r\n\t80%{\r\n\t\ttransform: translateY(0%) scaleY(1.05) scaleX(1);\r\n\t}\r\n\t90%{\r\n\t\ttransform: translateY(0%) scaleY(0.95) scaleX(1);\r\n\t}\r\n\t100%{\r\n\t\ttransform: translateY(0%) scaleY(1) scaleX(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes bounce {\r\n\t0% {\r\n\t\t-webkit-transform: translateY(0%) scaleY(0.6);\r\n\t}\r\n\t60%{\r\n\t\t-webkit-transform: translateY(-100%) scaleY(1.1);\r\n\t}\r\n\t70%{\r\n\t\t-webkit-transform: translateY(0%) scaleY(0.95) scaleX(1.05);\r\n\t}\r\n\t80%{\r\n\t\t-webkit-transform: translateY(0%) scaleY(1.05) scaleX(1);\r\n\t}\r\n\t90%{\r\n\t\t-webkit-transform: translateY(0%) scaleY(0.95) scaleX(1);\r\n\t}\r\n\t100%{\r\n\t\t-webkit-transform: translateY(0%) scaleY(1) scaleX(1);\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n==============================================\r\npulse\r\n==============================================\r\n*/\r\n\r\n.pulse{\r\n\tanimation-name: pulse;\r\n\t-webkit-animation-name: pulse;\r\n\r\n\tanimation-duration: 1.5s;\r\n\t-webkit-animation-duration: 1.5s;\r\n\r\n\tanimation-iteration-count: infinite;\r\n\t-webkit-animation-iteration-count: infinite;\r\n}\r\n\r\n@keyframes pulse {\r\n\t0% {\r\n\t\ttransform: scale(0.9);\r\n\t\topacity: 0.7;\r\n\t}\r\n\t50% {\r\n\t\ttransform: scale(1);\r\n\t\topacity: 1;\r\n\t}\r\n\t100% {\r\n\t\ttransform: scale(0.9);\r\n\t\topacity: 0.7;\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes pulse {\r\n\t0% {\r\n\t\t-webkit-transform: scale(0.95);\r\n\t\topacity: 0.7;\r\n\t}\r\n\t50% {\r\n\t\t-webkit-transform: scale(1);\r\n\t\topacity: 1;\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scale(0.95);\r\n\t\topacity: 0.7;\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nfloating\r\n==============================================\r\n*/\r\n\r\n.floating{\r\n\tanimation-name: floating;\r\n\t-webkit-animation-name: floating;\r\n\r\n\tanimation-duration: 1.5s;\r\n\t-webkit-animation-duration: 1.5s;\r\n\r\n\tanimation-iteration-count: infinite;\r\n\t-webkit-animation-iteration-count: infinite;\r\n}\r\n\r\n@keyframes floating {\r\n\t0% {\r\n\t\ttransform: translateY(0%);\r\n\t}\r\n\t50% {\r\n\t\ttransform: translateY(8%);\r\n\t}\r\n\t100% {\r\n\t\ttransform: translateY(0%);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes floating {\r\n\t0% {\r\n\t\t-webkit-transform: translateY(0%);\r\n\t}\r\n\t50% {\r\n\t\t-webkit-transform: translateY(8%);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: translateY(0%);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\ntossing\r\n==============================================\r\n*/\r\n\r\n.tossing{\r\n\tanimation-name: tossing;\r\n\t-webkit-animation-name: tossing;\r\n\r\n\tanimation-duration: 2.5s;\r\n\t-webkit-animation-duration: 2.5s;\r\n\r\n\tanimation-iteration-count: infinite;\r\n\t-webkit-animation-iteration-count: infinite;\r\n}\r\n\r\n@keyframes tossing {\r\n\t0% {\r\n\t\ttransform: rotate(-4deg);\r\n\t}\r\n\t50% {\r\n\t\ttransform: rotate(4deg);\r\n\t}\r\n\t100% {\r\n\t\ttransform: rotate(-4deg);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes tossing {\r\n\t0% {\r\n\t\t-webkit-transform: rotate(-4deg);\r\n\t}\r\n\t50% {\r\n\t\t-webkit-transform: rotate(4deg);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: rotate(-4deg);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\npullUp\r\n==============================================\r\n*/\r\n\r\n.pullUp{\r\n\tanimation-name: pullUp;\r\n\t-webkit-animation-name: pullUp;\r\n\r\n\tanimation-duration: 1.1s;\r\n\t-webkit-animation-duration: 1.1s;\r\n\r\n\tanimation-timing-function: ease-out;\r\n\t-webkit-animation-timing-function: ease-out;\r\n\r\n\ttransform-origin: 50% 100%;\r\n\t-ms-transform-origin: 50% 100%;\r\n\t-webkit-transform-origin: 50% 100%;\r\n}\r\n\r\n@keyframes pullUp {\r\n\t0% {\r\n\t\ttransform: scaleY(0.1);\r\n\t}\r\n\t40% {\r\n\t\ttransform: scaleY(1.02);\r\n\t}\r\n\t60% {\r\n\t\ttransform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleY(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes pullUp {\r\n\t0% {\r\n\t\t-webkit-transform: scaleY(0.1);\r\n\t}\r\n\t40% {\r\n\t\t-webkit-transform: scaleY(1.02);\r\n\t}\r\n\t60% {\r\n\t\t-webkit-transform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleY(1);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\npullDown\r\n==============================================\r\n*/\r\n\r\n.pullDown{\r\n\tanimation-name: pullDown;\r\n\t-webkit-animation-name: pullDown;\r\n\r\n\tanimation-duration: 1.1s;\r\n\t-webkit-animation-duration: 1.1s;\r\n\r\n\tanimation-timing-function: ease-out;\r\n\t-webkit-animation-timing-function: ease-out;\r\n\r\n\ttransform-origin: 50% 0%;\r\n\t-ms-transform-origin: 50% 0%;\r\n\t-webkit-transform-origin: 50% 0%;\r\n}\r\n\r\n@keyframes pullDown {\r\n\t0% {\r\n\t\ttransform: scaleY(0.1);\r\n\t}\r\n\t40% {\r\n\t\ttransform: scaleY(1.02);\r\n\t}\r\n\t60% {\r\n\t\ttransform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleY(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes pullDown {\r\n\t0% {\r\n\t\t-webkit-transform: scaleY(0.1);\r\n\t}\r\n\t40% {\r\n\t\t-webkit-transform: scaleY(1.02);\r\n\t}\r\n\t60% {\r\n\t\t-webkit-transform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleY(1);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nstretchLeft\r\n==============================================\r\n*/\r\n\r\n.stretchLeft{\r\n\tanimation-name: stretchLeft;\r\n\t-webkit-animation-name: stretchLeft;\r\n\r\n\tanimation-duration: 1.5s;\r\n\t-webkit-animation-duration: 1.5s;\r\n\r\n\tanimation-timing-function: ease-out;\r\n\t-webkit-animation-timing-function: ease-out;\r\n\r\n\ttransform-origin: 100% 0%;\r\n\t-ms-transform-origin: 100% 0%;\r\n\t-webkit-transform-origin: 100% 0%;\r\n}\r\n\r\n@keyframes stretchLeft {\r\n\t0% {\r\n\t\ttransform: scaleX(0.3);\r\n\t}\r\n\t40% {\r\n\t\ttransform: scaleX(1.02);\r\n\t}\r\n\t60% {\r\n\t\ttransform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleX(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes stretchLeft {\r\n\t0% {\r\n\t\t-webkit-transform: scaleX(0.3);\r\n\t}\r\n\t40% {\r\n\t\t-webkit-transform: scaleX(1.02);\r\n\t}\r\n\t60% {\r\n\t\t-webkit-transform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleX(1);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nstretchRight\r\n==============================================\r\n*/\r\n\r\n.stretchRight{\r\n\tanimation-name: stretchRight;\r\n\t-webkit-animation-name: stretchRight;\r\n\r\n\tanimation-duration: 1.5s;\r\n\t-webkit-animation-duration: 1.5s;\r\n\r\n\tanimation-timing-function: ease-out;\r\n\t-webkit-animation-timing-function: ease-out;\r\n\r\n\ttransform-origin: 0% 0%;\r\n\t-ms-transform-origin: 0% 0%;\r\n\t-webkit-transform-origin: 0% 0%;\r\n}\r\n\r\n@keyframes stretchRight {\r\n\t0% {\r\n\t\ttransform: scaleX(0.3);\r\n\t}\r\n\t40% {\r\n\t\ttransform: scaleX(1.02);\r\n\t}\r\n\t60% {\r\n\t\ttransform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleX(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes stretchRight {\r\n\t0% {\r\n\t\t-webkit-transform: scaleX(0.3);\r\n\t}\r\n\t40% {\r\n\t\t-webkit-transform: scaleX(1.02);\r\n\t}\r\n\t60% {\r\n\t\t-webkit-transform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleX(1);\r\n\t}\r\n}", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/editor.css":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/editor.css ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".editor-left {\r\n  overflow: scroll;\r\n  display: flex;\r\n  flex-flow: column;\r\n  justify-content: flex-start;\r\n  align-content: center;\r\n  height: 85vh;\r\n  width: 100%;\r\n  padding: 2px;\r\n}\r\n\r\n.editor-left.card > .card-footer > .card-btn {\r\n  width: 48%;\r\n}\r\n\r\n.editor-right {\r\n  background: white;\r\n  border: 1px dashed green;\r\n  width: 90%;\r\n  overflow-y: scroll;\r\n  height: 85vh;\r\n  padding: 10px;\r\n  display: flex;\r\n  flex-flow: column;\r\n  justify-content: flex-start;\r\n}\r\n\r\n.editor-input {\r\n  width: 100%;\r\n  line-height: 20px;\r\n}\r\n\r\n.editor-text {\r\n  height: 500px;\r\n  margin-bottom: 10px;\r\n}\r\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/index.css":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/index.css ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports
exports.push([module.i, "@import url(https://fonts.googleapis.com/css?family=Rubik);", ""]);
exports.push([module.i, "@import url(https://fonts.googleapis.com/css?family=Inconsolata);", ""]);
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./animations.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/animations.css"), "");
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./slideshow.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/slideshow.css"), "");
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./editor.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/editor.css"), "");
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./modal.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/modal.css"), "");
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./preview.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/preview.css"), "");
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./slides.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/slides.css"), "");
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./presentations.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/presentations.css"), "");
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./toolbar.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/toolbar.css"), "");

// module
exports.push([module.i, "/* index.css */\r\n\r\n\r\n* {\r\n  box-sizing: border-box;\r\n}\r\n\r\n\r\nbody,\r\nhtml {\r\n  padding: 0;\r\n  margin: 0;\r\n  display: flex;\r\n  flex-direction: column;\r\n  font-family: \"Rubik\", \"Inconsolata\", sans-serif;\r\n}\r\n\r\n.main {\r\n  display: grid;\r\n  grid-template-areas: \"toolbar\" \"body\";\r\n}\r\n\r\n.container {\r\n\r\n  padding: 4px;\r\n  display: flex;\r\n  flex-flow: column;\r\n  justify-content: flex-start;\r\n  align-content: flex-start;\r\n}\r\n\r\n.card {\r\n  position: relative;\r\n  display: flex;\r\n  flex-flow: column;\r\n  justify-content: stretch;\r\n  min-width: 200px;\r\n  max-width: 300px;\r\n  height: fit-content;\r\n  margin: 10px;\r\n  border-radius: 2%;\r\n  background-color: rgba(44, 62, 80, 1);\r\n  box-shadow: 1px 1px 2px 1px #95a5a6;\r\n  color: rgba(236,240,241 ,1);\r\n}\r\n\r\n.card-header {\r\n  max-height: 100px;\r\n  width: 100%;\r\n  padding: 4px;\r\n  background-color: rgba(44, 62, 80, 1);\r\n  border-bottom: 1px #34495e;\r\n  display: flex;\r\n  justify-content: space-around;\r\n  align-content: center;\r\n}\r\n\r\n.card-body {\r\n  max-height: 200px;\r\n  width: 100%;\r\n  padding: 2px;\r\n  background-color: rgba(44, 62, 80, 1);\r\n  border-bottom: 1px #34495e;\r\n}\r\n\r\n.card:hover .card-delete {\r\n  opacity: 1;\r\n}\r\n\r\n.card-footer {\r\n  max-height: 100px;\r\n  width: 100%;\r\n  padding: 2px;\r\n  background-color: rgba(44, 62, 80, 1);\r\n  display: flex;\r\n  flex-flow: wrap;\r\n  justify-content: space-between;\r\n  align-content: center;\r\n}\r\n\r\n.card-delete {\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n  position: absolute;\r\n  top: -5px;\r\n  right: -5px;\r\n  width: 20px;\r\n  height: 20px;\r\n  border-radius: 50%;\r\n  opacity: 0;\r\n  cursor: pointer;\r\n}\r\n\r\n.card-delete:before {\r\n  font-size: 10px;\r\n  content: \"X\";\r\n}\r\n\r\n.card-delete:hover {\r\n  background-color: #e74c3c;\r\n  color: rgba(44, 62, 80, 1);\r\n}\r\n\r\n.card-btn {\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n  height: 40px;\r\n  margin: 2px;\r\n  padding: 10px;\r\n  border-radius: 2px;\r\n  cursor: pointer;\r\n  font-size: 18px;\r\n  transition: all 0.2s;\r\n  display: flex;\r\n  flex-flow: wrap;\r\n}\r\n\r\n.card-btn:hover {\r\n  background-color: rgba(189,195,199,1);\r\n   color: rgba(44, 62, 80, 1);\r\n}\r\n\r\n.lang-js {\r\n  display: block;\r\n  padding: 20px;\r\n  font-size: 17px;\r\n  line-height: 1.2em;\r\n  background: rgba(44, 62, 80, 1);\r\n  color: rgba(39, 174, 96, 1);\r\n  border-radius: 6px;\r\n  font-family: Inconsolata;\r\n}\r\n\r\n.lang-html {\r\n  font-family: code;\r\n  background: rgba(44, 62, 80, 1);\r\n  background: linear-gradient(180deg, #ccc 0, #ccc 1.2em, #eee 0);\r\n  color: rgba(41, 128, 185, 1);\r\n}\r\n\r\n.full-width {\r\n  width: 100%;\r\n}\r\n\r\n@media only screen and (min-width: 600px) {\r\n  .container {\r\n    flex-flow: row;\r\n  }\r\n}\r\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/modal.css":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/modal.css ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".modal-container {\r\n  position:absolute;\r\n  width: 100%;\r\n  height: 100%;\r\n  background: rgba(44, 62, 80,.9);\r\n  display: flex;\r\n  flex-flow: column;\r\n  justify-content: center;\r\n  z-index: 10;\r\n}\r\n\r\n\r\n.modal-container > .card {\r\n  margin: 0 auto;\r\n}\r\n\r\n.modal-content {\r\n  display: flex;\r\n  flex-flow: column;\r\n  justify-content: center;\r\n  align-content: center;\r\n  width: 80%;\r\n}\r\n\r\n.modal-label {\r\n\r\n}\r\n\r\n.modal-input {\r\n\r\n}\r\n\r\n.modal-close {\r\n  width: 200px;\r\n  height: 40px;\r\n  background: white;\r\n}\r\n\r\n.modal-close:before {\r\n  content: 'Cancel'\r\n}\r\n\r\n.modal-saveBtn {\r\n\r\n}\r\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/presentations.css":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/presentations.css ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "\r\n@keyframes fadeIn {\r\n  0% {\r\n    opacity: 0;\r\n  }\r\n\r\n  100% {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n@keyframes fadeOut {\r\n  0% {\r\n    opacity: 1;\r\n  }\r\n\r\n  100% {\r\n    opacity: 0;\r\n  }\r\n}\r\n\r\n\r\n.presentations {\r\n  animation: fadeIn .5s ease-in-out;\r\n}\r\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/preview.css":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/preview.css ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".preview {\r\n  width: 200px;\r\n  height: 200px;\r\n  margin: 12px;\r\n  overflow: hidden;\r\n}\r\n\r\n.card.preview {\r\n  cursor: grab;\r\n}\r\n\r\n.preview > .card-header {\r\n  background: transparent;\r\n}\r\n\r\n.preview > .card-body {\r\n  position: absolute;\r\n  background: transparent;\r\n}\r\n\r\n.preview > .card-body > * {\r\n  opacity: 0.1;\r\n}\r\n\r\n.preview-delete {\r\n  top: 4px;\r\n  right: 4px;\r\n  z-index: 3;\r\n  cursor: pointer;\r\n}\r\n\r\n.preview-delete:before {\r\n  padding-left: 4px;\r\n}\r\n\r\n.slidePosition {\r\n  color: #e67e22;\r\n  font-size: 6rem;\r\n}\r\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/slides.css":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/slides.css ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".slides {\r\n  justify-content: space-evenly;\r\n  animation: fadeIn 0.5s ease-in-out;\r\n}\r\n\r\n.left-drag {\r\n  grid-area: left-drag;\r\n  display: flex;\r\n  flex-flow: column;\r\n  order: 1;\r\n  border: 1px dashed rgba(44, 62, 80, 0.3);\r\n  height: 88vh;\r\n}\r\n\r\n.left-drag .card:hover {\r\n  cursor: grab;\r\n}\r\n\r\n.right-drag {\r\n  order: 2;\r\n  grid-area: right-drag;\r\n  flex-flow: wrap;\r\n  display: flex;\r\n  min-width: 100%;\r\n  border: 1px dashed rgba(44, 62, 80, 0.3);\r\n}\r\n\r\n.isDragging {\r\n  background: rgba(44, 62, 80, 0.3);\r\n  box-shadow: inset 0 0 1px rgba(44, 62, 80, 1);\r\n}\r\n\r\n.drop {\r\n  cursor: drop;\r\n}\r\n\r\n@media only screen and (min-width: 600px) {\r\n  .slides {\r\n    display: inline-grid;\r\n    grid-template-areas: \"left-drag right-drag\";\r\n    grid-template-columns: 1fr 2fr;\r\n    max-height: 90vh;\r\n  }\r\n}\r\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/slideshow.css":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/slideshow.css ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".slideshow {\r\n  height: 90vh;\r\n  width: 90%;\r\n  margin: 0 auto;\r\n  background: white;\r\n  outline: 0;\r\n}\r\n\r\n.slidecard {\r\n  animation: stretchRight 1s ease-in-out both;\r\n  outline: 0;\r\n}\r\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/toolbar.css":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/toolbar.css ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".toolbar {\r\n  display: flex;\r\n  flex-flow: column;\r\n  line-height: 2;\r\n  background: #ecf0f1;\r\n  padding: 2px;\r\n}\r\n\r\n.toolbar-left {\r\n  order: 1;\r\n  grid-area: toolbar-left;\r\n  display: flex;\r\n  flex-flow: wrap;\r\n  justify-content: space-between;\r\n}\r\n\r\n\r\n.toolbar-right {\r\n  order: 2;\r\n  grid-area: toolbar-right;\r\n  display: flex;\r\n  flex-flow: wrap;\r\n  justify-content: space-between;\r\n}\r\n\r\n.toolbar-item {\r\n  text-decoration: none;\r\n  color: rgba(44, 62, 80,1);\r\n  margin: 2px;\r\n  padding: 10px;\r\n  border-radius:2px;\r\n  cursor: pointer;\r\n  transition: all .5s;\r\n}\r\n\r\n.toolbar-item:hover {\r\n  background-color: rgba(44, 62, 80,1);\r\n  color: rgba(236, 240, 241,1.0);\r\n}\r\n\r\n@media only screen and (min-width: 600px) {\r\n  .toolbar {\r\n    display: inline-grid;\r\n    grid-template-areas: \"toolbar-left toolbar-right\";\r\n    line-height: 2;\r\n    background: rgba(236, 240, 241,1.0);\r\n    padding: 2px;\r\n  }\r\n}", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/index.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./task */ "./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/task.js");


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/task.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/task.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate, process) {


/**
 * A helper for delaying the execution of a function.
 * @private
 * @summary (Any... -> Any) -> Void
 */
var delayed = typeof setImmediate !== 'undefined'?  setImmediate
            : typeof process !== 'undefined'?       process.nextTick
            : /* otherwise */                       setTimeout

/**
 * @module lib/task
 */
module.exports = Task;

// -- Implementation ---------------------------------------------------

/**
 * The `Task[Î±, Î²]` structure represents values that depend on time. This
 * allows one to model time-based effects explicitly, such that one can have
 * full knowledge of when they're dealing with delayed computations, latency,
 * or anything that can not be computed immediately.
 *
 * A common use for this structure is to replace the usual Continuation-Passing
 * Style form of programming, in order to be able to compose and sequence
 * time-dependent effects using the generic and powerful monadic operations.
 *
 * @class
 * @summary
 * ((Î± â Void), (Î² â Void) â Void), (Void â Void) â Task[Î±, Î²]
 *
 * Task[Î±, Î²] <: Chain[Î²]
 *               , Monad[Î²]
 *               , Functor[Î²]
 *               , Applicative[Î²]
 *               , Semigroup[Î²]
 *               , Monoid[Î²]
 *               , Show
 */
function Task(computation, cleanup) {
  this.fork = computation;

  this.cleanup = cleanup || function() {};
}

/**
 * Constructs a new `Task[Î±, Î²]` containing the single value `Î²`.
 *
 * `Î²` can be any value, including `null`, `undefined`, or another
 * `Task[Î±, Î²]` structure.
 *
 * @summary Î² â Task[Î±, Î²]
 */
Task.prototype.of = function _of(b) {
  return new Task(function(_, resolve) {
    return resolve(b);
  });
};

Task.of = Task.prototype.of;

/**
 * Constructs a new `Task[Î±, Î²]` containing the single value `Î±`.
 *
 * `Î±` can be any value, including `null`, `undefined`, or another
 * `Task[Î±, Î²]` structure.
 *
 * @summary Î± â Task[Î±, Î²]
 */
Task.prototype.rejected = function _rejected(a) {
  return new Task(function(reject) {
    return reject(a);
  });
};

Task.rejected = Task.prototype.rejected;

// -- Functor ----------------------------------------------------------

/**
 * Transforms the successful value of the `Task[Î±, Î²]` using a regular unary
 * function.
 *
 * @summary @Task[Î±, Î²] => (Î² â Î³) â Task[Î±, Î³]
 */
Task.prototype.map = function _map(f) {
  var fork = this.fork;
  var cleanup = this.cleanup;

  return new Task(function(reject, resolve) {
    return fork(function(a) {
      return reject(a);
    }, function(b) {
      return resolve(f(b));
    });
  }, cleanup);
};

// -- Chain ------------------------------------------------------------

/**
 * Transforms the succesful value of the `Task[Î±, Î²]` using a function to a
 * monad.
 *
 * @summary @Task[Î±, Î²] => (Î² â Task[Î±, Î³]) â Task[Î±, Î³]
 */
Task.prototype.chain = function _chain(f) {
  var fork = this.fork;
  var cleanup = this.cleanup;

  return new Task(function(reject, resolve) {
    return fork(function(a) {
      return reject(a);
    }, function(b) {
      return f(b).fork(reject, resolve);
    });
  }, cleanup);
};

// -- Apply ------------------------------------------------------------

/**
 * Applys the successful value of the `Task[Î±, (Î² â Î³)]` to the successful
 * value of the `Task[Î±, Î²]`
 *
 * @summary @Task[Î±, (Î² â Î³)] => Task[Î±, Î²] â Task[Î±, Î³]
 */

Task.prototype.ap = function _ap(that) {
  var forkThis = this.fork;
  var forkThat = that.fork;
  var cleanupThis = this.cleanup;
  var cleanupThat = that.cleanup;

  function cleanupBoth(state) {
    cleanupThis(state[0]);
    cleanupThat(state[1]);
  }

  return new Task(function(reject, resolve) {
    var func, funcLoaded = false;
    var val, valLoaded = false;
    var rejected = false;
    var allState;

    var thisState = forkThis(guardReject, guardResolve(function(x) {
      funcLoaded = true;
      func = x;
    }));

    var thatState = forkThat(guardReject, guardResolve(function(x) {
      valLoaded = true;
      val = x;
    }));

    function guardResolve(setter) {
      return function(x) {
        if (rejected) {
          return;
        }

        setter(x);
        if (funcLoaded && valLoaded) {
          delayed(function(){ cleanupBoth(allState) });
          return resolve(func(val));
        } else {
          return x;
        }
      }
    }

    function guardReject(x) {
      if (!rejected) {
        rejected = true;
        return reject(x);
      }
    }

    return allState = [thisState, thatState];
  }, cleanupBoth);
};

// -- Semigroup ------------------------------------------------------------

/**
 * Selects the earlier of the two tasks `Task[Î±, Î²]`
 *
 * @summary @Task[Î±, Î²] => Task[Î±, Î²] â Task[Î±, Î²]
 */

Task.prototype.concat = function _concat(that) {
  var forkThis = this.fork;
  var forkThat = that.fork;
  var cleanupThis = this.cleanup;
  var cleanupThat = that.cleanup;

  function cleanupBoth(state) {
    cleanupThis(state[0]);
    cleanupThat(state[1]);
  }

  return new Task(function(reject, resolve) {
    var done = false;
    var allState;
    var thisState = forkThis(guard(reject), guard(resolve));
    var thatState = forkThat(guard(reject), guard(resolve));

    return allState = [thisState, thatState];

    function guard(f) {
      return function(x) {
        if (!done) {
          done = true;
          delayed(function(){ cleanupBoth(allState) })
          return f(x);
        }
      };
    }
  }, cleanupBoth);

};

// -- Monoid ------------------------------------------------------------

/**
 * Returns a Task that will never resolve
 *
 * @summary Void â Task[Î±, _]
 */
Task.empty = function _empty() {
  return new Task(function() {});
};

Task.prototype.empty = Task.empty;

// -- Show -------------------------------------------------------------

/**
 * Returns a textual representation of the `Task[Î±, Î²]`
 *
 * @summary @Task[Î±, Î²] => Void â String
 */
Task.prototype.toString = function _toString() {
  return 'Task';
};

// -- Extracting and recovering ----------------------------------------

/**
 * Transforms a failure value into a new `Task[Î±, Î²]`. Does nothing if the
 * structure already contains a successful value.
 *
 * @summary @Task[Î±, Î²] => (Î± â Task[Î³, Î²]) â Task[Î³, Î²]
 */
Task.prototype.orElse = function _orElse(f) {
  var fork = this.fork;
  var cleanup = this.cleanup;

  return new Task(function(reject, resolve) {
    return fork(function(a) {
      return f(a).fork(reject, resolve);
    }, function(b) {
      return resolve(b);
    });
  }, cleanup);
};

// -- Folds and extended transformations -------------------------------

/**
 * Catamorphism. Takes two functions, applies the leftmost one to the failure
 * value, and the rightmost one to the successful value, depending on which one
 * is present.
 *
 * @summary @Task[Î±, Î²] => (Î± â Î³), (Î² â Î³) â Task[Î´, Î³]
 */
Task.prototype.fold = function _fold(f, g) {
  var fork = this.fork;
  var cleanup = this.cleanup;

  return new Task(function(reject, resolve) {
    return fork(function(a) {
      return resolve(f(a));
    }, function(b) {
      return resolve(g(b));
    });
  }, cleanup);
};

/**
 * Catamorphism.
 *
 * @summary @Task[Î±, Î²] => { Rejected: Î± â Î³, Resolved: Î² â Î³ } â Task[Î´, Î³]
 */
Task.prototype.cata = function _cata(pattern) {
  return this.fold(pattern.Rejected, pattern.Resolved);
};

/**
 * Swaps the disjunction values.
 *
 * @summary @Task[Î±, Î²] => Void â Task[Î², Î±]
 */
Task.prototype.swap = function _swap() {
  var fork = this.fork;
  var cleanup = this.cleanup;

  return new Task(function(reject, resolve) {
    return fork(function(a) {
      return resolve(a);
    }, function(b) {
      return reject(b);
    });
  }, cleanup);
};

/**
 * Maps both sides of the disjunction.
 *
 * @summary @Task[Î±, Î²] => (Î± â Î³), (Î² â Î´) â Task[Î³, Î´]
 */
Task.prototype.bimap = function _bimap(f, g) {
  var fork = this.fork;
  var cleanup = this.cleanup;

  return new Task(function(reject, resolve) {
    return fork(function(a) {
      return reject(f(a));
    }, function(b) {
      return resolve(g(b));
    });
  }, cleanup);
};

/**
 * Maps the left side of the disjunction (failure).
 *
 * @summary @Task[Î±, Î²] => (Î± â Î³) â Task[Î³, Î²]
 */
Task.prototype.rejectedMap = function _rejectedMap(f) {
  var fork = this.fork;
  var cleanup = this.cleanup;

  return new Task(function(reject, resolve) {
    return fork(function(a) {
      return reject(f(a));
    }, function(b) {
      return resolve(b);
    });
  }, cleanup);
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../timers-browserify/2.0.10/node_modules/timers-browserify/main.js */ "./node_modules/.registry.npmjs.org/timers-browserify/2.0.10/node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../../../../process/0.11.10/node_modules/process/browser.js */ "./node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril-stream/1.1.0/node_modules/mithril-stream/stream.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril-stream/1.1.0/node_modules/mithril-stream/stream.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable */
;(function() {
"use strict"
/* eslint-enable */

var guid = 0, HALT = {}
function createStream() {
	function stream() {
		if (arguments.length > 0 && arguments[0] !== HALT) updateStream(stream, arguments[0])
		return stream._state.value
	}
	initStream(stream)

	if (arguments.length > 0 && arguments[0] !== HALT) updateStream(stream, arguments[0])

	return stream
}
function initStream(stream) {
	stream.constructor = createStream
	stream._state = {id: guid++, value: undefined, state: 0, derive: undefined, recover: undefined, deps: {}, parents: [], endStream: undefined, unregister: undefined}
	stream.map = stream["fantasy-land/map"] = map, stream["fantasy-land/ap"] = ap, stream["fantasy-land/of"] = createStream
	stream.valueOf = valueOf, stream.toJSON = toJSON, stream.toString = valueOf

	Object.defineProperties(stream, {
		end: {get: function() {
			if (!stream._state.endStream) {
				var endStream = createStream()
				endStream.map(function(value) {
					if (value === true) {
						unregisterStream(stream)
						endStream._state.unregister = function(){unregisterStream(endStream)}
					}
					return value
				})
				stream._state.endStream = endStream
			}
			return stream._state.endStream
		}}
	})
}
function updateStream(stream, value) {
	updateState(stream, value)
	for (var id in stream._state.deps) updateDependency(stream._state.deps[id], false)
	if (stream._state.unregister != null) stream._state.unregister()
	finalize(stream)
}
function updateState(stream, value) {
	stream._state.value = value
	stream._state.changed = true
	if (stream._state.state !== 2) stream._state.state = 1
}
function updateDependency(stream, mustSync) {
	var state = stream._state, parents = state.parents
	if (parents.length > 0 && parents.every(active) && (mustSync || parents.some(changed))) {
		var value = stream._state.derive()
		if (value === HALT) return false
		updateState(stream, value)
	}
}
function finalize(stream) {
	stream._state.changed = false
	for (var id in stream._state.deps) stream._state.deps[id]._state.changed = false
}

function combine(fn, streams) {
	if (!streams.every(valid)) throw new Error("Ensure that each item passed to stream.combine/stream.merge is a stream")
	return initDependency(createStream(), streams, function() {
		return fn.apply(this, streams.concat([streams.filter(changed)]))
	})
}

function initDependency(dep, streams, derive) {
	var state = dep._state
	state.derive = derive
	state.parents = streams.filter(notEnded)

	registerDependency(dep, state.parents)
	updateDependency(dep, true)

	return dep
}
function registerDependency(stream, parents) {
	for (var i = 0; i < parents.length; i++) {
		parents[i]._state.deps[stream._state.id] = stream
		registerDependency(stream, parents[i]._state.parents)
	}
}
function unregisterStream(stream) {
	for (var i = 0; i < stream._state.parents.length; i++) {
		var parent = stream._state.parents[i]
		delete parent._state.deps[stream._state.id]
	}
	for (var id in stream._state.deps) {
		var dependent = stream._state.deps[id]
		var index = dependent._state.parents.indexOf(stream)
		if (index > -1) dependent._state.parents.splice(index, 1)
	}
	stream._state.state = 2 //ended
	stream._state.deps = {}
}

function map(fn) {return combine(function(stream) {return fn(stream())}, [this])}
function ap(stream) {return combine(function(s1, s2) {return s1()(s2())}, [stream, this])}
function valueOf() {return this._state.value}
function toJSON() {return this._state.value != null && typeof this._state.value.toJSON === "function" ? this._state.value.toJSON() : this._state.value}

function valid(stream) {return stream._state }
function active(stream) {return stream._state.state === 1}
function changed(stream) {return stream._state.changed}
function notEnded(stream) {return stream._state.state !== 2}

function merge(streams) {
	return combine(function() {
		return streams.map(function(s) {return s()})
	}, streams)
}

function scan(reducer, seed, stream) {
	var newStream = combine(function (s) {
		return seed = reducer(seed, s._state.value)
	}, [stream])

	if (newStream._state.state === 0) newStream(seed)

	return newStream
}

function scanMerge(tuples, seed) {
	var streams = tuples.map(function(tuple) {
		var stream = tuple[0]
		if (stream._state.state === 0) stream(undefined)
		return stream
	})

	var newStream = combine(function() {
		var changed = arguments[arguments.length - 1]

		streams.forEach(function(stream, idx) {
			if (changed.indexOf(stream) > -1) {
				seed = tuples[idx][1](seed, stream._state.value)
			}
		})

		return seed
	}, streams)

	return newStream
}

createStream["fantasy-land/of"] = createStream
createStream.merge = merge
createStream.combine = combine
createStream.scan = scan
createStream.scanMerge = scanMerge
createStream.HALT = HALT

if (true) module["exports"] = createStream
else {}

}());


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/mount.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/mount.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Vnode = __webpack_require__(/*! ../render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")

module.exports = function(redrawService) {
	return function(root, component) {
		if (component === null) {
			redrawService.unsubscribe(root)
		} else if (component.view == null && typeof component !== "function") {
			throw new Error("m.mount(element, component) expects a component, not a vnode")
		} else {
			redrawService.subscribe(root, function() { return Vnode(component) })
		}
	}
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/redraw.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/redraw.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var coreRenderer = __webpack_require__(/*! ../render/render */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/render.js")

function throttle(callback) {
	var pending = null
	return function() {
		if (pending === null) {
			pending = requestAnimationFrame(function() {
				pending = null
				callback()
			})
		}
	}
}

module.exports = function($window, throttleMock) {
	var renderService = coreRenderer($window)
	var subscriptions = []
	var rendering = false

	function run(sub) {
		var vnode = sub.c(sub)
		if (vnode !== sub) renderService.render(sub.k, vnode)
	}
	function subscribe(key, callback, onremove) {
		var sub = {k: key, c: callback, r: onremove}
		unsubscribe(key)
		subscriptions.push(sub)
		var vnode = sub.c(sub)
		if (vnode !== sub) renderService.render(sub.k, vnode)
	}
	function unsubscribe(key) {
		for (var i = 0; i < subscriptions.length; i++) {
			var sub = subscriptions[i]
			if (sub.k === key) {
				subscriptions.splice(i, 1)
				renderService.render(sub.k, [])
				if (typeof sub.r === "function") sub.r()
				break
			}
		}
	}
	function sync() {
		if (rendering) throw new Error("Nested m.redraw.sync() call")
		rendering = true
		for (var i = 0; i < subscriptions.length; i++) {
			try { run(subscriptions[i]) }
			catch (e) { if (typeof console !== "undefined") console.error(e) }
		}
		rendering = false
	}

	var redraw = (throttleMock || throttle)(sync)
	redraw.sync = sync
	renderService.setRedraw(redraw)
	return {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/router.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/router.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Vnode = __webpack_require__(/*! ../render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")
var Promise = __webpack_require__(/*! ../promise/promise */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/promise.js")
var coreRouter = __webpack_require__(/*! ../router/router */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/router/router.js")

var sentinel = {}

module.exports = function($window, redrawService) {
	var routeService = coreRouter($window)

	var currentResolver = sentinel, component, attrs, currentPath, lastUpdate
	var route = function(root, defaultRoute, routes) {
		if (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined")
		var init = false
		var bail = function(path) {
			if (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})
			else throw new Error("Could not resolve default route " + defaultRoute)
		}
		function run() {
			init = true
			if (sentinel !== currentResolver) {
				var vnode = Vnode(component, attrs.key, attrs)
				if (currentResolver) vnode = currentResolver.render(vnode)
				return vnode
			}
		}
		routeService.defineRoutes(routes, function(payload, params, path, route) {
			var update = lastUpdate = function(routeResolver, comp) {
				if (update !== lastUpdate) return
				component = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div"
				attrs = params, currentPath = path, lastUpdate = null
				currentResolver = routeResolver.render ? routeResolver : null
				if (init) redrawService.redraw()
				else {
					init = true
					redrawService.redraw.sync()
				}
			}
			if (payload.view || typeof payload === "function") update({}, payload)
			else {
				if (payload.onmatch) {
					Promise.resolve(payload.onmatch(params, path, route)).then(function(resolved) {
						update(payload, resolved)
					}, function () { bail(path) })
				}
				else update(payload, "div")
			}
		}, bail, defaultRoute, function (unsubscribe) {
			redrawService.subscribe(root, function(sub) {
				sub.c = run
				return sub
			}, unsubscribe)
		})
	}
	route.set = function(path, data, options) {
		if (lastUpdate != null) {
			options = options || {}
			options.replace = true
		}
		lastUpdate = null
		routeService.setPath(path, data, options)
	}
	route.get = function() {return currentPath}
	route.prefix = function(prefix) {routeService.prefix = prefix}
	var link = function(options, vnode) {
		vnode.dom.setAttribute("href", routeService.prefix + vnode.attrs.href)
		vnode.dom.onclick = function(e) {
			if (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return
			e.preventDefault()
			e.redraw = false
			var href = this.getAttribute("href")
			if (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)
			route.set(href, undefined, options)
		}
	}
	route.link = function(args) {
		if (args.tag == null) return link.bind(link, args)
		return link({}, args)
	}
	route.param = function(key) {
		if(typeof attrs !== "undefined" && typeof key !== "undefined") return attrs[key]
		return attrs
	}

	return route
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/hyperscript.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/hyperscript.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hyperscript = __webpack_require__(/*! ./render/hyperscript */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/hyperscript.js")

hyperscript.trust = __webpack_require__(/*! ./render/trust */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/trust.js")
hyperscript.fragment = __webpack_require__(/*! ./render/fragment */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/fragment.js")

module.exports = hyperscript


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hyperscript = __webpack_require__(/*! ./hyperscript */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/hyperscript.js")
var m = function m() { return hyperscript.apply(this, arguments) }
m.m = hyperscript
m.trust = hyperscript.trust
m.fragment = hyperscript.fragment

var requestService = __webpack_require__(/*! ./request */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/request.js")
var redrawService = __webpack_require__(/*! ./redraw */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/redraw.js")

requestService.setCompletionCallback(redrawService.redraw)

m.mount = __webpack_require__(/*! ./mount */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/mount.js")
m.route = __webpack_require__(/*! ./route */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/route.js")
m.render = __webpack_require__(/*! ./render */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render.js").render
m.redraw = redrawService.redraw
m.request = requestService.request
m.jsonp = requestService.jsonp
m.parseQueryString = __webpack_require__(/*! ./querystring/parse */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/parse.js")
m.buildQueryString = __webpack_require__(/*! ./querystring/build */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/build.js")
m.parsePathname = __webpack_require__(/*! ./pathname/parse */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/parse.js")
m.buildPathname = __webpack_require__(/*! ./pathname/build */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/build.js")
m.version = __webpack_require__(/*! ./package.json */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/package.json").version
m.vnode = __webpack_require__(/*! ./render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")
m.PromisePolyfill = __webpack_require__(/*! ./promise/polyfill */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/polyfill.js")

module.exports = m


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/mount.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/mount.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redrawService = __webpack_require__(/*! ./redraw */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/redraw.js")

module.exports = __webpack_require__(/*! ./api/mount */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/mount.js")(redrawService)


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/package.json":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/package.json ***!
  \***********************************************************************************************/
/*! exports provided: name, version, description, author, license, unpkg, repository, scripts, devDependencies, bin, lint-staged, dependencies, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"mithril\",\"version\":\"2.0.0-rc.7\",\"description\":\"A framework for building brilliant applications\",\"author\":\"Leo Horie\",\"license\":\"MIT\",\"unpkg\":\"mithril.min.js\",\"repository\":\"MithrilJS/mithril.js\",\"scripts\":{\"dev\":\"node bundler/cli browser.js -output mithril.js -watch\",\"build\":\"npm run build-browser & npm run build-min\",\"build-browser\":\"node bundler/cli browser.js -output mithril.js\",\"build-min\":\"node bundler/cli browser.js -output mithril.min.js -minify\",\"precommit\":\"lint-staged\",\"lintdocs\":\"node docs/lint\",\"gendocs\":\"node docs/generate\",\"lint\":\"eslint . || true\",\"lint:fix\":\"eslint . --fix\",\"perf\":\"node performance/test-perf.js\",\"test\":\"node ospec/bin/ospec\",\"posttest\":\"npm run lint\",\"cover\":\"istanbul cover --print both ospec/bin/ospec\",\"release\":\"npm version -m 'v%s'\",\"preversion\":\"npm run test\",\"version\":\"npm run build && git add mithril.js mithril.min.js\",\"postversion\":\"git push --follow-tags\"},\"devDependencies\":{\"@alrra/travis-scripts\":\"^3.0.1\",\"benchmark\":\"^2.1.4\",\"chokidar\":\"^2.0.4\",\"dedent\":\"^0.7.0\",\"eslint\":\"^5.13.0\",\"gh-pages\":\"^2.0.1\",\"istanbul\":\"^0.4.5\",\"lint-staged\":\"^8.1.3\",\"locater\":\"^1.3.0\",\"marked\":\"^0.6.2\",\"pinpoint\":\"^1.1.0\",\"terser\":\"^3.16.1\"},\"bin\":{\"ospec\":\"./ospec/bin/ospec\"},\"lint-staged\":{\"*.js\":[\"eslint . --fix\",\"git add\"]},\"dependencies\":{}}");

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/assign.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/assign.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Object.assign || function(target, source) {
	if(source) Object.keys(source).forEach(function(key) { target[key] = source[key] })
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/build.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/build.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var buildQueryString = __webpack_require__(/*! ../querystring/build */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/build.js")
var assign = __webpack_require__(/*! ./assign */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/assign.js")

// Returns `path` from `template` + `params`
module.exports = function(template, params) {
	if ((/:([^\/\.-]+)(\.{3})?:/).test(template)) {
		throw new SyntaxError("Template parameter names *must* be separated")
	}
	if (params == null) return template
	var queryIndex = template.indexOf("?")
	var hashIndex = template.indexOf("#")
	var queryEnd = hashIndex < 0 ? template.length : hashIndex
	var pathEnd = queryIndex < 0 ? queryEnd : queryIndex
	var path = template.slice(0, pathEnd)
	var query = {}

	assign(query, params)

	var resolved = path.replace(/:([^\/\.-]+)(\.{3})?/g, function(m, key, variadic) {
		delete query[key]
		// If no such parameter exists, don't interpolate it.
		if (params[key] == null) return m
		// Escape normal parameters, but not variadic ones.
		return variadic ? params[key] : encodeURIComponent(String(params[key]))
	})

	// In case the template substitution adds new query/hash parameters.
	var newQueryIndex = resolved.indexOf("?")
	var newHashIndex = resolved.indexOf("#")
	var newQueryEnd = newHashIndex < 0 ? resolved.length : newHashIndex
	var newPathEnd = newQueryIndex < 0 ? newQueryEnd : newQueryIndex
	var result = resolved.slice(0, newPathEnd)

	if (queryIndex >= 0) result += template.slice(queryIndex, queryEnd)
	if (newQueryIndex >= 0) result += (queryIndex < 0 ? "?" : "&") + resolved.slice(newQueryIndex, newQueryEnd)
	var querystring = buildQueryString(query)
	if (querystring) result += (queryIndex < 0 && newQueryIndex < 0 ? "?" : "&") + querystring
	if (hashIndex >= 0) result += template.slice(hashIndex)
	if (newHashIndex >= 0) result += (hashIndex < 0 ? "" : "&") + resolved.slice(newHashIndex)
	return result
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/compileTemplate.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/compileTemplate.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var parsePathname = __webpack_require__(/*! ./parse */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/parse.js")

// Compiles a template into a function that takes a resolved path (without query
// strings) and returns an object containing the template parameters with their
// parsed values. This expects the input of the compiled template to be the
// output of `parsePathname`. Note that it does *not* remove query parameters
// specified in the template.
module.exports = function(template) {
	var templateData = parsePathname(template)
	var templateKeys = Object.keys(templateData.params)
	var keys = []
	var regexp = new RegExp("^" + templateData.path.replace(
		// I escape literal text so people can use things like `:file.:ext` or
		// `:lang-:locale` in routes. This is all merged into one pass so I
		// don't also accidentally escape `-` and make it harder to detect it to
		// ban it from template parameters.
		/:([^\/.-]+)(\.{3}|\.(?!\.)|-)?|[\\^$*+.()|\[\]{}]/g,
		function(m, key, extra) {
			if (key == null) return "\\" + m
			keys.push({k: key, r: extra === "..."})
			if (extra === "...") return "(.*)"
			if (extra === ".") return "([^/]+)\\."
			return "([^/]+)" + (extra || "")
		}
	) + "$")
	return function(data) {
		// First, check the params. Usually, there isn't any, and it's just
		// checking a static set.
		for (var i = 0; i < templateKeys.length; i++) {
			if (templateData.params[templateKeys[i]] !== data.params[templateKeys[i]]) return false
		}
		// If no interpolations exist, let's skip all the ceremony
		if (!keys.length) return regexp.test(data.path)
		var values = regexp.exec(data.path)
		if (values == null) return false
		for (var i = 0; i < keys.length; i++) {
			data.params[keys[i].k] = keys[i].r ? values[i + 1] : decodeURIComponent(values[i + 1])
		}
		return true
	}
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/parse.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/parse.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var parseQueryString = __webpack_require__(/*! ../querystring/parse */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/parse.js")

// Returns `{path, params}` from `url`
module.exports = function(url) {
	var queryIndex = url.indexOf("?")
	var hashIndex = url.indexOf("#")
	var queryEnd = hashIndex < 0 ? url.length : hashIndex
	var pathEnd = queryIndex < 0 ? queryEnd : queryIndex
	var path = url.slice(0, pathEnd).replace(/\/{2,}/g, "/")

	if (!path) path = "/"
	else {
		if (path[0] !== "/") path = "/" + path
		if (path.length > 1 && path[path.length - 1] === "/") path = path.slice(0, -1)
	}
	return {
		path: path,
		params: queryIndex < 0
			? {}
			: parseQueryString(url.slice(queryIndex + 1, queryEnd)),
	}
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/polyfill.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/polyfill.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {
/** @constructor */
var PromisePolyfill = function(executor) {
	if (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`")
	if (typeof executor !== "function") throw new TypeError("executor must be a function")

	var self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)
	var instance = self._instance = {resolvers: resolvers, rejectors: rejectors}
	var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout
	function handler(list, shouldAbsorb) {
		return function execute(value) {
			var then
			try {
				if (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
					if (value === self) throw new TypeError("Promise can't be resolved w/ itself")
					executeOnce(then.bind(value))
				}
				else {
					callAsync(function() {
						if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value)
						for (var i = 0; i < list.length; i++) list[i](value)
						resolvers.length = 0, rejectors.length = 0
						instance.state = shouldAbsorb
						instance.retry = function() {execute(value)}
					})
				}
			}
			catch (e) {
				rejectCurrent(e)
			}
		}
	}
	function executeOnce(then) {
		var runs = 0
		function run(fn) {
			return function(value) {
				if (runs++ > 0) return
				fn(value)
			}
		}
		var onerror = run(rejectCurrent)
		try {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}
	}

	executeOnce(executor)
}
PromisePolyfill.prototype.then = function(onFulfilled, onRejection) {
	var self = this, instance = self._instance
	function handle(callback, list, next, state) {
		list.push(function(value) {
			if (typeof callback !== "function") next(value)
			else try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}
		})
		if (typeof instance.retry === "function" && state === instance.state) instance.retry()
	}
	var resolveNext, rejectNext
	var promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})
	handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)
	return promise
}
PromisePolyfill.prototype.catch = function(onRejection) {
	return this.then(null, onRejection)
}
PromisePolyfill.prototype.finally = function(callback) {
	return this.then(
		function(value) {
			return PromisePolyfill.resolve(callback()).then(function() {
				return value
			})
		},
		function(reason) {
			return PromisePolyfill.resolve(callback()).then(function() {
				return PromisePolyfill.reject(reason);
			})
		}
	)
}
PromisePolyfill.resolve = function(value) {
	if (value instanceof PromisePolyfill) return value
	return new PromisePolyfill(function(resolve) {resolve(value)})
}
PromisePolyfill.reject = function(value) {
	return new PromisePolyfill(function(resolve, reject) {reject(value)})
}
PromisePolyfill.all = function(list) {
	return new PromisePolyfill(function(resolve, reject) {
		var total = list.length, count = 0, values = []
		if (list.length === 0) resolve([])
		else for (var i = 0; i < list.length; i++) {
			(function(i) {
				function consume(value) {
					count++
					values[i] = value
					if (count === total) resolve(values)
				}
				if (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
					list[i].then(consume, reject)
				}
				else consume(list[i])
			})(i)
		}
	})
}
PromisePolyfill.race = function(list) {
	return new PromisePolyfill(function(resolve, reject) {
		for (var i = 0; i < list.length; i++) {
			list[i].then(resolve, reject)
		}
	})
}

module.exports = PromisePolyfill

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../timers-browserify/2.0.10/node_modules/timers-browserify/main.js */ "./node_modules/.registry.npmjs.org/timers-browserify/2.0.10/node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/promise.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/promise.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var PromisePolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/polyfill.js")

if (typeof window !== "undefined") {
	if (typeof window.Promise === "undefined") {
		window.Promise = PromisePolyfill
	} else if (!window.Promise.prototype.finally) {
		window.Promise.prototype.finally = PromisePolyfill.prototype.finally
	}
	module.exports = window.Promise
} else if (typeof global !== "undefined") {
	if (typeof global.Promise === "undefined") {
		global.Promise = PromisePolyfill
	} else if (!global.Promise.prototype.finally) {
		global.Promise.prototype.finally = PromisePolyfill.prototype.finally
	}
	module.exports = global.Promise
} else {
	module.exports = PromisePolyfill
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/4.35.3_webpack@4.35.3/node_modules/webpack/buildin/global.js */ "./node_modules/.registry.npmjs.org/webpack/4.35.3_webpack@4.35.3/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/build.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/build.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function(object) {
	if (Object.prototype.toString.call(object) !== "[object Object]") return ""

	var args = []
	for (var key in object) {
		destructure(key, object[key])
	}

	return args.join("&")

	function destructure(key, value) {
		if (Array.isArray(value)) {
			for (var i = 0; i < value.length; i++) {
				destructure(key + "[" + i + "]", value[i])
			}
		}
		else if (Object.prototype.toString.call(value) === "[object Object]") {
			for (var i in value) {
				destructure(key + "[" + i + "]", value[i])
			}
		}
		else args.push(encodeURIComponent(key) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""))
	}
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/parse.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/parse.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// The extra `data` parameter is for if you want to append to an existing
// parameters object.
module.exports = function(string) {
	if (string === "" || string == null) return {}
	if (string.charAt(0) === "?") string = string.slice(1)

	var entries = string.split("&"), counters = {}, data = {}
	for (var i = 0; i < entries.length; i++) {
		var entry = entries[i].split("=")
		var key = decodeURIComponent(entry[0])
		var value = entry.length === 2 ? decodeURIComponent(entry[1]) : ""

		if (value === "true") value = true
		else if (value === "false") value = false

		var levels = key.split(/\]\[?|\[/)
		var cursor = data
		if (key.indexOf("[") > -1) levels.pop()
		for (var j = 0; j < levels.length; j++) {
			var level = levels[j], nextLevel = levels[j + 1]
			var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10))
			var isValue = j === levels.length - 1
			if (level === "") {
				var key = levels.slice(0, j).join()
				if (counters[key] == null) {
					counters[key] = Array.isArray(cursor) ? cursor.length : 0
				}
				level = counters[key]++
			}
			if (isValue) cursor[level] = value
			else if (cursor[level] == null) cursor[level] = isNumber ? [] : {}
			cursor = cursor[level]
		}
	}
	return data
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/redraw.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/redraw.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./api/redraw */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/redraw.js")(window)


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./render/render */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/render.js")(window)


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/fragment.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/fragment.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Vnode = __webpack_require__(/*! ../render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")
var hyperscriptVnode = __webpack_require__(/*! ./hyperscriptVnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/hyperscriptVnode.js")

module.exports = function() {
	var vnode = hyperscriptVnode.apply(0, arguments)

	vnode.tag = "["
	vnode.children = Vnode.normalizeChildren(vnode.children)
	return vnode
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/hyperscript.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/hyperscript.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Vnode = __webpack_require__(/*! ../render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")
var hyperscriptVnode = __webpack_require__(/*! ./hyperscriptVnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/hyperscriptVnode.js")

var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g
var selectorCache = {}
var hasOwn = {}.hasOwnProperty

function isEmpty(object) {
	for (var key in object) if (hasOwn.call(object, key)) return false
	return true
}

function compileSelector(selector) {
	var match, tag = "div", classes = [], attrs = {}
	while (match = selectorParser.exec(selector)) {
		var type = match[1], value = match[2]
		if (type === "" && value !== "") tag = value
		else if (type === "#") attrs.id = value
		else if (type === ".") classes.push(value)
		else if (match[3][0] === "[") {
			var attrValue = match[6]
			if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\")
			if (match[4] === "class") classes.push(attrValue)
			else attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true
		}
	}
	if (classes.length > 0) attrs.className = classes.join(" ")
	return selectorCache[selector] = {tag: tag, attrs: attrs}
}

function execSelector(state, vnode) {
	var attrs = vnode.attrs
	var children = Vnode.normalizeChildren(vnode.children)
	var hasClass = hasOwn.call(attrs, "class")
	var className = hasClass ? attrs.class : attrs.className

	vnode.tag = state.tag
	vnode.attrs = null
	vnode.children = undefined

	if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
		var newAttrs = {}

		for (var key in attrs) {
			if (hasOwn.call(attrs, key)) newAttrs[key] = attrs[key]
		}

		attrs = newAttrs
	}

	for (var key in state.attrs) {
		if (hasOwn.call(state.attrs, key) && key !== "className" && !hasOwn.call(attrs, key)){
			attrs[key] = state.attrs[key]
		}
	}
	if (className != null || state.attrs.className != null) attrs.className =
		className != null
			? state.attrs.className != null
				? String(state.attrs.className) + " " + String(className)
				: className
			: state.attrs.className != null
				? state.attrs.className
				: null

	if (hasClass) attrs.class = null

	for (var key in attrs) {
		if (hasOwn.call(attrs, key) && key !== "key") {
			vnode.attrs = attrs
			break
		}
	}

	if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
		vnode.text = children[0].children
	} else {
		vnode.children = children
	}

	return vnode
}

function hyperscript(selector) {
	if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
		throw Error("The selector must be either a string or a component.");
	}

	var vnode = hyperscriptVnode.apply(1, arguments)

	if (typeof selector === "string") {
		vnode.children = Vnode.normalizeChildren(vnode.children)
		if (selector !== "[") return execSelector(selectorCache[selector] || compileSelector(selector), vnode)
	}

	vnode.tag = selector
	return vnode
}

module.exports = hyperscript


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/hyperscriptVnode.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/hyperscriptVnode.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Vnode = __webpack_require__(/*! ../render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")

// Call via `hyperscriptVnode.apply(startOffset, arguments)`
//
// The reason I do it this way, forwarding the arguments and passing the start
// offset in `this`, is so I don't have to create a temporary array in a
// performance-critical path.
//
// In native ES6, I'd instead add a final `...args` parameter to the
// `hyperscript` and `fragment` factories and define this as
// `hyperscriptVnode(...args)`, since modern engines do optimize that away. But
// ES5 (what Mithril requires thanks to IE support) doesn't give me that luxury,
// and engines aren't nearly intelligent enough to do either of these:
//
// 1. Elide the allocation for `[].slice.call(arguments, 1)` when it's passed to
//    another function only to be indexed.
// 2. Elide an `arguments` allocation when it's passed to any function other
//    than `Function.prototype.apply` or `Reflect.apply`.
//
// In ES6, it'd probably look closer to this (I'd need to profile it, though):
// module.exports = function(attrs, ...children) {
//     if (attrs == null || typeof attrs === "object" && attrs.tag == null && !Array.isArray(attrs)) {
//         if (children.length === 1 && Array.isArray(children[0])) children = children[0]
//     } else {
//         children = children.length === 0 && Array.isArray(attrs) ? attrs : [attrs, ...children]
//         attrs = undefined
//     }
//
//     if (attrs == null) attrs = {}
//     return Vnode("", attrs.key, attrs, children)
// }
module.exports = function() {
	var attrs = arguments[this], start = this + 1, children

	if (attrs == null) {
		attrs = {}
	} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
		attrs = {}
		start = this
	}

	if (arguments.length === start + 1) {
		children = arguments[start]
		if (!Array.isArray(children)) children = [children]
	} else {
		children = []
		while (start < arguments.length) children.push(arguments[start++])
	}

	return Vnode("", attrs.key, attrs, children)
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/render.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/render.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Vnode = __webpack_require__(/*! ../render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")

module.exports = function($window) {
	var $doc = $window.document

	var nameSpace = {
		svg: "http://www.w3.org/2000/svg",
		math: "http://www.w3.org/1998/Math/MathML"
	}

	var redraw
	function setRedraw(callback) {return redraw = callback}

	function getNameSpace(vnode) {
		return vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]
	}

	//sanity check to discourage people from doing `vnode.state = ...`
	function checkState(vnode, original) {
		if (vnode.state !== original) throw new Error("`vnode.state` must not be modified")
	}

	//Note: the hook is passed as the `this` argument to allow proxying the
	//arguments without requiring a full array allocation to do so. It also
	//takes advantage of the fact the current `vnode` is the first argument in
	//all lifecycle methods.
	function callHook(vnode) {
		var original = vnode.state
		try {
			return this.apply(original, arguments)
		} finally {
			checkState(vnode, original)
		}
	}

	// IE11 (at least) throws an UnspecifiedError when accessing document.activeElement when
	// inside an iframe. Catch and swallow this error, and heavy-handidly return null.
	function activeElement() {
		try {
			return $doc.activeElement
		} catch (e) {
			return null
		}
	}
	function validateKeys(vnodes, isKeyed) {
		// Note: this is a *very* perf-sensitive check.
		// Fun fact: merging the loop like this is somehow faster than splitting
		// it, noticeably so.
		for (var i = 1; i < vnodes.length; i++) {
			if ((vnodes[i] != null && vnodes[i].key != null) !== isKeyed) {
				throw new TypeError("Vnodes must either always have keys or never have keys!")
			}
		}
	}
	//create
	function createNodesChecked(parent, vnodes, hooks, nextSibling, ns) {
		if (vnodes.length) {
			validateKeys(vnodes, vnodes[0] != null && vnodes[0].key != null)
			createNodesUnchecked(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)
		}
	}
	function createNodesUnchecked(parent, vnodes, start, end, hooks, nextSibling, ns) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				createNode(parent, vnode, hooks, ns, nextSibling)
			}
		}
	}
	function createNode(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		if (typeof tag === "string") {
			vnode.state = {}
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
			switch (tag) {
				case "#": createText(parent, vnode, nextSibling); break
				case "<": createHTML(parent, vnode, ns, nextSibling); break
				case "[": createFragment(parent, vnode, hooks, ns, nextSibling); break
				default: createElement(parent, vnode, hooks, ns, nextSibling)
			}
		}
		else createComponent(parent, vnode, hooks, ns, nextSibling)
	}
	function createText(parent, vnode, nextSibling) {
		vnode.dom = $doc.createTextNode(vnode.children)
		insertNode(parent, vnode.dom, nextSibling)
	}
	var possibleParents = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}
	function createHTML(parent, vnode, ns, nextSibling) {
		var match = vnode.children.match(/^\s*?<(\w+)/im) || []
		// not using the proper parent makes the child element(s) vanish.
		//     var div = document.createElement("div")
		//     div.innerHTML = "<td>i</td><td>j</td>"
		//     console.log(div.innerHTML)
		// --> "ij", no <td> in sight.
		var temp = $doc.createElement(possibleParents[match[1]] || "div")
		if (ns === "http://www.w3.org/2000/svg") {
			temp.innerHTML = "<svg xmlns=\"http://www.w3.org/2000/svg\">" + vnode.children + "</svg>"
			temp = temp.firstChild
		} else {
			temp.innerHTML = vnode.children
		}
		vnode.dom = temp.firstChild
		vnode.domSize = temp.childNodes.length
		var fragment = $doc.createDocumentFragment()
		var child
		while (child = temp.firstChild) {
			fragment.appendChild(child)
		}
		insertNode(parent, fragment, nextSibling)
	}
	function createFragment(parent, vnode, hooks, ns, nextSibling) {
		var fragment = $doc.createDocumentFragment()
		if (vnode.children != null) {
			var children = vnode.children
			createNodesChecked(fragment, children, hooks, null, ns)
		}
		vnode.dom = fragment.firstChild
		vnode.domSize = fragment.childNodes.length
		insertNode(parent, fragment, nextSibling)
	}
	function createElement(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		var attrs = vnode.attrs
		var is = attrs && attrs.is

		ns = getNameSpace(vnode) || ns

		var element = ns ?
			is ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :
			is ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)
		vnode.dom = element

		if (attrs != null) {
			setAttrs(vnode, attrs, ns)
		}

		insertNode(parent, element, nextSibling)

		if (!maybeSetContentEditable(vnode)) {
			if (vnode.text != null) {
				if (vnode.text !== "") element.textContent = vnode.text
				else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			}
			if (vnode.children != null) {
				var children = vnode.children
				createNodesChecked(element, children, hooks, null, ns)
				if (vnode.tag === "select" && attrs != null) setLateSelectAttrs(vnode, attrs)
			}
		}
	}
	function initComponent(vnode, hooks) {
		var sentinel
		if (typeof vnode.tag.view === "function") {
			vnode.state = Object.create(vnode.tag)
			sentinel = vnode.state.view
			if (sentinel.$$reentrantLock$$ != null) return
			sentinel.$$reentrantLock$$ = true
		} else {
			vnode.state = void 0
			sentinel = vnode.tag
			if (sentinel.$$reentrantLock$$ != null) return
			sentinel.$$reentrantLock$$ = true
			vnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)
		}
		initLifecycle(vnode.state, vnode, hooks)
		if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
		vnode.instance = Vnode.normalize(callHook.call(vnode.state.view, vnode))
		if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
		sentinel.$$reentrantLock$$ = null
	}
	function createComponent(parent, vnode, hooks, ns, nextSibling) {
		initComponent(vnode, hooks)
		if (vnode.instance != null) {
			createNode(parent, vnode.instance, hooks, ns, nextSibling)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0
		}
		else {
			vnode.domSize = 0
		}
	}

	//update
	/**
	 * @param {Element|Fragment} parent - the parent element
	 * @param {Vnode[] | null} old - the list of vnodes of the last `render()` call for
	 *                               this part of the tree
	 * @param {Vnode[] | null} vnodes - as above, but for the current `render()` call.
	 * @param {Function[]} hooks - an accumulator of post-render hooks (oncreate/onupdate)
	 * @param {Element | null} nextSibling - the next DOM node if we're dealing with a
	 *                                       fragment that is not the last item in its
	 *                                       parent
	 * @param {'svg' | 'math' | String | null} ns) - the current XML namespace, if any
	 * @returns void
	 */
	// This function diffs and patches lists of vnodes, both keyed and unkeyed.
	//
	// We will:
	//
	// 1. describe its general structure
	// 2. focus on the diff algorithm optimizations
	// 3. discuss DOM node operations.

	// ## Overview:
	//
	// The updateNodes() function:
	// - deals with trivial cases
	// - determines whether the lists are keyed or unkeyed based on the first non-null node
	//   of each list.
	// - diffs them and patches the DOM if needed (that's the brunt of the code)
	// - manages the leftovers: after diffing, are there:
	//   - old nodes left to remove?
	// 	 - new nodes to insert?
	// 	 deal with them!
	//
	// The lists are only iterated over once, with an exception for the nodes in `old` that
	// are visited in the fourth part of the diff and in the `removeNodes` loop.

	// ## Diffing
	//
	// Reading https://github.com/localvoid/ivi/blob/ddc09d06abaef45248e6133f7040d00d3c6be853/packages/ivi/src/vdom/implementation.ts#L617-L837
	// may be good for context on longest increasing subsequence-based logic for moving nodes.
	//
	// In order to diff keyed lists, one has to
	//
	// 1) match nodes in both lists, per key, and update them accordingly
	// 2) create the nodes present in the new list, but absent in the old one
	// 3) remove the nodes present in the old list, but absent in the new one
	// 4) figure out what nodes in 1) to move in order to minimize the DOM operations.
	//
	// To achieve 1) one can create a dictionary of keys => index (for the old list), then iterate
	// over the new list and for each new vnode, find the corresponding vnode in the old list using
	// the map.
	// 2) is achieved in the same step: if a new node has no corresponding entry in the map, it is new
	// and must be created.
	// For the removals, we actually remove the nodes that have been updated from the old list.
	// The nodes that remain in that list after 1) and 2) have been performed can be safely removed.
	// The fourth step is a bit more complex and relies on the longest increasing subsequence (LIS)
	// algorithm.
	//
	// the longest increasing subsequence is the list of nodes that can remain in place. Imagine going
	// from `1,2,3,4,5` to `4,5,1,2,3` where the numbers are not necessarily the keys, but the indices
	// corresponding to the keyed nodes in the old list (keyed nodes `e,d,c,b,a` => `b,a,e,d,c` would
	//  match the above lists, for example).
	//
	// In there are two increasing subsequences: `4,5` and `1,2,3`, the latter being the longest. We
	// can update those nodes without moving them, and only call `insertNode` on `4` and `5`.
	//
	// @localvoid adapted the algo to also support node deletions and insertions (the `lis` is actually
	// the longest increasing subsequence *of old nodes still present in the new list*).
	//
	// It is a general algorithm that is fireproof in all circumstances, but it requires the allocation
	// and the construction of a `key => oldIndex` map, and three arrays (one with `newIndex => oldIndex`,
	// the `LIS` and a temporary one to create the LIS).
	//
	// So we cheat where we can: if the tails of the lists are identical, they are guaranteed to be part of
	// the LIS and can be updated without moving them.
	//
	// If two nodes are swapped, they are guaranteed not to be part of the LIS, and must be moved (with
	// the exception of the last node if the list is fully reversed).
	//
	// ## Finding the next sibling.
	//
	// `updateNode()` and `createNode()` expect a nextSibling parameter to perform DOM operations.
	// When the list is being traversed top-down, at any index, the DOM nodes up to the previous
	// vnode reflect the content of the new list, whereas the rest of the DOM nodes reflect the old
	// list. The next sibling must be looked for in the old list using `getNextSibling(... oldStart + 1 ...)`.
	//
	// In the other scenarios (swaps, upwards traversal, map-based diff),
	// the new vnodes list is traversed upwards. The DOM nodes at the bottom of the list reflect the
	// bottom part of the new vnodes list, and we can use the `v.dom`  value of the previous node
	// as the next sibling (cached in the `nextSibling` variable).


	// ## DOM node moves
	//
	// In most scenarios `updateNode()` and `createNode()` perform the DOM operations. However,
	// this is not the case if the node moved (second and fourth part of the diff algo). We move
	// the old DOM nodes before updateNode runs because it enables us to use the cached `nextSibling`
	// variable rather than fetching it using `getNextSibling()`.
	//
	// The fourth part of the diff currently inserts nodes unconditionally, leading to issues
	// like #1791 and #1999. We need to be smarter about those situations where adjascent old
	// nodes remain together in the new list in a way that isn't covered by parts one and
	// three of the diff algo.

	function updateNodes(parent, old, vnodes, hooks, nextSibling, ns) {
		if (old === vnodes || old == null && vnodes == null) return
		else if (old == null || old.length === 0) createNodesChecked(parent, vnodes, hooks, nextSibling, ns)
		else if (vnodes == null || vnodes.length === 0) removeNodes(old, 0, old.length)
		else {
			var isOldKeyed = old[0] != null && old[0].key != null
			var isKeyed = vnodes[0] != null && vnodes[0].key != null
			var start = 0, oldStart = 0
			validateKeys(vnodes, isKeyed)
			if (!isOldKeyed) while (oldStart < old.length && old[oldStart] == null) oldStart++
			if (!isKeyed) while (start < vnodes.length && vnodes[start] == null) start++
			if (isKeyed === null && isOldKeyed == null) return // both lists are full of nulls
			if (isOldKeyed !== isKeyed) {
				removeNodes(old, oldStart, old.length)
				createNodesUnchecked(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns)
			} else if (!isKeyed) {
				// Don't index past the end of either list (causes deopts).
				var commonLength = old.length < vnodes.length ? old.length : vnodes.length
				// Rewind if necessary to the first non-null index on either side.
				// We could alternatively either explicitly create or remove nodes when `start !== oldStart`
				// but that would be optimizing for sparse lists which are more rare than dense ones.
				start = start < oldStart ? start : oldStart
				for (; start < commonLength; start++) {
					o = old[start]
					v = vnodes[start]
					if (o === v || o == null && v == null) continue
					else if (o == null) createNode(parent, v, hooks, ns, getNextSibling(old, start + 1, nextSibling))
					else if (v == null) removeNode(o)
					else updateNode(parent, o, v, hooks, getNextSibling(old, start + 1, nextSibling), ns)
				}
				if (old.length > commonLength) removeNodes(old, start, old.length)
				if (vnodes.length > commonLength) createNodesUnchecked(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns)
			} else {
				// keyed diff
				var oldEnd = old.length - 1, end = vnodes.length - 1, map, o, v, oe, ve, topSibling

				// bottom-up
				while (oldEnd >= oldStart && end >= start) {
					oe = old[oldEnd]
					ve = vnodes[end]
					if (oe.key !== ve.key) break
					if (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)
					if (ve.dom != null) nextSibling = ve.dom
					oldEnd--, end--
				}
				// top-down
				while (oldEnd >= oldStart && end >= start) {
					o = old[oldStart]
					v = vnodes[start]
					if (o.key !== v.key) break
					oldStart++, start++
					if (o !== v) updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), ns)
				}
				// swaps and list reversals
				while (oldEnd >= oldStart && end >= start) {
					if (start === end) break
					if (o.key !== ve.key || oe.key !== v.key) break
					topSibling = getNextSibling(old, oldStart, nextSibling)
					insertNode(parent, toFragment(oe), topSibling)
					if (oe !== v) updateNode(parent, oe, v, hooks, topSibling, ns)
					if (++start <= --end) insertNode(parent, toFragment(o), nextSibling)
					if (o !== ve) updateNode(parent, o, ve, hooks, nextSibling, ns)
					if (ve.dom != null) nextSibling = ve.dom
					oldStart++; oldEnd--
					oe = old[oldEnd]
					ve = vnodes[end]
					o = old[oldStart]
					v = vnodes[start]
				}
				// bottom up once again
				while (oldEnd >= oldStart && end >= start) {
					if (oe.key !== ve.key) break
					if (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)
					if (ve.dom != null) nextSibling = ve.dom
					oldEnd--, end--
					oe = old[oldEnd]
					ve = vnodes[end]
				}
				if (start > end) removeNodes(old, oldStart, oldEnd + 1)
				else if (oldStart > oldEnd) createNodesUnchecked(parent, vnodes, start, end + 1, hooks, nextSibling, ns)
				else {
					// inspired by ivi https://github.com/ivijs/ivi/ by Boris Kaul
					var originalNextSibling = nextSibling, vnodesLength = end - start + 1, oldIndices = new Array(vnodesLength), li=0, i=0, pos = 2147483647, matched = 0, map, lisIndices
					for (i = 0; i < vnodesLength; i++) oldIndices[i] = -1
					for (i = end; i >= start; i--) {
						if (map == null) map = getKeyMap(old, oldStart, oldEnd + 1)
						ve = vnodes[i]
						var oldIndex = map[ve.key]
						if (oldIndex != null) {
							pos = (oldIndex < pos) ? oldIndex : -1 // becomes -1 if nodes were re-ordered
							oldIndices[i-start] = oldIndex
							oe = old[oldIndex]
							old[oldIndex] = null
							if (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)
							if (ve.dom != null) nextSibling = ve.dom
							matched++
						}
					}
					nextSibling = originalNextSibling
					if (matched !== oldEnd - oldStart + 1) removeNodes(old, oldStart, oldEnd + 1)
					if (matched === 0) createNodesUnchecked(parent, vnodes, start, end + 1, hooks, nextSibling, ns)
					else {
						if (pos === -1) {
							// the indices of the indices of the items that are part of the
							// longest increasing subsequence in the oldIndices list
							lisIndices = makeLisIndices(oldIndices)
							li = lisIndices.length - 1
							for (i = end; i >= start; i--) {
								v = vnodes[i]
								if (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling)
								else {
									if (lisIndices[li] === i - start) li--
									else insertNode(parent, toFragment(v), nextSibling)
								}
								if (v.dom != null) nextSibling = vnodes[i].dom
							}
						} else {
							for (i = end; i >= start; i--) {
								v = vnodes[i]
								if (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling)
								if (v.dom != null) nextSibling = vnodes[i].dom
							}
						}
					}
				}
			}
		}
	}
	function updateNode(parent, old, vnode, hooks, nextSibling, ns) {
		var oldTag = old.tag, tag = vnode.tag
		if (oldTag === tag) {
			vnode.state = old.state
			vnode.events = old.events
			if (shouldNotUpdate(vnode, old)) return
			if (typeof oldTag === "string") {
				if (vnode.attrs != null) {
					updateLifecycle(vnode.attrs, vnode, hooks)
				}
				switch (oldTag) {
					case "#": updateText(old, vnode); break
					case "<": updateHTML(parent, old, vnode, ns, nextSibling); break
					case "[": updateFragment(parent, old, vnode, hooks, nextSibling, ns); break
					default: updateElement(old, vnode, hooks, ns)
				}
			}
			else updateComponent(parent, old, vnode, hooks, nextSibling, ns)
		}
		else {
			removeNode(old)
			createNode(parent, vnode, hooks, ns, nextSibling)
		}
	}
	function updateText(old, vnode) {
		if (old.children.toString() !== vnode.children.toString()) {
			old.dom.nodeValue = vnode.children
		}
		vnode.dom = old.dom
	}
	function updateHTML(parent, old, vnode, ns, nextSibling) {
		if (old.children !== vnode.children) {
			toFragment(old)
			createHTML(parent, vnode, ns, nextSibling)
		}
		else vnode.dom = old.dom, vnode.domSize = old.domSize
	}
	function updateFragment(parent, old, vnode, hooks, nextSibling, ns) {
		updateNodes(parent, old.children, vnode.children, hooks, nextSibling, ns)
		var domSize = 0, children = vnode.children
		vnode.dom = null
		if (children != null) {
			for (var i = 0; i < children.length; i++) {
				var child = children[i]
				if (child != null && child.dom != null) {
					if (vnode.dom == null) vnode.dom = child.dom
					domSize += child.domSize || 1
				}
			}
			if (domSize !== 1) vnode.domSize = domSize
		}
	}
	function updateElement(old, vnode, hooks, ns) {
		var element = vnode.dom = old.dom
		ns = getNameSpace(vnode) || ns

		if (vnode.tag === "textarea") {
			if (vnode.attrs == null) vnode.attrs = {}
			if (vnode.text != null) {
				vnode.attrs.value = vnode.text //FIXME handle multiple children
				vnode.text = undefined
			}
		}
		updateAttrs(vnode, old.attrs, vnode.attrs, ns)
		if (!maybeSetContentEditable(vnode)) {
			if (old.text != null && vnode.text != null && vnode.text !== "") {
				if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text
			}
			else {
				if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]
				if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
				updateNodes(element, old.children, vnode.children, hooks, null, ns)
			}
		}
	}
	function updateComponent(parent, old, vnode, hooks, nextSibling, ns) {
		vnode.instance = Vnode.normalize(callHook.call(vnode.state.view, vnode))
		if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
		updateLifecycle(vnode.state, vnode, hooks)
		if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)
		if (vnode.instance != null) {
			if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)
			else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, ns)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.instance.domSize
		}
		else if (old.instance != null) {
			removeNode(old.instance)
			vnode.dom = undefined
			vnode.domSize = 0
		}
		else {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
		}
	}
	function getKeyMap(vnodes, start, end) {
		var map = Object.create(null)
		for (; start < end; start++) {
			var vnode = vnodes[start]
			if (vnode != null) {
				var key = vnode.key
				if (key != null) map[key] = start
			}
		}
		return map
	}
	// Lifted from ivi https://github.com/ivijs/ivi/
	// takes a list of unique numbers (-1 is special and can
	// occur multiple times) and returns an array with the indices
	// of the items that are part of the longest increasing
	// subsequece
	var lisTemp = []
	function makeLisIndices(a) {
		var result = [0]
		var u = 0, v = 0, i = 0
		var il = lisTemp.length = a.length
		for (var i = 0; i < il; i++) lisTemp[i] = a[i]
		for (var i = 0; i < il; ++i) {
			if (a[i] === -1) continue
			var j = result[result.length - 1]
			if (a[j] < a[i]) {
				lisTemp[i] = j
				result.push(i)
				continue
			}
			u = 0
			v = result.length - 1
			while (u < v) {
				// Fast integer average without overflow.
				// eslint-disable-next-line no-bitwise
				var c = (u >>> 1) + (v >>> 1) + (u & v & 1)
				if (a[result[c]] < a[i]) {
					u = c + 1
				}
				else {
					v = c
				}
			}
			if (a[i] < a[result[u]]) {
				if (u > 0) lisTemp[i] = result[u - 1]
				result[u] = i
			}
		}
		u = result.length
		v = result[u - 1]
		while (u-- > 0) {
			result[u] = v
			v = lisTemp[v]
		}
		lisTemp.length = 0
		return result
	}

	function toFragment(vnode) {
		var count = vnode.domSize
		if (count != null || vnode.dom == null) {
			var fragment = $doc.createDocumentFragment()
			if (count > 0) {
				var dom = vnode.dom
				while (--count) fragment.appendChild(dom.nextSibling)
				fragment.insertBefore(dom, fragment.firstChild)
			}
			return fragment
		}
		else return vnode.dom
	}
	function getNextSibling(vnodes, i, nextSibling) {
		for (; i < vnodes.length; i++) {
			if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom
		}
		return nextSibling
	}

	function insertNode(parent, dom, nextSibling) {
		if (nextSibling != null) parent.insertBefore(dom, nextSibling)
		else parent.appendChild(dom)
	}

	function maybeSetContentEditable(vnode) {
		if (vnode.attrs == null || (
			vnode.attrs.contenteditable == null && // attribute
			vnode.attrs.contentEditable == null // property
		)) return
		var children = vnode.children
		if (children != null && children.length === 1 && children[0].tag === "<") {
			var content = children[0].children
			if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content
		}
		else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")
	}

	//remove
	function removeNodes(vnodes, start, end) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) removeNode(vnode)
		}
	}
	function removeNode(vnode) {
		var expected = 1, called = 0
		var original = vnode.state
		if (typeof vnode.tag !== "string" && typeof vnode.state.onbeforeremove === "function") {
			var result = callHook.call(vnode.state.onbeforeremove, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
			var result = callHook.call(vnode.attrs.onbeforeremove, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		continuation()
		function continuation() {
			if (++called === expected) {
				checkState(vnode, original)
				onremove(vnode)
				if (vnode.dom) {
					var parent = vnode.dom.parentNode
					var count = vnode.domSize || 1
					while (--count) parent.removeChild(vnode.dom.nextSibling)
					parent.removeChild(vnode.dom)
				}
			}
		}
	}
	function onremove(vnode) {
		if (typeof vnode.tag !== "string" && typeof vnode.state.onremove === "function") callHook.call(vnode.state.onremove, vnode)
		if (vnode.attrs && typeof vnode.attrs.onremove === "function") callHook.call(vnode.attrs.onremove, vnode)
		if (typeof vnode.tag !== "string") {
			if (vnode.instance != null) onremove(vnode.instance)
		} else {
			var children = vnode.children
			if (Array.isArray(children)) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i]
					if (child != null) onremove(child)
				}
			}
		}
	}

	//attrs
	function setAttrs(vnode, attrs, ns) {
		for (var key in attrs) {
			setAttr(vnode, key, null, attrs[key], ns)
		}
	}
	function setAttr(vnode, key, old, value, ns) {
		if (key === "key" || key === "is" || value == null || isLifecycleMethod(key) || (old === value && !isFormAttribute(vnode, key)) && typeof value !== "object") return
		if (key[0] === "o" && key[1] === "n") return updateEvent(vnode, key, value)
		if (key.slice(0, 6) === "xlink:") vnode.dom.setAttributeNS("http://www.w3.org/1999/xlink", key.slice(6), value)
		else if (key === "style") updateStyle(vnode.dom, old, value)
		else if (hasPropertyKey(vnode, key, ns)) {
			if (key === "value") {
				// Only do the coercion if we're actually going to check the value.
				/* eslint-disable no-implicit-coercion */
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === "" + value && vnode.dom === activeElement()) return
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select" && old !== null && vnode.dom.value === "" + value) return
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && old !== null && vnode.dom.value === "" + value) return
				/* eslint-enable no-implicit-coercion */
			}
			// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.
			if (vnode.tag === "input" && key === "type") vnode.dom.setAttribute(key, value)
			else vnode.dom[key] = value
		} else {
			if (typeof value === "boolean") {
				if (value) vnode.dom.setAttribute(key, "")
				else vnode.dom.removeAttribute(key)
			}
			else vnode.dom.setAttribute(key === "className" ? "class" : key, value)
		}
	}
	function removeAttr(vnode, key, old, ns) {
		if (key === "key" || key === "is" || old == null || isLifecycleMethod(key)) return
		if (key[0] === "o" && key[1] === "n" && !isLifecycleMethod(key)) updateEvent(vnode, key, undefined)
		else if (key === "style") updateStyle(vnode.dom, old, null)
		else if (
			hasPropertyKey(vnode, key, ns)
			&& key !== "className"
			&& !(key === "value" && (
				vnode.tag === "option"
				|| vnode.tag === "select" && vnode.dom.selectedIndex === -1 && vnode.dom === activeElement()
			))
			&& !(vnode.tag === "input" && key === "type")
		) {
			vnode.dom[key] = null
		} else {
			var nsLastIndex = key.indexOf(":")
			if (nsLastIndex !== -1) key = key.slice(nsLastIndex + 1)
			if (old !== false) vnode.dom.removeAttribute(key === "className" ? "class" : key)
		}
	}
	function setLateSelectAttrs(vnode, attrs) {
		if ("value" in attrs) {
			if(attrs.value === null) {
				if (vnode.dom.selectedIndex !== -1) vnode.dom.value = null
			} else {
				var normalized = "" + attrs.value // eslint-disable-line no-implicit-coercion
				if (vnode.dom.value !== normalized || vnode.dom.selectedIndex === -1) {
					vnode.dom.value = normalized
				}
			}
		}
		if ("selectedIndex" in attrs) setAttr(vnode, "selectedIndex", null, attrs.selectedIndex, undefined)
	}
	function updateAttrs(vnode, old, attrs, ns) {
		if (attrs != null) {
			for (var key in attrs) {
				setAttr(vnode, key, old && old[key], attrs[key], ns)
			}
		}
		var val
		if (old != null) {
			for (var key in old) {
				if (((val = old[key]) != null) && (attrs == null || attrs[key] == null)) {
					removeAttr(vnode, key, val, ns)
				}
			}
		}
	}
	function isFormAttribute(vnode, attr) {
		return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === activeElement() || vnode.tag === "option" && vnode.dom.parentNode === $doc.activeElement
	}
	function isLifecycleMethod(attr) {
		return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
	}
	function hasPropertyKey(vnode, key, ns) {
		// Filter out namespaced keys
		return ns === undefined && (
			// If it's a custom element, just keep it.
			vnode.tag.indexOf("-") > -1 || vnode.attrs != null && vnode.attrs.is ||
			// If it's a normal element, let's try to avoid a few browser bugs.
			key !== "href" && key !== "list" && key !== "form" && key !== "width" && key !== "height"// && key !== "type"
			// Defer the property check until *after* we check everything.
		) && key in vnode.dom
	}

	//style
	var uppercaseRegex = /[A-Z]/g
	function toLowerCase(capital) { return "-" + capital.toLowerCase() }
	function normalizeKey(key) {
		return key[0] === "-" && key[1] === "-" ? key :
			key === "cssFloat" ? "float" :
				key.replace(uppercaseRegex, toLowerCase)
	}
	function updateStyle(element, old, style) {
		if (old === style) {
			// Styles are equivalent, do nothing.
		} else if (style == null) {
			// New style is missing, just clear it.
			element.style.cssText = ""
		} else if (typeof style !== "object") {
			// New style is a string, let engine deal with patching.
			element.style.cssText = style
		} else if (old == null || typeof old !== "object") {
			// `old` is missing or a string, `style` is an object.
			element.style.cssText = ""
			// Add new style properties
			for (var key in style) {
				var value = style[key]
				if (value != null) element.style.setProperty(normalizeKey(key), String(value))
			}
		} else {
			// Both old & new are (different) objects.
			// Update style properties that have changed
			for (var key in style) {
				var value = style[key]
				if (value != null && (value = String(value)) !== String(old[key])) {
					element.style.setProperty(normalizeKey(key), value)
				}
			}
			// Remove style properties that no longer exist
			for (var key in old) {
				if (old[key] != null && style[key] == null) {
					element.style.removeProperty(normalizeKey(key))
				}
			}
		}
	}

	// Here's an explanation of how this works:
	// 1. The event names are always (by design) prefixed by `on`.
	// 2. The EventListener interface accepts either a function or an object
	//    with a `handleEvent` method.
	// 3. The object does not inherit from `Object.prototype`, to avoid
	//    any potential interference with that (e.g. setters).
	// 4. The event name is remapped to the handler before calling it.
	// 5. In function-based event handlers, `ev.target === this`. We replicate
	//    that below.
	// 6. In function-based event handlers, `return false` prevents the default
	//    action and stops event propagation. We replicate that below.
	function EventDict() {}
	EventDict.prototype = Object.create(null)
	EventDict.prototype.handleEvent = function (ev) {
		var handler = this["on" + ev.type]
		var result
		if (typeof handler === "function") result = handler.call(ev.currentTarget, ev)
		else if (typeof handler.handleEvent === "function") handler.handleEvent(ev)
		if (ev.redraw === false) ev.redraw = undefined
		else if (typeof redraw === "function") redraw()
		if (result === false) {
			ev.preventDefault()
			ev.stopPropagation()
		}
	}

	//event
	function updateEvent(vnode, key, value) {
		if (vnode.events != null) {
			if (vnode.events[key] === value) return
			if (value != null && (typeof value === "function" || typeof value === "object")) {
				if (vnode.events[key] == null) vnode.dom.addEventListener(key.slice(2), vnode.events, false)
				vnode.events[key] = value
			} else {
				if (vnode.events[key] != null) vnode.dom.removeEventListener(key.slice(2), vnode.events, false)
				vnode.events[key] = undefined
			}
		} else if (value != null && (typeof value === "function" || typeof value === "object")) {
			vnode.events = new EventDict()
			vnode.dom.addEventListener(key.slice(2), vnode.events, false)
			vnode.events[key] = value
		}
	}

	//lifecycle
	function initLifecycle(source, vnode, hooks) {
		if (typeof source.oninit === "function") callHook.call(source.oninit, vnode)
		if (typeof source.oncreate === "function") hooks.push(callHook.bind(source.oncreate, vnode))
	}
	function updateLifecycle(source, vnode, hooks) {
		if (typeof source.onupdate === "function") hooks.push(callHook.bind(source.onupdate, vnode))
	}
	function shouldNotUpdate(vnode, old) {
		do {
			if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") {
				var force = callHook.call(vnode.attrs.onbeforeupdate, vnode, old)
				if (force !== undefined && !force) break
			}
			if (typeof vnode.tag !== "string" && typeof vnode.state.onbeforeupdate === "function") {
				var force = callHook.call(vnode.state.onbeforeupdate, vnode, old)
				if (force !== undefined && !force) break
			}
			return false
		} while (false); // eslint-disable-line no-constant-condition
		vnode.dom = old.dom
		vnode.domSize = old.domSize
		vnode.instance = old.instance
		// One would think having the actual latest attributes would be ideal,
		// but it doesn't let us properly diff based on our current internal
		// representation. We have to save not only the old DOM info, but also
		// the attributes used to create it, as we diff *that*, not against the
		// DOM directly (with a few exceptions in `setAttr`). And, of course, we
		// need to save the children and text as they are conceptually not
		// unlike special "attributes" internally.
		vnode.attrs = old.attrs
		vnode.children = old.children
		vnode.text = old.text
		return true
	}

	function render(dom, vnodes) {
		if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")
		var hooks = []
		var active = activeElement()
		var namespace = dom.namespaceURI

		// First time rendering into a node clears it out
		if (dom.vnodes == null) dom.textContent = ""

		vnodes = Vnode.normalizeChildren(Array.isArray(vnodes) ? vnodes : [vnodes])
		updateNodes(dom, dom.vnodes, vnodes, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)
		dom.vnodes = vnodes
		// `document.activeElement` can return null: https://html.spec.whatwg.org/multipage/interaction.html#dom-document-activeelement
		if (active != null && activeElement() !== active && typeof active.focus === "function") active.focus()
		for (var i = 0; i < hooks.length; i++) hooks[i]()
	}

	return {render: render, setRedraw: setRedraw}
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/trust.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/trust.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Vnode = __webpack_require__(/*! ../render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")

module.exports = function(html) {
	if (html == null) html = ""
	return Vnode("<", undefined, undefined, html, undefined, undefined)
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function Vnode(tag, key, attrs, children, text, dom) {
	return {tag: tag, key: key, attrs: attrs, children: children, text: text, dom: dom, domSize: undefined, state: undefined, events: undefined, instance: undefined}
}
Vnode.normalize = function(node) {
	if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)
	if (node == null || typeof node === "boolean") return null
	if (typeof node === "object") return node
	return Vnode("#", undefined, undefined, String(node), undefined, undefined)
}
Vnode.normalizeChildren = function(input) {
	var children = []
	for (var i = 0; i < input.length; i++) {
		children[i] = Vnode.normalize(input[i])
	}
	return children
}

module.exports = Vnode


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/request.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/request.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var PromisePolyfill = __webpack_require__(/*! ./promise/promise */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/promise.js")
module.exports = __webpack_require__(/*! ./request/request */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/request/request.js")(window, PromisePolyfill)


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/request/request.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/request/request.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var buildPathname = __webpack_require__(/*! ../pathname/build */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/build.js")

module.exports = function($window, Promise) {
	var callbackCount = 0
	var oncompletion

	function PromiseProxy(executor) {
		return new Promise(executor)
	}

	// In case the global Promise is some userland library's where they rely on
	// `foo instanceof this.constructor`, `this.constructor.resolve(value)`, or
	// similar. Let's *not* break them.
	PromiseProxy.prototype = Promise.prototype
	PromiseProxy.__proto__ = Promise // eslint-disable-line no-proto

	function makeRequest(factory) {
		return function(url, args) {
			if (typeof url !== "string") { args = url; url = url.url }
			else if (args == null) args = {}
			var promise = new Promise(function(resolve, reject) {
				factory(buildPathname(url, args.params), args, function (data) {
					if (typeof args.type === "function") {
						if (Array.isArray(data)) {
							for (var i = 0; i < data.length; i++) {
								data[i] = new args.type(data[i])
							}
						}
						else data = new args.type(data)
					}
					resolve(data)
				}, reject)
			})
			if (args.background === true) return promise
			var count = 0
			function complete() {
				if (--count === 0 && typeof oncompletion === "function") oncompletion()
			}

			return wrap(promise)

			function wrap(promise) {
				var then = promise.then
				// Set the constructor, so engines know to not await or resolve
				// this as a native promise. At the time of writing, this is
				// only necessary for V8, but their behavior is the correct
				// behavior per spec. See this spec issue for more details:
				// https://github.com/tc39/ecma262/issues/1577. Also, see the
				// corresponding comment in `request/tests/test-request.js` for
				// a bit more background on the issue at hand.
				promise.constructor = PromiseProxy
				promise.then = function() {
					count++
					var next = then.apply(promise, arguments)
					next.then(complete, function(e) {
						complete()
						if (count === 0) throw e
					})
					return wrap(next)
				}
				return promise
			}
		}
	}

	function hasHeader(args, name) {
		for (var key in args.headers) {
			if ({}.hasOwnProperty.call(args.headers, key) && name.test(key)) return true
		}
		return false
	}

	return {
		request: makeRequest(function(url, args, resolve, reject) {
			var method = args.method != null ? args.method.toUpperCase() : "GET"
			var body = args.body
			var assumeJSON = (args.serialize == null || args.serialize === JSON.serialize) && !(body instanceof $window.FormData)
			var responseType = args.responseType || (typeof args.extract === "function" ? "" : "json")

			var xhr = new $window.XMLHttpRequest(), aborted = false
			var original = xhr, replacedAbort
			var abort = xhr.abort

			xhr.abort = function() {
				aborted = true
				abort.call(this)
			}

			xhr.open(method, url, args.async !== false, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined)

			if (assumeJSON && body != null && !hasHeader(args, /^content-type$/i)) {
				xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")
			}
			if (typeof args.deserialize !== "function" && !hasHeader(args, /^accept$/i)) {
				xhr.setRequestHeader("Accept", "application/json, text/*")
			}
			if (args.withCredentials) xhr.withCredentials = args.withCredentials
			if (args.timeout) xhr.timeout = args.timeout
			xhr.responseType = responseType

			for (var key in args.headers) {
				if ({}.hasOwnProperty.call(args.headers, key)) {
					xhr.setRequestHeader(key, args.headers[key])
				}
			}

			xhr.onreadystatechange = function(ev) {
				// Don't throw errors on xhr.abort().
				if (aborted) return

				if (ev.target.readyState === 4) {
					try {
						var success = (ev.target.status >= 200 && ev.target.status < 300) || ev.target.status === 304 || (/^file:\/\//i).test(url)
						// When the response type isn't "" or "text",
						// `xhr.responseText` is the wrong thing to use.
						// Browsers do the right thing and throw here, and we
						// should honor that and do the right thing by
						// preferring `xhr.response` where possible/practical.
						var response = ev.target.response, message

						if (responseType === "json") {
							// For IE and Edge, which don't implement
							// `responseType: "json"`.
							if (!ev.target.responseType && typeof args.extract !== "function") response = JSON.parse(ev.target.responseText)
						} else if (!responseType || responseType === "text") {
							// Only use this default if it's text. If a parsed
							// document is needed on old IE and friends (all
							// unsupported), the user should use a custom
							// `config` instead. They're already using this at
							// their own risk.
							if (response == null) response = ev.target.responseText
						}

						if (typeof args.extract === "function") {
							response = args.extract(ev.target, args)
							success = true
						} else if (typeof args.deserialize === "function") {
							response = args.deserialize(response)
						}
						if (success) resolve(response)
						else {
							try { message = ev.target.responseText }
							catch (e) { message = response }
							var error = new Error(message)
							error.code = ev.target.status
							error.response = response
							reject(error)
						}
					}
					catch (e) {
						reject(e)
					}
				}
			}

			if (typeof args.config === "function") {
				xhr = args.config(xhr, args, url) || xhr

				// Propagate the `abort` to any replacement XHR as well.
				if (xhr !== original) {
					replacedAbort = xhr.abort
					xhr.abort = function() {
						aborted = true
						replacedAbort.call(this)
					}
				}
			}

			if (body == null) xhr.send()
			else if (typeof args.serialize === "function") xhr.send(args.serialize(body))
			else if (body instanceof $window.FormData) xhr.send(body)
			else xhr.send(JSON.stringify(body))
		}),
		jsonp: makeRequest(function(url, args, resolve, reject) {
			var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++
			var script = $window.document.createElement("script")
			$window[callbackName] = function(data) {
				delete $window[callbackName]
				script.parentNode.removeChild(script)
				resolve(data)
			}
			script.onerror = function() {
				delete $window[callbackName]
				script.parentNode.removeChild(script)
				reject(new Error("JSONP request failed"))
			}
			script.src = url + (url.indexOf("?") < 0 ? "?" : "&") +
				encodeURIComponent(args.callbackKey || "callback") + "=" +
				encodeURIComponent(callbackName)
			$window.document.documentElement.appendChild(script)
		}),
		setCompletionCallback: function(callback) {
			oncompletion = callback
		},
	}
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/route.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/route.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redrawService = __webpack_require__(/*! ./redraw */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/redraw.js")

module.exports = __webpack_require__(/*! ./api/router */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/router.js")(window, redrawService)


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/router/router.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/router/router.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {

var buildPathname = __webpack_require__(/*! ../pathname/build */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/build.js")
var parsePathname = __webpack_require__(/*! ../pathname/parse */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/parse.js")
var compileTemplate = __webpack_require__(/*! ../pathname/compileTemplate */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/compileTemplate.js")
var assign = __webpack_require__(/*! ../pathname/assign */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/assign.js")

module.exports = function($window) {
	var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout
	var supportsPushState = typeof $window.history.pushState === "function"
	var fireAsync

	return {
		prefix: "#!",

		getPath: function() {
			// Consider the pathname holistically. The prefix might even be invalid,
			// but that's not our problem.
			var prefix = $window.location.hash
			if (this.prefix[0] !== "#") {
				prefix = $window.location.search + prefix
				if (this.prefix[0] !== "?") {
					prefix = $window.location.pathname + prefix
					if (prefix[0] !== "/") prefix = "/" + prefix
				}
			}
			// This seemingly useless `.concat()` speeds up the tests quite a bit,
			// since the representation is consistently a relatively poorly
			// optimized cons string.
			return prefix.concat()
				.replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)
				.slice(this.prefix.length)
		},

		setPath: function(path, data, options) {
			path = buildPathname(path, data)
			if (fireAsync != null) {
				fireAsync()
				var state = options ? options.state : null
				var title = options ? options.title : null
				if (options && options.replace) $window.history.replaceState(state, title, this.prefix + path)
				else $window.history.pushState(state, title, this.prefix + path)
			}
			else {
				$window.location.href = this.prefix + path
			}
		},

		defineRoutes: function(routes, resolve, reject, defaultRoute, subscribe) {
			var self = this
			var compiled = Object.keys(routes).map(function(route) {
				if (route[0] !== "/") throw new SyntaxError("Routes must start with a `/`")
				if ((/:([^\/\.-]+)(\.{3})?:/).test(route)) {
					throw new SyntaxError("Route parameter names must be separated with either `/`, `.`, or `-`")
				}
				return {
					route: route,
					component: routes[route],
					check: compileTemplate(route),
				}
			})
			var unsubscribe, asyncId

			fireAsync = null

			if (defaultRoute != null) {
				var defaultData = parsePathname(defaultRoute)

				if (!compiled.some(function (i) { return i.check(defaultData) })) {
					throw new ReferenceError("Default route doesn't match any known routes")
				}
			}

			function resolveRoute() {
				var path = self.getPath()
				var data = parsePathname(path)

				assign(data.params, $window.history.state)

				for (var i = 0; i < compiled.length; i++) {
					if (compiled[i].check(data)) {
						resolve(compiled[i].component, data.params, path, compiled[i].route)
						return
					}
				}

				reject(path, data.params)
			}

			if (supportsPushState) {
				unsubscribe = function() {
					$window.removeEventListener("popstate", fireAsync, false)
				}
				$window.addEventListener("popstate", fireAsync = function() {
					if (asyncId) return
					asyncId = callAsync(function() {
						asyncId = null
						resolveRoute()
					})
				}, false)
			} else if (this.prefix[0] === "#") {
				unsubscribe = function() {
					$window.removeEventListener("hashchange", resolveRoute, false)
				}
				$window.addEventListener("hashchange", resolveRoute, false)
			}

			subscribe(unsubscribe)
			resolveRoute()
		},
	}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../timers-browserify/2.0.10/node_modules/timers-browserify/main.js */ "./node_modules/.registry.npmjs.org/timers-browserify/2.0.10/node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/F.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/F.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _always__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./always */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js");


/**
 * A function that always returns `false`. Any passed in parameters are ignored.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig * -> Boolean
 * @param {*}
 * @return {Boolean}
 * @see R.always, R.T
 * @example
 *
 *      R.F(); //=> false
 */
var F = /*#__PURE__*/Object(_always__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
/* harmony default export */ __webpack_exports__["default"] = (F);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/T.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/T.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _always__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./always */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js");


/**
 * A function that always returns `true`. Any passed in parameters are ignored.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig * -> Boolean
 * @param {*}
 * @return {Boolean}
 * @see R.always, R.F
 * @example
 *
 *      R.T(); //=> true
 */
var T = /*#__PURE__*/Object(_always__WEBPACK_IMPORTED_MODULE_0__["default"])(true);
/* harmony default export */ __webpack_exports__["default"] = (T);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/__.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/__.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * A special placeholder value used to specify "gaps" within curried functions,
 * allowing partial application of any combination of arguments, regardless of
 * their positions.
 *
 * If `g` is a curried ternary function and `_` is `R.__`, the following are
 * equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2, _)(1, 3)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @constant
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @example
 *
 *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
 *      greet('Alice'); //=> 'Hello, Alice!'
 */
/* harmony default export */ __webpack_exports__["default"] = ({ '@@functional/placeholder': true });

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/add.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/add.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Adds two values.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a
 * @param {Number} b
 * @return {Number}
 * @see R.subtract
 * @example
 *
 *      R.add(2, 3);       //=>  5
 *      R.add(7)(10);      //=> 17
 */
var add = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function add(a, b) {
  return Number(a) + Number(b);
});
/* harmony default export */ __webpack_exports__["default"] = (add);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/addIndex.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/addIndex.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");




/**
 * Creates a new list iteration function from an existing one by adding two new
 * parameters to its callback function: the current index, and the entire list.
 *
 * This would turn, for instance, [`R.map`](#map) function into one that
 * more closely resembles `Array.prototype.map`. Note that this will only work
 * for functions in which the iteration callback function is the first
 * parameter, and where the list is the last parameter. (This latter might be
 * unimportant if the list parameter is not used.)
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Function
 * @category List
 * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
 * @param {Function} fn A list iteration function that does not pass index or list to its callback
 * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
 * @example
 *
 *      var mapIndexed = R.addIndex(R.map);
 *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
 *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
 */
var addIndex = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_1__["default"])(function addIndex(fn) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_2__["default"])(fn.length, function () {
    var idx = 0;
    var origFn = arguments[0];
    var list = arguments[arguments.length - 1];
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = function () {
      var result = origFn.apply(this, Object(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"])(arguments, [idx, list]));
      idx += 1;
      return result;
    };
    return fn.apply(this, args);
  });
});
/* harmony default export */ __webpack_exports__["default"] = (addIndex);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/adjust.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/adjust.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");



/**
 * Applies a function to the value at the given index of an array, returning a
 * new copy of the array with the element at the given index replaced with the
 * result of the function application.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig (a -> a) -> Number -> [a] -> [a]
 * @param {Function} fn The function to apply.
 * @param {Number} idx The index.
 * @param {Array|Arguments} list An array-like object whose value
 *        at the supplied index will be replaced.
 * @return {Array} A copy of the supplied array-like object with
 *         the element at index `idx` replaced with the value
 *         returned by applying `fn` to the existing element.
 * @see R.update
 * @example
 *
 *      R.adjust(R.add(10), 1, [1, 2, 3]);     //=> [1, 12, 3]
 *      R.adjust(R.add(10))(1)([1, 2, 3]);     //=> [1, 12, 3]
 * @symb R.adjust(f, -1, [a, b]) = [a, f(b)]
 * @symb R.adjust(f, 0, [a, b]) = [f(a), b]
 */
var adjust = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_1__["default"])(function adjust(fn, idx, list) {
  if (idx >= list.length || idx < -list.length) {
    return list;
  }
  var start = idx < 0 ? list.length : 0;
  var _idx = start + idx;
  var _list = Object(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"])(list);
  _list[_idx] = fn(list[_idx]);
  return _list;
});
/* harmony default export */ __webpack_exports__["default"] = (adjust);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/all.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/all.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xall__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xall */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xall.js");




/**
 * Returns `true` if all elements of the list match the predicate, `false` if
 * there are any that don't.
 *
 * Dispatches to the `all` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
 *         otherwise.
 * @see R.any, R.none, R.transduce
 * @example
 *
 *      var equals3 = R.equals(3);
 *      R.all(equals3)([3, 3, 3, 3]); //=> true
 *      R.all(equals3)([3, 3, 1, 3]); //=> false
 */
var all = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['all'], _internal_xall__WEBPACK_IMPORTED_MODULE_2__["default"], function all(fn, list) {
  var idx = 0;
  while (idx < list.length) {
    if (!fn(list[idx])) {
      return false;
    }
    idx += 1;
  }
  return true;
}));
/* harmony default export */ __webpack_exports__["default"] = (all);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/allPass.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/allPass.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./max */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js");
/* harmony import */ var _pluck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pluck */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pluck.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");






/**
 * Takes a list of predicates and returns a predicate that returns true for a
 * given list of arguments if every one of the provided predicates is satisfied
 * by those arguments.
 *
 * The function returned is a curried function whose arity matches that of the
 * highest-arity predicate.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Logic
 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
 * @param {Array} predicates An array of predicates to check
 * @return {Function} The combined predicate
 * @see R.anyPass
 * @example
 *
 *      var isQueen = R.propEq('rank', 'Q');
 *      var isSpade = R.propEq('suit', 'â ï¸');
 *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
 *
 *      isQueenOfSpades({rank: 'Q', suit: 'â£ï¸'}); //=> false
 *      isQueenOfSpades({rank: 'Q', suit: 'â ï¸'}); //=> true
 */
var allPass = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function allPass(preds) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_reduce__WEBPACK_IMPORTED_MODULE_4__["default"])(_max__WEBPACK_IMPORTED_MODULE_2__["default"], 0, Object(_pluck__WEBPACK_IMPORTED_MODULE_3__["default"])('length', preds)), function () {
    var idx = 0;
    var len = preds.length;
    while (idx < len) {
      if (!preds[idx].apply(this, arguments)) {
        return false;
      }
      idx += 1;
    }
    return true;
  });
});
/* harmony default export */ __webpack_exports__["default"] = (allPass);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Returns a function that always returns the given value. Note that for
 * non-primitives the value returned is a reference to the original value.
 *
 * This function is known as `const`, `constant`, or `K` (for K combinator) in
 * other languages and libraries.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig a -> (* -> a)
 * @param {*} val The value to wrap in a function
 * @return {Function} A Function :: * -> val.
 * @example
 *
 *      var t = R.always('Tee');
 *      t(); //=> 'Tee'
 */
var always = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function always(val) {
  return function () {
    return val;
  };
});
/* harmony default export */ __webpack_exports__["default"] = (always);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/and.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/and.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns `true` if both arguments are `true`; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig a -> b -> a | b
 * @param {Any} a
 * @param {Any} b
 * @return {Any} the first argument if it is falsy, otherwise the second argument.
 * @see R.both
 * @example
 *
 *      R.and(true, true); //=> true
 *      R.and(true, false); //=> false
 *      R.and(false, true); //=> false
 *      R.and(false, false); //=> false
 */
var and = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function and(a, b) {
  return a && b;
});
/* harmony default export */ __webpack_exports__["default"] = (and);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/any.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/any.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xany__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xany */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xany.js");




/**
 * Returns `true` if at least one of elements of the list match the predicate,
 * `false` otherwise.
 *
 * Dispatches to the `any` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
 *         otherwise.
 * @see R.all, R.none, R.transduce
 * @example
 *
 *      var lessThan0 = R.flip(R.lt)(0);
 *      var lessThan2 = R.flip(R.lt)(2);
 *      R.any(lessThan0)([1, 2]); //=> false
 *      R.any(lessThan2)([1, 2]); //=> true
 */
var any = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['any'], _internal_xany__WEBPACK_IMPORTED_MODULE_2__["default"], function any(fn, list) {
  var idx = 0;
  while (idx < list.length) {
    if (fn(list[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
}));
/* harmony default export */ __webpack_exports__["default"] = (any);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/anyPass.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/anyPass.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./max */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js");
/* harmony import */ var _pluck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pluck */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pluck.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");






/**
 * Takes a list of predicates and returns a predicate that returns true for a
 * given list of arguments if at least one of the provided predicates is
 * satisfied by those arguments.
 *
 * The function returned is a curried function whose arity matches that of the
 * highest-arity predicate.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Logic
 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
 * @param {Array} predicates An array of predicates to check
 * @return {Function} The combined predicate
 * @see R.allPass
 * @example
 *
 *      var isClub = R.propEq('suit', 'â£');
 *      var isSpade = R.propEq('suit', 'â ');
 *      var isBlackCard = R.anyPass([isClub, isSpade]);
 *
 *      isBlackCard({rank: '10', suit: 'â£'}); //=> true
 *      isBlackCard({rank: 'Q', suit: 'â '}); //=> true
 *      isBlackCard({rank: 'Q', suit: 'â¦'}); //=> false
 */
var anyPass = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function anyPass(preds) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_reduce__WEBPACK_IMPORTED_MODULE_4__["default"])(_max__WEBPACK_IMPORTED_MODULE_2__["default"], 0, Object(_pluck__WEBPACK_IMPORTED_MODULE_3__["default"])('length', preds)), function () {
    var idx = 0;
    var len = preds.length;
    while (idx < len) {
      if (preds[idx].apply(this, arguments)) {
        return true;
      }
      idx += 1;
    }
    return false;
  });
});
/* harmony default export */ __webpack_exports__["default"] = (anyPass);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ap.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ap.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");





/**
 * ap applies a list of functions to a list of values.
 *
 * Dispatches to the `ap` method of the second argument, if present. Also
 * treats curried functions as applicatives.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Function
 * @sig [a -> b] -> [a] -> [b]
 * @sig Apply f => f (a -> b) -> f a -> f b
 * @sig (a -> b -> c) -> (a -> b) -> (a -> c)
 * @param {*} applyF
 * @param {*} applyX
 * @return {*}
 * @example
 *
 *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
 *      R.ap([R.concat('tasty '), R.toUpper], ['pizza', 'salad']); //=> ["tasty pizza", "tasty salad", "PIZZA", "SALAD"]
 *
 *      // R.ap can also be used as S combinator
 *      // when only two functions are passed
 *      R.ap(R.concat, R.toUpper)('Ramda') //=> 'RamdaRAMDA'
 * @symb R.ap([f, g], [a, b]) = [f(a), f(b), g(a), g(b)]
 */
var ap = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function ap(applyF, applyX) {
  return typeof applyX['fantasy-land/ap'] === 'function' ? applyX['fantasy-land/ap'](applyF) : typeof applyF.ap === 'function' ? applyF.ap(applyX) : typeof applyF === 'function' ? function (x) {
    return applyF(x)(applyX(x));
  } :
  // else
  Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_2__["default"])(function (acc, f) {
    return Object(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"])(acc, Object(_map__WEBPACK_IMPORTED_MODULE_3__["default"])(f, applyX));
  }, [], applyF);
});
/* harmony default export */ __webpack_exports__["default"] = (ap);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/aperture.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/aperture.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_aperture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_aperture */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_aperture.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xaperture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_xaperture */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xaperture.js");





/**
 * Returns a new list, composed of n-tuples of consecutive elements. If `n` is
 * greater than the length of the list, an empty list is returned.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig Number -> [a] -> [[a]]
 * @param {Number} n The size of the tuples to create
 * @param {Array} list The list to split into `n`-length tuples
 * @return {Array} The resulting list of `n`-length tuples
 * @see R.transduce
 * @example
 *
 *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
 *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
 *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
 */
var aperture = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_2__["default"])([], _internal_xaperture__WEBPACK_IMPORTED_MODULE_3__["default"], _internal_aperture__WEBPACK_IMPORTED_MODULE_0__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (aperture);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/append.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/append.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Returns a new list containing the contents of the given list, followed by
 * the given element.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> [a]
 * @param {*} el The element to add to the end of the new list.
 * @param {Array} list The list of elements to add a new item to.
 *        list.
 * @return {Array} A new list containing the elements of the old list followed by `el`.
 * @see R.prepend
 * @example
 *
 *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
 *      R.append('tests', []); //=> ['tests']
 *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
 */
var append = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function append(el, list) {
  return Object(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"])(list, [el]);
});
/* harmony default export */ __webpack_exports__["default"] = (append);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/apply.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/apply.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Applies function `fn` to the argument list `args`. This is useful for
 * creating a fixed-arity function from a variadic function. `fn` should be a
 * bound function if context is significant.
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Function
 * @sig (*... -> a) -> [*] -> a
 * @param {Function} fn The function which will be called with `args`
 * @param {Array} args The arguments to call `fn` with
 * @return {*} result The result, equivalent to `fn(...args)`
 * @see R.call, R.unapply
 * @example
 *
 *      var nums = [1, 2, 3, -99, 42, 6, 7];
 *      R.apply(Math.max, nums); //=> 42
 * @symb R.apply(f, [a, b, c]) = f(a, b, c)
 */
var apply = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function apply(fn, args) {
  return fn.apply(this, args);
});
/* harmony default export */ __webpack_exports__["default"] = (apply);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/applySpec.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/applySpec.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _apply__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./apply */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/apply.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");
/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./max */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js");
/* harmony import */ var _pluck__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pluck */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pluck.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");
/* harmony import */ var _values__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./values */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/values.js");









/**
 * Given a spec object recursively mapping properties to functions, creates a
 * function producing an object of the same structure, by mapping each property
 * to the result of calling its associated function with the supplied arguments.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Function
 * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
 * @param {Object} spec an object recursively mapping properties to functions for
 *        producing the values for these properties.
 * @return {Function} A function that returns an object of the same structure
 * as `spec', with each property set to the value returned by calling its
 * associated function with the supplied arguments.
 * @see R.converge, R.juxt
 * @example
 *
 *      var getMetrics = R.applySpec({
 *        sum: R.add,
 *        nested: { mul: R.multiply }
 *      });
 *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
 * @symb R.applySpec({ x: f, y: { z: g } })(a, b) = { x: f(a, b), y: { z: g(a, b) } }
 */
var applySpec = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function applySpec(spec) {
  spec = Object(_map__WEBPACK_IMPORTED_MODULE_3__["default"])(function (v) {
    return typeof v == 'function' ? v : applySpec(v);
  }, spec);
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_reduce__WEBPACK_IMPORTED_MODULE_6__["default"])(_max__WEBPACK_IMPORTED_MODULE_4__["default"], 0, Object(_pluck__WEBPACK_IMPORTED_MODULE_5__["default"])('length', Object(_values__WEBPACK_IMPORTED_MODULE_7__["default"])(spec))), function () {
    var args = arguments;
    return Object(_map__WEBPACK_IMPORTED_MODULE_3__["default"])(function (f) {
      return Object(_apply__WEBPACK_IMPORTED_MODULE_1__["default"])(f, args);
    }, spec);
  });
});
/* harmony default export */ __webpack_exports__["default"] = (applySpec);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/applyTo.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/applyTo.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
* Takes a value and applies a function to it.
*
* This function is also known as the `thrush` combinator.
*
* @func
* @memberOf R
 * @since v0.25.0
* @category Function
* @sig a -> (a -> b) -> b
* @param {*} x The value
* @param {Function} f The function to apply
* @return {*} The result of applying `f` to `x`
* @example
*
*      var t42 = R.applyTo(42);
*      t42(R.identity); //=> 42
*      t42(R.add(1)); //=> 43
*/
var applyTo = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function applyTo(x, f) {
  return f(x);
});
/* harmony default export */ __webpack_exports__["default"] = (applyTo);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ascend.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ascend.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Makes an ascending comparator function out of a function that returns a value
 * that can be compared with `<` and `>`.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Function
 * @sig Ord b => (a -> b) -> a -> a -> Number
 * @param {Function} fn A function of arity one that returns a value that can be compared
 * @param {*} a The first item to be compared.
 * @param {*} b The second item to be compared.
 * @return {Number} `-1` if fn(a) < fn(b), `1` if fn(b) < fn(a), otherwise `0`
 * @see R.descend
 * @example
 *
 *      var byAge = R.ascend(R.prop('age'));
 *      var people = [
 *        // ...
 *      ];
 *      var peopleByYoungestFirst = R.sort(byAge, people);
 */
var ascend = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function ascend(fn, a, b) {
  var aa = fn(a);
  var bb = fn(b);
  return aa < bb ? -1 : aa > bb ? 1 : 0;
});
/* harmony default export */ __webpack_exports__["default"] = (ascend);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assoc.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assoc.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Makes a shallow clone of an object, setting or overriding the specified
 * property with the given value. Note that this copies and flattens prototype
 * properties onto the new object as well. All non-primitive properties are
 * copied by reference.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @sig String -> a -> {k: v} -> {k: v}
 * @param {String} prop The property name to set
 * @param {*} val The new value
 * @param {Object} obj The object to clone
 * @return {Object} A new object equivalent to the original except for the changed property.
 * @see R.dissoc
 * @example
 *
 *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
 */
var assoc = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function assoc(prop, val, obj) {
  var result = {};
  for (var p in obj) {
    result[p] = obj[p];
  }
  result[prop] = val;
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (assoc);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assocPath.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assocPath.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");
/* harmony import */ var _internal_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");
/* harmony import */ var _internal_isInteger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_isInteger */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isInteger.js");
/* harmony import */ var _assoc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./assoc */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assoc.js");
/* harmony import */ var _isNil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isNil */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/isNil.js");







/**
 * Makes a shallow clone of an object, setting or overriding the nodes required
 * to create the given path, and placing the specific value at the tail end of
 * that path. Note that this copies and flattens prototype properties onto the
 * new object as well. All non-primitive properties are copied by reference.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig [Idx] -> a -> {a} -> {a}
 * @param {Array} path the path to set
 * @param {*} val The new value
 * @param {Object} obj The object to clone
 * @return {Object} A new object equivalent to the original except along the specified path.
 * @see R.dissocPath
 * @example
 *
 *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
 *
 *      // Any missing or non-object keys in path will be overridden
 *      R.assocPath(['a', 'b', 'c'], 42, {a: 5}); //=> {a: {b: {c: 42}}}
 */
var assocPath = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function assocPath(path, val, obj) {
  if (path.length === 0) {
    return val;
  }
  var idx = path[0];
  if (path.length > 1) {
    var nextObj = !Object(_isNil__WEBPACK_IMPORTED_MODULE_5__["default"])(obj) && Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(idx, obj) ? obj[idx] : Object(_internal_isInteger__WEBPACK_IMPORTED_MODULE_3__["default"])(path[1]) ? [] : {};
    val = assocPath(Array.prototype.slice.call(path, 1), val, nextObj);
  }
  if (Object(_internal_isInteger__WEBPACK_IMPORTED_MODULE_3__["default"])(idx) && Object(_internal_isArray__WEBPACK_IMPORTED_MODULE_2__["default"])(obj)) {
    var arr = [].concat(obj);
    arr[idx] = val;
    return arr;
  } else {
    return Object(_assoc__WEBPACK_IMPORTED_MODULE_4__["default"])(idx, val, obj);
  }
});
/* harmony default export */ __webpack_exports__["default"] = (assocPath);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/binary.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/binary.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _nAry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nAry */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nAry.js");



/**
 * Wraps a function of any arity (including nullary) in a function that accepts
 * exactly 2 parameters. Any extraneous parameters will not be passed to the
 * supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Function
 * @sig (* -> c) -> (a, b -> c)
 * @param {Function} fn The function to wrap.
 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
 *         arity 2.
 * @see R.nAry, R.unary
 * @example
 *
 *      var takesThreeArgs = function(a, b, c) {
 *        return [a, b, c];
 *      };
 *      takesThreeArgs.length; //=> 3
 *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
 *
 *      var takesTwoArgs = R.binary(takesThreeArgs);
 *      takesTwoArgs.length; //=> 2
 *      // Only 2 arguments are passed to the wrapped function
 *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
 * @symb R.binary(f)(a, b, c) = f(a, b)
 */
var binary = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function binary(fn) {
  return Object(_nAry__WEBPACK_IMPORTED_MODULE_1__["default"])(2, fn);
});
/* harmony default export */ __webpack_exports__["default"] = (binary);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/bind.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/bind.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Creates a function that is bound to a context.
 * Note: `R.bind` does not provide the additional argument-binding capabilities of
 * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @category Object
 * @sig (* -> *) -> {*} -> (* -> *)
 * @param {Function} fn The function to bind to context
 * @param {Object} thisObj The context to bind `fn` to
 * @return {Function} A function that will execute in the context of `thisObj`.
 * @see R.partial
 * @example
 *
 *      var log = R.bind(console.log, console);
 *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
 *      // logs {a: 2}
 * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
 */
var bind = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function bind(fn, thisObj) {
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(fn.length, function () {
    return fn.apply(thisObj, arguments);
  });
});
/* harmony default export */ __webpack_exports__["default"] = (bind);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/both.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/both.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isFunction */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isFunction.js");
/* harmony import */ var _and__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./and */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/and.js");
/* harmony import */ var _lift__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lift */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lift.js");





/**
 * A function which calls the two provided functions and returns the `&&`
 * of the results.
 * It returns the result of the first function if it is false-y and the result
 * of the second function otherwise. Note that this is short-circuited,
 * meaning that the second function will not be invoked if the first returns a
 * false-y value.
 *
 * In addition to functions, `R.both` also accepts any fantasy-land compatible
 * applicative functor.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
 * @param {Function} f A predicate
 * @param {Function} g Another predicate
 * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
 * @see R.and
 * @example
 *
 *      var gt10 = R.gt(R.__, 10)
 *      var lt20 = R.lt(R.__, 20)
 *      var f = R.both(gt10, lt20);
 *      f(15); //=> true
 *      f(30); //=> false
 */
var both = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function both(f, g) {
  return Object(_internal_isFunction__WEBPACK_IMPORTED_MODULE_1__["default"])(f) ? function _both() {
    return f.apply(this, arguments) && g.apply(this, arguments);
  } : Object(_lift__WEBPACK_IMPORTED_MODULE_3__["default"])(_and__WEBPACK_IMPORTED_MODULE_2__["default"])(f, g);
});
/* harmony default export */ __webpack_exports__["default"] = (both);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/call.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/call.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curry */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curry.js");


/**
 * Returns the result of calling its first argument with the remaining
 * arguments. This is occasionally useful as a converging function for
 * [`R.converge`](#converge): the first branch can produce a function while the
 * remaining branches produce values to be passed to that function as its
 * arguments.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig (*... -> a),*... -> a
 * @param {Function} fn The function to apply to the remaining arguments.
 * @param {...*} args Any number of positional arguments.
 * @return {*}
 * @see R.apply
 * @example
 *
 *      R.call(R.add, 1, 2); //=> 3
 *
 *      var indentN = R.pipe(R.repeat(' '),
 *                           R.join(''),
 *                           R.replace(/^(?!$)/gm));
 *
 *      var format = R.converge(R.call, [
 *                                  R.pipe(R.prop('indent'), indentN),
 *                                  R.prop('value')
 *                              ]);
 *
 *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
 * @symb R.call(f, a, b) = f(a, b)
 */
var call = /*#__PURE__*/Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function call(fn) {
  return fn.apply(this, Array.prototype.slice.call(arguments, 1));
});
/* harmony default export */ __webpack_exports__["default"] = (call);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/chain.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/chain.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_makeFlat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_makeFlat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_makeFlat.js");
/* harmony import */ var _internal_xchain__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_xchain */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xchain.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");






/**
 * `chain` maps a function over a list and concatenates the results. `chain`
 * is also known as `flatMap` in some libraries
 *
 * Dispatches to the `chain` method of the second argument, if present,
 * according to the [FantasyLand Chain spec](https://github.com/fantasyland/fantasy-land#chain).
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig Chain m => (a -> m b) -> m a -> m b
 * @param {Function} fn The function to map with
 * @param {Array} list The list to map over
 * @return {Array} The result of flat-mapping `list` with `fn`
 * @example
 *
 *      var duplicate = n => [n, n];
 *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
 *
 *      R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]
 */
var chain = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['fantasy-land/chain', 'chain'], _internal_xchain__WEBPACK_IMPORTED_MODULE_3__["default"], function chain(fn, monad) {
  if (typeof monad === 'function') {
    return function (x) {
      return fn(monad(x))(x);
    };
  }
  return Object(_internal_makeFlat__WEBPACK_IMPORTED_MODULE_2__["default"])(false)(Object(_map__WEBPACK_IMPORTED_MODULE_4__["default"])(fn, monad));
}));
/* harmony default export */ __webpack_exports__["default"] = (chain);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/clamp.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/clamp.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Restricts a number to be within a range.
 *
 * Also works for other ordered types such as Strings and Dates.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Relation
 * @sig Ord a => a -> a -> a -> a
 * @param {Number} minimum The lower limit of the clamp (inclusive)
 * @param {Number} maximum The upper limit of the clamp (inclusive)
 * @param {Number} value Value to be clamped
 * @return {Number} Returns `minimum` when `val < minimum`, `maximum` when `val > maximum`, returns `val` otherwise
 * @example
 *
 *      R.clamp(1, 10, -5) // => 1
 *      R.clamp(1, 10, 15) // => 10
 *      R.clamp(1, 10, 4)  // => 4
 */
var clamp = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function clamp(min, max, value) {
  if (min > max) {
    throw new Error('min must not be greater than max in clamp(min, max, value)');
  }
  return value < min ? min : value > max ? max : value;
});
/* harmony default export */ __webpack_exports__["default"] = (clamp);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/clone.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/clone.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_clone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_clone */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_clone.js");
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");



/**
 * Creates a deep copy of the value which may contain (nested) `Array`s and
 * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are
 * assigned by reference rather than copied
 *
 * Dispatches to a `clone` method if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {*} -> {*}
 * @param {*} value The object or array to clone
 * @return {*} A deeply cloned copy of `val`
 * @example
 *
 *      var objects = [{}, {}, {}];
 *      var objectsClone = R.clone(objects);
 *      objects === objectsClone; //=> false
 *      objects[0] === objectsClone[0]; //=> false
 */
var clone = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_1__["default"])(function clone(value) {
  return value != null && typeof value.clone === 'function' ? value.clone() : Object(_internal_clone__WEBPACK_IMPORTED_MODULE_0__["default"])(value, [], [], true);
});
/* harmony default export */ __webpack_exports__["default"] = (clone);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/comparator.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/comparator.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Makes a comparator function out of a function that reports whether the first
 * element is less than the second.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((a, b) -> Boolean) -> ((a, b) -> Number)
 * @param {Function} pred A predicate function of arity two which will return `true` if the first argument
 * is less than the second, `false` otherwise
 * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`
 * @example
 *
 *      var byAge = R.comparator((a, b) => a.age < b.age);
 *      var people = [
 *        // ...
 *      ];
 *      var peopleByIncreasingAge = R.sort(byAge, people);
 */
var comparator = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function comparator(pred) {
  return function (a, b) {
    return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
  };
});
/* harmony default export */ __webpack_exports__["default"] = (comparator);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/complement.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/complement.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lift */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lift.js");
/* harmony import */ var _not__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./not */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/not.js");



/**
 * Takes a function `f` and returns a function `g` such that if called with the same arguments
 * when `f` returns a "truthy" value, `g` returns `false` and when `f` returns a "falsy" value `g` returns `true`.
 *
 * `R.complement` may be applied to any functor
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category Logic
 * @sig (*... -> *) -> (*... -> Boolean)
 * @param {Function} f
 * @return {Function}
 * @see R.not
 * @example
 *
 *      var isNotNil = R.complement(R.isNil);
 *      isNil(null); //=> true
 *      isNotNil(null); //=> false
 *      isNil(7); //=> false
 *      isNotNil(7); //=> true
 */
var complement = /*#__PURE__*/Object(_lift__WEBPACK_IMPORTED_MODULE_0__["default"])(_not__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (complement);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/compose.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/compose.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return compose; });
/* harmony import */ var _pipe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pipe */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipe.js");
/* harmony import */ var _reverse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reverse */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reverse.js");



/**
 * Performs right-to-left function composition. The rightmost function may have
 * any arity; the remaining functions must be unary.
 *
 * **Note:** The result of compose is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
 * @param {...Function} ...functions The functions to compose
 * @return {Function}
 * @see R.pipe
 * @example
 *
 *      var classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
 *      var yellGreeting = R.compose(R.toUpper, classyGreeting);
 *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
 *
 *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
 *
 * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
 */
function compose() {
  if (arguments.length === 0) {
    throw new Error('compose requires at least one argument');
  }
  return _pipe__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, Object(_reverse__WEBPACK_IMPORTED_MODULE_1__["default"])(arguments));
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/composeK.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/composeK.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return composeK; });
/* harmony import */ var _chain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chain */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/chain.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compose */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/compose.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");




/**
 * Returns the right-to-left Kleisli composition of the provided functions,
 * each of which must return a value of a type supported by [`chain`](#chain).
 *
 * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), f)`.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Function
 * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (a -> m z)
 * @param {...Function} ...functions The functions to compose
 * @return {Function}
 * @see R.pipeK
 * @example
 *
 *       //  get :: String -> Object -> Maybe *
 *       var get = R.curry((propName, obj) => Maybe(obj[propName]))
 *
 *       //  getStateCode :: Maybe String -> Maybe String
 *       var getStateCode = R.composeK(
 *         R.compose(Maybe.of, R.toUpper),
 *         get('state'),
 *         get('address'),
 *         get('user'),
 *       );
 *       getStateCode({"user":{"address":{"state":"ny"}}}); //=> Maybe.Just("NY")
 *       getStateCode({}); //=> Maybe.Nothing()
 * @symb R.composeK(f, g, h)(a) = R.chain(f, R.chain(g, h(a)))
 */
function composeK() {
  if (arguments.length === 0) {
    throw new Error('composeK requires at least one argument');
  }
  var init = Array.prototype.slice.call(arguments);
  var last = init.pop();
  return Object(_compose__WEBPACK_IMPORTED_MODULE_1__["default"])(_compose__WEBPACK_IMPORTED_MODULE_1__["default"].apply(this, Object(_map__WEBPACK_IMPORTED_MODULE_2__["default"])(_chain__WEBPACK_IMPORTED_MODULE_0__["default"], init)), last);
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/composeP.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/composeP.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return composeP; });
/* harmony import */ var _pipeP__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pipeP */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipeP.js");
/* harmony import */ var _reverse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reverse */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reverse.js");



/**
 * Performs right-to-left composition of one or more Promise-returning
 * functions. The rightmost function may have any arity; the remaining
 * functions must be unary.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
 * @param {...Function} functions The functions to compose
 * @return {Function}
 * @see R.pipeP
 * @example
 *
 *      var db = {
 *        users: {
 *          JOE: {
 *            name: 'Joe',
 *            followers: ['STEVE', 'SUZY']
 *          }
 *        }
 *      }
 *
 *      // We'll pretend to do a db lookup which returns a promise
 *      var lookupUser = (userId) => Promise.resolve(db.users[userId])
 *      var lookupFollowers = (user) => Promise.resolve(user.followers)
 *      lookupUser('JOE').then(lookupFollowers)
 *
 *      //  followersForUser :: String -> Promise [UserId]
 *      var followersForUser = R.composeP(lookupFollowers, lookupUser);
 *      followersForUser('JOE').then(followers => console.log('Followers:', followers))
 *      // Followers: ["STEVE","SUZY"]
 */
function composeP() {
  if (arguments.length === 0) {
    throw new Error('composeP requires at least one argument');
  }
  return _pipeP__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, Object(_reverse__WEBPACK_IMPORTED_MODULE_1__["default"])(arguments));
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/concat.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/concat.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");
/* harmony import */ var _internal_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_isFunction */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isFunction.js");
/* harmony import */ var _internal_isString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_isString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isString.js");
/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./toString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toString.js");






/**
 * Returns the result of concatenating the given lists or strings.
 *
 * Note: `R.concat` expects both arguments to be of the same type,
 * unlike the native `Array.prototype.concat` method. It will throw
 * an error if you `concat` an Array with a non-Array value.
 *
 * Dispatches to the `concat` method of the first argument, if present.
 * Can also concatenate two members of a [fantasy-land
 * compatible semigroup](https://github.com/fantasyland/fantasy-land#semigroup).
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a] -> [a]
 * @sig String -> String -> String
 * @param {Array|String} firstList The first list
 * @param {Array|String} secondList The second list
 * @return {Array|String} A list consisting of the elements of `firstList` followed by the elements of
 * `secondList`.
 *
 * @example
 *
 *      R.concat('ABC', 'DEF'); // 'ABCDEF'
 *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
 *      R.concat([], []); //=> []
 */
var concat = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function concat(a, b) {
  if (Object(_internal_isArray__WEBPACK_IMPORTED_MODULE_1__["default"])(a)) {
    if (Object(_internal_isArray__WEBPACK_IMPORTED_MODULE_1__["default"])(b)) {
      return a.concat(b);
    }
    throw new TypeError(Object(_toString__WEBPACK_IMPORTED_MODULE_4__["default"])(b) + ' is not an array');
  }
  if (Object(_internal_isString__WEBPACK_IMPORTED_MODULE_3__["default"])(a)) {
    if (Object(_internal_isString__WEBPACK_IMPORTED_MODULE_3__["default"])(b)) {
      return a + b;
    }
    throw new TypeError(Object(_toString__WEBPACK_IMPORTED_MODULE_4__["default"])(b) + ' is not a string');
  }
  if (a != null && Object(_internal_isFunction__WEBPACK_IMPORTED_MODULE_2__["default"])(a['fantasy-land/concat'])) {
    return a['fantasy-land/concat'](b);
  }
  if (a != null && Object(_internal_isFunction__WEBPACK_IMPORTED_MODULE_2__["default"])(a.concat)) {
    return a.concat(b);
  }
  throw new TypeError(Object(_toString__WEBPACK_IMPORTED_MODULE_4__["default"])(a) + ' does not have a method named "concat" or "fantasy-land/concat"');
});
/* harmony default export */ __webpack_exports__["default"] = (concat);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/cond.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/cond.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");
/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./max */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");






/**
 * Returns a function, `fn`, which encapsulates `if/else, if/else, ...` logic.
 * `R.cond` takes a list of [predicate, transformer] pairs. All of the arguments
 * to `fn` are applied to each of the predicates in turn until one returns a
 * "truthy" value, at which point `fn` returns the result of applying its
 * arguments to the corresponding transformer. If none of the predicates
 * matches, `fn` returns undefined.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Logic
 * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
 * @param {Array} pairs A list of [predicate, transformer]
 * @return {Function}
 * @example
 *
 *      var fn = R.cond([
 *        [R.equals(0),   R.always('water freezes at 0Â°C')],
 *        [R.equals(100), R.always('water boils at 100Â°C')],
 *        [R.T,           temp => 'nothing special happens at ' + temp + 'Â°C']
 *      ]);
 *      fn(0); //=> 'water freezes at 0Â°C'
 *      fn(50); //=> 'nothing special happens at 50Â°C'
 *      fn(100); //=> 'water boils at 100Â°C'
 */
var cond = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_1__["default"])(function cond(pairs) {
  var arity = Object(_reduce__WEBPACK_IMPORTED_MODULE_4__["default"])(_max__WEBPACK_IMPORTED_MODULE_3__["default"], 0, Object(_map__WEBPACK_IMPORTED_MODULE_2__["default"])(function (pair) {
    return pair[0].length;
  }, pairs));
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(arity, function () {
    var idx = 0;
    while (idx < pairs.length) {
      if (pairs[idx][0].apply(this, arguments)) {
        return pairs[idx][1].apply(this, arguments);
      }
      idx += 1;
    }
  });
});
/* harmony default export */ __webpack_exports__["default"] = (cond);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/construct.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/construct.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _constructN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constructN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/constructN.js");



/**
 * Wraps a constructor function inside a curried function that can be called
 * with the same arguments and returns the same type.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (* -> {*}) -> (* -> {*})
 * @param {Function} fn The constructor function to wrap.
 * @return {Function} A wrapped, curried constructor function.
 * @see R.invoker
 * @example
 *
 *      // Constructor function
 *      function Animal(kind) {
 *        this.kind = kind;
 *      };
 *      Animal.prototype.sighting = function() {
 *        return "It's a " + this.kind + "!";
 *      }
 *
 *      var AnimalConstructor = R.construct(Animal)
 *
 *      // Notice we no longer need the 'new' keyword:
 *      AnimalConstructor('Pig'); //=> {"kind": "Pig", "sighting": function (){...}};
 *
 *      var animalTypes = ["Lion", "Tiger", "Bear"];
 *      var animalSighting = R.invoker(0, 'sighting');
 *      var sightNewAnimal = R.compose(animalSighting, AnimalConstructor);
 *      R.map(sightNewAnimal, animalTypes); //=> ["It's a Lion!", "It's a Tiger!", "It's a Bear!"]
 */
var construct = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function construct(Fn) {
  return Object(_constructN__WEBPACK_IMPORTED_MODULE_1__["default"])(Fn.length, Fn);
});
/* harmony default export */ __webpack_exports__["default"] = (construct);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/constructN.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/constructN.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curry */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curry.js");
/* harmony import */ var _nAry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nAry */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nAry.js");




/**
 * Wraps a constructor function inside a curried function that can be called
 * with the same arguments and returns the same type. The arity of the function
 * returned is specified to allow using variadic constructor functions.
 *
 * @func
 * @memberOf R
 * @since v0.4.0
 * @category Function
 * @sig Number -> (* -> {*}) -> (* -> {*})
 * @param {Number} n The arity of the constructor function.
 * @param {Function} Fn The constructor function to wrap.
 * @return {Function} A wrapped, curried constructor function.
 * @example
 *
 *      // Variadic Constructor function
 *      function Salad() {
 *        this.ingredients = arguments;
 *      }
 *
 *      Salad.prototype.recipe = function() {
 *        var instructions = R.map(ingredient => 'Add a dollop of ' + ingredient, this.ingredients);
 *        return R.join('\n', instructions);
 *      };
 *
 *      var ThreeLayerSalad = R.constructN(3, Salad);
 *
 *      // Notice we no longer need the 'new' keyword, and the constructor is curried for 3 arguments.
 *      var salad = ThreeLayerSalad('Mayonnaise')('Potato Chips')('Ketchup');
 *
 *      console.log(salad.recipe());
 *      // Add a dollop of Mayonnaise
 *      // Add a dollop of Potato Chips
 *      // Add a dollop of Ketchup
 */
var constructN = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function constructN(n, Fn) {
  if (n > 10) {
    throw new Error('Constructor with greater than ten arguments');
  }
  if (n === 0) {
    return function () {
      return new Fn();
    };
  }
  return Object(_curry__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_nAry__WEBPACK_IMPORTED_MODULE_2__["default"])(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
    switch (arguments.length) {
      case 1:
        return new Fn($0);
      case 2:
        return new Fn($0, $1);
      case 3:
        return new Fn($0, $1, $2);
      case 4:
        return new Fn($0, $1, $2, $3);
      case 5:
        return new Fn($0, $1, $2, $3, $4);
      case 6:
        return new Fn($0, $1, $2, $3, $4, $5);
      case 7:
        return new Fn($0, $1, $2, $3, $4, $5, $6);
      case 8:
        return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
      case 9:
        return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
      case 10:
        return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
    }
  }));
});
/* harmony default export */ __webpack_exports__["default"] = (constructN);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/contains.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/contains.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_contains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_contains */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Returns `true` if the specified value is equal, in [`R.equals`](#equals)
 * terms, to at least one element of the given list; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> Boolean
 * @param {Object} a The item to compare against.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
 * @see R.any
 * @example
 *
 *      R.contains(3, [1, 2, 3]); //=> true
 *      R.contains(4, [1, 2, 3]); //=> false
 *      R.contains({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
 *      R.contains([42], [[42]]); //=> true
 */
var contains = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(_internal_contains__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (contains);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/converge.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/converge.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_map.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./max */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js");
/* harmony import */ var _pluck__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pluck */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pluck.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");







/**
 * Accepts a converging function and a list of branching functions and returns
 * a new function. When invoked, this new function is applied to some
 * arguments, each branching function is applied to those same arguments. The
 * results of each branching function are passed as arguments to the converging
 * function to produce the return value.
 *
 * @func
 * @memberOf R
 * @since v0.4.2
 * @category Function
 * @sig ((x1, x2, ...) -> z) -> [((a, b, ...) -> x1), ((a, b, ...) -> x2), ...] -> (a -> b -> ... -> z)
 * @param {Function} after A function. `after` will be invoked with the return values of
 *        `fn1` and `fn2` as its arguments.
 * @param {Array} functions A list of functions.
 * @return {Function} A new function.
 * @see R.useWith
 * @example
 *
 *      var average = R.converge(R.divide, [R.sum, R.length])
 *      average([1, 2, 3, 4, 5, 6, 7]) //=> 4
 *
 *      var strangeConcat = R.converge(R.concat, [R.toUpper, R.toLower])
 *      strangeConcat("Yodel") //=> "YODELyodel"
 *
 * @symb R.converge(f, [g, h])(a, b) = f(g(a, b), h(a, b))
 */
var converge = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function converge(after, fns) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_reduce__WEBPACK_IMPORTED_MODULE_5__["default"])(_max__WEBPACK_IMPORTED_MODULE_3__["default"], 0, Object(_pluck__WEBPACK_IMPORTED_MODULE_4__["default"])('length', fns)), function () {
    var args = arguments;
    var context = this;
    return after.apply(context, Object(_internal_map__WEBPACK_IMPORTED_MODULE_1__["default"])(function (fn) {
      return fn.apply(context, args);
    }, fns));
  });
});
/* harmony default export */ __webpack_exports__["default"] = (converge);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/countBy.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/countBy.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reduceBy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reduceBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceBy.js");


/**
 * Counts the elements of a list according to how many match each value of a
 * key generated by the supplied function. Returns an object mapping the keys
 * produced by `fn` to the number of occurrences in the list. Note that all
 * keys are coerced to strings because of how JavaScript objects work.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig (a -> String) -> [a] -> {*}
 * @param {Function} fn The function used to map values to keys.
 * @param {Array} list The list to count elements from.
 * @return {Object} An object mapping keys to number of occurrences in the list.
 * @example
 *
 *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
 *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
 *
 *      var letters = ['a', 'b', 'A', 'a', 'B', 'c'];
 *      R.countBy(R.toLower)(letters);   //=> {'a': 3, 'b': 2, 'c': 1}
 */
var countBy = /*#__PURE__*/Object(_reduceBy__WEBPACK_IMPORTED_MODULE_0__["default"])(function (acc, elem) {
  return acc + 1;
}, 0);
/* harmony default export */ __webpack_exports__["default"] = (countBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curry.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curry.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");



/**
 * Returns a curried equivalent of the provided function. The curried function
 * has two unusual capabilities. First, its arguments needn't be provided one
 * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
 * the following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (* -> a) -> (* -> a)
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curryN
 * @example
 *
 *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
 *
 *      var curriedAddFourNumbers = R.curry(addFourNumbers);
 *      var f = curriedAddFourNumbers(1, 2);
 *      var g = f(3);
 *      g(4); //=> 10
 */
var curry = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function curry(fn) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(fn.length, fn);
});
/* harmony default export */ __webpack_exports__["default"] = (curry);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_curryN__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curryN.js");





/**
 * Returns a curried equivalent of the provided function, with the specified
 * arity. The curried function has two unusual capabilities. First, its
 * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
 * the following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curry
 * @example
 *
 *      var sumArgs = (...args) => R.sum(args);
 *
 *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
 *      var f = curriedAddFourNumbers(1, 2);
 *      var g = f(3);
 *      g(4); //=> 10
 */
var curryN = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_2__["default"])(function curryN(length, fn) {
  if (length === 1) {
    return Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_1__["default"])(fn);
  }
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(length, Object(_internal_curryN__WEBPACK_IMPORTED_MODULE_3__["default"])(length, [], fn));
});
/* harmony default export */ __webpack_exports__["default"] = (curryN);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dec.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dec.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _add__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/add.js");


/**
 * Decrements its argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Math
 * @sig Number -> Number
 * @param {Number} n
 * @return {Number} n - 1
 * @see R.inc
 * @example
 *
 *      R.dec(42); //=> 41
 */
var dec = /*#__PURE__*/Object(_add__WEBPACK_IMPORTED_MODULE_0__["default"])(-1);
/* harmony default export */ __webpack_exports__["default"] = (dec);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/defaultTo.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/defaultTo.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns the second argument if it is not `null`, `undefined` or `NaN`;
 * otherwise the first argument is returned.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Logic
 * @sig a -> b -> a | b
 * @param {a} default The default value.
 * @param {b} val `val` will be returned instead of `default` unless `val` is `null`, `undefined` or `NaN`.
 * @return {*} The second value if it is not `null`, `undefined` or `NaN`, otherwise the default value
 * @example
 *
 *      var defaultTo42 = R.defaultTo(42);
 *
 *      defaultTo42(null);  //=> 42
 *      defaultTo42(undefined);  //=> 42
 *      defaultTo42('Ramda');  //=> 'Ramda'
 *      // parseInt('string') results in NaN
 *      defaultTo42(parseInt('string')); //=> 42
 */
var defaultTo = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function defaultTo(d, v) {
  return v == null || v !== v ? d : v;
});
/* harmony default export */ __webpack_exports__["default"] = (defaultTo);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/descend.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/descend.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Makes a descending comparator function out of a function that returns a value
 * that can be compared with `<` and `>`.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Function
 * @sig Ord b => (a -> b) -> a -> a -> Number
 * @param {Function} fn A function of arity one that returns a value that can be compared
 * @param {*} a The first item to be compared.
 * @param {*} b The second item to be compared.
 * @return {Number} `-1` if fn(a) > fn(b), `1` if fn(b) > fn(a), otherwise `0`
 * @see R.ascend
 * @example
 *
 *      var byAge = R.descend(R.prop('age'));
 *      var people = [
 *        // ...
 *      ];
 *      var peopleByOldestFirst = R.sort(byAge, people);
 */
var descend = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function descend(fn, a, b) {
  var aa = fn(a);
  var bb = fn(b);
  return aa > bb ? -1 : aa < bb ? 1 : 0;
});
/* harmony default export */ __webpack_exports__["default"] = (descend);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/difference.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/difference.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_contains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_contains */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Finds the set (i.e. no duplicates) of all elements in the first list not
 * contained in the second list. Objects and Arrays are compared in terms of
 * value equality, not reference equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` that are not in `list2`.
 * @see R.differenceWith, R.symmetricDifference, R.symmetricDifferenceWith, R.without
 * @example
 *
 *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
 *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
 *      R.difference([{a: 1}, {b: 2}], [{a: 1}, {c: 3}]) //=> [{b: 2}]
 */
var difference = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function difference(first, second) {
  var out = [];
  var idx = 0;
  var firstLen = first.length;
  while (idx < firstLen) {
    if (!Object(_internal_contains__WEBPACK_IMPORTED_MODULE_0__["default"])(first[idx], second) && !Object(_internal_contains__WEBPACK_IMPORTED_MODULE_0__["default"])(first[idx], out)) {
      out[out.length] = first[idx];
    }
    idx += 1;
  }
  return out;
});
/* harmony default export */ __webpack_exports__["default"] = (difference);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/differenceWith.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/differenceWith.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_containsWith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_containsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_containsWith.js");
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");



/**
 * Finds the set (i.e. no duplicates) of all elements in the first list not
 * contained in the second list. Duplication is determined according to the
 * value returned by applying the supplied predicate to two list elements.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` that are not in `list2`.
 * @see R.difference, R.symmetricDifference, R.symmetricDifferenceWith
 * @example
 *
 *      var cmp = (x, y) => x.a === y.a;
 *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
 *      var l2 = [{a: 3}, {a: 4}];
 *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
 */
var differenceWith = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_1__["default"])(function differenceWith(pred, first, second) {
  var out = [];
  var idx = 0;
  var firstLen = first.length;
  while (idx < firstLen) {
    if (!Object(_internal_containsWith__WEBPACK_IMPORTED_MODULE_0__["default"])(pred, first[idx], second) && !Object(_internal_containsWith__WEBPACK_IMPORTED_MODULE_0__["default"])(pred, first[idx], out)) {
      out.push(first[idx]);
    }
    idx += 1;
  }
  return out;
});
/* harmony default export */ __webpack_exports__["default"] = (differenceWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dissoc.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dissoc.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns a new object that does not contain a `prop` property.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Object
 * @sig String -> {k: v} -> {k: v}
 * @param {String} prop The name of the property to dissociate
 * @param {Object} obj The object to clone
 * @return {Object} A new object equivalent to the original but without the specified property
 * @see R.assoc
 * @example
 *
 *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
 */
var dissoc = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function dissoc(prop, obj) {
  var result = {};
  for (var p in obj) {
    result[p] = obj[p];
  }
  delete result[prop];
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (dissoc);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dissocPath.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dissocPath.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isInteger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isInteger */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isInteger.js");
/* harmony import */ var _assoc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assoc */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assoc.js");
/* harmony import */ var _dissoc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dissoc */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dissoc.js");
/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./remove */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/remove.js");
/* harmony import */ var _update__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./update */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/update.js");







/**
 * Makes a shallow clone of an object, omitting the property at the given path.
 * Note that this copies and flattens prototype properties onto the new object
 * as well. All non-primitive properties are copied by reference.
 *
 * @func
 * @memberOf R
 * @since v0.11.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig [Idx] -> {k: v} -> {k: v}
 * @param {Array} path The path to the value to omit
 * @param {Object} obj The object to clone
 * @return {Object} A new object without the property at path
 * @see R.assocPath
 * @example
 *
 *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
 */
var dissocPath = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function dissocPath(path, obj) {
  switch (path.length) {
    case 0:
      return obj;
    case 1:
      return Object(_internal_isInteger__WEBPACK_IMPORTED_MODULE_1__["default"])(path[0]) ? Object(_remove__WEBPACK_IMPORTED_MODULE_4__["default"])(path[0], 1, obj) : Object(_dissoc__WEBPACK_IMPORTED_MODULE_3__["default"])(path[0], obj);
    default:
      var head = path[0];
      var tail = Array.prototype.slice.call(path, 1);
      if (obj[head] == null) {
        return obj;
      } else if (Object(_internal_isInteger__WEBPACK_IMPORTED_MODULE_1__["default"])(path[0])) {
        return Object(_update__WEBPACK_IMPORTED_MODULE_5__["default"])(head, dissocPath(tail, obj[head]), obj);
      } else {
        return Object(_assoc__WEBPACK_IMPORTED_MODULE_2__["default"])(head, dissocPath(tail, obj[head]), obj);
      }
  }
});
/* harmony default export */ __webpack_exports__["default"] = (dissocPath);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/divide.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/divide.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Divides two numbers. Equivalent to `a / b`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The first value.
 * @param {Number} b The second value.
 * @return {Number} The result of `a / b`.
 * @see R.multiply
 * @example
 *
 *      R.divide(71, 100); //=> 0.71
 *
 *      var half = R.divide(R.__, 2);
 *      half(42); //=> 21
 *
 *      var reciprocal = R.divide(1);
 *      reciprocal(4);   //=> 0.25
 */
var divide = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function divide(a, b) {
  return a / b;
});
/* harmony default export */ __webpack_exports__["default"] = (divide);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/drop.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/drop.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xdrop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xdrop */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdrop.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");





/**
 * Returns all but the first `n` elements of the given list, string, or
 * transducer/transformer (or object with a `drop` method).
 *
 * Dispatches to the `drop` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n
 * @param {*} list
 * @return {*} A copy of list without the first `n` elements
 * @see R.take, R.transduce, R.dropLast, R.dropWhile
 * @example
 *
 *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
 *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
 *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
 *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
 *      R.drop(3, 'ramda');               //=> 'da'
 */
var drop = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['drop'], _internal_xdrop__WEBPACK_IMPORTED_MODULE_2__["default"], function drop(n, xs) {
  return Object(_slice__WEBPACK_IMPORTED_MODULE_3__["default"])(Math.max(0, n), Infinity, xs);
}));
/* harmony default export */ __webpack_exports__["default"] = (drop);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropLast.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropLast.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_dropLast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_dropLast */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dropLast.js");
/* harmony import */ var _internal_xdropLast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_xdropLast */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropLast.js");





/**
 * Returns a list containing all but the last `n` elements of the given `list`.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n The number of elements of `list` to skip.
 * @param {Array} list The list of elements to consider.
 * @return {Array} A copy of the list with only the first `list.length - n` elements
 * @see R.takeLast, R.drop, R.dropWhile, R.dropLastWhile
 * @example
 *
 *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
 *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
 *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
 *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
 *      R.dropLast(3, 'ramda');               //=> 'ra'
 */
var dropLast = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xdropLast__WEBPACK_IMPORTED_MODULE_3__["default"], _internal_dropLast__WEBPACK_IMPORTED_MODULE_2__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (dropLast);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropLastWhile.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropLastWhile.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_dropLastWhile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_dropLastWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dropLastWhile.js");
/* harmony import */ var _internal_xdropLastWhile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_xdropLastWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropLastWhile.js");





/**
 * Returns a new list excluding all the tailing elements of a given list which
 * satisfy the supplied predicate function. It passes each value from the right
 * to the supplied predicate function, skipping elements until the predicate
 * function returns a `falsy` value. The predicate function is applied to one argument:
 * *(value)*.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @sig (a -> Boolean) -> String -> String
 * @param {Function} predicate The function to be called on each element
 * @param {Array} xs The collection to iterate over.
 * @return {Array} A new array without any trailing elements that return `falsy` values from the `predicate`.
 * @see R.takeLastWhile, R.addIndex, R.drop, R.dropWhile
 * @example
 *
 *      var lteThree = x => x <= 3;
 *
 *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
 *
 *      R.dropLastWhile(x => x !== 'd' , 'Ramda'); //=> 'Ramd'
 */
var dropLastWhile = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xdropLastWhile__WEBPACK_IMPORTED_MODULE_3__["default"], _internal_dropLastWhile__WEBPACK_IMPORTED_MODULE_2__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (dropLastWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropRepeats.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropRepeats.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xdropRepeatsWith__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xdropRepeatsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropRepeatsWith.js");
/* harmony import */ var _dropRepeatsWith__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dropRepeatsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropRepeatsWith.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");






/**
 * Returns a new list without any consecutively repeating elements.
 * [`R.equals`](#equals) is used to determine equality.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig [a] -> [a]
 * @param {Array} list The array to consider.
 * @return {Array} `list` without repeating elements.
 * @see R.transduce
 * @example
 *
 *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
 */
var dropRepeats = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], /*#__PURE__*/Object(_internal_xdropRepeatsWith__WEBPACK_IMPORTED_MODULE_2__["default"])(_equals__WEBPACK_IMPORTED_MODULE_4__["default"]), /*#__PURE__*/Object(_dropRepeatsWith__WEBPACK_IMPORTED_MODULE_3__["default"])(_equals__WEBPACK_IMPORTED_MODULE_4__["default"])));
/* harmony default export */ __webpack_exports__["default"] = (dropRepeats);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropRepeatsWith.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropRepeatsWith.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xdropRepeatsWith__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xdropRepeatsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropRepeatsWith.js");
/* harmony import */ var _last__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./last */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/last.js");





/**
 * Returns a new list without any consecutively repeating elements. Equality is
 * determined by applying the supplied predicate to each pair of consecutive elements. The
 * first element in a series of equal elements will be preserved.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig ((a, a) -> Boolean) -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list The array to consider.
 * @return {Array} `list` without repeating elements.
 * @see R.transduce
 * @example
 *
 *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
 *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
 */
var dropRepeatsWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xdropRepeatsWith__WEBPACK_IMPORTED_MODULE_2__["default"], function dropRepeatsWith(pred, list) {
  var result = [];
  var idx = 1;
  var len = list.length;
  if (len !== 0) {
    result[0] = list[0];
    while (idx < len) {
      if (!pred(Object(_last__WEBPACK_IMPORTED_MODULE_3__["default"])(result), list[idx])) {
        result[result.length] = list[idx];
      }
      idx += 1;
    }
  }
  return result;
}));
/* harmony default export */ __webpack_exports__["default"] = (dropRepeatsWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropWhile.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropWhile.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xdropWhile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xdropWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropWhile.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");





/**
 * Returns a new list excluding the leading elements of a given list which
 * satisfy the supplied predicate function. It passes each value to the supplied
 * predicate function, skipping elements while the predicate function returns
 * `true`. The predicate function is applied to one argument: *(value)*.
 *
 * Dispatches to the `dropWhile` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @sig (a -> Boolean) -> String -> String
 * @param {Function} fn The function called per iteration.
 * @param {Array} xs The collection to iterate over.
 * @return {Array} A new array.
 * @see R.takeWhile, R.transduce, R.addIndex
 * @example
 *
 *      var lteTwo = x => x <= 2;
 *
 *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
 *
 *      R.dropWhile(x => x !== 'd' , 'Ramda'); //=> 'da'
 */
var dropWhile = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['dropWhile'], _internal_xdropWhile__WEBPACK_IMPORTED_MODULE_2__["default"], function dropWhile(pred, xs) {
  var idx = 0;
  var len = xs.length;
  while (idx < len && pred(xs[idx])) {
    idx += 1;
  }
  return Object(_slice__WEBPACK_IMPORTED_MODULE_3__["default"])(idx, Infinity, xs);
}));
/* harmony default export */ __webpack_exports__["default"] = (dropWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/either.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/either.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isFunction */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isFunction.js");
/* harmony import */ var _lift__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lift */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lift.js");
/* harmony import */ var _or__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./or */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/or.js");





/**
 * A function wrapping calls to the two functions in an `||` operation,
 * returning the result of the first function if it is truth-y and the result
 * of the second function otherwise. Note that this is short-circuited,
 * meaning that the second function will not be invoked if the first returns a
 * truth-y value.
 *
 * In addition to functions, `R.either` also accepts any fantasy-land compatible
 * applicative functor.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
 * @param {Function} f a predicate
 * @param {Function} g another predicate
 * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
 * @see R.or
 * @example
 *
 *      var gt10 = x => x > 10;
 *      var even = x => x % 2 === 0;
 *      var f = R.either(gt10, even);
 *      f(101); //=> true
 *      f(8); //=> true
 */
var either = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function either(f, g) {
  return Object(_internal_isFunction__WEBPACK_IMPORTED_MODULE_1__["default"])(f) ? function _either() {
    return f.apply(this, arguments) || g.apply(this, arguments);
  } : Object(_lift__WEBPACK_IMPORTED_MODULE_2__["default"])(_or__WEBPACK_IMPORTED_MODULE_3__["default"])(f, g);
});
/* harmony default export */ __webpack_exports__["default"] = (either);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/empty.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/empty.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_isArguments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isArguments */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArguments.js");
/* harmony import */ var _internal_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");
/* harmony import */ var _internal_isObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_isObject */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isObject.js");
/* harmony import */ var _internal_isString__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/_isString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isString.js");






/**
 * Returns the empty value of its argument's type. Ramda defines the empty
 * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
 * types are supported if they define `<Type>.empty`,
 * `<Type>.prototype.empty` or implement the
 * [FantasyLand Monoid spec](https://github.com/fantasyland/fantasy-land#monoid).
 *
 * Dispatches to the `empty` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Function
 * @sig a -> a
 * @param {*} x
 * @return {*}
 * @example
 *
 *      R.empty(Just(42));      //=> Nothing()
 *      R.empty([1, 2, 3]);     //=> []
 *      R.empty('unicorns');    //=> ''
 *      R.empty({x: 1, y: 2});  //=> {}
 */
var empty = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function empty(x) {
  return x != null && typeof x['fantasy-land/empty'] === 'function' ? x['fantasy-land/empty']() : x != null && x.constructor != null && typeof x.constructor['fantasy-land/empty'] === 'function' ? x.constructor['fantasy-land/empty']() : x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : Object(_internal_isArray__WEBPACK_IMPORTED_MODULE_2__["default"])(x) ? [] : Object(_internal_isString__WEBPACK_IMPORTED_MODULE_4__["default"])(x) ? '' : Object(_internal_isObject__WEBPACK_IMPORTED_MODULE_3__["default"])(x) ? {} : Object(_internal_isArguments__WEBPACK_IMPORTED_MODULE_1__["default"])(x) ? function () {
    return arguments;
  }() :
  // else
  void 0;
});
/* harmony default export */ __webpack_exports__["default"] = (empty);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/endsWith.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/endsWith.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");
/* harmony import */ var _takeLast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./takeLast */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeLast.js");




/**
 * Checks if a list ends with the provided values
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category List
 * @sig [a] -> Boolean
 * @sig String -> Boolean
 * @param {*} suffix
 * @param {*} list
 * @return {Boolean}
 * @example
 *
 *      R.endsWith('c', 'abc')                //=> true
 *      R.endsWith('b', 'abc')                //=> false
 *      R.endsWith(['c'], ['a', 'b', 'c'])    //=> true
 *      R.endsWith(['b'], ['a', 'b', 'c'])    //=> false
 */
var endsWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function (suffix, list) {
  return Object(_equals__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_takeLast__WEBPACK_IMPORTED_MODULE_2__["default"])(suffix.length, list), suffix);
});
/* harmony default export */ __webpack_exports__["default"] = (endsWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/eqBy.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/eqBy.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");



/**
 * Takes a function and two values in its domain and returns `true` if the
 * values map to the same value in the codomain; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Relation
 * @sig (a -> b) -> a -> a -> Boolean
 * @param {Function} f
 * @param {*} x
 * @param {*} y
 * @return {Boolean}
 * @example
 *
 *      R.eqBy(Math.abs, 5, -5); //=> true
 */
var eqBy = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function eqBy(f, x, y) {
  return Object(_equals__WEBPACK_IMPORTED_MODULE_1__["default"])(f(x), f(y));
});
/* harmony default export */ __webpack_exports__["default"] = (eqBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/eqProps.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/eqProps.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");



/**
 * Reports whether two objects have the same value, in [`R.equals`](#equals)
 * terms, for the specified property. Useful as a curried predicate.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig k -> {k: v} -> {k: v} -> Boolean
 * @param {String} prop The name of the property to compare
 * @param {Object} obj1
 * @param {Object} obj2
 * @return {Boolean}
 *
 * @example
 *
 *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
 *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
 *      R.eqProps('a', o1, o2); //=> false
 *      R.eqProps('c', o1, o2); //=> true
 */
var eqProps = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function eqProps(prop, obj1, obj2) {
  return Object(_equals__WEBPACK_IMPORTED_MODULE_1__["default"])(obj1[prop], obj2[prop]);
});
/* harmony default export */ __webpack_exports__["default"] = (eqProps);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_equals.js");



/**
 * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
 * cyclical data structures.
 *
 * Dispatches symmetrically to the `equals` methods of both arguments, if
 * present.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> b -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      R.equals(1, 1); //=> true
 *      R.equals(1, '1'); //=> false
 *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
 *
 *      var a = {}; a.v = a;
 *      var b = {}; b.v = b;
 *      R.equals(a, b); //=> true
 */
var equals = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function equals(a, b) {
  return Object(_internal_equals__WEBPACK_IMPORTED_MODULE_1__["default"])(a, b, [], []);
});
/* harmony default export */ __webpack_exports__["default"] = (equals);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/evolve.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/evolve.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Creates a new object by recursively evolving a shallow copy of `object`,
 * according to the `transformation` functions. All non-primitive properties
 * are copied by reference.
 *
 * A `transformation` function will not be invoked if its corresponding key
 * does not exist in the evolved object.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig {k: (v -> v)} -> {k: v} -> {k: v}
 * @param {Object} transformations The object specifying transformation functions to apply
 *        to the object.
 * @param {Object} object The object to be transformed.
 * @return {Object} The transformed object.
 * @example
 *
 *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
 *      var transformations = {
 *        firstName: R.trim,
 *        lastName: R.trim, // Will not get invoked.
 *        data: {elapsed: R.add(1), remaining: R.add(-1)}
 *      };
 *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
 */
var evolve = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function evolve(transformations, object) {
  var result = {};
  var transformation, key, type;
  for (key in object) {
    transformation = transformations[key];
    type = typeof transformation;
    result[key] = type === 'function' ? transformation(object[key]) : transformation && type === 'object' ? evolve(transformation, object[key]) : object[key];
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (evolve);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/filter.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/filter.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_filter */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_filter.js");
/* harmony import */ var _internal_isObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_isObject */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isObject.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _internal_xfilter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./internal/_xfilter */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfilter.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");








/**
 * Takes a predicate and a `Filterable`, and returns a new filterable of the
 * same type containing the members of the given filterable which satisfy the
 * given predicate. Filterable objects include plain objects or any object
 * that has a filter method such as `Array`.
 *
 * Dispatches to the `filter` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array} Filterable
 * @see R.reject, R.transduce, R.addIndex
 * @example
 *
 *      var isEven = n => n % 2 === 0;
 *
 *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */
var filter = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['filter'], _internal_xfilter__WEBPACK_IMPORTED_MODULE_5__["default"], function (pred, filterable) {
  return Object(_internal_isObject__WEBPACK_IMPORTED_MODULE_3__["default"])(filterable) ? Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_4__["default"])(function (acc, key) {
    if (pred(filterable[key])) {
      acc[key] = filterable[key];
    }
    return acc;
  }, {}, Object(_keys__WEBPACK_IMPORTED_MODULE_6__["default"])(filterable)) :
  // else
  Object(_internal_filter__WEBPACK_IMPORTED_MODULE_2__["default"])(pred, filterable);
}));
/* harmony default export */ __webpack_exports__["default"] = (filter);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/find.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/find.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xfind__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xfind */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfind.js");




/**
 * Returns the first element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Dispatches to the `find` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> a | undefined
 * @param {Function} fn The predicate function used to determine if the element is the
 *        desired one.
 * @param {Array} list The array to consider.
 * @return {Object} The element found, or `undefined`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
 *      R.find(R.propEq('a', 4))(xs); //=> undefined
 */
var find = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['find'], _internal_xfind__WEBPACK_IMPORTED_MODULE_2__["default"], function find(fn, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    if (fn(list[idx])) {
      return list[idx];
    }
    idx += 1;
  }
}));
/* harmony default export */ __webpack_exports__["default"] = (find);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findIndex.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findIndex.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xfindIndex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xfindIndex */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindIndex.js");




/**
 * Returns the index of the first element of the list which matches the
 * predicate, or `-1` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> Number
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Number} The index of the element found, or `-1`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
 *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
 */
var findIndex = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xfindIndex__WEBPACK_IMPORTED_MODULE_2__["default"], function findIndex(fn, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    if (fn(list[idx])) {
      return idx;
    }
    idx += 1;
  }
  return -1;
}));
/* harmony default export */ __webpack_exports__["default"] = (findIndex);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findLast.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findLast.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xfindLast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xfindLast */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindLast.js");




/**
 * Returns the last element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> a | undefined
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Object} The element found, or `undefined`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
 *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
 *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
 */
var findLast = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xfindLast__WEBPACK_IMPORTED_MODULE_2__["default"], function findLast(fn, list) {
  var idx = list.length - 1;
  while (idx >= 0) {
    if (fn(list[idx])) {
      return list[idx];
    }
    idx -= 1;
  }
}));
/* harmony default export */ __webpack_exports__["default"] = (findLast);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findLastIndex.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findLastIndex.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xfindLastIndex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xfindLastIndex */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindLastIndex.js");




/**
 * Returns the index of the last element of the list which matches the
 * predicate, or `-1` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> Number
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Number} The index of the element found, or `-1`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
 *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
 *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
 */
var findLastIndex = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xfindLastIndex__WEBPACK_IMPORTED_MODULE_2__["default"], function findLastIndex(fn, list) {
  var idx = list.length - 1;
  while (idx >= 0) {
    if (fn(list[idx])) {
      return idx;
    }
    idx -= 1;
  }
  return -1;
}));
/* harmony default export */ __webpack_exports__["default"] = (findLastIndex);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flatten.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flatten.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_makeFlat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_makeFlat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_makeFlat.js");



/**
 * Returns a new list by pulling every item out of it (and all its sub-arrays)
 * and putting them in a new array, depth-first.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [b]
 * @param {Array} list The array to consider.
 * @return {Array} The flattened list.
 * @see R.unnest
 * @example
 *
 *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
 *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
 */
var flatten = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_makeFlat__WEBPACK_IMPORTED_MODULE_1__["default"])(true));
/* harmony default export */ __webpack_exports__["default"] = (flatten);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flip.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flip.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");



/**
 * Returns a new function much like the supplied one, except that the first two
 * arguments' order is reversed.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((a, b, c, ...) -> z) -> (b -> a -> c -> ... -> z)
 * @param {Function} fn The function to invoke with its first two parameters reversed.
 * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
 * @example
 *
 *      var mergeThree = (a, b, c) => [].concat(a, b, c);
 *
 *      mergeThree(1, 2, 3); //=> [1, 2, 3]
 *
 *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
 * @symb R.flip(f)(a, b, c) = f(b, a, c)
 */
var flip = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function flip(fn) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(fn.length, function (a, b) {
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = b;
    args[1] = a;
    return fn.apply(this, args);
  });
});
/* harmony default export */ __webpack_exports__["default"] = (flip);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/forEach.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/forEach.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_checkForMethod */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_checkForMethod.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Iterate over an input `list`, calling a provided function `fn` for each
 * element in the list.
 *
 * `fn` receives one argument: *(value)*.
 *
 * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.forEach` method. For more
 * details on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
 *
 * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
 * the original array. In some libraries this function is named `each`.
 *
 * Dispatches to the `forEach` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> *) -> [a] -> [a]
 * @param {Function} fn The function to invoke. Receives one argument, `value`.
 * @param {Array} list The list to iterate over.
 * @return {Array} The original list.
 * @see R.addIndex
 * @example
 *
 *      var printXPlusFive = x => console.log(x + 5);
 *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
 *      // logs 6
 *      // logs 7
 *      // logs 8
 * @symb R.forEach(f, [a, b, c]) = [a, b, c]
 */
var forEach = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__["default"])('forEach', function forEach(fn, list) {
  var len = list.length;
  var idx = 0;
  while (idx < len) {
    fn(list[idx]);
    idx += 1;
  }
  return list;
}));
/* harmony default export */ __webpack_exports__["default"] = (forEach);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/forEachObjIndexed.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/forEachObjIndexed.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");



/**
 * Iterate over an input `object`, calling a provided function `fn` for each
 * key and value in the object.
 *
 * `fn` receives three argument: *(value, key, obj)*.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Object
 * @sig ((a, String, StrMap a) -> Any) -> StrMap a -> StrMap a
 * @param {Function} fn The function to invoke. Receives three argument, `value`, `key`, `obj`.
 * @param {Object} obj The object to iterate over.
 * @return {Object} The original object.
 * @example
 *
 *      var printKeyConcatValue = (value, key) => console.log(key + ':' + value);
 *      R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=> {x: 1, y: 2}
 *      // logs x:1
 *      // logs y:2
 * @symb R.forEachObjIndexed(f, {x: a, y: b}) = {x: a, y: b}
 */
var forEachObjIndexed = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function forEachObjIndexed(fn, obj) {
  var keyList = Object(_keys__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
  var idx = 0;
  while (idx < keyList.length) {
    var key = keyList[idx];
    fn(obj[key], key, obj);
    idx += 1;
  }
  return obj;
});
/* harmony default export */ __webpack_exports__["default"] = (forEachObjIndexed);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/fromPairs.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/fromPairs.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Creates a new object from a list key-value pairs. If a key appears in
 * multiple pairs, the rightmost pair is included in the object.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig [[k,v]] -> {k: v}
 * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
 * @return {Object} The object made by pairing up `keys` and `values`.
 * @see R.toPairs, R.pair
 * @example
 *
 *      R.fromPairs([['a', 1], ['b', 2], ['c', 3]]); //=> {a: 1, b: 2, c: 3}
 */
var fromPairs = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function fromPairs(pairs) {
  var result = {};
  var idx = 0;
  while (idx < pairs.length) {
    result[pairs[idx][0]] = pairs[idx][1];
    idx += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (fromPairs);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/groupBy.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/groupBy.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_checkForMethod */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_checkForMethod.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduceBy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reduceBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceBy.js");




/**
 * Splits a list into sub-lists stored in an object, based on the result of
 * calling a String-returning function on each element, and grouping the
 * results according to values returned.
 *
 * Dispatches to the `groupBy` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> String) -> [a] -> {String: [a]}
 * @param {Function} fn Function :: a -> String
 * @param {Array} list The array to group
 * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
 *         that produced that key when passed to `fn`.
 * @see R.transduce
 * @example
 *
 *      var byGrade = R.groupBy(function(student) {
 *        var score = student.score;
 *        return score < 65 ? 'F' :
 *               score < 70 ? 'D' :
 *               score < 80 ? 'C' :
 *               score < 90 ? 'B' : 'A';
 *      });
 *      var students = [{name: 'Abby', score: 84},
 *                      {name: 'Eddy', score: 58},
 *                      // ...
 *                      {name: 'Jack', score: 69}];
 *      byGrade(students);
 *      // {
 *      //   'A': [{name: 'Dianne', score: 99}],
 *      //   'B': [{name: 'Abby', score: 84}]
 *      //   // ...,
 *      //   'F': [{name: 'Eddy', score: 58}]
 *      // }
 */
var groupBy = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__["default"])('groupBy', /*#__PURE__*/Object(_reduceBy__WEBPACK_IMPORTED_MODULE_2__["default"])(function (acc, item) {
  if (acc == null) {
    acc = [];
  }
  acc.push(item);
  return acc;
}, null)));
/* harmony default export */ __webpack_exports__["default"] = (groupBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/groupWith.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/groupWith.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Takes a list and returns a list of lists where each sublist's elements are
 * all satisfied pairwise comparison according to the provided function.
 * Only adjacent elements are passed to the comparison function.
 *
 * @func
 * @memberOf R
 * @since v0.21.0
 * @category List
 * @sig ((a, a) â Boolean) â [a] â [[a]]
 * @param {Function} fn Function for determining whether two given (adjacent)
 *        elements should be in the same group
 * @param {Array} list The array to group. Also accepts a string, which will be
 *        treated as a list of characters.
 * @return {List} A list that contains sublists of elements,
 *         whose concatenations are equal to the original list.
 * @example
 *
 * R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
 * //=> [[0], [1, 1], [2], [3], [5], [8], [13], [21]]
 *
 * R.groupWith((a, b) => a + 1 === b, [0, 1, 1, 2, 3, 5, 8, 13, 21])
 * //=> [[0, 1], [1, 2, 3], [5], [8], [13], [21]]
 *
 * R.groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
 * //=> [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
 *
 * R.groupWith(R.eqBy(isVowel), 'aestiou')
 * //=> ['ae', 'st', 'iou']
 */
var groupWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function (fn, list) {
  var res = [];
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    var nextidx = idx + 1;
    while (nextidx < len && fn(list[nextidx - 1], list[nextidx])) {
      nextidx += 1;
    }
    res.push(list.slice(idx, nextidx));
    idx = nextidx;
  }
  return res;
});
/* harmony default export */ __webpack_exports__["default"] = (groupWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/gt.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/gt.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns `true` if the first argument is greater than the second; `false`
 * otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @see R.lt
 * @example
 *
 *      R.gt(2, 1); //=> true
 *      R.gt(2, 2); //=> false
 *      R.gt(2, 3); //=> false
 *      R.gt('a', 'z'); //=> false
 *      R.gt('z', 'a'); //=> true
 */
var gt = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function gt(a, b) {
  return a > b;
});
/* harmony default export */ __webpack_exports__["default"] = (gt);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/gte.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/gte.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns `true` if the first argument is greater than or equal to the second;
 * `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {Number} a
 * @param {Number} b
 * @return {Boolean}
 * @see R.lte
 * @example
 *
 *      R.gte(2, 1); //=> true
 *      R.gte(2, 2); //=> true
 *      R.gte(2, 3); //=> false
 *      R.gte('a', 'z'); //=> false
 *      R.gte('z', 'a'); //=> true
 */
var gte = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function gte(a, b) {
  return a >= b;
});
/* harmony default export */ __webpack_exports__["default"] = (gte);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/has.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/has.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");



/**
 * Returns whether or not an object has an own property with the specified name
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Object
 * @sig s -> {s: x} -> Boolean
 * @param {String} prop The name of the property to check for.
 * @param {Object} obj The object to query.
 * @return {Boolean} Whether the property exists.
 * @example
 *
 *      var hasName = R.has('name');
 *      hasName({name: 'alice'});   //=> true
 *      hasName({name: 'bob'});     //=> true
 *      hasName({});                //=> false
 *
 *      var point = {x: 0, y: 0};
 *      var pointHas = R.has(R.__, point);
 *      pointHas('x');  //=> true
 *      pointHas('y');  //=> true
 *      pointHas('z');  //=> false
 */
var has = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (has);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/hasIn.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/hasIn.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns whether or not an object or its prototype chain has a property with
 * the specified name
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Object
 * @sig s -> {s: x} -> Boolean
 * @param {String} prop The name of the property to check for.
 * @param {Object} obj The object to query.
 * @return {Boolean} Whether the property exists.
 * @example
 *
 *      function Rectangle(width, height) {
 *        this.width = width;
 *        this.height = height;
 *      }
 *      Rectangle.prototype.area = function() {
 *        return this.width * this.height;
 *      };
 *
 *      var square = new Rectangle(2, 2);
 *      R.hasIn('width', square);  //=> true
 *      R.hasIn('area', square);  //=> true
 */
var hasIn = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function hasIn(prop, obj) {
  return prop in obj;
});
/* harmony default export */ __webpack_exports__["default"] = (hasIn);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/head.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/head.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nth */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nth.js");


/**
 * Returns the first element of the given list or string. In some libraries
 * this function is named `first`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> a | Undefined
 * @sig String -> String
 * @param {Array|String} list
 * @return {*}
 * @see R.tail, R.init, R.last
 * @example
 *
 *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
 *      R.head([]); //=> undefined
 *
 *      R.head('abc'); //=> 'a'
 *      R.head(''); //=> ''
 */
var head = /*#__PURE__*/Object(_nth__WEBPACK_IMPORTED_MODULE_0__["default"])(0);
/* harmony default export */ __webpack_exports__["default"] = (head);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identical.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identical.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns true if its arguments are identical, false otherwise. Values are
 * identical if they reference the same memory. `NaN` is identical to `NaN`;
 * `0` and `-0` are not identical.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      var o = {};
 *      R.identical(o, o); //=> true
 *      R.identical(1, 1); //=> true
 *      R.identical(1, '1'); //=> false
 *      R.identical([], []); //=> false
 *      R.identical(0, -0); //=> false
 *      R.identical(NaN, NaN); //=> true
 */
var identical = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function identical(a, b) {
  // SameValue algorithm
  if (a === b) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return a !== 0 || 1 / a === 1 / b;
  } else {
    // Step 6.a: NaN == NaN
    return a !== a && b !== b;
  }
});
/* harmony default export */ __webpack_exports__["default"] = (identical);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identity.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identity.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_identity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_identity.js");



/**
 * A function that does nothing but return the parameter supplied to it. Good
 * as a default or placeholder function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig a -> a
 * @param {*} x The value to return.
 * @return {*} The input value, `x`.
 * @example
 *
 *      R.identity(1); //=> 1
 *
 *      var obj = {};
 *      R.identity(obj) === obj; //=> true
 * @symb R.identity(a) = a
 */
var identity = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(_internal_identity__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (identity);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ifElse.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ifElse.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");



/**
 * Creates a function that will process either the `onTrue` or the `onFalse`
 * function depending upon the result of the `condition` predicate.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
 * @param {Function} condition A predicate function
 * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
 * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
 * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
 *                    function depending upon the result of the `condition` predicate.
 * @see R.unless, R.when
 * @example
 *
 *      var incCount = R.ifElse(
 *        R.has('count'),
 *        R.over(R.lensProp('count'), R.inc),
 *        R.assoc('count', 1)
 *      );
 *      incCount({});           //=> { count: 1 }
 *      incCount({ count: 1 }); //=> { count: 2 }
 */
var ifElse = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function ifElse(condition, onTrue, onFalse) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
    return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
  });
});
/* harmony default export */ __webpack_exports__["default"] = (ifElse);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/inc.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/inc.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _add__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/add.js");


/**
 * Increments its argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Math
 * @sig Number -> Number
 * @param {Number} n
 * @return {Number} n + 1
 * @see R.dec
 * @example
 *
 *      R.inc(42); //=> 43
 */
var inc = /*#__PURE__*/Object(_add__WEBPACK_IMPORTED_MODULE_0__["default"])(1);
/* harmony default export */ __webpack_exports__["default"] = (inc);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js ***!
  \**************************************************************************************/
/*! exports provided: F, T, __, add, addIndex, adjust, all, allPass, always, and, any, anyPass, ap, aperture, append, apply, applySpec, applyTo, ascend, assoc, assocPath, binary, bind, both, call, chain, clamp, clone, comparator, complement, compose, composeK, composeP, concat, cond, construct, constructN, contains, converge, countBy, curry, curryN, dec, defaultTo, descend, difference, differenceWith, dissoc, dissocPath, divide, drop, dropLast, dropLastWhile, dropRepeats, dropRepeatsWith, dropWhile, either, empty, endsWith, eqBy, eqProps, equals, evolve, filter, find, findIndex, findLast, findLastIndex, flatten, flip, forEach, forEachObjIndexed, fromPairs, groupBy, groupWith, gt, gte, has, hasIn, head, identical, identity, ifElse, inc, indexBy, indexOf, init, innerJoin, insert, insertAll, intersection, intersperse, into, invert, invertObj, invoker, is, isEmpty, isNil, join, juxt, keys, keysIn, last, lastIndexOf, length, lens, lensIndex, lensPath, lensProp, lift, liftN, lt, lte, map, mapAccum, mapAccumRight, mapObjIndexed, match, mathMod, max, maxBy, mean, median, memoize, memoizeWith, merge, mergeAll, mergeDeepLeft, mergeDeepRight, mergeDeepWith, mergeDeepWithKey, mergeWith, mergeWithKey, min, minBy, modulo, multiply, nAry, negate, none, not, nth, nthArg, o, objOf, of, omit, once, or, over, pair, partial, partialRight, partition, path, pathEq, pathOr, pathSatisfies, pick, pickAll, pickBy, pipe, pipeK, pipeP, pluck, prepend, product, project, prop, propEq, propIs, propOr, propSatisfies, props, range, reduce, reduceBy, reduceRight, reduceWhile, reduced, reject, remove, repeat, replace, reverse, scan, sequence, set, slice, sort, sortBy, sortWith, split, splitAt, splitEvery, splitWhen, startsWith, subtract, sum, symmetricDifference, symmetricDifferenceWith, tail, take, takeLast, takeLastWhile, takeWhile, tap, test, times, toLower, toPairs, toPairsIn, toString, toUpper, transduce, transpose, traverse, trim, tryCatch, type, unapply, unary, uncurryN, unfold, union, unionWith, uniq, uniqBy, uniqWith, unless, unnest, until, update, useWith, values, valuesIn, view, when, where, whereEq, without, xprod, zip, zipObj, zipWith */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _F__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./F */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/F.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "F", function() { return _F__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _T__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./T */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/T.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "T", function() { return _T__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./__ */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/__.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "__", function() { return ___WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _add__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./add */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/add.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "add", function() { return _add__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _addIndex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./addIndex */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/addIndex.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addIndex", function() { return _addIndex__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _adjust__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./adjust */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/adjust.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "adjust", function() { return _adjust__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _all__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./all */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/all.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "all", function() { return _all__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _allPass__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./allPass */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/allPass.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allPass", function() { return _allPass__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _always__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./always */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "always", function() { return _always__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _and__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./and */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/and.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "and", function() { return _and__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _any__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./any */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/any.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "any", function() { return _any__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _anyPass__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./anyPass */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/anyPass.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "anyPass", function() { return _anyPass__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _ap__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ap", function() { return _ap__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _aperture__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./aperture */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/aperture.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "aperture", function() { return _aperture__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _append__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./append */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/append.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "append", function() { return _append__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _apply__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./apply */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/apply.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "apply", function() { return _apply__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _applySpec__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./applySpec */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/applySpec.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applySpec", function() { return _applySpec__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _applyTo__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./applyTo */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/applyTo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyTo", function() { return _applyTo__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _ascend__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./ascend */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ascend.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ascend", function() { return _ascend__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _assoc__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./assoc */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assoc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assoc", function() { return _assoc__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _assocPath__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./assocPath */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assocPath.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assocPath", function() { return _assocPath__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _binary__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./binary */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/binary.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "binary", function() { return _binary__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _bind__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./bind */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/bind.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bind", function() { return _bind__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _both__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./both */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/both.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "both", function() { return _both__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _call__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./call */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/call.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "call", function() { return _call__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _chain__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./chain */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/chain.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chain", function() { return _chain__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _clamp__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./clamp */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/clamp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return _clamp__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _clone__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./clone */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/clone.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _clone__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony import */ var _comparator__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./comparator */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/comparator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "comparator", function() { return _comparator__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony import */ var _complement__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./complement */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/complement.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "complement", function() { return _complement__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./compose */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/compose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return _compose__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony import */ var _composeK__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./composeK */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/composeK.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "composeK", function() { return _composeK__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _composeP__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./composeP */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/composeP.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "composeP", function() { return _composeP__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony import */ var _concat__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/concat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return _concat__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony import */ var _cond__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./cond */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/cond.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cond", function() { return _cond__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony import */ var _construct__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./construct */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/construct.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "construct", function() { return _construct__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony import */ var _constructN__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./constructN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/constructN.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "constructN", function() { return _constructN__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony import */ var _contains__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./contains */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/contains.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "contains", function() { return _contains__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony import */ var _converge__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./converge */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/converge.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "converge", function() { return _converge__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony import */ var _countBy__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./countBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/countBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "countBy", function() { return _countBy__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./curry */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curry", function() { return _curry__WEBPACK_IMPORTED_MODULE_40__["default"]; });

/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curryN", function() { return _curryN__WEBPACK_IMPORTED_MODULE_41__["default"]; });

/* harmony import */ var _dec__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./dec */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dec.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dec", function() { return _dec__WEBPACK_IMPORTED_MODULE_42__["default"]; });

/* harmony import */ var _defaultTo__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./defaultTo */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/defaultTo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultTo", function() { return _defaultTo__WEBPACK_IMPORTED_MODULE_43__["default"]; });

/* harmony import */ var _descend__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./descend */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/descend.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "descend", function() { return _descend__WEBPACK_IMPORTED_MODULE_44__["default"]; });

/* harmony import */ var _difference__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./difference */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/difference.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "difference", function() { return _difference__WEBPACK_IMPORTED_MODULE_45__["default"]; });

/* harmony import */ var _differenceWith__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./differenceWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/differenceWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "differenceWith", function() { return _differenceWith__WEBPACK_IMPORTED_MODULE_46__["default"]; });

/* harmony import */ var _dissoc__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./dissoc */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dissoc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dissoc", function() { return _dissoc__WEBPACK_IMPORTED_MODULE_47__["default"]; });

/* harmony import */ var _dissocPath__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./dissocPath */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dissocPath.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dissocPath", function() { return _dissocPath__WEBPACK_IMPORTED_MODULE_48__["default"]; });

/* harmony import */ var _divide__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./divide */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/divide.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return _divide__WEBPACK_IMPORTED_MODULE_49__["default"]; });

/* harmony import */ var _drop__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./drop */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/drop.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drop", function() { return _drop__WEBPACK_IMPORTED_MODULE_50__["default"]; });

/* harmony import */ var _dropLast__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./dropLast */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropLast.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dropLast", function() { return _dropLast__WEBPACK_IMPORTED_MODULE_51__["default"]; });

/* harmony import */ var _dropLastWhile__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./dropLastWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropLastWhile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dropLastWhile", function() { return _dropLastWhile__WEBPACK_IMPORTED_MODULE_52__["default"]; });

/* harmony import */ var _dropRepeats__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./dropRepeats */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropRepeats.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dropRepeats", function() { return _dropRepeats__WEBPACK_IMPORTED_MODULE_53__["default"]; });

/* harmony import */ var _dropRepeatsWith__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./dropRepeatsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropRepeatsWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dropRepeatsWith", function() { return _dropRepeatsWith__WEBPACK_IMPORTED_MODULE_54__["default"]; });

/* harmony import */ var _dropWhile__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./dropWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropWhile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dropWhile", function() { return _dropWhile__WEBPACK_IMPORTED_MODULE_55__["default"]; });

/* harmony import */ var _either__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./either */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/either.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "either", function() { return _either__WEBPACK_IMPORTED_MODULE_56__["default"]; });

/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./empty */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/empty.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "empty", function() { return _empty__WEBPACK_IMPORTED_MODULE_57__["default"]; });

/* harmony import */ var _endsWith__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./endsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/endsWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "endsWith", function() { return _endsWith__WEBPACK_IMPORTED_MODULE_58__["default"]; });

/* harmony import */ var _eqBy__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./eqBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/eqBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eqBy", function() { return _eqBy__WEBPACK_IMPORTED_MODULE_59__["default"]; });

/* harmony import */ var _eqProps__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./eqProps */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/eqProps.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eqProps", function() { return _eqProps__WEBPACK_IMPORTED_MODULE_60__["default"]; });

/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return _equals__WEBPACK_IMPORTED_MODULE_61__["default"]; });

/* harmony import */ var _evolve__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./evolve */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/evolve.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "evolve", function() { return _evolve__WEBPACK_IMPORTED_MODULE_62__["default"]; });

/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./filter */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/filter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return _filter__WEBPACK_IMPORTED_MODULE_63__["default"]; });

/* harmony import */ var _find__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./find */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/find.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "find", function() { return _find__WEBPACK_IMPORTED_MODULE_64__["default"]; });

/* harmony import */ var _findIndex__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./findIndex */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findIndex.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return _findIndex__WEBPACK_IMPORTED_MODULE_65__["default"]; });

/* harmony import */ var _findLast__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./findLast */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findLast.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findLast", function() { return _findLast__WEBPACK_IMPORTED_MODULE_66__["default"]; });

/* harmony import */ var _findLastIndex__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./findLastIndex */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findLastIndex.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findLastIndex", function() { return _findLastIndex__WEBPACK_IMPORTED_MODULE_67__["default"]; });

/* harmony import */ var _flatten__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./flatten */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flatten.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return _flatten__WEBPACK_IMPORTED_MODULE_68__["default"]; });

/* harmony import */ var _flip__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./flip */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flip", function() { return _flip__WEBPACK_IMPORTED_MODULE_69__["default"]; });

/* harmony import */ var _forEach__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./forEach */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/forEach.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return _forEach__WEBPACK_IMPORTED_MODULE_70__["default"]; });

/* harmony import */ var _forEachObjIndexed__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./forEachObjIndexed */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/forEachObjIndexed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEachObjIndexed", function() { return _forEachObjIndexed__WEBPACK_IMPORTED_MODULE_71__["default"]; });

/* harmony import */ var _fromPairs__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./fromPairs */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/fromPairs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fromPairs", function() { return _fromPairs__WEBPACK_IMPORTED_MODULE_72__["default"]; });

/* harmony import */ var _groupBy__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./groupBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/groupBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "groupBy", function() { return _groupBy__WEBPACK_IMPORTED_MODULE_73__["default"]; });

/* harmony import */ var _groupWith__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./groupWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/groupWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "groupWith", function() { return _groupWith__WEBPACK_IMPORTED_MODULE_74__["default"]; });

/* harmony import */ var _gt__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./gt */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/gt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gt", function() { return _gt__WEBPACK_IMPORTED_MODULE_75__["default"]; });

/* harmony import */ var _gte__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./gte */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/gte.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gte", function() { return _gte__WEBPACK_IMPORTED_MODULE_76__["default"]; });

/* harmony import */ var _has__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/has.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "has", function() { return _has__WEBPACK_IMPORTED_MODULE_77__["default"]; });

/* harmony import */ var _hasIn__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./hasIn */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/hasIn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasIn", function() { return _hasIn__WEBPACK_IMPORTED_MODULE_78__["default"]; });

/* harmony import */ var _head__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./head */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/head.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "head", function() { return _head__WEBPACK_IMPORTED_MODULE_79__["default"]; });

/* harmony import */ var _identical__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./identical */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identical.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "identical", function() { return _identical__WEBPACK_IMPORTED_MODULE_80__["default"]; });

/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./identity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identity.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return _identity__WEBPACK_IMPORTED_MODULE_81__["default"]; });

/* harmony import */ var _ifElse__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./ifElse */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ifElse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ifElse", function() { return _ifElse__WEBPACK_IMPORTED_MODULE_82__["default"]; });

/* harmony import */ var _inc__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./inc */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/inc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inc", function() { return _inc__WEBPACK_IMPORTED_MODULE_83__["default"]; });

/* harmony import */ var _indexBy__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./indexBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/indexBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "indexBy", function() { return _indexBy__WEBPACK_IMPORTED_MODULE_84__["default"]; });

/* harmony import */ var _indexOf__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./indexOf */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/indexOf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "indexOf", function() { return _indexOf__WEBPACK_IMPORTED_MODULE_85__["default"]; });

/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./init */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/init.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "init", function() { return _init__WEBPACK_IMPORTED_MODULE_86__["default"]; });

/* harmony import */ var _innerJoin__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./innerJoin */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/innerJoin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "innerJoin", function() { return _innerJoin__WEBPACK_IMPORTED_MODULE_87__["default"]; });

/* harmony import */ var _insert__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./insert */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/insert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "insert", function() { return _insert__WEBPACK_IMPORTED_MODULE_88__["default"]; });

/* harmony import */ var _insertAll__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./insertAll */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/insertAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "insertAll", function() { return _insertAll__WEBPACK_IMPORTED_MODULE_89__["default"]; });

/* harmony import */ var _intersection__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./intersection */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/intersection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "intersection", function() { return _intersection__WEBPACK_IMPORTED_MODULE_90__["default"]; });

/* harmony import */ var _intersperse__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./intersperse */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/intersperse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "intersperse", function() { return _intersperse__WEBPACK_IMPORTED_MODULE_91__["default"]; });

/* harmony import */ var _into__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./into */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/into.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "into", function() { return _into__WEBPACK_IMPORTED_MODULE_92__["default"]; });

/* harmony import */ var _invert__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./invert */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return _invert__WEBPACK_IMPORTED_MODULE_93__["default"]; });

/* harmony import */ var _invertObj__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./invertObj */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invertObj.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invertObj", function() { return _invertObj__WEBPACK_IMPORTED_MODULE_94__["default"]; });

/* harmony import */ var _invoker__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./invoker */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invoker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invoker", function() { return _invoker__WEBPACK_IMPORTED_MODULE_95__["default"]; });

/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./is */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/is.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "is", function() { return _is__WEBPACK_IMPORTED_MODULE_96__["default"]; });

/* harmony import */ var _isEmpty__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./isEmpty */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/isEmpty.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return _isEmpty__WEBPACK_IMPORTED_MODULE_97__["default"]; });

/* harmony import */ var _isNil__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./isNil */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/isNil.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNil", function() { return _isNil__WEBPACK_IMPORTED_MODULE_98__["default"]; });

/* harmony import */ var _join__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./join */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/join.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "join", function() { return _join__WEBPACK_IMPORTED_MODULE_99__["default"]; });

/* harmony import */ var _juxt__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./juxt */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/juxt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "juxt", function() { return _juxt__WEBPACK_IMPORTED_MODULE_100__["default"]; });

/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return _keys__WEBPACK_IMPORTED_MODULE_101__["default"]; });

/* harmony import */ var _keysIn__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./keysIn */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keysIn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keysIn", function() { return _keysIn__WEBPACK_IMPORTED_MODULE_102__["default"]; });

/* harmony import */ var _last__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./last */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/last.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "last", function() { return _last__WEBPACK_IMPORTED_MODULE_103__["default"]; });

/* harmony import */ var _lastIndexOf__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./lastIndexOf */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lastIndexOf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lastIndexOf", function() { return _lastIndexOf__WEBPACK_IMPORTED_MODULE_104__["default"]; });

/* harmony import */ var _length__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./length */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/length.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "length", function() { return _length__WEBPACK_IMPORTED_MODULE_105__["default"]; });

/* harmony import */ var _lens__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./lens */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lens.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lens", function() { return _lens__WEBPACK_IMPORTED_MODULE_106__["default"]; });

/* harmony import */ var _lensIndex__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./lensIndex */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensIndex.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lensIndex", function() { return _lensIndex__WEBPACK_IMPORTED_MODULE_107__["default"]; });

/* harmony import */ var _lensPath__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./lensPath */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensPath.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lensPath", function() { return _lensPath__WEBPACK_IMPORTED_MODULE_108__["default"]; });

/* harmony import */ var _lensProp__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./lensProp */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensProp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lensProp", function() { return _lensProp__WEBPACK_IMPORTED_MODULE_109__["default"]; });

/* harmony import */ var _lift__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./lift */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lift.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lift", function() { return _lift__WEBPACK_IMPORTED_MODULE_110__["default"]; });

/* harmony import */ var _liftN__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./liftN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/liftN.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "liftN", function() { return _liftN__WEBPACK_IMPORTED_MODULE_111__["default"]; });

/* harmony import */ var _lt__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./lt */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lt", function() { return _lt__WEBPACK_IMPORTED_MODULE_112__["default"]; });

/* harmony import */ var _lte__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./lte */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lte.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lte", function() { return _lte__WEBPACK_IMPORTED_MODULE_113__["default"]; });

/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _map__WEBPACK_IMPORTED_MODULE_114__["default"]; });

/* harmony import */ var _mapAccum__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./mapAccum */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapAccum.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mapAccum", function() { return _mapAccum__WEBPACK_IMPORTED_MODULE_115__["default"]; });

/* harmony import */ var _mapAccumRight__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./mapAccumRight */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapAccumRight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mapAccumRight", function() { return _mapAccumRight__WEBPACK_IMPORTED_MODULE_116__["default"]; });

/* harmony import */ var _mapObjIndexed__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./mapObjIndexed */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapObjIndexed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mapObjIndexed", function() { return _mapObjIndexed__WEBPACK_IMPORTED_MODULE_117__["default"]; });

/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_118__ = __webpack_require__(/*! ./match */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/match.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "match", function() { return _match__WEBPACK_IMPORTED_MODULE_118__["default"]; });

/* harmony import */ var _mathMod__WEBPACK_IMPORTED_MODULE_119__ = __webpack_require__(/*! ./mathMod */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mathMod.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mathMod", function() { return _mathMod__WEBPACK_IMPORTED_MODULE_119__["default"]; });

/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_120__ = __webpack_require__(/*! ./max */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _max__WEBPACK_IMPORTED_MODULE_120__["default"]; });

/* harmony import */ var _maxBy__WEBPACK_IMPORTED_MODULE_121__ = __webpack_require__(/*! ./maxBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/maxBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maxBy", function() { return _maxBy__WEBPACK_IMPORTED_MODULE_121__["default"]; });

/* harmony import */ var _mean__WEBPACK_IMPORTED_MODULE_122__ = __webpack_require__(/*! ./mean */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mean.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return _mean__WEBPACK_IMPORTED_MODULE_122__["default"]; });

/* harmony import */ var _median__WEBPACK_IMPORTED_MODULE_123__ = __webpack_require__(/*! ./median */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/median.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "median", function() { return _median__WEBPACK_IMPORTED_MODULE_123__["default"]; });

/* harmony import */ var _memoize__WEBPACK_IMPORTED_MODULE_124__ = __webpack_require__(/*! ./memoize */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/memoize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "memoize", function() { return _memoize__WEBPACK_IMPORTED_MODULE_124__["default"]; });

/* harmony import */ var _memoizeWith__WEBPACK_IMPORTED_MODULE_125__ = __webpack_require__(/*! ./memoizeWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/memoizeWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "memoizeWith", function() { return _memoizeWith__WEBPACK_IMPORTED_MODULE_125__["default"]; });

/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_126__ = __webpack_require__(/*! ./merge */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/merge.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _merge__WEBPACK_IMPORTED_MODULE_126__["default"]; });

/* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_127__ = __webpack_require__(/*! ./mergeAll */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeAll", function() { return _mergeAll__WEBPACK_IMPORTED_MODULE_127__["default"]; });

/* harmony import */ var _mergeDeepLeft__WEBPACK_IMPORTED_MODULE_128__ = __webpack_require__(/*! ./mergeDeepLeft */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepLeft.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeDeepLeft", function() { return _mergeDeepLeft__WEBPACK_IMPORTED_MODULE_128__["default"]; });

/* harmony import */ var _mergeDeepRight__WEBPACK_IMPORTED_MODULE_129__ = __webpack_require__(/*! ./mergeDeepRight */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepRight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeDeepRight", function() { return _mergeDeepRight__WEBPACK_IMPORTED_MODULE_129__["default"]; });

/* harmony import */ var _mergeDeepWith__WEBPACK_IMPORTED_MODULE_130__ = __webpack_require__(/*! ./mergeDeepWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeDeepWith", function() { return _mergeDeepWith__WEBPACK_IMPORTED_MODULE_130__["default"]; });

/* harmony import */ var _mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_131__ = __webpack_require__(/*! ./mergeDeepWithKey */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWithKey.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeDeepWithKey", function() { return _mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_131__["default"]; });

/* harmony import */ var _mergeWith__WEBPACK_IMPORTED_MODULE_132__ = __webpack_require__(/*! ./mergeWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeWith", function() { return _mergeWith__WEBPACK_IMPORTED_MODULE_132__["default"]; });

/* harmony import */ var _mergeWithKey__WEBPACK_IMPORTED_MODULE_133__ = __webpack_require__(/*! ./mergeWithKey */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWithKey.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeWithKey", function() { return _mergeWithKey__WEBPACK_IMPORTED_MODULE_133__["default"]; });

/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_134__ = __webpack_require__(/*! ./min */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/min.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _min__WEBPACK_IMPORTED_MODULE_134__["default"]; });

/* harmony import */ var _minBy__WEBPACK_IMPORTED_MODULE_135__ = __webpack_require__(/*! ./minBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/minBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "minBy", function() { return _minBy__WEBPACK_IMPORTED_MODULE_135__["default"]; });

/* harmony import */ var _modulo__WEBPACK_IMPORTED_MODULE_136__ = __webpack_require__(/*! ./modulo */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/modulo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "modulo", function() { return _modulo__WEBPACK_IMPORTED_MODULE_136__["default"]; });

/* harmony import */ var _multiply__WEBPACK_IMPORTED_MODULE_137__ = __webpack_require__(/*! ./multiply */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/multiply.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return _multiply__WEBPACK_IMPORTED_MODULE_137__["default"]; });

/* harmony import */ var _nAry__WEBPACK_IMPORTED_MODULE_138__ = __webpack_require__(/*! ./nAry */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nAry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nAry", function() { return _nAry__WEBPACK_IMPORTED_MODULE_138__["default"]; });

/* harmony import */ var _negate__WEBPACK_IMPORTED_MODULE_139__ = __webpack_require__(/*! ./negate */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/negate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return _negate__WEBPACK_IMPORTED_MODULE_139__["default"]; });

/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_140__ = __webpack_require__(/*! ./none */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/none.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "none", function() { return _none__WEBPACK_IMPORTED_MODULE_140__["default"]; });

/* harmony import */ var _not__WEBPACK_IMPORTED_MODULE_141__ = __webpack_require__(/*! ./not */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/not.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "not", function() { return _not__WEBPACK_IMPORTED_MODULE_141__["default"]; });

/* harmony import */ var _nth__WEBPACK_IMPORTED_MODULE_142__ = __webpack_require__(/*! ./nth */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nth.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nth", function() { return _nth__WEBPACK_IMPORTED_MODULE_142__["default"]; });

/* harmony import */ var _nthArg__WEBPACK_IMPORTED_MODULE_143__ = __webpack_require__(/*! ./nthArg */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nthArg.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nthArg", function() { return _nthArg__WEBPACK_IMPORTED_MODULE_143__["default"]; });

/* harmony import */ var _o__WEBPACK_IMPORTED_MODULE_144__ = __webpack_require__(/*! ./o */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/o.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "o", function() { return _o__WEBPACK_IMPORTED_MODULE_144__["default"]; });

/* harmony import */ var _objOf__WEBPACK_IMPORTED_MODULE_145__ = __webpack_require__(/*! ./objOf */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/objOf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "objOf", function() { return _objOf__WEBPACK_IMPORTED_MODULE_145__["default"]; });

/* harmony import */ var _of__WEBPACK_IMPORTED_MODULE_146__ = __webpack_require__(/*! ./of */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/of.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "of", function() { return _of__WEBPACK_IMPORTED_MODULE_146__["default"]; });

/* harmony import */ var _omit__WEBPACK_IMPORTED_MODULE_147__ = __webpack_require__(/*! ./omit */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/omit.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "omit", function() { return _omit__WEBPACK_IMPORTED_MODULE_147__["default"]; });

/* harmony import */ var _once__WEBPACK_IMPORTED_MODULE_148__ = __webpack_require__(/*! ./once */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/once.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "once", function() { return _once__WEBPACK_IMPORTED_MODULE_148__["default"]; });

/* harmony import */ var _or__WEBPACK_IMPORTED_MODULE_149__ = __webpack_require__(/*! ./or */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/or.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "or", function() { return _or__WEBPACK_IMPORTED_MODULE_149__["default"]; });

/* harmony import */ var _over__WEBPACK_IMPORTED_MODULE_150__ = __webpack_require__(/*! ./over */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/over.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "over", function() { return _over__WEBPACK_IMPORTED_MODULE_150__["default"]; });

/* harmony import */ var _pair__WEBPACK_IMPORTED_MODULE_151__ = __webpack_require__(/*! ./pair */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pair.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pair", function() { return _pair__WEBPACK_IMPORTED_MODULE_151__["default"]; });

/* harmony import */ var _partial__WEBPACK_IMPORTED_MODULE_152__ = __webpack_require__(/*! ./partial */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partial", function() { return _partial__WEBPACK_IMPORTED_MODULE_152__["default"]; });

/* harmony import */ var _partialRight__WEBPACK_IMPORTED_MODULE_153__ = __webpack_require__(/*! ./partialRight */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partialRight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partialRight", function() { return _partialRight__WEBPACK_IMPORTED_MODULE_153__["default"]; });

/* harmony import */ var _partition__WEBPACK_IMPORTED_MODULE_154__ = __webpack_require__(/*! ./partition */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partition.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return _partition__WEBPACK_IMPORTED_MODULE_154__["default"]; });

/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_155__ = __webpack_require__(/*! ./path */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "path", function() { return _path__WEBPACK_IMPORTED_MODULE_155__["default"]; });

/* harmony import */ var _pathEq__WEBPACK_IMPORTED_MODULE_156__ = __webpack_require__(/*! ./pathEq */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathEq.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pathEq", function() { return _pathEq__WEBPACK_IMPORTED_MODULE_156__["default"]; });

/* harmony import */ var _pathOr__WEBPACK_IMPORTED_MODULE_157__ = __webpack_require__(/*! ./pathOr */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathOr.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pathOr", function() { return _pathOr__WEBPACK_IMPORTED_MODULE_157__["default"]; });

/* harmony import */ var _pathSatisfies__WEBPACK_IMPORTED_MODULE_158__ = __webpack_require__(/*! ./pathSatisfies */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathSatisfies.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pathSatisfies", function() { return _pathSatisfies__WEBPACK_IMPORTED_MODULE_158__["default"]; });

/* harmony import */ var _pick__WEBPACK_IMPORTED_MODULE_159__ = __webpack_require__(/*! ./pick */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pick.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pick", function() { return _pick__WEBPACK_IMPORTED_MODULE_159__["default"]; });

/* harmony import */ var _pickAll__WEBPACK_IMPORTED_MODULE_160__ = __webpack_require__(/*! ./pickAll */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pickAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pickAll", function() { return _pickAll__WEBPACK_IMPORTED_MODULE_160__["default"]; });

/* harmony import */ var _pickBy__WEBPACK_IMPORTED_MODULE_161__ = __webpack_require__(/*! ./pickBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pickBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pickBy", function() { return _pickBy__WEBPACK_IMPORTED_MODULE_161__["default"]; });

/* harmony import */ var _pipe__WEBPACK_IMPORTED_MODULE_162__ = __webpack_require__(/*! ./pipe */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipe.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pipe", function() { return _pipe__WEBPACK_IMPORTED_MODULE_162__["default"]; });

/* harmony import */ var _pipeK__WEBPACK_IMPORTED_MODULE_163__ = __webpack_require__(/*! ./pipeK */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipeK.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pipeK", function() { return _pipeK__WEBPACK_IMPORTED_MODULE_163__["default"]; });

/* harmony import */ var _pipeP__WEBPACK_IMPORTED_MODULE_164__ = __webpack_require__(/*! ./pipeP */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipeP.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pipeP", function() { return _pipeP__WEBPACK_IMPORTED_MODULE_164__["default"]; });

/* harmony import */ var _pluck__WEBPACK_IMPORTED_MODULE_165__ = __webpack_require__(/*! ./pluck */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pluck.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pluck", function() { return _pluck__WEBPACK_IMPORTED_MODULE_165__["default"]; });

/* harmony import */ var _prepend__WEBPACK_IMPORTED_MODULE_166__ = __webpack_require__(/*! ./prepend */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prepend.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "prepend", function() { return _prepend__WEBPACK_IMPORTED_MODULE_166__["default"]; });

/* harmony import */ var _product__WEBPACK_IMPORTED_MODULE_167__ = __webpack_require__(/*! ./product */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/product.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "product", function() { return _product__WEBPACK_IMPORTED_MODULE_167__["default"]; });

/* harmony import */ var _project__WEBPACK_IMPORTED_MODULE_168__ = __webpack_require__(/*! ./project */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/project.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "project", function() { return _project__WEBPACK_IMPORTED_MODULE_168__["default"]; });

/* harmony import */ var _prop__WEBPACK_IMPORTED_MODULE_169__ = __webpack_require__(/*! ./prop */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prop.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "prop", function() { return _prop__WEBPACK_IMPORTED_MODULE_169__["default"]; });

/* harmony import */ var _propEq__WEBPACK_IMPORTED_MODULE_170__ = __webpack_require__(/*! ./propEq */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propEq.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "propEq", function() { return _propEq__WEBPACK_IMPORTED_MODULE_170__["default"]; });

/* harmony import */ var _propIs__WEBPACK_IMPORTED_MODULE_171__ = __webpack_require__(/*! ./propIs */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propIs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "propIs", function() { return _propIs__WEBPACK_IMPORTED_MODULE_171__["default"]; });

/* harmony import */ var _propOr__WEBPACK_IMPORTED_MODULE_172__ = __webpack_require__(/*! ./propOr */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propOr.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "propOr", function() { return _propOr__WEBPACK_IMPORTED_MODULE_172__["default"]; });

/* harmony import */ var _propSatisfies__WEBPACK_IMPORTED_MODULE_173__ = __webpack_require__(/*! ./propSatisfies */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propSatisfies.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "propSatisfies", function() { return _propSatisfies__WEBPACK_IMPORTED_MODULE_173__["default"]; });

/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_174__ = __webpack_require__(/*! ./props */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/props.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "props", function() { return _props__WEBPACK_IMPORTED_MODULE_174__["default"]; });

/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_175__ = __webpack_require__(/*! ./range */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/range.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _range__WEBPACK_IMPORTED_MODULE_175__["default"]; });

/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_176__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduce", function() { return _reduce__WEBPACK_IMPORTED_MODULE_176__["default"]; });

/* harmony import */ var _reduceBy__WEBPACK_IMPORTED_MODULE_177__ = __webpack_require__(/*! ./reduceBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduceBy", function() { return _reduceBy__WEBPACK_IMPORTED_MODULE_177__["default"]; });

/* harmony import */ var _reduceRight__WEBPACK_IMPORTED_MODULE_178__ = __webpack_require__(/*! ./reduceRight */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceRight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduceRight", function() { return _reduceRight__WEBPACK_IMPORTED_MODULE_178__["default"]; });

/* harmony import */ var _reduceWhile__WEBPACK_IMPORTED_MODULE_179__ = __webpack_require__(/*! ./reduceWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceWhile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduceWhile", function() { return _reduceWhile__WEBPACK_IMPORTED_MODULE_179__["default"]; });

/* harmony import */ var _reduced__WEBPACK_IMPORTED_MODULE_180__ = __webpack_require__(/*! ./reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduced.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduced", function() { return _reduced__WEBPACK_IMPORTED_MODULE_180__["default"]; });

/* harmony import */ var _reject__WEBPACK_IMPORTED_MODULE_181__ = __webpack_require__(/*! ./reject */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reject.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reject", function() { return _reject__WEBPACK_IMPORTED_MODULE_181__["default"]; });

/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_182__ = __webpack_require__(/*! ./remove */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/remove.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return _remove__WEBPACK_IMPORTED_MODULE_182__["default"]; });

/* harmony import */ var _repeat__WEBPACK_IMPORTED_MODULE_183__ = __webpack_require__(/*! ./repeat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/repeat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "repeat", function() { return _repeat__WEBPACK_IMPORTED_MODULE_183__["default"]; });

/* harmony import */ var _replace__WEBPACK_IMPORTED_MODULE_184__ = __webpack_require__(/*! ./replace */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/replace.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "replace", function() { return _replace__WEBPACK_IMPORTED_MODULE_184__["default"]; });

/* harmony import */ var _reverse__WEBPACK_IMPORTED_MODULE_185__ = __webpack_require__(/*! ./reverse */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reverse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return _reverse__WEBPACK_IMPORTED_MODULE_185__["default"]; });

/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_186__ = __webpack_require__(/*! ./scan */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/scan.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scan", function() { return _scan__WEBPACK_IMPORTED_MODULE_186__["default"]; });

/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_187__ = __webpack_require__(/*! ./sequence */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sequence.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sequence", function() { return _sequence__WEBPACK_IMPORTED_MODULE_187__["default"]; });

/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_188__ = __webpack_require__(/*! ./set */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/set.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "set", function() { return _set__WEBPACK_IMPORTED_MODULE_188__["default"]; });

/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_189__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return _slice__WEBPACK_IMPORTED_MODULE_189__["default"]; });

/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_190__ = __webpack_require__(/*! ./sort */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sort.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sort", function() { return _sort__WEBPACK_IMPORTED_MODULE_190__["default"]; });

/* harmony import */ var _sortBy__WEBPACK_IMPORTED_MODULE_191__ = __webpack_require__(/*! ./sortBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sortBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sortBy", function() { return _sortBy__WEBPACK_IMPORTED_MODULE_191__["default"]; });

/* harmony import */ var _sortWith__WEBPACK_IMPORTED_MODULE_192__ = __webpack_require__(/*! ./sortWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sortWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sortWith", function() { return _sortWith__WEBPACK_IMPORTED_MODULE_192__["default"]; });

/* harmony import */ var _split__WEBPACK_IMPORTED_MODULE_193__ = __webpack_require__(/*! ./split */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/split.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "split", function() { return _split__WEBPACK_IMPORTED_MODULE_193__["default"]; });

/* harmony import */ var _splitAt__WEBPACK_IMPORTED_MODULE_194__ = __webpack_require__(/*! ./splitAt */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitAt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "splitAt", function() { return _splitAt__WEBPACK_IMPORTED_MODULE_194__["default"]; });

/* harmony import */ var _splitEvery__WEBPACK_IMPORTED_MODULE_195__ = __webpack_require__(/*! ./splitEvery */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitEvery.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "splitEvery", function() { return _splitEvery__WEBPACK_IMPORTED_MODULE_195__["default"]; });

/* harmony import */ var _splitWhen__WEBPACK_IMPORTED_MODULE_196__ = __webpack_require__(/*! ./splitWhen */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitWhen.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "splitWhen", function() { return _splitWhen__WEBPACK_IMPORTED_MODULE_196__["default"]; });

/* harmony import */ var _startsWith__WEBPACK_IMPORTED_MODULE_197__ = __webpack_require__(/*! ./startsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/startsWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "startsWith", function() { return _startsWith__WEBPACK_IMPORTED_MODULE_197__["default"]; });

/* harmony import */ var _subtract__WEBPACK_IMPORTED_MODULE_198__ = __webpack_require__(/*! ./subtract */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/subtract.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return _subtract__WEBPACK_IMPORTED_MODULE_198__["default"]; });

/* harmony import */ var _sum__WEBPACK_IMPORTED_MODULE_199__ = __webpack_require__(/*! ./sum */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sum.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return _sum__WEBPACK_IMPORTED_MODULE_199__["default"]; });

/* harmony import */ var _symmetricDifference__WEBPACK_IMPORTED_MODULE_200__ = __webpack_require__(/*! ./symmetricDifference */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/symmetricDifference.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symmetricDifference", function() { return _symmetricDifference__WEBPACK_IMPORTED_MODULE_200__["default"]; });

/* harmony import */ var _symmetricDifferenceWith__WEBPACK_IMPORTED_MODULE_201__ = __webpack_require__(/*! ./symmetricDifferenceWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/symmetricDifferenceWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symmetricDifferenceWith", function() { return _symmetricDifferenceWith__WEBPACK_IMPORTED_MODULE_201__["default"]; });

/* harmony import */ var _tail__WEBPACK_IMPORTED_MODULE_202__ = __webpack_require__(/*! ./tail */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tail.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tail", function() { return _tail__WEBPACK_IMPORTED_MODULE_202__["default"]; });

/* harmony import */ var _take__WEBPACK_IMPORTED_MODULE_203__ = __webpack_require__(/*! ./take */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/take.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "take", function() { return _take__WEBPACK_IMPORTED_MODULE_203__["default"]; });

/* harmony import */ var _takeLast__WEBPACK_IMPORTED_MODULE_204__ = __webpack_require__(/*! ./takeLast */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeLast.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "takeLast", function() { return _takeLast__WEBPACK_IMPORTED_MODULE_204__["default"]; });

/* harmony import */ var _takeLastWhile__WEBPACK_IMPORTED_MODULE_205__ = __webpack_require__(/*! ./takeLastWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeLastWhile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "takeLastWhile", function() { return _takeLastWhile__WEBPACK_IMPORTED_MODULE_205__["default"]; });

/* harmony import */ var _takeWhile__WEBPACK_IMPORTED_MODULE_206__ = __webpack_require__(/*! ./takeWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeWhile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "takeWhile", function() { return _takeWhile__WEBPACK_IMPORTED_MODULE_206__["default"]; });

/* harmony import */ var _tap__WEBPACK_IMPORTED_MODULE_207__ = __webpack_require__(/*! ./tap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tap", function() { return _tap__WEBPACK_IMPORTED_MODULE_207__["default"]; });

/* harmony import */ var _test__WEBPACK_IMPORTED_MODULE_208__ = __webpack_require__(/*! ./test */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/test.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "test", function() { return _test__WEBPACK_IMPORTED_MODULE_208__["default"]; });

/* harmony import */ var _times__WEBPACK_IMPORTED_MODULE_209__ = __webpack_require__(/*! ./times */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/times.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "times", function() { return _times__WEBPACK_IMPORTED_MODULE_209__["default"]; });

/* harmony import */ var _toLower__WEBPACK_IMPORTED_MODULE_210__ = __webpack_require__(/*! ./toLower */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toLower.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toLower", function() { return _toLower__WEBPACK_IMPORTED_MODULE_210__["default"]; });

/* harmony import */ var _toPairs__WEBPACK_IMPORTED_MODULE_211__ = __webpack_require__(/*! ./toPairs */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toPairs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toPairs", function() { return _toPairs__WEBPACK_IMPORTED_MODULE_211__["default"]; });

/* harmony import */ var _toPairsIn__WEBPACK_IMPORTED_MODULE_212__ = __webpack_require__(/*! ./toPairsIn */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toPairsIn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toPairsIn", function() { return _toPairsIn__WEBPACK_IMPORTED_MODULE_212__["default"]; });

/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_213__ = __webpack_require__(/*! ./toString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toString.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toString", function() { return _toString__WEBPACK_IMPORTED_MODULE_213__["default"]; });

/* harmony import */ var _toUpper__WEBPACK_IMPORTED_MODULE_214__ = __webpack_require__(/*! ./toUpper */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toUpper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toUpper", function() { return _toUpper__WEBPACK_IMPORTED_MODULE_214__["default"]; });

/* harmony import */ var _transduce__WEBPACK_IMPORTED_MODULE_215__ = __webpack_require__(/*! ./transduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/transduce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transduce", function() { return _transduce__WEBPACK_IMPORTED_MODULE_215__["default"]; });

/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_216__ = __webpack_require__(/*! ./transpose */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/transpose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return _transpose__WEBPACK_IMPORTED_MODULE_216__["default"]; });

/* harmony import */ var _traverse__WEBPACK_IMPORTED_MODULE_217__ = __webpack_require__(/*! ./traverse */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/traverse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "traverse", function() { return _traverse__WEBPACK_IMPORTED_MODULE_217__["default"]; });

/* harmony import */ var _trim__WEBPACK_IMPORTED_MODULE_218__ = __webpack_require__(/*! ./trim */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/trim.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "trim", function() { return _trim__WEBPACK_IMPORTED_MODULE_218__["default"]; });

/* harmony import */ var _tryCatch__WEBPACK_IMPORTED_MODULE_219__ = __webpack_require__(/*! ./tryCatch */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tryCatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tryCatch", function() { return _tryCatch__WEBPACK_IMPORTED_MODULE_219__["default"]; });

/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_220__ = __webpack_require__(/*! ./type */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "type", function() { return _type__WEBPACK_IMPORTED_MODULE_220__["default"]; });

/* harmony import */ var _unapply__WEBPACK_IMPORTED_MODULE_221__ = __webpack_require__(/*! ./unapply */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unapply.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unapply", function() { return _unapply__WEBPACK_IMPORTED_MODULE_221__["default"]; });

/* harmony import */ var _unary__WEBPACK_IMPORTED_MODULE_222__ = __webpack_require__(/*! ./unary */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unary.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unary", function() { return _unary__WEBPACK_IMPORTED_MODULE_222__["default"]; });

/* harmony import */ var _uncurryN__WEBPACK_IMPORTED_MODULE_223__ = __webpack_require__(/*! ./uncurryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uncurryN.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uncurryN", function() { return _uncurryN__WEBPACK_IMPORTED_MODULE_223__["default"]; });

/* harmony import */ var _unfold__WEBPACK_IMPORTED_MODULE_224__ = __webpack_require__(/*! ./unfold */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unfold.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unfold", function() { return _unfold__WEBPACK_IMPORTED_MODULE_224__["default"]; });

/* harmony import */ var _union__WEBPACK_IMPORTED_MODULE_225__ = __webpack_require__(/*! ./union */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/union.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "union", function() { return _union__WEBPACK_IMPORTED_MODULE_225__["default"]; });

/* harmony import */ var _unionWith__WEBPACK_IMPORTED_MODULE_226__ = __webpack_require__(/*! ./unionWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unionWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unionWith", function() { return _unionWith__WEBPACK_IMPORTED_MODULE_226__["default"]; });

/* harmony import */ var _uniq__WEBPACK_IMPORTED_MODULE_227__ = __webpack_require__(/*! ./uniq */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniq.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uniq", function() { return _uniq__WEBPACK_IMPORTED_MODULE_227__["default"]; });

/* harmony import */ var _uniqBy__WEBPACK_IMPORTED_MODULE_228__ = __webpack_require__(/*! ./uniqBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uniqBy", function() { return _uniqBy__WEBPACK_IMPORTED_MODULE_228__["default"]; });

/* harmony import */ var _uniqWith__WEBPACK_IMPORTED_MODULE_229__ = __webpack_require__(/*! ./uniqWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uniqWith", function() { return _uniqWith__WEBPACK_IMPORTED_MODULE_229__["default"]; });

/* harmony import */ var _unless__WEBPACK_IMPORTED_MODULE_230__ = __webpack_require__(/*! ./unless */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unless.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unless", function() { return _unless__WEBPACK_IMPORTED_MODULE_230__["default"]; });

/* harmony import */ var _unnest__WEBPACK_IMPORTED_MODULE_231__ = __webpack_require__(/*! ./unnest */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unnest.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unnest", function() { return _unnest__WEBPACK_IMPORTED_MODULE_231__["default"]; });

/* harmony import */ var _until__WEBPACK_IMPORTED_MODULE_232__ = __webpack_require__(/*! ./until */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/until.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "until", function() { return _until__WEBPACK_IMPORTED_MODULE_232__["default"]; });

/* harmony import */ var _update__WEBPACK_IMPORTED_MODULE_233__ = __webpack_require__(/*! ./update */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/update.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "update", function() { return _update__WEBPACK_IMPORTED_MODULE_233__["default"]; });

/* harmony import */ var _useWith__WEBPACK_IMPORTED_MODULE_234__ = __webpack_require__(/*! ./useWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/useWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useWith", function() { return _useWith__WEBPACK_IMPORTED_MODULE_234__["default"]; });

/* harmony import */ var _values__WEBPACK_IMPORTED_MODULE_235__ = __webpack_require__(/*! ./values */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/values.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "values", function() { return _values__WEBPACK_IMPORTED_MODULE_235__["default"]; });

/* harmony import */ var _valuesIn__WEBPACK_IMPORTED_MODULE_236__ = __webpack_require__(/*! ./valuesIn */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/valuesIn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valuesIn", function() { return _valuesIn__WEBPACK_IMPORTED_MODULE_236__["default"]; });

/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_237__ = __webpack_require__(/*! ./view */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/view.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "view", function() { return _view__WEBPACK_IMPORTED_MODULE_237__["default"]; });

/* harmony import */ var _when__WEBPACK_IMPORTED_MODULE_238__ = __webpack_require__(/*! ./when */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/when.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "when", function() { return _when__WEBPACK_IMPORTED_MODULE_238__["default"]; });

/* harmony import */ var _where__WEBPACK_IMPORTED_MODULE_239__ = __webpack_require__(/*! ./where */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/where.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "where", function() { return _where__WEBPACK_IMPORTED_MODULE_239__["default"]; });

/* harmony import */ var _whereEq__WEBPACK_IMPORTED_MODULE_240__ = __webpack_require__(/*! ./whereEq */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/whereEq.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "whereEq", function() { return _whereEq__WEBPACK_IMPORTED_MODULE_240__["default"]; });

/* harmony import */ var _without__WEBPACK_IMPORTED_MODULE_241__ = __webpack_require__(/*! ./without */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/without.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "without", function() { return _without__WEBPACK_IMPORTED_MODULE_241__["default"]; });

/* harmony import */ var _xprod__WEBPACK_IMPORTED_MODULE_242__ = __webpack_require__(/*! ./xprod */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/xprod.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "xprod", function() { return _xprod__WEBPACK_IMPORTED_MODULE_242__["default"]; });

/* harmony import */ var _zip__WEBPACK_IMPORTED_MODULE_243__ = __webpack_require__(/*! ./zip */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return _zip__WEBPACK_IMPORTED_MODULE_243__["default"]; });

/* harmony import */ var _zipObj__WEBPACK_IMPORTED_MODULE_244__ = __webpack_require__(/*! ./zipObj */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zipObj.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zipObj", function() { return _zipObj__WEBPACK_IMPORTED_MODULE_244__["default"]; });

/* harmony import */ var _zipWith__WEBPACK_IMPORTED_MODULE_245__ = __webpack_require__(/*! ./zipWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zipWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zipWith", function() { return _zipWith__WEBPACK_IMPORTED_MODULE_245__["default"]; });
























































































































































































































































/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/indexBy.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/indexBy.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reduceBy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reduceBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceBy.js");


/**
 * Given a function that generates a key, turns a list of objects into an
 * object indexing the objects by the given key. Note that if multiple
 * objects generate the same value for the indexing key only the last value
 * will be included in the generated object.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
 * @param {Function} fn Function :: a -> String
 * @param {Array} array The array of objects to index
 * @return {Object} An object indexing each array element by the given property.
 * @example
 *
 *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
 *      R.indexBy(R.prop('id'), list);
 *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
 */
var indexBy = /*#__PURE__*/Object(_reduceBy__WEBPACK_IMPORTED_MODULE_0__["default"])(function (acc, elem) {
  return elem;
}, null);
/* harmony default export */ __webpack_exports__["default"] = (indexBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/indexOf.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/indexOf.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_indexOf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_indexOf */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_indexOf.js");
/* harmony import */ var _internal_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");




/**
 * Returns the position of the first occurrence of an item in an array, or -1
 * if the item is not included in the array. [`R.equals`](#equals) is used to
 * determine equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> Number
 * @param {*} target The item to find.
 * @param {Array} xs The array to search in.
 * @return {Number} the index of the target, or -1 if the target is not found.
 * @see R.lastIndexOf
 * @example
 *
 *      R.indexOf(3, [1,2,3,4]); //=> 2
 *      R.indexOf(10, [1,2,3,4]); //=> -1
 */
var indexOf = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function indexOf(target, xs) {
  return typeof xs.indexOf === 'function' && !Object(_internal_isArray__WEBPACK_IMPORTED_MODULE_2__["default"])(xs) ? xs.indexOf(target) : Object(_internal_indexOf__WEBPACK_IMPORTED_MODULE_1__["default"])(xs, target, 0);
});
/* harmony default export */ __webpack_exports__["default"] = (indexOf);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/init.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/init.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");


/**
 * Returns all but the last element of the given list or string.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.last, R.head, R.tail
 * @example
 *
 *      R.init([1, 2, 3]);  //=> [1, 2]
 *      R.init([1, 2]);     //=> [1]
 *      R.init([1]);        //=> []
 *      R.init([]);         //=> []
 *
 *      R.init('abc');  //=> 'ab'
 *      R.init('ab');   //=> 'a'
 *      R.init('a');    //=> ''
 *      R.init('');     //=> ''
 */
var init = /*#__PURE__*/Object(_slice__WEBPACK_IMPORTED_MODULE_0__["default"])(0, -1);
/* harmony default export */ __webpack_exports__["default"] = (init);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/innerJoin.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/innerJoin.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_containsWith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_containsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_containsWith.js");
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _internal_filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_filter */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_filter.js");




/**
 * Takes a predicate `pred`, a list `xs`, and a list `ys`, and returns a list
 * `xs'` comprising each of the elements of `xs` which is equal to one or more
 * elements of `ys` according to `pred`.
 *
 * `pred` must be a binary function expecting an element from each list.
 *
 * `xs`, `ys`, and `xs'` are treated as sets, semantically, so ordering should
 * not be significant, but since `xs'` is ordered the implementation guarantees
 * that its values are in the same order as they appear in `xs`. Duplicates are
 * not removed, so `xs'` may contain duplicates if `xs` contains duplicates.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Relation
 * @sig ((a, b) -> Boolean) -> [a] -> [b] -> [a]
 * @param {Function} pred
 * @param {Array} xs
 * @param {Array} ys
 * @return {Array}
 * @see R.intersection
 * @example
 *
 *      R.innerJoin(
 *        (record, id) => record.id === id,
 *        [{id: 824, name: 'Richie Furay'},
 *         {id: 956, name: 'Dewey Martin'},
 *         {id: 313, name: 'Bruce Palmer'},
 *         {id: 456, name: 'Stephen Stills'},
 *         {id: 177, name: 'Neil Young'}],
 *        [177, 456, 999]
 *      );
 *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
 */
var innerJoin = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_1__["default"])(function innerJoin(pred, xs, ys) {
  return Object(_internal_filter__WEBPACK_IMPORTED_MODULE_2__["default"])(function (x) {
    return Object(_internal_containsWith__WEBPACK_IMPORTED_MODULE_0__["default"])(pred, x, ys);
  }, xs);
});
/* harmony default export */ __webpack_exports__["default"] = (innerJoin);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/insert.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/insert.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Inserts the supplied element into the list, at the specified `index`. _Note that

 * this is not destructive_: it returns a copy of the list with the changes.
 * <small>No lists have been harmed in the application of this function.</small>
 *
 * @func
 * @memberOf R
 * @since v0.2.2
 * @category List
 * @sig Number -> a -> [a] -> [a]
 * @param {Number} index The position to insert the element
 * @param {*} elt The element to insert into the Array
 * @param {Array} list The list to insert into
 * @return {Array} A new Array with `elt` inserted at `index`.
 * @example
 *
 *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
 */
var insert = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function insert(idx, elt, list) {
  idx = idx < list.length && idx >= 0 ? idx : list.length;
  var result = Array.prototype.slice.call(list, 0);
  result.splice(idx, 0, elt);
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (insert);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/insertAll.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/insertAll.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Inserts the sub-list into the list, at the specified `index`. _Note that this is not
 * destructive_: it returns a copy of the list with the changes.
 * <small>No lists have been harmed in the application of this function.</small>
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category List
 * @sig Number -> [a] -> [a] -> [a]
 * @param {Number} index The position to insert the sub-list
 * @param {Array} elts The sub-list to insert into the Array
 * @param {Array} list The list to insert the sub-list into
 * @return {Array} A new Array with `elts` inserted starting at `index`.
 * @example
 *
 *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
 */
var insertAll = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function insertAll(idx, elts, list) {
  idx = idx < list.length && idx >= 0 ? idx : list.length;
  return [].concat(Array.prototype.slice.call(list, 0, idx), elts, Array.prototype.slice.call(list, idx));
});
/* harmony default export */ __webpack_exports__["default"] = (insertAll);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_Set.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_Set.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _contains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_contains */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js");


var _Set = /*#__PURE__*/function () {
  function _Set() {
    /* globals Set */
    this._nativeSet = typeof Set === 'function' ? new Set() : null;
    this._items = {};
  }

  // until we figure out why jsdoc chokes on this
  // @param item The item to add to the Set
  // @returns {boolean} true if the item did not exist prior, otherwise false
  //
  _Set.prototype.add = function (item) {
    return !hasOrAdd(item, true, this);
  };

  //
  // @param item The item to check for existence in the Set
  // @returns {boolean} true if the item exists in the Set, otherwise false
  //
  _Set.prototype.has = function (item) {
    return hasOrAdd(item, false, this);
  };

  //
  // Combines the logic for checking whether an item is a member of the set and
  // for adding a new item to the set.
  //
  // @param item       The item to check or add to the Set instance.
  // @param shouldAdd  If true, the item will be added to the set if it doesn't
  //                   already exist.
  // @param set        The set instance to check or add to.
  // @return {boolean} true if the item already existed, otherwise false.
  //
  return _Set;
}();

function hasOrAdd(item, shouldAdd, set) {
  var type = typeof item;
  var prevSize, newSize;
  switch (type) {
    case 'string':
    case 'number':
      // distinguish between +0 and -0
      if (item === 0 && 1 / item === -Infinity) {
        if (set._items['-0']) {
          return true;
        } else {
          if (shouldAdd) {
            set._items['-0'] = true;
          }
          return false;
        }
      }
      // these types can all utilise the native Set
      if (set._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set._nativeSet.size;
          set._nativeSet.add(item);
          newSize = set._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set._nativeSet.has(item);
        }
      } else {
        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = {};
            set._items[type][item] = true;
          }
          return false;
        } else if (item in set._items[type]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type][item] = true;
          }
          return false;
        }
      }

    case 'boolean':
      // set._items['boolean'] holds a two element array
      // representing [ falseExists, trueExists ]
      if (type in set._items) {
        var bIdx = item ? 1 : 0;
        if (set._items[type][bIdx]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type][bIdx] = true;
          }
          return false;
        }
      } else {
        if (shouldAdd) {
          set._items[type] = item ? [false, true] : [true, false];
        }
        return false;
      }

    case 'function':
      // compare functions for reference equality
      if (set._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set._nativeSet.size;
          set._nativeSet.add(item);
          newSize = set._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set._nativeSet.has(item);
        }
      } else {
        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = [item];
          }
          return false;
        }
        if (!Object(_contains__WEBPACK_IMPORTED_MODULE_0__["default"])(item, set._items[type])) {
          if (shouldAdd) {
            set._items[type].push(item);
          }
          return false;
        }
        return true;
      }

    case 'undefined':
      if (set._items[type]) {
        return true;
      } else {
        if (shouldAdd) {
          set._items[type] = true;
        }
        return false;
      }

    case 'object':
      if (item === null) {
        if (!set._items['null']) {
          if (shouldAdd) {
            set._items['null'] = true;
          }
          return false;
        }
        return true;
      }
    /* falls through */
    default:
      // reduce the search size of heterogeneous sets by creating buckets
      // for each type.
      type = Object.prototype.toString.call(item);
      if (!(type in set._items)) {
        if (shouldAdd) {
          set._items[type] = [item];
        }
        return false;
      }
      // scan through all previously applied items
      if (!Object(_contains__WEBPACK_IMPORTED_MODULE_0__["default"])(item, set._items[type])) {
        if (shouldAdd) {
          set._items[type].push(item);
        }
        return false;
      }
      return true;
  }
}

// A simple Set type that honours R.equals semantics
/* harmony default export */ __webpack_exports__["default"] = (_Set);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_aperture.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_aperture.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _aperture; });
function _aperture(n, list) {
  var idx = 0;
  var limit = list.length - (n - 1);
  var acc = new Array(limit >= 0 ? limit : 0);
  while (idx < limit) {
    acc[idx] = Array.prototype.slice.call(list, idx, idx + n);
    idx += 1;
  }
  return acc;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arity; });
function _arity(n, fn) {
  /* eslint-disable no-unused-vars */
  switch (n) {
    case 0:
      return function () {
        return fn.apply(this, arguments);
      };
    case 1:
      return function (a0) {
        return fn.apply(this, arguments);
      };
    case 2:
      return function (a0, a1) {
        return fn.apply(this, arguments);
      };
    case 3:
      return function (a0, a1, a2) {
        return fn.apply(this, arguments);
      };
    case 4:
      return function (a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };
    case 5:
      return function (a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };
    case 6:
      return function (a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };
    case 7:
      return function (a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };
    case 8:
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };
    case 9:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };
    case 10:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };
    default:
      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arrayFromIterator.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arrayFromIterator.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayFromIterator; });
function _arrayFromIterator(iter) {
  var list = [];
  var next;
  while (!(next = iter.next()).done) {
    list.push(next.value);
  }
  return list;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_assign.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_assign.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _objectAssign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_objectAssign */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_objectAssign.js");


/* harmony default export */ __webpack_exports__["default"] = (typeof Object.assign === 'function' ? Object.assign : _objectAssign__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_checkForMethod.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_checkForMethod.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _checkForMethod; });
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");


/**
 * This checks whether a function has a [methodname] function. If it isn't an
 * array it will execute that function otherwise it will default to the ramda
 * implementation.
 *
 * @private
 * @param {Function} fn ramda implemtation
 * @param {String} methodname property to check for a custom implementation
 * @return {Object} Whatever the return value of the method is.
 */
function _checkForMethod(methodname, fn) {
  return function () {
    var length = arguments.length;
    if (length === 0) {
      return fn();
    }
    var obj = arguments[length - 1];
    return Object(_isArray__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_clone.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_clone.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _clone; });
/* harmony import */ var _cloneRegExp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cloneRegExp */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_cloneRegExp.js");
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../type */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/type.js");



/**
 * Copies an object.
 *
 * @private
 * @param {*} value The value to be copied
 * @param {Array} refFrom Array containing the source references
 * @param {Array} refTo Array containing the copied source references
 * @param {Boolean} deep Whether or not to perform deep cloning.
 * @return {*} The copied value.
 */
function _clone(value, refFrom, refTo, deep) {
  var copy = function copy(copiedValue) {
    var len = refFrom.length;
    var idx = 0;
    while (idx < len) {
      if (value === refFrom[idx]) {
        return refTo[idx];
      }
      idx += 1;
    }
    refFrom[idx + 1] = value;
    refTo[idx + 1] = copiedValue;
    for (var key in value) {
      copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
    }
    return copiedValue;
  };
  switch (Object(_type__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
    case 'Object':
      return copy({});
    case 'Array':
      return copy([]);
    case 'Date':
      return new Date(value.valueOf());
    case 'RegExp':
      return Object(_cloneRegExp__WEBPACK_IMPORTED_MODULE_0__["default"])(value);
    default:
      return value;
  }
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_cloneRegExp.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_cloneRegExp.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _cloneRegExp; });
function _cloneRegExp(pattern) {
                                  return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_complement.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_complement.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _complement; });
function _complement(f) {
  return function () {
    return !f.apply(this, arguments);
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _concat; });
/**
 * Private `concat` function to merge two array-like objects.
 *
 * @private
 * @param {Array|Arguments} [set1=[]] An array-like object.
 * @param {Array|Arguments} [set2=[]] An array-like object.
 * @return {Array} A new, merged array.
 * @example
 *
 *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
 */
function _concat(set1, set2) {
  set1 = set1 || [];
  set2 = set2 || [];
  var idx;
  var len1 = set1.length;
  var len2 = set2.length;
  var result = [];

  idx = 0;
  while (idx < len1) {
    result[result.length] = set1[idx];
    idx += 1;
  }
  idx = 0;
  while (idx < len2) {
    result[result.length] = set2[idx];
    idx += 1;
  }
  return result;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _contains; });
/* harmony import */ var _indexOf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_indexOf */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_indexOf.js");


function _contains(a, list) {
  return Object(_indexOf__WEBPACK_IMPORTED_MODULE_0__["default"])(list, a, 0) >= 0;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_containsWith.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_containsWith.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _containsWith; });
function _containsWith(pred, x, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    if (pred(x, list[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_createPartialApplicator.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_createPartialApplicator.js ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _createPartialApplicator; });
/* harmony import */ var _arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



function _createPartialApplicator(concat) {
  return Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (fn, args) {
    return Object(_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.max(0, fn.length - args.length), function () {
      return fn.apply(this, concat(args, arguments));
    });
  });
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _curry1; });
/* harmony import */ var _isPlaceholder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isPlaceholder */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isPlaceholder.js");


/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_0__["default"])(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _curry2; });
/* harmony import */ var _curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _isPlaceholder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isPlaceholder */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isPlaceholder.js");



/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_1__["default"])(a) ? f2 : Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function (_b) {
          return fn(a, _b);
        });
      default:
        return Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_1__["default"])(a) && Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_1__["default"])(b) ? f2 : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_1__["default"])(a) ? Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function (_a) {
          return fn(_a, b);
        }) : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_1__["default"])(b) ? Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function (_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _curry3; });
/* harmony import */ var _curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _isPlaceholder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_isPlaceholder */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isPlaceholder.js");




/**
 * Optimized internal three-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
function _curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;
      case 1:
        return Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(a) ? f3 : Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (_b, _c) {
          return fn(a, _b, _c);
        });
      case 2:
        return Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(a) && Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(b) ? f3 : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(a) ? Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (_a, _c) {
          return fn(_a, b, _c);
        }) : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(b) ? Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (_b, _c) {
          return fn(a, _b, _c);
        }) : Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function (_c) {
          return fn(a, b, _c);
        });
      default:
        return Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(a) && Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(b) && Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(c) ? f3 : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(a) && Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(b) ? Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (_a, _b) {
          return fn(_a, _b, c);
        }) : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(a) && Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(c) ? Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (_a, _c) {
          return fn(_a, b, _c);
        }) : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(b) && Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(c) ? Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (_b, _c) {
          return fn(a, _b, _c);
        }) : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(a) ? Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function (_a) {
          return fn(_a, b, c);
        }) : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(b) ? Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function (_b) {
          return fn(a, _b, c);
        }) : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(c) ? Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function (_c) {
          return fn(a, b, _c);
        }) : fn(a, b, c);
    }
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curryN.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curryN.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _curryN; });
/* harmony import */ var _arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _isPlaceholder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isPlaceholder */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isPlaceholder.js");



/**
 * Internal curryN function.
 *
 * @private
 * @category Function
 * @param {Number} length The arity of the curried function.
 * @param {Array} received An array of arguments received thus far.
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
function _curryN(length, received, fn) {
  return function () {
    var combined = [];
    var argsIdx = 0;
    var left = length;
    var combinedIdx = 0;
    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;
      if (combinedIdx < received.length && (!Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_1__["default"])(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }
      combined[combinedIdx] = result;
      if (!Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_1__["default"])(result)) {
        left -= 1;
      }
      combinedIdx += 1;
    }
    return left <= 0 ? fn.apply(this, combined) : Object(_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(left, _curryN(length, combined, fn));
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _dispatchable; });
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");
/* harmony import */ var _isTransformer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isTransformer */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isTransformer.js");



/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a function with one of the given method names, it will
 * execute that function (functor case). Otherwise, if it is a transformer,
 * uses transducer [xf] to return a new transformer (transducer case).
 * Otherwise, it will default to executing [fn].
 *
 * @private
 * @param {Array} methodNames properties to check for a custom implementation
 * @param {Function} xf transducer to initialize if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */
function _dispatchable(methodNames, xf, fn) {
  return function () {
    if (arguments.length === 0) {
      return fn();
    }
    var args = Array.prototype.slice.call(arguments, 0);
    var obj = args.pop();
    if (!Object(_isArray__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) {
      var idx = 0;
      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === 'function') {
          return obj[methodNames[idx]].apply(obj, args);
        }
        idx += 1;
      }
      if (Object(_isTransformer__WEBPACK_IMPORTED_MODULE_1__["default"])(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }
    return fn.apply(this, arguments);
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dropLast.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dropLast.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return dropLast; });
/* harmony import */ var _take__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../take */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/take.js");


function dropLast(n, xs) {
  return Object(_take__WEBPACK_IMPORTED_MODULE_0__["default"])(n < xs.length ? xs.length - n : 0, xs);
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dropLastWhile.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dropLastWhile.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return dropLastWhile; });
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");


function dropLastWhile(pred, xs) {
  var idx = xs.length - 1;
  while (idx >= 0 && pred(xs[idx])) {
    idx -= 1;
  }
  return Object(_slice__WEBPACK_IMPORTED_MODULE_0__["default"])(0, idx + 1, xs);
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_equals.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_equals.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _equals; });
/* harmony import */ var _arrayFromIterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayFromIterator */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arrayFromIterator.js");
/* harmony import */ var _containsWith__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_containsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_containsWith.js");
/* harmony import */ var _functionName__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_functionName */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_functionName.js");
/* harmony import */ var _has__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");
/* harmony import */ var _identical__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../identical */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identical.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../type */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/type.js");








/**
 * private _uniqContentEquals function.
 * That function is checking equality of 2 iterator contents with 2 assumptions
 * - iterators lengths are the same
 * - iterators values are unique
 *
 * false-positive result will be returned for comparision of, e.g.
 * - [1,2,3] and [1,2,3,4]
 * - [1,1,1] and [1,2,3]
 * */

function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
  var a = Object(_arrayFromIterator__WEBPACK_IMPORTED_MODULE_0__["default"])(aIterator);
  var b = Object(_arrayFromIterator__WEBPACK_IMPORTED_MODULE_0__["default"])(bIterator);

  function eq(_a, _b) {
    return _equals(_a, _b, stackA.slice(), stackB.slice());
  }

  // if *a* array contains any element that is not included in *b*
  return !Object(_containsWith__WEBPACK_IMPORTED_MODULE_1__["default"])(function (b, aItem) {
    return !Object(_containsWith__WEBPACK_IMPORTED_MODULE_1__["default"])(eq, aItem, b);
  }, b, a);
}

function _equals(a, b, stackA, stackB) {
  if (Object(_identical__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b)) {
    return true;
  }

  var typeA = Object(_type__WEBPACK_IMPORTED_MODULE_6__["default"])(a);

  if (typeA !== Object(_type__WEBPACK_IMPORTED_MODULE_6__["default"])(b)) {
    return false;
  }

  if (a == null || b == null) {
    return false;
  }

  if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
    return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
  }

  if (typeof a.equals === 'function' || typeof b.equals === 'function') {
    return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
  }

  switch (typeA) {
    case 'Arguments':
    case 'Array':
    case 'Object':
      if (typeof a.constructor === 'function' && Object(_functionName__WEBPACK_IMPORTED_MODULE_2__["default"])(a.constructor) === 'Promise') {
        return a === b;
      }
      break;
    case 'Boolean':
    case 'Number':
    case 'String':
      if (!(typeof a === typeof b && Object(_identical__WEBPACK_IMPORTED_MODULE_4__["default"])(a.valueOf(), b.valueOf()))) {
        return false;
      }
      break;
    case 'Date':
      if (!Object(_identical__WEBPACK_IMPORTED_MODULE_4__["default"])(a.valueOf(), b.valueOf())) {
        return false;
      }
      break;
    case 'Error':
      return a.name === b.name && a.message === b.message;
    case 'RegExp':
      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
        return false;
      }
      break;
  }

  var idx = stackA.length - 1;
  while (idx >= 0) {
    if (stackA[idx] === a) {
      return stackB[idx] === b;
    }
    idx -= 1;
  }

  switch (typeA) {
    case 'Map':
      if (a.size !== b.size) {
        return false;
      }

      return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
    case 'Set':
      if (a.size !== b.size) {
        return false;
      }

      return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
    case 'Arguments':
    case 'Array':
    case 'Object':
    case 'Boolean':
    case 'Number':
    case 'String':
    case 'Date':
    case 'Error':
    case 'RegExp':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'ArrayBuffer':
      break;
    default:
      // Values of other types are only equal if identical.
      return false;
  }

  var keysA = Object(_keys__WEBPACK_IMPORTED_MODULE_5__["default"])(a);
  if (keysA.length !== Object(_keys__WEBPACK_IMPORTED_MODULE_5__["default"])(b).length) {
    return false;
  }

  var extendedStackA = stackA.concat([a]);
  var extendedStackB = stackB.concat([b]);

  idx = keysA.length - 1;
  while (idx >= 0) {
    var key = keysA[idx];
    if (!(Object(_has__WEBPACK_IMPORTED_MODULE_3__["default"])(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
      return false;
    }
    idx -= 1;
  }
  return true;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_filter.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_filter.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _filter; });
function _filter(fn, list) {
  var idx = 0;
  var len = list.length;
  var result = [];

  while (idx < len) {
    if (fn(list[idx])) {
      result[result.length] = list[idx];
    }
    idx += 1;
  }
  return result;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_flatCat.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_flatCat.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _forceReduced__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_forceReduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_forceReduced.js");
/* harmony import */ var _isArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArrayLike.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");





var preservingReduced = function (xf) {
  return {
    '@@transducer/init': _xfBase__WEBPACK_IMPORTED_MODULE_3__["default"].init,
    '@@transducer/result': function (result) {
      return xf['@@transducer/result'](result);
    },
    '@@transducer/step': function (result, input) {
      var ret = xf['@@transducer/step'](result, input);
      return ret['@@transducer/reduced'] ? Object(_forceReduced__WEBPACK_IMPORTED_MODULE_0__["default"])(ret) : ret;
    }
  };
};

var _flatCat = function _xcat(xf) {
  var rxf = preservingReduced(xf);
  return {
    '@@transducer/init': _xfBase__WEBPACK_IMPORTED_MODULE_3__["default"].init,
    '@@transducer/result': function (result) {
      return rxf['@@transducer/result'](result);
    },
    '@@transducer/step': function (result, input) {
      return !Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(input) ? Object(_reduce__WEBPACK_IMPORTED_MODULE_2__["default"])(rxf, result, [input]) : Object(_reduce__WEBPACK_IMPORTED_MODULE_2__["default"])(rxf, result, input);
    }
  };
};

/* harmony default export */ __webpack_exports__["default"] = (_flatCat);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_forceReduced.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_forceReduced.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _forceReduced; });
function _forceReduced(x) {
  return {
    '@@transducer/value': x,
    '@@transducer/reduced': true
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_functionName.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_functionName.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _functionName; });
function _functionName(f) {
  // String(x => x) evaluates to "x => x", so the pattern may not match.
  var match = String(f).match(/^function (\w*)/);
  return match == null ? '' : match[1];
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _has; });
function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_identity.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_identity.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _identity; });
function _identity(x) {
  return x;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_indexOf.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_indexOf.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _indexOf; });
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");


function _indexOf(list, a, idx) {
  var inf, item;
  // Array.prototype.indexOf doesn't exist below IE9
  if (typeof list.indexOf === 'function') {
    switch (typeof a) {
      case 'number':
        if (a === 0) {
          // manually crawl the list to distinguish between +0 and -0
          inf = 1 / a;
          while (idx < list.length) {
            item = list[idx];
            if (item === 0 && 1 / item === inf) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        } else if (a !== a) {
          // NaN
          while (idx < list.length) {
            item = list[idx];
            if (typeof item === 'number' && item !== item) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        }
        // non-zero numbers can utilise Set
        return list.indexOf(a, idx);

      // all these types can utilise Set
      case 'string':
      case 'boolean':
      case 'function':
      case 'undefined':
        return list.indexOf(a, idx);

      case 'object':
        if (a === null) {
          // null can utilise Set
          return list.indexOf(a, idx);
        }
    }
  }
  // anything else not covered above, defer to R.equals
  while (idx < list.length) {
    if (Object(_equals__WEBPACK_IMPORTED_MODULE_0__["default"])(list[idx], a)) {
      return idx;
    }
    idx += 1;
  }
  return -1;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArguments.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArguments.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _has__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");


var toString = Object.prototype.toString;
var _isArguments = function () {
  return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
    return toString.call(x) === '[object Arguments]';
  } : function _isArguments(x) {
    return Object(_has__WEBPACK_IMPORTED_MODULE_0__["default"])('callee', x);
  };
};

/* harmony default export */ __webpack_exports__["default"] = (_isArguments);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
/* harmony default export */ __webpack_exports__["default"] = (Array.isArray || function _isArray(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
});

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArrayLike.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArrayLike.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");
/* harmony import */ var _isString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_isString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isString.js");




/**
 * Tests whether or not an object is similar to an array.
 *
 * @private
 * @category Type
 * @category List
 * @sig * -> Boolean
 * @param {*} x The object to test.
 * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
 * @example
 *
 *      _isArrayLike([]); //=> true
 *      _isArrayLike(true); //=> false
 *      _isArrayLike({}); //=> false
 *      _isArrayLike({length: 10}); //=> false
 *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
 */
var _isArrayLike = /*#__PURE__*/Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function isArrayLike(x) {
  if (Object(_isArray__WEBPACK_IMPORTED_MODULE_1__["default"])(x)) {
    return true;
  }
  if (!x) {
    return false;
  }
  if (typeof x !== 'object') {
    return false;
  }
  if (Object(_isString__WEBPACK_IMPORTED_MODULE_2__["default"])(x)) {
    return false;
  }
  if (x.nodeType === 1) {
    return !!x.length;
  }
  if (x.length === 0) {
    return true;
  }
  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }
  return false;
});
/* harmony default export */ __webpack_exports__["default"] = (_isArrayLike);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isFunction.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isFunction.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isFunction; });
function _isFunction(x) {
  return Object.prototype.toString.call(x) === '[object Function]';
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isInteger.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isInteger.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Determine if the passed argument is an integer.
 *
 * @private
 * @param {*} n
 * @category Type
 * @return {Boolean}
 */
/* harmony default export */ __webpack_exports__["default"] = (Number.isInteger || function _isInteger(n) {
  return n << 0 === n;
});

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isNumber.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isNumber.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isNumber; });
function _isNumber(x) {
  return Object.prototype.toString.call(x) === '[object Number]';
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isObject.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isObject.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isObject; });
function _isObject(x) {
  return Object.prototype.toString.call(x) === '[object Object]';
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isPlaceholder.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isPlaceholder.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isPlaceholder; });
function _isPlaceholder(a) {
       return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isRegExp.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isRegExp.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isRegExp; });
function _isRegExp(x) {
  return Object.prototype.toString.call(x) === '[object RegExp]';
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isString.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isString.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isString; });
function _isString(x) {
  return Object.prototype.toString.call(x) === '[object String]';
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isTransformer.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isTransformer.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isTransformer; });
function _isTransformer(obj) {
  return typeof obj['@@transducer/step'] === 'function';
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_makeFlat.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_makeFlat.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _makeFlat; });
/* harmony import */ var _isArrayLike__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArrayLike.js");


/**
 * `_makeFlat` is a helper function that returns a one-level or fully recursive
 * function based on the flag passed in.
 *
 * @private
 */
function _makeFlat(recursive) {
  return function flatt(list) {
    var value, jlen, j;
    var result = [];
    var idx = 0;
    var ilen = list.length;

    while (idx < ilen) {
      if (Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_0__["default"])(list[idx])) {
        value = recursive ? flatt(list[idx]) : list[idx];
        j = 0;
        jlen = value.length;
        while (j < jlen) {
          result[result.length] = value[j];
          j += 1;
        }
      } else {
        result[result.length] = list[idx];
      }
      idx += 1;
    }
    return result;
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_map.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_map.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _map; });
function _map(fn, functor) {
  var idx = 0;
  var len = functor.length;
  var result = Array(len);
  while (idx < len) {
    result[idx] = fn(functor[idx]);
    idx += 1;
  }
  return result;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_objectAssign.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_objectAssign.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectAssign; });
/* harmony import */ var _has__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");


// Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
function _objectAssign(target) {
  if (target == null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);
  var idx = 1;
  var length = arguments.length;
  while (idx < length) {
    var source = arguments[idx];
    if (source != null) {
      for (var nextKey in source) {
        if (Object(_has__WEBPACK_IMPORTED_MODULE_0__["default"])(nextKey, source)) {
          output[nextKey] = source[nextKey];
        }
      }
    }
    idx += 1;
  }
  return output;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_of.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_of.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _of; });
function _of(x) {
  return [x];
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_pipe.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_pipe.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _pipe; });
function _pipe(f, g) {
  return function () {
    return g.call(this, f.apply(this, arguments));
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_pipeP.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_pipeP.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _pipeP; });
function _pipeP(f, g) {
  return function () {
    var ctx = this;
    return f.apply(ctx, arguments).then(function (x) {
      return g.call(ctx, x);
    });
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_quote.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_quote.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _quote; });
function _quote(s) {
  var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b') // \b matches word boundary; [\b] matches backspace
  .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');

  return '"' + escaped.replace(/"/g, '\\"') + '"';
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _reduce; });
/* harmony import */ var _isArrayLike__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArrayLike.js");
/* harmony import */ var _xwrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xwrap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xwrap.js");
/* harmony import */ var _bind__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../bind */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/bind.js");




function _arrayReduce(xf, acc, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    acc = xf['@@transducer/step'](acc, list[idx]);
    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }
    idx += 1;
  }
  return xf['@@transducer/result'](acc);
}

function _iterableReduce(xf, acc, iter) {
  var step = iter.next();
  while (!step.done) {
    acc = xf['@@transducer/step'](acc, step.value);
    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }
    step = iter.next();
  }
  return xf['@@transducer/result'](acc);
}

function _methodReduce(xf, acc, obj, methodName) {
  return xf['@@transducer/result'](obj[methodName](Object(_bind__WEBPACK_IMPORTED_MODULE_2__["default"])(xf['@@transducer/step'], xf), acc));
}

var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';

function _reduce(fn, acc, list) {
  if (typeof fn === 'function') {
    fn = Object(_xwrap__WEBPACK_IMPORTED_MODULE_1__["default"])(fn);
  }
  if (Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_0__["default"])(list)) {
    return _arrayReduce(fn, acc, list);
  }
  if (typeof list['fantasy-land/reduce'] === 'function') {
    return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
  }
  if (list[symIterator] != null) {
    return _iterableReduce(fn, acc, list[symIterator]());
  }
  if (typeof list.next === 'function') {
    return _iterableReduce(fn, acc, list);
  }
  if (typeof list.reduce === 'function') {
    return _methodReduce(fn, acc, list, 'reduce');
  }

  throw new TypeError('reduce: list must be array or iterable');
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _reduced; });
function _reduced(x) {
  return x && x['@@transducer/reduced'] ? x : {
    '@@transducer/value': x,
    '@@transducer/reduced': true
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_stepCat.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_stepCat.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _stepCat; });
/* harmony import */ var _assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assign */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_assign.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_identity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_identity.js");
/* harmony import */ var _isArrayLike__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_isArrayLike */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArrayLike.js");
/* harmony import */ var _isTransformer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isTransformer */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isTransformer.js");
/* harmony import */ var _objOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../objOf */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/objOf.js");






var _stepCatArray = {
  '@@transducer/init': Array,
  '@@transducer/step': function (xs, x) {
    xs.push(x);
    return xs;
  },
  '@@transducer/result': _identity__WEBPACK_IMPORTED_MODULE_1__["default"]
};
var _stepCatString = {
  '@@transducer/init': String,
  '@@transducer/step': function (a, b) {
    return a + b;
  },
  '@@transducer/result': _identity__WEBPACK_IMPORTED_MODULE_1__["default"]
};
var _stepCatObject = {
  '@@transducer/init': Object,
  '@@transducer/step': function (result, input) {
    return Object(_assign__WEBPACK_IMPORTED_MODULE_0__["default"])(result, Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_2__["default"])(input) ? Object(_objOf__WEBPACK_IMPORTED_MODULE_4__["default"])(input[0], input[1]) : input);
  },
  '@@transducer/result': _identity__WEBPACK_IMPORTED_MODULE_1__["default"]
};

function _stepCat(obj) {
  if (Object(_isTransformer__WEBPACK_IMPORTED_MODULE_3__["default"])(obj)) {
    return obj;
  }
  if (Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_2__["default"])(obj)) {
    return _stepCatArray;
  }
  if (typeof obj === 'string') {
    return _stepCatString;
  }
  if (typeof obj === 'object') {
    return _stepCatObject;
  }
  throw new Error('Cannot create transformer for ' + obj);
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_toISOString.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_toISOString.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
 */
var pad = function pad(n) {
  return (n < 10 ? '0' : '') + n;
};

var _toISOString = typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
  return d.toISOString();
} : function _toISOString(d) {
  return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
};

/* harmony default export */ __webpack_exports__["default"] = (_toISOString);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_toString.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_toString.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _toString; });
/* harmony import */ var _contains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_contains */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_map.js");
/* harmony import */ var _quote__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_quote */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_quote.js");
/* harmony import */ var _toISOString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_toISOString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_toISOString.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");
/* harmony import */ var _reject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../reject */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reject.js");







function _toString(x, seen) {
  var recur = function recur(y) {
    var xs = seen.concat([x]);
    return Object(_contains__WEBPACK_IMPORTED_MODULE_0__["default"])(y, xs) ? '<Circular>' : _toString(y, xs);
  };

  //  mapPairs :: (Object, [String]) -> [String]
  var mapPairs = function (obj, keys) {
    return Object(_map__WEBPACK_IMPORTED_MODULE_1__["default"])(function (k) {
      return Object(_quote__WEBPACK_IMPORTED_MODULE_2__["default"])(k) + ': ' + recur(obj[k]);
    }, keys.slice().sort());
  };

  switch (Object.prototype.toString.call(x)) {
    case '[object Arguments]':
      return '(function() { return arguments; }(' + Object(_map__WEBPACK_IMPORTED_MODULE_1__["default"])(recur, x).join(', ') + '))';
    case '[object Array]':
      return '[' + Object(_map__WEBPACK_IMPORTED_MODULE_1__["default"])(recur, x).concat(mapPairs(x, Object(_reject__WEBPACK_IMPORTED_MODULE_5__["default"])(function (k) {
        return (/^\d+$/.test(k)
        );
      }, Object(_keys__WEBPACK_IMPORTED_MODULE_4__["default"])(x)))).join(', ') + ']';
    case '[object Boolean]':
      return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
    case '[object Date]':
      return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : Object(_quote__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_toISOString__WEBPACK_IMPORTED_MODULE_3__["default"])(x))) + ')';
    case '[object Null]':
      return 'null';
    case '[object Number]':
      return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
    case '[object String]':
      return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : Object(_quote__WEBPACK_IMPORTED_MODULE_2__["default"])(x);
    case '[object Undefined]':
      return 'undefined';
    default:
      if (typeof x.toString === 'function') {
        var repr = x.toString();
        if (repr !== '[object Object]') {
          return repr;
        }
      }
      return '{' + mapPairs(x, Object(_keys__WEBPACK_IMPORTED_MODULE_4__["default"])(x)).join(', ') + '}';
  }
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xall.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xall.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XAll = /*#__PURE__*/function () {
  function XAll(f, xf) {
    this.xf = xf;
    this.f = f;
    this.all = true;
  }
  XAll.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XAll.prototype['@@transducer/result'] = function (result) {
    if (this.all) {
      result = this.xf['@@transducer/step'](result, true);
    }
    return this.xf['@@transducer/result'](result);
  };
  XAll.prototype['@@transducer/step'] = function (result, input) {
    if (!this.f(input)) {
      this.all = false;
      result = Object(_reduced__WEBPACK_IMPORTED_MODULE_1__["default"])(this.xf['@@transducer/step'](result, false));
    }
    return result;
  };

  return XAll;
}();

var _xall = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xall(f, xf) {
  return new XAll(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xall);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xany.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xany.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XAny = /*#__PURE__*/function () {
  function XAny(f, xf) {
    this.xf = xf;
    this.f = f;
    this.any = false;
  }
  XAny.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XAny.prototype['@@transducer/result'] = function (result) {
    if (!this.any) {
      result = this.xf['@@transducer/step'](result, false);
    }
    return this.xf['@@transducer/result'](result);
  };
  XAny.prototype['@@transducer/step'] = function (result, input) {
    if (this.f(input)) {
      this.any = true;
      result = Object(_reduced__WEBPACK_IMPORTED_MODULE_1__["default"])(this.xf['@@transducer/step'](result, true));
    }
    return result;
  };

  return XAny;
}();

var _xany = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xany(f, xf) {
  return new XAny(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xany);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xaperture.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xaperture.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XAperture = /*#__PURE__*/function () {
  function XAperture(n, xf) {
    this.xf = xf;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n);
  }
  XAperture.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XAperture.prototype['@@transducer/result'] = function (result) {
    this.acc = null;
    return this.xf['@@transducer/result'](result);
  };
  XAperture.prototype['@@transducer/step'] = function (result, input) {
    this.store(input);
    return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
  };
  XAperture.prototype.store = function (input) {
    this.acc[this.pos] = input;
    this.pos += 1;
    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };
  XAperture.prototype.getCopy = function () {
    return Object(_concat__WEBPACK_IMPORTED_MODULE_0__["default"])(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
  };

  return XAperture;
}();

var _xaperture = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function _xaperture(n, xf) {
  return new XAperture(n, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xaperture);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xchain.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xchain.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _flatCat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_flatCat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_flatCat.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");




var _xchain = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xchain(f, xf) {
  return Object(_map__WEBPACK_IMPORTED_MODULE_2__["default"])(f, Object(_flatCat__WEBPACK_IMPORTED_MODULE_1__["default"])(xf));
});
/* harmony default export */ __webpack_exports__["default"] = (_xchain);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdrop.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdrop.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XDrop = /*#__PURE__*/function () {
  function XDrop(n, xf) {
    this.xf = xf;
    this.n = n;
  }
  XDrop.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XDrop.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].result;
  XDrop.prototype['@@transducer/step'] = function (result, input) {
    if (this.n > 0) {
      this.n -= 1;
      return result;
    }
    return this.xf['@@transducer/step'](result, input);
  };

  return XDrop;
}();

var _xdrop = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xdrop(n, xf) {
  return new XDrop(n, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xdrop);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropLast.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropLast.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XDropLast = /*#__PURE__*/function () {
  function XDropLast(n, xf) {
    this.xf = xf;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n);
  }
  XDropLast.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XDropLast.prototype['@@transducer/result'] = function (result) {
    this.acc = null;
    return this.xf['@@transducer/result'](result);
  };
  XDropLast.prototype['@@transducer/step'] = function (result, input) {
    if (this.full) {
      result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
    }
    this.store(input);
    return result;
  };
  XDropLast.prototype.store = function (input) {
    this.acc[this.pos] = input;
    this.pos += 1;
    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };

  return XDropLast;
}();

var _xdropLast = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xdropLast(n, xf) {
  return new XDropLast(n, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xdropLast);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropLastWhile.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropLastWhile.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XDropLastWhile = /*#__PURE__*/function () {
  function XDropLastWhile(fn, xf) {
    this.f = fn;
    this.retained = [];
    this.xf = xf;
  }
  XDropLastWhile.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XDropLastWhile.prototype['@@transducer/result'] = function (result) {
    this.retained = null;
    return this.xf['@@transducer/result'](result);
  };
  XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.retain(result, input) : this.flush(result, input);
  };
  XDropLastWhile.prototype.flush = function (result, input) {
    result = Object(_reduce__WEBPACK_IMPORTED_MODULE_1__["default"])(this.xf['@@transducer/step'], result, this.retained);
    this.retained = [];
    return this.xf['@@transducer/step'](result, input);
  };
  XDropLastWhile.prototype.retain = function (result, input) {
    this.retained.push(input);
    return result;
  };

  return XDropLastWhile;
}();

var _xdropLastWhile = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xdropLastWhile(fn, xf) {
  return new XDropLastWhile(fn, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xdropLastWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropRepeatsWith.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropRepeatsWith.js ***!
  \***********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XDropRepeatsWith = /*#__PURE__*/function () {
  function XDropRepeatsWith(pred, xf) {
    this.xf = xf;
    this.pred = pred;
    this.lastValue = undefined;
    this.seenFirstValue = false;
  }

  XDropRepeatsWith.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XDropRepeatsWith.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].result;
  XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
    var sameAsLast = false;
    if (!this.seenFirstValue) {
      this.seenFirstValue = true;
    } else if (this.pred(this.lastValue, input)) {
      sameAsLast = true;
    }
    this.lastValue = input;
    return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
  };

  return XDropRepeatsWith;
}();

var _xdropRepeatsWith = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xdropRepeatsWith(pred, xf) {
  return new XDropRepeatsWith(pred, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xdropRepeatsWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropWhile.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropWhile.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XDropWhile = /*#__PURE__*/function () {
  function XDropWhile(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XDropWhile.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XDropWhile.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].result;
  XDropWhile.prototype['@@transducer/step'] = function (result, input) {
    if (this.f) {
      if (this.f(input)) {
        return result;
      }
      this.f = null;
    }
    return this.xf['@@transducer/step'](result, input);
  };

  return XDropWhile;
}();

var _xdropWhile = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xdropWhile(f, xf) {
  return new XDropWhile(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xdropWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  init: function () {
    return this.xf['@@transducer/init']();
  },
  result: function (result) {
    return this.xf['@@transducer/result'](result);
  }
});

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfilter.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfilter.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XFilter = /*#__PURE__*/function () {
  function XFilter(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XFilter.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XFilter.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].result;
  XFilter.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
  };

  return XFilter;
}();

var _xfilter = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xfilter(f, xf) {
  return new XFilter(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xfilter);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfind.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfind.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XFind = /*#__PURE__*/function () {
  function XFind(f, xf) {
    this.xf = xf;
    this.f = f;
    this.found = false;
  }
  XFind.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XFind.prototype['@@transducer/result'] = function (result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, void 0);
    }
    return this.xf['@@transducer/result'](result);
  };
  XFind.prototype['@@transducer/step'] = function (result, input) {
    if (this.f(input)) {
      this.found = true;
      result = Object(_reduced__WEBPACK_IMPORTED_MODULE_1__["default"])(this.xf['@@transducer/step'](result, input));
    }
    return result;
  };

  return XFind;
}();

var _xfind = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xfind(f, xf) {
  return new XFind(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xfind);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindIndex.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindIndex.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XFindIndex = /*#__PURE__*/function () {
  function XFindIndex(f, xf) {
    this.xf = xf;
    this.f = f;
    this.idx = -1;
    this.found = false;
  }
  XFindIndex.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XFindIndex.prototype['@@transducer/result'] = function (result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, -1);
    }
    return this.xf['@@transducer/result'](result);
  };
  XFindIndex.prototype['@@transducer/step'] = function (result, input) {
    this.idx += 1;
    if (this.f(input)) {
      this.found = true;
      result = Object(_reduced__WEBPACK_IMPORTED_MODULE_1__["default"])(this.xf['@@transducer/step'](result, this.idx));
    }
    return result;
  };

  return XFindIndex;
}();

var _xfindIndex = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xfindIndex(f, xf) {
  return new XFindIndex(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xfindIndex);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindLast.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindLast.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XFindLast = /*#__PURE__*/function () {
  function XFindLast(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XFindLast.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XFindLast.prototype['@@transducer/result'] = function (result) {
    return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
  };
  XFindLast.prototype['@@transducer/step'] = function (result, input) {
    if (this.f(input)) {
      this.last = input;
    }
    return result;
  };

  return XFindLast;
}();

var _xfindLast = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xfindLast(f, xf) {
  return new XFindLast(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xfindLast);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindLastIndex.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindLastIndex.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XFindLastIndex = /*#__PURE__*/function () {
  function XFindLastIndex(f, xf) {
    this.xf = xf;
    this.f = f;
    this.idx = -1;
    this.lastIdx = -1;
  }
  XFindLastIndex.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XFindLastIndex.prototype['@@transducer/result'] = function (result) {
    return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
  };
  XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
    this.idx += 1;
    if (this.f(input)) {
      this.lastIdx = this.idx;
    }
    return result;
  };

  return XFindLastIndex;
}();

var _xfindLastIndex = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xfindLastIndex(f, xf) {
  return new XFindLastIndex(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xfindLastIndex);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xmap.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xmap.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XMap = /*#__PURE__*/function () {
  function XMap(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XMap.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XMap.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].result;
  XMap.prototype['@@transducer/step'] = function (result, input) {
    return this.xf['@@transducer/step'](result, this.f(input));
  };

  return XMap;
}();

var _xmap = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xmap(f, xf) {
  return new XMap(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xmap);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xreduceBy.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xreduceBy.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curryN.js");
/* harmony import */ var _has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XReduceBy = /*#__PURE__*/function () {
  function XReduceBy(valueFn, valueAcc, keyFn, xf) {
    this.valueFn = valueFn;
    this.valueAcc = valueAcc;
    this.keyFn = keyFn;
    this.xf = xf;
    this.inputs = {};
  }
  XReduceBy.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XReduceBy.prototype['@@transducer/result'] = function (result) {
    var key;
    for (key in this.inputs) {
      if (Object(_has__WEBPACK_IMPORTED_MODULE_1__["default"])(key, this.inputs)) {
        result = this.xf['@@transducer/step'](result, this.inputs[key]);
        if (result['@@transducer/reduced']) {
          result = result['@@transducer/value'];
          break;
        }
      }
    }
    this.inputs = null;
    return this.xf['@@transducer/result'](result);
  };
  XReduceBy.prototype['@@transducer/step'] = function (result, input) {
    var key = this.keyFn(input);
    this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
    this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
    return result;
  };

  return XReduceBy;
}();

var _xreduceBy = /*#__PURE__*/Object(_curryN__WEBPACK_IMPORTED_MODULE_0__["default"])(4, [], function _xreduceBy(valueFn, valueAcc, keyFn, xf) {
  return new XReduceBy(valueFn, valueAcc, keyFn, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xreduceBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtake.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtake.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XTake = /*#__PURE__*/function () {
  function XTake(n, xf) {
    this.xf = xf;
    this.n = n;
    this.i = 0;
  }
  XTake.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XTake.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].result;
  XTake.prototype['@@transducer/step'] = function (result, input) {
    this.i += 1;
    var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
    return this.n >= 0 && this.i >= this.n ? Object(_reduced__WEBPACK_IMPORTED_MODULE_1__["default"])(ret) : ret;
  };

  return XTake;
}();

var _xtake = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xtake(n, xf) {
  return new XTake(n, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xtake);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtakeWhile.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtakeWhile.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XTakeWhile = /*#__PURE__*/function () {
  function XTakeWhile(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XTakeWhile.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XTakeWhile.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].result;
  XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.xf['@@transducer/step'](result, input) : Object(_reduced__WEBPACK_IMPORTED_MODULE_1__["default"])(result);
  };

  return XTakeWhile;
}();

var _xtakeWhile = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xtakeWhile(f, xf) {
  return new XTakeWhile(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xtakeWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtap.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtap.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XTap = /*#__PURE__*/function () {
  function XTap(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XTap.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XTap.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].result;
  XTap.prototype['@@transducer/step'] = function (result, input) {
    this.f(input);
    return this.xf['@@transducer/step'](result, input);
  };

  return XTap;
}();

var _xtap = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xtap(f, xf) {
  return new XTap(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xtap);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xwrap.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xwrap.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _xwrap; });
var XWrap = /*#__PURE__*/function () {
  function XWrap(fn) {
    this.f = fn;
  }
  XWrap.prototype['@@transducer/init'] = function () {
    throw new Error('init not implemented on XWrap');
  };
  XWrap.prototype['@@transducer/result'] = function (acc) {
    return acc;
  };
  XWrap.prototype['@@transducer/step'] = function (acc, x) {
    return this.f(acc, x);
  };

  return XWrap;
}();

function _xwrap(fn) {
  return new XWrap(fn);
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/intersection.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/intersection.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_contains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_contains */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_filter */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_filter.js");
/* harmony import */ var _flip__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flip */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flip.js");
/* harmony import */ var _uniq__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./uniq */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniq.js");






/**
 * Combines two lists into a set (i.e. no duplicates) composed of those
 * elements common to both lists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The list of elements found in both `list1` and `list2`.
 * @see R.innerJoin
 * @example
 *
 *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
 */
var intersection = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function intersection(list1, list2) {
  var lookupList, filteredList;
  if (list1.length > list2.length) {
    lookupList = list1;
    filteredList = list2;
  } else {
    lookupList = list2;
    filteredList = list1;
  }
  return Object(_uniq__WEBPACK_IMPORTED_MODULE_4__["default"])(Object(_internal_filter__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_flip__WEBPACK_IMPORTED_MODULE_3__["default"])(_internal_contains__WEBPACK_IMPORTED_MODULE_0__["default"])(lookupList), filteredList));
});
/* harmony default export */ __webpack_exports__["default"] = (intersection);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/intersperse.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/intersperse.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_checkForMethod */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_checkForMethod.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Creates a new list with the separator interposed between elements.
 *
 * Dispatches to the `intersperse` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig a -> [a] -> [a]
 * @param {*} separator The element to add to the list.
 * @param {Array} list The list to be interposed.
 * @return {Array} The new list.
 * @example
 *
 *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
 */
var intersperse = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__["default"])('intersperse', function intersperse(separator, list) {
  var out = [];
  var idx = 0;
  var length = list.length;
  while (idx < length) {
    if (idx === length - 1) {
      out.push(list[idx]);
    } else {
      out.push(list[idx], separator);
    }
    idx += 1;
  }
  return out;
}));
/* harmony default export */ __webpack_exports__["default"] = (intersperse);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/into.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/into.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_clone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_clone */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_clone.js");
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _internal_isTransformer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_isTransformer */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isTransformer.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _internal_stepCat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/_stepCat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_stepCat.js");






/**
 * Transforms the items of the list with the transducer and appends the
 * transformed items to the accumulator using an appropriate iterator function
 * based on the accumulator type.
 *
 * The accumulator can be an array, string, object or a transformer. Iterated
 * items will be appended to arrays and concatenated to strings. Objects will
 * be merged directly or 2-item arrays will be merged as key, value pairs.
 *
 * The accumulator can also be a transformer object that provides a 2-arity
 * reducing iterator function, step, 0-arity initial value function, init, and
 * 1-arity result extraction function result. The step function is used as the
 * iterator function in reduce. The result function is used to convert the
 * final accumulator into the return type and in most cases is R.identity. The
 * init function is used to provide the initial accumulator.
 *
 * The iteration is performed with [`R.reduce`](#reduce) after initializing the
 * transducer.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig a -> (b -> b) -> [c] -> a
 * @param {*} acc The initial accumulator value.
 * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @example
 *
 *      var numbers = [1, 2, 3, 4];
 *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
 *
 *      R.into([], transducer, numbers); //=> [2, 3]
 *
 *      var intoArray = R.into([]);
 *      intoArray(transducer, numbers); //=> [2, 3]
 */
var into = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_1__["default"])(function into(acc, xf, list) {
  return Object(_internal_isTransformer__WEBPACK_IMPORTED_MODULE_2__["default"])(acc) ? Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_3__["default"])(xf(acc), acc['@@transducer/init'](), list) : Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_3__["default"])(xf(Object(_internal_stepCat__WEBPACK_IMPORTED_MODULE_4__["default"])(acc)), Object(_internal_clone__WEBPACK_IMPORTED_MODULE_0__["default"])(acc, [], [], false), list);
});
/* harmony default export */ __webpack_exports__["default"] = (into);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invert.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invert.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");




/**
 * Same as [`R.invertObj`](#invertObj), however this accounts for objects with
 * duplicate values by putting the values into an array.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig {s: x} -> {x: [ s, ... ]}
 * @param {Object} obj The object or array to invert
 * @return {Object} out A new object with keys in an array.
 * @see R.invertObj
 * @example
 *
 *      var raceResultsByFirstName = {
 *        first: 'alice',
 *        second: 'jake',
 *        third: 'alice',
 *      };
 *      R.invert(raceResultsByFirstName);
 *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
 */
var invert = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function invert(obj) {
  var props = Object(_keys__WEBPACK_IMPORTED_MODULE_2__["default"])(obj);
  var len = props.length;
  var idx = 0;
  var out = {};

  while (idx < len) {
    var key = props[idx];
    var val = obj[key];
    var list = Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(val, out) ? out[val] : out[val] = [];
    list[list.length] = key;
    idx += 1;
  }
  return out;
});
/* harmony default export */ __webpack_exports__["default"] = (invert);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invertObj.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invertObj.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");



/**
 * Returns a new object with the keys of the given object as values, and the
 * values of the given object, which are coerced to strings, as keys. Note
 * that the last key found is preferred when handling the same value.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig {s: x} -> {x: s}
 * @param {Object} obj The object or array to invert
 * @return {Object} out A new object
 * @see R.invert
 * @example
 *
 *      var raceResults = {
 *        first: 'alice',
 *        second: 'jake'
 *      };
 *      R.invertObj(raceResults);
 *      //=> { 'alice': 'first', 'jake':'second' }
 *
 *      // Alternatively:
 *      var raceResults = ['alice', 'jake'];
 *      R.invertObj(raceResults);
 *      //=> { 'alice': '0', 'jake':'1' }
 */
var invertObj = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function invertObj(obj) {
  var props = Object(_keys__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
  var len = props.length;
  var idx = 0;
  var out = {};

  while (idx < len) {
    var key = props[idx];
    out[obj[key]] = key;
    idx += 1;
  }
  return out;
});
/* harmony default export */ __webpack_exports__["default"] = (invertObj);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invoker.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invoker.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isFunction */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isFunction.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toString.js");





/**
 * Turns a named method with a specified arity into a function that can be
 * called directly supplied with arguments and a target object.
 *
 * The returned function is curried and accepts `arity + 1` parameters where
 * the final parameter is the target object.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
 * @param {Number} arity Number of arguments the returned function should take
 *        before the target object.
 * @param {String} method Name of the method to call.
 * @return {Function} A new curried function.
 * @see R.construct
 * @example
 *
 *      var sliceFrom = R.invoker(1, 'slice');
 *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
 *      var sliceFrom6 = R.invoker(2, 'slice')(6);
 *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
 * @symb R.invoker(0, 'method')(o) = o['method']()
 * @symb R.invoker(1, 'method')(a, o) = o['method'](a)
 * @symb R.invoker(2, 'method')(a, b, o) = o['method'](a, b)
 */
var invoker = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function invoker(arity, method) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_2__["default"])(arity + 1, function () {
    var target = arguments[arity];
    if (target != null && Object(_internal_isFunction__WEBPACK_IMPORTED_MODULE_1__["default"])(target[method])) {
      return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
    }
    throw new TypeError(Object(_toString__WEBPACK_IMPORTED_MODULE_3__["default"])(target) + ' does not have a method named "' + method + '"');
  });
});
/* harmony default export */ __webpack_exports__["default"] = (invoker);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/is.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/is.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * See if an object (`val`) is an instance of the supplied constructor. This
 * function will check up the inheritance chain, if any.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Type
 * @sig (* -> {*}) -> a -> Boolean
 * @param {Object} ctor A constructor
 * @param {*} val The value to test
 * @return {Boolean}
 * @example
 *
 *      R.is(Object, {}); //=> true
 *      R.is(Number, 1); //=> true
 *      R.is(Object, 1); //=> false
 *      R.is(String, 's'); //=> true
 *      R.is(String, new String('')); //=> true
 *      R.is(Object, new String('')); //=> true
 *      R.is(Object, 's'); //=> false
 *      R.is(Number, {}); //=> false
 */
var is = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function is(Ctor, val) {
  return val != null && val.constructor === Ctor || val instanceof Ctor;
});
/* harmony default export */ __webpack_exports__["default"] = (is);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/isEmpty.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/isEmpty.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./empty */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/empty.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");




/**
 * Returns `true` if the given value is its type's empty value; `false`
 * otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig a -> Boolean
 * @param {*} x
 * @return {Boolean}
 * @see R.empty
 * @example
 *
 *      R.isEmpty([1, 2, 3]);   //=> false
 *      R.isEmpty([]);          //=> true
 *      R.isEmpty('');          //=> true
 *      R.isEmpty(null);        //=> false
 *      R.isEmpty({});          //=> true
 *      R.isEmpty({length: 0}); //=> false
 */
var isEmpty = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function isEmpty(x) {
  return x != null && Object(_equals__WEBPACK_IMPORTED_MODULE_2__["default"])(x, Object(_empty__WEBPACK_IMPORTED_MODULE_1__["default"])(x));
});
/* harmony default export */ __webpack_exports__["default"] = (isEmpty);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/isNil.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/isNil.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Checks if the input value is `null` or `undefined`.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Type
 * @sig * -> Boolean
 * @param {*} x The value to test.
 * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
 * @example
 *
 *      R.isNil(null); //=> true
 *      R.isNil(undefined); //=> true
 *      R.isNil(0); //=> false
 *      R.isNil([]); //=> false
 */
var isNil = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function isNil(x) {
  return x == null;
});
/* harmony default export */ __webpack_exports__["default"] = (isNil);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/join.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/join.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _invoker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invoker */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invoker.js");


/**
 * Returns a string made by inserting the `separator` between each element and
 * concatenating all the elements into a single string.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig String -> [a] -> String
 * @param {Number|String} separator The string used to separate the elements.
 * @param {Array} xs The elements to join into a string.
 * @return {String} str The string made by concatenating `xs` with `separator`.
 * @see R.split
 * @example
 *
 *      var spacer = R.join(' ');
 *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
 *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
 */
var join = /*#__PURE__*/Object(_invoker__WEBPACK_IMPORTED_MODULE_0__["default"])(1, 'join');
/* harmony default export */ __webpack_exports__["default"] = (join);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/juxt.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/juxt.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _converge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./converge */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/converge.js");



/**
 * juxt applies a list of functions to a list of values.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Function
 * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
 * @param {Array} fns An array of functions
 * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
 * @see R.applySpec
 * @example
 *
 *      var getRange = R.juxt([Math.min, Math.max]);
 *      getRange(3, 4, 9, -3); //=> [-3, 9]
 * @symb R.juxt([f, g, h])(a, b) = [f(a, b), g(a, b), h(a, b)]
 */
var juxt = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function juxt(fns) {
  return Object(_converge__WEBPACK_IMPORTED_MODULE_1__["default"])(function () {
    return Array.prototype.slice.call(arguments, 0);
  }, fns);
});
/* harmony default export */ __webpack_exports__["default"] = (juxt);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");
/* harmony import */ var _internal_isArguments__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_isArguments */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArguments.js");




// cover IE < 9 keys issues
var hasEnumBug = ! /*#__PURE__*/{ toString: null }.propertyIsEnumerable('toString');
var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
// Safari bug
var hasArgsEnumBug = /*#__PURE__*/function () {
  'use strict';

  return arguments.propertyIsEnumerable('length');
}();

var contains = function contains(list, item) {
  var idx = 0;
  while (idx < list.length) {
    if (list[idx] === item) {
      return true;
    }
    idx += 1;
  }
  return false;
};

/**
 * Returns a list containing the names of all the enumerable own properties of
 * the supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own properties.
 * @see R.keysIn, R.values
 * @example
 *
 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
 */
var _keys = typeof Object.keys === 'function' && !hasArgsEnumBug ? function keys(obj) {
  return Object(obj) !== obj ? [] : Object.keys(obj);
} : function keys(obj) {
  if (Object(obj) !== obj) {
    return [];
  }
  var prop, nIdx;
  var ks = [];
  var checkArgsLength = hasArgsEnumBug && Object(_internal_isArguments__WEBPACK_IMPORTED_MODULE_2__["default"])(obj);
  for (prop in obj) {
    if (Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(prop, obj) && (!checkArgsLength || prop !== 'length')) {
      ks[ks.length] = prop;
    }
  }
  if (hasEnumBug) {
    nIdx = nonEnumerableProps.length - 1;
    while (nIdx >= 0) {
      prop = nonEnumerableProps[nIdx];
      if (Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(prop, obj) && !contains(ks, prop)) {
        ks[ks.length] = prop;
      }
      nIdx -= 1;
    }
  }
  return ks;
};
var keys = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(_keys);
/* harmony default export */ __webpack_exports__["default"] = (keys);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keysIn.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keysIn.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Returns a list containing the names of all the properties of the supplied
 * object, including prototype properties.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own and prototype properties.
 * @see R.keys, R.valuesIn
 * @example
 *
 *      var F = function() { this.x = 'X'; };
 *      F.prototype.y = 'Y';
 *      var f = new F();
 *      R.keysIn(f); //=> ['x', 'y']
 */
var keysIn = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function keysIn(obj) {
  var prop;
  var ks = [];
  for (prop in obj) {
    ks[ks.length] = prop;
  }
  return ks;
});
/* harmony default export */ __webpack_exports__["default"] = (keysIn);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/last.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/last.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nth */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nth.js");


/**
 * Returns the last element of the given list or string.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig [a] -> a | Undefined
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.init, R.head, R.tail
 * @example
 *
 *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
 *      R.last([]); //=> undefined
 *
 *      R.last('abc'); //=> 'c'
 *      R.last(''); //=> ''
 */
var last = /*#__PURE__*/Object(_nth__WEBPACK_IMPORTED_MODULE_0__["default"])(-1);
/* harmony default export */ __webpack_exports__["default"] = (last);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lastIndexOf.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lastIndexOf.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");




/**
 * Returns the position of the last occurrence of an item in an array, or -1 if
 * the item is not included in the array. [`R.equals`](#equals) is used to
 * determine equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> Number
 * @param {*} target The item to find.
 * @param {Array} xs The array to search in.
 * @return {Number} the index of the target, or -1 if the target is not found.
 * @see R.indexOf
 * @example
 *
 *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
 *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
 */
var lastIndexOf = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function lastIndexOf(target, xs) {
  if (typeof xs.lastIndexOf === 'function' && !Object(_internal_isArray__WEBPACK_IMPORTED_MODULE_1__["default"])(xs)) {
    return xs.lastIndexOf(target);
  } else {
    var idx = xs.length - 1;
    while (idx >= 0) {
      if (Object(_equals__WEBPACK_IMPORTED_MODULE_2__["default"])(xs[idx], target)) {
        return idx;
      }
      idx -= 1;
    }
    return -1;
  }
});
/* harmony default export */ __webpack_exports__["default"] = (lastIndexOf);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/length.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/length.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_isNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isNumber */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isNumber.js");



/**
 * Returns the number of elements in the array by returning `list.length`.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig [a] -> Number
 * @param {Array} list The array to inspect.
 * @return {Number} The length of the array.
 * @example
 *
 *      R.length([]); //=> 0
 *      R.length([1, 2, 3]); //=> 3
 */
var length = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function length(list) {
  return list != null && Object(_internal_isNumber__WEBPACK_IMPORTED_MODULE_1__["default"])(list.length) ? list.length : NaN;
});
/* harmony default export */ __webpack_exports__["default"] = (length);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lens.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lens.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");



/**
 * Returns a lens for the given getter and setter functions. The getter "gets"
 * the value of the focus; the setter "sets" the value of the focus. The setter
 * should not mutate the data structure.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
 * @param {Function} getter
 * @param {Function} setter
 * @return {Lens}
 * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
 * @example
 *
 *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
 *
 *      R.view(xLens, {x: 1, y: 2});            //=> 1
 *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
 *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
 */
var lens = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function lens(getter, setter) {
  return function (toFunctorFn) {
    return function (target) {
      return Object(_map__WEBPACK_IMPORTED_MODULE_1__["default"])(function (focus) {
        return setter(focus, target);
      }, toFunctorFn(getter(target)));
    };
  };
});
/* harmony default export */ __webpack_exports__["default"] = (lens);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensIndex.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensIndex.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _lens__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lens */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lens.js");
/* harmony import */ var _nth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nth */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nth.js");
/* harmony import */ var _update__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./update */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/update.js");





/**
 * Returns a lens whose focus is the specified index.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Number -> Lens s a
 * @param {Number} n
 * @return {Lens}
 * @see R.view, R.set, R.over
 * @example
 *
 *      var headLens = R.lensIndex(0);
 *
 *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
 *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
 *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
 */
var lensIndex = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function lensIndex(n) {
  return Object(_lens__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_nth__WEBPACK_IMPORTED_MODULE_2__["default"])(n), Object(_update__WEBPACK_IMPORTED_MODULE_3__["default"])(n));
});
/* harmony default export */ __webpack_exports__["default"] = (lensIndex);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensPath.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensPath.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _assocPath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assocPath */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assocPath.js");
/* harmony import */ var _lens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lens */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lens.js");
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./path */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js");





/**
 * Returns a lens whose focus is the specified path.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Object
 * @typedefn Idx = String | Int
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig [Idx] -> Lens s a
 * @param {Array} path The path to use.
 * @return {Lens}
 * @see R.view, R.set, R.over
 * @example
 *
 *      var xHeadYLens = R.lensPath(['x', 0, 'y']);
 *
 *      R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
 *      //=> 2
 *      R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
 *      //=> {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
 *      R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
 *      //=> {x: [{y: -2, z: 3}, {y: 4, z: 5}]}
 */
var lensPath = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function lensPath(p) {
  return Object(_lens__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_path__WEBPACK_IMPORTED_MODULE_3__["default"])(p), Object(_assocPath__WEBPACK_IMPORTED_MODULE_1__["default"])(p));
});
/* harmony default export */ __webpack_exports__["default"] = (lensPath);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensProp.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensProp.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _assoc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assoc */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assoc.js");
/* harmony import */ var _lens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lens */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lens.js");
/* harmony import */ var _prop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./prop */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prop.js");





/**
 * Returns a lens whose focus is the specified property.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig String -> Lens s a
 * @param {String} k
 * @return {Lens}
 * @see R.view, R.set, R.over
 * @example
 *
 *      var xLens = R.lensProp('x');
 *
 *      R.view(xLens, {x: 1, y: 2});            //=> 1
 *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
 *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
 */
var lensProp = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function lensProp(k) {
  return Object(_lens__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_prop__WEBPACK_IMPORTED_MODULE_3__["default"])(k), Object(_assoc__WEBPACK_IMPORTED_MODULE_1__["default"])(k));
});
/* harmony default export */ __webpack_exports__["default"] = (lensProp);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lift.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lift.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _liftN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./liftN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/liftN.js");



/**
 * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other
 * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Function
 * @sig (*... -> *) -> ([*]... -> [*])
 * @param {Function} fn The function to lift into higher context
 * @return {Function} The lifted function.
 * @see R.liftN
 * @example
 *
 *      var madd3 = R.lift((a, b, c) => a + b + c);
 *
 *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
 *
 *      var madd5 = R.lift((a, b, c, d, e) => a + b + c + d + e);
 *
 *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
 */
var lift = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function lift(fn) {
  return Object(_liftN__WEBPACK_IMPORTED_MODULE_1__["default"])(fn.length, fn);
});
/* harmony default export */ __webpack_exports__["default"] = (lift);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/liftN.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/liftN.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _ap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ap.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");






/**
 * "lifts" a function to be the specified arity, so that it may "map over" that
 * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Function
 * @sig Number -> (*... -> *) -> ([*]... -> [*])
 * @param {Function} fn The function to lift into higher context
 * @return {Function} The lifted function.
 * @see R.lift, R.ap
 * @example
 *
 *      var madd3 = R.liftN(3, (...args) => R.sum(args));
 *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
 */
var liftN = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function liftN(arity, fn) {
  var lifted = Object(_curryN__WEBPACK_IMPORTED_MODULE_3__["default"])(arity, fn);
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_3__["default"])(arity, function () {
    return Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_1__["default"])(_ap__WEBPACK_IMPORTED_MODULE_2__["default"], Object(_map__WEBPACK_IMPORTED_MODULE_4__["default"])(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
  });
});
/* harmony default export */ __webpack_exports__["default"] = (liftN);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lt.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lt.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns `true` if the first argument is less than the second; `false`
 * otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @see R.gt
 * @example
 *
 *      R.lt(2, 1); //=> false
 *      R.lt(2, 2); //=> false
 *      R.lt(2, 3); //=> true
 *      R.lt('a', 'z'); //=> true
 *      R.lt('z', 'a'); //=> false
 */
var lt = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function lt(a, b) {
  return a < b;
});
/* harmony default export */ __webpack_exports__["default"] = (lt);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lte.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lte.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns `true` if the first argument is less than or equal to the second;
 * `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {Number} a
 * @param {Number} b
 * @return {Boolean}
 * @see R.gte
 * @example
 *
 *      R.lte(2, 1); //=> false
 *      R.lte(2, 2); //=> true
 *      R.lte(2, 3); //=> true
 *      R.lte('a', 'z'); //=> true
 *      R.lte('z', 'a'); //=> false
 */
var lte = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function lte(a, b) {
  return a <= b;
});
/* harmony default export */ __webpack_exports__["default"] = (lte);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_map.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _internal_xmap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/_xmap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xmap.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");








/**
 * Takes a function and
 * a [functor](https://github.com/fantasyland/fantasy-land#functor),
 * applies the function to each of the functor's values, and returns
 * a functor of the same shape.
 *
 * Ramda provides suitable `map` implementations for `Array` and `Object`,
 * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
 *
 * Dispatches to the `map` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * Also treats functions as functors and will compose them together.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Functor f => (a -> b) -> f a -> f b
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {Array} list The list to be iterated over.
 * @return {Array} The new list.
 * @see R.transduce, R.addIndex
 * @example
 *
 *      var double = x => x * 2;
 *
 *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
 *
 *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
 * @symb R.map(f, [a, b]) = [f(a), f(b)]
 * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
 * @symb R.map(f, functor_o) = functor_o.map(f)
 */
var map = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['fantasy-land/map', 'map'], _internal_xmap__WEBPACK_IMPORTED_MODULE_4__["default"], function map(fn, functor) {
  switch (Object.prototype.toString.call(functor)) {
    case '[object Function]':
      return Object(_curryN__WEBPACK_IMPORTED_MODULE_5__["default"])(functor.length, function () {
        return fn.call(this, functor.apply(this, arguments));
      });
    case '[object Object]':
      return Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_3__["default"])(function (acc, key) {
        acc[key] = fn(functor[key]);
        return acc;
      }, {}, Object(_keys__WEBPACK_IMPORTED_MODULE_6__["default"])(functor));
    default:
      return Object(_internal_map__WEBPACK_IMPORTED_MODULE_2__["default"])(fn, functor);
  }
}));
/* harmony default export */ __webpack_exports__["default"] = (map);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapAccum.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapAccum.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * The `mapAccum` function behaves like a combination of map and reduce; it
 * applies a function to each element of a list, passing an accumulating
 * parameter from left to right, and returning a final value of this
 * accumulator together with the new list.
 *
 * The iterator function receives two arguments, *acc* and *value*, and should
 * return a tuple *[acc, value]*.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig ((acc, x) -> (acc, y)) -> acc -> [x] -> (acc, [y])
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.addIndex, R.mapAccumRight
 * @example
 *
 *      var digits = ['1', '2', '3', '4'];
 *      var appender = (a, b) => [a + b, a + b];
 *
 *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
 * @symb R.mapAccum(f, a, [b, c, d]) = [
 *   f(f(f(a, b)[0], c)[0], d)[0],
 *   [
 *     f(a, b)[1],
 *     f(f(a, b)[0], c)[1],
 *     f(f(f(a, b)[0], c)[0], d)[1]
 *   ]
 * ]
 */
var mapAccum = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function mapAccum(fn, acc, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  var tuple = [acc];
  while (idx < len) {
    tuple = fn(tuple[0], list[idx]);
    result[idx] = tuple[1];
    idx += 1;
  }
  return [tuple[0], result];
});
/* harmony default export */ __webpack_exports__["default"] = (mapAccum);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapAccumRight.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapAccumRight.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * The `mapAccumRight` function behaves like a combination of map and reduce; it
 * applies a function to each element of a list, passing an accumulating
 * parameter from right to left, and returning a final value of this
 * accumulator together with the new list.
 *
 * Similar to [`mapAccum`](#mapAccum), except moves through the input list from
 * the right to the left.
 *
 * The iterator function receives two arguments, *value* and *acc*, and should
 * return a tuple *[value, acc]*.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig ((x, acc) -> (y, acc)) -> acc -> [x] -> ([y], acc)
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.addIndex, R.mapAccum
 * @example
 *
 *      var digits = ['1', '2', '3', '4'];
 *      var append = (a, b) => [a + b, a + b];
 *
 *      R.mapAccumRight(append, 5, digits); //=> [['12345', '2345', '345', '45'], '12345']
 * @symb R.mapAccumRight(f, a, [b, c, d]) = [
 *   [
 *     f(b, f(c, f(d, a)[0])[0])[1],
 *     f(c, f(d, a)[0])[1],
 *     f(d, a)[1],
 *   ]
 *   f(b, f(c, f(d, a)[0])[0])[0],
 * ]
 */
var mapAccumRight = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function mapAccumRight(fn, acc, list) {
  var idx = list.length - 1;
  var result = [];
  var tuple = [acc];
  while (idx >= 0) {
    tuple = fn(list[idx], tuple[0]);
    result[idx] = tuple[1];
    idx -= 1;
  }
  return [result, tuple[0]];
});
/* harmony default export */ __webpack_exports__["default"] = (mapAccumRight);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapObjIndexed.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapObjIndexed.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");




/**
 * An Object-specific version of [`map`](#map). The function is applied to three
 * arguments: *(value, key, obj)*. If only the value is significant, use
 * [`map`](#map) instead.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig ((*, String, Object) -> *) -> Object -> Object
 * @param {Function} fn
 * @param {Object} obj
 * @return {Object}
 * @see R.map
 * @example
 *
 *      var values = { x: 1, y: 2, z: 3 };
 *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
 *
 *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
 */
var mapObjIndexed = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function mapObjIndexed(fn, obj) {
  return Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_1__["default"])(function (acc, key) {
    acc[key] = fn(obj[key], key, obj);
    return acc;
  }, {}, Object(_keys__WEBPACK_IMPORTED_MODULE_2__["default"])(obj));
});
/* harmony default export */ __webpack_exports__["default"] = (mapObjIndexed);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/match.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/match.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Tests a regular expression against a String. Note that this function will
 * return an empty array when there are no matches. This differs from
 * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
 * which returns `null` when there are no matches.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category String
 * @sig RegExp -> String -> [String | Undefined]
 * @param {RegExp} rx A regular expression.
 * @param {String} str The string to match against
 * @return {Array} The list of matches or empty array.
 * @see R.test
 * @example
 *
 *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
 *      R.match(/a/, 'b'); //=> []
 *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
 */
var match = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function match(rx, str) {
  return str.match(rx) || [];
});
/* harmony default export */ __webpack_exports__["default"] = (match);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mathMod.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mathMod.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isInteger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isInteger */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isInteger.js");



/**
 * `mathMod` behaves like the modulo operator should mathematically, unlike the
 * `%` operator (and by extension, [`R.modulo`](#modulo)). So while
 * `-17 % 5` is `-2`, `mathMod(-17, 5)` is `3`. `mathMod` requires Integer
 * arguments, and returns NaN when the modulus is zero or negative.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} m The dividend.
 * @param {Number} p the modulus.
 * @return {Number} The result of `b mod a`.
 * @see R.modulo
 * @example
 *
 *      R.mathMod(-17, 5);  //=> 3
 *      R.mathMod(17, 5);   //=> 2
 *      R.mathMod(17, -5);  //=> NaN
 *      R.mathMod(17, 0);   //=> NaN
 *      R.mathMod(17.2, 5); //=> NaN
 *      R.mathMod(17, 5.3); //=> NaN
 *
 *      var clock = R.mathMod(R.__, 12);
 *      clock(15); //=> 3
 *      clock(24); //=> 0
 *
 *      var seventeenMod = R.mathMod(17);
 *      seventeenMod(3);  //=> 2
 *      seventeenMod(4);  //=> 1
 *      seventeenMod(10); //=> 7
 */
var mathMod = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function mathMod(m, p) {
  if (!Object(_internal_isInteger__WEBPACK_IMPORTED_MODULE_1__["default"])(m)) {
    return NaN;
  }
  if (!Object(_internal_isInteger__WEBPACK_IMPORTED_MODULE_1__["default"])(p) || p < 1) {
    return NaN;
  }
  return (m % p + p) % p;
});
/* harmony default export */ __webpack_exports__["default"] = (mathMod);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns the larger of its two arguments.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> a
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.maxBy, R.min
 * @example
 *
 *      R.max(789, 123); //=> 789
 *      R.max('a', 'b'); //=> 'b'
 */
var max = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function max(a, b) {
  return b > a ? b : a;
});
/* harmony default export */ __webpack_exports__["default"] = (max);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/maxBy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/maxBy.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Takes a function and two values, and returns whichever value produces the
 * larger result when passed to the provided function.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Relation
 * @sig Ord b => (a -> b) -> a -> a -> a
 * @param {Function} f
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.max, R.minBy
 * @example
 *
 *      //  square :: Number -> Number
 *      var square = n => n * n;
 *
 *      R.maxBy(square, -3, 2); //=> -3
 *
 *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
 *      R.reduce(R.maxBy(square), 0, []); //=> 0
 */
var maxBy = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function maxBy(f, a, b) {
  return f(b) > f(a) ? b : a;
});
/* harmony default export */ __webpack_exports__["default"] = (maxBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mean.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mean.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _sum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sum */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sum.js");



/**
 * Returns the mean of the given list of numbers.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list
 * @return {Number}
 * @see R.median
 * @example
 *
 *      R.mean([2, 7, 9]); //=> 6
 *      R.mean([]); //=> NaN
 */
var mean = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function mean(list) {
  return Object(_sum__WEBPACK_IMPORTED_MODULE_1__["default"])(list) / list.length;
});
/* harmony default export */ __webpack_exports__["default"] = (mean);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/median.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/median.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _mean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mean */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mean.js");



/**
 * Returns the median of the given list of numbers.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list
 * @return {Number}
 * @see R.mean
 * @example
 *
 *      R.median([2, 9, 7]); //=> 7
 *      R.median([7, 2, 10, 9]); //=> 8
 *      R.median([]); //=> NaN
 */
var median = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function median(list) {
  var len = list.length;
  if (len === 0) {
    return NaN;
  }
  var width = 2 - len % 2;
  var idx = (len - width) / 2;
  return Object(_mean__WEBPACK_IMPORTED_MODULE_1__["default"])(Array.prototype.slice.call(list, 0).sort(function (a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }).slice(idx, idx + width));
});
/* harmony default export */ __webpack_exports__["default"] = (median);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/memoize.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/memoize.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _memoizeWith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memoizeWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/memoizeWith.js");
/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toString.js");



/**
 * Creates a new function that, when invoked, caches the result of calling `fn`
 * for a given argument set and returns the result. Subsequent calls to the
 * memoized `fn` with the same argument set will not result in an additional
 * call to `fn`; instead, the cached result for that set of arguments will be
 * returned.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (*... -> a) -> (*... -> a)
 * @param {Function} fn The function to memoize.
 * @return {Function} Memoized version of `fn`.
 * @see R.memoizeWith
 * @deprecated since v0.25.0
 * @example
 *
 *      let count = 0;
 *      const factorial = R.memoize(n => {
 *        count += 1;
 *        return R.product(R.range(1, n + 1));
 *      });
 *      factorial(5); //=> 120
 *      factorial(5); //=> 120
 *      factorial(5); //=> 120
 *      count; //=> 1
 */
var memoize = /*#__PURE__*/Object(_memoizeWith__WEBPACK_IMPORTED_MODULE_0__["default"])(function () {
  return Object(_toString__WEBPACK_IMPORTED_MODULE_1__["default"])(arguments);
});
/* harmony default export */ __webpack_exports__["default"] = (memoize);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/memoizeWith.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/memoizeWith.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");




/**
 * A customisable version of [`R.memoize`](#memoize). `memoizeWith` takes an
 * additional function that will be applied to a given argument set and used to
 * create the cache key under which the results of the function to be memoized
 * will be stored. Care must be taken when implementing key generation to avoid
 * clashes that may overwrite previous entries erroneously.
 *
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Function
 * @sig (*... -> String) -> (*... -> a) -> (*... -> a)
 * @param {Function} fn The function to generate the cache key.
 * @param {Function} fn The function to memoize.
 * @return {Function} Memoized version of `fn`.
 * @see R.memoize
 * @example
 *
 *      let count = 0;
 *      const factorial = R.memoizeWith(R.identity, n => {
 *        count += 1;
 *        return R.product(R.range(1, n + 1));
 *      });
 *      factorial(5); //=> 120
 *      factorial(5); //=> 120
 *      factorial(5); //=> 120
 *      count; //=> 1
 */
var memoizeWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function memoizeWith(mFn, fn) {
  var cache = {};
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(fn.length, function () {
    var key = mFn.apply(this, arguments);
    if (!Object(_internal_has__WEBPACK_IMPORTED_MODULE_2__["default"])(key, cache)) {
      cache[key] = fn.apply(this, arguments);
    }
    return cache[key];
  });
});
/* harmony default export */ __webpack_exports__["default"] = (memoizeWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/merge.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/merge.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_assign */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_assign.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Create a new object with the own properties of the first object merged with
 * the own properties of the second object. If a key exists in both objects,
 * the value from the second object will be used.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> {k: v} -> {k: v}
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.mergeDeepRight, R.mergeWith, R.mergeWithKey
 * @example
 *
 *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
 *      //=> { 'name': 'fred', 'age': 40 }
 *
 *      var resetToDefault = R.merge(R.__, {x: 0});
 *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
 * @symb R.merge({ x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: 5, z: 3 }
 */
var merge = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function merge(l, r) {
  return Object(_internal_assign__WEBPACK_IMPORTED_MODULE_0__["default"])({}, l, r);
});
/* harmony default export */ __webpack_exports__["default"] = (merge);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeAll.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeAll.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_assign */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_assign.js");
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");



/**
 * Merges a list of objects together into one object.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig [{k: v}] -> {k: v}
 * @param {Array} list An array of objects
 * @return {Object} A merged object.
 * @see R.reduce
 * @example
 *
 *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
 *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
 * @symb R.mergeAll([{ x: 1 }, { y: 2 }, { z: 3 }]) = { x: 1, y: 2, z: 3 }
 */
var mergeAll = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_1__["default"])(function mergeAll(list) {
  return _internal_assign__WEBPACK_IMPORTED_MODULE_0__["default"].apply(null, [{}].concat(list));
});
/* harmony default export */ __webpack_exports__["default"] = (mergeAll);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepLeft.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepLeft.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeDeepWithKey */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWithKey.js");



/**
 * Creates a new object with the own properties of the first object merged with
 * the own properties of the second object. If a key exists in both objects:
 * - and both values are objects, the two values will be recursively merged
 * - otherwise the value from the first object will be used.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Object
 * @sig {a} -> {a} -> {a}
 * @param {Object} lObj
 * @param {Object} rObj
 * @return {Object}
 * @see R.merge, R.mergeDeepRight, R.mergeDeepWith, R.mergeDeepWithKey
 * @example
 *
 *      R.mergeDeepLeft({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
 *                      { age: 40, contact: { email: 'baa@example.com' }});
 *      //=> { name: 'fred', age: 10, contact: { email: 'moo@example.com' }}
 */
var mergeDeepLeft = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function mergeDeepLeft(lObj, rObj) {
  return Object(_mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_1__["default"])(function (k, lVal, rVal) {
    return lVal;
  }, lObj, rObj);
});
/* harmony default export */ __webpack_exports__["default"] = (mergeDeepLeft);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepRight.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepRight.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeDeepWithKey */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWithKey.js");



/**
 * Creates a new object with the own properties of the first object merged with
 * the own properties of the second object. If a key exists in both objects:
 * - and both values are objects, the two values will be recursively merged
 * - otherwise the value from the second object will be used.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Object
 * @sig {a} -> {a} -> {a}
 * @param {Object} lObj
 * @param {Object} rObj
 * @return {Object}
 * @see R.merge, R.mergeDeepLeft, R.mergeDeepWith, R.mergeDeepWithKey
 * @example
 *
 *      R.mergeDeepRight({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
 *                       { age: 40, contact: { email: 'baa@example.com' }});
 *      //=> { name: 'fred', age: 40, contact: { email: 'baa@example.com' }}
 */
var mergeDeepRight = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function mergeDeepRight(lObj, rObj) {
  return Object(_mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_1__["default"])(function (k, lVal, rVal) {
    return rVal;
  }, lObj, rObj);
});
/* harmony default export */ __webpack_exports__["default"] = (mergeDeepRight);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWith.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWith.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeDeepWithKey */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWithKey.js");



/**
 * Creates a new object with the own properties of the two provided objects.
 * If a key exists in both objects:
 * - and both associated values are also objects then the values will be
 *   recursively merged.
 * - otherwise the provided function is applied to associated values using the
 *   resulting value as the new value associated with the key.
 * If a key only exists in one object, the value will be associated with the key
 * of the resulting object.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Object
 * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} lObj
 * @param {Object} rObj
 * @return {Object}
 * @see R.mergeWith, R.mergeDeep, R.mergeDeepWithKey
 * @example
 *
 *      R.mergeDeepWith(R.concat,
 *                      { a: true, c: { values: [10, 20] }},
 *                      { b: true, c: { values: [15, 35] }});
 *      //=> { a: true, b: true, c: { values: [10, 20, 15, 35] }}
 */
var mergeDeepWith = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function mergeDeepWith(fn, lObj, rObj) {
  return Object(_mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_1__["default"])(function (k, lVal, rVal) {
    return fn(lVal, rVal);
  }, lObj, rObj);
});
/* harmony default export */ __webpack_exports__["default"] = (mergeDeepWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWithKey.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWithKey.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _internal_isObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isObject */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isObject.js");
/* harmony import */ var _mergeWithKey__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mergeWithKey */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWithKey.js");




/**
 * Creates a new object with the own properties of the two provided objects.
 * If a key exists in both objects:
 * - and both associated values are also objects then the values will be
 *   recursively merged.
 * - otherwise the provided function is applied to the key and associated values
 *   using the resulting value as the new value associated with the key.
 * If a key only exists in one object, the value will be associated with the key
 * of the resulting object.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Object
 * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} lObj
 * @param {Object} rObj
 * @return {Object}
 * @see R.mergeWithKey, R.mergeDeep, R.mergeDeepWith
 * @example
 *
 *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
 *      R.mergeDeepWithKey(concatValues,
 *                         { a: true, c: { thing: 'foo', values: [10, 20] }},
 *                         { b: true, c: { thing: 'bar', values: [15, 35] }});
 *      //=> { a: true, b: true, c: { thing: 'bar', values: [10, 20, 15, 35] }}
 */
var mergeDeepWithKey = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function mergeDeepWithKey(fn, lObj, rObj) {
  return Object(_mergeWithKey__WEBPACK_IMPORTED_MODULE_2__["default"])(function (k, lVal, rVal) {
    if (Object(_internal_isObject__WEBPACK_IMPORTED_MODULE_1__["default"])(lVal) && Object(_internal_isObject__WEBPACK_IMPORTED_MODULE_1__["default"])(rVal)) {
      return mergeDeepWithKey(fn, lVal, rVal);
    } else {
      return fn(k, lVal, rVal);
    }
  }, lObj, rObj);
});
/* harmony default export */ __webpack_exports__["default"] = (mergeDeepWithKey);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWith.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWith.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _mergeWithKey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeWithKey */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWithKey.js");



/**
 * Creates a new object with the own properties of the two provided objects. If
 * a key exists in both objects, the provided function is applied to the values
 * associated with the key in each object, with the result being used as the
 * value associated with the key in the returned object.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Object
 * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.mergeDeepWith, R.merge, R.mergeWithKey
 * @example
 *
 *      R.mergeWith(R.concat,
 *                  { a: true, values: [10, 20] },
 *                  { b: true, values: [15, 35] });
 *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
 */
var mergeWith = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function mergeWith(fn, l, r) {
  return Object(_mergeWithKey__WEBPACK_IMPORTED_MODULE_1__["default"])(function (_, _l, _r) {
    return fn(_l, _r);
  }, l, r);
});
/* harmony default export */ __webpack_exports__["default"] = (mergeWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWithKey.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWithKey.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");



/**
 * Creates a new object with the own properties of the two provided objects. If
 * a key exists in both objects, the provided function is applied to the key
 * and the values associated with the key in each object, with the result being
 * used as the value associated with the key in the returned object.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Object
 * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.mergeDeepWithKey, R.merge, R.mergeWith
 * @example
 *
 *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
 *      R.mergeWithKey(concatValues,
 *                     { a: true, thing: 'foo', values: [10, 20] },
 *                     { b: true, thing: 'bar', values: [15, 35] });
 *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
 * @symb R.mergeWithKey(f, { x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: f('y', 2, 5), z: 3 }
 */
var mergeWithKey = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function mergeWithKey(fn, l, r) {
  var result = {};
  var k;

  for (k in l) {
    if (Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(k, l)) {
      result[k] = Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(k, r) ? fn(k, l[k], r[k]) : l[k];
    }
  }

  for (k in r) {
    if (Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(k, r) && !Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(k, result)) {
      result[k] = r[k];
    }
  }

  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (mergeWithKey);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/min.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/min.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns the smaller of its two arguments.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> a
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.minBy, R.max
 * @example
 *
 *      R.min(789, 123); //=> 123
 *      R.min('a', 'b'); //=> 'a'
 */
var min = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function min(a, b) {
  return b < a ? b : a;
});
/* harmony default export */ __webpack_exports__["default"] = (min);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/minBy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/minBy.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Takes a function and two values, and returns whichever value produces the
 * smaller result when passed to the provided function.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Relation
 * @sig Ord b => (a -> b) -> a -> a -> a
 * @param {Function} f
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.min, R.maxBy
 * @example
 *
 *      //  square :: Number -> Number
 *      var square = n => n * n;
 *
 *      R.minBy(square, -3, 2); //=> 2
 *
 *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
 *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
 */
var minBy = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function minBy(f, a, b) {
  return f(b) < f(a) ? b : a;
});
/* harmony default export */ __webpack_exports__["default"] = (minBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/modulo.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/modulo.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Divides the first parameter by the second and returns the remainder. Note
 * that this function preserves the JavaScript-style behavior for modulo. For
 * mathematical modulo see [`mathMod`](#mathMod).
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The value to the divide.
 * @param {Number} b The pseudo-modulus
 * @return {Number} The result of `b % a`.
 * @see R.mathMod
 * @example
 *
 *      R.modulo(17, 3); //=> 2
 *      // JS behavior:
 *      R.modulo(-17, 3); //=> -2
 *      R.modulo(17, -3); //=> 2
 *
 *      var isOdd = R.modulo(R.__, 2);
 *      isOdd(42); //=> 0
 *      isOdd(21); //=> 1
 */
var modulo = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function modulo(a, b) {
  return a % b;
});
/* harmony default export */ __webpack_exports__["default"] = (modulo);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/multiply.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/multiply.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Multiplies two numbers. Equivalent to `a * b` but curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The first value.
 * @param {Number} b The second value.
 * @return {Number} The result of `a * b`.
 * @see R.divide
 * @example
 *
 *      var double = R.multiply(2);
 *      var triple = R.multiply(3);
 *      double(3);       //=>  6
 *      triple(4);       //=> 12
 *      R.multiply(2, 5);  //=> 10
 */
var multiply = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function multiply(a, b) {
  return a * b;
});
/* harmony default export */ __webpack_exports__["default"] = (multiply);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nAry.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nAry.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Wraps a function of any arity (including nullary) in a function that accepts
 * exactly `n` parameters. Any extraneous parameters will not be passed to the
 * supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} n The desired arity of the new function.
 * @param {Function} fn The function to wrap.
 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
 *         arity `n`.
 * @see R.binary, R.unary
 * @example
 *
 *      var takesTwoArgs = (a, b) => [a, b];
 *
 *      takesTwoArgs.length; //=> 2
 *      takesTwoArgs(1, 2); //=> [1, 2]
 *
 *      var takesOneArg = R.nAry(1, takesTwoArgs);
 *      takesOneArg.length; //=> 1
 *      // Only `n` arguments are passed to the wrapped function
 *      takesOneArg(1, 2); //=> [1, undefined]
 * @symb R.nAry(0, f)(a, b) = f()
 * @symb R.nAry(1, f)(a, b) = f(a)
 * @symb R.nAry(2, f)(a, b) = f(a, b)
 */
var nAry = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function nAry(n, fn) {
  switch (n) {
    case 0:
      return function () {
        return fn.call(this);
      };
    case 1:
      return function (a0) {
        return fn.call(this, a0);
      };
    case 2:
      return function (a0, a1) {
        return fn.call(this, a0, a1);
      };
    case 3:
      return function (a0, a1, a2) {
        return fn.call(this, a0, a1, a2);
      };
    case 4:
      return function (a0, a1, a2, a3) {
        return fn.call(this, a0, a1, a2, a3);
      };
    case 5:
      return function (a0, a1, a2, a3, a4) {
        return fn.call(this, a0, a1, a2, a3, a4);
      };
    case 6:
      return function (a0, a1, a2, a3, a4, a5) {
        return fn.call(this, a0, a1, a2, a3, a4, a5);
      };
    case 7:
      return function (a0, a1, a2, a3, a4, a5, a6) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
      };
    case 8:
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
      };
    case 9:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
      };
    case 10:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
      };
    default:
      throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
  }
});
/* harmony default export */ __webpack_exports__["default"] = (nAry);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/negate.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/negate.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Negates its argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Math
 * @sig Number -> Number
 * @param {Number} n
 * @return {Number}
 * @example
 *
 *      R.negate(42); //=> -42
 */
var negate = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function negate(n) {
  return -n;
});
/* harmony default export */ __webpack_exports__["default"] = (negate);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/none.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/none.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_complement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_complement */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_complement.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xany__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_xany */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xany.js");
/* harmony import */ var _any__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./any */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/any.js");






/**
 * Returns `true` if no elements of the list match the predicate, `false`
 * otherwise.
 *
 * Dispatches to the `any` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
 * @see R.all, R.any
 * @example
 *
 *      var isEven = n => n % 2 === 0;
 *      var isOdd = n => n % 2 === 1;
 *
 *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
 *      R.none(isOdd, [1, 3, 5, 7, 8, 11]); //=> false
 */
var none = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_internal_complement__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_2__["default"])(['any'], _internal_xany__WEBPACK_IMPORTED_MODULE_3__["default"], _any__WEBPACK_IMPORTED_MODULE_4__["default"])));
/* harmony default export */ __webpack_exports__["default"] = (none);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/not.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/not.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * A function that returns the `!` of its argument. It will return `true` when
 * passed false-y value, and `false` when passed a truth-y one.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig * -> Boolean
 * @param {*} a any value
 * @return {Boolean} the logical inverse of passed argument.
 * @see R.complement
 * @example
 *
 *      R.not(true); //=> false
 *      R.not(false); //=> true
 *      R.not(0); //=> true
 *      R.not(1); //=> false
 */
var not = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function not(a) {
  return !a;
});
/* harmony default export */ __webpack_exports__["default"] = (not);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nth.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nth.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isString.js");



/**
 * Returns the nth element of the given list or string. If n is negative the
 * element at index length + n is returned.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> a | Undefined
 * @sig Number -> String -> String
 * @param {Number} offset
 * @param {*} list
 * @return {*}
 * @example
 *
 *      var list = ['foo', 'bar', 'baz', 'quux'];
 *      R.nth(1, list); //=> 'bar'
 *      R.nth(-1, list); //=> 'quux'
 *      R.nth(-99, list); //=> undefined
 *
 *      R.nth(2, 'abc'); //=> 'c'
 *      R.nth(3, 'abc'); //=> ''
 * @symb R.nth(-1, [a, b, c]) = c
 * @symb R.nth(0, [a, b, c]) = a
 * @symb R.nth(1, [a, b, c]) = b
 */
var nth = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function nth(offset, list) {
  var idx = offset < 0 ? list.length + offset : offset;
  return Object(_internal_isString__WEBPACK_IMPORTED_MODULE_1__["default"])(list) ? list.charAt(idx) : list[idx];
});
/* harmony default export */ __webpack_exports__["default"] = (nth);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nthArg.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nthArg.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _nth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nth */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nth.js");




/**
 * Returns a function which returns its nth argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig Number -> *... -> *
 * @param {Number} n
 * @return {Function}
 * @example
 *
 *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
 *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
 * @symb R.nthArg(-1)(a, b, c) = c
 * @symb R.nthArg(0)(a, b, c) = a
 * @symb R.nthArg(1)(a, b, c) = b
 */
var nthArg = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function nthArg(n) {
  var arity = n < 0 ? 1 : n + 1;
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(arity, function () {
    return Object(_nth__WEBPACK_IMPORTED_MODULE_2__["default"])(n, arguments);
  });
});
/* harmony default export */ __webpack_exports__["default"] = (nthArg);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/o.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/o.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * `o` is a curried composition function that returns a unary function.
 * Like [`compose`](#compose), `o` performs right-to-left function composition.
 * Unlike [`compose`](#compose), the rightmost function passed to `o` will be
 * invoked with only one argument.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Function
 * @sig (b -> c) -> (a -> b) -> a -> c
 * @param {Function} f
 * @param {Function} g
 * @return {Function}
 * @see R.compose, R.pipe
 * @example
 *
 *      var classyGreeting = name => "The name's " + name.last + ", " + name.first + " " + name.last
 *      var yellGreeting = R.o(R.toUpper, classyGreeting);
 *      yellGreeting({first: 'James', last: 'Bond'}); //=> "THE NAME'S BOND, JAMES BOND"
 *
 *      R.o(R.multiply(10), R.add(10))(-4) //=> 60
 *
 * @symb R.o(f, g, x) = f(g(x))
 */
var o = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function o(f, g, x) {
  return f(g(x));
});
/* harmony default export */ __webpack_exports__["default"] = (o);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/objOf.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/objOf.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Creates an object containing a single key:value pair.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Object
 * @sig String -> a -> {String:a}
 * @param {String} key
 * @param {*} val
 * @return {Object}
 * @see R.pair
 * @example
 *
 *      var matchPhrases = R.compose(
 *        R.objOf('must'),
 *        R.map(R.objOf('match_phrase'))
 *      );
 *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
 */
var objOf = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function objOf(key, val) {
  var obj = {};
  obj[key] = val;
  return obj;
});
/* harmony default export */ __webpack_exports__["default"] = (objOf);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/of.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/of.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_of */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_of.js");



/**
 * Returns a singleton array containing the value provided.
 *
 * Note this `of` is different from the ES6 `of`; See
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Function
 * @sig a -> [a]
 * @param {*} x any value
 * @return {Array} An array wrapping `x`.
 * @example
 *
 *      R.of(null); //=> [null]
 *      R.of([42]); //=> [[42]]
 */
var of = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(_internal_of__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (of);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/omit.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/omit.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns a partial copy of an object omitting the keys specified.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [String] -> {String: *} -> {String: *}
 * @param {Array} names an array of String property names to omit from the new object
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with properties from `names` not on it.
 * @see R.pick
 * @example
 *
 *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
 */
var omit = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function omit(names, obj) {
  var result = {};
  var index = {};
  var idx = 0;
  var len = names.length;

  while (idx < len) {
    index[names[idx]] = 1;
    idx += 1;
  }

  for (var prop in obj) {
    if (!index.hasOwnProperty(prop)) {
      result[prop] = obj[prop];
    }
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (omit);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/once.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/once.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");



/**
 * Accepts a function `fn` and returns a function that guards invocation of
 * `fn` such that `fn` can only ever be called once, no matter how many times
 * the returned function is invoked. The first value calculated is returned in
 * subsequent invocations.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (a... -> b) -> (a... -> b)
 * @param {Function} fn The function to wrap in a call-only-once wrapper.
 * @return {Function} The wrapped function.
 * @example
 *
 *      var addOneOnce = R.once(x => x + 1);
 *      addOneOnce(10); //=> 11
 *      addOneOnce(addOneOnce(50)); //=> 11
 */
var once = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_1__["default"])(function once(fn) {
  var called = false;
  var result;
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(fn.length, function () {
    if (called) {
      return result;
    }
    called = true;
    result = fn.apply(this, arguments);
    return result;
  });
});
/* harmony default export */ __webpack_exports__["default"] = (once);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/or.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/or.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns `true` if one or both of its arguments are `true`. Returns `false`
 * if both arguments are `false`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig a -> b -> a | b
 * @param {Any} a
 * @param {Any} b
 * @return {Any} the first argument if truthy, otherwise the second argument.
 * @see R.either
 * @example
 *
 *      R.or(true, true); //=> true
 *      R.or(true, false); //=> true
 *      R.or(false, true); //=> true
 *      R.or(false, false); //=> false
 */
var or = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function or(a, b) {
  return a || b;
});
/* harmony default export */ __webpack_exports__["default"] = (or);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/over.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/over.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


// `Identity` is a functor that holds a single value, where `map` simply
// transforms the held value with the provided function.
var Identity = function (x) {
  return { value: x, map: function (f) {
      return Identity(f(x));
    } };
};

/**
 * Returns the result of "setting" the portion of the given data structure
 * focused by the given lens to the result of applying the given function to
 * the focused value.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Lens s a -> (a -> a) -> s -> s
 * @param {Lens} lens
 * @param {*} v
 * @param {*} x
 * @return {*}
 * @see R.prop, R.lensIndex, R.lensProp
 * @example
 *
 *      var headLens = R.lensIndex(0);
 *
 *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
 */
var over = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function over(lens, f, x) {
  // The value returned by the getter function is first transformed with `f`,
  // then set as the value of an `Identity`. This is then mapped over with the
  // setter function of the lens.
  return lens(function (y) {
    return Identity(f(y));
  })(x).value;
});
/* harmony default export */ __webpack_exports__["default"] = (over);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pair.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pair.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category List
 * @sig a -> b -> (a,b)
 * @param {*} fst
 * @param {*} snd
 * @return {Array}
 * @see R.objOf, R.of
 * @example
 *
 *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
 */
var pair = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function pair(fst, snd) {
  return [fst, snd];
});
/* harmony default export */ __webpack_exports__["default"] = (pair);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partial.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partial.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_createPartialApplicator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_createPartialApplicator */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_createPartialApplicator.js");



/**
 * Takes a function `f` and a list of arguments, and returns a function `g`.
 * When applied, `g` returns the result of applying `f` to the arguments
 * provided initially followed by the arguments provided to `g`.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
 * @param {Function} f
 * @param {Array} args
 * @return {Function}
 * @see R.partialRight
 * @example
 *
 *      var multiply2 = (a, b) => a * b;
 *      var double = R.partial(multiply2, [2]);
 *      double(2); //=> 4
 *
 *      var greet = (salutation, title, firstName, lastName) =>
 *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
 *
 *      var sayHello = R.partial(greet, ['Hello']);
 *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
 *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
 * @symb R.partial(f, [a, b])(c, d) = f(a, b, c, d)
 */
var partial = /*#__PURE__*/Object(_internal_createPartialApplicator__WEBPACK_IMPORTED_MODULE_1__["default"])(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (partial);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partialRight.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partialRight.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_createPartialApplicator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_createPartialApplicator */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_createPartialApplicator.js");
/* harmony import */ var _flip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flip */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flip.js");




/**
 * Takes a function `f` and a list of arguments, and returns a function `g`.
 * When applied, `g` returns the result of applying `f` to the arguments
 * provided to `g` followed by the arguments provided initially.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
 * @param {Function} f
 * @param {Array} args
 * @return {Function}
 * @see R.partial
 * @example
 *
 *      var greet = (salutation, title, firstName, lastName) =>
 *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
 *
 *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
 *
 *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
 * @symb R.partialRight(f, [a, b])(c, d) = f(c, d, a, b)
 */
var partialRight = /*#__PURE__*/Object(_internal_createPartialApplicator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_flip__WEBPACK_IMPORTED_MODULE_2__["default"])(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (partialRight);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partition.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partition.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/filter.js");
/* harmony import */ var _juxt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./juxt */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/juxt.js");
/* harmony import */ var _reject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reject */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reject.js");




/**
 * Takes a predicate and a list or other `Filterable` object and returns the
 * pair of filterable objects of the same type of elements which do and do not
 * satisfy, the predicate, respectively. Filterable objects include plain objects or any object
 * that has a filter method such as `Array`.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
 * @param {Function} pred A predicate to determine which side the element belongs to.
 * @param {Array} filterable the list (or other filterable) to partition.
 * @return {Array} An array, containing first the subset of elements that satisfy the
 *         predicate, and second the subset of elements that do not satisfy.
 * @see R.filter, R.reject
 * @example
 *
 *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
 *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
 *
 *      R.partition(R.contains('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
 *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
 */
var partition = /*#__PURE__*/Object(_juxt__WEBPACK_IMPORTED_MODULE_1__["default"])([_filter__WEBPACK_IMPORTED_MODULE_0__["default"], _reject__WEBPACK_IMPORTED_MODULE_2__["default"]]);
/* harmony default export */ __webpack_exports__["default"] = (partition);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Retrieve the value at a given path.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig [Idx] -> {a} -> a | Undefined
 * @param {Array} path The path to use.
 * @param {Object} obj The object to retrieve the nested property from.
 * @return {*} The data at `path`.
 * @see R.prop
 * @example
 *
 *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
 *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
 */
var path = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function path(paths, obj) {
  var val = obj;
  var idx = 0;
  while (idx < paths.length) {
    if (val == null) {
      return;
    }
    val = val[paths[idx]];
    idx += 1;
  }
  return val;
});
/* harmony default export */ __webpack_exports__["default"] = (path);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathEq.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathEq.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js");




/**
 * Determines whether a nested path on an object has a specific value, in
 * [`R.equals`](#equals) terms. Most likely used to filter a list.
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Relation
 * @typedefn Idx = String | Int
 * @sig [Idx] -> a -> {a} -> Boolean
 * @param {Array} path The path of the nested property to use
 * @param {*} val The value to compare the nested property with
 * @param {Object} obj The object to check the nested property in
 * @return {Boolean} `true` if the value equals the nested object property,
 *         `false` otherwise.
 * @example
 *
 *      var user1 = { address: { zipCode: 90210 } };
 *      var user2 = { address: { zipCode: 55555 } };
 *      var user3 = { name: 'Bob' };
 *      var users = [ user1, user2, user3 ];
 *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
 *      R.filter(isFamous, users); //=> [ user1 ]
 */
var pathEq = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function pathEq(_path, val, obj) {
  return Object(_equals__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_path__WEBPACK_IMPORTED_MODULE_2__["default"])(_path, obj), val);
});
/* harmony default export */ __webpack_exports__["default"] = (pathEq);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathOr.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathOr.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _defaultTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultTo */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/defaultTo.js");
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js");




/**
 * If the given, non-null object has a value at the given path, returns the
 * value at that path. Otherwise returns the provided default value.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig a -> [Idx] -> {a} -> a
 * @param {*} d The default value.
 * @param {Array} p The path to use.
 * @param {Object} obj The object to retrieve the nested property from.
 * @return {*} The data at `path` of the supplied object or the default value.
 * @example
 *
 *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
 *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
 */
var pathOr = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function pathOr(d, p, obj) {
  return Object(_defaultTo__WEBPACK_IMPORTED_MODULE_1__["default"])(d, Object(_path__WEBPACK_IMPORTED_MODULE_2__["default"])(p, obj));
});
/* harmony default export */ __webpack_exports__["default"] = (pathOr);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathSatisfies.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathSatisfies.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js");



/**
 * Returns `true` if the specified object property at given path satisfies the
 * given predicate; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Logic
 * @typedefn Idx = String | Int
 * @sig (a -> Boolean) -> [Idx] -> {a} -> Boolean
 * @param {Function} pred
 * @param {Array} propPath
 * @param {*} obj
 * @return {Boolean}
 * @see R.propSatisfies, R.path
 * @example
 *
 *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
 */
var pathSatisfies = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function pathSatisfies(pred, propPath, obj) {
  return propPath.length > 0 && pred(Object(_path__WEBPACK_IMPORTED_MODULE_1__["default"])(propPath, obj));
});
/* harmony default export */ __webpack_exports__["default"] = (pathSatisfies);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pick.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pick.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns a partial copy of an object containing only the keys specified. If
 * the key does not exist, the property is ignored.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [k] -> {k: v} -> {k: v}
 * @param {Array} names an array of String property names to copy onto a new object
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with only properties from `names` on it.
 * @see R.omit, R.props
 * @example
 *
 *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
 *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
 */
var pick = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function pick(names, obj) {
  var result = {};
  var idx = 0;
  while (idx < names.length) {
    if (names[idx] in obj) {
      result[names[idx]] = obj[names[idx]];
    }
    idx += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (pick);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pickAll.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pickAll.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Similar to `pick` except that this one includes a `key: undefined` pair for
 * properties that don't exist.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [k] -> {k: v} -> {k: v}
 * @param {Array} names an array of String property names to copy onto a new object
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with only properties from `names` on it.
 * @see R.pick
 * @example
 *
 *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
 *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
 */
var pickAll = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function pickAll(names, obj) {
  var result = {};
  var idx = 0;
  var len = names.length;
  while (idx < len) {
    var name = names[idx];
    result[name] = obj[name];
    idx += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (pickAll);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pickBy.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pickBy.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns a partial copy of an object containing only the keys that satisfy
 * the supplied predicate.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @sig ((v, k) -> Boolean) -> {k: v} -> {k: v}
 * @param {Function} pred A predicate to determine whether or not a key
 *        should be included on the output object.
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with only properties that satisfy `pred`
 *         on it.
 * @see R.pick, R.filter
 * @example
 *
 *      var isUpperCase = (val, key) => key.toUpperCase() === key;
 *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
 */
var pickBy = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function pickBy(test, obj) {
  var result = {};
  for (var prop in obj) {
    if (test(obj[prop], prop, obj)) {
      result[prop] = obj[prop];
    }
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (pickBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipe.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipe.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pipe; });
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_pipe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_pipe */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_pipe.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");
/* harmony import */ var _tail__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tail */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tail.js");





/**
 * Performs left-to-right function composition. The leftmost function may have
 * any arity; the remaining functions must be unary.
 *
 * In some libraries this function is named `sequence`.
 *
 * **Note:** The result of pipe is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
 * @param {...Function} functions
 * @return {Function}
 * @see R.compose
 * @example
 *
 *      var f = R.pipe(Math.pow, R.negate, R.inc);
 *
 *      f(3, 4); // -(3^4) + 1
 * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
 */
function pipe() {
  if (arguments.length === 0) {
    throw new Error('pipe requires at least one argument');
  }
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(arguments[0].length, Object(_reduce__WEBPACK_IMPORTED_MODULE_2__["default"])(_internal_pipe__WEBPACK_IMPORTED_MODULE_1__["default"], arguments[0], Object(_tail__WEBPACK_IMPORTED_MODULE_3__["default"])(arguments)));
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipeK.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipeK.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pipeK; });
/* harmony import */ var _composeK__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./composeK */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/composeK.js");
/* harmony import */ var _reverse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reverse */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reverse.js");



/**
 * Returns the left-to-right Kleisli composition of the provided functions,
 * each of which must return a value of a type supported by [`chain`](#chain).
 *
 * `R.pipeK(f, g, h)` is equivalent to `R.pipe(f, R.chain(g), R.chain(h))`.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Function
 * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (a -> m z)
 * @param {...Function}
 * @return {Function}
 * @see R.composeK
 * @example
 *
 *      //  parseJson :: String -> Maybe *
 *      //  get :: String -> Object -> Maybe *
 *
 *      //  getStateCode :: Maybe String -> Maybe String
 *      var getStateCode = R.pipeK(
 *        parseJson,
 *        get('user'),
 *        get('address'),
 *        get('state'),
 *        R.compose(Maybe.of, R.toUpper)
 *      );
 *
 *      getStateCode('{"user":{"address":{"state":"ny"}}}');
 *      //=> Just('NY')
 *      getStateCode('[Invalid JSON]');
 *      //=> Nothing()
 * @symb R.pipeK(f, g, h)(a) = R.chain(h, R.chain(g, f(a)))
 */
function pipeK() {
  if (arguments.length === 0) {
    throw new Error('pipeK requires at least one argument');
  }
  return _composeK__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, Object(_reverse__WEBPACK_IMPORTED_MODULE_1__["default"])(arguments));
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipeP.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipeP.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pipeP; });
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_pipeP__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_pipeP */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_pipeP.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");
/* harmony import */ var _tail__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tail */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tail.js");





/**
 * Performs left-to-right composition of one or more Promise-returning
 * functions. The leftmost function may have any arity; the remaining functions
 * must be unary.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
 * @param {...Function} functions
 * @return {Function}
 * @see R.composeP
 * @example
 *
 *      //  followersForUser :: String -> Promise [User]
 *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
 */
function pipeP() {
  if (arguments.length === 0) {
    throw new Error('pipeP requires at least one argument');
  }
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(arguments[0].length, Object(_reduce__WEBPACK_IMPORTED_MODULE_2__["default"])(_internal_pipeP__WEBPACK_IMPORTED_MODULE_1__["default"], arguments[0], Object(_tail__WEBPACK_IMPORTED_MODULE_3__["default"])(arguments)));
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pluck.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pluck.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");
/* harmony import */ var _prop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./prop */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prop.js");




/**
 * Returns a new list by plucking the same named property off all objects in
 * the list supplied.
 *
 * `pluck` will work on
 * any [functor](https://github.com/fantasyland/fantasy-land#functor) in
 * addition to arrays, as it is equivalent to `R.map(R.prop(k), f)`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Functor f => k -> f {k: v} -> f v
 * @param {Number|String} key The key name to pluck off of each object.
 * @param {Array} f The array or functor to consider.
 * @return {Array} The list of values for the given key.
 * @see R.props
 * @example
 *
 *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
 *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
 *      R.pluck('val', {a: {val: 3}, b: {val: 5}}); //=> {a: 3, b: 5}
 * @symb R.pluck('x', [{x: 1, y: 2}, {x: 3, y: 4}, {x: 5, y: 6}]) = [1, 3, 5]
 * @symb R.pluck(0, [[1, 2], [3, 4], [5, 6]]) = [1, 3, 5]
 */
var pluck = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function pluck(p, list) {
  return Object(_map__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_prop__WEBPACK_IMPORTED_MODULE_2__["default"])(p), list);
});
/* harmony default export */ __webpack_exports__["default"] = (pluck);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prepend.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prepend.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Returns a new list with the given element at the front, followed by the
 * contents of the list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> [a]
 * @param {*} el The item to add to the head of the output list.
 * @param {Array} list The array to add to the tail of the output list.
 * @return {Array} A new array.
 * @see R.append
 * @example
 *
 *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
 */
var prepend = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function prepend(el, list) {
  return Object(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"])([el], list);
});
/* harmony default export */ __webpack_exports__["default"] = (prepend);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/product.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/product.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _multiply__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./multiply */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/multiply.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");



/**
 * Multiplies together all the elements of a list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list An array of numbers
 * @return {Number} The product of all the numbers in the list.
 * @see R.reduce
 * @example
 *
 *      R.product([2,4,6,8,100,1]); //=> 38400
 */
var product = /*#__PURE__*/Object(_reduce__WEBPACK_IMPORTED_MODULE_1__["default"])(_multiply__WEBPACK_IMPORTED_MODULE_0__["default"], 1);
/* harmony default export */ __webpack_exports__["default"] = (product);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/project.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/project.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_map.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./identity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identity.js");
/* harmony import */ var _pickAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pickAll */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pickAll.js");
/* harmony import */ var _useWith__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/useWith.js");





/**
 * Reasonable analog to SQL `select` statement.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @category Relation
 * @sig [k] -> [{k: v}] -> [{k: v}]
 * @param {Array} props The property names to project
 * @param {Array} objs The objects to query
 * @return {Array} An array of objects with just the `props` properties.
 * @example
 *
 *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
 *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
 *      var kids = [abby, fred];
 *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
 */
var project = /*#__PURE__*/Object(_useWith__WEBPACK_IMPORTED_MODULE_3__["default"])(_internal_map__WEBPACK_IMPORTED_MODULE_0__["default"], [_pickAll__WEBPACK_IMPORTED_MODULE_2__["default"], _identity__WEBPACK_IMPORTED_MODULE_1__["default"]]); // passing `identity` gives correct arity
/* harmony default export */ __webpack_exports__["default"] = (project);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prop.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prop.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js");



/**
 * Returns a function that when supplied an object returns the indicated
 * property of that object, if it exists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig s -> {s: a} -> a | Undefined
 * @param {String} p The property name
 * @param {Object} obj The object to query
 * @return {*} The value at `obj.p`.
 * @see R.path
 * @example
 *
 *      R.prop('x', {x: 100}); //=> 100
 *      R.prop('x', {}); //=> undefined
 */

var prop = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function prop(p, obj) {
  return Object(_path__WEBPACK_IMPORTED_MODULE_1__["default"])([p], obj);
});
/* harmony default export */ __webpack_exports__["default"] = (prop);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propEq.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propEq.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");



/**
 * Returns `true` if the specified object property is equal, in
 * [`R.equals`](#equals) terms, to the given value; `false` otherwise.
 * You can test multiple properties with [`R.where`](#where).
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig String -> a -> Object -> Boolean
 * @param {String} name
 * @param {*} val
 * @param {*} obj
 * @return {Boolean}
 * @see R.whereEq, R.propSatisfies, R.equals
 * @example
 *
 *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
 *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
 *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
 *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
 *      var kids = [abby, fred, rusty, alois];
 *      var hasBrownHair = R.propEq('hair', 'brown');
 *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
 */
var propEq = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function propEq(name, val, obj) {
  return Object(_equals__WEBPACK_IMPORTED_MODULE_1__["default"])(val, obj[name]);
});
/* harmony default export */ __webpack_exports__["default"] = (propEq);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propIs.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propIs.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/is.js");



/**
 * Returns `true` if the specified object property is of the given type;
 * `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Type
 * @sig Type -> String -> Object -> Boolean
 * @param {Function} type
 * @param {String} name
 * @param {*} obj
 * @return {Boolean}
 * @see R.is, R.propSatisfies
 * @example
 *
 *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
 *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
 *      R.propIs(Number, 'x', {});            //=> false
 */
var propIs = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function propIs(type, name, obj) {
  return Object(_is__WEBPACK_IMPORTED_MODULE_1__["default"])(type, obj[name]);
});
/* harmony default export */ __webpack_exports__["default"] = (propIs);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propOr.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propOr.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");



/**
 * If the given, non-null object has an own property with the specified name,
 * returns the value of that property. Otherwise returns the provided default
 * value.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Object
 * @sig a -> String -> Object -> a
 * @param {*} val The default value.
 * @param {String} p The name of the property to return.
 * @param {Object} obj The object to query.
 * @return {*} The value of given property of the supplied object or the default value.
 * @example
 *
 *      var alice = {
 *        name: 'ALICE',
 *        age: 101
 *      };
 *      var favorite = R.prop('favoriteLibrary');
 *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
 *
 *      favorite(alice);  //=> undefined
 *      favoriteWithDefault(alice);  //=> 'Ramda'
 */
var propOr = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function propOr(val, p, obj) {
  return obj != null && Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(p, obj) ? obj[p] : val;
});
/* harmony default export */ __webpack_exports__["default"] = (propOr);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propSatisfies.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propSatisfies.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Returns `true` if the specified object property satisfies the given
 * predicate; `false` otherwise. You can test multiple properties with
 * [`R.where`](#where).
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Logic
 * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
 * @param {Function} pred
 * @param {String} name
 * @param {*} obj
 * @return {Boolean}
 * @see R.where, R.propEq, R.propIs
 * @example
 *
 *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
 */
var propSatisfies = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function propSatisfies(pred, name, obj) {
  return pred(obj[name]);
});
/* harmony default export */ __webpack_exports__["default"] = (propSatisfies);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/props.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/props.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Acts as multiple `prop`: array of keys in, array of values out. Preserves
 * order.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [k] -> {k: v} -> [v]
 * @param {Array} ps The property names to fetch
 * @param {Object} obj The object to query
 * @return {Array} The corresponding values or partially applied function.
 * @example
 *
 *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
 *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
 *
 *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
 *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
 */
var props = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function props(ps, obj) {
  var len = ps.length;
  var out = [];
  var idx = 0;

  while (idx < len) {
    out[idx] = obj[ps[idx]];
    idx += 1;
  }

  return out;
});
/* harmony default export */ __webpack_exports__["default"] = (props);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/range.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/range.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isNumber */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isNumber.js");



/**
 * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> Number -> [Number]
 * @param {Number} from The first number in the list.
 * @param {Number} to One more than the last number in the list.
 * @return {Array} The list of numbers in tthe set `[a, b)`.
 * @example
 *
 *      R.range(1, 5);    //=> [1, 2, 3, 4]
 *      R.range(50, 53);  //=> [50, 51, 52]
 */
var range = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function range(from, to) {
  if (!(Object(_internal_isNumber__WEBPACK_IMPORTED_MODULE_1__["default"])(from) && Object(_internal_isNumber__WEBPACK_IMPORTED_MODULE_1__["default"])(to))) {
    throw new TypeError('Both arguments to range must be numbers');
  }
  var result = [];
  var n = from;
  while (n < to) {
    result.push(n);
    n += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (range);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");



/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It may use
 * [`R.reduced`](#reduced) to shortcut the iteration.
 *
 * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
 * is *(value, acc)*.
 *
 * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduce` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
 *
 * Dispatches to the `reduce` method of the third argument, if present. When
 * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
 * shortcuting, as this is not implemented by `reduce`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduced, R.addIndex, R.reduceRight
 * @example
 *
 *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
 *      //          -               -10
 *      //         / \              / \
 *      //        -   4           -6   4
 *      //       / \              / \
 *      //      -   3   ==>     -3   3
 *      //     / \              / \
 *      //    -   2           -1   2
 *      //   / \              / \
 *      //  0   1            0   1
 *
 * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
 */
var reduce = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(_internal_reduce__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (reduce);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceBy.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceBy.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curryN__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curryN.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _internal_xreduceBy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/_xreduceBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xreduceBy.js");






/**
 * Groups the elements of the list according to the result of calling
 * the String-returning function `keyFn` on each element and reduces the elements
 * of each group to a single value via the reducer function `valueFn`.
 *
 * This function is basically a more general [`groupBy`](#groupBy) function.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category List
 * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
 * @param {Function} valueFn The function that reduces the elements of each group to a single
 *        value. Receives two values, accumulator for a particular group and the current element.
 * @param {*} acc The (initial) accumulator value for each group.
 * @param {Function} keyFn The function that maps the list's element into a key.
 * @param {Array} list The array to group.
 * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
 *         `valueFn` for elements which produced that key when passed to `keyFn`.
 * @see R.groupBy, R.reduce
 * @example
 *
 *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);
 *      var namesByGrade = reduceToNamesBy(function(student) {
 *        var score = student.score;
 *        return score < 65 ? 'F' :
 *               score < 70 ? 'D' :
 *               score < 80 ? 'C' :
 *               score < 90 ? 'B' : 'A';
 *      });
 *      var students = [{name: 'Lucy', score: 92},
 *                      {name: 'Drew', score: 85},
 *                      // ...
 *                      {name: 'Bart', score: 62}];
 *      namesByGrade(students);
 *      // {
 *      //   'A': ['Lucy'],
 *      //   'B': ['Drew']
 *      //   // ...,
 *      //   'F': ['Bart']
 *      // }
 */
var reduceBy = /*#__PURE__*/Object(_internal_curryN__WEBPACK_IMPORTED_MODULE_0__["default"])(4, [], /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xreduceBy__WEBPACK_IMPORTED_MODULE_4__["default"], function reduceBy(valueFn, valueAcc, keyFn, list) {
  return Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_3__["default"])(function (acc, elt) {
    var key = keyFn(elt);
    acc[key] = valueFn(Object(_internal_has__WEBPACK_IMPORTED_MODULE_2__["default"])(key, acc) ? acc[key] : valueAcc, elt);
    return acc;
  }, {}, list);
}));
/* harmony default export */ __webpack_exports__["default"] = (reduceBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceRight.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceRight.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * Similar to [`reduce`](#reduce), except moves through the input list from the
 * right to the left.
 *
 * The iterator function receives two values: *(value, acc)*, while the arguments'
 * order of `reduce`'s iterator function is *(acc, value)*.
 *
 * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduceRight` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> b) -> b -> [a] -> b
 * @param {Function} fn The iterator function. Receives two values, the current element from the array
 *        and the accumulator.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduce, R.addIndex
 * @example
 *
 *      R.reduceRight(R.subtract, 0, [1, 2, 3, 4]) // => (1 - (2 - (3 - (4 - 0)))) = -2
 *      //    -               -2
 *      //   / \              / \
 *      //  1   -            1   3
 *      //     / \              / \
 *      //    2   -     ==>    2  -1
 *      //       / \              / \
 *      //      3   -            3   4
 *      //         / \              / \
 *      //        4   0            4   0
 *
 * @symb R.reduceRight(f, a, [b, c, d]) = f(b, f(c, f(d, a)))
 */
var reduceRight = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function reduceRight(fn, acc, list) {
  var idx = list.length - 1;
  while (idx >= 0) {
    acc = fn(list[idx], acc);
    idx -= 1;
  }
  return acc;
});
/* harmony default export */ __webpack_exports__["default"] = (reduceRight);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceWhile.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceWhile.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curryN__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curryN.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _internal_reduced__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");




/**
 * Like [`reduce`](#reduce), `reduceWhile` returns a single item by iterating
 * through the list, successively calling the iterator function. `reduceWhile`
 * also takes a predicate that is evaluated before each step. If the predicate
 * returns `false`, it "short-circuits" the iteration and returns the current
 * value of the accumulator.
 *
 * @func
 * @memberOf R
 * @since v0.22.0
 * @category List
 * @sig ((a, b) -> Boolean) -> ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} pred The predicate. It is passed the accumulator and the
 *        current element.
 * @param {Function} fn The iterator function. Receives two values, the
 *        accumulator and the current element.
 * @param {*} a The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduce, R.reduced
 * @example
 *
 *      var isOdd = (acc, x) => x % 2 === 1;
 *      var xs = [1, 3, 5, 60, 777, 800];
 *      R.reduceWhile(isOdd, R.add, 0, xs); //=> 9
 *
 *      var ys = [2, 4, 6]
 *      R.reduceWhile(isOdd, R.add, 111, ys); //=> 111
 */
var reduceWhile = /*#__PURE__*/Object(_internal_curryN__WEBPACK_IMPORTED_MODULE_0__["default"])(4, [], function _reduceWhile(pred, fn, a, list) {
  return Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_1__["default"])(function (acc, x) {
    return pred(acc, x) ? fn(acc, x) : Object(_internal_reduced__WEBPACK_IMPORTED_MODULE_2__["default"])(acc);
  }, a, list);
});
/* harmony default export */ __webpack_exports__["default"] = (reduceWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduced.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduced.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_reduced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");



/**
 * Returns a value wrapped to indicate that it is the final value of the reduce
 * and transduce functions. The returned value should be considered a black
 * box: the internal structure is not guaranteed to be stable.
 *
 * Note: this optimization is unavailable to functions not explicitly listed
 * above. For instance, it is not currently supported by
 * [`reduceRight`](#reduceRight).
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category List
 * @sig a -> *
 * @param {*} x The final value of the reduce.
 * @return {*} The wrapped value.
 * @see R.reduce, R.transduce
 * @example
 *
 *     R.reduce(
 *       (acc, item) => item > 3 ? R.reduced(acc) : acc.concat(item),
 *       [],
 *       [1, 2, 3, 4, 5]) // [1, 2, 3]
 */
var reduced = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(_internal_reduced__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (reduced);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reject.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reject.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_complement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_complement */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_complement.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/filter.js");




/**
 * The complement of [`filter`](#filter).
 *
 * Acts as a transducer if a transformer is given in list position. Filterable
 * objects include plain objects or any object that has a filter method such
 * as `Array`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array}
 * @see R.filter, R.transduce, R.addIndex
 * @example
 *
 *      var isOdd = (n) => n % 2 === 1;
 *
 *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */
var reject = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function reject(pred, filterable) {
  return Object(_filter__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_internal_complement__WEBPACK_IMPORTED_MODULE_0__["default"])(pred), filterable);
});
/* harmony default export */ __webpack_exports__["default"] = (reject);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/remove.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/remove.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Removes the sub-list of `list` starting at index `start` and containing
 * `count` elements. _Note that this is not destructive_: it returns a copy of
 * the list with the changes.
 * <small>No lists have been harmed in the application of this function.</small>
 *
 * @func
 * @memberOf R
 * @since v0.2.2
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @param {Number} start The position to start removing elements
 * @param {Number} count The number of elements to remove
 * @param {Array} list The list to remove from
 * @return {Array} A new Array with `count` elements from `start` removed.
 * @example
 *
 *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
 */
var remove = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function remove(start, count, list) {
  var result = Array.prototype.slice.call(list, 0);
  result.splice(start, count);
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (remove);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/repeat.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/repeat.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _always__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./always */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js");
/* harmony import */ var _times__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./times */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/times.js");




/**
 * Returns a fixed list of size `n` containing a specified identical value.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig a -> n -> [a]
 * @param {*} value The value to repeat.
 * @param {Number} n The desired size of the output list.
 * @return {Array} A new array containing `n` `value`s.
 * @see R.times
 * @example
 *
 *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
 *
 *      var obj = {};
 *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
 *      repeatedObjs[0] === repeatedObjs[1]; //=> true
 * @symb R.repeat(a, 0) = []
 * @symb R.repeat(a, 1) = [a]
 * @symb R.repeat(a, 2) = [a, a]
 */
var repeat = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function repeat(value, n) {
  return Object(_times__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_always__WEBPACK_IMPORTED_MODULE_1__["default"])(value), n);
});
/* harmony default export */ __webpack_exports__["default"] = (repeat);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/replace.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/replace.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Replace a substring or regex match in a string with a replacement.
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category String
 * @sig RegExp|String -> String -> String -> String
 * @param {RegExp|String} pattern A regular expression or a substring to match.
 * @param {String} replacement The string to replace the matches with.
 * @param {String} str The String to do the search and replacement in.
 * @return {String} The result.
 * @example
 *
 *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
 *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
 *
 *      // Use the "g" (global) flag to replace all occurrences:
 *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
 */
var replace = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function replace(regex, replacement, str) {
  return str.replace(regex, replacement);
});
/* harmony default export */ __webpack_exports__["default"] = (replace);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reverse.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reverse.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_isString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isString.js");



/**
 * Returns a new list or string with the elements or characters in reverse
 * order.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {Array|String} list
 * @return {Array|String}
 * @example
 *
 *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
 *      R.reverse([1, 2]);     //=> [2, 1]
 *      R.reverse([1]);        //=> [1]
 *      R.reverse([]);         //=> []
 *
 *      R.reverse('abc');      //=> 'cba'
 *      R.reverse('ab');       //=> 'ba'
 *      R.reverse('a');        //=> 'a'
 *      R.reverse('');         //=> ''
 */
var reverse = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function reverse(list) {
  return Object(_internal_isString__WEBPACK_IMPORTED_MODULE_1__["default"])(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();
});
/* harmony default export */ __webpack_exports__["default"] = (reverse);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/scan.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/scan.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Scan is similar to [`reduce`](#reduce), but returns a list of successively
 * reduced values from the left
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig ((a, b) -> a) -> a -> [b] -> [a]
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {Array} A list of all intermediately reduced values.
 * @see R.reduce
 * @example
 *
 *      var numbers = [1, 2, 3, 4];
 *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
 * @symb R.scan(f, a, [b, c]) = [a, f(a, b), f(f(a, b), c)]
 */
var scan = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function scan(fn, acc, list) {
  var idx = 0;
  var len = list.length;
  var result = [acc];
  while (idx < len) {
    acc = fn(acc, list[idx]);
    result[idx + 1] = acc;
    idx += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (scan);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sequence.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sequence.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _ap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ap.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");
/* harmony import */ var _prepend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./prepend */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prepend.js");
/* harmony import */ var _reduceRight__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reduceRight */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceRight.js");






/**
 * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
 * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
 * Applicative of Traversable.
 *
 * Dispatches to the `sequence` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
 * @param {Function} of
 * @param {*} traversable
 * @return {*}
 * @see R.traverse
 * @example
 *
 *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
 *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
 *
 *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
 *      R.sequence(R.of, Nothing());       //=> [Nothing()]
 */
var sequence = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function sequence(of, traversable) {
  return typeof traversable.sequence === 'function' ? traversable.sequence(of) : Object(_reduceRight__WEBPACK_IMPORTED_MODULE_4__["default"])(function (x, acc) {
    return Object(_ap__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_map__WEBPACK_IMPORTED_MODULE_2__["default"])(_prepend__WEBPACK_IMPORTED_MODULE_3__["default"], x), acc);
  }, of([]), traversable);
});
/* harmony default export */ __webpack_exports__["default"] = (sequence);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/set.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/set.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _always__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./always */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js");
/* harmony import */ var _over__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./over */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/over.js");




/**
 * Returns the result of "setting" the portion of the given data structure
 * focused by the given lens to the given value.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Lens s a -> a -> s -> s
 * @param {Lens} lens
 * @param {*} v
 * @param {*} x
 * @return {*}
 * @see R.prop, R.lensIndex, R.lensProp
 * @example
 *
 *      var xLens = R.lensProp('x');
 *
 *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
 *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
 */
var set = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function set(lens, v, x) {
  return Object(_over__WEBPACK_IMPORTED_MODULE_2__["default"])(lens, Object(_always__WEBPACK_IMPORTED_MODULE_1__["default"])(v), x);
});
/* harmony default export */ __webpack_exports__["default"] = (set);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_checkForMethod */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_checkForMethod.js");
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");



/**
 * Returns the elements of the given list or string (or object with a `slice`
 * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
 *
 * Dispatches to the `slice` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @sig Number -> Number -> String -> String
 * @param {Number} fromIndex The start index (inclusive).
 * @param {Number} toIndex The end index (exclusive).
 * @param {*} list
 * @return {*}
 * @example
 *
 *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
 *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
 *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
 *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
 *      R.slice(0, 3, 'ramda');                     //=> 'ram'
 */
var slice = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__["default"])('slice', function slice(fromIndex, toIndex, list) {
  return Array.prototype.slice.call(list, fromIndex, toIndex);
}));
/* harmony default export */ __webpack_exports__["default"] = (slice);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sort.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sort.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns a copy of the list, sorted according to the comparator function,
 * which should accept two values at a time and return a negative number if the
 * first value is smaller, a positive number if it's larger, and zero if they
 * are equal. Please note that this is a **copy** of the list. It does not
 * modify the original.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, a) -> Number) -> [a] -> [a]
 * @param {Function} comparator A sorting function :: a -> b -> Int
 * @param {Array} list The list to sort
 * @return {Array} a new array with its elements sorted by the comparator function.
 * @example
 *
 *      var diff = function(a, b) { return a - b; };
 *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
 */
var sort = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function sort(comparator, list) {
  return Array.prototype.slice.call(list, 0).sort(comparator);
});
/* harmony default export */ __webpack_exports__["default"] = (sort);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sortBy.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sortBy.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Sorts the list according to the supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord b => (a -> b) -> [a] -> [a]
 * @param {Function} fn
 * @param {Array} list The list to sort.
 * @return {Array} A new list sorted by the keys generated by `fn`.
 * @example
 *
 *      var sortByFirstItem = R.sortBy(R.prop(0));
 *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
 *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
 *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
 *      var alice = {
 *        name: 'ALICE',
 *        age: 101
 *      };
 *      var bob = {
 *        name: 'Bob',
 *        age: -10
 *      };
 *      var clara = {
 *        name: 'clara',
 *        age: 314.159
 *      };
 *      var people = [clara, bob, alice];
 *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
 */
var sortBy = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function sortBy(fn, list) {
  return Array.prototype.slice.call(list, 0).sort(function (a, b) {
    var aa = fn(a);
    var bb = fn(b);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });
});
/* harmony default export */ __webpack_exports__["default"] = (sortBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sortWith.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sortWith.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Sorts a list according to a list of comparators.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Relation
 * @sig [(a, a) -> Number] -> [a] -> [a]
 * @param {Array} functions A list of comparator functions.
 * @param {Array} list The list to sort.
 * @return {Array} A new list sorted according to the comarator functions.
 * @example
 *
 *      var alice = {
 *        name: 'alice',
 *        age: 40
 *      };
 *      var bob = {
 *        name: 'bob',
 *        age: 30
 *      };
 *      var clara = {
 *        name: 'clara',
 *        age: 40
 *      };
 *      var people = [clara, bob, alice];
 *      var ageNameSort = R.sortWith([
 *        R.descend(R.prop('age')),
 *        R.ascend(R.prop('name'))
 *      ]);
 *      ageNameSort(people); //=> [alice, clara, bob]
 */
var sortWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function sortWith(fns, list) {
  return Array.prototype.slice.call(list, 0).sort(function (a, b) {
    var result = 0;
    var i = 0;
    while (result === 0 && i < fns.length) {
      result = fns[i](a, b);
      i += 1;
    }
    return result;
  });
});
/* harmony default export */ __webpack_exports__["default"] = (sortWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/split.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/split.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _invoker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invoker */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invoker.js");


/**
 * Splits a string into an array of strings based on the given
 * separator.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category String
 * @sig (String | RegExp) -> String -> [String]
 * @param {String|RegExp} sep The pattern.
 * @param {String} str The string to separate into an array.
 * @return {Array} The array of strings from `str` separated by `str`.
 * @see R.join
 * @example
 *
 *      var pathComponents = R.split('/');
 *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
 *
 *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
 */
var split = /*#__PURE__*/Object(_invoker__WEBPACK_IMPORTED_MODULE_0__["default"])(1, 'split');
/* harmony default export */ __webpack_exports__["default"] = (split);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitAt.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitAt.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _length__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./length */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/length.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");




/**
 * Splits a given list or string at a given index.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig Number -> [a] -> [[a], [a]]
 * @sig Number -> String -> [String, String]
 * @param {Number} index The index where the array/string is split.
 * @param {Array|String} array The array/string to be split.
 * @return {Array}
 * @example
 *
 *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
 *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
 *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
 */
var splitAt = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function splitAt(index, array) {
  return [Object(_slice__WEBPACK_IMPORTED_MODULE_2__["default"])(0, index, array), Object(_slice__WEBPACK_IMPORTED_MODULE_2__["default"])(index, Object(_length__WEBPACK_IMPORTED_MODULE_1__["default"])(array), array)];
});
/* harmony default export */ __webpack_exports__["default"] = (splitAt);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitEvery.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitEvery.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");



/**
 * Splits a collection into slices of the specified length.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [[a]]
 * @sig Number -> String -> [String]
 * @param {Number} n
 * @param {Array} list
 * @return {Array}
 * @example
 *
 *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
 *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
 */
var splitEvery = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function splitEvery(n, list) {
  if (n <= 0) {
    throw new Error('First argument to splitEvery must be a positive integer');
  }
  var result = [];
  var idx = 0;
  while (idx < list.length) {
    result.push(Object(_slice__WEBPACK_IMPORTED_MODULE_1__["default"])(idx, idx += n, list));
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (splitEvery);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitWhen.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitWhen.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Takes a list and a predicate and returns a pair of lists with the following properties:
 *
 *  - the result of concatenating the two output lists is equivalent to the input list;
 *  - none of the elements of the first output list satisfies the predicate; and
 *  - if the second output list is non-empty, its first element satisfies the predicate.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [[a], [a]]
 * @param {Function} pred The predicate that determines where the array is split.
 * @param {Array} list The array to be split.
 * @return {Array}
 * @example
 *
 *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
 */
var splitWhen = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function splitWhen(pred, list) {
  var idx = 0;
  var len = list.length;
  var prefix = [];

  while (idx < len && !pred(list[idx])) {
    prefix.push(list[idx]);
    idx += 1;
  }

  return [prefix, Array.prototype.slice.call(list, idx)];
});
/* harmony default export */ __webpack_exports__["default"] = (splitWhen);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/startsWith.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/startsWith.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");
/* harmony import */ var _take__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./take */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/take.js");




/**
 * Checks if a list starts with the provided values
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category List
 * @sig [a] -> Boolean
 * @sig String -> Boolean
 * @param {*} prefix
 * @param {*} list
 * @return {Boolean}
 * @example
 *
 *      R.startsWith('a', 'abc')                //=> true
 *      R.startsWith('b', 'abc')                //=> false
 *      R.startsWith(['a'], ['a', 'b', 'c'])    //=> true
 *      R.startsWith(['b'], ['a', 'b', 'c'])    //=> false
 */
var startsWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function (prefix, list) {
  return Object(_equals__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_take__WEBPACK_IMPORTED_MODULE_2__["default"])(prefix.length, list), prefix);
});
/* harmony default export */ __webpack_exports__["default"] = (startsWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/subtract.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/subtract.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Subtracts its second argument from its first argument.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The first value.
 * @param {Number} b The second value.
 * @return {Number} The result of `a - b`.
 * @see R.add
 * @example
 *
 *      R.subtract(10, 8); //=> 2
 *
 *      var minus5 = R.subtract(R.__, 5);
 *      minus5(17); //=> 12
 *
 *      var complementaryAngle = R.subtract(90);
 *      complementaryAngle(30); //=> 60
 *      complementaryAngle(72); //=> 18
 */
var subtract = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function subtract(a, b) {
  return Number(a) - Number(b);
});
/* harmony default export */ __webpack_exports__["default"] = (subtract);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sum.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sum.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _add__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/add.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");



/**
 * Adds together all the elements of a list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list An array of numbers
 * @return {Number} The sum of all the numbers in the list.
 * @see R.reduce
 * @example
 *
 *      R.sum([2,4,6,8,100,1]); //=> 121
 */
var sum = /*#__PURE__*/Object(_reduce__WEBPACK_IMPORTED_MODULE_1__["default"])(_add__WEBPACK_IMPORTED_MODULE_0__["default"], 0);
/* harmony default export */ __webpack_exports__["default"] = (sum);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/symmetricDifference.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/symmetricDifference.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _concat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/concat.js");
/* harmony import */ var _difference__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./difference */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/difference.js");




/**
 * Finds the set (i.e. no duplicates) of all elements contained in the first or
 * second list, but not both.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` or `list2`, but not both.
 * @see R.symmetricDifferenceWith, R.difference, R.differenceWith
 * @example
 *
 *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
 *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
 */
var symmetricDifference = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function symmetricDifference(list1, list2) {
  return Object(_concat__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_difference__WEBPACK_IMPORTED_MODULE_2__["default"])(list1, list2), Object(_difference__WEBPACK_IMPORTED_MODULE_2__["default"])(list2, list1));
});
/* harmony default export */ __webpack_exports__["default"] = (symmetricDifference);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/symmetricDifferenceWith.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/symmetricDifferenceWith.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _concat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/concat.js");
/* harmony import */ var _differenceWith__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./differenceWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/differenceWith.js");




/**
 * Finds the set (i.e. no duplicates) of all elements contained in the first or
 * second list, but not both. Duplication is determined according to the value
 * returned by applying the supplied predicate to two list elements.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Relation
 * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` or `list2`, but not both.
 * @see R.symmetricDifference, R.difference, R.differenceWith
 * @example
 *
 *      var eqA = R.eqBy(R.prop('a'));
 *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
 *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
 *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
 */
var symmetricDifferenceWith = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function symmetricDifferenceWith(pred, list1, list2) {
  return Object(_concat__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_differenceWith__WEBPACK_IMPORTED_MODULE_2__["default"])(pred, list1, list2), Object(_differenceWith__WEBPACK_IMPORTED_MODULE_2__["default"])(pred, list2, list1));
});
/* harmony default export */ __webpack_exports__["default"] = (symmetricDifferenceWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tail.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tail.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_checkForMethod */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_checkForMethod.js");
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");




/**
 * Returns all but the first element of the given list or string (or object
 * with a `tail` method).
 *
 * Dispatches to the `slice` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.head, R.init, R.last
 * @example
 *
 *      R.tail([1, 2, 3]);  //=> [2, 3]
 *      R.tail([1, 2]);     //=> [2]
 *      R.tail([1]);        //=> []
 *      R.tail([]);         //=> []
 *
 *      R.tail('abc');  //=> 'bc'
 *      R.tail('ab');   //=> 'b'
 *      R.tail('a');    //=> ''
 *      R.tail('');     //=> ''
 */
var tail = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__["default"])('tail', /*#__PURE__*/Object(_slice__WEBPACK_IMPORTED_MODULE_2__["default"])(1, Infinity)));
/* harmony default export */ __webpack_exports__["default"] = (tail);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/take.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/take.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xtake__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xtake */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtake.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");





/**
 * Returns the first `n` elements of the given list, string, or
 * transducer/transformer (or object with a `take` method).
 *
 * Dispatches to the `take` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n
 * @param {*} list
 * @return {*}
 * @see R.drop
 * @example
 *
 *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
 *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
 *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.take(3, 'ramda');               //=> 'ram'
 *
 *      var personnel = [
 *        'Dave Brubeck',
 *        'Paul Desmond',
 *        'Eugene Wright',
 *        'Joe Morello',
 *        'Gerry Mulligan',
 *        'Bob Bates',
 *        'Joe Dodge',
 *        'Ron Crotty'
 *      ];
 *
 *      var takeFive = R.take(5);
 *      takeFive(personnel);
 *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
 * @symb R.take(-1, [a, b]) = [a, b]
 * @symb R.take(0, [a, b]) = []
 * @symb R.take(1, [a, b]) = [a]
 * @symb R.take(2, [a, b]) = [a, b]
 */
var take = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['take'], _internal_xtake__WEBPACK_IMPORTED_MODULE_2__["default"], function take(n, xs) {
  return Object(_slice__WEBPACK_IMPORTED_MODULE_3__["default"])(0, n < 0 ? Infinity : n, xs);
}));
/* harmony default export */ __webpack_exports__["default"] = (take);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeLast.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeLast.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _drop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drop */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/drop.js");



/**
 * Returns a new list containing the last `n` elements of the given list.
 * If `n > list.length`, returns a list of `list.length` elements.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n The number of elements to return.
 * @param {Array} xs The collection to consider.
 * @return {Array}
 * @see R.dropLast
 * @example
 *
 *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
 *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
 *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.takeLast(3, 'ramda');               //=> 'mda'
 */
var takeLast = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function takeLast(n, xs) {
  return Object(_drop__WEBPACK_IMPORTED_MODULE_1__["default"])(n >= 0 ? xs.length - n : 0, xs);
});
/* harmony default export */ __webpack_exports__["default"] = (takeLast);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeLastWhile.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeLastWhile.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");



/**
 * Returns a new list containing the last `n` elements of a given list, passing
 * each value to the supplied predicate function, and terminating when the
 * predicate function returns `false`. Excludes the element that caused the
 * predicate function to fail. The predicate function is passed one argument:
 * *(value)*.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @sig (a -> Boolean) -> String -> String
 * @param {Function} fn The function called per iteration.
 * @param {Array} xs The collection to iterate over.
 * @return {Array} A new array.
 * @see R.dropLastWhile, R.addIndex
 * @example
 *
 *      var isNotOne = x => x !== 1;
 *
 *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
 *
 *      R.takeLastWhile(x => x !== 'R' , 'Ramda'); //=> 'amda'
 */
var takeLastWhile = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function takeLastWhile(fn, xs) {
  var idx = xs.length - 1;
  while (idx >= 0 && fn(xs[idx])) {
    idx -= 1;
  }
  return Object(_slice__WEBPACK_IMPORTED_MODULE_1__["default"])(idx + 1, Infinity, xs);
});
/* harmony default export */ __webpack_exports__["default"] = (takeLastWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeWhile.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeWhile.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xtakeWhile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xtakeWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtakeWhile.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");





/**
 * Returns a new list containing the first `n` elements of a given list,
 * passing each value to the supplied predicate function, and terminating when
 * the predicate function returns `false`. Excludes the element that caused the
 * predicate function to fail. The predicate function is passed one argument:
 * *(value)*.
 *
 * Dispatches to the `takeWhile` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @sig (a -> Boolean) -> String -> String
 * @param {Function} fn The function called per iteration.
 * @param {Array} xs The collection to iterate over.
 * @return {Array} A new array.
 * @see R.dropWhile, R.transduce, R.addIndex
 * @example
 *
 *      var isNotFour = x => x !== 4;
 *
 *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
 *
 *      R.takeWhile(x => x !== 'd' , 'Ramda'); //=> 'Ram'
 */
var takeWhile = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['takeWhile'], _internal_xtakeWhile__WEBPACK_IMPORTED_MODULE_2__["default"], function takeWhile(fn, xs) {
  var idx = 0;
  var len = xs.length;
  while (idx < len && fn(xs[idx])) {
    idx += 1;
  }
  return Object(_slice__WEBPACK_IMPORTED_MODULE_3__["default"])(0, idx, xs);
}));
/* harmony default export */ __webpack_exports__["default"] = (takeWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tap.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tap.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xtap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xtap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtap.js");




/**
 * Runs the given function with the supplied object, then returns the object.
 *
 * Acts as a transducer if a transformer is given as second parameter.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (a -> *) -> a -> a
 * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
 * @param {*} x
 * @return {*} `x`.
 * @example
 *
 *      var sayX = x => console.log('x is ' + x);
 *      R.tap(sayX, 100); //=> 100
 *      // logs 'x is 100'
 * @symb R.tap(f, a) = a
 */
var tap = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xtap__WEBPACK_IMPORTED_MODULE_2__["default"], function tap(fn, x) {
  fn(x);
  return x;
}));
/* harmony default export */ __webpack_exports__["default"] = (tap);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/test.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/test.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_cloneRegExp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_cloneRegExp */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_cloneRegExp.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isRegExp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_isRegExp */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isRegExp.js");
/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toString.js");





/**
 * Determines whether a given string matches a given regular expression.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category String
 * @sig RegExp -> String -> Boolean
 * @param {RegExp} pattern
 * @param {String} str
 * @return {Boolean}
 * @see R.match
 * @example
 *
 *      R.test(/^x/, 'xyz'); //=> true
 *      R.test(/^y/, 'xyz'); //=> false
 */
var test = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function test(pattern, str) {
  if (!Object(_internal_isRegExp__WEBPACK_IMPORTED_MODULE_2__["default"])(pattern)) {
    throw new TypeError('âtestâ requires a value of type RegExp as its first argument; received ' + Object(_toString__WEBPACK_IMPORTED_MODULE_3__["default"])(pattern));
  }
  return Object(_internal_cloneRegExp__WEBPACK_IMPORTED_MODULE_0__["default"])(pattern).test(str);
});
/* harmony default export */ __webpack_exports__["default"] = (test);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/times.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/times.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Calls an input function `n` times, returning an array containing the results
 * of those function calls.
 *
 * `fn` is passed one argument: The current value of `n`, which begins at `0`
 * and is gradually incremented to `n - 1`.
 *
 * @func
 * @memberOf R
 * @since v0.2.3
 * @category List
 * @sig (Number -> a) -> Number -> [a]
 * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
 * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
 * @return {Array} An array containing the return values of all calls to `fn`.
 * @see R.repeat
 * @example
 *
 *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
 * @symb R.times(f, 0) = []
 * @symb R.times(f, 1) = [f(0)]
 * @symb R.times(f, 2) = [f(0), f(1)]
 */
var times = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function times(fn, n) {
  var len = Number(n);
  var idx = 0;
  var list;

  if (len < 0 || isNaN(len)) {
    throw new RangeError('n must be a non-negative number');
  }
  list = new Array(len);
  while (idx < len) {
    list[idx] = fn(idx);
    idx += 1;
  }
  return list;
});
/* harmony default export */ __webpack_exports__["default"] = (times);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toLower.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toLower.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _invoker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invoker */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invoker.js");


/**
 * The lower case version of a string.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category String
 * @sig String -> String
 * @param {String} str The string to lower case.
 * @return {String} The lower case version of `str`.
 * @see R.toUpper
 * @example
 *
 *      R.toLower('XYZ'); //=> 'xyz'
 */
var toLower = /*#__PURE__*/Object(_invoker__WEBPACK_IMPORTED_MODULE_0__["default"])(0, 'toLowerCase');
/* harmony default export */ __webpack_exports__["default"] = (toLower);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toPairs.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toPairs.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");



/**
 * Converts an object into an array of key, value arrays. Only the object's
 * own properties are used.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.4.0
 * @category Object
 * @sig {String: *} -> [[String,*]]
 * @param {Object} obj The object to extract from
 * @return {Array} An array of key, value arrays from the object's own properties.
 * @see R.fromPairs
 * @example
 *
 *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
 */
var toPairs = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function toPairs(obj) {
  var pairs = [];
  for (var prop in obj) {
    if (Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(prop, obj)) {
      pairs[pairs.length] = [prop, obj[prop]];
    }
  }
  return pairs;
});
/* harmony default export */ __webpack_exports__["default"] = (toPairs);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toPairsIn.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toPairsIn.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Converts an object into an array of key, value arrays. The object's own
 * properties and prototype properties are used. Note that the order of the
 * output array is not guaranteed to be consistent across different JS
 * platforms.
 *
 * @func
 * @memberOf R
 * @since v0.4.0
 * @category Object
 * @sig {String: *} -> [[String,*]]
 * @param {Object} obj The object to extract from
 * @return {Array} An array of key, value arrays from the object's own
 *         and prototype properties.
 * @example
 *
 *      var F = function() { this.x = 'X'; };
 *      F.prototype.y = 'Y';
 *      var f = new F();
 *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
 */
var toPairsIn = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function toPairsIn(obj) {
  var pairs = [];
  for (var prop in obj) {
    pairs[pairs.length] = [prop, obj[prop]];
  }
  return pairs;
});
/* harmony default export */ __webpack_exports__["default"] = (toPairsIn);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toString.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toString.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_toString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_toString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_toString.js");



/**
 * Returns the string representation of the given value. `eval`'ing the output
 * should result in a value equivalent to the input value. Many of the built-in
 * `toString` methods do not satisfy this requirement.
 *
 * If the given value is an `[object Object]` with a `toString` method other
 * than `Object.prototype.toString`, this method is invoked with no arguments
 * to produce the return value. This means user-defined constructor functions
 * can provide a suitable `toString` method. For example:
 *
 *     function Point(x, y) {
 *       this.x = x;
 *       this.y = y;
 *     }
 *
 *     Point.prototype.toString = function() {
 *       return 'new Point(' + this.x + ', ' + this.y + ')';
 *     };
 *
 *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category String
 * @sig * -> String
 * @param {*} val
 * @return {String}
 * @example
 *
 *      R.toString(42); //=> '42'
 *      R.toString('abc'); //=> '"abc"'
 *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
 *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
 *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
 */
var toString = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function toString(val) {
  return Object(_internal_toString__WEBPACK_IMPORTED_MODULE_1__["default"])(val, []);
});
/* harmony default export */ __webpack_exports__["default"] = (toString);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toUpper.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toUpper.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _invoker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invoker */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invoker.js");


/**
 * The upper case version of a string.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category String
 * @sig String -> String
 * @param {String} str The string to upper case.
 * @return {String} The upper case version of `str`.
 * @see R.toLower
 * @example
 *
 *      R.toUpper('abc'); //=> 'ABC'
 */
var toUpper = /*#__PURE__*/Object(_invoker__WEBPACK_IMPORTED_MODULE_0__["default"])(0, 'toUpperCase');
/* harmony default export */ __webpack_exports__["default"] = (toUpper);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/transduce.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/transduce.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _internal_xwrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_xwrap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xwrap.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");




/**
 * Initializes a transducer using supplied iterator function. Returns a single
 * item by iterating through the list, successively calling the transformed
 * iterator function and passing it an accumulator value and the current value
 * from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It will be
 * wrapped as a transformer to initialize the transducer. A transformer can be
 * passed directly in place of an iterator function. In both cases, iteration
 * may be stopped early with the [`R.reduced`](#reduced) function.
 *
 * A transducer is a function that accepts a transformer and returns a
 * transformer and can be composed directly.
 *
 * A transformer is an an object that provides a 2-arity reducing iterator
 * function, step, 0-arity initial value function, init, and 1-arity result
 * extraction function, result. The step function is used as the iterator
 * function in reduce. The result function is used to convert the final
 * accumulator into the return type and in most cases is
 * [`R.identity`](#identity). The init function can be used to provide an
 * initial accumulator, but is ignored by transduce.
 *
 * The iteration is performed with [`R.reduce`](#reduce) after initializing the transducer.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig (c -> c) -> ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array. Wrapped as transformer, if necessary, and used to
 *        initialize the transducer
 * @param {*} acc The initial accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduce, R.reduced, R.into
 * @example
 *
 *      var numbers = [1, 2, 3, 4];
 *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
 *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
 *
 *      var isOdd = (x) => x % 2 === 1;
 *      var firstOddTransducer = R.compose(R.filter(isOdd), R.take(1));
 *      R.transduce(firstOddTransducer, R.flip(R.append), [], R.range(0, 100)); //=> [1]
 */
var transduce = /*#__PURE__*/Object(_curryN__WEBPACK_IMPORTED_MODULE_2__["default"])(4, function transduce(xf, fn, acc, list) {
  return Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_0__["default"])(xf(typeof fn === 'function' ? Object(_internal_xwrap__WEBPACK_IMPORTED_MODULE_1__["default"])(fn) : fn), acc, list);
});
/* harmony default export */ __webpack_exports__["default"] = (transduce);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/transpose.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/transpose.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Transposes the rows and columns of a 2D list.
 * When passed a list of `n` lists of length `x`,
 * returns a list of `x` lists of length `n`.
 *
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig [[a]] -> [[a]]
 * @param {Array} list A 2D list
 * @return {Array} A 2D list
 * @example
 *
 *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
 *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
 *
 *      // If some of the rows are shorter than the following rows, their elements are skipped:
 *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
 * @symb R.transpose([[a], [b], [c]]) = [a, b, c]
 * @symb R.transpose([[a, b], [c, d]]) = [[a, c], [b, d]]
 * @symb R.transpose([[a, b], [c]]) = [[a, c], [b]]
 */
var transpose = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function transpose(outerlist) {
  var i = 0;
  var result = [];
  while (i < outerlist.length) {
    var innerlist = outerlist[i];
    var j = 0;
    while (j < innerlist.length) {
      if (typeof result[j] === 'undefined') {
        result[j] = [];
      }
      result[j].push(innerlist[j]);
      j += 1;
    }
    i += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (transpose);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/traverse.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/traverse.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");
/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sequence */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sequence.js");




/**
 * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
 * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
 * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
 * into an Applicative of Traversable.
 *
 * Dispatches to the `traverse` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
 * @param {Function} of
 * @param {Function} f
 * @param {*} traversable
 * @return {*}
 * @see R.sequence
 * @example
 *
 *      // Returns `Nothing` if the given divisor is `0`
 *      safeDiv = n => d => d === 0 ? Nothing() : Just(n / d)
 *
 *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Just([5, 2.5, 2])
 *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing
 */
var traverse = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function traverse(of, f, traversable) {
  return typeof traversable['fantasy-land/traverse'] === 'function' ? traversable['fantasy-land/traverse'](f, of) : Object(_sequence__WEBPACK_IMPORTED_MODULE_2__["default"])(of, Object(_map__WEBPACK_IMPORTED_MODULE_1__["default"])(f, traversable));
});
/* harmony default export */ __webpack_exports__["default"] = (traverse);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/trim.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/trim.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
var zeroWidth = '\u200b';
var hasProtoTrim = typeof String.prototype.trim === 'function';
/**
 * Removes (strips) whitespace from both ends of the string.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category String
 * @sig String -> String
 * @param {String} str The string to trim.
 * @return {String} Trimmed version of `str`.
 * @example
 *
 *      R.trim('   xyz  '); //=> 'xyz'
 *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
 */
var _trim = !hasProtoTrim || /*#__PURE__*/ws.trim() || ! /*#__PURE__*/zeroWidth.trim() ? function trim(str) {
  var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
  var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
  return str.replace(beginRx, '').replace(endRx, '');
} : function trim(str) {
  return str.trim();
};
var trim = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(_trim);
/* harmony default export */ __webpack_exports__["default"] = (trim);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tryCatch.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tryCatch.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");




/**
 * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
 * function evaluates the `tryer`; if it does not throw, it simply returns the
 * result. If the `tryer` *does* throw, the returned function evaluates the
 * `catcher` function and returns its result. Note that for effective
 * composition with this function, both the `tryer` and `catcher` functions
 * must return the same type of results.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Function
 * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
 * @param {Function} tryer The function that may throw.
 * @param {Function} catcher The function that will be evaluated if `tryer` throws.
 * @return {Function} A new function that will catch exceptions and send then to the catcher.
 * @example
 *
 *      R.tryCatch(R.prop('x'), R.F)({x: true}); //=> true
 *      R.tryCatch(R.prop('x'), R.F)(null);      //=> false
 */
var tryCatch = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_2__["default"])(function _tryCatch(tryer, catcher) {
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(tryer.length, function () {
    try {
      return tryer.apply(this, arguments);
    } catch (e) {
      return catcher.apply(this, Object(_internal_concat__WEBPACK_IMPORTED_MODULE_1__["default"])([e], arguments));
    }
  });
});
/* harmony default export */ __webpack_exports__["default"] = (tryCatch);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/type.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/type.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Gives a single-word string description of the (native) type of a value,
 * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
 * attempt to distinguish user Object types any further, reporting them all as
 * 'Object'.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Type
 * @sig (* -> {*}) -> String
 * @param {*} val The value to test
 * @return {String}
 * @example
 *
 *      R.type({}); //=> "Object"
 *      R.type(1); //=> "Number"
 *      R.type(false); //=> "Boolean"
 *      R.type('s'); //=> "String"
 *      R.type(null); //=> "Null"
 *      R.type([]); //=> "Array"
 *      R.type(/[A-z]/); //=> "RegExp"
 *      R.type(() => {}); //=> "Function"
 *      R.type(undefined); //=> "Undefined"
 */
var type = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function type(val) {
  return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
});
/* harmony default export */ __webpack_exports__["default"] = (type);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unapply.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unapply.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Takes a function `fn`, which takes a single array argument, and returns a
 * function which:
 *
 *   - takes any number of positional arguments;
 *   - passes these arguments to `fn` as an array; and
 *   - returns the result.
 *
 * In other words, `R.unapply` derives a variadic function from a function which
 * takes an array. `R.unapply` is the inverse of [`R.apply`](#apply).
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Function
 * @sig ([*...] -> a) -> (*... -> a)
 * @param {Function} fn
 * @return {Function}
 * @see R.apply
 * @example
 *
 *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
 * @symb R.unapply(f)(a, b) = f([a, b])
 */
var unapply = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function unapply(fn) {
  return function () {
    return fn(Array.prototype.slice.call(arguments, 0));
  };
});
/* harmony default export */ __webpack_exports__["default"] = (unapply);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unary.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unary.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _nAry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nAry */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nAry.js");



/**
 * Wraps a function of any arity (including nullary) in a function that accepts
 * exactly 1 parameter. Any extraneous parameters will not be passed to the
 * supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Function
 * @sig (* -> b) -> (a -> b)
 * @param {Function} fn The function to wrap.
 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
 *         arity 1.
 * @see R.binary, R.nAry
 * @example
 *
 *      var takesTwoArgs = function(a, b) {
 *        return [a, b];
 *      };
 *      takesTwoArgs.length; //=> 2
 *      takesTwoArgs(1, 2); //=> [1, 2]
 *
 *      var takesOneArg = R.unary(takesTwoArgs);
 *      takesOneArg.length; //=> 1
 *      // Only 1 argument is passed to the wrapped function
 *      takesOneArg(1, 2); //=> [1, undefined]
 * @symb R.unary(f)(a, b, c) = f(a)
 */
var unary = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function unary(fn) {
  return Object(_nAry__WEBPACK_IMPORTED_MODULE_1__["default"])(1, fn);
});
/* harmony default export */ __webpack_exports__["default"] = (unary);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uncurryN.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uncurryN.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");



/**
 * Returns a function of arity `n` from a (manually) curried function.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Function
 * @sig Number -> (a -> b) -> (a -> c)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to uncurry.
 * @return {Function} A new function.
 * @see R.curry
 * @example
 *
 *      var addFour = a => b => c => d => a + b + c + d;
 *
 *      var uncurriedAddFour = R.uncurryN(4, addFour);
 *      uncurriedAddFour(1, 2, 3, 4); //=> 10
 */
var uncurryN = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function uncurryN(depth, fn) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(depth, function () {
    var currentDepth = 1;
    var value = fn;
    var idx = 0;
    var endIdx;
    while (currentDepth <= depth && typeof value === 'function') {
      endIdx = currentDepth === depth ? arguments.length : idx + value.length;
      value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
      currentDepth += 1;
      idx = endIdx;
    }
    return value;
  });
});
/* harmony default export */ __webpack_exports__["default"] = (uncurryN);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unfold.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unfold.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Builds a list from a seed value. Accepts an iterator function, which returns
 * either false to stop iteration or an array of length 2 containing the value
 * to add to the resulting list and the seed to be used in the next call to the
 * iterator function.
 *
 * The iterator function receives one argument: *(seed)*.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig (a -> [b]) -> * -> [b]
 * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
 *        either false to quit iteration or an array of length two to proceed. The element
 *        at index 0 of this array will be added to the resulting array, and the element
 *        at index 1 will be passed to the next call to `fn`.
 * @param {*} seed The seed value.
 * @return {Array} The final list.
 * @example
 *
 *      var f = n => n > 50 ? false : [-n, n + 10];
 *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
 * @symb R.unfold(f, x) = [f(x)[0], f(f(x)[1])[0], f(f(f(x)[1])[1])[0], ...]
 */
var unfold = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function unfold(fn, seed) {
  var pair = fn(seed);
  var result = [];
  while (pair && pair.length) {
    result[result.length] = pair[0];
    pair = fn(pair[1]);
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (unfold);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/union.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/union.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compose */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/compose.js");
/* harmony import */ var _uniq__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./uniq */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniq.js");





/**
 * Combines two lists into a set (i.e. no duplicates) composed of the elements
 * of each list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} as The first list.
 * @param {Array} bs The second list.
 * @return {Array} The first and second lists concatenated, with
 *         duplicates removed.
 * @example
 *
 *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
 */
var union = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_compose__WEBPACK_IMPORTED_MODULE_2__["default"])(_uniq__WEBPACK_IMPORTED_MODULE_3__["default"], _internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (union);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unionWith.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unionWith.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _uniqWith__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./uniqWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqWith.js");




/**
 * Combines two lists into a set (i.e. no duplicates) composed of the elements
 * of each list. Duplication is determined according to the value returned by
 * applying the supplied predicate to two list elements.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig ((a, a) -> Boolean) -> [*] -> [*] -> [*]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The first and second lists concatenated, with
 *         duplicates removed.
 * @see R.union
 * @example
 *
 *      var l1 = [{a: 1}, {a: 2}];
 *      var l2 = [{a: 1}, {a: 4}];
 *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
 */
var unionWith = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_1__["default"])(function unionWith(pred, list1, list2) {
  return Object(_uniqWith__WEBPACK_IMPORTED_MODULE_2__["default"])(pred, Object(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"])(list1, list2));
});
/* harmony default export */ __webpack_exports__["default"] = (unionWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniq.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniq.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identity.js");
/* harmony import */ var _uniqBy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uniqBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqBy.js");



/**
 * Returns a new list containing only one copy of each element in the original
 * list. [`R.equals`](#equals) is used to determine equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
 *      R.uniq([1, '1']);     //=> [1, '1']
 *      R.uniq([[42], [42]]); //=> [[42]]
 */
var uniq = /*#__PURE__*/Object(_uniqBy__WEBPACK_IMPORTED_MODULE_1__["default"])(_identity__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (uniq);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqBy.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqBy.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_Set__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_Set */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_Set.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Returns a new list containing only one copy of each element in the original
 * list, based upon the value returned by applying the supplied function to
 * each list element. Prefers the first item if the supplied function produces
 * the same value on two items. [`R.equals`](#equals) is used for comparison.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> b) -> [a] -> [a]
 * @param {Function} fn A function used to produce a value to use during comparisons.
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
 */
var uniqBy = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function uniqBy(fn, list) {
  var set = new _internal_Set__WEBPACK_IMPORTED_MODULE_0__["default"]();
  var result = [];
  var idx = 0;
  var appliedItem, item;

  while (idx < list.length) {
    item = list[idx];
    appliedItem = fn(item);
    if (set.add(appliedItem)) {
      result.push(item);
    }
    idx += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (uniqBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqWith.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqWith.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_containsWith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_containsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_containsWith.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Returns a new list containing only one copy of each element in the original
 * list, based upon the value returned by applying the supplied predicate to
 * two list elements. Prefers the first item if two items compare equal based
 * on the predicate.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category List
 * @sig ((a, a) -> Boolean) -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      var strEq = R.eqBy(String);
 *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
 *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
 *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
 *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
 */
var uniqWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function uniqWith(pred, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  var item;
  while (idx < len) {
    item = list[idx];
    if (!Object(_internal_containsWith__WEBPACK_IMPORTED_MODULE_0__["default"])(pred, item, result)) {
      result[result.length] = item;
    }
    idx += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (uniqWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unless.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unless.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Tests the final argument by passing it to the given predicate function. If
 * the predicate is not satisfied, the function will return the result of
 * calling the `whenFalseFn` function with the same argument. If the predicate
 * is satisfied, the argument is returned as is.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Logic
 * @sig (a -> Boolean) -> (a -> a) -> a -> a
 * @param {Function} pred        A predicate function
 * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
 *                               to a falsy value.
 * @param {*}        x           An object to test with the `pred` function and
 *                               pass to `whenFalseFn` if necessary.
 * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
 * @see R.ifElse, R.when
 * @example
 *
 *      let safeInc = R.unless(R.isNil, R.inc);
 *      safeInc(null); //=> null
 *      safeInc(1); //=> 2
 */
var unless = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function unless(pred, whenFalseFn, x) {
  return pred(x) ? x : whenFalseFn(x);
});
/* harmony default export */ __webpack_exports__["default"] = (unless);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unnest.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unnest.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_identity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_identity.js");
/* harmony import */ var _chain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chain */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/chain.js");



/**
 * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
 * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig Chain c => c (c a) -> c a
 * @param {*} list
 * @return {*}
 * @see R.flatten, R.chain
 * @example
 *
 *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
 *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
 */
var unnest = /*#__PURE__*/Object(_chain__WEBPACK_IMPORTED_MODULE_1__["default"])(_internal_identity__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (unnest);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/until.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/until.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Takes a predicate, a transformation function, and an initial value,
 * and returns a value of the same type as the initial value.
 * It does so by applying the transformation until the predicate is satisfied,
 * at which point it returns the satisfactory value.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Logic
 * @sig (a -> Boolean) -> (a -> a) -> a -> a
 * @param {Function} pred A predicate function
 * @param {Function} fn The iterator function
 * @param {*} init Initial value
 * @return {*} Final value that satisfies predicate
 * @example
 *
 *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
 */
var until = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function until(pred, fn, init) {
  var val = init;
  while (!pred(val)) {
    val = fn(val);
  }
  return val;
});
/* harmony default export */ __webpack_exports__["default"] = (until);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/update.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/update.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _adjust__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adjust */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/adjust.js");
/* harmony import */ var _always__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./always */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js");




/**
 * Returns a new copy of the array with the element at the provided index
 * replaced with the given value.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig Number -> a -> [a] -> [a]
 * @param {Number} idx The index to update.
 * @param {*} x The value to exist at the given index of the returned array.
 * @param {Array|Arguments} list The source array-like object to be updated.
 * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
 * @see R.adjust
 * @example
 *
 *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
 *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
 * @symb R.update(-1, a, [b, c]) = [b, a]
 * @symb R.update(0, a, [b, c]) = [a, c]
 * @symb R.update(1, a, [b, c]) = [b, a]
 */
var update = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function update(idx, x, list) {
  return Object(_adjust__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_always__WEBPACK_IMPORTED_MODULE_2__["default"])(x), idx, list);
});
/* harmony default export */ __webpack_exports__["default"] = (update);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/useWith.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/useWith.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");



/**
 * Accepts a function `fn` and a list of transformer functions and returns a
 * new curried function. When the new function is invoked, it calls the
 * function `fn` with parameters consisting of the result of calling each
 * supplied handler on successive arguments to the new function.
 *
 * If more arguments are passed to the returned function than transformer
 * functions, those arguments are passed directly to `fn` as additional
 * parameters. If you expect additional arguments that don't need to be
 * transformed, although you can ignore them, it's best to pass an identity
 * function so that the new function reports the correct arity.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((x1, x2, ...) -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
 * @param {Function} fn The function to wrap.
 * @param {Array} transformers A list of transformer functions
 * @return {Function} The wrapped function.
 * @see R.converge
 * @example
 *
 *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
 *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
 *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
 *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
 * @symb R.useWith(f, [g, h])(a, b) = f(g(a), h(b))
 */
var useWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function useWith(fn, transformers) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(transformers.length, function () {
    var args = [];
    var idx = 0;
    while (idx < transformers.length) {
      args.push(transformers[idx].call(this, arguments[idx]));
      idx += 1;
    }
    return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
  });
});
/* harmony default export */ __webpack_exports__["default"] = (useWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/values.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/values.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");



/**
 * Returns a list of all the enumerable own properties of the supplied object.
 * Note that the order of the output array is not guaranteed across different
 * JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [v]
 * @param {Object} obj The object to extract values from
 * @return {Array} An array of the values of the object's own properties.
 * @see R.valuesIn, R.keys
 * @example
 *
 *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
 */
var values = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function values(obj) {
  var props = Object(_keys__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
  var len = props.length;
  var vals = [];
  var idx = 0;
  while (idx < len) {
    vals[idx] = obj[props[idx]];
    idx += 1;
  }
  return vals;
});
/* harmony default export */ __webpack_exports__["default"] = (values);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/valuesIn.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/valuesIn.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Returns a list of all the properties, including prototype properties, of the
 * supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @sig {k: v} -> [v]
 * @param {Object} obj The object to extract values from
 * @return {Array} An array of the values of the object's own and prototype properties.
 * @see R.values, R.keysIn
 * @example
 *
 *      var F = function() { this.x = 'X'; };
 *      F.prototype.y = 'Y';
 *      var f = new F();
 *      R.valuesIn(f); //=> ['X', 'Y']
 */
var valuesIn = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function valuesIn(obj) {
  var prop;
  var vs = [];
  for (prop in obj) {
    vs[vs.length] = obj[prop];
  }
  return vs;
});
/* harmony default export */ __webpack_exports__["default"] = (valuesIn);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/view.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/view.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


// `Const` is a functor that effectively ignores the function given to `map`.
var Const = function (x) {
  return { value: x, 'fantasy-land/map': function () {
      return this;
    } };
};

/**
 * Returns a "view" of the given data structure, determined by the given lens.
 * The lens's focus determines which portion of the data structure is visible.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Lens s a -> s -> a
 * @param {Lens} lens
 * @param {*} x
 * @return {*}
 * @see R.prop, R.lensIndex, R.lensProp
 * @example
 *
 *      var xLens = R.lensProp('x');
 *
 *      R.view(xLens, {x: 1, y: 2});  //=> 1
 *      R.view(xLens, {x: 4, y: 2});  //=> 4
 */
var view = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function view(lens, x) {
  // Using `Const` effectively ignores the setter function of the `lens`,
  // leaving the value returned by the getter function unmodified.
  return lens(Const)(x).value;
});
/* harmony default export */ __webpack_exports__["default"] = (view);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/when.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/when.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Tests the final argument by passing it to the given predicate function. If
 * the predicate is satisfied, the function will return the result of calling
 * the `whenTrueFn` function with the same argument. If the predicate is not
 * satisfied, the argument is returned as is.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Logic
 * @sig (a -> Boolean) -> (a -> a) -> a -> a
 * @param {Function} pred       A predicate function
 * @param {Function} whenTrueFn A function to invoke when the `condition`
 *                              evaluates to a truthy value.
 * @param {*}        x          An object to test with the `pred` function and
 *                              pass to `whenTrueFn` if necessary.
 * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
 * @see R.ifElse, R.unless
 * @example
 *
 *      // truncate :: String -> String
 *      var truncate = R.when(
 *        R.propSatisfies(R.gt(R.__, 10), 'length'),
 *        R.pipe(R.take(10), R.append('â¦'), R.join(''))
 *      );
 *      truncate('12345');         //=> '12345'
 *      truncate('0123456789ABC'); //=> '0123456789â¦'
 */
var when = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function when(pred, whenTrueFn, x) {
  return pred(x) ? whenTrueFn(x) : x;
});
/* harmony default export */ __webpack_exports__["default"] = (when);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/where.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/where.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");



/**
 * Takes a spec object and a test object; returns true if the test satisfies
 * the spec. Each of the spec's own properties must be a predicate function.
 * Each predicate is applied to the value of the corresponding property of the
 * test object. `where` returns true if all the predicates return true, false
 * otherwise.
 *
 * `where` is well suited to declaratively expressing constraints for other
 * functions such as [`filter`](#filter) and [`find`](#find).
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category Object
 * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
 * @param {Object} spec
 * @param {Object} testObj
 * @return {Boolean}
 * @see R.propSatisfies, R.whereEq
 * @example
 *
 *      // pred :: Object -> Boolean
 *      var pred = R.where({
 *        a: R.equals('foo'),
 *        b: R.complement(R.equals('bar')),
 *        x: R.gt(R.__, 10),
 *        y: R.lt(R.__, 20)
 *      });
 *
 *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
 *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
 *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
 *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
 *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
 */
var where = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function where(spec, testObj) {
  for (var prop in spec) {
    if (Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(prop, spec) && !spec[prop](testObj[prop])) {
      return false;
    }
  }
  return true;
});
/* harmony default export */ __webpack_exports__["default"] = (where);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/whereEq.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/whereEq.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");
/* harmony import */ var _where__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./where */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/where.js");





/**
 * Takes a spec object and a test object; returns true if the test satisfies
 * the spec, false otherwise. An object satisfies the spec if, for each of the
 * spec's own properties, accessing that property of the object gives the same
 * value (in [`R.equals`](#equals) terms) as accessing that property of the
 * spec.
 *
 * `whereEq` is a specialization of [`where`](#where).
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Object
 * @sig {String: *} -> {String: *} -> Boolean
 * @param {Object} spec
 * @param {Object} testObj
 * @return {Boolean}
 * @see R.propEq, R.where
 * @example
 *
 *      // pred :: Object -> Boolean
 *      var pred = R.whereEq({a: 1, b: 2});
 *
 *      pred({a: 1});              //=> false
 *      pred({a: 1, b: 2});        //=> true
 *      pred({a: 1, b: 2, c: 3});  //=> true
 *      pred({a: 1, b: 1});        //=> false
 */
var whereEq = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function whereEq(spec, testObj) {
  return Object(_where__WEBPACK_IMPORTED_MODULE_3__["default"])(Object(_map__WEBPACK_IMPORTED_MODULE_2__["default"])(_equals__WEBPACK_IMPORTED_MODULE_1__["default"], spec), testObj);
});
/* harmony default export */ __webpack_exports__["default"] = (whereEq);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/without.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/without.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_contains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_contains */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _flip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flip */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flip.js");
/* harmony import */ var _reject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reject */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reject.js");





/**
 * Returns a new list without values in the first argument.
 * [`R.equals`](#equals) is used to determine equality.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig [a] -> [a] -> [a]
 * @param {Array} list1 The values to be removed from `list2`.
 * @param {Array} list2 The array to remove values from.
 * @return {Array} The new array without values in `list1`.
 * @see R.transduce, R.difference
 * @example
 *
 *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
 */
var without = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (xs, list) {
  return Object(_reject__WEBPACK_IMPORTED_MODULE_3__["default"])(Object(_flip__WEBPACK_IMPORTED_MODULE_2__["default"])(_internal_contains__WEBPACK_IMPORTED_MODULE_0__["default"])(xs), list);
});
/* harmony default export */ __webpack_exports__["default"] = (without);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/xprod.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/xprod.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Creates a new list out of the two supplied by creating each possible pair
 * from the lists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [b] -> [[a,b]]
 * @param {Array} as The first list.
 * @param {Array} bs The second list.
 * @return {Array} The list made by combining each possible pair from
 *         `as` and `bs` into pairs (`[a, b]`).
 * @example
 *
 *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
 * @symb R.xprod([a, b], [c, d]) = [[a, c], [a, d], [b, c], [b, d]]
 */
var xprod = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function xprod(a, b) {
  // = xprodWith(prepend); (takes about 3 times as long...)
  var idx = 0;
  var ilen = a.length;
  var j;
  var jlen = b.length;
  var result = [];
  while (idx < ilen) {
    j = 0;
    while (j < jlen) {
      result[result.length] = [a[idx], b[j]];
      j += 1;
    }
    idx += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (xprod);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zip.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zip.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Creates a new list out of the two supplied by pairing up equally-positioned
 * items from both lists. The returned list is truncated to the length of the
 * shorter of the two input lists.
 * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [b] -> [[a,b]]
 * @param {Array} list1 The first array to consider.
 * @param {Array} list2 The second array to consider.
 * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
 * @example
 *
 *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
 * @symb R.zip([a, b, c], [d, e, f]) = [[a, d], [b, e], [c, f]]
 */
var zip = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function zip(a, b) {
  var rv = [];
  var idx = 0;
  var len = Math.min(a.length, b.length);
  while (idx < len) {
    rv[idx] = [a[idx], b[idx]];
    idx += 1;
  }
  return rv;
});
/* harmony default export */ __webpack_exports__["default"] = (zip);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zipObj.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zipObj.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Creates a new object out of a list of keys and a list of values.
 * Key/value pairing is truncated to the length of the shorter of the two lists.
 * Note: `zipObj` is equivalent to `pipe(zip, fromPairs)`.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig [String] -> [*] -> {String: *}
 * @param {Array} keys The array that will be properties on the output object.
 * @param {Array} values The list of values on the output object.
 * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
 * @example
 *
 *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
 */
var zipObj = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function zipObj(keys, values) {
  var idx = 0;
  var len = Math.min(keys.length, values.length);
  var out = {};
  while (idx < len) {
    out[keys[idx]] = values[idx];
    idx += 1;
  }
  return out;
});
/* harmony default export */ __webpack_exports__["default"] = (zipObj);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zipWith.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zipWith.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Creates a new list out of the two supplied by applying the function to each
 * equally-positioned pair in the lists. The returned list is truncated to the
 * length of the shorter of the two input lists.
 *
 * @function
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> c) -> [a] -> [b] -> [c]
 * @param {Function} fn The function used to combine the two elements into one value.
 * @param {Array} list1 The first array to consider.
 * @param {Array} list2 The second array to consider.
 * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
 *         using `fn`.
 * @example
 *
 *      var f = (x, y) => {
 *        // ...
 *      };
 *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
 *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
 * @symb R.zipWith(fn, [a, b, c], [d, e, f]) = [fn(a, d), fn(b, e), fn(c, f)]
 */
var zipWith = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function zipWith(fn, a, b) {
  var rv = [];
  var idx = 0;
  var len = Math.min(a.length, b.length);
  while (idx < len) {
    rv[idx] = fn(a[idx], b[idx]);
    idx += 1;
  }
  return rv;
});
/* harmony default export */ __webpack_exports__["default"] = (zipWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/index.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./lib/ */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/index.js");


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/entities.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/entities.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid entities
//
// Generate with ./support/entities.js script
//


/*eslint quotes:0*/
module.exports = {
  "Aacute":"\u00C1",
  "aacute":"\u00E1",
  "Abreve":"\u0102",
  "abreve":"\u0103",
  "ac":"\u223E",
  "acd":"\u223F",
  "acE":"\u223E\u0333",
  "Acirc":"\u00C2",
  "acirc":"\u00E2",
  "acute":"\u00B4",
  "Acy":"\u0410",
  "acy":"\u0430",
  "AElig":"\u00C6",
  "aelig":"\u00E6",
  "af":"\u2061",
  "Afr":"\uD835\uDD04",
  "afr":"\uD835\uDD1E",
  "Agrave":"\u00C0",
  "agrave":"\u00E0",
  "alefsym":"\u2135",
  "aleph":"\u2135",
  "Alpha":"\u0391",
  "alpha":"\u03B1",
  "Amacr":"\u0100",
  "amacr":"\u0101",
  "amalg":"\u2A3F",
  "AMP":"\u0026",
  "amp":"\u0026",
  "And":"\u2A53",
  "and":"\u2227",
  "andand":"\u2A55",
  "andd":"\u2A5C",
  "andslope":"\u2A58",
  "andv":"\u2A5A",
  "ang":"\u2220",
  "ange":"\u29A4",
  "angle":"\u2220",
  "angmsd":"\u2221",
  "angmsdaa":"\u29A8",
  "angmsdab":"\u29A9",
  "angmsdac":"\u29AA",
  "angmsdad":"\u29AB",
  "angmsdae":"\u29AC",
  "angmsdaf":"\u29AD",
  "angmsdag":"\u29AE",
  "angmsdah":"\u29AF",
  "angrt":"\u221F",
  "angrtvb":"\u22BE",
  "angrtvbd":"\u299D",
  "angsph":"\u2222",
  "angst":"\u00C5",
  "angzarr":"\u237C",
  "Aogon":"\u0104",
  "aogon":"\u0105",
  "Aopf":"\uD835\uDD38",
  "aopf":"\uD835\uDD52",
  "ap":"\u2248",
  "apacir":"\u2A6F",
  "apE":"\u2A70",
  "ape":"\u224A",
  "apid":"\u224B",
  "apos":"\u0027",
  "ApplyFunction":"\u2061",
  "approx":"\u2248",
  "approxeq":"\u224A",
  "Aring":"\u00C5",
  "aring":"\u00E5",
  "Ascr":"\uD835\uDC9C",
  "ascr":"\uD835\uDCB6",
  "Assign":"\u2254",
  "ast":"\u002A",
  "asymp":"\u2248",
  "asympeq":"\u224D",
  "Atilde":"\u00C3",
  "atilde":"\u00E3",
  "Auml":"\u00C4",
  "auml":"\u00E4",
  "awconint":"\u2233",
  "awint":"\u2A11",
  "backcong":"\u224C",
  "backepsilon":"\u03F6",
  "backprime":"\u2035",
  "backsim":"\u223D",
  "backsimeq":"\u22CD",
  "Backslash":"\u2216",
  "Barv":"\u2AE7",
  "barvee":"\u22BD",
  "Barwed":"\u2306",
  "barwed":"\u2305",
  "barwedge":"\u2305",
  "bbrk":"\u23B5",
  "bbrktbrk":"\u23B6",
  "bcong":"\u224C",
  "Bcy":"\u0411",
  "bcy":"\u0431",
  "bdquo":"\u201E",
  "becaus":"\u2235",
  "Because":"\u2235",
  "because":"\u2235",
  "bemptyv":"\u29B0",
  "bepsi":"\u03F6",
  "bernou":"\u212C",
  "Bernoullis":"\u212C",
  "Beta":"\u0392",
  "beta":"\u03B2",
  "beth":"\u2136",
  "between":"\u226C",
  "Bfr":"\uD835\uDD05",
  "bfr":"\uD835\uDD1F",
  "bigcap":"\u22C2",
  "bigcirc":"\u25EF",
  "bigcup":"\u22C3",
  "bigodot":"\u2A00",
  "bigoplus":"\u2A01",
  "bigotimes":"\u2A02",
  "bigsqcup":"\u2A06",
  "bigstar":"\u2605",
  "bigtriangledown":"\u25BD",
  "bigtriangleup":"\u25B3",
  "biguplus":"\u2A04",
  "bigvee":"\u22C1",
  "bigwedge":"\u22C0",
  "bkarow":"\u290D",
  "blacklozenge":"\u29EB",
  "blacksquare":"\u25AA",
  "blacktriangle":"\u25B4",
  "blacktriangledown":"\u25BE",
  "blacktriangleleft":"\u25C2",
  "blacktriangleright":"\u25B8",
  "blank":"\u2423",
  "blk12":"\u2592",
  "blk14":"\u2591",
  "blk34":"\u2593",
  "block":"\u2588",
  "bne":"\u003D\u20E5",
  "bnequiv":"\u2261\u20E5",
  "bNot":"\u2AED",
  "bnot":"\u2310",
  "Bopf":"\uD835\uDD39",
  "bopf":"\uD835\uDD53",
  "bot":"\u22A5",
  "bottom":"\u22A5",
  "bowtie":"\u22C8",
  "boxbox":"\u29C9",
  "boxDL":"\u2557",
  "boxDl":"\u2556",
  "boxdL":"\u2555",
  "boxdl":"\u2510",
  "boxDR":"\u2554",
  "boxDr":"\u2553",
  "boxdR":"\u2552",
  "boxdr":"\u250C",
  "boxH":"\u2550",
  "boxh":"\u2500",
  "boxHD":"\u2566",
  "boxHd":"\u2564",
  "boxhD":"\u2565",
  "boxhd":"\u252C",
  "boxHU":"\u2569",
  "boxHu":"\u2567",
  "boxhU":"\u2568",
  "boxhu":"\u2534",
  "boxminus":"\u229F",
  "boxplus":"\u229E",
  "boxtimes":"\u22A0",
  "boxUL":"\u255D",
  "boxUl":"\u255C",
  "boxuL":"\u255B",
  "boxul":"\u2518",
  "boxUR":"\u255A",
  "boxUr":"\u2559",
  "boxuR":"\u2558",
  "boxur":"\u2514",
  "boxV":"\u2551",
  "boxv":"\u2502",
  "boxVH":"\u256C",
  "boxVh":"\u256B",
  "boxvH":"\u256A",
  "boxvh":"\u253C",
  "boxVL":"\u2563",
  "boxVl":"\u2562",
  "boxvL":"\u2561",
  "boxvl":"\u2524",
  "boxVR":"\u2560",
  "boxVr":"\u255F",
  "boxvR":"\u255E",
  "boxvr":"\u251C",
  "bprime":"\u2035",
  "Breve":"\u02D8",
  "breve":"\u02D8",
  "brvbar":"\u00A6",
  "Bscr":"\u212C",
  "bscr":"\uD835\uDCB7",
  "bsemi":"\u204F",
  "bsim":"\u223D",
  "bsime":"\u22CD",
  "bsol":"\u005C",
  "bsolb":"\u29C5",
  "bsolhsub":"\u27C8",
  "bull":"\u2022",
  "bullet":"\u2022",
  "bump":"\u224E",
  "bumpE":"\u2AAE",
  "bumpe":"\u224F",
  "Bumpeq":"\u224E",
  "bumpeq":"\u224F",
  "Cacute":"\u0106",
  "cacute":"\u0107",
  "Cap":"\u22D2",
  "cap":"\u2229",
  "capand":"\u2A44",
  "capbrcup":"\u2A49",
  "capcap":"\u2A4B",
  "capcup":"\u2A47",
  "capdot":"\u2A40",
  "CapitalDifferentialD":"\u2145",
  "caps":"\u2229\uFE00",
  "caret":"\u2041",
  "caron":"\u02C7",
  "Cayleys":"\u212D",
  "ccaps":"\u2A4D",
  "Ccaron":"\u010C",
  "ccaron":"\u010D",
  "Ccedil":"\u00C7",
  "ccedil":"\u00E7",
  "Ccirc":"\u0108",
  "ccirc":"\u0109",
  "Cconint":"\u2230",
  "ccups":"\u2A4C",
  "ccupssm":"\u2A50",
  "Cdot":"\u010A",
  "cdot":"\u010B",
  "cedil":"\u00B8",
  "Cedilla":"\u00B8",
  "cemptyv":"\u29B2",
  "cent":"\u00A2",
  "CenterDot":"\u00B7",
  "centerdot":"\u00B7",
  "Cfr":"\u212D",
  "cfr":"\uD835\uDD20",
  "CHcy":"\u0427",
  "chcy":"\u0447",
  "check":"\u2713",
  "checkmark":"\u2713",
  "Chi":"\u03A7",
  "chi":"\u03C7",
  "cir":"\u25CB",
  "circ":"\u02C6",
  "circeq":"\u2257",
  "circlearrowleft":"\u21BA",
  "circlearrowright":"\u21BB",
  "circledast":"\u229B",
  "circledcirc":"\u229A",
  "circleddash":"\u229D",
  "CircleDot":"\u2299",
  "circledR":"\u00AE",
  "circledS":"\u24C8",
  "CircleMinus":"\u2296",
  "CirclePlus":"\u2295",
  "CircleTimes":"\u2297",
  "cirE":"\u29C3",
  "cire":"\u2257",
  "cirfnint":"\u2A10",
  "cirmid":"\u2AEF",
  "cirscir":"\u29C2",
  "ClockwiseContourIntegral":"\u2232",
  "CloseCurlyDoubleQuote":"\u201D",
  "CloseCurlyQuote":"\u2019",
  "clubs":"\u2663",
  "clubsuit":"\u2663",
  "Colon":"\u2237",
  "colon":"\u003A",
  "Colone":"\u2A74",
  "colone":"\u2254",
  "coloneq":"\u2254",
  "comma":"\u002C",
  "commat":"\u0040",
  "comp":"\u2201",
  "compfn":"\u2218",
  "complement":"\u2201",
  "complexes":"\u2102",
  "cong":"\u2245",
  "congdot":"\u2A6D",
  "Congruent":"\u2261",
  "Conint":"\u222F",
  "conint":"\u222E",
  "ContourIntegral":"\u222E",
  "Copf":"\u2102",
  "copf":"\uD835\uDD54",
  "coprod":"\u2210",
  "Coproduct":"\u2210",
  "COPY":"\u00A9",
  "copy":"\u00A9",
  "copysr":"\u2117",
  "CounterClockwiseContourIntegral":"\u2233",
  "crarr":"\u21B5",
  "Cross":"\u2A2F",
  "cross":"\u2717",
  "Cscr":"\uD835\uDC9E",
  "cscr":"\uD835\uDCB8",
  "csub":"\u2ACF",
  "csube":"\u2AD1",
  "csup":"\u2AD0",
  "csupe":"\u2AD2",
  "ctdot":"\u22EF",
  "cudarrl":"\u2938",
  "cudarrr":"\u2935",
  "cuepr":"\u22DE",
  "cuesc":"\u22DF",
  "cularr":"\u21B6",
  "cularrp":"\u293D",
  "Cup":"\u22D3",
  "cup":"\u222A",
  "cupbrcap":"\u2A48",
  "CupCap":"\u224D",
  "cupcap":"\u2A46",
  "cupcup":"\u2A4A",
  "cupdot":"\u228D",
  "cupor":"\u2A45",
  "cups":"\u222A\uFE00",
  "curarr":"\u21B7",
  "curarrm":"\u293C",
  "curlyeqprec":"\u22DE",
  "curlyeqsucc":"\u22DF",
  "curlyvee":"\u22CE",
  "curlywedge":"\u22CF",
  "curren":"\u00A4",
  "curvearrowleft":"\u21B6",
  "curvearrowright":"\u21B7",
  "cuvee":"\u22CE",
  "cuwed":"\u22CF",
  "cwconint":"\u2232",
  "cwint":"\u2231",
  "cylcty":"\u232D",
  "Dagger":"\u2021",
  "dagger":"\u2020",
  "daleth":"\u2138",
  "Darr":"\u21A1",
  "dArr":"\u21D3",
  "darr":"\u2193",
  "dash":"\u2010",
  "Dashv":"\u2AE4",
  "dashv":"\u22A3",
  "dbkarow":"\u290F",
  "dblac":"\u02DD",
  "Dcaron":"\u010E",
  "dcaron":"\u010F",
  "Dcy":"\u0414",
  "dcy":"\u0434",
  "DD":"\u2145",
  "dd":"\u2146",
  "ddagger":"\u2021",
  "ddarr":"\u21CA",
  "DDotrahd":"\u2911",
  "ddotseq":"\u2A77",
  "deg":"\u00B0",
  "Del":"\u2207",
  "Delta":"\u0394",
  "delta":"\u03B4",
  "demptyv":"\u29B1",
  "dfisht":"\u297F",
  "Dfr":"\uD835\uDD07",
  "dfr":"\uD835\uDD21",
  "dHar":"\u2965",
  "dharl":"\u21C3",
  "dharr":"\u21C2",
  "DiacriticalAcute":"\u00B4",
  "DiacriticalDot":"\u02D9",
  "DiacriticalDoubleAcute":"\u02DD",
  "DiacriticalGrave":"\u0060",
  "DiacriticalTilde":"\u02DC",
  "diam":"\u22C4",
  "Diamond":"\u22C4",
  "diamond":"\u22C4",
  "diamondsuit":"\u2666",
  "diams":"\u2666",
  "die":"\u00A8",
  "DifferentialD":"\u2146",
  "digamma":"\u03DD",
  "disin":"\u22F2",
  "div":"\u00F7",
  "divide":"\u00F7",
  "divideontimes":"\u22C7",
  "divonx":"\u22C7",
  "DJcy":"\u0402",
  "djcy":"\u0452",
  "dlcorn":"\u231E",
  "dlcrop":"\u230D",
  "dollar":"\u0024",
  "Dopf":"\uD835\uDD3B",
  "dopf":"\uD835\uDD55",
  "Dot":"\u00A8",
  "dot":"\u02D9",
  "DotDot":"\u20DC",
  "doteq":"\u2250",
  "doteqdot":"\u2251",
  "DotEqual":"\u2250",
  "dotminus":"\u2238",
  "dotplus":"\u2214",
  "dotsquare":"\u22A1",
  "doublebarwedge":"\u2306",
  "DoubleContourIntegral":"\u222F",
  "DoubleDot":"\u00A8",
  "DoubleDownArrow":"\u21D3",
  "DoubleLeftArrow":"\u21D0",
  "DoubleLeftRightArrow":"\u21D4",
  "DoubleLeftTee":"\u2AE4",
  "DoubleLongLeftArrow":"\u27F8",
  "DoubleLongLeftRightArrow":"\u27FA",
  "DoubleLongRightArrow":"\u27F9",
  "DoubleRightArrow":"\u21D2",
  "DoubleRightTee":"\u22A8",
  "DoubleUpArrow":"\u21D1",
  "DoubleUpDownArrow":"\u21D5",
  "DoubleVerticalBar":"\u2225",
  "DownArrow":"\u2193",
  "Downarrow":"\u21D3",
  "downarrow":"\u2193",
  "DownArrowBar":"\u2913",
  "DownArrowUpArrow":"\u21F5",
  "DownBreve":"\u0311",
  "downdownarrows":"\u21CA",
  "downharpoonleft":"\u21C3",
  "downharpoonright":"\u21C2",
  "DownLeftRightVector":"\u2950",
  "DownLeftTeeVector":"\u295E",
  "DownLeftVector":"\u21BD",
  "DownLeftVectorBar":"\u2956",
  "DownRightTeeVector":"\u295F",
  "DownRightVector":"\u21C1",
  "DownRightVectorBar":"\u2957",
  "DownTee":"\u22A4",
  "DownTeeArrow":"\u21A7",
  "drbkarow":"\u2910",
  "drcorn":"\u231F",
  "drcrop":"\u230C",
  "Dscr":"\uD835\uDC9F",
  "dscr":"\uD835\uDCB9",
  "DScy":"\u0405",
  "dscy":"\u0455",
  "dsol":"\u29F6",
  "Dstrok":"\u0110",
  "dstrok":"\u0111",
  "dtdot":"\u22F1",
  "dtri":"\u25BF",
  "dtrif":"\u25BE",
  "duarr":"\u21F5",
  "duhar":"\u296F",
  "dwangle":"\u29A6",
  "DZcy":"\u040F",
  "dzcy":"\u045F",
  "dzigrarr":"\u27FF",
  "Eacute":"\u00C9",
  "eacute":"\u00E9",
  "easter":"\u2A6E",
  "Ecaron":"\u011A",
  "ecaron":"\u011B",
  "ecir":"\u2256",
  "Ecirc":"\u00CA",
  "ecirc":"\u00EA",
  "ecolon":"\u2255",
  "Ecy":"\u042D",
  "ecy":"\u044D",
  "eDDot":"\u2A77",
  "Edot":"\u0116",
  "eDot":"\u2251",
  "edot":"\u0117",
  "ee":"\u2147",
  "efDot":"\u2252",
  "Efr":"\uD835\uDD08",
  "efr":"\uD835\uDD22",
  "eg":"\u2A9A",
  "Egrave":"\u00C8",
  "egrave":"\u00E8",
  "egs":"\u2A96",
  "egsdot":"\u2A98",
  "el":"\u2A99",
  "Element":"\u2208",
  "elinters":"\u23E7",
  "ell":"\u2113",
  "els":"\u2A95",
  "elsdot":"\u2A97",
  "Emacr":"\u0112",
  "emacr":"\u0113",
  "empty":"\u2205",
  "emptyset":"\u2205",
  "EmptySmallSquare":"\u25FB",
  "emptyv":"\u2205",
  "EmptyVerySmallSquare":"\u25AB",
  "emsp":"\u2003",
  "emsp13":"\u2004",
  "emsp14":"\u2005",
  "ENG":"\u014A",
  "eng":"\u014B",
  "ensp":"\u2002",
  "Eogon":"\u0118",
  "eogon":"\u0119",
  "Eopf":"\uD835\uDD3C",
  "eopf":"\uD835\uDD56",
  "epar":"\u22D5",
  "eparsl":"\u29E3",
  "eplus":"\u2A71",
  "epsi":"\u03B5",
  "Epsilon":"\u0395",
  "epsilon":"\u03B5",
  "epsiv":"\u03F5",
  "eqcirc":"\u2256",
  "eqcolon":"\u2255",
  "eqsim":"\u2242",
  "eqslantgtr":"\u2A96",
  "eqslantless":"\u2A95",
  "Equal":"\u2A75",
  "equals":"\u003D",
  "EqualTilde":"\u2242",
  "equest":"\u225F",
  "Equilibrium":"\u21CC",
  "equiv":"\u2261",
  "equivDD":"\u2A78",
  "eqvparsl":"\u29E5",
  "erarr":"\u2971",
  "erDot":"\u2253",
  "Escr":"\u2130",
  "escr":"\u212F",
  "esdot":"\u2250",
  "Esim":"\u2A73",
  "esim":"\u2242",
  "Eta":"\u0397",
  "eta":"\u03B7",
  "ETH":"\u00D0",
  "eth":"\u00F0",
  "Euml":"\u00CB",
  "euml":"\u00EB",
  "euro":"\u20AC",
  "excl":"\u0021",
  "exist":"\u2203",
  "Exists":"\u2203",
  "expectation":"\u2130",
  "ExponentialE":"\u2147",
  "exponentiale":"\u2147",
  "fallingdotseq":"\u2252",
  "Fcy":"\u0424",
  "fcy":"\u0444",
  "female":"\u2640",
  "ffilig":"\uFB03",
  "fflig":"\uFB00",
  "ffllig":"\uFB04",
  "Ffr":"\uD835\uDD09",
  "ffr":"\uD835\uDD23",
  "filig":"\uFB01",
  "FilledSmallSquare":"\u25FC",
  "FilledVerySmallSquare":"\u25AA",
  "fjlig":"\u0066\u006A",
  "flat":"\u266D",
  "fllig":"\uFB02",
  "fltns":"\u25B1",
  "fnof":"\u0192",
  "Fopf":"\uD835\uDD3D",
  "fopf":"\uD835\uDD57",
  "ForAll":"\u2200",
  "forall":"\u2200",
  "fork":"\u22D4",
  "forkv":"\u2AD9",
  "Fouriertrf":"\u2131",
  "fpartint":"\u2A0D",
  "frac12":"\u00BD",
  "frac13":"\u2153",
  "frac14":"\u00BC",
  "frac15":"\u2155",
  "frac16":"\u2159",
  "frac18":"\u215B",
  "frac23":"\u2154",
  "frac25":"\u2156",
  "frac34":"\u00BE",
  "frac35":"\u2157",
  "frac38":"\u215C",
  "frac45":"\u2158",
  "frac56":"\u215A",
  "frac58":"\u215D",
  "frac78":"\u215E",
  "frasl":"\u2044",
  "frown":"\u2322",
  "Fscr":"\u2131",
  "fscr":"\uD835\uDCBB",
  "gacute":"\u01F5",
  "Gamma":"\u0393",
  "gamma":"\u03B3",
  "Gammad":"\u03DC",
  "gammad":"\u03DD",
  "gap":"\u2A86",
  "Gbreve":"\u011E",
  "gbreve":"\u011F",
  "Gcedil":"\u0122",
  "Gcirc":"\u011C",
  "gcirc":"\u011D",
  "Gcy":"\u0413",
  "gcy":"\u0433",
  "Gdot":"\u0120",
  "gdot":"\u0121",
  "gE":"\u2267",
  "ge":"\u2265",
  "gEl":"\u2A8C",
  "gel":"\u22DB",
  "geq":"\u2265",
  "geqq":"\u2267",
  "geqslant":"\u2A7E",
  "ges":"\u2A7E",
  "gescc":"\u2AA9",
  "gesdot":"\u2A80",
  "gesdoto":"\u2A82",
  "gesdotol":"\u2A84",
  "gesl":"\u22DB\uFE00",
  "gesles":"\u2A94",
  "Gfr":"\uD835\uDD0A",
  "gfr":"\uD835\uDD24",
  "Gg":"\u22D9",
  "gg":"\u226B",
  "ggg":"\u22D9",
  "gimel":"\u2137",
  "GJcy":"\u0403",
  "gjcy":"\u0453",
  "gl":"\u2277",
  "gla":"\u2AA5",
  "glE":"\u2A92",
  "glj":"\u2AA4",
  "gnap":"\u2A8A",
  "gnapprox":"\u2A8A",
  "gnE":"\u2269",
  "gne":"\u2A88",
  "gneq":"\u2A88",
  "gneqq":"\u2269",
  "gnsim":"\u22E7",
  "Gopf":"\uD835\uDD3E",
  "gopf":"\uD835\uDD58",
  "grave":"\u0060",
  "GreaterEqual":"\u2265",
  "GreaterEqualLess":"\u22DB",
  "GreaterFullEqual":"\u2267",
  "GreaterGreater":"\u2AA2",
  "GreaterLess":"\u2277",
  "GreaterSlantEqual":"\u2A7E",
  "GreaterTilde":"\u2273",
  "Gscr":"\uD835\uDCA2",
  "gscr":"\u210A",
  "gsim":"\u2273",
  "gsime":"\u2A8E",
  "gsiml":"\u2A90",
  "GT":"\u003E",
  "Gt":"\u226B",
  "gt":"\u003E",
  "gtcc":"\u2AA7",
  "gtcir":"\u2A7A",
  "gtdot":"\u22D7",
  "gtlPar":"\u2995",
  "gtquest":"\u2A7C",
  "gtrapprox":"\u2A86",
  "gtrarr":"\u2978",
  "gtrdot":"\u22D7",
  "gtreqless":"\u22DB",
  "gtreqqless":"\u2A8C",
  "gtrless":"\u2277",
  "gtrsim":"\u2273",
  "gvertneqq":"\u2269\uFE00",
  "gvnE":"\u2269\uFE00",
  "Hacek":"\u02C7",
  "hairsp":"\u200A",
  "half":"\u00BD",
  "hamilt":"\u210B",
  "HARDcy":"\u042A",
  "hardcy":"\u044A",
  "hArr":"\u21D4",
  "harr":"\u2194",
  "harrcir":"\u2948",
  "harrw":"\u21AD",
  "Hat":"\u005E",
  "hbar":"\u210F",
  "Hcirc":"\u0124",
  "hcirc":"\u0125",
  "hearts":"\u2665",
  "heartsuit":"\u2665",
  "hellip":"\u2026",
  "hercon":"\u22B9",
  "Hfr":"\u210C",
  "hfr":"\uD835\uDD25",
  "HilbertSpace":"\u210B",
  "hksearow":"\u2925",
  "hkswarow":"\u2926",
  "hoarr":"\u21FF",
  "homtht":"\u223B",
  "hookleftarrow":"\u21A9",
  "hookrightarrow":"\u21AA",
  "Hopf":"\u210D",
  "hopf":"\uD835\uDD59",
  "horbar":"\u2015",
  "HorizontalLine":"\u2500",
  "Hscr":"\u210B",
  "hscr":"\uD835\uDCBD",
  "hslash":"\u210F",
  "Hstrok":"\u0126",
  "hstrok":"\u0127",
  "HumpDownHump":"\u224E",
  "HumpEqual":"\u224F",
  "hybull":"\u2043",
  "hyphen":"\u2010",
  "Iacute":"\u00CD",
  "iacute":"\u00ED",
  "ic":"\u2063",
  "Icirc":"\u00CE",
  "icirc":"\u00EE",
  "Icy":"\u0418",
  "icy":"\u0438",
  "Idot":"\u0130",
  "IEcy":"\u0415",
  "iecy":"\u0435",
  "iexcl":"\u00A1",
  "iff":"\u21D4",
  "Ifr":"\u2111",
  "ifr":"\uD835\uDD26",
  "Igrave":"\u00CC",
  "igrave":"\u00EC",
  "ii":"\u2148",
  "iiiint":"\u2A0C",
  "iiint":"\u222D",
  "iinfin":"\u29DC",
  "iiota":"\u2129",
  "IJlig":"\u0132",
  "ijlig":"\u0133",
  "Im":"\u2111",
  "Imacr":"\u012A",
  "imacr":"\u012B",
  "image":"\u2111",
  "ImaginaryI":"\u2148",
  "imagline":"\u2110",
  "imagpart":"\u2111",
  "imath":"\u0131",
  "imof":"\u22B7",
  "imped":"\u01B5",
  "Implies":"\u21D2",
  "in":"\u2208",
  "incare":"\u2105",
  "infin":"\u221E",
  "infintie":"\u29DD",
  "inodot":"\u0131",
  "Int":"\u222C",
  "int":"\u222B",
  "intcal":"\u22BA",
  "integers":"\u2124",
  "Integral":"\u222B",
  "intercal":"\u22BA",
  "Intersection":"\u22C2",
  "intlarhk":"\u2A17",
  "intprod":"\u2A3C",
  "InvisibleComma":"\u2063",
  "InvisibleTimes":"\u2062",
  "IOcy":"\u0401",
  "iocy":"\u0451",
  "Iogon":"\u012E",
  "iogon":"\u012F",
  "Iopf":"\uD835\uDD40",
  "iopf":"\uD835\uDD5A",
  "Iota":"\u0399",
  "iota":"\u03B9",
  "iprod":"\u2A3C",
  "iquest":"\u00BF",
  "Iscr":"\u2110",
  "iscr":"\uD835\uDCBE",
  "isin":"\u2208",
  "isindot":"\u22F5",
  "isinE":"\u22F9",
  "isins":"\u22F4",
  "isinsv":"\u22F3",
  "isinv":"\u2208",
  "it":"\u2062",
  "Itilde":"\u0128",
  "itilde":"\u0129",
  "Iukcy":"\u0406",
  "iukcy":"\u0456",
  "Iuml":"\u00CF",
  "iuml":"\u00EF",
  "Jcirc":"\u0134",
  "jcirc":"\u0135",
  "Jcy":"\u0419",
  "jcy":"\u0439",
  "Jfr":"\uD835\uDD0D",
  "jfr":"\uD835\uDD27",
  "jmath":"\u0237",
  "Jopf":"\uD835\uDD41",
  "jopf":"\uD835\uDD5B",
  "Jscr":"\uD835\uDCA5",
  "jscr":"\uD835\uDCBF",
  "Jsercy":"\u0408",
  "jsercy":"\u0458",
  "Jukcy":"\u0404",
  "jukcy":"\u0454",
  "Kappa":"\u039A",
  "kappa":"\u03BA",
  "kappav":"\u03F0",
  "Kcedil":"\u0136",
  "kcedil":"\u0137",
  "Kcy":"\u041A",
  "kcy":"\u043A",
  "Kfr":"\uD835\uDD0E",
  "kfr":"\uD835\uDD28",
  "kgreen":"\u0138",
  "KHcy":"\u0425",
  "khcy":"\u0445",
  "KJcy":"\u040C",
  "kjcy":"\u045C",
  "Kopf":"\uD835\uDD42",
  "kopf":"\uD835\uDD5C",
  "Kscr":"\uD835\uDCA6",
  "kscr":"\uD835\uDCC0",
  "lAarr":"\u21DA",
  "Lacute":"\u0139",
  "lacute":"\u013A",
  "laemptyv":"\u29B4",
  "lagran":"\u2112",
  "Lambda":"\u039B",
  "lambda":"\u03BB",
  "Lang":"\u27EA",
  "lang":"\u27E8",
  "langd":"\u2991",
  "langle":"\u27E8",
  "lap":"\u2A85",
  "Laplacetrf":"\u2112",
  "laquo":"\u00AB",
  "Larr":"\u219E",
  "lArr":"\u21D0",
  "larr":"\u2190",
  "larrb":"\u21E4",
  "larrbfs":"\u291F",
  "larrfs":"\u291D",
  "larrhk":"\u21A9",
  "larrlp":"\u21AB",
  "larrpl":"\u2939",
  "larrsim":"\u2973",
  "larrtl":"\u21A2",
  "lat":"\u2AAB",
  "lAtail":"\u291B",
  "latail":"\u2919",
  "late":"\u2AAD",
  "lates":"\u2AAD\uFE00",
  "lBarr":"\u290E",
  "lbarr":"\u290C",
  "lbbrk":"\u2772",
  "lbrace":"\u007B",
  "lbrack":"\u005B",
  "lbrke":"\u298B",
  "lbrksld":"\u298F",
  "lbrkslu":"\u298D",
  "Lcaron":"\u013D",
  "lcaron":"\u013E",
  "Lcedil":"\u013B",
  "lcedil":"\u013C",
  "lceil":"\u2308",
  "lcub":"\u007B",
  "Lcy":"\u041B",
  "lcy":"\u043B",
  "ldca":"\u2936",
  "ldquo":"\u201C",
  "ldquor":"\u201E",
  "ldrdhar":"\u2967",
  "ldrushar":"\u294B",
  "ldsh":"\u21B2",
  "lE":"\u2266",
  "le":"\u2264",
  "LeftAngleBracket":"\u27E8",
  "LeftArrow":"\u2190",
  "Leftarrow":"\u21D0",
  "leftarrow":"\u2190",
  "LeftArrowBar":"\u21E4",
  "LeftArrowRightArrow":"\u21C6",
  "leftarrowtail":"\u21A2",
  "LeftCeiling":"\u2308",
  "LeftDoubleBracket":"\u27E6",
  "LeftDownTeeVector":"\u2961",
  "LeftDownVector":"\u21C3",
  "LeftDownVectorBar":"\u2959",
  "LeftFloor":"\u230A",
  "leftharpoondown":"\u21BD",
  "leftharpoonup":"\u21BC",
  "leftleftarrows":"\u21C7",
  "LeftRightArrow":"\u2194",
  "Leftrightarrow":"\u21D4",
  "leftrightarrow":"\u2194",
  "leftrightarrows":"\u21C6",
  "leftrightharpoons":"\u21CB",
  "leftrightsquigarrow":"\u21AD",
  "LeftRightVector":"\u294E",
  "LeftTee":"\u22A3",
  "LeftTeeArrow":"\u21A4",
  "LeftTeeVector":"\u295A",
  "leftthreetimes":"\u22CB",
  "LeftTriangle":"\u22B2",
  "LeftTriangleBar":"\u29CF",
  "LeftTriangleEqual":"\u22B4",
  "LeftUpDownVector":"\u2951",
  "LeftUpTeeVector":"\u2960",
  "LeftUpVector":"\u21BF",
  "LeftUpVectorBar":"\u2958",
  "LeftVector":"\u21BC",
  "LeftVectorBar":"\u2952",
  "lEg":"\u2A8B",
  "leg":"\u22DA",
  "leq":"\u2264",
  "leqq":"\u2266",
  "leqslant":"\u2A7D",
  "les":"\u2A7D",
  "lescc":"\u2AA8",
  "lesdot":"\u2A7F",
  "lesdoto":"\u2A81",
  "lesdotor":"\u2A83",
  "lesg":"\u22DA\uFE00",
  "lesges":"\u2A93",
  "lessapprox":"\u2A85",
  "lessdot":"\u22D6",
  "lesseqgtr":"\u22DA",
  "lesseqqgtr":"\u2A8B",
  "LessEqualGreater":"\u22DA",
  "LessFullEqual":"\u2266",
  "LessGreater":"\u2276",
  "lessgtr":"\u2276",
  "LessLess":"\u2AA1",
  "lesssim":"\u2272",
  "LessSlantEqual":"\u2A7D",
  "LessTilde":"\u2272",
  "lfisht":"\u297C",
  "lfloor":"\u230A",
  "Lfr":"\uD835\uDD0F",
  "lfr":"\uD835\uDD29",
  "lg":"\u2276",
  "lgE":"\u2A91",
  "lHar":"\u2962",
  "lhard":"\u21BD",
  "lharu":"\u21BC",
  "lharul":"\u296A",
  "lhblk":"\u2584",
  "LJcy":"\u0409",
  "ljcy":"\u0459",
  "Ll":"\u22D8",
  "ll":"\u226A",
  "llarr":"\u21C7",
  "llcorner":"\u231E",
  "Lleftarrow":"\u21DA",
  "llhard":"\u296B",
  "lltri":"\u25FA",
  "Lmidot":"\u013F",
  "lmidot":"\u0140",
  "lmoust":"\u23B0",
  "lmoustache":"\u23B0",
  "lnap":"\u2A89",
  "lnapprox":"\u2A89",
  "lnE":"\u2268",
  "lne":"\u2A87",
  "lneq":"\u2A87",
  "lneqq":"\u2268",
  "lnsim":"\u22E6",
  "loang":"\u27EC",
  "loarr":"\u21FD",
  "lobrk":"\u27E6",
  "LongLeftArrow":"\u27F5",
  "Longleftarrow":"\u27F8",
  "longleftarrow":"\u27F5",
  "LongLeftRightArrow":"\u27F7",
  "Longleftrightarrow":"\u27FA",
  "longleftrightarrow":"\u27F7",
  "longmapsto":"\u27FC",
  "LongRightArrow":"\u27F6",
  "Longrightarrow":"\u27F9",
  "longrightarrow":"\u27F6",
  "looparrowleft":"\u21AB",
  "looparrowright":"\u21AC",
  "lopar":"\u2985",
  "Lopf":"\uD835\uDD43",
  "lopf":"\uD835\uDD5D",
  "loplus":"\u2A2D",
  "lotimes":"\u2A34",
  "lowast":"\u2217",
  "lowbar":"\u005F",
  "LowerLeftArrow":"\u2199",
  "LowerRightArrow":"\u2198",
  "loz":"\u25CA",
  "lozenge":"\u25CA",
  "lozf":"\u29EB",
  "lpar":"\u0028",
  "lparlt":"\u2993",
  "lrarr":"\u21C6",
  "lrcorner":"\u231F",
  "lrhar":"\u21CB",
  "lrhard":"\u296D",
  "lrm":"\u200E",
  "lrtri":"\u22BF",
  "lsaquo":"\u2039",
  "Lscr":"\u2112",
  "lscr":"\uD835\uDCC1",
  "Lsh":"\u21B0",
  "lsh":"\u21B0",
  "lsim":"\u2272",
  "lsime":"\u2A8D",
  "lsimg":"\u2A8F",
  "lsqb":"\u005B",
  "lsquo":"\u2018",
  "lsquor":"\u201A",
  "Lstrok":"\u0141",
  "lstrok":"\u0142",
  "LT":"\u003C",
  "Lt":"\u226A",
  "lt":"\u003C",
  "ltcc":"\u2AA6",
  "ltcir":"\u2A79",
  "ltdot":"\u22D6",
  "lthree":"\u22CB",
  "ltimes":"\u22C9",
  "ltlarr":"\u2976",
  "ltquest":"\u2A7B",
  "ltri":"\u25C3",
  "ltrie":"\u22B4",
  "ltrif":"\u25C2",
  "ltrPar":"\u2996",
  "lurdshar":"\u294A",
  "luruhar":"\u2966",
  "lvertneqq":"\u2268\uFE00",
  "lvnE":"\u2268\uFE00",
  "macr":"\u00AF",
  "male":"\u2642",
  "malt":"\u2720",
  "maltese":"\u2720",
  "Map":"\u2905",
  "map":"\u21A6",
  "mapsto":"\u21A6",
  "mapstodown":"\u21A7",
  "mapstoleft":"\u21A4",
  "mapstoup":"\u21A5",
  "marker":"\u25AE",
  "mcomma":"\u2A29",
  "Mcy":"\u041C",
  "mcy":"\u043C",
  "mdash":"\u2014",
  "mDDot":"\u223A",
  "measuredangle":"\u2221",
  "MediumSpace":"\u205F",
  "Mellintrf":"\u2133",
  "Mfr":"\uD835\uDD10",
  "mfr":"\uD835\uDD2A",
  "mho":"\u2127",
  "micro":"\u00B5",
  "mid":"\u2223",
  "midast":"\u002A",
  "midcir":"\u2AF0",
  "middot":"\u00B7",
  "minus":"\u2212",
  "minusb":"\u229F",
  "minusd":"\u2238",
  "minusdu":"\u2A2A",
  "MinusPlus":"\u2213",
  "mlcp":"\u2ADB",
  "mldr":"\u2026",
  "mnplus":"\u2213",
  "models":"\u22A7",
  "Mopf":"\uD835\uDD44",
  "mopf":"\uD835\uDD5E",
  "mp":"\u2213",
  "Mscr":"\u2133",
  "mscr":"\uD835\uDCC2",
  "mstpos":"\u223E",
  "Mu":"\u039C",
  "mu":"\u03BC",
  "multimap":"\u22B8",
  "mumap":"\u22B8",
  "nabla":"\u2207",
  "Nacute":"\u0143",
  "nacute":"\u0144",
  "nang":"\u2220\u20D2",
  "nap":"\u2249",
  "napE":"\u2A70\u0338",
  "napid":"\u224B\u0338",
  "napos":"\u0149",
  "napprox":"\u2249",
  "natur":"\u266E",
  "natural":"\u266E",
  "naturals":"\u2115",
  "nbsp":"\u00A0",
  "nbump":"\u224E\u0338",
  "nbumpe":"\u224F\u0338",
  "ncap":"\u2A43",
  "Ncaron":"\u0147",
  "ncaron":"\u0148",
  "Ncedil":"\u0145",
  "ncedil":"\u0146",
  "ncong":"\u2247",
  "ncongdot":"\u2A6D\u0338",
  "ncup":"\u2A42",
  "Ncy":"\u041D",
  "ncy":"\u043D",
  "ndash":"\u2013",
  "ne":"\u2260",
  "nearhk":"\u2924",
  "neArr":"\u21D7",
  "nearr":"\u2197",
  "nearrow":"\u2197",
  "nedot":"\u2250\u0338",
  "NegativeMediumSpace":"\u200B",
  "NegativeThickSpace":"\u200B",
  "NegativeThinSpace":"\u200B",
  "NegativeVeryThinSpace":"\u200B",
  "nequiv":"\u2262",
  "nesear":"\u2928",
  "nesim":"\u2242\u0338",
  "NestedGreaterGreater":"\u226B",
  "NestedLessLess":"\u226A",
  "NewLine":"\u000A",
  "nexist":"\u2204",
  "nexists":"\u2204",
  "Nfr":"\uD835\uDD11",
  "nfr":"\uD835\uDD2B",
  "ngE":"\u2267\u0338",
  "nge":"\u2271",
  "ngeq":"\u2271",
  "ngeqq":"\u2267\u0338",
  "ngeqslant":"\u2A7E\u0338",
  "nges":"\u2A7E\u0338",
  "nGg":"\u22D9\u0338",
  "ngsim":"\u2275",
  "nGt":"\u226B\u20D2",
  "ngt":"\u226F",
  "ngtr":"\u226F",
  "nGtv":"\u226B\u0338",
  "nhArr":"\u21CE",
  "nharr":"\u21AE",
  "nhpar":"\u2AF2",
  "ni":"\u220B",
  "nis":"\u22FC",
  "nisd":"\u22FA",
  "niv":"\u220B",
  "NJcy":"\u040A",
  "njcy":"\u045A",
  "nlArr":"\u21CD",
  "nlarr":"\u219A",
  "nldr":"\u2025",
  "nlE":"\u2266\u0338",
  "nle":"\u2270",
  "nLeftarrow":"\u21CD",
  "nleftarrow":"\u219A",
  "nLeftrightarrow":"\u21CE",
  "nleftrightarrow":"\u21AE",
  "nleq":"\u2270",
  "nleqq":"\u2266\u0338",
  "nleqslant":"\u2A7D\u0338",
  "nles":"\u2A7D\u0338",
  "nless":"\u226E",
  "nLl":"\u22D8\u0338",
  "nlsim":"\u2274",
  "nLt":"\u226A\u20D2",
  "nlt":"\u226E",
  "nltri":"\u22EA",
  "nltrie":"\u22EC",
  "nLtv":"\u226A\u0338",
  "nmid":"\u2224",
  "NoBreak":"\u2060",
  "NonBreakingSpace":"\u00A0",
  "Nopf":"\u2115",
  "nopf":"\uD835\uDD5F",
  "Not":"\u2AEC",
  "not":"\u00AC",
  "NotCongruent":"\u2262",
  "NotCupCap":"\u226D",
  "NotDoubleVerticalBar":"\u2226",
  "NotElement":"\u2209",
  "NotEqual":"\u2260",
  "NotEqualTilde":"\u2242\u0338",
  "NotExists":"\u2204",
  "NotGreater":"\u226F",
  "NotGreaterEqual":"\u2271",
  "NotGreaterFullEqual":"\u2267\u0338",
  "NotGreaterGreater":"\u226B\u0338",
  "NotGreaterLess":"\u2279",
  "NotGreaterSlantEqual":"\u2A7E\u0338",
  "NotGreaterTilde":"\u2275",
  "NotHumpDownHump":"\u224E\u0338",
  "NotHumpEqual":"\u224F\u0338",
  "notin":"\u2209",
  "notindot":"\u22F5\u0338",
  "notinE":"\u22F9\u0338",
  "notinva":"\u2209",
  "notinvb":"\u22F7",
  "notinvc":"\u22F6",
  "NotLeftTriangle":"\u22EA",
  "NotLeftTriangleBar":"\u29CF\u0338",
  "NotLeftTriangleEqual":"\u22EC",
  "NotLess":"\u226E",
  "NotLessEqual":"\u2270",
  "NotLessGreater":"\u2278",
  "NotLessLess":"\u226A\u0338",
  "NotLessSlantEqual":"\u2A7D\u0338",
  "NotLessTilde":"\u2274",
  "NotNestedGreaterGreater":"\u2AA2\u0338",
  "NotNestedLessLess":"\u2AA1\u0338",
  "notni":"\u220C",
  "notniva":"\u220C",
  "notnivb":"\u22FE",
  "notnivc":"\u22FD",
  "NotPrecedes":"\u2280",
  "NotPrecedesEqual":"\u2AAF\u0338",
  "NotPrecedesSlantEqual":"\u22E0",
  "NotReverseElement":"\u220C",
  "NotRightTriangle":"\u22EB",
  "NotRightTriangleBar":"\u29D0\u0338",
  "NotRightTriangleEqual":"\u22ED",
  "NotSquareSubset":"\u228F\u0338",
  "NotSquareSubsetEqual":"\u22E2",
  "NotSquareSuperset":"\u2290\u0338",
  "NotSquareSupersetEqual":"\u22E3",
  "NotSubset":"\u2282\u20D2",
  "NotSubsetEqual":"\u2288",
  "NotSucceeds":"\u2281",
  "NotSucceedsEqual":"\u2AB0\u0338",
  "NotSucceedsSlantEqual":"\u22E1",
  "NotSucceedsTilde":"\u227F\u0338",
  "NotSuperset":"\u2283\u20D2",
  "NotSupersetEqual":"\u2289",
  "NotTilde":"\u2241",
  "NotTildeEqual":"\u2244",
  "NotTildeFullEqual":"\u2247",
  "NotTildeTilde":"\u2249",
  "NotVerticalBar":"\u2224",
  "npar":"\u2226",
  "nparallel":"\u2226",
  "nparsl":"\u2AFD\u20E5",
  "npart":"\u2202\u0338",
  "npolint":"\u2A14",
  "npr":"\u2280",
  "nprcue":"\u22E0",
  "npre":"\u2AAF\u0338",
  "nprec":"\u2280",
  "npreceq":"\u2AAF\u0338",
  "nrArr":"\u21CF",
  "nrarr":"\u219B",
  "nrarrc":"\u2933\u0338",
  "nrarrw":"\u219D\u0338",
  "nRightarrow":"\u21CF",
  "nrightarrow":"\u219B",
  "nrtri":"\u22EB",
  "nrtrie":"\u22ED",
  "nsc":"\u2281",
  "nsccue":"\u22E1",
  "nsce":"\u2AB0\u0338",
  "Nscr":"\uD835\uDCA9",
  "nscr":"\uD835\uDCC3",
  "nshortmid":"\u2224",
  "nshortparallel":"\u2226",
  "nsim":"\u2241",
  "nsime":"\u2244",
  "nsimeq":"\u2244",
  "nsmid":"\u2224",
  "nspar":"\u2226",
  "nsqsube":"\u22E2",
  "nsqsupe":"\u22E3",
  "nsub":"\u2284",
  "nsubE":"\u2AC5\u0338",
  "nsube":"\u2288",
  "nsubset":"\u2282\u20D2",
  "nsubseteq":"\u2288",
  "nsubseteqq":"\u2AC5\u0338",
  "nsucc":"\u2281",
  "nsucceq":"\u2AB0\u0338",
  "nsup":"\u2285",
  "nsupE":"\u2AC6\u0338",
  "nsupe":"\u2289",
  "nsupset":"\u2283\u20D2",
  "nsupseteq":"\u2289",
  "nsupseteqq":"\u2AC6\u0338",
  "ntgl":"\u2279",
  "Ntilde":"\u00D1",
  "ntilde":"\u00F1",
  "ntlg":"\u2278",
  "ntriangleleft":"\u22EA",
  "ntrianglelefteq":"\u22EC",
  "ntriangleright":"\u22EB",
  "ntrianglerighteq":"\u22ED",
  "Nu":"\u039D",
  "nu":"\u03BD",
  "num":"\u0023",
  "numero":"\u2116",
  "numsp":"\u2007",
  "nvap":"\u224D\u20D2",
  "nVDash":"\u22AF",
  "nVdash":"\u22AE",
  "nvDash":"\u22AD",
  "nvdash":"\u22AC",
  "nvge":"\u2265\u20D2",
  "nvgt":"\u003E\u20D2",
  "nvHarr":"\u2904",
  "nvinfin":"\u29DE",
  "nvlArr":"\u2902",
  "nvle":"\u2264\u20D2",
  "nvlt":"\u003C\u20D2",
  "nvltrie":"\u22B4\u20D2",
  "nvrArr":"\u2903",
  "nvrtrie":"\u22B5\u20D2",
  "nvsim":"\u223C\u20D2",
  "nwarhk":"\u2923",
  "nwArr":"\u21D6",
  "nwarr":"\u2196",
  "nwarrow":"\u2196",
  "nwnear":"\u2927",
  "Oacute":"\u00D3",
  "oacute":"\u00F3",
  "oast":"\u229B",
  "ocir":"\u229A",
  "Ocirc":"\u00D4",
  "ocirc":"\u00F4",
  "Ocy":"\u041E",
  "ocy":"\u043E",
  "odash":"\u229D",
  "Odblac":"\u0150",
  "odblac":"\u0151",
  "odiv":"\u2A38",
  "odot":"\u2299",
  "odsold":"\u29BC",
  "OElig":"\u0152",
  "oelig":"\u0153",
  "ofcir":"\u29BF",
  "Ofr":"\uD835\uDD12",
  "ofr":"\uD835\uDD2C",
  "ogon":"\u02DB",
  "Ograve":"\u00D2",
  "ograve":"\u00F2",
  "ogt":"\u29C1",
  "ohbar":"\u29B5",
  "ohm":"\u03A9",
  "oint":"\u222E",
  "olarr":"\u21BA",
  "olcir":"\u29BE",
  "olcross":"\u29BB",
  "oline":"\u203E",
  "olt":"\u29C0",
  "Omacr":"\u014C",
  "omacr":"\u014D",
  "Omega":"\u03A9",
  "omega":"\u03C9",
  "Omicron":"\u039F",
  "omicron":"\u03BF",
  "omid":"\u29B6",
  "ominus":"\u2296",
  "Oopf":"\uD835\uDD46",
  "oopf":"\uD835\uDD60",
  "opar":"\u29B7",
  "OpenCurlyDoubleQuote":"\u201C",
  "OpenCurlyQuote":"\u2018",
  "operp":"\u29B9",
  "oplus":"\u2295",
  "Or":"\u2A54",
  "or":"\u2228",
  "orarr":"\u21BB",
  "ord":"\u2A5D",
  "order":"\u2134",
  "orderof":"\u2134",
  "ordf":"\u00AA",
  "ordm":"\u00BA",
  "origof":"\u22B6",
  "oror":"\u2A56",
  "orslope":"\u2A57",
  "orv":"\u2A5B",
  "oS":"\u24C8",
  "Oscr":"\uD835\uDCAA",
  "oscr":"\u2134",
  "Oslash":"\u00D8",
  "oslash":"\u00F8",
  "osol":"\u2298",
  "Otilde":"\u00D5",
  "otilde":"\u00F5",
  "Otimes":"\u2A37",
  "otimes":"\u2297",
  "otimesas":"\u2A36",
  "Ouml":"\u00D6",
  "ouml":"\u00F6",
  "ovbar":"\u233D",
  "OverBar":"\u203E",
  "OverBrace":"\u23DE",
  "OverBracket":"\u23B4",
  "OverParenthesis":"\u23DC",
  "par":"\u2225",
  "para":"\u00B6",
  "parallel":"\u2225",
  "parsim":"\u2AF3",
  "parsl":"\u2AFD",
  "part":"\u2202",
  "PartialD":"\u2202",
  "Pcy":"\u041F",
  "pcy":"\u043F",
  "percnt":"\u0025",
  "period":"\u002E",
  "permil":"\u2030",
  "perp":"\u22A5",
  "pertenk":"\u2031",
  "Pfr":"\uD835\uDD13",
  "pfr":"\uD835\uDD2D",
  "Phi":"\u03A6",
  "phi":"\u03C6",
  "phiv":"\u03D5",
  "phmmat":"\u2133",
  "phone":"\u260E",
  "Pi":"\u03A0",
  "pi":"\u03C0",
  "pitchfork":"\u22D4",
  "piv":"\u03D6",
  "planck":"\u210F",
  "planckh":"\u210E",
  "plankv":"\u210F",
  "plus":"\u002B",
  "plusacir":"\u2A23",
  "plusb":"\u229E",
  "pluscir":"\u2A22",
  "plusdo":"\u2214",
  "plusdu":"\u2A25",
  "pluse":"\u2A72",
  "PlusMinus":"\u00B1",
  "plusmn":"\u00B1",
  "plussim":"\u2A26",
  "plustwo":"\u2A27",
  "pm":"\u00B1",
  "Poincareplane":"\u210C",
  "pointint":"\u2A15",
  "Popf":"\u2119",
  "popf":"\uD835\uDD61",
  "pound":"\u00A3",
  "Pr":"\u2ABB",
  "pr":"\u227A",
  "prap":"\u2AB7",
  "prcue":"\u227C",
  "prE":"\u2AB3",
  "pre":"\u2AAF",
  "prec":"\u227A",
  "precapprox":"\u2AB7",
  "preccurlyeq":"\u227C",
  "Precedes":"\u227A",
  "PrecedesEqual":"\u2AAF",
  "PrecedesSlantEqual":"\u227C",
  "PrecedesTilde":"\u227E",
  "preceq":"\u2AAF",
  "precnapprox":"\u2AB9",
  "precneqq":"\u2AB5",
  "precnsim":"\u22E8",
  "precsim":"\u227E",
  "Prime":"\u2033",
  "prime":"\u2032",
  "primes":"\u2119",
  "prnap":"\u2AB9",
  "prnE":"\u2AB5",
  "prnsim":"\u22E8",
  "prod":"\u220F",
  "Product":"\u220F",
  "profalar":"\u232E",
  "profline":"\u2312",
  "profsurf":"\u2313",
  "prop":"\u221D",
  "Proportion":"\u2237",
  "Proportional":"\u221D",
  "propto":"\u221D",
  "prsim":"\u227E",
  "prurel":"\u22B0",
  "Pscr":"\uD835\uDCAB",
  "pscr":"\uD835\uDCC5",
  "Psi":"\u03A8",
  "psi":"\u03C8",
  "puncsp":"\u2008",
  "Qfr":"\uD835\uDD14",
  "qfr":"\uD835\uDD2E",
  "qint":"\u2A0C",
  "Qopf":"\u211A",
  "qopf":"\uD835\uDD62",
  "qprime":"\u2057",
  "Qscr":"\uD835\uDCAC",
  "qscr":"\uD835\uDCC6",
  "quaternions":"\u210D",
  "quatint":"\u2A16",
  "quest":"\u003F",
  "questeq":"\u225F",
  "QUOT":"\u0022",
  "quot":"\u0022",
  "rAarr":"\u21DB",
  "race":"\u223D\u0331",
  "Racute":"\u0154",
  "racute":"\u0155",
  "radic":"\u221A",
  "raemptyv":"\u29B3",
  "Rang":"\u27EB",
  "rang":"\u27E9",
  "rangd":"\u2992",
  "range":"\u29A5",
  "rangle":"\u27E9",
  "raquo":"\u00BB",
  "Rarr":"\u21A0",
  "rArr":"\u21D2",
  "rarr":"\u2192",
  "rarrap":"\u2975",
  "rarrb":"\u21E5",
  "rarrbfs":"\u2920",
  "rarrc":"\u2933",
  "rarrfs":"\u291E",
  "rarrhk":"\u21AA",
  "rarrlp":"\u21AC",
  "rarrpl":"\u2945",
  "rarrsim":"\u2974",
  "Rarrtl":"\u2916",
  "rarrtl":"\u21A3",
  "rarrw":"\u219D",
  "rAtail":"\u291C",
  "ratail":"\u291A",
  "ratio":"\u2236",
  "rationals":"\u211A",
  "RBarr":"\u2910",
  "rBarr":"\u290F",
  "rbarr":"\u290D",
  "rbbrk":"\u2773",
  "rbrace":"\u007D",
  "rbrack":"\u005D",
  "rbrke":"\u298C",
  "rbrksld":"\u298E",
  "rbrkslu":"\u2990",
  "Rcaron":"\u0158",
  "rcaron":"\u0159",
  "Rcedil":"\u0156",
  "rcedil":"\u0157",
  "rceil":"\u2309",
  "rcub":"\u007D",
  "Rcy":"\u0420",
  "rcy":"\u0440",
  "rdca":"\u2937",
  "rdldhar":"\u2969",
  "rdquo":"\u201D",
  "rdquor":"\u201D",
  "rdsh":"\u21B3",
  "Re":"\u211C",
  "real":"\u211C",
  "realine":"\u211B",
  "realpart":"\u211C",
  "reals":"\u211D",
  "rect":"\u25AD",
  "REG":"\u00AE",
  "reg":"\u00AE",
  "ReverseElement":"\u220B",
  "ReverseEquilibrium":"\u21CB",
  "ReverseUpEquilibrium":"\u296F",
  "rfisht":"\u297D",
  "rfloor":"\u230B",
  "Rfr":"\u211C",
  "rfr":"\uD835\uDD2F",
  "rHar":"\u2964",
  "rhard":"\u21C1",
  "rharu":"\u21C0",
  "rharul":"\u296C",
  "Rho":"\u03A1",
  "rho":"\u03C1",
  "rhov":"\u03F1",
  "RightAngleBracket":"\u27E9",
  "RightArrow":"\u2192",
  "Rightarrow":"\u21D2",
  "rightarrow":"\u2192",
  "RightArrowBar":"\u21E5",
  "RightArrowLeftArrow":"\u21C4",
  "rightarrowtail":"\u21A3",
  "RightCeiling":"\u2309",
  "RightDoubleBracket":"\u27E7",
  "RightDownTeeVector":"\u295D",
  "RightDownVector":"\u21C2",
  "RightDownVectorBar":"\u2955",
  "RightFloor":"\u230B",
  "rightharpoondown":"\u21C1",
  "rightharpoonup":"\u21C0",
  "rightleftarrows":"\u21C4",
  "rightleftharpoons":"\u21CC",
  "rightrightarrows":"\u21C9",
  "rightsquigarrow":"\u219D",
  "RightTee":"\u22A2",
  "RightTeeArrow":"\u21A6",
  "RightTeeVector":"\u295B",
  "rightthreetimes":"\u22CC",
  "RightTriangle":"\u22B3",
  "RightTriangleBar":"\u29D0",
  "RightTriangleEqual":"\u22B5",
  "RightUpDownVector":"\u294F",
  "RightUpTeeVector":"\u295C",
  "RightUpVector":"\u21BE",
  "RightUpVectorBar":"\u2954",
  "RightVector":"\u21C0",
  "RightVectorBar":"\u2953",
  "ring":"\u02DA",
  "risingdotseq":"\u2253",
  "rlarr":"\u21C4",
  "rlhar":"\u21CC",
  "rlm":"\u200F",
  "rmoust":"\u23B1",
  "rmoustache":"\u23B1",
  "rnmid":"\u2AEE",
  "roang":"\u27ED",
  "roarr":"\u21FE",
  "robrk":"\u27E7",
  "ropar":"\u2986",
  "Ropf":"\u211D",
  "ropf":"\uD835\uDD63",
  "roplus":"\u2A2E",
  "rotimes":"\u2A35",
  "RoundImplies":"\u2970",
  "rpar":"\u0029",
  "rpargt":"\u2994",
  "rppolint":"\u2A12",
  "rrarr":"\u21C9",
  "Rrightarrow":"\u21DB",
  "rsaquo":"\u203A",
  "Rscr":"\u211B",
  "rscr":"\uD835\uDCC7",
  "Rsh":"\u21B1",
  "rsh":"\u21B1",
  "rsqb":"\u005D",
  "rsquo":"\u2019",
  "rsquor":"\u2019",
  "rthree":"\u22CC",
  "rtimes":"\u22CA",
  "rtri":"\u25B9",
  "rtrie":"\u22B5",
  "rtrif":"\u25B8",
  "rtriltri":"\u29CE",
  "RuleDelayed":"\u29F4",
  "ruluhar":"\u2968",
  "rx":"\u211E",
  "Sacute":"\u015A",
  "sacute":"\u015B",
  "sbquo":"\u201A",
  "Sc":"\u2ABC",
  "sc":"\u227B",
  "scap":"\u2AB8",
  "Scaron":"\u0160",
  "scaron":"\u0161",
  "sccue":"\u227D",
  "scE":"\u2AB4",
  "sce":"\u2AB0",
  "Scedil":"\u015E",
  "scedil":"\u015F",
  "Scirc":"\u015C",
  "scirc":"\u015D",
  "scnap":"\u2ABA",
  "scnE":"\u2AB6",
  "scnsim":"\u22E9",
  "scpolint":"\u2A13",
  "scsim":"\u227F",
  "Scy":"\u0421",
  "scy":"\u0441",
  "sdot":"\u22C5",
  "sdotb":"\u22A1",
  "sdote":"\u2A66",
  "searhk":"\u2925",
  "seArr":"\u21D8",
  "searr":"\u2198",
  "searrow":"\u2198",
  "sect":"\u00A7",
  "semi":"\u003B",
  "seswar":"\u2929",
  "setminus":"\u2216",
  "setmn":"\u2216",
  "sext":"\u2736",
  "Sfr":"\uD835\uDD16",
  "sfr":"\uD835\uDD30",
  "sfrown":"\u2322",
  "sharp":"\u266F",
  "SHCHcy":"\u0429",
  "shchcy":"\u0449",
  "SHcy":"\u0428",
  "shcy":"\u0448",
  "ShortDownArrow":"\u2193",
  "ShortLeftArrow":"\u2190",
  "shortmid":"\u2223",
  "shortparallel":"\u2225",
  "ShortRightArrow":"\u2192",
  "ShortUpArrow":"\u2191",
  "shy":"\u00AD",
  "Sigma":"\u03A3",
  "sigma":"\u03C3",
  "sigmaf":"\u03C2",
  "sigmav":"\u03C2",
  "sim":"\u223C",
  "simdot":"\u2A6A",
  "sime":"\u2243",
  "simeq":"\u2243",
  "simg":"\u2A9E",
  "simgE":"\u2AA0",
  "siml":"\u2A9D",
  "simlE":"\u2A9F",
  "simne":"\u2246",
  "simplus":"\u2A24",
  "simrarr":"\u2972",
  "slarr":"\u2190",
  "SmallCircle":"\u2218",
  "smallsetminus":"\u2216",
  "smashp":"\u2A33",
  "smeparsl":"\u29E4",
  "smid":"\u2223",
  "smile":"\u2323",
  "smt":"\u2AAA",
  "smte":"\u2AAC",
  "smtes":"\u2AAC\uFE00",
  "SOFTcy":"\u042C",
  "softcy":"\u044C",
  "sol":"\u002F",
  "solb":"\u29C4",
  "solbar":"\u233F",
  "Sopf":"\uD835\uDD4A",
  "sopf":"\uD835\uDD64",
  "spades":"\u2660",
  "spadesuit":"\u2660",
  "spar":"\u2225",
  "sqcap":"\u2293",
  "sqcaps":"\u2293\uFE00",
  "sqcup":"\u2294",
  "sqcups":"\u2294\uFE00",
  "Sqrt":"\u221A",
  "sqsub":"\u228F",
  "sqsube":"\u2291",
  "sqsubset":"\u228F",
  "sqsubseteq":"\u2291",
  "sqsup":"\u2290",
  "sqsupe":"\u2292",
  "sqsupset":"\u2290",
  "sqsupseteq":"\u2292",
  "squ":"\u25A1",
  "Square":"\u25A1",
  "square":"\u25A1",
  "SquareIntersection":"\u2293",
  "SquareSubset":"\u228F",
  "SquareSubsetEqual":"\u2291",
  "SquareSuperset":"\u2290",
  "SquareSupersetEqual":"\u2292",
  "SquareUnion":"\u2294",
  "squarf":"\u25AA",
  "squf":"\u25AA",
  "srarr":"\u2192",
  "Sscr":"\uD835\uDCAE",
  "sscr":"\uD835\uDCC8",
  "ssetmn":"\u2216",
  "ssmile":"\u2323",
  "sstarf":"\u22C6",
  "Star":"\u22C6",
  "star":"\u2606",
  "starf":"\u2605",
  "straightepsilon":"\u03F5",
  "straightphi":"\u03D5",
  "strns":"\u00AF",
  "Sub":"\u22D0",
  "sub":"\u2282",
  "subdot":"\u2ABD",
  "subE":"\u2AC5",
  "sube":"\u2286",
  "subedot":"\u2AC3",
  "submult":"\u2AC1",
  "subnE":"\u2ACB",
  "subne":"\u228A",
  "subplus":"\u2ABF",
  "subrarr":"\u2979",
  "Subset":"\u22D0",
  "subset":"\u2282",
  "subseteq":"\u2286",
  "subseteqq":"\u2AC5",
  "SubsetEqual":"\u2286",
  "subsetneq":"\u228A",
  "subsetneqq":"\u2ACB",
  "subsim":"\u2AC7",
  "subsub":"\u2AD5",
  "subsup":"\u2AD3",
  "succ":"\u227B",
  "succapprox":"\u2AB8",
  "succcurlyeq":"\u227D",
  "Succeeds":"\u227B",
  "SucceedsEqual":"\u2AB0",
  "SucceedsSlantEqual":"\u227D",
  "SucceedsTilde":"\u227F",
  "succeq":"\u2AB0",
  "succnapprox":"\u2ABA",
  "succneqq":"\u2AB6",
  "succnsim":"\u22E9",
  "succsim":"\u227F",
  "SuchThat":"\u220B",
  "Sum":"\u2211",
  "sum":"\u2211",
  "sung":"\u266A",
  "Sup":"\u22D1",
  "sup":"\u2283",
  "sup1":"\u00B9",
  "sup2":"\u00B2",
  "sup3":"\u00B3",
  "supdot":"\u2ABE",
  "supdsub":"\u2AD8",
  "supE":"\u2AC6",
  "supe":"\u2287",
  "supedot":"\u2AC4",
  "Superset":"\u2283",
  "SupersetEqual":"\u2287",
  "suphsol":"\u27C9",
  "suphsub":"\u2AD7",
  "suplarr":"\u297B",
  "supmult":"\u2AC2",
  "supnE":"\u2ACC",
  "supne":"\u228B",
  "supplus":"\u2AC0",
  "Supset":"\u22D1",
  "supset":"\u2283",
  "supseteq":"\u2287",
  "supseteqq":"\u2AC6",
  "supsetneq":"\u228B",
  "supsetneqq":"\u2ACC",
  "supsim":"\u2AC8",
  "supsub":"\u2AD4",
  "supsup":"\u2AD6",
  "swarhk":"\u2926",
  "swArr":"\u21D9",
  "swarr":"\u2199",
  "swarrow":"\u2199",
  "swnwar":"\u292A",
  "szlig":"\u00DF",
  "Tab":"\u0009",
  "target":"\u2316",
  "Tau":"\u03A4",
  "tau":"\u03C4",
  "tbrk":"\u23B4",
  "Tcaron":"\u0164",
  "tcaron":"\u0165",
  "Tcedil":"\u0162",
  "tcedil":"\u0163",
  "Tcy":"\u0422",
  "tcy":"\u0442",
  "tdot":"\u20DB",
  "telrec":"\u2315",
  "Tfr":"\uD835\uDD17",
  "tfr":"\uD835\uDD31",
  "there4":"\u2234",
  "Therefore":"\u2234",
  "therefore":"\u2234",
  "Theta":"\u0398",
  "theta":"\u03B8",
  "thetasym":"\u03D1",
  "thetav":"\u03D1",
  "thickapprox":"\u2248",
  "thicksim":"\u223C",
  "ThickSpace":"\u205F\u200A",
  "thinsp":"\u2009",
  "ThinSpace":"\u2009",
  "thkap":"\u2248",
  "thksim":"\u223C",
  "THORN":"\u00DE",
  "thorn":"\u00FE",
  "Tilde":"\u223C",
  "tilde":"\u02DC",
  "TildeEqual":"\u2243",
  "TildeFullEqual":"\u2245",
  "TildeTilde":"\u2248",
  "times":"\u00D7",
  "timesb":"\u22A0",
  "timesbar":"\u2A31",
  "timesd":"\u2A30",
  "tint":"\u222D",
  "toea":"\u2928",
  "top":"\u22A4",
  "topbot":"\u2336",
  "topcir":"\u2AF1",
  "Topf":"\uD835\uDD4B",
  "topf":"\uD835\uDD65",
  "topfork":"\u2ADA",
  "tosa":"\u2929",
  "tprime":"\u2034",
  "TRADE":"\u2122",
  "trade":"\u2122",
  "triangle":"\u25B5",
  "triangledown":"\u25BF",
  "triangleleft":"\u25C3",
  "trianglelefteq":"\u22B4",
  "triangleq":"\u225C",
  "triangleright":"\u25B9",
  "trianglerighteq":"\u22B5",
  "tridot":"\u25EC",
  "trie":"\u225C",
  "triminus":"\u2A3A",
  "TripleDot":"\u20DB",
  "triplus":"\u2A39",
  "trisb":"\u29CD",
  "tritime":"\u2A3B",
  "trpezium":"\u23E2",
  "Tscr":"\uD835\uDCAF",
  "tscr":"\uD835\uDCC9",
  "TScy":"\u0426",
  "tscy":"\u0446",
  "TSHcy":"\u040B",
  "tshcy":"\u045B",
  "Tstrok":"\u0166",
  "tstrok":"\u0167",
  "twixt":"\u226C",
  "twoheadleftarrow":"\u219E",
  "twoheadrightarrow":"\u21A0",
  "Uacute":"\u00DA",
  "uacute":"\u00FA",
  "Uarr":"\u219F",
  "uArr":"\u21D1",
  "uarr":"\u2191",
  "Uarrocir":"\u2949",
  "Ubrcy":"\u040E",
  "ubrcy":"\u045E",
  "Ubreve":"\u016C",
  "ubreve":"\u016D",
  "Ucirc":"\u00DB",
  "ucirc":"\u00FB",
  "Ucy":"\u0423",
  "ucy":"\u0443",
  "udarr":"\u21C5",
  "Udblac":"\u0170",
  "udblac":"\u0171",
  "udhar":"\u296E",
  "ufisht":"\u297E",
  "Ufr":"\uD835\uDD18",
  "ufr":"\uD835\uDD32",
  "Ugrave":"\u00D9",
  "ugrave":"\u00F9",
  "uHar":"\u2963",
  "uharl":"\u21BF",
  "uharr":"\u21BE",
  "uhblk":"\u2580",
  "ulcorn":"\u231C",
  "ulcorner":"\u231C",
  "ulcrop":"\u230F",
  "ultri":"\u25F8",
  "Umacr":"\u016A",
  "umacr":"\u016B",
  "uml":"\u00A8",
  "UnderBar":"\u005F",
  "UnderBrace":"\u23DF",
  "UnderBracket":"\u23B5",
  "UnderParenthesis":"\u23DD",
  "Union":"\u22C3",
  "UnionPlus":"\u228E",
  "Uogon":"\u0172",
  "uogon":"\u0173",
  "Uopf":"\uD835\uDD4C",
  "uopf":"\uD835\uDD66",
  "UpArrow":"\u2191",
  "Uparrow":"\u21D1",
  "uparrow":"\u2191",
  "UpArrowBar":"\u2912",
  "UpArrowDownArrow":"\u21C5",
  "UpDownArrow":"\u2195",
  "Updownarrow":"\u21D5",
  "updownarrow":"\u2195",
  "UpEquilibrium":"\u296E",
  "upharpoonleft":"\u21BF",
  "upharpoonright":"\u21BE",
  "uplus":"\u228E",
  "UpperLeftArrow":"\u2196",
  "UpperRightArrow":"\u2197",
  "Upsi":"\u03D2",
  "upsi":"\u03C5",
  "upsih":"\u03D2",
  "Upsilon":"\u03A5",
  "upsilon":"\u03C5",
  "UpTee":"\u22A5",
  "UpTeeArrow":"\u21A5",
  "upuparrows":"\u21C8",
  "urcorn":"\u231D",
  "urcorner":"\u231D",
  "urcrop":"\u230E",
  "Uring":"\u016E",
  "uring":"\u016F",
  "urtri":"\u25F9",
  "Uscr":"\uD835\uDCB0",
  "uscr":"\uD835\uDCCA",
  "utdot":"\u22F0",
  "Utilde":"\u0168",
  "utilde":"\u0169",
  "utri":"\u25B5",
  "utrif":"\u25B4",
  "uuarr":"\u21C8",
  "Uuml":"\u00DC",
  "uuml":"\u00FC",
  "uwangle":"\u29A7",
  "vangrt":"\u299C",
  "varepsilon":"\u03F5",
  "varkappa":"\u03F0",
  "varnothing":"\u2205",
  "varphi":"\u03D5",
  "varpi":"\u03D6",
  "varpropto":"\u221D",
  "vArr":"\u21D5",
  "varr":"\u2195",
  "varrho":"\u03F1",
  "varsigma":"\u03C2",
  "varsubsetneq":"\u228A\uFE00",
  "varsubsetneqq":"\u2ACB\uFE00",
  "varsupsetneq":"\u228B\uFE00",
  "varsupsetneqq":"\u2ACC\uFE00",
  "vartheta":"\u03D1",
  "vartriangleleft":"\u22B2",
  "vartriangleright":"\u22B3",
  "Vbar":"\u2AEB",
  "vBar":"\u2AE8",
  "vBarv":"\u2AE9",
  "Vcy":"\u0412",
  "vcy":"\u0432",
  "VDash":"\u22AB",
  "Vdash":"\u22A9",
  "vDash":"\u22A8",
  "vdash":"\u22A2",
  "Vdashl":"\u2AE6",
  "Vee":"\u22C1",
  "vee":"\u2228",
  "veebar":"\u22BB",
  "veeeq":"\u225A",
  "vellip":"\u22EE",
  "Verbar":"\u2016",
  "verbar":"\u007C",
  "Vert":"\u2016",
  "vert":"\u007C",
  "VerticalBar":"\u2223",
  "VerticalLine":"\u007C",
  "VerticalSeparator":"\u2758",
  "VerticalTilde":"\u2240",
  "VeryThinSpace":"\u200A",
  "Vfr":"\uD835\uDD19",
  "vfr":"\uD835\uDD33",
  "vltri":"\u22B2",
  "vnsub":"\u2282\u20D2",
  "vnsup":"\u2283\u20D2",
  "Vopf":"\uD835\uDD4D",
  "vopf":"\uD835\uDD67",
  "vprop":"\u221D",
  "vrtri":"\u22B3",
  "Vscr":"\uD835\uDCB1",
  "vscr":"\uD835\uDCCB",
  "vsubnE":"\u2ACB\uFE00",
  "vsubne":"\u228A\uFE00",
  "vsupnE":"\u2ACC\uFE00",
  "vsupne":"\u228B\uFE00",
  "Vvdash":"\u22AA",
  "vzigzag":"\u299A",
  "Wcirc":"\u0174",
  "wcirc":"\u0175",
  "wedbar":"\u2A5F",
  "Wedge":"\u22C0",
  "wedge":"\u2227",
  "wedgeq":"\u2259",
  "weierp":"\u2118",
  "Wfr":"\uD835\uDD1A",
  "wfr":"\uD835\uDD34",
  "Wopf":"\uD835\uDD4E",
  "wopf":"\uD835\uDD68",
  "wp":"\u2118",
  "wr":"\u2240",
  "wreath":"\u2240",
  "Wscr":"\uD835\uDCB2",
  "wscr":"\uD835\uDCCC",
  "xcap":"\u22C2",
  "xcirc":"\u25EF",
  "xcup":"\u22C3",
  "xdtri":"\u25BD",
  "Xfr":"\uD835\uDD1B",
  "xfr":"\uD835\uDD35",
  "xhArr":"\u27FA",
  "xharr":"\u27F7",
  "Xi":"\u039E",
  "xi":"\u03BE",
  "xlArr":"\u27F8",
  "xlarr":"\u27F5",
  "xmap":"\u27FC",
  "xnis":"\u22FB",
  "xodot":"\u2A00",
  "Xopf":"\uD835\uDD4F",
  "xopf":"\uD835\uDD69",
  "xoplus":"\u2A01",
  "xotime":"\u2A02",
  "xrArr":"\u27F9",
  "xrarr":"\u27F6",
  "Xscr":"\uD835\uDCB3",
  "xscr":"\uD835\uDCCD",
  "xsqcup":"\u2A06",
  "xuplus":"\u2A04",
  "xutri":"\u25B3",
  "xvee":"\u22C1",
  "xwedge":"\u22C0",
  "Yacute":"\u00DD",
  "yacute":"\u00FD",
  "YAcy":"\u042F",
  "yacy":"\u044F",
  "Ycirc":"\u0176",
  "ycirc":"\u0177",
  "Ycy":"\u042B",
  "ycy":"\u044B",
  "yen":"\u00A5",
  "Yfr":"\uD835\uDD1C",
  "yfr":"\uD835\uDD36",
  "YIcy":"\u0407",
  "yicy":"\u0457",
  "Yopf":"\uD835\uDD50",
  "yopf":"\uD835\uDD6A",
  "Yscr":"\uD835\uDCB4",
  "yscr":"\uD835\uDCCE",
  "YUcy":"\u042E",
  "yucy":"\u044E",
  "Yuml":"\u0178",
  "yuml":"\u00FF",
  "Zacute":"\u0179",
  "zacute":"\u017A",
  "Zcaron":"\u017D",
  "zcaron":"\u017E",
  "Zcy":"\u0417",
  "zcy":"\u0437",
  "Zdot":"\u017B",
  "zdot":"\u017C",
  "zeetrf":"\u2128",
  "ZeroWidthSpace":"\u200B",
  "Zeta":"\u0396",
  "zeta":"\u03B6",
  "Zfr":"\u2128",
  "zfr":"\uD835\uDD37",
  "ZHcy":"\u0416",
  "zhcy":"\u0436",
  "zigrarr":"\u21DD",
  "Zopf":"\u2124",
  "zopf":"\uD835\uDD6B",
  "Zscr":"\uD835\uDCB5",
  "zscr":"\uD835\uDCCF",
  "zwj":"\u200D",
  "zwnj":"\u200C"
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/html_blocks.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/html_blocks.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid html blocks names, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#html-blocks



var html_blocks = {};

[
  'article',
  'aside',
  'button',
  'blockquote',
  'body',
  'canvas',
  'caption',
  'col',
  'colgroup',
  'dd',
  'div',
  'dl',
  'dt',
  'embed',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'header',
  'hgroup',
  'hr',
  'iframe',
  'li',
  'map',
  'object',
  'ol',
  'output',
  'p',
  'pre',
  'progress',
  'script',
  'section',
  'style',
  'table',
  'tbody',
  'td',
  'textarea',
  'tfoot',
  'th',
  'tr',
  'thead',
  'ul',
  'video'
].forEach(function (name) { html_blocks[name] = true; });


module.exports = html_blocks;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/html_re.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/html_re.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Regexps to match html elements




function replace(regex, options) {
  regex = regex.source;
  options = options || '';

  return function self(name, val) {
    if (!name) {
      return new RegExp(regex, options);
    }
    val = val.source || val;
    regex = regex.replace(name, val);
    return self;
  };
}


var attr_name     = /[a-zA-Z_:][a-zA-Z0-9:._-]*/;

var unquoted      = /[^"'=<>`\x00-\x20]+/;
var single_quoted = /'[^']*'/;
var double_quoted = /"[^"]*"/;

/*eslint no-spaced-func:0*/
var attr_value  = replace(/(?:unquoted|single_quoted|double_quoted)/)
                    ('unquoted', unquoted)
                    ('single_quoted', single_quoted)
                    ('double_quoted', double_quoted)
                    ();

var attribute   = replace(/(?:\s+attr_name(?:\s*=\s*attr_value)?)/)
                    ('attr_name', attr_name)
                    ('attr_value', attr_value)
                    ();

var open_tag    = replace(/<[A-Za-z][A-Za-z0-9]*attribute*\s*\/?>/)
                    ('attribute', attribute)
                    ();

var close_tag   = /<\/[A-Za-z][A-Za-z0-9]*\s*>/;
var comment     = /<!--([^-]+|[-][^-]+)*-->/;
var processing  = /<[?].*?[?]>/;
var declaration = /<![A-Z]+\s+[^>]*>/;
var cdata       = /<!\[CDATA\[([^\]]+|\][^\]]|\]\][^>])*\]\]>/;

var HTML_TAG_RE = replace(/^(?:open_tag|close_tag|comment|processing|declaration|cdata)/)
  ('open_tag', open_tag)
  ('close_tag', close_tag)
  ('comment', comment)
  ('processing', processing)
  ('declaration', declaration)
  ('cdata', cdata)
  ();


module.exports.HTML_TAG_RE = HTML_TAG_RE;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/url_schemas.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/url_schemas.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid url schemas, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#autolinks




module.exports = [
  'coap',
  'doi',
  'javascript',
  'aaa',
  'aaas',
  'about',
  'acap',
  'cap',
  'cid',
  'crid',
  'data',
  'dav',
  'dict',
  'dns',
  'file',
  'ftp',
  'geo',
  'go',
  'gopher',
  'h323',
  'http',
  'https',
  'iax',
  'icap',
  'im',
  'imap',
  'info',
  'ipp',
  'iris',
  'iris.beep',
  'iris.xpc',
  'iris.xpcs',
  'iris.lwz',
  'ldap',
  'mailto',
  'mid',
  'msrp',
  'msrps',
  'mtqp',
  'mupdate',
  'news',
  'nfs',
  'ni',
  'nih',
  'nntp',
  'opaquelocktoken',
  'pop',
  'pres',
  'rtsp',
  'service',
  'session',
  'shttp',
  'sieve',
  'sip',
  'sips',
  'sms',
  'snmp',
  'soap.beep',
  'soap.beeps',
  'tag',
  'tel',
  'telnet',
  'tftp',
  'thismessage',
  'tn3270',
  'tip',
  'tv',
  'urn',
  'vemmi',
  'ws',
  'wss',
  'xcon',
  'xcon-userid',
  'xmlrpc.beep',
  'xmlrpc.beeps',
  'xmpp',
  'z39.50r',
  'z39.50s',
  'adiumxtra',
  'afp',
  'afs',
  'aim',
  'apt',
  'attachment',
  'aw',
  'beshare',
  'bitcoin',
  'bolo',
  'callto',
  'chrome',
  'chrome-extension',
  'com-eventbrite-attendee',
  'content',
  'cvs',
  'dlna-playsingle',
  'dlna-playcontainer',
  'dtn',
  'dvb',
  'ed2k',
  'facetime',
  'feed',
  'finger',
  'fish',
  'gg',
  'git',
  'gizmoproject',
  'gtalk',
  'hcp',
  'icon',
  'ipn',
  'irc',
  'irc6',
  'ircs',
  'itms',
  'jar',
  'jms',
  'keyparc',
  'lastfm',
  'ldaps',
  'magnet',
  'maps',
  'market',
  'message',
  'mms',
  'ms-help',
  'msnim',
  'mumble',
  'mvn',
  'notes',
  'oid',
  'palm',
  'paparazzi',
  'platform',
  'proxy',
  'psyc',
  'query',
  'res',
  'resource',
  'rmi',
  'rsync',
  'rtmp',
  'secondlife',
  'sftp',
  'sgn',
  'skype',
  'smb',
  'soldat',
  'spotify',
  'ssh',
  'steam',
  'svn',
  'teamspeak',
  'things',
  'udp',
  'unreal',
  'ut2004',
  'ventrilo',
  'view-source',
  'webcal',
  'wtai',
  'wyciwyg',
  'xfire',
  'xri',
  'ymsgr'
];


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Utility functions
 */

function typeOf(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return typeOf(obj) === '[object String]';
}

var hasOwn = Object.prototype.hasOwnProperty;

function has(object, key) {
  return object
    ? hasOwn.call(object, key)
    : false;
}

// Extend objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = [].slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) { return; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

////////////////////////////////////////////////////////////////////////////////

var UNESCAPE_MD_RE = /\\([\\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) { return str; }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) { return false; }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }
  // control codes
  if (c >= 0x00 && c <= 0x08) { return false; }
  if (c === 0x0B) { return false; }
  if (c >= 0x0E && c <= 0x1F) { return false; }
  if (c >= 0x7F && c <= 0x9F) { return false; }
  // out of range
  if (c > 0x10FFFF) { return false; }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var NAMED_ENTITY_RE   = /&([a-z#][a-z0-9]{1,31});/gi;
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
var entities = __webpack_require__(/*! ./entities */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/entities.js");

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  } else if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ?
      parseInt(name.slice(2), 16)
    :
      parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }
  return match;
}

function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(NAMED_ENTITY_RE, replaceEntityPattern);
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

exports.assign            = assign;
exports.isString          = isString;
exports.has               = has;
exports.unescapeMd        = unescapeMd;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint     = fromCodePoint;
exports.replaceEntities   = replaceEntities;
exports.escapeHtml        = escapeHtml;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/commonmark.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/commonmark.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Commonmark default options




module.exports = {
  options: {
    html:         true,         // Enable HTML tags in source
    xhtmlOut:     true,         // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links
    linkTarget:   '',           // set target to open link in

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to 'Â«Â»' for Russian, 'ââ' for German.
    quotes: 'ââââ',

    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'block',
        'inline',
        'references',
        'abbr2'
      ]
    },

    block: {
      rules: [
        'blockquote',
        'code',
        'fences',
        'heading',
        'hr',
        'htmlblock',
        'lheading',
        'list',
        'paragraph'
      ]
    },

    inline: {
      rules: [
        'autolink',
        'backticks',
        'emphasis',
        'entity',
        'escape',
        'htmltag',
        'links',
        'newline',
        'text'
      ]
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/default.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/default.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Remarkable default options




module.exports = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links
    linkTarget:   '',           // set target to open link in

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to 'Â«Â»' for Russian, 'ââ' for German.
    quotes: 'ââââ',

    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'block',
        'inline',
        'references',
        'replacements',
        'linkify',
        'smartquotes',
        'references',
        'abbr2',
        'footnote_tail'
      ]
    },

    block: {
      rules: [
        'blockquote',
        'code',
        'fences',
        'footnote',
        'heading',
        'hr',
        'htmlblock',
        'lheading',
        'list',
        'paragraph',
        'table'
      ]
    },

    inline: {
      rules: [
        'autolink',
        'backticks',
        'del',
        'emphasis',
        'entity',
        'escape',
        'footnote_ref',
        'htmltag',
        'links',
        'newline',
        'text'
      ]
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/full.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/full.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Remarkable default options




module.exports = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links
    linkTarget:   '',           // set target to open link in

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to 'Â«Â»' for Russian, 'ââ' for German.
    quotes:       'ââââ',

    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight:     null,

    maxNesting:    20            // Internal protection, recursion limit
  },

  components: {
    // Don't restrict core/block/inline rules
    core: {},
    block: {},
    inline: {}
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_link.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_link.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replaceEntities = __webpack_require__(/*! ../common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").replaceEntities;

module.exports = function normalizeLink(url) {
  var normalized = replaceEntities(url);
  // We shouldn't care about the result of malformed URIs,
  // and should not throw an exception.
  try {
    normalized = decodeURI(normalized);
  } catch (err) {}
  return encodeURI(normalized);
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_reference.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_reference.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_destination.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_destination.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var normalizeLink = __webpack_require__(/*! ./normalize_link */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_link.js");
var unescapeMd    = __webpack_require__(/*! ../common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").unescapeMd;

/**
 * Parse link destination
 *
 *   - on success it returns a string and updates state.pos;
 *   - on failure it returns null
 *
 * @param  {Object} state
 * @param  {Number} pos
 * @api private
 */

module.exports = function parseLinkDestination(state, pos) {
  var code, level, link,
      start = pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) === 0x3C /* < */) {
    pos++;
    while (pos < max) {
      code = state.src.charCodeAt(pos);
      if (code === 0x0A /* \n */) { return false; }
      if (code === 0x3E /* > */) {
        link = normalizeLink(unescapeMd(state.src.slice(start + 1, pos)));
        if (!state.parser.validateLink(link)) { return false; }
        state.pos = pos + 1;
        state.linkContent = link;
        return true;
      }
      if (code === 0x5C /* \ */ && pos + 1 < max) {
        pos += 2;
        continue;
      }

      pos++;
    }

    // no closing '>'
    return false;
  }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = state.src.charCodeAt(pos);

    if (code === 0x20) { break; }

    if (code > 0x08 && code < 0x0e) { break; }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
      level++;
      if (level > 1) { break; }
    }

    if (code === 0x29 /* ) */) {
      level--;
      if (level < 0) { break; }
    }

    pos++;
  }

  if (start === pos) { return false; }

  link = unescapeMd(state.src.slice(start, pos));
  if (!state.parser.validateLink(link)) { return false; }

  state.linkContent = link;
  state.pos = pos;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_label.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_label.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Parse link labels
 *
 * This function assumes that first character (`[`) already matches;
 * returns the end of the label.
 *
 * @param  {Object} state
 * @param  {Number} start
 * @api private
 */

module.exports = function parseLinkLabel(state, start) {
  var level, found, marker,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos,
      oldFlag = state.isInLabel;

  if (state.isInLabel) { return -1; }

  if (state.labelUnmatchedScopes) {
    state.labelUnmatchedScopes--;
    return -1;
  }

  state.pos = start + 1;
  state.isInLabel = true;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5B /* [ */) {
      level++;
    } else if (marker === 0x5D /* ] */) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }

    state.parser.skipToken(state);
  }

  if (found) {
    labelEnd = state.pos;
    state.labelUnmatchedScopes = 0;
  } else {
    state.labelUnmatchedScopes = level - 1;
  }

  // restore old state
  state.pos = oldPos;
  state.isInLabel = oldFlag;

  return labelEnd;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_title.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_title.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var unescapeMd = __webpack_require__(/*! ../common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").unescapeMd;

/**
 * Parse link title
 *
 *   - on success it returns a string and updates state.pos;
 *   - on failure it returns null
 *
 * @param  {Object} state
 * @param  {Number} pos
 * @api private
 */

module.exports = function parseLinkTitle(state, pos) {
  var code,
      start = pos,
      max = state.posMax,
      marker = state.src.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return false; }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) { marker = 0x29; }

  while (pos < max) {
    code = state.src.charCodeAt(pos);
    if (code === marker) {
      state.pos = pos + 1;
      state.linkContent = unescapeMd(state.src.slice(start + 1, pos));
      return true;
    }
    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    pos++;
  }

  return false;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/index.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var assign       = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").assign;
var Renderer     = __webpack_require__(/*! ./renderer */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/renderer.js");
var ParserCore   = __webpack_require__(/*! ./parser_core */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_core.js");
var ParserBlock  = __webpack_require__(/*! ./parser_block */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_block.js");
var ParserInline = __webpack_require__(/*! ./parser_inline */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_inline.js");
var Ruler        = __webpack_require__(/*! ./ruler */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/ruler.js");

/**
 * Preset configs
 */

var config = {
  'default':    __webpack_require__(/*! ./configs/default */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/default.js"),
  'full':       __webpack_require__(/*! ./configs/full */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/full.js"),
  'commonmark': __webpack_require__(/*! ./configs/commonmark */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/commonmark.js")
};

/**
 * The `StateCore` class manages state.
 *
 * @param {Object} `instance` Remarkable instance
 * @param {String} `str` Markdown string
 * @param {Object} `env`
 */

function StateCore(instance, str, env) {
  this.src = str;
  this.env = env;
  this.options = instance.options;
  this.tokens = [];
  this.inlineMode = false;

  this.inline = instance.inline;
  this.block = instance.block;
  this.renderer = instance.renderer;
  this.typographer = instance.typographer;
}

/**
 * The main `Remarkable` class. Create an instance of
 * `Remarkable` with a `preset` and/or `options`.
 *
 * @param {String} `preset` If no preset is given, `default` is used.
 * @param {Object} `options`
 */

function Remarkable(preset, options) {
  if (typeof preset !== 'string') {
    options = preset;
    preset = 'default';
  }

  this.inline   = new ParserInline();
  this.block    = new ParserBlock();
  this.core     = new ParserCore();
  this.renderer = new Renderer();
  this.ruler    = new Ruler();

  this.options  = {};
  this.configure(config[preset]);
  this.set(options || {});
}

/**
 * Set options as an alternative to passing them
 * to the constructor.
 *
 * ```js
 * md.set({typographer: true});
 * ```
 * @param {Object} `options`
 * @api public
 */

Remarkable.prototype.set = function (options) {
  assign(this.options, options);
};

/**
 * Batch loader for components rules states, and options
 *
 * @param  {Object} `presets`
 */

Remarkable.prototype.configure = function (presets) {
  var self = this;

  if (!presets) { throw new Error('Wrong `remarkable` preset, check name/content'); }
  if (presets.options) { self.set(presets.options); }
  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enable(presets.components[name].rules, true);
      }
    });
  }
};

/**
 * Use a plugin.
 *
 * ```js
 * var md = new Remarkable();
 *
 * md.use(plugin1)
 *   .use(plugin2, opts)
 *   .use(plugin3);
 * ```
 *
 * @param  {Function} `plugin`
 * @param  {Object} `options`
 * @return {Object} `Remarkable` for chaining
 */

Remarkable.prototype.use = function (plugin, options) {
  plugin(this, options);
  return this;
};


/**
 * Parse the input `string` and return a tokens array.
 * Modifies `env` with definitions data.
 *
 * @param  {String} `string`
 * @param  {Object} `env`
 * @return {Array} Array of tokens
 */

Remarkable.prototype.parse = function (str, env) {
  var state = new StateCore(this, str, env);
  this.core.process(state);
  return state.tokens;
};

/**
 * The main `.render()` method that does all the magic :)
 *
 * @param  {String} `string`
 * @param  {Object} `env`
 * @return {String} Rendered HTML.
 */

Remarkable.prototype.render = function (str, env) {
  env = env || {};
  return this.renderer.render(this.parse(str, env), this.options, env);
};

/**
 * Parse the given content `string` as a single string.
 *
 * @param  {String} `string`
 * @param  {Object} `env`
 * @return {Array} Array of tokens
 */

Remarkable.prototype.parseInline = function (str, env) {
  var state = new StateCore(this, str, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};

/**
 * Render a single content `string`, without wrapping it
 * to paragraphs
 *
 * @param  {String} `str`
 * @param  {Object} `env`
 * @return {String}
 */

Remarkable.prototype.renderInline = function (str, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(str, env), this.options, env);
};

/**
 * Expose `Remarkable`
 */

module.exports = Remarkable;

/**
 * Expose `utils`, Useful helper functions for custom
 * rendering.
 */

module.exports.utils = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js");


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_block.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_block.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var Ruler      = __webpack_require__(/*! ./ruler */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/ruler.js");
var StateBlock = __webpack_require__(/*! ./rules_block/state_block */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/state_block.js");

/**
 * Parser rules
 */

var _rules = [
  [ 'code',       __webpack_require__(/*! ./rules_block/code */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/code.js") ],
  [ 'fences',     __webpack_require__(/*! ./rules_block/fences */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/fences.js"),     [ 'paragraph', 'blockquote', 'list' ] ],
  [ 'blockquote', __webpack_require__(/*! ./rules_block/blockquote */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/blockquote.js"), [ 'paragraph', 'blockquote', 'list' ] ],
  [ 'hr',         __webpack_require__(/*! ./rules_block/hr */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/hr.js"),         [ 'paragraph', 'blockquote', 'list' ] ],
  [ 'list',       __webpack_require__(/*! ./rules_block/list */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/list.js"),       [ 'paragraph', 'blockquote' ] ],
  [ 'footnote',   __webpack_require__(/*! ./rules_block/footnote */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/footnote.js"),   [ 'paragraph' ] ],
  [ 'heading',    __webpack_require__(/*! ./rules_block/heading */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/heading.js"),    [ 'paragraph', 'blockquote' ] ],
  [ 'lheading',   __webpack_require__(/*! ./rules_block/lheading */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/lheading.js") ],
  [ 'htmlblock',  __webpack_require__(/*! ./rules_block/htmlblock */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/htmlblock.js"),  [ 'paragraph', 'blockquote' ] ],
  [ 'table',      __webpack_require__(/*! ./rules_block/table */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/table.js"),      [ 'paragraph' ] ],
  [ 'deflist',    __webpack_require__(/*! ./rules_block/deflist */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/deflist.js"),    [ 'paragraph' ] ],
  [ 'paragraph',  __webpack_require__(/*! ./rules_block/paragraph */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/paragraph.js") ]
];

/**
 * Block Parser class
 *
 * @api private
 */

function ParserBlock() {
  this.ruler = new Ruler();
  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], {
      alt: (_rules[i][2] || []).slice()
    });
  }
}

/**
 * Generate tokens for the given input range.
 *
 * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc
 * @param  {Number} `startLine`
 * @param  {Number} `endLine`
 * @api private
 */

ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var rules = this.ruler.getRules('');
  var len = rules.length;
  var line = startLine;
  var hasEmptyLines = false;
  var ok, i;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.tShift[line] < state.blkIndent) {
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight iff we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;

      // two empty lines should stop the parser in list mode
      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) { break; }
      state.line = line;
    }
  }
};

var TABS_SCAN_RE = /[\n\t]/g;
var NEWLINES_RE  = /\r[\n\u0085]|[\u2424\u2028\u0085]/g;
var SPACES_RE    = /\u00a0/g;

/**
 * Tokenize the given `str`.
 *
 * @param  {String} `str` Source string
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @param  {Array} `outTokens`
 * @api private
 */

ParserBlock.prototype.parse = function (str, options, env, outTokens) {
  var state, lineStart = 0, lastTabPos = 0;
  if (!str) { return []; }

  // Normalize spaces
  str = str.replace(SPACES_RE, ' ');

  // Normalize newlines
  str = str.replace(NEWLINES_RE, '\n');

  // Replace tabs with proper number of spaces (1..4)
  if (str.indexOf('\t') >= 0) {
    str = str.replace(TABS_SCAN_RE, function (match, offset) {
      var result;
      if (str.charCodeAt(offset) === 0x0A) {
        lineStart = offset + 1;
        lastTabPos = 0;
        return match;
      }
      result = '    '.slice((offset - lineStart - lastTabPos) % 4);
      lastTabPos = offset - lineStart + 1;
      return result;
    });
  }

  state = new StateBlock(str, this, options, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};

/**
 * Expose `ParserBlock`
 */

module.exports = ParserBlock;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_core.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_core.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var Ruler = __webpack_require__(/*! ./ruler */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/ruler.js");

/**
 * Core parser `rules`
 */

var _rules = [
  [ 'block',          __webpack_require__(/*! ./rules_core/block */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/block.js")          ],
  [ 'abbr',           __webpack_require__(/*! ./rules_core/abbr */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/abbr.js")           ],
  [ 'references',     __webpack_require__(/*! ./rules_core/references */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/references.js")     ],
  [ 'inline',         __webpack_require__(/*! ./rules_core/inline */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/inline.js")         ],
  [ 'footnote_tail',  __webpack_require__(/*! ./rules_core/footnote_tail */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/footnote_tail.js")  ],
  [ 'abbr2',          __webpack_require__(/*! ./rules_core/abbr2 */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/abbr2.js")          ],
  [ 'replacements',   __webpack_require__(/*! ./rules_core/replacements */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/replacements.js")   ],
  [ 'smartquotes',    __webpack_require__(/*! ./rules_core/smartquotes */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/smartquotes.js")    ],
  [ 'linkify',        __webpack_require__(/*! ./rules_core/linkify */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/linkify.js")        ]
];

/**
 * Class for top level (`core`) parser rules
 *
 * @api private
 */

function Core() {
  this.options = {};
  this.ruler = new Ruler();
  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Process rules with the given `state`
 *
 * @param  {Object} `state`
 * @api private
 */

Core.prototype.process = function (state) {
  var i, l, rules;
  rules = this.ruler.getRules('');
  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

/**
 * Expose `Core`
 */

module.exports = Core;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_inline.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_inline.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var Ruler       = __webpack_require__(/*! ./ruler */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/ruler.js");
var StateInline = __webpack_require__(/*! ./rules_inline/state_inline */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/state_inline.js");
var utils       = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js");

/**
 * Inline Parser `rules`
 */

var _rules = [
  [ 'text',            __webpack_require__(/*! ./rules_inline/text */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/text.js") ],
  [ 'newline',         __webpack_require__(/*! ./rules_inline/newline */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/newline.js") ],
  [ 'escape',          __webpack_require__(/*! ./rules_inline/escape */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/escape.js") ],
  [ 'backticks',       __webpack_require__(/*! ./rules_inline/backticks */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/backticks.js") ],
  [ 'del',             __webpack_require__(/*! ./rules_inline/del */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/del.js") ],
  [ 'ins',             __webpack_require__(/*! ./rules_inline/ins */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/ins.js") ],
  [ 'mark',            __webpack_require__(/*! ./rules_inline/mark */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/mark.js") ],
  [ 'emphasis',        __webpack_require__(/*! ./rules_inline/emphasis */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/emphasis.js") ],
  [ 'sub',             __webpack_require__(/*! ./rules_inline/sub */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/sub.js") ],
  [ 'sup',             __webpack_require__(/*! ./rules_inline/sup */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/sup.js") ],
  [ 'links',           __webpack_require__(/*! ./rules_inline/links */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/links.js") ],
  [ 'footnote_inline', __webpack_require__(/*! ./rules_inline/footnote_inline */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/footnote_inline.js") ],
  [ 'footnote_ref',    __webpack_require__(/*! ./rules_inline/footnote_ref */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/footnote_ref.js") ],
  [ 'autolink',        __webpack_require__(/*! ./rules_inline/autolink */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/autolink.js") ],
  [ 'htmltag',         __webpack_require__(/*! ./rules_inline/htmltag */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/htmltag.js") ],
  [ 'entity',          __webpack_require__(/*! ./rules_inline/entity */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/entity.js") ]
];

/**
 * Inline Parser class. Note that link validation is stricter
 * in Remarkable than what is specified by CommonMark. If you
 * want to change this you can use a custom validator.
 *
 * @api private
 */

function ParserInline() {
  this.ruler = new Ruler();
  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  // Can be overridden with a custom validator
  this.validateLink = validateLink;
}

/**
 * Skip a single token by running all rules in validation mode.
 * Returns `true` if any rule reports success.
 *
 * @param  {Object} `state`
 * @api privage
 */

ParserInline.prototype.skipToken = function (state) {
  var rules = this.ruler.getRules('');
  var len = rules.length;
  var pos = state.pos;
  var i, cached_pos;

  if ((cached_pos = state.cacheGet(pos)) > 0) {
    state.pos = cached_pos;
    return;
  }

  for (i = 0; i < len; i++) {
    if (rules[i](state, true)) {
      state.cacheSet(pos, state.pos);
      return;
    }
  }

  state.pos++;
  state.cacheSet(pos, state.pos);
};

/**
 * Generate tokens for the given input range.
 *
 * @param  {Object} `state`
 * @api private
 */

ParserInline.prototype.tokenize = function (state) {
  var rules = this.ruler.getRules('');
  var len = rules.length;
  var end = state.posMax;
  var ok, i;

  while (state.pos < end) {

    // Try all possible rules.
    // On success, the rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true
    for (i = 0; i < len; i++) {
      ok = rules[i](state, false);

      if (ok) {
        break;
      }
    }

    if (ok) {
      if (state.pos >= end) { break; }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * Parse the given input string.
 *
 * @param  {String} `str`
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @param  {Array} `outTokens`
 * @api private
 */

ParserInline.prototype.parse = function (str, options, env, outTokens) {
  var state = new StateInline(str, this, options, env, outTokens);
  this.tokenize(state);
};

/**
 * Validate the given `url` by checking for bad protocols.
 *
 * @param  {String} `url`
 * @return {Boolean}
 */

function validateLink(url) {
  var BAD_PROTOCOLS = [ 'vbscript', 'javascript', 'file', 'data' ];
  var str = url.trim().toLowerCase();
  // Care about digital entities "javascript&#x3A;alert(1)"
  str = utils.replaceEntities(str);
  if (str.indexOf(':') !== -1 && BAD_PROTOCOLS.indexOf(str.split(':')[0]) !== -1) {
    return false;
  }
  return true;
}

/**
 * Expose `ParserInline`
 */

module.exports = ParserInline;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/renderer.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/renderer.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var utils = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js");
var rules = __webpack_require__(/*! ./rules */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules.js");

/**
 * Expose `Renderer`
 */

module.exports = Renderer;

/**
 * Renderer class. Renders HTML and exposes `rules` to allow
 * local modifications.
 */

function Renderer() {
  this.rules = utils.assign({}, rules);

  // exported helper, for custom rules only
  this.getBreak = rules.getBreak;
}

/**
 * Render a string of inline HTML with the given `tokens` and
 * `options`.
 *
 * @param  {Array} `tokens`
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @return {String}
 * @api public
 */

Renderer.prototype.renderInline = function (tokens, options, env) {
  var _rules = this.rules;
  var len = tokens.length, i = 0;
  var result = '';

  while (len--) {
    result += _rules[tokens[i].type](tokens, i++, options, env, this);
  }

  return result;
};

/**
 * Render a string of HTML with the given `tokens` and
 * `options`.
 *
 * @param  {Array} `tokens`
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @return {String}
 * @api public
 */

Renderer.prototype.render = function (tokens, options, env) {
  var _rules = this.rules;
  var len = tokens.length, i = -1;
  var result = '';

  while (++i < len) {
    if (tokens[i].type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else {
      result += _rules[tokens[i].type](tokens, i, options, env, this);
    }
  }
  return result;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/ruler.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/ruler.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Ruler is a helper class for building responsibility chains from
 * parse rules. It allows:
 *
 *   - easy stack rules chains
 *   - getting main chain and named chains content (as arrays of functions)
 *
 * Helper methods, should not be used directly.
 * @api private
 */

function Ruler() {
  // List of added rules. Each element is:
  //
  // { name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ] }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - digital anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

/**
 * Find the index of a rule by `name`.
 *
 * @param  {String} `name`
 * @return {Number} Index of the given `name`
 * @api private
 */

Ruler.prototype.__find__ = function (name) {
  var len = this.__rules__.length;
  var i = -1;

  while (len--) {
    if (this.__rules__[++i].name === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Build the rules lookup cache
 *
 * @api private
 */

Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [ '' ];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler public methods
 * ------------------------------------------------
 */

/**
 * Replace rule function
 *
 * @param  {String} `name` Rule name
 * @param  {Function `fn`
 * @param  {Object} `options`
 * @api private
 */

Ruler.prototype.at = function (name, fn, options) {
  var idx = this.__find__(name);
  var opt = options || {};

  if (idx === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[idx].fn = fn;
  this.__rules__[idx].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Add a rule to the chain before given the `ruleName`.
 *
 * @param  {String}   `beforeName`
 * @param  {String}   `ruleName`
 * @param  {Function} `fn`
 * @param  {Object}   `options`
 * @api private
 */

Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var idx = this.__find__(beforeName);
  var opt = options || {};

  if (idx === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(idx, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Add a rule to the chain after the given `ruleName`.
 *
 * @param  {String}   `afterName`
 * @param  {String}   `ruleName`
 * @param  {Function} `fn`
 * @param  {Object}   `options`
 * @api private
 */

Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var idx = this.__find__(afterName);
  var opt = options || {};

  if (idx === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(idx + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Add a rule to the end of chain.
 *
 * @param  {String}   `ruleName`
 * @param  {Function} `fn`
 * @param  {Object}   `options`
 * @return {String}
 */

Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Enable a rule or list of rules.
 *
 * @param  {String|Array} `list` Name or array of rule names to enable
 * @param  {Boolean} `strict` If `true`, all non listed rules will be disabled.
 * @api private
 */

Ruler.prototype.enable = function (list, strict) {
  list = !Array.isArray(list)
    ? [ list ]
    : list;

  // In strict mode disable all existing rules first
  if (strict) {
    this.__rules__.forEach(function (rule) {
      rule.enabled = false;
    });
  }

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);
    if (idx < 0) {
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
  }, this);

  this.__cache__ = null;
};


/**
 * Disable a rule or list of rules.
 *
 * @param  {String|Array} `list` Name or array of rule names to disable
 * @api private
 */

Ruler.prototype.disable = function (list) {
  list = !Array.isArray(list)
    ? [ list ]
    : list;

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);
    if (idx < 0) {
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
  }, this);

  this.__cache__ = null;
};

/**
 * Get a rules list as an array of functions.
 *
 * @param  {String} `chainName`
 * @return {Object}
 * @api private
 */

Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};

/**
 * Expose `Ruler`
 */

module.exports = Ruler;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var has             = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").has;
var unescapeMd      = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").unescapeMd;
var replaceEntities = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").replaceEntities;
var escapeHtml      = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").escapeHtml;

/**
 * Renderer rules cache
 */

var rules = {};

/**
 * Blockquotes
 */

rules.blockquote_open = function(/* tokens, idx, options, env */) {
  return '<blockquote>\n';
};

rules.blockquote_close = function(tokens, idx /*, options, env */) {
  return '</blockquote>' + getBreak(tokens, idx);
};

/**
 * Code
 */

rules.code = function(tokens, idx /*, options, env */) {
  if (tokens[idx].block) {
    return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>' + getBreak(tokens, idx);
  }
  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';
};

/**
 * Fenced code blocks
 */

rules.fence = function(tokens, idx, options, env, instance) {
  var token = tokens[idx];
  var langClass = '';
  var langPrefix = options.langPrefix;
  var langName = '', fences, fenceName;
  var highlighted;

  if (token.params) {

    //
    // ```foo bar
    //
    // Try custom renderer "foo" first. That will simplify overwrite
    // for diagrams, latex, and any other fenced block with custom look
    //

    fences = token.params.split(/\s+/g);
    fenceName = fences.join(' ');

    if (has(instance.rules.fence_custom, fences[0])) {
      return instance.rules.fence_custom[fences[0]](tokens, idx, options, env, instance);
    }

    langName = escapeHtml(replaceEntities(unescapeMd(fenceName)));
    langClass = ' class="' + langPrefix + langName + '"';
  }

  if (options.highlight) {
    highlighted = options.highlight.apply(options.highlight, [ token.content ].concat(fences))
      || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  return '<pre><code' + langClass + '>'
        + highlighted
        + '</code></pre>'
        + getBreak(tokens, idx);
};

rules.fence_custom = {};

/**
 * Headings
 */

rules.heading_open = function(tokens, idx /*, options, env */) {
  return '<h' + tokens[idx].hLevel + '>';
};
rules.heading_close = function(tokens, idx /*, options, env */) {
  return '</h' + tokens[idx].hLevel + '>\n';
};

/**
 * Horizontal rules
 */

rules.hr = function(tokens, idx, options /*, env */) {
  return (options.xhtmlOut ? '<hr />' : '<hr>') + getBreak(tokens, idx);
};

/**
 * Bullets
 */

rules.bullet_list_open = function(/* tokens, idx, options, env */) {
  return '<ul>\n';
};
rules.bullet_list_close = function(tokens, idx /*, options, env */) {
  return '</ul>' + getBreak(tokens, idx);
};

/**
 * List items
 */

rules.list_item_open = function(/* tokens, idx, options, env */) {
  return '<li>';
};
rules.list_item_close = function(/* tokens, idx, options, env */) {
  return '</li>\n';
};

/**
 * Ordered list items
 */

rules.ordered_list_open = function(tokens, idx /*, options, env */) {
  var token = tokens[idx];
  var order = token.order > 1 ? ' start="' + token.order + '"' : '';
  return '<ol' + order + '>\n';
};
rules.ordered_list_close = function(tokens, idx /*, options, env */) {
  return '</ol>' + getBreak(tokens, idx);
};

/**
 * Paragraphs
 */

rules.paragraph_open = function(tokens, idx /*, options, env */) {
  return tokens[idx].tight ? '' : '<p>';
};
rules.paragraph_close = function(tokens, idx /*, options, env */) {
  var addBreak = !(tokens[idx].tight && idx && tokens[idx - 1].type === 'inline' && !tokens[idx - 1].content);
  return (tokens[idx].tight ? '' : '</p>') + (addBreak ? getBreak(tokens, idx) : '');
};

/**
 * Links
 */

rules.link_open = function(tokens, idx, options /* env */) {
  var title = tokens[idx].title ? (' title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '"') : '';
  var target = options.linkTarget ? (' target="' + options.linkTarget + '"') : '';
  return '<a href="' + escapeHtml(tokens[idx].href) + '"' + title + target + '>';
};
rules.link_close = function(/* tokens, idx, options, env */) {
  return '</a>';
};

/**
 * Images
 */

rules.image = function(tokens, idx, options /*, env */) {
  var src = ' src="' + escapeHtml(tokens[idx].src) + '"';
  var title = tokens[idx].title ? (' title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '"') : '';
  var alt = ' alt="' + (tokens[idx].alt ? escapeHtml(replaceEntities(unescapeMd(tokens[idx].alt))) : '') + '"';
  var suffix = options.xhtmlOut ? ' /' : '';
  return '<img' + src + alt + title + suffix + '>';
};

/**
 * Tables
 */

rules.table_open = function(/* tokens, idx, options, env */) {
  return '<table>\n';
};
rules.table_close = function(/* tokens, idx, options, env */) {
  return '</table>\n';
};
rules.thead_open = function(/* tokens, idx, options, env */) {
  return '<thead>\n';
};
rules.thead_close = function(/* tokens, idx, options, env */) {
  return '</thead>\n';
};
rules.tbody_open = function(/* tokens, idx, options, env */) {
  return '<tbody>\n';
};
rules.tbody_close = function(/* tokens, idx, options, env */) {
  return '</tbody>\n';
};
rules.tr_open = function(/* tokens, idx, options, env */) {
  return '<tr>';
};
rules.tr_close = function(/* tokens, idx, options, env */) {
  return '</tr>\n';
};
rules.th_open = function(tokens, idx /*, options, env */) {
  var token = tokens[idx];
  return '<th'
    + (token.align ? ' style="text-align:' + token.align + '"' : '')
    + '>';
};
rules.th_close = function(/* tokens, idx, options, env */) {
  return '</th>';
};
rules.td_open = function(tokens, idx /*, options, env */) {
  var token = tokens[idx];
  return '<td'
    + (token.align ? ' style="text-align:' + token.align + '"' : '')
    + '>';
};
rules.td_close = function(/* tokens, idx, options, env */) {
  return '</td>';
};

/**
 * Bold
 */

rules.strong_open = function(/* tokens, idx, options, env */) {
  return '<strong>';
};
rules.strong_close = function(/* tokens, idx, options, env */) {
  return '</strong>';
};

/**
 * Italicize
 */

rules.em_open = function(/* tokens, idx, options, env */) {
  return '<em>';
};
rules.em_close = function(/* tokens, idx, options, env */) {
  return '</em>';
};

/**
 * Strikethrough
 */

rules.del_open = function(/* tokens, idx, options, env */) {
  return '<del>';
};
rules.del_close = function(/* tokens, idx, options, env */) {
  return '</del>';
};

/**
 * Insert
 */

rules.ins_open = function(/* tokens, idx, options, env */) {
  return '<ins>';
};
rules.ins_close = function(/* tokens, idx, options, env */) {
  return '</ins>';
};

/**
 * Highlight
 */

rules.mark_open = function(/* tokens, idx, options, env */) {
  return '<mark>';
};
rules.mark_close = function(/* tokens, idx, options, env */) {
  return '</mark>';
};

/**
 * Super- and sub-script
 */

rules.sub = function(tokens, idx /*, options, env */) {
  return '<sub>' + escapeHtml(tokens[idx].content) + '</sub>';
};
rules.sup = function(tokens, idx /*, options, env */) {
  return '<sup>' + escapeHtml(tokens[idx].content) + '</sup>';
};

/**
 * Breaks
 */

rules.hardbreak = function(tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
rules.softbreak = function(tokens, idx, options /*, env */) {
  return options.breaks ? (options.xhtmlOut ? '<br />\n' : '<br>\n') : '\n';
};

/**
 * Text
 */

rules.text = function(tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

/**
 * Content
 */

rules.htmlblock = function(tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
rules.htmltag = function(tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * Abbreviations, initialism
 */

rules.abbr_open = function(tokens, idx /*, options, env */) {
  return '<abbr title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '">';
};
rules.abbr_close = function(/* tokens, idx, options, env */) {
  return '</abbr>';
};

/**
 * Footnotes
 */

rules.footnote_ref = function(tokens, idx) {
  var n = Number(tokens[idx].id + 1).toString();
  var id = 'fnref' + n;
  if (tokens[idx].subId > 0) {
    id += ':' + tokens[idx].subId;
  }
  return '<sup class="footnote-ref"><a href="#fn' + n + '" id="' + id + '">[' + n + ']</a></sup>';
};
rules.footnote_block_open = function(tokens, idx, options) {
  var hr = options.xhtmlOut
    ? '<hr class="footnotes-sep" />\n'
    : '<hr class="footnotes-sep">\n';
  return hr + '<section class="footnotes">\n<ol class="footnotes-list">\n';
};
rules.footnote_block_close = function() {
  return '</ol>\n</section>\n';
};
rules.footnote_open = function(tokens, idx) {
  var id = Number(tokens[idx].id + 1).toString();
  return '<li id="fn' + id + '"  class="footnote-item">';
};
rules.footnote_close = function() {
  return '</li>\n';
};
rules.footnote_anchor = function(tokens, idx) {
  var n = Number(tokens[idx].id + 1).toString();
  var id = 'fnref' + n;
  if (tokens[idx].subId > 0) {
    id += ':' + tokens[idx].subId;
  }
  return ' <a href="#' + id + '" class="footnote-backref">â©</a>';
};

/**
 * Definition lists
 */

rules.dl_open = function() {
  return '<dl>\n';
};
rules.dt_open = function() {
  return '<dt>';
};
rules.dd_open = function() {
  return '<dd>';
};
rules.dl_close = function() {
  return '</dl>\n';
};
rules.dt_close = function() {
  return '</dt>\n';
};
rules.dd_close = function() {
  return '</dd>\n';
};

/**
 * Helper functions
 */

function nextToken(tokens, idx) {
  if (++idx >= tokens.length - 2) {
    return idx;
  }
  if ((tokens[idx].type === 'paragraph_open' && tokens[idx].tight) &&
      (tokens[idx + 1].type === 'inline' && tokens[idx + 1].content.length === 0) &&
      (tokens[idx + 2].type === 'paragraph_close' && tokens[idx + 2].tight)) {
    return nextToken(tokens, idx + 2);
  }
  return idx;
}

/**
 * Check to see if `\n` is needed before the next token.
 *
 * @param  {Array} `tokens`
 * @param  {Number} `idx`
 * @return {String} Empty string or newline
 * @api private
 */

var getBreak = rules.getBreak = function getBreak(tokens, idx) {
  idx = nextToken(tokens, idx);
  if (idx < tokens.length && tokens[idx].type === 'list_item_close') {
    return '';
  }
  return '\n';
};

/**
 * Expose `rules`
 */

module.exports = rules;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/blockquote.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/blockquote.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Block quotes




module.exports = function blockquote(state, startLine, endLine, silent) {
  var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines,
      terminatorRules,
      i, l, terminate,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos > max) { return false; }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }

  if (state.level >= state.options.maxNesting) { return false; }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) { return true; }

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20) { pos++; }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  oldBMarks = [ state.bMarks[startLine] ];
  state.bMarks[startLine] = pos;

  // check if we have an empty blockquote
  pos = pos < max ? state.skipSpaces(pos) : pos;
  lastLineEmpty = pos >= max;

  oldTShift = [ state.tShift[startLine] ];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.parser.ruler.getRules('blockquote');

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E/* > */) {
      // This line is inside the blockquote.

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20) { pos++; }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      pos = pos < max ? state.skipSpaces(pos) : pos;
      lastLineEmpty = pos >= max;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) { break; }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }

    oldBMarks.push(state.bMarks[nextLine]);
    oldTShift.push(state.tShift[nextLine]);

    // A negative number means that this is a paragraph continuation;
    //
    // Any negative number will do the job here, but it's better for it
    // to be large enough to make any bugs obvious.
    state.tShift[nextLine] = -1337;
  }

  oldParentType = state.parentType;
  state.parentType = 'blockquote';
  state.tokens.push({
    type: 'blockquote_open',
    lines: lines = [ startLine, 0 ],
    level: state.level++
  });
  state.parser.tokenize(state, startLine, nextLine);
  state.tokens.push({
    type: 'blockquote_close',
    level: --state.level
  });
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
  }
  state.blkIndent = oldIndent;

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/code.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/code.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Code block (4 spaces padded)




module.exports = function code(state, startLine, endLine/*, silent*/) {
  var nextLine, last;

  if (state.tShift[startLine] - state.blkIndent < 4) { return false; }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.tShift[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = nextLine;
  state.tokens.push({
    type: 'code',
    content: state.getLines(startLine, last, 4 + state.blkIndent, true),
    block: true,
    lines: [ startLine, state.line ],
    level: state.level
  });

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/deflist.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/deflist.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Definition lists




// Search `[:~][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipMarker(state, line) {
  var pos, marker,
      start = state.bMarks[line] + state.tShift[line],
      max = state.eMarks[line];

  if (start >= max) { return -1; }

  // Check bullet
  marker = state.src.charCodeAt(start++);
  if (marker !== 0x7E/* ~ */ && marker !== 0x3A/* : */) { return -1; }

  pos = state.skipSpaces(start);

  // require space after ":"
  if (start === pos) { return -1; }

  // no empty definitions, e.g. "  : "
  if (pos >= max) { return -1; }

  return pos;
}

function markTightParagraphs(state, idx) {
  var i, l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].tight = true;
      state.tokens[i].tight = true;
      i += 2;
    }
  }
}

module.exports = function deflist(state, startLine, endLine, silent) {
  var contentStart,
      ddLine,
      dtLine,
      itemLines,
      listLines,
      listTokIdx,
      nextLine,
      oldIndent,
      oldDDIndent,
      oldParentType,
      oldTShift,
      oldTight,
      prevEmptyEnd,
      tight;

  if (silent) {
    // quirk: validation mode validates a dd block only, not a whole deflist
    if (state.ddIndent < 0) { return false; }
    return skipMarker(state, startLine) >= 0;
  }

  nextLine = startLine + 1;
  if (state.isEmpty(nextLine)) {
    if (++nextLine > endLine) { return false; }
  }

  if (state.tShift[nextLine] < state.blkIndent) { return false; }
  contentStart = skipMarker(state, nextLine);
  if (contentStart < 0) { return false; }

  if (state.level >= state.options.maxNesting) { return false; }

  // Start list
  listTokIdx = state.tokens.length;

  state.tokens.push({
    type: 'dl_open',
    lines: listLines = [ startLine, 0 ],
    level: state.level++
  });

  //
  // Iterate list items
  //

  dtLine = startLine;
  ddLine = nextLine;

  // One definition list can contain multiple DTs,
  // and one DT can be followed by multiple DDs.
  //
  // Thus, there is two loops here, and label is
  // needed to break out of the second one
  //
  /*eslint no-labels:0,block-scoped-var:0*/
  OUTER:
  for (;;) {
    tight = true;
    prevEmptyEnd = false;

    state.tokens.push({
      type: 'dt_open',
      lines: [ dtLine, dtLine ],
      level: state.level++
    });
    state.tokens.push({
      type: 'inline',
      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),
      level: state.level + 1,
      lines: [ dtLine, dtLine ],
      children: []
    });
    state.tokens.push({
      type: 'dt_close',
      level: --state.level
    });

    for (;;) {
      state.tokens.push({
        type: 'dd_open',
        lines: itemLines = [ nextLine, 0 ],
        level: state.level++
      });

      oldTight = state.tight;
      oldDDIndent = state.ddIndent;
      oldIndent = state.blkIndent;
      oldTShift = state.tShift[ddLine];
      oldParentType = state.parentType;
      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;
      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];
      state.tight = true;
      state.parentType = 'deflist';

      state.parser.tokenize(state, ddLine, endLine, true);

      // If any of list item is tight, mark list as tight
      if (!state.tight || prevEmptyEnd) {
        tight = false;
      }
      // Item become loose if finish with empty line,
      // but we should filter last element, because it means list finish
      prevEmptyEnd = (state.line - ddLine) > 1 && state.isEmpty(state.line - 1);

      state.tShift[ddLine] = oldTShift;
      state.tight = oldTight;
      state.parentType = oldParentType;
      state.blkIndent = oldIndent;
      state.ddIndent = oldDDIndent;

      state.tokens.push({
        type: 'dd_close',
        level: --state.level
      });

      itemLines[1] = nextLine = state.line;

      if (nextLine >= endLine) { break OUTER; }

      if (state.tShift[nextLine] < state.blkIndent) { break OUTER; }
      contentStart = skipMarker(state, nextLine);
      if (contentStart < 0) { break; }

      ddLine = nextLine;

      // go to the next loop iteration:
      // insert DD tag and repeat checking
    }

    if (nextLine >= endLine) { break; }
    dtLine = nextLine;

    if (state.isEmpty(dtLine)) { break; }
    if (state.tShift[dtLine] < state.blkIndent) { break; }

    ddLine = dtLine + 1;
    if (ddLine >= endLine) { break; }
    if (state.isEmpty(ddLine)) { ddLine++; }
    if (ddLine >= endLine) { break; }

    if (state.tShift[ddLine] < state.blkIndent) { break; }
    contentStart = skipMarker(state, ddLine);
    if (contentStart < 0) { break; }

    // go to the next loop iteration:
    // insert DT and DD tags and repeat checking
  }

  // Finilize list
  state.tokens.push({
    type: 'dl_close',
    level: --state.level
  });
  listLines[1] = nextLine;

  state.line = nextLine;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/fences.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/fences.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// fences (``` lang, ~~~ lang)




module.exports = function fences(state, startLine, endLine, silent) {
  var marker, len, params, nextLine, mem,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos + 3 > max) { return false; }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {
    return false;
  }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) { return false; }

  params = state.src.slice(pos, max).trim();

  if (params.indexOf('`') >= 0) { return false; }

  // Since start is found, we can report success here in validation mode
  if (silent) { return true; }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.tShift[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) { continue; }

    if (state.tShift[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) { continue; }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) { continue; }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.tShift[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);
  state.tokens.push({
    type: 'fence',
    params: params,
    content: state.getLines(startLine + 1, nextLine, len, true),
    lines: [ startLine, state.line ],
    level: state.level
  });

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/footnote.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/footnote.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process footnote reference list




module.exports = function footnote(state, startLine, endLine, silent) {
  var oldBMark, oldTShift, oldParentType, pos, label,
      start = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // line should be at least 5 chars - "[^x]:"
  if (start + 4 > max) { return false; }

  if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  for (pos = start + 2; pos < max; pos++) {
    if (state.src.charCodeAt(pos) === 0x20) { return false; }
    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {
      break;
    }
  }

  if (pos === start + 2) { return false; } // no empty footnote labels
  if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A /* : */) { return false; }
  if (silent) { return true; }
  pos++;

  if (!state.env.footnotes) { state.env.footnotes = {}; }
  if (!state.env.footnotes.refs) { state.env.footnotes.refs = {}; }
  label = state.src.slice(start + 2, pos - 2);
  state.env.footnotes.refs[':' + label] = -1;

  state.tokens.push({
    type: 'footnote_reference_open',
    label: label,
    level: state.level++
  });

  oldBMark = state.bMarks[startLine];
  oldTShift = state.tShift[startLine];
  oldParentType = state.parentType;
  state.tShift[startLine] = state.skipSpaces(pos) - pos;
  state.bMarks[startLine] = pos;
  state.blkIndent += 4;
  state.parentType = 'footnote';

  if (state.tShift[startLine] < state.blkIndent) {
    state.tShift[startLine] += state.blkIndent;
    state.bMarks[startLine] -= state.blkIndent;
  }

  state.parser.tokenize(state, startLine, endLine, true);

  state.parentType = oldParentType;
  state.blkIndent -= 4;
  state.tShift[startLine] = oldTShift;
  state.bMarks[startLine] = oldBMark;

  state.tokens.push({
    type: 'footnote_reference_close',
    level: --state.level
  });

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/heading.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/heading.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// heading (#, ##, ...)




module.exports = function heading(state, startLine, endLine, silent) {
  var ch, level, tmp,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos >= max) { return false; }

  ch  = state.src.charCodeAt(pos);

  if (ch !== 0x23/* # */ || pos >= max) { return false; }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23/* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || (pos < max && ch !== 0x20/* space */)) { return false; }

  if (silent) { return true; }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipCharsBack(max, 0x20, pos); // space
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && state.src.charCodeAt(tmp - 1) === 0x20/* space */) {
    max = tmp;
  }

  state.line = startLine + 1;

  state.tokens.push({ type: 'heading_open',
    hLevel: level,
    lines: [ startLine, state.line ],
    level: state.level
  });

  // only if header is not empty
  if (pos < max) {
    state.tokens.push({
      type: 'inline',
      content: state.src.slice(pos, max).trim(),
      level: state.level + 1,
      lines: [ startLine, state.line ],
      children: []
    });
  }
  state.tokens.push({ type: 'heading_close', hLevel: level, level: state.level });

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/hr.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/hr.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Horizontal rule




module.exports = function hr(state, startLine, endLine, silent) {
  var marker, cnt, ch,
      pos = state.bMarks[startLine],
      max = state.eMarks[startLine];

  pos += state.tShift[startLine];

  if (pos > max) { return false; }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x5F/* _ */) {
    return false;
  }

  // markers can be mixed with spaces, but there should be at least 3 one

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && ch !== 0x20/* space */) { return false; }
    if (ch === marker) { cnt++; }
  }

  if (cnt < 3) { return false; }

  if (silent) { return true; }

  state.line = startLine + 1;
  state.tokens.push({
    type: 'hr',
    lines: [ startLine, state.line ],
    level: state.level
  });

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/htmlblock.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/htmlblock.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML block




var block_names = __webpack_require__(/*! ../common/html_blocks */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/html_blocks.js");


var HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\s\/>]/;
var HTML_TAG_CLOSE_RE = /^<\/([a-zA-Z]{1,15})[\s>]/;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
}

module.exports = function htmlblock(state, startLine, endLine, silent) {
  var ch, match, nextLine,
      pos = state.bMarks[startLine],
      max = state.eMarks[startLine],
      shift = state.tShift[startLine];

  pos += shift;

  if (!state.options.html) { return false; }

  if (shift > 3 || pos + 2 >= max) { return false; }

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  ch = state.src.charCodeAt(pos + 1);

  if (ch === 0x21/* ! */ || ch === 0x3F/* ? */) {
    // Directive start / comment start / processing instruction start
    if (silent) { return true; }

  } else if (ch === 0x2F/* / */ || isLetter(ch)) {

    // Probably start or end of tag
    if (ch === 0x2F/* \ */) {
      // closing tag
      match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);
      if (!match) { return false; }
    } else {
      // opening tag
      match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);
      if (!match) { return false; }
    }
    // Make sure tag name is valid
    if (block_names[match[1].toLowerCase()] !== true) { return false; }
    if (silent) { return true; }

  } else {
    return false;
  }

  // If we are here - we detected HTML block.
  // Let's roll down till empty line (block end).
  nextLine = startLine + 1;
  while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {
    nextLine++;
  }

  state.line = nextLine;
  state.tokens.push({
    type: 'htmlblock',
    level: state.level,
    lines: [ startLine, state.line ],
    content: state.getLines(startLine, nextLine, 0, true)
  });

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/lheading.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/lheading.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// lheading (---, ===)




module.exports = function lheading(state, startLine, endLine/*, silent*/) {
  var marker, pos, max,
      next = startLine + 1;

  if (next >= endLine) { return false; }
  if (state.tShift[next] < state.blkIndent) { return false; }

  // Scan next line

  if (state.tShift[next] - state.blkIndent > 3) { return false; }

  pos = state.bMarks[next] + state.tShift[next];
  max = state.eMarks[next];

  if (pos >= max) { return false; }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x2D/* - */ && marker !== 0x3D/* = */) { return false; }

  pos = state.skipChars(pos, marker);

  pos = state.skipSpaces(pos);

  if (pos < max) { return false; }

  pos = state.bMarks[startLine] + state.tShift[startLine];

  state.line = next + 1;
  state.tokens.push({
    type: 'heading_open',
    hLevel: marker === 0x3D/* = */ ? 1 : 2,
    lines: [ startLine, state.line ],
    level: state.level
  });
  state.tokens.push({
    type: 'inline',
    content: state.src.slice(pos, state.eMarks[startLine]).trim(),
    level: state.level + 1,
    lines: [ startLine, state.line - 1 ],
    children: []
  });
  state.tokens.push({
    type: 'heading_close',
    hLevel: marker === 0x3D/* = */ ? 1 : 2,
    level: state.level
  });

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/list.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/list.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Lists




// Search `[-+*][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  if (pos >= max) { return -1; }

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x2B/* + */) {
    return -1;
  }

  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {
    // " 1.test " - is not a list item
    return -1;
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos + 1 >= max) { return -1; }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }

  for (;;) {
    // EOL -> fail
    if (pos >= max) { return -1; }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {
      continue;
    }

    // found valid marker
    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {
      break;
    }

    return -1;
  }


  if (pos < max && state.src.charCodeAt(pos) !== 0x20/* space */) {
    // " 1.test " - is not a list item
    return -1;
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i, l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].tight = true;
      state.tokens[i].tight = true;
      i += 2;
    }
  }
}


module.exports = function list(state, startLine, endLine, silent) {
  var nextLine,
      indent,
      oldTShift,
      oldIndent,
      oldTight,
      oldParentType,
      start,
      posAfterMarker,
      max,
      indentAfterMarker,
      markerValue,
      markerCharCode,
      isOrdered,
      contentStart,
      listTokIdx,
      prevEmptyEnd,
      listLines,
      itemLines,
      tight = true,
      terminatorRules,
      i, l, terminate;

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  if (state.level >= state.options.maxNesting) { return false; }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) { return true; }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    state.tokens.push({
      type: 'ordered_list_open',
      order: markerValue,
      lines: listLines = [ startLine, 0 ],
      level: state.level++
    });

  } else {
    state.tokens.push({
      type: 'bullet_list_open',
      lines: listLines = [ startLine, 0 ],
      level: state.level++
    });
  }

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.parser.ruler.getRules('list');

  while (nextLine < endLine) {
    contentStart = state.skipSpaces(posAfterMarker);
    max = state.eMarks[nextLine];

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = contentStart - posAfterMarker;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) { indentAfterMarker = 1; }

    // If indent is less than 1, assume that it's one, example:
    //  "-\n  test"
    if (indentAfterMarker < 1) { indentAfterMarker = 1; }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = (posAfterMarker - state.bMarks[nextLine]) + indentAfterMarker;

    // Run subparser & write tokens
    state.tokens.push({
      type: 'list_item_open',
      lines: itemLines = [ startLine, 0 ],
      level: state.level++
    });

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldParentType = state.parentType;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.parentType = 'list';

    state.parser.tokenize(state, startLine, endLine, true);

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.tight = oldTight;
    state.parentType = oldParentType;

    state.tokens.push({
      type: 'list_item_close',
      level: --state.level
    });

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) { break; }

    if (state.isEmpty(nextLine)) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.tShift[nextLine] < state.blkIndent) { break; }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }
  }

  // Finilize list
  state.tokens.push({
    type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',
    level: --state.level
  });
  listLines[1] = nextLine;

  state.line = nextLine;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/paragraph.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/paragraph.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Paragraph




module.exports = function paragraph(state, startLine/*, endLine*/) {
  var endLine, content, terminate, i, l,
      nextLine = startLine + 1,
      terminatorRules;

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  if (nextLine < endLine && !state.isEmpty(nextLine)) {
    terminatorRules = state.parser.ruler.getRules('paragraph');

    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      // this would be a code block normally, but after paragraph
      // it's considered a lazy continuation regardless of what's there
      if (state.tShift[nextLine] - state.blkIndent > 3) { continue; }

      // Some tags can terminate paragraph without empty line.
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) { break; }
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;
  if (content.length) {
    state.tokens.push({
      type: 'paragraph_open',
      tight: false,
      lines: [ startLine, state.line ],
      level: state.level
    });
    state.tokens.push({
      type: 'inline',
      content: content,
      level: state.level + 1,
      lines: [ startLine, state.line ],
      children: []
    });
    state.tokens.push({
      type: 'paragraph_close',
      tight: false,
      level: state.level
    });
  }

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/state_block.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/state_block.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parser state class




function StateBlock(src, parser, options, env, tokens) {
  var ch, s, start, pos, len, indent, indent_found;

  this.src = src;

  // Shortcuts to simplify nested calls
  this.parser = parser;

  this.options = options;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = [];  // line begin offsets for fast jumps
  this.eMarks = [];  // line end offsets for fast jumps
  this.tShift = [];  // indent for each line

  // block parser variables
  this.blkIndent  = 0; // required block content indent
                       // (for example, if we are in list)
  this.line       = 0; // line index in src
  this.lineMax    = 0; // lines count
  this.tight      = false;  // loose/tight mode for lists
  this.parentType = 'root'; // if `list`, block parser stops on two newlines
  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent = 0;
  indent_found = false;

  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (ch === 0x20/* space */) {
        indent++;
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) { pos++; }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);

      indent_found = false;
      indent = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== 0x20/* space */) { break; }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) { break; }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) { return pos; }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i, first, last, queue, shift,
      line = begin;

  if (begin >= end) {
    return '';
  }

  // Opt: don't use push queue for single line;
  if (line + 1 === end) {
    first = this.bMarks[line] + Math.min(this.tShift[line], indent);
    last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];
    return this.src.slice(first, last);
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    shift = this.tShift[line];
    if (shift > indent) { shift = indent; }
    if (shift < 0) { shift = 0; }

    first = this.bMarks[line] + shift;

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    queue[i] = this.src.slice(first, last);
  }

  return queue.join('');
};


module.exports = StateBlock;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/table.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/table.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GFM table, non-standard




function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, rows, cell,
      aligns, t, tableLines, tbodyLines;

  // should have at least three lines
  if (startLine + 2 > endLine) { return false; }

  nextLine = startLine + 1;

  if (state.tShift[nextLine] < state.blkIndent) { return false; }

  // first character of the second line should be '|' or '-'

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) { return false; }

  ch = state.src.charCodeAt(pos);
  if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }

  lineText = getLine(state, startLine + 1);
  if (!/^[-:| ]+$/.test(lineText)) { return false; }

  rows = lineText.split('|');
  if (rows <= 2) { return false; }
  aligns = [];
  for (i = 0; i < rows.length; i++) {
    t = rows[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === rows.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) { return false; }
    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {
      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');
    } else if (t.charCodeAt(0) === 0x3A/* : */) {
      aligns.push('left');
    } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) { return false; }
  rows = lineText.replace(/^\||\|$/g, '').split('|');
  if (aligns.length !== rows.length) { return false; }
  if (silent) { return true; }

  state.tokens.push({
    type: 'table_open',
    lines: tableLines = [ startLine, 0 ],
    level: state.level++
  });
  state.tokens.push({
    type: 'thead_open',
    lines: [ startLine, startLine + 1 ],
    level: state.level++
  });

  state.tokens.push({
    type: 'tr_open',
    lines: [ startLine, startLine + 1 ],
    level: state.level++
  });
  for (i = 0; i < rows.length; i++) {
    state.tokens.push({
      type: 'th_open',
      align: aligns[i],
      lines: [ startLine, startLine + 1 ],
      level: state.level++
    });
    state.tokens.push({
      type: 'inline',
      content: rows[i].trim(),
      lines: [ startLine, startLine + 1 ],
      level: state.level,
      children: []
    });
    state.tokens.push({ type: 'th_close', level: --state.level });
  }
  state.tokens.push({ type: 'tr_close', level: --state.level });
  state.tokens.push({ type: 'thead_close', level: --state.level });

  state.tokens.push({
    type: 'tbody_open',
    lines: tbodyLines = [ startLine + 2, 0 ],
    level: state.level++
  });

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.tShift[nextLine] < state.blkIndent) { break; }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) { break; }
    rows = lineText.replace(/^\||\|$/g, '').split('|');

    state.tokens.push({ type: 'tr_open', level: state.level++ });
    for (i = 0; i < rows.length; i++) {
      state.tokens.push({ type: 'td_open', align: aligns[i], level: state.level++ });
      // 0x7c === '|'
      cell = rows[i].substring(
          rows[i].charCodeAt(0) === 0x7c ? 1 : 0,
          rows[i].charCodeAt(rows[i].length - 1) === 0x7c ? rows[i].length - 1 : rows[i].length
      ).trim();
      state.tokens.push({
        type: 'inline',
        content: cell,
        level: state.level,
        children: []
      });
      state.tokens.push({ type: 'td_close', level: --state.level });
    }
    state.tokens.push({ type: 'tr_close', level: --state.level });
  }
  state.tokens.push({ type: 'tbody_close', level: --state.level });
  state.tokens.push({ type: 'table_close', level: --state.level });

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/abbr.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/abbr.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse abbreviation definitions, i.e. `*[abbr]: description`
//




var StateInline    = __webpack_require__(/*! ../rules_inline/state_inline */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/state_inline.js");
var parseLinkLabel = __webpack_require__(/*! ../helpers/parse_link_label */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_label.js");


function parseAbbr(str, parserInline, options, env) {
  var state, labelEnd, pos, max, label, title;

  if (str.charCodeAt(0) !== 0x2A/* * */) { return -1; }
  if (str.charCodeAt(1) !== 0x5B/* [ */) { return -1; }

  if (str.indexOf(']:') === -1) { return -1; }

  state = new StateInline(str, parserInline, options, env, []);
  labelEnd = parseLinkLabel(state, 1);

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }

  max = state.posMax;

  // abbr title is always one line, so looking for ending "\n" here
  for (pos = labelEnd + 2; pos < max; pos++) {
    if (state.src.charCodeAt(pos) === 0x0A) { break; }
  }

  label = str.slice(2, labelEnd);
  title = str.slice(labelEnd + 2, pos).trim();
  if (title.length === 0) { return -1; }
  if (!env.abbreviations) { env.abbreviations = {}; }
  // prepend ':' to avoid conflict with Object.prototype members
  if (typeof env.abbreviations[':' + label] === 'undefined') {
    env.abbreviations[':' + label] = title;
  }

  return pos;
}

module.exports = function abbr(state) {
  var tokens = state.tokens, i, l, content, pos;

  if (state.inlineMode) {
    return;
  }

  // Parse inlines
  for (i = 1, l = tokens.length - 1; i < l; i++) {
    if (tokens[i - 1].type === 'paragraph_open' &&
        tokens[i].type === 'inline' &&
        tokens[i + 1].type === 'paragraph_close') {

      content = tokens[i].content;
      while (content.length) {
        pos = parseAbbr(content, state.inline, state.options, state.env);
        if (pos < 0) { break; }
        content = content.slice(pos).trim();
      }

      tokens[i].content = content;
      if (!content.length) {
        tokens[i - 1].tight = true;
        tokens[i + 1].tight = true;
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/abbr2.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/abbr2.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Enclose abbreviations in <abbr> tags
//



var PUNCT_CHARS = ' \n()[]\'".,!?-';


// from Google closure library
// http://closure-library.googlecode.com/git-history/docs/local_closure_goog_string_string.js.source.html#line1021
function regEscape(s) {
  return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1');
}


module.exports = function abbr2(state) {
  var i, j, l, tokens, token, text, nodes, pos, level, reg, m, regText,
      blockTokens = state.tokens;

  if (!state.env.abbreviations) { return; }
  if (!state.env.abbrRegExp) {
    regText = '(^|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])'
            + '(' + Object.keys(state.env.abbreviations).map(function (x) {
                      return x.substr(1);
                    }).sort(function (a, b) {
                      return b.length - a.length;
                    }).map(regEscape).join('|') + ')'
            + '($|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])';
    state.env.abbrRegExp = new RegExp(regText, 'g');
  }
  reg = state.env.abbrRegExp;

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline') { continue; }
    tokens = blockTokens[j].children;

    // We scan from the end, to keep position when new tags added.
    for (i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i];
      if (token.type !== 'text') { continue; }

      pos = 0;
      text = token.content;
      reg.lastIndex = 0;
      level = token.level;
      nodes = [];

      while ((m = reg.exec(text))) {
        if (reg.lastIndex > pos) {
          nodes.push({
            type: 'text',
            content: text.slice(pos, m.index + m[1].length),
            level: level
          });
        }

        nodes.push({
          type: 'abbr_open',
          title: state.env.abbreviations[':' + m[2]],
          level: level++
        });
        nodes.push({
          type: 'text',
          content: m[2],
          level: level
        });
        nodes.push({
          type: 'abbr_close',
          level: --level
        });
        pos = reg.lastIndex - m[3].length;
      }

      if (!nodes.length) { continue; }

      if (pos < text.length) {
        nodes.push({
          type: 'text',
          content: text.slice(pos),
          level: level
        });
      }

      // replace current node
      blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/block.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/block.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function block(state) {

  if (state.inlineMode) {
    state.tokens.push({
      type: 'inline',
      content: state.src.replace(/\n/g, ' ').trim(),
      level: 0,
      lines: [ 0, 1 ],
      children: []
    });

  } else {
    state.block.parse(state.src, state.options, state.env, state.tokens);
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/footnote_tail.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/footnote_tail.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



module.exports = function footnote_block(state) {
  var i, l, j, t, lastParagraph, list, tokens, current, currentLabel,
      level = 0,
      insideRef = false,
      refTokens = {};

  if (!state.env.footnotes) { return; }

  state.tokens = state.tokens.filter(function(tok) {
    if (tok.type === 'footnote_reference_open') {
      insideRef = true;
      current = [];
      currentLabel = tok.label;
      return false;
    }
    if (tok.type === 'footnote_reference_close') {
      insideRef = false;
      // prepend ':' to avoid conflict with Object.prototype members
      refTokens[':' + currentLabel] = current;
      return false;
    }
    if (insideRef) { current.push(tok); }
    return !insideRef;
  });

  if (!state.env.footnotes.list) { return; }
  list = state.env.footnotes.list;

  state.tokens.push({
    type: 'footnote_block_open',
    level: level++
  });
  for (i = 0, l = list.length; i < l; i++) {
    state.tokens.push({
      type: 'footnote_open',
      id: i,
      level: level++
    });

    if (list[i].tokens) {
      tokens = [];
      tokens.push({
        type: 'paragraph_open',
        tight: false,
        level: level++
      });
      tokens.push({
        type: 'inline',
        content: '',
        level: level,
        children: list[i].tokens
      });
      tokens.push({
        type: 'paragraph_close',
        tight: false,
        level: --level
      });
    } else if (list[i].label) {
      tokens = refTokens[':' + list[i].label];
    }

    state.tokens = state.tokens.concat(tokens);
    if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {
      lastParagraph = state.tokens.pop();
    } else {
      lastParagraph = null;
    }

    t = list[i].count > 0 ? list[i].count : 1;
    for (j = 0; j < t; j++) {
      state.tokens.push({
        type: 'footnote_anchor',
        id: i,
        subId: j,
        level: level
      });
    }

    if (lastParagraph) {
      state.tokens.push(lastParagraph);
    }

    state.tokens.push({
      type: 'footnote_close',
      level: --level
    });
  }
  state.tokens.push({
    type: 'footnote_block_close',
    level: --level
  });
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/inline.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/inline.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function inline(state) {
  var tokens = state.tokens, tok, i, l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.inline.parse(tok.content, state.options, state.env, tok.children);
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/linkify.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/linkify.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Replace link-like texts with link nodes.
//
// Currently restricted by `inline.validateLink()` to http/https/ftp
//



var Autolinker = __webpack_require__(/*! autolinker */ "./node_modules/.registry.npmjs.org/autolinker/0.15.3/node_modules/autolinker/dist/Autolinker.js");


var LINK_SCAN_RE = /www|@|\:\/\//;


function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}

// Stupid fabric to avoid singletons, for thread safety.
// Required for engines like Nashorn.
//
function createLinkifier() {
  var links = [];
  var autolinker = new Autolinker({
    stripPrefix: false,
    url: true,
    email: true,
    twitter: false,
    replaceFn: function (linker, match) {
      // Only collect matched strings but don't change anything.
      switch (match.getType()) {
        /*eslint default-case:0*/
        case 'url':
          links.push({
            text: match.matchedText,
            url: match.getUrl()
          });
          break;
        case 'email':
          links.push({
            text: match.matchedText,
            // normalize email protocol
            url: 'mailto:' + match.getEmail().replace(/^mailto:/i, '')
          });
          break;
      }
      return false;
    }
  });

  return {
    links: links,
    autolinker: autolinker
  };
}


module.exports = function linkify(state) {
  var i, j, l, tokens, token, text, nodes, ln, pos, level, htmlLinkLevel,
      blockTokens = state.tokens,
      linkifier = null, links, autolinker;

  if (!state.options.linkify) { return; }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline') { continue; }
    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i];

      // Skip content of markdown links
      if (token.type === 'link_close') {
        i--;
        while (tokens[i].level !== token.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (token.type === 'htmltag') {
        if (isLinkOpen(token.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(token.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) { continue; }

      if (token.type === 'text' && LINK_SCAN_RE.test(token.content)) {

        // Init linkifier in lazy manner, only if required.
        if (!linkifier) {
          linkifier = createLinkifier();
          links = linkifier.links;
          autolinker = linkifier.autolinker;
        }

        text = token.content;
        links.length = 0;
        autolinker.link(text);

        if (!links.length) { continue; }

        // Now split string to nodes
        nodes = [];
        level = token.level;

        for (ln = 0; ln < links.length; ln++) {

          if (!state.inline.validateLink(links[ln].url)) { continue; }

          pos = text.indexOf(links[ln].text);

          if (pos) {
            level = level;
            nodes.push({
              type: 'text',
              content: text.slice(0, pos),
              level: level
            });
          }
          nodes.push({
            type: 'link_open',
            href: links[ln].url,
            title: '',
            level: level++
          });
          nodes.push({
            type: 'text',
            content: links[ln].text,
            level: level
          });
          nodes.push({
            type: 'link_close',
            level: --level
          });
          text = text.slice(pos + links[ln].text.length);
        }
        if (text.length) {
          nodes.push({
            type: 'text',
            content: text,
            level: level
          });
        }

        // replace current node
        blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/references.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/references.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var StateInline          = __webpack_require__(/*! ../rules_inline/state_inline */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/state_inline.js");
var parseLinkLabel       = __webpack_require__(/*! ../helpers/parse_link_label */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_label.js");
var parseLinkDestination = __webpack_require__(/*! ../helpers/parse_link_destination */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_destination.js");
var parseLinkTitle       = __webpack_require__(/*! ../helpers/parse_link_title */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_title.js");
var normalizeReference   = __webpack_require__(/*! ../helpers/normalize_reference */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_reference.js");


function parseReference(str, parser, options, env) {
  var state, labelEnd, pos, max, code, start, href, title, label;

  if (str.charCodeAt(0) !== 0x5B/* [ */) { return -1; }

  if (str.indexOf(']:') === -1) { return -1; }

  state = new StateInline(str, parser, options, env, []);
  labelEnd = parseLinkLabel(state, 0);

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }

  max = state.posMax;

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    code = state.src.charCodeAt(pos);
    if (code !== 0x20 && code !== 0x0A) { break; }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  if (!parseLinkDestination(state, pos)) { return -1; }
  href = state.linkContent;
  pos = state.pos;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (pos = pos + 1; pos < max; pos++) {
    code = state.src.charCodeAt(pos);
    if (code !== 0x20 && code !== 0x0A) { break; }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  if (pos < max && start !== pos && parseLinkTitle(state, pos)) {
    title = state.linkContent;
    pos = state.pos;
  } else {
    title = '';
    pos = start;
  }

  // ensure that the end of the line is empty
  while (pos < max && state.src.charCodeAt(pos) === 0x20/* space */) { pos++; }
  if (pos < max && state.src.charCodeAt(pos) !== 0x0A) { return -1; }

  label = normalizeReference(str.slice(1, labelEnd));
  if (typeof env.references[label] === 'undefined') {
    env.references[label] = { title: title, href: href };
  }

  return pos;
}


module.exports = function references(state) {
  var tokens = state.tokens, i, l, content, pos;

  state.env.references = state.env.references || {};

  if (state.inlineMode) {
    return;
  }

  // Scan definitions in paragraph inlines
  for (i = 1, l = tokens.length - 1; i < l; i++) {
    if (tokens[i].type === 'inline' &&
        tokens[i - 1].type === 'paragraph_open' &&
        tokens[i + 1].type === 'paragraph_close') {

      content = tokens[i].content;
      while (content.length) {
        pos = parseReference(content, state.inline, state.options, state.env);
        if (pos < 0) { break; }
        content = content.slice(pos).trim();
      }

      tokens[i].content = content;
      if (!content.length) {
        tokens[i - 1].tight = true;
        tokens[i + 1].tight = true;
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/replacements.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/replacements.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Simple typographical replacements
//


// TODO:
// - fractionals 1/2, 1/4, 3/4 -> Â½, Â¼, Â¾
// - miltiplication 2 x 4 -> 2 Ã 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  'c': 'Â©',
  'r': 'Â®',
  'p': 'Â§',
  'tm': 'â¢'
};

function replaceScopedAbbr(str) {
  if (str.indexOf('(') < 0) { return str; }

  return str.replace(SCOPED_ABBR_RE, function(match, name) {
    return SCOPED_ABBR[name.toLowerCase()];
  });
}


module.exports = function replace(state) {
  var i, token, text, inlineTokens, blkIdx;

  if (!state.options.typographer) { return; }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') { continue; }

    inlineTokens = state.tokens[blkIdx].children;

    for (i = inlineTokens.length - 1; i >= 0; i--) {
      token = inlineTokens[i];
      if (token.type === 'text') {
        text = token.content;

        text = replaceScopedAbbr(text);

        if (RARE_RE.test(text)) {
          text = text
            .replace(/\+-/g, 'Â±')
            // .., ..., ....... -> â¦
            // but ?..... & !..... -> ?.. & !..
            .replace(/\.{2,}/g, 'â¦').replace(/([?!])â¦/g, '$1..')
            .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
            // em-dash
            .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
            // en-dash
            .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2')
            .replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
        }

        token.content = text;
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/smartquotes.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/smartquotes.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Convert straight quotation marks to typographic ones
//



var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var PUNCT_RE = /[-\s()\[\]]/;
var APOSTROPHE = 'â';

// This function returns true if the character at `pos`
// could be inside a word.
function isLetter(str, pos) {
  if (pos < 0 || pos >= str.length) { return false; }
  return !PUNCT_RE.test(str[pos]);
}


function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}


module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var i, token, text, t, pos, max, thisLevel, lastSpace, nextSpace, item,
      canOpen, canClose, j, isSingle, blkIdx, tokens,
      stack;

  if (!state.options.typographer) { return; }

  stack = [];

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') { continue; }

    tokens = state.tokens[blkIdx].children;
    stack.length = 0;

    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];

      if (token.type !== 'text' || QUOTE_TEST_RE.test(token.text)) { continue; }

      thisLevel = tokens[i].level;

      for (j = stack.length - 1; j >= 0; j--) {
        if (stack[j].level <= thisLevel) { break; }
      }
      stack.length = j + 1;

      text = token.content;
      pos = 0;
      max = text.length;

      /*eslint no-labels:0,block-scoped-var:0*/
      OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        t = QUOTE_RE.exec(text);
        if (!t) { break; }

        lastSpace = !isLetter(text, t.index - 1);
        pos = t.index + 1;
        isSingle = (t[0] === "'");
        nextSpace = !isLetter(text, pos);

        if (!nextSpace && !lastSpace) {
          // middle of word
          if (isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }
          continue;
        }

        canOpen = !nextSpace;
        canClose = !lastSpace;

        if (canClose) {
          // this could be a closing quote, rewind the stack to get a match
          for (j = stack.length - 1; j >= 0; j--) {
            item = stack[j];
            if (stack[j].level < thisLevel) { break; }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              if (isSingle) {
                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[2]);
                token.content = replaceAt(token.content, t.index, state.options.quotes[3]);
              } else {
                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[0]);
                token.content = replaceAt(token.content, t.index, state.options.quotes[1]);
              }
              stack.length = j;
              continue OUTER;
            }
          }
        }

        if (canOpen) {
          stack.push({
            token: i,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/autolink.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/autolink.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process autolinks '<protocol:...>'



var url_schemas   = __webpack_require__(/*! ../common/url_schemas */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/url_schemas.js");
var normalizeLink = __webpack_require__(/*! ../helpers/normalize_link */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_link.js");


/*eslint max-len:0*/
var EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z.\-]{1,25}):([^<>\x00-\x20]*)>/;


module.exports = function autolink(state, silent) {
  var tail, linkMatch, emailMatch, url, fullUrl, pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) { return false; }

  linkMatch = tail.match(AUTOLINK_RE);

  if (linkMatch) {
    if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) { return false; }

    url = linkMatch[0].slice(1, -1);
    fullUrl = normalizeLink(url);
    if (!state.parser.validateLink(url)) { return false; }

    if (!silent) {
      state.push({
        type: 'link_open',
        href: fullUrl,
        level: state.level
      });
      state.push({
        type: 'text',
        content: url,
        level: state.level + 1
      });
      state.push({ type: 'link_close', level: state.level });
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  emailMatch = tail.match(EMAIL_RE);

  if (emailMatch) {

    url = emailMatch[0].slice(1, -1);

    fullUrl = normalizeLink('mailto:' + url);
    if (!state.parser.validateLink(fullUrl)) { return false; }

    if (!silent) {
      state.push({
        type: 'link_open',
        href: fullUrl,
        level: state.level
      });
      state.push({
        type: 'text',
        content: url,
        level: state.level + 1
      });
      state.push({ type: 'link_close', level: state.level });
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/backticks.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/backticks.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse backticks



module.exports = function backticks(state, silent) {
  var start, max, marker, matchStart, matchEnd,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60/* ` */) { return false; }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        state.push({
          type: 'code',
          content: state.src.slice(pos, matchStart)
                              .replace(/[ \n]+/g, ' ')
                              .trim(),
          block: false,
          level: state.level
        });
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) { state.pending += marker; }
  state.pos += marker.length;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/del.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/del.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ~~deleted text~~



module.exports = function del(state, silent) {
  var found,
      pos,
      stack,
      max = state.posMax,
      start = state.pos,
      lastChar,
      nextChar;

  if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 4 >= max) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x7E/* ~ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
  nextChar = state.src.charCodeAt(start + 2);

  if (lastChar === 0x7E/* ~ */) { return false; }
  if (nextChar === 0x7E/* ~ */) { return false; }
  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }

  pos = start + 2;
  while (pos < max && state.src.charCodeAt(pos) === 0x7E/* ~ */) { pos++; }
  if (pos > start + 3) {
    // sequence of 4+ markers taking as literal, same as in a emphasis
    state.pos += pos - start;
    if (!silent) { state.pending += state.src.slice(start, pos); }
    return true;
  }

  state.pos = start + 2;
  stack = 1;

  while (state.pos + 1 < max) {
    if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {
      if (state.src.charCodeAt(state.pos + 1) === 0x7E/* ~ */) {
        lastChar = state.src.charCodeAt(state.pos - 1);
        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;
        if (nextChar !== 0x7E/* ~ */ && lastChar !== 0x7E/* ~ */) {
          if (lastChar !== 0x20 && lastChar !== 0x0A) {
            // closing '~~'
            stack--;
          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {
            // opening '~~'
            stack++;
          } // else {
            //  // standalone ' ~~ ' indented with spaces
            // }
          if (stack <= 0) {
            found = true;
            break;
          }
        }
      }
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 2;

  if (!silent) {
    state.push({ type: 'del_open', level: state.level++ });
    state.parser.tokenize(state);
    state.push({ type: 'del_close', level: --state.level });
  }

  state.pos = state.posMax + 2;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/emphasis.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/emphasis.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process *this* and _that_




function isAlphaNum(code) {
  return (code >= 0x30 /* 0 */ && code <= 0x39 /* 9 */) ||
         (code >= 0x41 /* A */ && code <= 0x5A /* Z */) ||
         (code >= 0x61 /* a */ && code <= 0x7A /* z */);
}

// parse sequence of emphasis markers,
// "start" should point at a valid marker
function scanDelims(state, start) {
  var pos = start, lastChar, nextChar, count,
      can_open = true,
      can_close = true,
      max = state.posMax,
      marker = state.src.charCodeAt(start);

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;

  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }
  if (pos >= max) { can_open = false; }
  count = pos - start;

  if (count >= 4) {
    // sequence of four or more unescaped markers can't start/end an emphasis
    can_open = can_close = false;
  } else {
    nextChar = pos < max ? state.src.charCodeAt(pos) : -1;

    // check whitespace conditions
    if (nextChar === 0x20 || nextChar === 0x0A) { can_open = false; }
    if (lastChar === 0x20 || lastChar === 0x0A) { can_close = false; }

    if (marker === 0x5F /* _ */) {
      // check if we aren't inside the word
      if (isAlphaNum(lastChar)) { can_open = false; }
      if (isAlphaNum(nextChar)) { can_close = false; }
    }
  }

  return {
    can_open: can_open,
    can_close: can_close,
    delims: count
  };
}

module.exports = function emphasis(state, silent) {
  var startCount,
      count,
      found,
      oldCount,
      newCount,
      stack,
      res,
      max = state.posMax,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (marker !== 0x5F/* _ */ && marker !== 0x2A /* * */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode

  res = scanDelims(state, start);
  startCount = res.delims;
  if (!res.can_open) {
    state.pos += startCount;
    if (!silent) { state.pending += state.src.slice(start, state.pos); }
    return true;
  }

  if (state.level >= state.options.maxNesting) { return false; }

  state.pos = start + startCount;
  stack = [ startCount ];

  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === marker) {
      res = scanDelims(state, state.pos);
      count = res.delims;
      if (res.can_close) {
        oldCount = stack.pop();
        newCount = count;

        while (oldCount !== newCount) {
          if (newCount < oldCount) {
            stack.push(oldCount - newCount);
            break;
          }

          // assert(newCount > oldCount)
          newCount -= oldCount;

          if (stack.length === 0) { break; }
          state.pos += oldCount;
          oldCount = stack.pop();
        }

        if (stack.length === 0) {
          startCount = oldCount;
          found = true;
          break;
        }
        state.pos += count;
        continue;
      }

      if (res.can_open) { stack.push(count); }
      state.pos += count;
      continue;
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + startCount;

  if (!silent) {
    if (startCount === 2 || startCount === 3) {
      state.push({ type: 'strong_open', level: state.level++ });
    }
    if (startCount === 1 || startCount === 3) {
      state.push({ type: 'em_open', level: state.level++ });
    }

    state.parser.tokenize(state);

    if (startCount === 1 || startCount === 3) {
      state.push({ type: 'em_close', level: --state.level });
    }
    if (startCount === 2 || startCount === 3) {
      state.push({ type: 'strong_close', level: --state.level });
    }
  }

  state.pos = state.posMax + startCount;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/entity.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/entity.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html entity - &#123;, &#xAF;, &quot;, ...



var entities          = __webpack_require__(/*! ../common/entities */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/entities.js");
var has               = __webpack_require__(/*! ../common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").has;
var isValidEntityCode = __webpack_require__(/*! ../common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").isValidEntityCode;
var fromCodePoint     = __webpack_require__(/*! ../common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").fromCodePoint;


var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;


module.exports = function entity(state, silent) {
  var ch, code, match, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
      match = state.src.slice(pos).match(DIGITAL_RE);
      if (match) {
        if (!silent) {
          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
        }
        state.pos += match[0].length;
        return true;
      }
    } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) { state.pending += entities[match[1]]; }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) { state.pending += '&'; }
  state.pos++;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/escape.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/escape.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess escaped chars and hardbreaks



var ESCAPED = [];

for (var i = 0; i < 256; i++) { ESCAPED.push(0); }

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'
  .split('').forEach(function(ch) { ESCAPED[ch.charCodeAt(0)] = 1; });


module.exports = function escape(state, silent) {
  var ch, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C/* \ */) { return false; }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) { state.pending += state.src[pos]; }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push({
          type: 'hardbreak',
          level: state.level
        });
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) { state.pending += '\\'; }
  state.pos++;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/footnote_inline.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/footnote_inline.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process inline footnotes (^[...])



var parseLinkLabel = __webpack_require__(/*! ../helpers/parse_link_label */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_label.js");


module.exports = function footnote_inline(state, silent) {
  var labelStart,
      labelEnd,
      footnoteId,
      oldLength,
      max = state.posMax,
      start = state.pos;

  if (start + 2 >= max) { return false; }
  if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x5B/* [ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  labelStart = start + 2;
  labelEnd = parseLinkLabel(state, start + 1);

  // parser failed to find ']', so it's not a valid note
  if (labelEnd < 0) { return false; }

  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    if (!state.env.footnotes) { state.env.footnotes = {}; }
    if (!state.env.footnotes.list) { state.env.footnotes.list = []; }
    footnoteId = state.env.footnotes.list.length;

    state.pos = labelStart;
    state.posMax = labelEnd;

    state.push({
      type: 'footnote_ref',
      id: footnoteId,
      level: state.level
    });
    state.linkLevel++;
    oldLength = state.tokens.length;
    state.parser.tokenize(state);
    state.env.footnotes.list[footnoteId] = { tokens: state.tokens.splice(oldLength) };
    state.linkLevel--;
  }

  state.pos = labelEnd + 1;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/footnote_ref.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/footnote_ref.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process footnote references ([^...])




module.exports = function footnote_ref(state, silent) {
  var label,
      pos,
      footnoteId,
      footnoteSubId,
      max = state.posMax,
      start = state.pos;

  // should be at least 4 chars - "[^x]"
  if (start + 3 > max) { return false; }

  if (!state.env.footnotes || !state.env.footnotes.refs) { return false; }
  if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  for (pos = start + 2; pos < max; pos++) {
    if (state.src.charCodeAt(pos) === 0x20) { return false; }
    if (state.src.charCodeAt(pos) === 0x0A) { return false; }
    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {
      break;
    }
  }

  if (pos === start + 2) { return false; } // no empty footnote labels
  if (pos >= max) { return false; }
  pos++;

  label = state.src.slice(start + 2, pos - 1);
  if (typeof state.env.footnotes.refs[':' + label] === 'undefined') { return false; }

  if (!silent) {
    if (!state.env.footnotes.list) { state.env.footnotes.list = []; }

    if (state.env.footnotes.refs[':' + label] < 0) {
      footnoteId = state.env.footnotes.list.length;
      state.env.footnotes.list[footnoteId] = { label: label, count: 0 };
      state.env.footnotes.refs[':' + label] = footnoteId;
    } else {
      footnoteId = state.env.footnotes.refs[':' + label];
    }

    footnoteSubId = state.env.footnotes.list[footnoteId].count;
    state.env.footnotes.list[footnoteId].count++;

    state.push({
      type: 'footnote_ref',
      id: footnoteId,
      subId: footnoteSubId,
      level: state.level
    });
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/htmltag.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/htmltag.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html tags




var HTML_TAG_RE = __webpack_require__(/*! ../common/html_re */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/html_re.js").HTML_TAG_RE;


function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
}


module.exports = function htmltag(state, silent) {
  var ch, match, max, pos = state.pos;

  if (!state.options.html) { return false; }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||
      pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21/* ! */ &&
      ch !== 0x3F/* ? */ &&
      ch !== 0x2F/* / */ &&
      !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) { return false; }

  if (!silent) {
    state.push({
      type: 'htmltag',
      content: state.src.slice(pos, pos + match[0].length),
      level: state.level
    });
  }
  state.pos += match[0].length;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/ins.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/ins.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ++inserted text++



module.exports = function ins(state, silent) {
  var found,
      pos,
      stack,
      max = state.posMax,
      start = state.pos,
      lastChar,
      nextChar;

  if (state.src.charCodeAt(start) !== 0x2B/* + */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 4 >= max) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x2B/* + */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
  nextChar = state.src.charCodeAt(start + 2);

  if (lastChar === 0x2B/* + */) { return false; }
  if (nextChar === 0x2B/* + */) { return false; }
  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }

  pos = start + 2;
  while (pos < max && state.src.charCodeAt(pos) === 0x2B/* + */) { pos++; }
  if (pos !== start + 2) {
    // sequence of 3+ markers taking as literal, same as in a emphasis
    state.pos += pos - start;
    if (!silent) { state.pending += state.src.slice(start, pos); }
    return true;
  }

  state.pos = start + 2;
  stack = 1;

  while (state.pos + 1 < max) {
    if (state.src.charCodeAt(state.pos) === 0x2B/* + */) {
      if (state.src.charCodeAt(state.pos + 1) === 0x2B/* + */) {
        lastChar = state.src.charCodeAt(state.pos - 1);
        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;
        if (nextChar !== 0x2B/* + */ && lastChar !== 0x2B/* + */) {
          if (lastChar !== 0x20 && lastChar !== 0x0A) {
            // closing '++'
            stack--;
          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {
            // opening '++'
            stack++;
          } // else {
            //  // standalone ' ++ ' indented with spaces
            // }
          if (stack <= 0) {
            found = true;
            break;
          }
        }
      }
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 2;

  if (!silent) {
    state.push({ type: 'ins_open', level: state.level++ });
    state.parser.tokenize(state);
    state.push({ type: 'ins_close', level: --state.level });
  }

  state.pos = state.posMax + 2;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/links.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/links.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process [links](<to> "stuff")



var parseLinkLabel       = __webpack_require__(/*! ../helpers/parse_link_label */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_label.js");
var parseLinkDestination = __webpack_require__(/*! ../helpers/parse_link_destination */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_destination.js");
var parseLinkTitle       = __webpack_require__(/*! ../helpers/parse_link_title */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_title.js");
var normalizeReference   = __webpack_require__(/*! ../helpers/normalize_reference */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_reference.js");


module.exports = function links(state, silent) {
  var labelStart,
      labelEnd,
      label,
      href,
      title,
      pos,
      ref,
      code,
      isImage = false,
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (marker === 0x21/* ! */) {
    isImage = true;
    marker = state.src.charCodeAt(++start);
  }

  if (marker !== 0x5B/* [ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  labelStart = start + 1;
  labelEnd = parseLinkLabel(state, start);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) { return false; }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
    //
    // Inline link
    //

    // [link](  <href>  "title"  )
    //        ^^ skipping these spaces
    pos++;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (code !== 0x20 && code !== 0x0A) { break; }
    }
    if (pos >= max) { return false; }

    // [link](  <href>  "title"  )
    //          ^^^^^^ parsing link destination
    start = pos;
    if (parseLinkDestination(state, pos)) {
      href = state.linkContent;
      pos = state.pos;
    } else {
      href = '';
    }

    // [link](  <href>  "title"  )
    //                ^^ skipping these spaces
    start = pos;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (code !== 0x20 && code !== 0x0A) { break; }
    }

    // [link](  <href>  "title"  )
    //                  ^^^^^^^ parsing link title
    if (pos < max && start !== pos && parseLinkTitle(state, pos)) {
      title = state.linkContent;
      pos = state.pos;

      // [link](  <href>  "title"  )
      //                         ^^ skipping these spaces
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (code !== 0x20 && code !== 0x0A) { break; }
      }
    } else {
      title = '';
    }

    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    //
    // Link reference
    //

    // do not allow nested reference links
    if (state.linkLevel > 0) { return false; }

    // [foo]  [bar]
    //      ^^ optional whitespace (can include newlines)
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (code !== 0x20 && code !== 0x0A) { break; }
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
      start = pos + 1;
      pos = parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = start - 1;
      }
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      if (typeof label === 'undefined') {
        pos = labelEnd + 1;
      }
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    if (isImage) {
      state.push({
        type: 'image',
        src: href,
        title: title,
        alt: state.src.substr(labelStart, labelEnd - labelStart),
        level: state.level
      });
    } else {
      state.push({
        type: 'link_open',
        href: href,
        title: title,
        level: state.level++
      });
      state.linkLevel++;
      state.parser.tokenize(state);
      state.linkLevel--;
      state.push({ type: 'link_close', level: --state.level });
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/mark.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/mark.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ==highlighted text==



module.exports = function del(state, silent) {
  var found,
      pos,
      stack,
      max = state.posMax,
      start = state.pos,
      lastChar,
      nextChar;

  if (state.src.charCodeAt(start) !== 0x3D/* = */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 4 >= max) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x3D/* = */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
  nextChar = state.src.charCodeAt(start + 2);

  if (lastChar === 0x3D/* = */) { return false; }
  if (nextChar === 0x3D/* = */) { return false; }
  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }

  pos = start + 2;
  while (pos < max && state.src.charCodeAt(pos) === 0x3D/* = */) { pos++; }
  if (pos !== start + 2) {
    // sequence of 3+ markers taking as literal, same as in a emphasis
    state.pos += pos - start;
    if (!silent) { state.pending += state.src.slice(start, pos); }
    return true;
  }

  state.pos = start + 2;
  stack = 1;

  while (state.pos + 1 < max) {
    if (state.src.charCodeAt(state.pos) === 0x3D/* = */) {
      if (state.src.charCodeAt(state.pos + 1) === 0x3D/* = */) {
        lastChar = state.src.charCodeAt(state.pos - 1);
        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;
        if (nextChar !== 0x3D/* = */ && lastChar !== 0x3D/* = */) {
          if (lastChar !== 0x20 && lastChar !== 0x0A) {
            // closing '=='
            stack--;
          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {
            // opening '=='
            stack++;
          } // else {
            //  // standalone ' == ' indented with spaces
            // }
          if (stack <= 0) {
            found = true;
            break;
          }
        }
      }
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 2;

  if (!silent) {
    state.push({ type: 'mark_open', level: state.level++ });
    state.parser.tokenize(state);
    state.push({ type: 'mark_close', level: --state.level });
  }

  state.pos = state.posMax + 2;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/newline.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/newline.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess '\n'



module.exports = function newline(state, silent) {
  var pmax, max, pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A/* \n */) { return false; }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        // Strip out all trailing spaces on this line.
        for (var i = pmax - 2; i >= 0; i--) {
          if (state.pending.charCodeAt(i) !== 0x20) {
            state.pending = state.pending.substring(0, i + 1);
            break;
          }
        }
        state.push({
          type: 'hardbreak',
          level: state.level
        });
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push({
          type: 'softbreak',
          level: state.level
        });
      }

    } else {
      state.push({
        type: 'softbreak',
        level: state.level
      });
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }

  state.pos = pos;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/state_inline.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/state_inline.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Inline parser state



function StateInline(src, parserInline, options, env, outTokens) {
  this.src = src;
  this.env = env;
  this.options = options;
  this.parser = parserInline;
  this.tokens = outTokens;
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = [];        // Stores { start: end } pairs. Useful for backtrack
                          // optimization of pairs parse (emphasis, strikes).

  // Link parser state vars

  this.isInLabel = false; // Set true when seek link label - we should disable
                          // "paired" rules (emphasis, strikes) to not skip
                          // tailing `]`

  this.linkLevel = 0;     // Increment for each nesting link. Used to prevent
                          // nesting in definitions

  this.linkContent = '';  // Temporary storage for link url

  this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels
                                 // (backtrack optimization)
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  this.tokens.push({
    type: 'text',
    content: this.pending,
    level: this.pendingLevel
  });
  this.pending = '';
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (token) {
  if (this.pending) {
    this.pushPending();
  }

  this.tokens.push(token);
  this.pendingLevel = this.level;
};

// Store value to cache.
// !!! Implementation has parser-specific optimizations
// !!! keys MUST be integer, >= 0; values MUST be integer, > 0
//
StateInline.prototype.cacheSet = function (key, val) {
  for (var i = this.cache.length; i <= key; i++) {
    this.cache.push(0);
  }

  this.cache[key] = val;
};

// Get cache value
//
StateInline.prototype.cacheGet = function (key) {
  return key < this.cache.length ? this.cache[key] : 0;
};

module.exports = StateInline;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/sub.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/sub.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ~subscript~



// same as UNESCAPE_MD_RE plus a space
var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;

module.exports = function sub(state, silent) {
  var found,
      content,
      max = state.posMax,
      start = state.pos;

  if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 2 >= max) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  state.pos = start + 1;

  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {
      found = true;
      break;
    }

    state.parser.skipToken(state);
  }

  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }

  content = state.src.slice(start + 1, state.pos);

  // don't allow unescaped spaces/newlines inside
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 1;

  if (!silent) {
    state.push({
      type: 'sub',
      level: state.level,
      content: content.replace(UNESCAPE_RE, '$1')
    });
  }

  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/sup.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/sup.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ^superscript^



// same as UNESCAPE_MD_RE plus a space
var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;

module.exports = function sup(state, silent) {
  var found,
      content,
      max = state.posMax,
      start = state.pos;

  if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 2 >= max) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  state.pos = start + 1;

  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 0x5E/* ^ */) {
      found = true;
      break;
    }

    state.parser.skipToken(state);
  }

  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }

  content = state.src.slice(start + 1, state.pos);

  // don't allow unescaped spaces/newlines inside
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 1;

  if (!silent) {
    state.push({
      type: 'sup',
      level: state.level,
      content: content.replace(UNESCAPE_RE, '$1')
    });
  }

  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/text.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/text.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Skip text characters for text token, place those to pending buffer
// and increment current pos



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A/* \n */:
    case 0x5C/* \ */:
    case 0x60/* ` */:
    case 0x2A/* * */:
    case 0x5F/* _ */:
    case 0x5E/* ^ */:
    case 0x5B/* [ */:
    case 0x5D/* ] */:
    case 0x21/* ! */:
    case 0x26/* & */:
    case 0x3C/* < */:
    case 0x3E/* > */:
    case 0x7B/* { */:
    case 0x7D/* } */:
    case 0x24/* $ */:
    case 0x25/* % */:
    case 0x40/* @ */:
    case 0x7E/* ~ */:
    case 0x2B/* + */:
    case 0x3D/* = */:
    case 0x3A/* : */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) { return false; }

  if (!silent) { state.pending += state.src.slice(state.pos, pos); }

  state.pos = pos;

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/setimmediate/1.0.5/node_modules/setimmediate/setImmediate.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/setimmediate/1.0.5/node_modules/setimmediate/setImmediate.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6â8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/4.35.3_webpack@4.35.3/node_modules/webpack/buildin/global.js */ "./node_modules/.registry.npmjs.org/webpack/4.35.3_webpack@4.35.3/node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../process/0.11.10/node_modules/process/browser.js */ "./node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/style-loader/0.20.3/node_modules/style-loader/lib/addStyles.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/style-loader/0.20.3/node_modules/style-loader/lib/addStyles.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target) {
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/.registry.npmjs.org/style-loader/0.20.3/node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/style-loader/0.20.3/node_modules/style-loader/lib/urls.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/style-loader/0.20.3/node_modules/style-loader/lib/urls.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/timers-browserify/2.0.10/node_modules/timers-browserify/main.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/timers-browserify/2.0.10/node_modules/timers-browserify/main.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/.registry.npmjs.org/setimmediate/1.0.5/node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/4.35.3_webpack@4.35.3/node_modules/webpack/buildin/global.js */ "./node_modules/.registry.npmjs.org/webpack/4.35.3_webpack@4.35.3/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/webpack/4.35.3_webpack@4.35.3/node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./secret.js":
/*!*******************!*\
  !*** ./secret.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var onlineUrl = exports.onlineUrl = "https://eu1.prisma.sh/boaz-blake-8951e1/mithril-presenter/dev";

/***/ }),

/***/ "./src/App.js":
/*!********************!*\
  !*** ./src/App.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.App = undefined;

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _mithrilStream = __webpack_require__(/*! mithril-stream */ "./node_modules/.registry.npmjs.org/mithril-stream/1.1.0/node_modules/mithril-stream/stream.js");

var _mithrilStream2 = _interopRequireDefault(_mithrilStream);

var _component = __webpack_require__(/*! ./presentations/component.js */ "./src/presentations/component.js");

var _component2 = _interopRequireDefault(_component);

var _component3 = __webpack_require__(/*! ./slides/component.js */ "./src/slides/component.js");

var _component4 = _interopRequireDefault(_component3);

var _component5 = __webpack_require__(/*! ./editor/component.js */ "./src/editor/component.js");

var _component6 = _interopRequireDefault(_component5);

var _component7 = __webpack_require__(/*! ./layout/component.js */ "./src/layout/component.js");

var _component8 = _interopRequireDefault(_component7);

var _component9 = __webpack_require__(/*! ./slideshow/component.js */ "./src/slideshow/component.js");

var _component10 = _interopRequireDefault(_component9);

var _model = __webpack_require__(/*! ./presentations/model.js */ "./src/presentations/model.js");

var _index = __webpack_require__(/*! ./services/index.js */ "./src/services/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var makeRoutes = function makeRoutes(mdl) {
  var model = (0, _mithrilStream2.default)(mdl);
  return {
    '/presentations': {
      view: function view() {
        return (0, _mithril2.default)(_component8.default, model(), (0, _mithril2.default)(_component2.default, model()));
      }
    },
    '/presentation/:id/slides': {
      view: function view() {
        return (0, _mithril2.default)(_component8.default, model(), (0, _mithril2.default)(_component4.default, model()));
      }
    },
    '/edit/:pid/slide/:id': {
      view: function view() {
        return (0, _mithril2.default)(_component8.default, model(), (0, _mithril2.default)(_component6.default, model()));
      }
    },
    '/slideshow/:id': {
      view: function view() {
        return (0, _mithril2.default)(_component8.default, model(), (0, _mithril2.default)(_component10.default, model()));
      }
    }
  };
};

var App = exports.App = function App(_ref) {
  var model = _ref.attrs;

  var state = {
    errors: ''
  };

  var onError = function onError(error) {
    (0, _index.log)('error')(error);
    state.error = error;
  };

  var onSuccess = function onSuccess(Models) {
    return function (dto) {
      return Models.Presentations = dto;
    };
  };

  var findPresentations = function findPresentations(_ref2) {
    var Models = _ref2.attrs.Models;
    return (0, _model.getPresentations)().fork(onError, onSuccess(Models));
  };

  return {
    oninit: findPresentations,
    oncreate: function oncreate(_ref3) {
      var dom = _ref3.dom;

      var main = dom.querySelector('.main');

      _mithril2.default.route(main, '/presentations', makeRoutes(model));
    },
    view: function view(_ref4) {
      var children = _ref4.children;

      return (0, _mithril2.default)('.app', [(0, _mithril2.default)('.main', children)]);
    }
  };
};

exports.default = App;

/***/ }),

/***/ "./src/Models.js":
/*!***********************!*\
  !*** ./src/Models.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithrilStream = __webpack_require__(/*! mithril-stream */ "./node_modules/.registry.npmjs.org/mithril-stream/1.1.0/node_modules/mithril-stream/stream.js");

var _mithrilStream2 = _interopRequireDefault(_mithrilStream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SlideModel = {
  title: '',
  contents: '',
  order: 0,
  presentation_id: ''
};

var Slides = [];

var Presentations = [];

var SlideShowStruct = {
  keys: new Set(),
  values: {},
  items: (0, _mithrilStream2.default)([])
};

var CurrentPresentation = {
  title: '',
  id: '',
  slideShow: (0, _mithrilStream2.default)([]),
  Slides: Slides
};

var getProfile = function getProfile(w) {
  if (w < 668) return 'phone';
  if (w < 920) return 'tablet';
  return 'desktop';
};

var Models = {
  profile: getProfile(window.innerWidth),
  SlideShowStruct: SlideShowStruct,
  Presentations: Presentations,
  CurrentPresentation: CurrentPresentation,
  SlideModel: SlideModel,
  toggleModal: false
};

exports.default = Models;

/***/ }),

/***/ "./src/Toolbar/component.js":
/*!**********************************!*\
  !*** ./src/Toolbar/component.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var toggleModal = function toggleModal(model) {
  return [(0, _mithril2.default)("a.toolbar-item", {
    onclick: function onclick() {
      return model.toggleModal = !model.toggleModal;
    }
  }, "Add New")];
};
var toPresentations = [(0, _mithril2.default)("a.toolbar-item", {
  oncreate: _mithril2.default.route.link,
  href: "/presentations"
}, "Presentations")];

var toSlides = function toSlides(model) {
  return [(0, _mithril2.default)("a.toolbar-item", {
    oncreate: _mithril2.default.route.link,
    href: "/presentation/" + model.CurrentPresentation.id + "/slides"
  }, "slides")];
};

var toSlideShow = function toSlideShow(model) {
  return [(0, _mithril2.default)("a.toolbar-item", {
    disabled: (0, _ramda.isEmpty)((0, _ramda.length)(model.CurrentPresentation.slideShow)) ? true : false,
    oncreate: _mithril2.default.route.link,
    href: "/slideshow/" + model.CurrentPresentation.id
  }, "Slide Show")];
};

var navView = function navView(model) {
  return function (page) {
    switch (page) {
      case "presentation":
        return [toPresentations, toSlideShow(model)];
        break;

      case "slideshow":
        return [toPresentations, toSlides(model)];
        break;

      case "slides":
        return [toPresentations, toSlideShow(model)];
        break;

      case "edit":
        return [toPresentations, toSlides(model), toSlideShow(model)];
        break;
      default:
    }
  };
};

var actionView = function actionView(model) {
  return function (page) {
    switch (page) {
      case "presentations":
        return [toggleModal(model)];
        break;
      case "presentation":
        return [toggleModal(model)];
        break;
      default:
    }
  };
};

var Toolbar = function Toolbar(_ref) {
  var Models = _ref.attrs.Models;

  var currentPage = (0, _ramda.view)((0, _ramda.lensProp)(1), (0, _ramda.split)("/", _mithril2.default.route.get()));
  return {
    view: function view(_ref2) {
      var Models = _ref2.attrs.Models;
      return (0, _mithril2.default)(".toolbar", [(0, _mithril2.default)(".toolbar-left", [navView(Models)(currentPage)]), (0, _mithril2.default)(".toolbar-right", [actionView(Models)(currentPage)])]);
    }
  };
};

exports.default = Toolbar;

/***/ }),

/***/ "./src/editor/component.js":
/*!*********************************!*\
  !*** ./src/editor/component.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _model = __webpack_require__(/*! ./model.js */ "./src/editor/model.js");

var _remarkable = __webpack_require__(/*! remarkable */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/index.js");

var _remarkable2 = _interopRequireDefault(_remarkable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var md = new _remarkable2.default("full", {
  baseUrl: null,
  breaks: false,
  gfm: true,
  headerIds: true,
  headerPrefix: "",
  highlight: null,
  langPrefix: "lang-",
  mangle: true,
  pedantic: false,
  sanitize: false,
  sanitizer: null,
  silent: true,
  smartLists: true,
  smartypants: true,
  tables: true,
  xhtml: true,
  html: true,
  linkify: true,
  linkTarget: "",
  typographer: true,
  quotes: "ââââ"
});

var Editor = function Editor() {
  var state = { presentationId: "", slide: { title: "", content: "", id: "" } };

  var toSlides = function toSlides(_) {
    return _mithril2.default.route.set("/presentation/" + state.presentationId + "/slides");
  };

  var onError = function onError(error) {
    return log("error")(error);
  };

  var onSuccess = function onSuccess(slide) {
    state.slide = slide;
  };

  var getSlide = function getSlide() {
    state.slide.id = _mithril2.default.route.param("id");
    state.presentationId = _mithril2.default.route.param("pid");
    return (0, _model.loadSlide)(state.slide.id).fork(onError, onSuccess);
  };

  var updateInput = function updateInput(input) {
    return function (e) {
      return state.slide[input] = e.target.value;
    };
  };

  var save = function save(e) {
    e.preventDefault();

    (0, _model.editSlide)(state.slide).fork(onError, function () {
      return toSlides();
    });
  };

  return {
    oncreate: getSlide,
    view: function view(_ref) {
      var Models = _ref.attrs.Models;
      return (0, _mithril2.default)(".container", [(0, _mithril2.default)(".editor-left.card", [(0, _mithril2.default)(".card-header", [(0, _mithril2.default)("input.editor-input", {
        type: "text",
        placeholder: "Slide Title",
        oninput: updateInput("title"),
        value: state.slide.title
      })]), (0, _mithril2.default)("textarea.editor-text", {
        oninput: updateInput("content"),
        value: state.slide.content
      }), (0, _mithril2.default)(".card-footer", [(0, _mithril2.default)("button.card-btn", {
        onclick: save
      }, "Save"), (0, _mithril2.default)("button.card-btn", {
        onclick: toSlides
      }, "Cancel")])]), (0, _mithril2.default)(".editor-right", _mithril2.default.trust(md.render(state.slide.content || "")))]);
    }
  };
};

exports.default = Editor;

/***/ }),

/***/ "./src/editor/model.js":
/*!*****************************!*\
  !*** ./src/editor/model.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.editSlide = exports.loadSlide = undefined;

var _requests = __webpack_require__(/*! ../services/requests.js */ "./src/services/requests.js");

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var loadSlide = exports.loadSlide = function loadSlide(id) {
  var q = '{ slide(where:{id:' + JSON.stringify(id) + '}){\n              id content title\n            }\n          }';
  return (0, _requests.getQlTask)(q).map((0, _ramda.path)(['data', 'slide']));
};

var editSlide = exports.editSlide = function editSlide(_ref) {
  var id = _ref.id,
      title = _ref.title,
      content = _ref.content;

  var q = 'mutation {\n            updateSlide(\n              data: {\n                title: ' + JSON.stringify(title) + '\n                content: ' + JSON.stringify(content) + '\n              }\n              where: {\n                id: ' + JSON.stringify(id) + '\n              }) {\n                id\n                title\n              }\n        }';

  return (0, _requests.getQlTask)(q).map((0, _ramda.path)(['data', 'updatePresentation', 'Slides']));
};

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

__webpack_require__(/*! ./styles/index.css */ "./src/styles/index.css");

var _Models = __webpack_require__(/*! ./Models.js */ "./src/Models.js");

var _Models2 = _interopRequireDefault(_Models);

var _App = __webpack_require__(/*! ./App.js */ "./src/App.js");

var _App2 = _interopRequireDefault(_App);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var root = document.body; // index.jsx

_mithril2.default.render(root, (0, _mithril2.default)(_App2.default, { Models: _Models2.default }));

/***/ }),

/***/ "./src/layout/component.js":
/*!*********************************!*\
  !*** ./src/layout/component.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _component = __webpack_require__(/*! ../Toolbar/component.js */ "./src/Toolbar/component.js");

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Layout = {
  view: function view(_ref) {
    var children = _ref.children,
        Models = _ref.attrs;
    return [(0, _mithril2.default)(_component2.default, Models), children];
  }
};

exports.default = Layout;

/***/ }),

/***/ "./src/presentations/Presentation/component.js":
/*!*****************************************************!*\
  !*** ./src/presentations/Presentation/component.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _index = __webpack_require__(/*! ../../services/index.js */ "./src/services/index.js");

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _model = __webpack_require__(/*! ../model.js */ "./src/presentations/model.js");

var _data = __webpack_require__(/*! data.task */ "./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/index.js");

var _data2 = _interopRequireDefault(_data);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Presentation = function Presentation(_ref) {
  var _ref$attrs = _ref.attrs,
      title = _ref$attrs.title,
      id = _ref$attrs.id,
      Models = _ref$attrs.Models;

  var onError = function onError(task) {
    return function (error) {
      return (0, _index.log)("error with " + task)(error);
    };
  };
  var onSuccess = function onSuccess(models) {
    return function (deleted) {
      return Models.Presentations = (0, _ramda.without)([deleted], Models.Presentations);
    };
  };

  var authDeleteTask = function authDeleteTask(id) {
    return window.confirm("Are you sure you want to delete?") ? _data2.default.of(id) : _data2.default.rejected(id);
  };

  var removePresTask = function removePresTask(pId) {
    return authDeleteTask(pId).chain(_model.deletePresentationsTask).fork(onError("deleting"), onSuccess(Models));
  };

  return {
    view: function view(_ref2) {
      var _ref2$attrs = _ref2.attrs,
          title = _ref2$attrs.title,
          id = _ref2$attrs.id,
          Models = _ref2$attrs.Models;
      return (0, _mithril2.default)(".card", [(0, _mithril2.default)("div.card-header", [(0, _mithril2.default)(".card-btn.full-width", {
        onclick: function onclick() {
          return _mithril2.default.route.set("/presentation/" + id + "/slides");
        }
      }, title), (0, _mithril2.default)("button.card-delete", {
        onclick: function onclick() {
          return removePresTask(id);
        }
      })]), (0, _mithril2.default)("div.card-body", []), (0, _mithril2.default)("div.card-footer", [])]);
    }
  };
};

exports.default = Presentation;

/***/ }),

/***/ "./src/presentations/component.js":
/*!****************************************!*\
  !*** ./src/presentations/component.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _animations = __webpack_require__(/*! ../services/animations.js */ "./src/services/animations.js");

var _presentationModal = __webpack_require__(/*! ./presentationModal.js */ "./src/presentations/presentationModal.js");

var _presentationModal2 = _interopRequireDefault(_presentationModal);

var _component = __webpack_require__(/*! ./Presentation/component.js */ "./src/presentations/Presentation/component.js");

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Presentations = function Presentations(_ref) {
  var Models = _ref.attrs.Models;

  var state = {
    errors: [],
    title: ''
  };

  return {
    view: function view(_ref2) {
      var Models = _ref2.attrs.Models;
      return [Models.toggleModal ? (0, _mithril2.default)(_presentationModal2.default, {
        Models: Models,
        state: state,
        toggleModal: function toggleModal() {
          return Models.toggleModal = !Models.toggleModal;
        },
        presentations: Models.Presentations,
        presentationModel: (0, _ramda.clone)(Models.PresentationModel)
      }) : '', (0, _mithril2.default)('.container.presentations', {
        oncreate: function oncreate(_ref3) {
          var dom = _ref3.dom;
          return (0, _animations.animateFadeIn)({ dom: dom });
        },
        onBeforeRemove: function onBeforeRemove(vnode, done) {
          vnode.dom.addEventListener('animationend', done);
          vnode.dom.style.animation = 'fadeOut 1s';
        }
      }, [Models.Presentations && Models.Presentations.map(function (_ref4) {
        var title = _ref4.title,
            id = _ref4.id;
        return (0, _mithril2.default)(_component2.default, {
          key: id,
          id: id,
          title: title,
          Models: Models
        });
      })])];
    }
  };
};

exports.default = Presentations;

/***/ }),

/***/ "./src/presentations/model.js":
/*!************************************!*\
  !*** ./src/presentations/model.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deletePresentationsTask = exports.savePresentationTask = exports.getPresentations = undefined;

var _requests = __webpack_require__(/*! ../services/requests.js */ "./src/services/requests.js");

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _index = __webpack_require__(/*! ../services/index.js */ "./src/services/index.js");

var toViewModel = function toViewModel(_ref) {
  var data = _ref.data,
      errors = _ref.errors;

  console.log('errors', errors);
  console.log('data', data);
  return { data: data, errors: errors };
};

var getPresentations = exports.getPresentations = function getPresentations() {
  return (0, _requests.getQlTask)('query {\n  presentations{ id, title}\n}').map((0, _ramda.path)(['data', 'presentations']));
};

var savePresentationTask = exports.savePresentationTask = function savePresentationTask(state) {
  var q = 'mutation {\n    createPresentation(data: {title: ' + JSON.stringify(state.title) + '})\n    { title id}\n  }';
  return (0, _requests.getQlTask)(q).map((0, _ramda.path)(['data', 'createPresentation']));
};

var deletePresentationsTask = exports.deletePresentationsTask = function deletePresentationsTask(id) {
  var q = 'mutation {\n    deletePresentation(where: {id: ' + JSON.stringify(id) + '})\n    { title id}\n  }';
  return (0, _requests.getQlTask)(q).map((0, _ramda.path)(['data', 'deletePresentation']));
};

/***/ }),

/***/ "./src/presentations/presentationModal.js":
/*!************************************************!*\
  !*** ./src/presentations/presentationModal.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _model = __webpack_require__(/*! ./model.js */ "./src/presentations/model.js");

var _index = __webpack_require__(/*! ../services/index.js */ "./src/services/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PresentationModal = function PresentationModal(_ref) {
  var attrs = _ref.attrs;

  var onError = function onError(errors) {
    (0, _index.log)("error")(errors);
    attrs.state.errors = errors;
    attrs.toggleModal();
  };
  var onSuccess = function onSuccess(p) {
    attrs.state.title = "";
    attrs.state.errors = [];
    attrs.presentations.push(p);
    attrs.toggleModal();
  };

  var save = function save(e) {
    e.preventDefault();
    (0, _model.savePresentationTask)(attrs.state).fork(onError, onSuccess);
  };

  return {
    view: function view() {
      return (0, _mithril2.default)("article.modal-container", [(0, _mithril2.default)(".card", [(0, _mithril2.default)(".card-header", (0, _mithril2.default)("button.card-delete", {
        onclick: function onclick() {
          return attrs.toggleModal();
        },
        "aria-label": "close"
      })), (0, _mithril2.default)(".card-body", [(0, _mithril2.default)("fieldset", [(0, _mithril2.default)("label.modal-label", "Presentation Name"), (0, _mithril2.default)("input.modal-input", {
        autofocus: true,
        type: "text",
        onchange: function onchange(e) {
          return attrs.state.title = e.target.value;
        }
      })])]), (0, _mithril2.default)(".card-footer", (0, _mithril2.default)("button.card-btn", { onclick: save }, "save presentation"))])]);
    }
  };
};

exports.default = PresentationModal;

/***/ }),

/***/ "./src/services/Tasks.js":
/*!*******************************!*\
  !*** ./src/services/Tasks.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.postQl = undefined;

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _data = __webpack_require__(/*! data.task */ "./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/index.js");

var _data2 = _interopRequireDefault(_data);

var _index = __webpack_require__(/*! ./index.js */ "./src/services/index.js");

var _secret = __webpack_require__(/*! ../../secret.js */ "./secret.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var postQl = exports.postQl = function postQl(query) {
  return new _data2.default(function (rej, res) {
    return _mithril2.default.request({
      method: "POST",
      url: "" + _secret.onlineUrl,
      withCredentials: false,
      body: (0, _index.makeQuery)(query)
    }).then(res, rej);
  });
};

var postTask = function postTask(url) {
  return function (_ref) {
    var dto = _ref.dto;
    return new _data2.default(function (rej, res) {
      return _mithril2.default.request({
        method: "POST",
        url: _secret.onlineUrl + "/" + url,
        body: dto,
        withCredentials: false
      }).then(res, rej);
    });
  };
};

var putTask = function putTask(url) {
  return function (_ref2) {
    var dto = _ref2.dto;
    return new _data2.default(function (rej, res) {
      return _mithril2.default.request({
        method: "PUT",
        url: _secret.onlineUrl + "/" + url,
        body: dto,
        withCredentials: false
      }).then(res, rej);
    });
  };
};

var getTask = function getTask(url) {
  return new _data2.default(function (rej, res) {
    return _mithril2.default.request({
      method: "GET",
      url: _secret.onlineUrl + "/" + url,
      withCredentials: false
    }).then(res, rej);
  });
};

var deleteTask = function deleteTask(url) {
  return function (id) {
    return new _data2.default(function (rej, res) {
      return _mithril2.default.request({
        method: "DELETE",
        url: _secret.onlineUrl + "/" + url + "/" + id,
        withCredentials: false
      }).then(res, rej);
    });
  };
};

exports.default = { postTask: postTask, putTask: putTask, getTask: getTask, deleteTask: deleteTask, postQl: postQl };

/***/ }),

/***/ "./src/services/animations.js":
/*!************************************!*\
  !*** ./src/services/animations.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bounceEntrance = exports.animeEntrance = exports.animateFadeOut = exports.animateFadeIn = exports.animateExit = exports.animateChildEntrance = exports.animateEntranceRight = exports.animateSlideEntrance = undefined;

var _animejs = __webpack_require__(/*! animejs */ "./node_modules/.registry.npmjs.org/animejs/3.0.1/node_modules/animejs/lib/anime.es.js");

var _animejs2 = _interopRequireDefault(_animejs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var animateSlideEntrance = exports.animateSlideEntrance = function animateSlideEntrance(_ref) {
  var dom = _ref.dom;

  return dom.animate([{ transform: "translate3d(20%,0,0)", opacity: 0 }, { transform: "none", opacity: 1 }], {
    duration: 650
  });
};

var animateEntranceRight = exports.animateEntranceRight = function animateEntranceRight(_ref2) {
  var dom = _ref2.dom;

  return dom.animate([{
    animation: "",
    transform: "translate3d(100%,0,0)",
    scale: 2,
    opacity: 0
  }, {
    animation: "stretchRight 1s ease-in-out both",
    transform: "none",
    opacity: 1,
    scale: 1
  }], {
    duration: 350
  });
};

var animateChildEntrance = exports.animateChildEntrance = function animateChildEntrance(_ref3) {
  var dom = _ref3.dom;

  console.log("wtf", dom);
  var children = [].concat(_toConsumableArray(dom.children));

  return children.map(function (child, index) {
    setTimeout(function () {
      child.animate([{ transform: "translate3d(0,-100%,0)", opacity: 0 }, { transform: "none", opacity: 1 }], {
        duration: 850
      });
    }, (index + 1) * 200);
  });
};

var animateExit = exports.animateExit = function animateExit(dom) {
  var children = [].concat(_toConsumableArray(dom.children));

  var anim = animate([{ transform: "none", opacity: 1 }, { transform: "translate3d(25%,100%,0)", opacity: 0 }]);

  var waapi = children.map(function (child) {
    return child.animate(anim, {
      duration: 850
    });
  });

  return new Promise(function (resolve) {
    waapi.onfinish = function (e) {
      resolve();
    };
  });
};

var animateFadeIn = exports.animateFadeIn = function animateFadeIn(_ref4) {
  var dom = _ref4.dom;

  var children = [].concat(_toConsumableArray(dom.children));
  children.map(function (child, index) {
    child.style.opacity = 0;
    child.style.transition = "opacity .4s ease-in-out";

    return setTimeout(function () {
      child.style.opacity = 1;
    }, (index + 1) * 200);
  });
};

var animateFadeOut = exports.animateFadeOut = function animateFadeOut(_ref5) {
  var dom = _ref5.dom;

  var anim = [{ transition: "opacity .4s ease-in-out" }, { transform: "none", opacity: 1 }, { transform: "translate3d(25%,100%,0)", opacity: 0 }];
  var waapi = dom.animate(anim, {
    duration: 850
  });

  return new Promise(function (resolve) {
    waapi.onfinish = function (e) {
      resolve();
    };
  });
};

var animeEntrance = exports.animeEntrance = function animeEntrance(_ref6) {
  var dom = _ref6.dom;

  var children = [].concat(_toConsumableArray(dom.children));
  console.log(children);
  var res = children.map(function (el) {
    return (0, _animejs2.default)({
      target: el,
      easing: "easeInQuad",
      translateX: 250,
      offset: 0
    });
  });

  console.log("anim", res);
  return res;
};

var bounceEntrance = exports.bounceEntrance = function bounceEntrance(_ref7) {
  var dom = _ref7.dom;

  return dom.animate({
    animation: "animation 1000ms linear both",
    keyframes: {
      "0%": {
        transform: "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "3.4%": {
        transform: "matrix3d(1.316, 0, 0, 0, 0, 1.407, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "4.7%": {
        transform: "matrix3d(1.45, 0, 0, 0, 0, 1.599, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "6.81%": {
        transform: "matrix3d(1.659, 0, 0, 0, 0, 1.893, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "9.41%": {
        transform: "matrix3d(1.883, 0, 0, 0, 0, 2.168, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "10.21%": {
        transform: "matrix3d(1.942, 0, 0, 0, 0, 2.226, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "13.61%": {
        transform: "matrix3d(2.123, 0, 0, 0, 0, 2.332, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "14.11%": {
        transform: "matrix3d(2.141, 0, 0, 0, 0, 2.331, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "17.52%": {
        transform: "matrix3d(2.208, 0, 0, 0, 0, 2.239, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "18.72%": {
        transform: "matrix3d(2.212, 0, 0, 0, 0, 2.187, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "21.32%": {
        transform: "matrix3d(2.196, 0, 0, 0, 0, 2.069, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "24.32%": {
        transform: "matrix3d(2.151, 0, 0, 0, 0, 1.96, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "25.23%": {
        transform: "matrix3d(2.134, 0, 0, 0, 0, 1.938, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "29.03%": {
        transform: "matrix3d(2.063, 0, 0, 0, 0, 1.897, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "29.93%": {
        transform: "matrix3d(2.048, 0, 0, 0, 0, 1.899, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "35.54%": {
        transform: "matrix3d(1.979, 0, 0, 0, 0, 1.962, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "36.74%": {
        transform: "matrix3d(1.972, 0, 0, 0, 0, 1.979, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "41.04%": {
        transform: "matrix3d(1.961, 0, 0, 0, 0, 2.022, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "44.44%": {
        transform: "matrix3d(1.966, 0, 0, 0, 0, 2.032, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "52.15%": {
        transform: "matrix3d(1.991, 0, 0, 0, 0, 2.006, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "59.86%": {
        transform: "matrix3d(2.006, 0, 0, 0, 0, 1.99, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "63.26%": {
        transform: "matrix3d(2.007, 0, 0, 0, 0, 1.992, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "75.28%": {
        transform: "matrix3d(2.001, 0, 0, 0, 0, 2.003, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "85.49%": {
        transform: "matrix3d(1.999, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "90.69%": {
        transform: "matrix3d(1.999, 0, 0, 0, 0, 1.999, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "100%": {
        transform: "matrix3d(2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      }
    }
  });
};

/***/ }),

/***/ "./src/services/index.js":
/*!*******************************!*\
  !*** ./src/services/index.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeQuery = exports.wait = exports.repeat = exports.log = exports.viewModelMap = undefined;

var _mithrilStream = __webpack_require__(/*! mithril-stream */ "./node_modules/.registry.npmjs.org/mithril-stream/1.1.0/node_modules/mithril-stream/stream.js");

var _mithrilStream2 = _interopRequireDefault(_mithrilStream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var makeQuery = function makeQuery(string) {
  return JSON.parse(JSON.stringify(string));
};

var repeat = function repeat(n) {
  return function (f) {
    return function (x) {
      var m = n;
      while (true) {
        if (m === 0) return x;else m = m - 1, x = f(x);
      }
    };
  };
};

var wait = function wait(n) {
  return function (f) {
    return function (x) {
      var m = n;
      while (true) {
        if (m === 0) return x;else m = m - 1, x = f(x);
      }
    };
  };
};

var log = function log(m) {
  return function (v) {
    console.log(m, v);
    return v;
  };
};

var viewModelMap = function viewModelMap(signature) {
  var _map = {};
  return function (key) {
    if (!_map[key]) {
      _map[key] = {};
      for (var prop in signature) {
        _map[key][prop] = (0, _mithrilStream2.default)(signature[prop]());
      }
    }
    return _map[key];
  };
};
exports.viewModelMap = viewModelMap;
exports.log = log;
exports.repeat = repeat;
exports.wait = wait;
exports.makeQuery = makeQuery;

/***/ }),

/***/ "./src/services/requests.js":
/*!**********************************!*\
  !*** ./src/services/requests.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadSlideTask = exports.deleteSlideTask = exports.updateSlideTask = exports.saveSlideTask = exports.findSlidesTask = exports.deletePresentationsTask = exports.savePresentationTask = exports.getQlTask = exports.findPresentationsTask = undefined;

var _Tasks = __webpack_require__(/*! ./Tasks.js */ "./src/services/Tasks.js");

var _Tasks2 = _interopRequireDefault(_Tasks);

var _data = __webpack_require__(/*! data.task */ "./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/index.js");

var _data2 = _interopRequireDefault(_data);

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _index = __webpack_require__(/*! ./index.js */ "./src/services/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var findPresentationsTask = exports.findPresentationsTask = function findPresentationsTask() {
  return _Tasks2.default.getTask('presentations');
};

var getQlTask = exports.getQlTask = function getQlTask(query) {
  return _Tasks2.default.postQl({ query: query });
};

var savePresentationTask = exports.savePresentationTask = function savePresentationTask(dto) {
  return _Tasks2.default.postTask('presentations')({
    dto: dto
  });
};

var deletePresentationsTask = exports.deletePresentationsTask = function deletePresentationsTask(id) {
  return _Tasks2.default.deleteTask('presentations')(id);
};

var findSlidesTask = exports.findSlidesTask = function findSlidesTask(id) {
  return _Tasks2.default.getTask('presentations/' + id + '/slides');
};

var saveSlideTask = exports.saveSlideTask = function saveSlideTask(dto) {
  return _Tasks2.default.postTask('slides')({ dto: dto });
};

var updateSlideTask = exports.updateSlideTask = function updateSlideTask(id) {
  return function (dto) {
    return _Tasks2.default.putTask('slides/' + id)({ dto: dto });
  };
};

var deleteSlideTask = exports.deleteSlideTask = function deleteSlideTask(id) {
  return _Tasks2.default.deleteTask('slides')(id);
};

var loadSlideTask = exports.loadSlideTask = function loadSlideTask(id) {
  return _Tasks2.default.getTask('slides/' + id);
};

/***/ }),

/***/ "./src/slides/Preview/component.js":
/*!*****************************************!*\
  !*** ./src/slides/Preview/component.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _index = __webpack_require__(/*! ../../services/index.js */ "./src/services/index.js");

var _animations = __webpack_require__(/*! ../../services/animations.js */ "./src/services/animations.js");

var _model = __webpack_require__(/*! ../model.js */ "./src/slides/model.js");

var _remarkable = __webpack_require__(/*! remarkable */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/index.js");

var _remarkable2 = _interopRequireDefault(_remarkable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var md = new _remarkable2.default("full", {
  baseUrl: null,
  breaks: false,
  gfm: true,
  headerIds: true,
  headerPrefix: "",
  highlight: null,
  langPrefix: "lang-",
  mangle: true,
  pedantic: false,
  sanitize: false,
  sanitizer: null,
  silent: true,
  smartLists: true,
  smartypants: true,
  tables: true,
  xhtml: true,
  html: true,
  linkify: true,
  linkTarget: "",
  typographer: true,
  quotes: "ââââ"
});

var Preview = function Preview(_ref) {
  var _ref$attrs = _ref.attrs,
      getSlides = _ref$attrs.getSlides,
      Models = _ref$attrs.Models,
      s = _ref$attrs.s,
      key = _ref$attrs.key,
      state = _ref$attrs.state;

  var onError = function onError(task) {
    return function (error) {
      return (0, _index.log)("error with " + task)(error);
    };
  };
  var onSuccess = function onSuccess(_) {
    return getSlides({ attrs: { Models: Models } });
  };

  var updateAndSaveSlideTask = function updateAndSaveSlideTask(slides) {
    return (0, _model.updateSlideTask)(Models.CurrentPresentation.id)(slides).fork(onError("updating"), onSuccess);
  };

  var removeSlideTask = function removeSlideTask(s) {
    var tail = (0, _ramda.compose)((0, _ramda.map)(_model.reduceOrder), (0, _ramda.filter)((0, _model.forGreater)(s)))(state.right());
    var removeSlide = (0, _model.updateRemoveSlide)(s);

    var updateList = (0, _ramda.concat)(removeSlide, tail);

    updateAndSaveSlideTask(updateList);
  };

  var handleDragStart = function handleDragStart(ev) {
    ev.target.style.opacity = "0.4";
    ev.dataTransfer.effectAllowed = "move";
    ev.dataTransfer.setData("text/plain", "preview");
    state.previewDrag.drag = (0, _ramda.head)((0, _ramda.filter)((0, _ramda.propEq)("id", s.id), state.right()));
  };

  var handleDragOver = function handleDragOver(ev) {
    ev.preventDefault();

    if (state.previewDrag.drag) state.previewDrag.drop = s;
  };

  var handleDragLeave = function handleDragLeave(ev) {
    ev.preventDefault();
    state.previewDrag.drop = null;
  };

  var handleDrop = function handleDrop(ev) {
    return ev.preventDefault();
  };

  var handleDragEnd = function handleDragEnd(ev) {
    ev.target.style.opacity = "1";
    state.slideDrag.dragging = false;
    if (state.previewDrag.drop) {
      var start = state.previewDrag.drag.order;
      var end = state.previewDrag.drop.order;

      var dragged = state.previewDrag.drag;
      var dropped = state.previewDrag.drop;

      state.previewDrag.drag = Models.SlideModel;
      state.previewDrag.drop = Models.SlideModel;

      if (!(0, _ramda.eqProps)("id", dragged, dropped)) {
        dragged.order = end;
        dropped.order = start;

        updateAndSaveSlideTask([dragged, dropped]);
      }
    }
  };

  return {
    oncreate: function oncreate(_ref2) {
      var dom = _ref2.dom;
      return (0, _animations.animateFadeIn)({ dom: dom });
    },
    view: function view(_ref3) {
      var _ref3$attrs = _ref3.attrs,
          s = _ref3$attrs.s,
          state = _ref3$attrs.state;
      return (0, _mithril2.default)(".card.preview", {
        draggable: true,
        ondragstart: handleDragStart,
        ondragend: handleDragEnd,
        ondragover: handleDragOver,
        ondrop: handleDrop,
        ondragleave: handleDragLeave,
        style: {
          opacity: state.previewDrag.drop && state.previewDrag.drop.id == s.id ? 0.4 : 1
        }
      }, [(0, _mithril2.default)(".card-header", [(0, _mithril2.default)("span.slidePosition", s.order), (0, _mithril2.default)("a.preview-delete.card-delete", {
        onclick: function onclick() {
          return removeSlideTask(s);
        }
      })]), (0, _mithril2.default)(".card-body", _mithril2.default.trust(md.render(s.content)))]);
    }
  };
};

exports.default = Preview;

/***/ }),

/***/ "./src/slides/Slide/component.js":
/*!***************************************!*\
  !*** ./src/slides/Slide/component.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _data = __webpack_require__(/*! data.task */ "./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/index.js");

var _data2 = _interopRequireDefault(_data);

var _index = __webpack_require__(/*! ../../services/index.js */ "./src/services/index.js");

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _model = __webpack_require__(/*! ../model.js */ "./src/slides/model.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Slide = function Slide(_ref) {
  var _ref$attrs = _ref.attrs,
      getSlides = _ref$attrs.getSlides,
      Models = _ref$attrs.Models,
      s = _ref$attrs.s,
      key = _ref$attrs.key,
      state = _ref$attrs.state;

  var onError = function onError(task) {
    return function (error) {
      return (0, _index.log)('error with ' + task)(error);
    };
  };
  var onSuccess = function onSuccess(_) {
    return getSlides({ attrs: { Models: Models } });
  };

  var authDeleteTask = function authDeleteTask(id) {
    return window.confirm('Are you sure you want to delete?') ? _data2.default.of(id) : _data2.default.rejected(id);
  };

  var removeSlideTask = function removeSlideTask(id) {
    return authDeleteTask(id).chain((0, _model.deleteSlideTask)(state.presentationId)).fork(onError('deleting'), onSuccess);
  };

  var addSlideToShow = function addSlideToShow(s) {
    (0, _model.updateSlideTask)(state.presentationId)([s]).fork(onError('updating'), function (_) {
      state.slideDrag = {
        dragId: '',
        dragging: false,
        droppable: false
      };
      onSuccess();
    });
  };

  var handleDragStart = function handleDragStart(ev) {
    ev.target.style.opacity = '0.4';
    ev.dataTransfer.effectAllowed = 'move';
    ev.dataTransfer.setData('text/plain', 'slide');
    state.slideDrag = (0, _model.updateSlideDragStart)(s)(state.slideDrag);
  };

  var handleDragEnd = function handleDragEnd(ev) {
    ev.target.style.opacity = '1';
    if (state.slideDrag.droppable) {
      var _slide = (0, _model.updateSlideDragEnd)(state.right().length)(s);

      (0, _model.updateStateDragEnd)(state.slideDrag);
      return addSlideToShow(_slide);
    }
  };

  return {
    view: function view(_ref2) {
      var _ref2$attrs = _ref2.attrs,
          s = _ref2$attrs.s,
          state = _ref2$attrs.state;
      return (0, _mithril2.default)('.card', {
        id: s.id,
        draggable: true,
        ondragstart: handleDragStart,
        ondragend: handleDragEnd
      }, [(0, _mithril2.default)('div.card-header', [(0, _mithril2.default)('h1.title', (0, _mithril2.default)('span', (0, _ramda.take)(15, s.title))), (0, _mithril2.default)('button.card-delete', {
        onclick: function onclick() {
          return removeSlideTask(s.id);
        }
      })]), (0, _mithril2.default)('.card-footer', (0, _mithril2.default)('a.card-btn', {
        onclick: function onclick() {
          return _mithril2.default.route.set('/edit/' + state.presentationId + '/slide/' + s.id);
        }
      }, (0, _mithril2.default)('i.fas fa-edit')))]);
    }
  };
};

exports.default = Slide;

/***/ }),

/***/ "./src/slides/component.js":
/*!*********************************!*\
  !*** ./src/slides/component.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _mithrilStream = __webpack_require__(/*! mithril-stream */ "./node_modules/.registry.npmjs.org/mithril-stream/1.1.0/node_modules/mithril-stream/stream.js");

var _mithrilStream2 = _interopRequireDefault(_mithrilStream);

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _slidesModal = __webpack_require__(/*! ./slidesModal.js */ "./src/slides/slidesModal.js");

var _slidesModal2 = _interopRequireDefault(_slidesModal);

var _component = __webpack_require__(/*! ./Slide/component.js */ "./src/slides/Slide/component.js");

var _component2 = _interopRequireDefault(_component);

var _component3 = __webpack_require__(/*! ./Preview/component.js */ "./src/slides/Preview/component.js");

var _component4 = _interopRequireDefault(_component3);

var _model = __webpack_require__(/*! ./model.js */ "./src/slides/model.js");

var _index = __webpack_require__(/*! ../services/index.js */ "./src/services/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Slides = function Slides(_ref) {
  var Models = _ref.attrs.Models;

  var state = {
    left: (0, _mithrilStream2.default)([]),
    right: (0, _mithrilStream2.default)([]),
    slideDrag: {
      dragId: "",
      dragging: false,
      droppable: false
    },
    previewDrag: {
      drag: null,
      drop: null
    },
    presentationId: ""
  };

  var onError = (0, _index.log)("error");

  var onSuccess = function onSuccess(presentation) {
    var slides = Models.CurrentPresentation.Slides;

    state.left((0, _ramda.filter)((0, _ramda.propEq)("order", 0), slides));

    state.right((0, _ramda.sortBy)((0, _ramda.prop)("order"), (0, _ramda.without)(state.left(), slides)));

    Models.CurrentPresentation.slideShow = (0, _mithrilStream2.default)(state.right());
  };

  var getSlides = function getSlides(_ref2) {
    var Models = _ref2.attrs.Models;

    state.presentationId = _mithril2.default.route.param("id");
    return (0, _model.loadSlides)(state.presentationId)(Models).fork(onError, onSuccess);
  };

  var handleDragEnter = function handleDragEnter(ev) {
    ev.preventDefault();
    state.bColor = true;
  };

  var handleDragLeave = function handleDragLeave(ev) {
    ev.preventDefault();
    state.slideDrag.dragging = false;
    state.slideDrag.droppable = false;
    state.bColor = false;
  };

  var handleDrop = function handleDrop(ev) {
    ev.preventDefault();
    var type = ev.dataTransfer.getData("text/plain");
    if (state.slideDrag.dragging) {
      if (type == "slide") {
        var item = (0, _ramda.head)((0, _ramda.filter)((0, _ramda.propEq)("id", state.slideDrag.dragId), state.left()));
        state.slideDrag.droppable = true;
        item.order = state.right().length + 1;
        state.left((0, _ramda.without)([item], state.left()));
        state.right((0, _ramda.concat)(state.right(), [item]));
      } else {
        var _item = (0, _ramda.head)((0, _ramda.filter)((0, _ramda.propEq)("id", state.slideDrag.dragId), state.right()));
      }
    }
  };

  var handleDragOver = function handleDragOver(ev) {
    ev.preventDefault();
    var type = ev.dataTransfer.getData("text/plain");
    state.slideDrag.dragging = true;
    ev.dataTransfer.dropEffect = "move";
  };

  return {
    oninit: getSlides,
    view: function view(_ref3) {
      var Models = _ref3.attrs.Models;
      return [Models.toggleModal ? (0, _mithril2.default)(_slidesModal2.default, {
        toggleModal: function toggleModal() {
          return Models.toggleModal = !Models.toggleModal;
        },
        left: state.left,
        slide: (0, _ramda.clone)(Models.SlideModel),
        getSlides: getSlides,
        Models: Models,
        pId: state.presentationId
      }) : "", (0, _mithril2.default)(".container.slides", [(0, _mithril2.default)("aside.left-drag " + (state.left().length == 0 ? ".isDragging" : ""), {
        onBeforeRemove: function onBeforeRemove(vnode, done) {
          vnode.dom.addEventListener("animationend", done);
          vnode.dom.style.animation = "fadeOut 1s";
        }
      }, [state.left().map(function (s) {
        return (0, _mithril2.default)(_component2.default, {
          key: s.id,
          Models: Models,
          getSlides: getSlides,
          s: s,
          state: state
        });
      })]), (0, _mithril2.default)("section.right-drag" + (state.slideDrag.dragging ? ".isDragging" : ""), {
        onBeforeRemove: function onBeforeRemove(vnode, done) {
          vnode.dom.addEventListener("animationend", done);
          vnode.dom.style.animation = "fadeOut 1s";
        },
        ondragleave: handleDragLeave,
        ondrop: handleDrop,
        ondragover: handleDragOver,
        ondragenter: handleDragEnter
      }, state.right().map(function (s) {
        return (0, _mithril2.default)(_component4.default, {
          key: s.id,
          Models: Models,
          getSlides: getSlides,
          s: s,
          state: state
        });
      }))])];
    }
  };
};

exports.default = Slides;

/***/ }),

/***/ "./src/slides/model.js":
/*!*****************************!*\
  !*** ./src/slides/model.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateSlideTask = exports.deleteSlideTask = exports.saveSlideTask = exports.loadSlides = exports.updateStateDragEnd = exports.updateSlideDragEnd = exports.updateSlideDragStart = exports.updateRemoveSlide = exports.getId = exports.reduceOrder = exports.forLess = exports.forGreater = exports.toStruct = undefined;

var _requests = __webpack_require__(/*! ../services/requests.js */ "./src/services/requests.js");

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var toViewModel = function toViewModel(model) {
  return function (presentations) {
    return model.CurrentPresentation = presentations;
  };
};

var toStruct = exports.toStruct = function toStruct(acc, item) {
  if (item.order > 0 && !acc.keys.has(item.id)) {
    item.order = acc.keys.size + 1;
    acc.keys.add(item.id);
    acc.values[item.order] = item;
    acc.items(Object.keys(acc.values));
    return acc;
  }
  return acc;
};

var orderOf = function orderOf(slide) {
  return (0, _ramda.prop)('order', slide);
};

var forGreater = exports.forGreater = function forGreater(removeSlide) {
  return function (checkSlide) {
    return (0, _ramda.lt)(orderOf(removeSlide), orderOf(checkSlide));
  };
};

var forLess = exports.forLess = function forLess(removeSlide) {
  return function (checkSlide) {
    return (0, _ramda.gt)(orderOf(removeSlide), orderOf(checkSlide));
  };
};

var reduceOrder = exports.reduceOrder = function reduceOrder(slide) {
  return (0, _ramda.set)((0, _ramda.lensProp)('order', slide), (0, _ramda.subtract)(orderOf(slide), 1), slide);
};

var getId = exports.getId = function getId(item) {
  return (0, _ramda.prop)('id', item);
};

var resetOrder = function resetOrder(slide) {
  return (0, _ramda.set)((0, _ramda.lensProp)('order', slide), 0, slide);
};

var updateRemoveSlide = exports.updateRemoveSlide = (0, _ramda.compose)(Array.of, resetOrder);

var updateId = function updateId(slide) {
  return function (slideDrag) {
    return (0, _ramda.set)((0, _ramda.lensProp)('dragId', slideDrag), (0, _ramda.prop)('id', slide), slideDrag);
  };
};

var updateSlideDragStart = exports.updateSlideDragStart = function updateSlideDragStart(slide) {
  return (0, _ramda.compose)(updateId(slide), updateDrag);
};

var updateOrder = function updateOrder(length) {
  return function (slide) {
    return (0, _ramda.set)((0, _ramda.lensProp)('order'), length, slide);
  };
};

var updateSlideDragEnd = exports.updateSlideDragEnd = function updateSlideDragEnd(length) {
  return (0, _ramda.compose)(updateOrder(length));
};

var updateDrag = function updateDrag(state) {
  return (0, _ramda.set)((0, _ramda.lensProp)('dragging', false, state));
};

var updateDrop = function updateDrop(state) {
  return (0, _ramda.set)((0, _ramda.lensProp)('droppable', false, state));
};

var updateStateDragEnd = exports.updateStateDragEnd = (0, _ramda.compose)(updateDrop, updateDrag);

var loadSlides = exports.loadSlides = function loadSlides(id) {
  return function (model) {
    return (0, _requests.getQlTask)('{ presentation(where:{id:' + JSON.stringify(id) + '}){\n      id, title, Slides { id title content order }\n    } }').map((0, _ramda.path)(['data', 'presentation'])).map(toViewModel(model));
  };
};

var saveSlideTask = exports.saveSlideTask = function saveSlideTask(_ref) {
  var title = _ref.title,
      order = _ref.order,
      presentation_id = _ref.presentation_id;

  var q = 'mutation {\n            updatePresentation(\n              where: {\n                id: ' + JSON.stringify(presentation_id) + '\n              }\n              data: {\n                  Slides:{\n                    create : {\n                      title: ' + JSON.stringify(title) + '\n                      content: ""\n                      order: ' + JSON.stringify(order) + '\n                    }\n                  } \n          }){\n    id title Slides { id title content order }\n  } }';

  return (0, _requests.getQlTask)(q).map((0, _ramda.path)(['data', 'updatePresentation', 'Slides']));
};

var deleteSlideTask = exports.deleteSlideTask = function deleteSlideTask(presentation_id) {
  return function (id) {
    var q = 'mutation {\n            updatePresentation(\n              where: {\n                id: ' + JSON.stringify(presentation_id) + '\n              }\n              data: {\n                  Slides:{\n                    delete : [{\n                      id: ' + JSON.stringify(id) + '\n                    }]\n                  } \n          }){\n    id title Slides { id title content order}\n  } }';

    return (0, _requests.getQlTask)(q).map((0, _ramda.path)(['data', 'updatePresentation', 'Slides']));
  };
};

var updateSlideTask = exports.updateSlideTask = function updateSlideTask(presentation_id) {
  return function (slides) {
    var qlSlides = slides.map(function (slide) {
      return '{\n      where: {\n        id: ' + JSON.stringify(slide.id) + '\n      }\n      data: {\n        order: ' + JSON.stringify(slide.order) + '\n      }\n    }';
    });

    var q = 'mutation {\n            updatePresentation(\n              where: {\n                id: ' + JSON.stringify(presentation_id) + '\n              }\n              data: {\n                Slides:{\n                  update : [' + qlSlides + ']\n                }\n              }\n            )\n          { id title Slides { id title content order } } \n        }';

    return (0, _requests.getQlTask)(q).map((0, _ramda.path)(['data', 'updatePresentation', 'Slides']));
  };
};

/***/ }),

/***/ "./src/slides/slidesModal.js":
/*!***********************************!*\
  !*** ./src/slides/slidesModal.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _model = __webpack_require__(/*! ./model.js */ "./src/slides/model.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SlidesModal = function SlidesModal(_ref) {
  var _ref$attrs = _ref.attrs,
      left = _ref$attrs.left,
      pId = _ref$attrs.pId,
      slide = _ref$attrs.slide,
      toggleModal = _ref$attrs.toggleModal,
      getSlides = _ref$attrs.getSlides,
      Models = _ref$attrs.Models;

  var state = {
    errors: "",
    title: ""
  };

  var onError = function onError(errors) {
    log("error")(errors);
    state.errors = errors;
  };

  var onSuccess = function onSuccess(slides) {
    getSlides({ attrs: { Models: Models } });
    return toggleModal();
  };

  var save = function save(e) {
    e.preventDefault();
    var dto = (0, _ramda.assoc)("presentation_id", pId, (0, _ramda.assoc)("title", state.title, slide));
    (0, _model.saveSlideTask)(dto).fork(onError, onSuccess);
  };

  return {
    view: function view() {
      return (0, _mithril2.default)("article.modal-container", [(0, _mithril2.default)(".card", [(0, _mithril2.default)(".card-header", (0, _mithril2.default)("button.card-delete", {
        onclick: function onclick() {
          return toggleModal();
        },
        "aria-label": "close"
      })), (0, _mithril2.default)(".card-body", [(0, _mithril2.default)("fieldset", [(0, _mithril2.default)("label.modal-label", "Slide Title"), (0, _mithril2.default)("input.modal-input", {
        autofocus: true,
        type: "text",
        onchange: function onchange(e) {
          return state.title = e.target.value;
        }
      })])]), (0, _mithril2.default)(".card-footer", (0, _mithril2.default)("button.card-btn", { onclick: save }, "save slide"))])]);
    }
  };
};

exports.default = SlidesModal;

/***/ }),

/***/ "./src/slideshow/component.js":
/*!************************************!*\
  !*** ./src/slideshow/component.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _animations = __webpack_require__(/*! ../services/animations.js */ "./src/services/animations.js");

var _remarkable = __webpack_require__(/*! remarkable */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/index.js");

var _remarkable2 = _interopRequireDefault(_remarkable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var md = new _remarkable2.default("full", {
  baseUrl: null,
  breaks: false,
  gfm: true,
  headerIds: true,
  headerPrefix: "",
  highlight: null,
  langPrefix: "lang-",
  mangle: true,
  pedantic: false,
  sanitize: false,
  sanitizer: null,
  silent: true,
  smartLists: true,
  smartypants: true,
  tables: true,
  xhtml: true,
  html: true,
  linkify: true,
  linkTarget: "",
  typographer: true,
  quotes: "ââââ"
});

var SlideShow = function SlideShow(_ref) {
  var Models = _ref.attrs.Models;

  var state = {
    cursor: 0,
    size: Models.CurrentPresentation.slideShow().length,
    contents: (0, _ramda.pluck)("content", Models.CurrentPresentation.slideShow())
  };

  var nextSlide = function nextSlide(dom) {
    dom.children[0].children[0].scrollIntoView({ behaviour: "smooth" });
    state.cursor == state.size - 1 ? state.cursor : state.cursor++;
  };

  var prevSlide = function prevSlide(dom) {
    dom.children[0].children[0].scrollIntoView({ behaviour: "smooth" });
    state.cursor == 0 ? state.cursor : state.cursor--;
  };

  var changeSlide = function changeSlide(key, target) {
    switch (key) {
      case "ArrowLeft":
        prevSlide(target);
        break;
      case "ArrowRight":
        nextSlide(target);
        break;
    }
  };

  return {
    oninit: state.slide = state.contents[state.cursor],
    view: function view(_ref2) {
      var Models = _ref2.attrs.Models;

      return (0, _mithril2.default)(".slideshow", {
        tabindex: 0,
        onkeyup: function onkeyup(_ref3) {
          var key = _ref3.key,
              target = _ref3.target;

          changeSlide(key, target);
        }
      }, (0, _mithril2.default)(".slidecard", {
        onupdate: function onupdate(_ref4) {
          var dom = _ref4.dom;
          return (0, _animations.animateEntranceRight)({ dom: dom });
        }
      }, _mithril2.default.trust(md.render(state.contents[state.cursor]) || "~ FIN ~")));
    }
  };
};

exports.default = SlideShow;

/***/ }),

/***/ "./src/styles/index.css":
/*!******************************!*\
  !*** ./src/styles/index.css ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./index.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/index.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/style-loader/0.20.3/node_modules/style-loader/lib/addStyles.js */ "./node_modules/.registry.npmjs.org/style-loader/0.20.3/node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvYW5pbWVqcy8zLjAuMS9ub2RlX21vZHVsZXMvYW5pbWVqcy9saWIvYW5pbWUuZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvYXV0b2xpbmtlci8wLjE1LjMvbm9kZV9tb2R1bGVzL2F1dG9saW5rZXIvZGlzdC9BdXRvbGlua2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMvYW5pbWF0aW9ucy5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy9lZGl0b3IuY3NzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMvaW5kZXguY3NzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMvbW9kYWwuY3NzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMvcHJlc2VudGF0aW9ucy5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy9wcmV2aWV3LmNzcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL3NsaWRlcy5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy9zbGlkZXNob3cuY3NzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMvdG9vbGJhci5jc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9kYXRhLnRhc2svMy4xLjIvbm9kZV9tb2R1bGVzL2RhdGEudGFzay9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvZGF0YS50YXNrLzMuMS4yL25vZGVfbW9kdWxlcy9kYXRhLnRhc2svbGliL3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC1zdHJlYW0vMS4xLjAvbm9kZV9tb2R1bGVzL21pdGhyaWwtc3RyZWFtL3N0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9taXRocmlsLzIuMC4wLXJjLjcvbm9kZV9tb2R1bGVzL21pdGhyaWwvYXBpL21vdW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9hcGkvcmVkcmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9hcGkvcm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9oeXBlcnNjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9taXRocmlsLzIuMC4wLXJjLjcvbm9kZV9tb2R1bGVzL21pdGhyaWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL21vdW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9wYXRobmFtZS9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL3BhdGhuYW1lL2J1aWxkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9wYXRobmFtZS9jb21waWxlVGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL3BhdGhuYW1lL3BhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9wcm9taXNlL3BvbHlmaWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9wcm9taXNlL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL3F1ZXJ5c3RyaW5nL2J1aWxkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9xdWVyeXN0cmluZy9wYXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9taXRocmlsLzIuMC4wLXJjLjcvbm9kZV9tb2R1bGVzL21pdGhyaWwvcmVkcmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9yZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL3JlbmRlci9mcmFnbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9taXRocmlsLzIuMC4wLXJjLjcvbm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyL2h5cGVyc2NyaXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9yZW5kZXIvaHlwZXJzY3JpcHRWbm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9taXRocmlsLzIuMC4wLXJjLjcvbm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyL3JlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9taXRocmlsLzIuMC4wLXJjLjcvbm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyL3RydXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9yZW5kZXIvdm5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL3JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL3JlcXVlc3QvcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9taXRocmlsLzIuMC4wLXJjLjcvbm9kZV9tb2R1bGVzL21pdGhyaWwvcm91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL3JvdXRlci9yb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcHJvY2Vzcy8wLjExLjEwL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9GLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvVC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL19fLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYWRkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYWRkSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hZGp1c3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hbGxQYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYWx3YXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYW55LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYW55UGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2FwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYXBlcnR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hcHBlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hcHBseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2FwcGx5U3BlYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2FwcGx5VG8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hc2NlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hc3NvYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Fzc29jUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2JpbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2JpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9ib3RoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2NoYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY2xhbXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2NvbXBhcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jb21wbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29tcG9zZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2NvbXBvc2VLLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29tcG9zZVAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jb25jYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jb25kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29uc3RydWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29uc3RydWN0Ti5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2NvbnRhaW5zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29udmVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jb3VudEJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY3VycnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jdXJyeU4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9kZWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9kZWZhdWx0VG8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9kZXNjZW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZGlmZmVyZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2RpZmZlcmVuY2VXaXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZGlzc29jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZGlzc29jUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2RpdmlkZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Ryb3AuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9kcm9wTGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Ryb3BMYXN0V2hpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9kcm9wUmVwZWF0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Ryb3BSZXBlYXRzV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Ryb3BXaGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2VpdGhlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2VtcHR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZW5kc1dpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9lcUJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZXFQcm9wcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2V2b2x2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9maW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9maW5kTGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ZpbmRMYXN0SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9mbGF0dGVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZmxpcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ZvckVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9mb3JFYWNoT2JqSW5kZXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Zyb21QYWlycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2dyb3VwQnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9ncm91cFdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9ndC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2d0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2hhc0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaGVhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2lkZW50aWNhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2lkZW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaWZFbHNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbmRleEJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW5kZXhPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2luaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbm5lckpvaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnNlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnNlcnRBbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2FwZXJ0dXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2FyaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2FycmF5RnJvbUl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jaGVja0Zvck1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jbG9uZVJlZ0V4cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jb21wbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2NvbmNhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jb250YWlucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jb250YWluc1dpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fY3VycnkxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2N1cnJ5Mi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jdXJyeTMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fY3VycnlOLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19kcm9wTGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19kcm9wTGFzdFdoaWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fZmxhdENhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19mb3JjZVJlZHVjZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fZnVuY3Rpb25OYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pbmRleE9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pc0ludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNOdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNQbGFjZWhvbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pc1JlZ0V4cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pc1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pc1RyYW5zZm9ybWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX21ha2VGbGF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX21hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19vYmplY3RBc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fcGlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19waXBlUC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19xdW90ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fcmVkdWNlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19zdGVwQ2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3RvSVNPU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3RvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feGFueS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194YXBlcnR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feGNoYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hkcm9wLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hkcm9wTGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194ZHJvcExhc3RXaGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194ZHJvcFJlcGVhdHNXaXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hkcm9wV2hpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feGZCYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hmaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feGZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feGZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194ZmluZExhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feGZpbmRMYXN0SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feG1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194cmVkdWNlQnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feHRha2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feHRha2VXaGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194dGFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3h3cmFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJzZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJzcGVyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW52ZXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW52ZXJ0T2JqLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW52b2tlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2lzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaXNFbXB0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2lzTmlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvam9pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2p1eHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMva2V5c0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2xhc3RJbmRleE9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGVucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2xlbnNJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2xlbnNQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGVuc1Byb3AuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9saWZ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGlmdE4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9sdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2x0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21hcEFjY3VtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbWFwQWNjdW1SaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21hcE9iakluZGV4ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21hdGhNb2QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tYXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tYXhCeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21lYW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZWRpYW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZW1vaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbWVtb2l6ZVdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZXJnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21lcmdlQWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbWVyZ2VEZWVwTGVmdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21lcmdlRGVlcFJpZ2h0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbWVyZ2VEZWVwV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21lcmdlRGVlcFdpdGhLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZXJnZVdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZXJnZVdpdGhLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9taW5CeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21vZHVsby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL211bHRpcGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbkFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL25lZ2F0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL25vbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9ub3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9udGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9udGhBcmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9vLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvb2JqT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL29taXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9vbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9vdmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGFpci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3BhcnRpYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wYXJ0aWFsUmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wYXJ0aXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGF0aEVxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGF0aE9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGF0aFNhdGlzZmllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3BpY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9waWNrQWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGlja0J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3BpcGVLLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGlwZVAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wbHVjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3ByZXBlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wcm9kdWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcHJvamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3Byb3AuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wcm9wRXEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wcm9wSXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wcm9wT3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wcm9wU2F0aXNmaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcHJvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9yYW5nZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3JlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3JlZHVjZUJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcmVkdWNlUmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9yZWR1Y2VXaGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3JlZHVjZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9yZWplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9yZXBsYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcmV2ZXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NjYW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9zZXF1ZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NsaWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NvcnRCeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NvcnRXaXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvc3BsaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9zcGxpdEF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvc3BsaXRFdmVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NwbGl0V2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3N0YXJ0c1dpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9zdWJ0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3N1bS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3N5bW1ldHJpY0RpZmZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9zeW1tZXRyaWNEaWZmZXJlbmNlV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3RhaWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90YWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdGFrZUxhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90YWtlTGFzdFdoaWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdGFrZVdoaWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdGFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdGVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3RpbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdG9Mb3dlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3RvUGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90b1BhaXJzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90b1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3RvVXBwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90cmFuc2R1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90cmFuc3Bvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90cmF2ZXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3RyaW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90cnlDYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy91bmFwcGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy91bmN1cnJ5Ti5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3VuZm9sZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3VuaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW5pb25XaXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW5pcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3VuaXFCeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3VuaXFXaXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW5sZXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW5uZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW50aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy91cGRhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy91c2VXaXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdmFsdWVzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy92aWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvd2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3doZXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvd2hlcmVFcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3dpdGhvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy94cHJvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3ppcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3ppcE9iai5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3ppcFdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9jb21tb24vZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvY29tbW9uL2h0bWxfYmxvY2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL2NvbW1vbi9odG1sX3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL2NvbW1vbi91cmxfc2NoZW1hcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9jb21tb24vdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvY29uZmlncy9jb21tb25tYXJrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL2NvbmZpZ3MvZGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9jb25maWdzL2Z1bGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvaGVscGVycy9ub3JtYWxpemVfbGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9oZWxwZXJzL25vcm1hbGl6ZV9yZWZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvaGVscGVycy9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcGFyc2VyX2Jsb2NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3BhcnNlcl9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3BhcnNlcl9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfYmxvY2svYmxvY2txdW90ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19ibG9jay9jb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2Jsb2NrL2RlZmxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfYmxvY2svZmVuY2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2Jsb2NrL2Zvb3Rub3RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfYmxvY2svaHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfYmxvY2svaHRtbGJsb2NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2Jsb2NrL2xoZWFkaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2Jsb2NrL2xpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfYmxvY2svcGFyYWdyYXBoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2Jsb2NrL3RhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2NvcmUvYWJici5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19jb3JlL2FiYnIyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2NvcmUvYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfY29yZS9mb290bm90ZV90YWlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2NvcmUvaW5saW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19jb3JlL3JlZmVyZW5jZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfY29yZS9zbWFydHF1b3Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19pbmxpbmUvYXV0b2xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfaW5saW5lL2JhY2t0aWNrcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19pbmxpbmUvZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS9lbXBoYXNpcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19pbmxpbmUvZW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfaW5saW5lL2Zvb3Rub3RlX2lubGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19pbmxpbmUvZm9vdG5vdGVfcmVmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS9odG1sdGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS9pbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfaW5saW5lL2xpbmtzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS9tYXJrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS9uZXdsaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfaW5saW5lL3N1Yi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19pbmxpbmUvc3VwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS90ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3NldGltbWVkaWF0ZS8xLjAuNS9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9zdHlsZS1sb2FkZXIvMC4yMC4zL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9zdHlsZS1sb2FkZXIvMC4yMC4zL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvdGltZXJzLWJyb3dzZXJpZnkvMi4wLjEwL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc2VjcmV0LmpzIiwid2VicGFjazovLy8uL3NyYy9BcHAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL01vZGVscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvVG9vbGJhci9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VkaXRvci9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VkaXRvci9tb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xheW91dC9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ByZXNlbnRhdGlvbnMvUHJlc2VudGF0aW9uL2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcHJlc2VudGF0aW9ucy9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ByZXNlbnRhdGlvbnMvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ByZXNlbnRhdGlvbnMvcHJlc2VudGF0aW9uTW9kYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlcnZpY2VzL1Rhc2tzLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXJ2aWNlcy9hbmltYXRpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXJ2aWNlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2VydmljZXMvcmVxdWVzdHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NsaWRlcy9QcmV2aWV3L2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2xpZGVzL1NsaWRlL2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2xpZGVzL2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2xpZGVzL21vZGVsLmpzIiwid2VicGFjazovLy8uL3NyYy9zbGlkZXMvc2xpZGVzTW9kYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NsaWRlc2hvdy9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy9pbmRleC5jc3M/OWJlNCJdLCJuYW1lcyI6WyJvbmxpbmVVcmwiLCJtYWtlUm91dGVzIiwibW9kZWwiLCJtZGwiLCJ2aWV3IiwiTGF5b3V0IiwiUHJlc2VudGF0aW9ucyIsIlNsaWRlcyIsIkVkaXRvciIsIlNsaWRlU2hvdyIsIkFwcCIsImF0dHJzIiwic3RhdGUiLCJlcnJvcnMiLCJvbkVycm9yIiwiZXJyb3IiLCJvblN1Y2Nlc3MiLCJNb2RlbHMiLCJkdG8iLCJmaW5kUHJlc2VudGF0aW9ucyIsImZvcmsiLCJvbmluaXQiLCJvbmNyZWF0ZSIsImRvbSIsIm1haW4iLCJxdWVyeVNlbGVjdG9yIiwibSIsInJvdXRlIiwiY2hpbGRyZW4iLCJTbGlkZU1vZGVsIiwidGl0bGUiLCJjb250ZW50cyIsIm9yZGVyIiwicHJlc2VudGF0aW9uX2lkIiwiU2xpZGVTaG93U3RydWN0Iiwia2V5cyIsIlNldCIsInZhbHVlcyIsIml0ZW1zIiwiQ3VycmVudFByZXNlbnRhdGlvbiIsImlkIiwic2xpZGVTaG93IiwiZ2V0UHJvZmlsZSIsInciLCJwcm9maWxlIiwid2luZG93IiwiaW5uZXJXaWR0aCIsInRvZ2dsZU1vZGFsIiwib25jbGljayIsInRvUHJlc2VudGF0aW9ucyIsImxpbmsiLCJocmVmIiwidG9TbGlkZXMiLCJ0b1NsaWRlU2hvdyIsImRpc2FibGVkIiwibmF2VmlldyIsInBhZ2UiLCJhY3Rpb25WaWV3IiwiVG9vbGJhciIsImN1cnJlbnRQYWdlIiwiZ2V0IiwibWQiLCJyZW1hcmthYmxlIiwiYmFzZVVybCIsImJyZWFrcyIsImdmbSIsImhlYWRlcklkcyIsImhlYWRlclByZWZpeCIsImhpZ2hsaWdodCIsImxhbmdQcmVmaXgiLCJtYW5nbGUiLCJwZWRhbnRpYyIsInNhbml0aXplIiwic2FuaXRpemVyIiwic2lsZW50Iiwic21hcnRMaXN0cyIsInNtYXJ0eXBhbnRzIiwidGFibGVzIiwieGh0bWwiLCJodG1sIiwibGlua2lmeSIsImxpbmtUYXJnZXQiLCJ0eXBvZ3JhcGhlciIsInF1b3RlcyIsInByZXNlbnRhdGlvbklkIiwic2xpZGUiLCJjb250ZW50Iiwic2V0IiwibG9nIiwiZ2V0U2xpZGUiLCJwYXJhbSIsInVwZGF0ZUlucHV0IiwiaW5wdXQiLCJlIiwidGFyZ2V0IiwidmFsdWUiLCJzYXZlIiwicHJldmVudERlZmF1bHQiLCJ0eXBlIiwicGxhY2Vob2xkZXIiLCJvbmlucHV0IiwidHJ1c3QiLCJyZW5kZXIiLCJsb2FkU2xpZGUiLCJxIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1hcCIsImVkaXRTbGlkZSIsInJvb3QiLCJkb2N1bWVudCIsImJvZHkiLCJQcmVzZW50YXRpb24iLCJ0YXNrIiwiZGVsZXRlZCIsImF1dGhEZWxldGVUYXNrIiwiY29uZmlybSIsIlRhc2siLCJvZiIsInJlamVjdGVkIiwicmVtb3ZlUHJlc1Rhc2siLCJwSWQiLCJjaGFpbiIsImRlbGV0ZVByZXNlbnRhdGlvbnNUYXNrIiwiUHJlc2VudGF0aW9uTW9kYWwiLCJwcmVzZW50YXRpb25zIiwicHJlc2VudGF0aW9uTW9kZWwiLCJQcmVzZW50YXRpb25Nb2RlbCIsIm9uQmVmb3JlUmVtb3ZlIiwidm5vZGUiLCJkb25lIiwiYWRkRXZlbnRMaXN0ZW5lciIsInN0eWxlIiwiYW5pbWF0aW9uIiwia2V5IiwidG9WaWV3TW9kZWwiLCJkYXRhIiwiY29uc29sZSIsImdldFByZXNlbnRhdGlvbnMiLCJzYXZlUHJlc2VudGF0aW9uVGFzayIsInB1c2giLCJwIiwiYXV0b2ZvY3VzIiwib25jaGFuZ2UiLCJwb3N0UWwiLCJyZWoiLCJyZXMiLCJyZXF1ZXN0IiwibWV0aG9kIiwidXJsIiwid2l0aENyZWRlbnRpYWxzIiwicXVlcnkiLCJ0aGVuIiwicG9zdFRhc2siLCJwdXRUYXNrIiwiZ2V0VGFzayIsImRlbGV0ZVRhc2siLCJhbmltYXRlU2xpZGVFbnRyYW5jZSIsImFuaW1hdGUiLCJ0cmFuc2Zvcm0iLCJvcGFjaXR5IiwiZHVyYXRpb24iLCJhbmltYXRlRW50cmFuY2VSaWdodCIsInNjYWxlIiwiYW5pbWF0ZUNoaWxkRW50cmFuY2UiLCJjaGlsZCIsImluZGV4Iiwic2V0VGltZW91dCIsImFuaW1hdGVFeGl0IiwiYW5pbSIsIndhYXBpIiwiUHJvbWlzZSIsInJlc29sdmUiLCJvbmZpbmlzaCIsImFuaW1hdGVGYWRlSW4iLCJ0cmFuc2l0aW9uIiwiYW5pbWF0ZUZhZGVPdXQiLCJhbmltZUVudHJhbmNlIiwiZWwiLCJlYXNpbmciLCJ0cmFuc2xhdGVYIiwib2Zmc2V0IiwiYm91bmNlRW50cmFuY2UiLCJrZXlmcmFtZXMiLCJtYWtlUXVlcnkiLCJwYXJzZSIsInN0cmluZyIsInJlcGVhdCIsIm4iLCJ4IiwiZiIsIndhaXQiLCJ2Iiwidmlld01vZGVsTWFwIiwiX21hcCIsInByb3AiLCJzaWduYXR1cmUiLCJmaW5kUHJlc2VudGF0aW9uc1Rhc2siLCJodHRwVGFza3MiLCJnZXRRbFRhc2siLCJmaW5kU2xpZGVzVGFzayIsInNhdmVTbGlkZVRhc2siLCJ1cGRhdGVTbGlkZVRhc2siLCJkZWxldGVTbGlkZVRhc2siLCJsb2FkU2xpZGVUYXNrIiwiUHJldmlldyIsImdldFNsaWRlcyIsInMiLCJ1cGRhdGVBbmRTYXZlU2xpZGVUYXNrIiwic2xpZGVzIiwicmVtb3ZlU2xpZGVUYXNrIiwidGFpbCIsInJlZHVjZU9yZGVyIiwicmlnaHQiLCJyZW1vdmVTbGlkZSIsInVwZGF0ZUxpc3QiLCJoYW5kbGVEcmFnU3RhcnQiLCJldiIsImRhdGFUcmFuc2ZlciIsImVmZmVjdEFsbG93ZWQiLCJzZXREYXRhIiwicHJldmlld0RyYWciLCJkcmFnIiwiaGFuZGxlRHJhZ092ZXIiLCJkcm9wIiwiaGFuZGxlRHJhZ0xlYXZlIiwiaGFuZGxlRHJvcCIsImhhbmRsZURyYWdFbmQiLCJzbGlkZURyYWciLCJkcmFnZ2luZyIsInN0YXJ0IiwiZW5kIiwiZHJhZ2dlZCIsImRyb3BwZWQiLCJkcmFnZ2FibGUiLCJvbmRyYWdzdGFydCIsIm9uZHJhZ2VuZCIsIm9uZHJhZ292ZXIiLCJvbmRyb3AiLCJvbmRyYWdsZWF2ZSIsIlNsaWRlIiwiYWRkU2xpZGVUb1Nob3ciLCJkcmFnSWQiLCJkcm9wcGFibGUiLCJfc2xpZGUiLCJsZW5ndGgiLCJsZWZ0IiwicHJlc2VudGF0aW9uIiwiaGFuZGxlRHJhZ0VudGVyIiwiYkNvbG9yIiwiZ2V0RGF0YSIsIml0ZW0iLCJkcm9wRWZmZWN0IiwiU2xpZGVzTW9kYWwiLCJvbmRyYWdlbnRlciIsInRvU3RydWN0IiwiYWNjIiwiaGFzIiwic2l6ZSIsImFkZCIsIk9iamVjdCIsIm9yZGVyT2YiLCJmb3JHcmVhdGVyIiwiY2hlY2tTbGlkZSIsImZvckxlc3MiLCJnZXRJZCIsInJlc2V0T3JkZXIiLCJ1cGRhdGVSZW1vdmVTbGlkZSIsIkFycmF5IiwidXBkYXRlSWQiLCJ1cGRhdGVTbGlkZURyYWdTdGFydCIsInVwZGF0ZURyYWciLCJ1cGRhdGVPcmRlciIsInVwZGF0ZVNsaWRlRHJhZ0VuZCIsInVwZGF0ZURyb3AiLCJ1cGRhdGVTdGF0ZURyYWdFbmQiLCJsb2FkU2xpZGVzIiwicWxTbGlkZXMiLCJjdXJzb3IiLCJuZXh0U2xpZGUiLCJzY3JvbGxJbnRvVmlldyIsImJlaGF2aW91ciIsInByZXZTbGlkZSIsImNoYW5nZVNsaWRlIiwidGFiaW5kZXgiLCJvbmtleXVwIiwib251cGRhdGUiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHlCQUF5QixFQUFF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Q0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2Qix3QkFBd0I7QUFDckQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdCQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxlQUFlO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7O0FBRUEsU0FBUztBQUNUOzs7Ozs7Ozs7Ozs7O0FDdjRCWTs7QUFFWixZQUFZLG1CQUFPLENBQUMsbUhBQWlCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1BZOztBQUVaO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNuQlk7O0FBRVosc0JBQXNCLG1CQUFPLENBQUMsd0hBQW1CO0FBQ2pELGlCQUFpQixtQkFBTyxDQUFDLHdIQUFtQjs7Ozs7Ozs7Ozs7OztBQ0hoQzs7QUFFWixvQkFBb0IsbUJBQU8sQ0FBQyx1SEFBbUI7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JNWTs7QUFFWixvQkFBb0IsbUJBQU8sQ0FBQyxzR0FBVTs7QUFFdEMsaUJBQWlCLG1CQUFPLENBQUMsOEdBQWM7Ozs7Ozs7Ozs7Ozs7QUNKdkMsb0RBQVk7O0FBRVosb0JBQW9CLG1CQUFPLENBQUMsdUhBQW1CO0FBQy9DLG9CQUFvQixtQkFBTyxDQUFDLHVIQUFtQjtBQUMvQyxzQkFBc0IsbUJBQU8sQ0FBQywySUFBNkI7QUFDM0QsYUFBYSxtQkFBTyxDQUFDLHlIQUFvQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUMsOEJBQThCO0FBQ25FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7OztBQ3ZMdEM7QUFBQTtBQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztB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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBbUM7QUFDQTtBQUNFO0FBQ0U7QUFDVTtBQUNKO0FBQ047QUFDUTtBQUNGO0FBQ047QUFDQTtBQUNRO0FBQ1Y7QUFDWTtBQUNKO0FBQ0Y7QUFDUTtBQUNKO0FBQ0Y7QUFDRjtBQUNRO0FBQ047QUFDSjtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDVTtBQUNBO0FBQ047QUFDRTtBQUNBO0FBQ0o7QUFDSjtBQUNVO0FBQ0U7QUFDSjtBQUNBO0FBQ0Y7QUFDSjtBQUNFO0FBQ047QUFDWTtBQUNKO0FBQ007QUFDUTtBQUNoQjtBQUNRO0FBQ1I7QUFDSjtBQUNRO0FBQ1U7QUFDSjtBQUNRO0FBQ1o7QUFDTjtBQUNGO0FBQ007QUFDUjtBQUNNO0FBQ0Y7QUFDQTtBQUNBO0FBQ0o7QUFDVTtBQUNGO0FBQ1U7QUFDWjtBQUNOO0FBQ007QUFDb0I7QUFDaEI7QUFDSjtBQUNJO0FBQ2Q7QUFDRTtBQUNBO0FBQ0k7QUFDRjtBQUNVO0FBQ0Y7QUFDSjtBQUNOO0FBQ1E7QUFDQTtBQUNOO0FBQ1U7QUFDTjtBQUNNO0FBQ007QUFDRjtBQUNkO0FBQ0k7QUFDTTtBQUNKO0FBQ1Y7QUFDVTtBQUNKO0FBQ0Y7QUFDQTtBQUNBO0FBQ0k7QUFDSjtBQUNjO0FBQ1Y7QUFDSjtBQUNVO0FBQ0Y7QUFDQTtBQUNSO0FBQ0U7QUFDTjtBQUNFO0FBQ0E7QUFDVTtBQUNVO0FBQ0E7QUFDaEI7QUFDSTtBQUNSO0FBQ0k7QUFDRjtBQUNJO0FBQ0U7QUFDUTtBQUNaO0FBQ007QUFDVTtBQUNFO0FBQ0Y7QUFDTTtBQUNkO0FBQ007QUFDbEI7QUFDSTtBQUNFO0FBQ0k7QUFDUjtBQUNJO0FBQ0o7QUFDRjtBQUNBO0FBQ007QUFDVjtBQUNRO0FBQ047QUFDSTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ007QUFDVTtBQUNOO0FBQ1Y7QUFDSTtBQUNBO0FBQ2M7QUFDbEI7QUFDTTtBQUNGO0FBQ0o7QUFDRTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDTjtBQUNJO0FBQ0E7QUFDQTtBQUNjO0FBQ2hCO0FBQ0E7QUFDRTtBQUNJO0FBQ007QUFDQTtBQUNSO0FBQ0Y7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNOO0FBQ1E7QUFDVjtBQUNJO0FBQ0Y7QUFDSTtBQUNJO0FBQ047QUFDSTtBQUNNO0FBQ0Y7QUFDRTtBQUNKO0FBQ1Y7QUFDZ0M7QUFDUTtBQUN0QztBQUNBO0FBQ1E7QUFDVTtBQUNSO0FBQ1o7QUFDRTtBQUNFO0FBQ0k7QUFDQTtBQUNJO0FBQ0Y7QUFDRjtBQUNJO0FBQ0E7QUFDRjtBQUNSO0FBQ1E7QUFDUjtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcmxFQTtBQUNBOztBQUVhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTs7O0FBR3ZEOzs7Ozs7Ozs7Ozs7O0FDN0RBOztBQUVhOzs7QUFHYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7Ozs7Ozs7Ozs7O0FDMURBO0FBQ0E7O0FBRWE7OztBQUdiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ3pMRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyw0R0FBUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBLG1CQUFtQiwyQkFBMkI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7O0FBRUEsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZCxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0WEE7QUFDQTtBQUNBO0FB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Q0Q7QUFKSCxPQUZLLEVBUUwsdUJBQ0UsWUFERixFQUVFO0FBQ0VnTSxrQkFBVTtBQUFBLGNBQUd2USxHQUFILFNBQUdBLEdBQUg7QUFBQSxpQkFBYSxzQ0FBcUIsRUFBRUEsUUFBRixFQUFyQixDQUFiO0FBQUE7QUFEWixPQUZGLEVBS0VHLGtCQUFFMkUsS0FBRixDQUFReEMsR0FBR3lDLE1BQUgsQ0FBVTFGLE1BQU1tQixRQUFOLENBQWVuQixNQUFNMFEsTUFBckIsQ0FBVixLQUEyQyxTQUFuRCxDQUxGLENBUkssQ0FBUDtBQWdCRDtBQW5CSSxHQUFQO0FBcUJELENBakREOztrQkFtRGU3USxTOzs7Ozs7Ozs7Ozs7QUMvRWYsY0FBYyxtQkFBTyxDQUFDLHFOQUEwRzs7QUFFaEksNENBQTRDLFFBQVM7O0FBRXJEO0FBQ0E7Ozs7QUFJQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLGdOQUF3Rzs7QUFFN0g7O0FBRUEsR0FBRyxLQUFVLEVBQUUsRSIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcbiIsIi8qXG4gKiBhbmltZS5qcyB2My4wLjFcbiAqIChjKSAyMDE5IEp1bGlhbiBHYXJuaWVyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGFuaW1lanMuY29tXG4gKi9cblxuLy8gRGVmYXVsdHNcblxudmFyIGRlZmF1bHRJbnN0YW5jZVNldHRpbmdzID0ge1xuICB1cGRhdGU6IG51bGwsXG4gIGJlZ2luOiBudWxsLFxuICBsb29wQmVnaW46IG51bGwsXG4gIGNoYW5nZUJlZ2luOiBudWxsLFxuICBjaGFuZ2U6IG51bGwsXG4gIGNoYW5nZUNvbXBsZXRlOiBudWxsLFxuICBsb29wQ29tcGxldGU6IG51bGwsXG4gIGNvbXBsZXRlOiBudWxsLFxuICBsb29wOiAxLFxuICBkaXJlY3Rpb246ICdub3JtYWwnLFxuICBhdXRvcGxheTogdHJ1ZSxcbiAgdGltZWxpbmVPZmZzZXQ6IDBcbn07XG5cbnZhciBkZWZhdWx0VHdlZW5TZXR0aW5ncyA9IHtcbiAgZHVyYXRpb246IDEwMDAsXG4gIGRlbGF5OiAwLFxuICBlbmREZWxheTogMCxcbiAgZWFzaW5nOiAnZWFzZU91dEVsYXN0aWMoMSwgLjUpJyxcbiAgcm91bmQ6IDBcbn07XG5cbnZhciB2YWxpZFRyYW5zZm9ybXMgPSBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICd0cmFuc2xhdGVaJywgJ3JvdGF0ZScsICdyb3RhdGVYJywgJ3JvdGF0ZVknLCAncm90YXRlWicsICdzY2FsZScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ3NjYWxlWicsICdza2V3JywgJ3NrZXdYJywgJ3NrZXdZJywgJ3BlcnNwZWN0aXZlJ107XG5cbi8vIENhY2hpbmdcblxudmFyIGNhY2hlID0ge1xuICBDU1M6IHt9LFxuICBzcHJpbmdzOiB7fVxufTtcblxuLy8gVXRpbHNcblxuZnVuY3Rpb24gbWluTWF4KHZhbCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nQ29udGFpbnMoc3RyLCB0ZXh0KSB7XG4gIHJldHVybiBzdHIuaW5kZXhPZih0ZXh0KSA+IC0xO1xufVxuXG5mdW5jdGlvbiBhcHBseUFyZ3VtZW50cyhmdW5jLCBhcmdzKSB7XG4gIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG52YXIgaXMgPSB7XG4gIGFycjogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkoYSk7IH0sXG4gIG9iajogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHN0cmluZ0NvbnRhaW5zKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSwgJ09iamVjdCcpOyB9LFxuICBwdGg6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBpcy5vYmooYSkgJiYgYS5oYXNPd25Qcm9wZXJ0eSgndG90YWxMZW5ndGgnKTsgfSxcbiAgc3ZnOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7IH0sXG4gIGlucDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50OyB9LFxuICBkb206IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5vZGVUeXBlIHx8IGlzLnN2ZyhhKTsgfSxcbiAgc3RyOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdHlwZW9mIGEgPT09ICdzdHJpbmcnOyB9LFxuICBmbmM6IGZ1bmN0aW9uIChhKSB7IHJldHVybiB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJzsgfSxcbiAgdW5kOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnOyB9LFxuICBoZXg6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAvKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpL2kudGVzdChhKTsgfSxcbiAgcmdiOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gL15yZ2IvLnRlc3QoYSk7IH0sXG4gIGhzbDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIC9eaHNsLy50ZXN0KGEpOyB9LFxuICBjb2w6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAoaXMuaGV4KGEpIHx8IGlzLnJnYihhKSB8fCBpcy5oc2woYSkpOyB9LFxuICBrZXk6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAhZGVmYXVsdEluc3RhbmNlU2V0dGluZ3MuaGFzT3duUHJvcGVydHkoYSkgJiYgIWRlZmF1bHRUd2VlblNldHRpbmdzLmhhc093blByb3BlcnR5KGEpICYmIGEgIT09ICd0YXJnZXRzJyAmJiBhICE9PSAna2V5ZnJhbWVzJzsgfVxufTtcblxuLy8gRWFzaW5nc1xuXG5mdW5jdGlvbiBwYXJzZUVhc2luZ1BhcmFtZXRlcnMoc3RyaW5nKSB7XG4gIHZhciBtYXRjaCA9IC9cXCgoW14pXSspXFwpLy5leGVjKHN0cmluZyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwYXJzZUZsb2F0KHApOyB9KSA6IFtdO1xufVxuXG4vLyBTcHJpbmcgc29sdmVyIGluc3BpcmVkIGJ5IFdlYmtpdCBDb3B5cmlnaHQgwqkgMjAxNiBBcHBsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIGh0dHBzOi8vd2Via2l0Lm9yZy9kZW1vcy9zcHJpbmcvc3ByaW5nLmpzXG5cbmZ1bmN0aW9uIHNwcmluZyhzdHJpbmcsIGR1cmF0aW9uKSB7XG5cbiAgdmFyIHBhcmFtcyA9IHBhcnNlRWFzaW5nUGFyYW1ldGVycyhzdHJpbmcpO1xuICB2YXIgbWFzcyA9IG1pbk1heChpcy51bmQocGFyYW1zWzBdKSA/IDEgOiBwYXJhbXNbMF0sIC4xLCAxMDApO1xuICB2YXIgc3RpZmZuZXNzID0gbWluTWF4KGlzLnVuZChwYXJhbXNbMV0pID8gMTAwIDogcGFyYW1zWzFdLCAuMSwgMTAwKTtcbiAgdmFyIGRhbXBpbmcgPSBtaW5NYXgoaXMudW5kKHBhcmFtc1syXSkgPyAxMCA6IHBhcmFtc1syXSwgLjEsIDEwMCk7XG4gIHZhciB2ZWxvY2l0eSA9ICBtaW5NYXgoaXMudW5kKHBhcmFtc1szXSkgPyAwIDogcGFyYW1zWzNdLCAuMSwgMTAwKTtcbiAgdmFyIHcwID0gTWF0aC5zcXJ0KHN0aWZmbmVzcyAvIG1hc3MpO1xuICB2YXIgemV0YSA9IGRhbXBpbmcgLyAoMiAqIE1hdGguc3FydChzdGlmZm5lc3MgKiBtYXNzKSk7XG4gIHZhciB3ZCA9IHpldGEgPCAxID8gdzAgKiBNYXRoLnNxcnQoMSAtIHpldGEgKiB6ZXRhKSA6IDA7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSB6ZXRhIDwgMSA/ICh6ZXRhICogdzAgKyAtdmVsb2NpdHkpIC8gd2QgOiAtdmVsb2NpdHkgKyB3MDtcblxuICBmdW5jdGlvbiBzb2x2ZXIodCkge1xuICAgIHZhciBwcm9ncmVzcyA9IGR1cmF0aW9uID8gKGR1cmF0aW9uICogdCkgLyAxMDAwIDogdDtcbiAgICBpZiAoemV0YSA8IDEpIHtcbiAgICAgIHByb2dyZXNzID0gTWF0aC5leHAoLXByb2dyZXNzICogemV0YSAqIHcwKSAqIChhICogTWF0aC5jb3Mod2QgKiBwcm9ncmVzcykgKyBiICogTWF0aC5zaW4od2QgKiBwcm9ncmVzcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9ncmVzcyA9IChhICsgYiAqIHByb2dyZXNzKSAqIE1hdGguZXhwKC1wcm9ncmVzcyAqIHcwKTtcbiAgICB9XG4gICAgaWYgKHQgPT09IDAgfHwgdCA9PT0gMSkgeyByZXR1cm4gdDsgfVxuICAgIHJldHVybiAxIC0gcHJvZ3Jlc3M7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREdXJhdGlvbigpIHtcbiAgICB2YXIgY2FjaGVkID0gY2FjaGUuc3ByaW5nc1tzdHJpbmddO1xuICAgIGlmIChjYWNoZWQpIHsgcmV0dXJuIGNhY2hlZDsgfVxuICAgIHZhciBmcmFtZSA9IDEvNjtcbiAgICB2YXIgZWxhcHNlZCA9IDA7XG4gICAgdmFyIHJlc3QgPSAwO1xuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIGVsYXBzZWQgKz0gZnJhbWU7XG4gICAgICBpZiAoc29sdmVyKGVsYXBzZWQpID09PSAxKSB7XG4gICAgICAgIHJlc3QrKztcbiAgICAgICAgaWYgKHJlc3QgPj0gMTYpIHsgYnJlYWs7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3QgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZHVyYXRpb24gPSBlbGFwc2VkICogZnJhbWUgKiAxMDAwO1xuICAgIGNhY2hlLnNwcmluZ3Nbc3RyaW5nXSA9IGR1cmF0aW9uO1xuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxuXG4gIHJldHVybiBkdXJhdGlvbiA/IHNvbHZlciA6IGdldER1cmF0aW9uO1xuXG59XG5cbi8vIEVsYXN0aWMgZWFzaW5nIGFkYXB0ZWQgZnJvbSBqUXVlcnlVSSBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9lYXNpbmdzL1xuXG5mdW5jdGlvbiBlbGFzdGljKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gIGlmICggYW1wbGl0dWRlID09PSB2b2lkIDAgKSBhbXBsaXR1ZGUgPSAxO1xuICBpZiAoIHBlcmlvZCA9PT0gdm9pZCAwICkgcGVyaW9kID0gLjU7XG5cbiAgdmFyIGEgPSBtaW5NYXgoYW1wbGl0dWRlLCAxLCAxMCk7XG4gIHZhciBwID0gbWluTWF4KHBlcmlvZCwgLjEsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gKHQgPT09IDAgfHwgdCA9PT0gMSkgPyB0IDogXG4gICAgICAtYSAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSkgKiBNYXRoLnNpbigoKCh0IC0gMSkgLSAocCAvIChNYXRoLlBJICogMikgKiBNYXRoLmFzaW4oMSAvIGEpKSkgKiAoTWF0aC5QSSAqIDIpKSAvIHApO1xuICB9XG59XG5cbi8vIEJhc2ljIHN0ZXBzIGVhc2luZyBpbXBsZW1lbnRhdGlvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9mci9kb2NzL1dlYi9DU1MvdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cblxuZnVuY3Rpb24gc3RlcHMoc3RlcHMpIHtcbiAgaWYgKCBzdGVwcyA9PT0gdm9pZCAwICkgc3RlcHMgPSAxMDtcblxuICByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE1hdGgucm91bmQodCAqIHN0ZXBzKSAqICgxIC8gc3RlcHMpOyB9O1xufVxuXG4vLyBCZXppZXJFYXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2dyZS9iZXppZXItZWFzaW5nXG5cbnZhciBiZXppZXIgPSAoZnVuY3Rpb24gKCkge1xuXG4gIHZhciBrU3BsaW5lVGFibGVTaXplID0gMTE7XG4gIHZhciBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCk7XG5cbiAgZnVuY3Rpb24gQShhQTEsIGFBMikgeyByZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExIH1cbiAgZnVuY3Rpb24gQihhQTEsIGFBMikgeyByZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExIH1cbiAgZnVuY3Rpb24gQyhhQTEpICAgICAgeyByZXR1cm4gMy4wICogYUExIH1cblxuICBmdW5jdGlvbiBjYWxjQmV6aWVyKGFULCBhQTEsIGFBMikgeyByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQgfVxuICBmdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHsgcmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSkgfVxuXG4gIGZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZShhWCwgYUEsIGFCLCBtWDEsIG1YMikge1xuICAgIHZhciBjdXJyZW50WCwgY3VycmVudFQsIGkgPSAwO1xuICAgIGRvIHtcbiAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG4gICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7IGFCID0gY3VycmVudFQ7IH0gZWxzZSB7IGFBID0gY3VycmVudFQ7IH1cbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiAwLjAwMDAwMDEgJiYgKytpIDwgMTApO1xuICAgIHJldHVybiBjdXJyZW50VDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7IHJldHVybiBhR3Vlc3NUOyB9XG4gICAgICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgICB9XG4gICAgcmV0dXJuIGFHdWVzc1Q7XG4gIH1cblxuICBmdW5jdGlvbiBiZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG5cbiAgICBpZiAoISgwIDw9IG1YMSAmJiBtWDEgPD0gMSAmJiAwIDw9IG1YMiAmJiBtWDIgPD0gMSkpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHNhbXBsZVZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG5cbiAgICBpZiAobVgxICE9PSBtWTEgfHwgbVgyICE9PSBtWTIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga1NwbGluZVRhYmxlU2l6ZTsgKytpKSB7XG4gICAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRGb3JYKGFYKSB7XG5cbiAgICAgIHZhciBpbnRlcnZhbFN0YXJ0ID0gMDtcbiAgICAgIHZhciBjdXJyZW50U2FtcGxlID0gMTtcbiAgICAgIHZhciBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG5cbiAgICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgICAgfVxuXG4gICAgICAtLWN1cnJlbnRTYW1wbGU7XG5cbiAgICAgIHZhciBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcbiAgICAgIHZhciBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgIHZhciBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcblxuICAgICAgaWYgKGluaXRpYWxTbG9wZSA+PSAwLjAwMSkge1xuICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHsgcmV0dXJuIHg7IH1cbiAgICAgIGlmICh4ID09PSAwIHx8IHggPT09IDEpIHsgcmV0dXJuIHg7IH1cbiAgICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKHgpLCBtWTEsIG1ZMik7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gYmV6aWVyO1xuXG59KSgpO1xuXG52YXIgcGVubmVyID0gKGZ1bmN0aW9uICgpIHtcblxuICB2YXIgbmFtZXMgPSBbJ1F1YWQnLCAnQ3ViaWMnLCAnUXVhcnQnLCAnUXVpbnQnLCAnU2luZScsICdFeHBvJywgJ0NpcmMnLCAnQmFjaycsICdFbGFzdGljJ107XG5cbiAgLy8gQXBwcm94aW1hdGVkIFBlbm5lciBlcXVhdGlvbnMgaHR0cDovL21hdHRoZXdsZWluLmNvbS9jZWFzZXIvXG5cbiAgdmFyIGN1cnZlcyA9IHtcbiAgICBJbjogW1xuICAgICAgWzAuNTUwLCAwLjA4NSwgMC42ODAsIDAuNTMwXSwgLyogaW5RdWFkICovXG4gICAgICBbMC41NTAsIDAuMDU1LCAwLjY3NSwgMC4xOTBdLCAvKiBpbkN1YmljICovXG4gICAgICBbMC44OTUsIDAuMDMwLCAwLjY4NSwgMC4yMjBdLCAvKiBpblF1YXJ0ICovXG4gICAgICBbMC43NTUsIDAuMDUwLCAwLjg1NSwgMC4wNjBdLCAvKiBpblF1aW50ICovXG4gICAgICBbMC40NzAsIDAuMDAwLCAwLjc0NSwgMC43MTVdLCAvKiBpblNpbmUgKi9cbiAgICAgIFswLjk1MCwgMC4wNTAsIDAuNzk1LCAwLjAzNV0sIC8qIGluRXhwbyAqL1xuICAgICAgWzAuNjAwLCAwLjA0MCwgMC45ODAsIDAuMzM1XSwgLyogaW5DaXJjICovXG4gICAgICBbMC42MDAsLTAuMjgwLCAwLjczNSwgMC4wNDVdLCAvKiBpbkJhY2sgKi9cbiAgICAgIGVsYXN0aWMgLyogaW5FbGFzdGljICovXG4gICAgXSxcbiAgICBPdXQ6IFtcbiAgICAgIFswLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MF0sIC8qIG91dFF1YWQgKi9cbiAgICAgIFswLjIxNSwgMC42MTAsIDAuMzU1LCAxLjAwMF0sIC8qIG91dEN1YmljICovXG4gICAgICBbMC4xNjUsIDAuODQwLCAwLjQ0MCwgMS4wMDBdLCAvKiBvdXRRdWFydCAqL1xuICAgICAgWzAuMjMwLCAxLjAwMCwgMC4zMjAsIDEuMDAwXSwgLyogb3V0UXVpbnQgKi9cbiAgICAgIFswLjM5MCwgMC41NzUsIDAuNTY1LCAxLjAwMF0sIC8qIG91dFNpbmUgKi9cbiAgICAgIFswLjE5MCwgMS4wMDAsIDAuMjIwLCAxLjAwMF0sIC8qIG91dEV4cG8gKi9cbiAgICAgIFswLjA3NSwgMC44MjAsIDAuMTY1LCAxLjAwMF0sIC8qIG91dENpcmMgKi9cbiAgICAgIFswLjE3NSwgMC44ODUsIDAuMzIwLCAxLjI3NV0sIC8qIG91dEJhY2sgKi9cbiAgICAgIGZ1bmN0aW9uIChhLCBwKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gMSAtIGVsYXN0aWMoYSwgcCkoMSAtIHQpOyB9OyB9IC8qIG91dEVsYXN0aWMgKi9cbiAgICBdLFxuICAgIEluT3V0OiBbXG4gICAgICBbMC40NTUsIDAuMDMwLCAwLjUxNSwgMC45NTVdLCAvKiBpbk91dFF1YWQgKi9cbiAgICAgIFswLjY0NSwgMC4wNDUsIDAuMzU1LCAxLjAwMF0sIC8qIGluT3V0Q3ViaWMgKi9cbiAgICAgIFswLjc3MCwgMC4wMDAsIDAuMTc1LCAxLjAwMF0sIC8qIGluT3V0UXVhcnQgKi9cbiAgICAgIFswLjg2MCwgMC4wMDAsIDAuMDcwLCAxLjAwMF0sIC8qIGluT3V0UXVpbnQgKi9cbiAgICAgIFswLjQ0NSwgMC4wNTAsIDAuNTUwLCAwLjk1MF0sIC8qIGluT3V0U2luZSAqL1xuICAgICAgWzEuMDAwLCAwLjAwMCwgMC4wMDAsIDEuMDAwXSwgLyogaW5PdXRFeHBvICovXG4gICAgICBbMC43ODUsIDAuMTM1LCAwLjE1MCwgMC44NjBdLCAvKiBpbk91dENpcmMgKi9cbiAgICAgIFswLjY4MCwtMC41NTAsIDAuMjY1LCAxLjU1MF0sIC8qIGluT3V0QmFjayAqL1xuICAgICAgZnVuY3Rpb24gKGEsIHApIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDwgLjUgPyBlbGFzdGljKGEsIHApKHQgKiAyKSAvIDIgOiAxIC0gZWxhc3RpYyhhLCBwKSh0ICogLTIgKyAyKSAvIDI7IH07IH0gLyogaW5PdXRFbGFzdGljICovXG4gICAgXVxuICB9O1xuXG4gIHZhciBlYXNlcyA9IHsgXG4gICAgbGluZWFyOiBbMC4yNTAsIDAuMjUwLCAwLjc1MCwgMC43NTBdXG4gIH07XG5cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGNvb3JkcyApIHtcbiAgICBjdXJ2ZXNbY29vcmRzXS5mb3JFYWNoKGZ1bmN0aW9uIChlYXNlLCBpKSB7XG4gICAgICBlYXNlc1snZWFzZScrY29vcmRzK25hbWVzW2ldXSA9IGVhc2U7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgY29vcmRzIGluIGN1cnZlcykgbG9vcCggY29vcmRzICk7XG5cbiAgcmV0dXJuIGVhc2VzO1xuXG59KSgpO1xuXG5mdW5jdGlvbiBwYXJzZUVhc2luZ3MoZWFzaW5nLCBkdXJhdGlvbikge1xuICBpZiAoaXMuZm5jKGVhc2luZykpIHsgcmV0dXJuIGVhc2luZzsgfVxuICB2YXIgbmFtZSA9IGVhc2luZy5zcGxpdCgnKCcpWzBdO1xuICB2YXIgZWFzZSA9IHBlbm5lcltuYW1lXTtcbiAgdmFyIGFyZ3MgPSBwYXJzZUVhc2luZ1BhcmFtZXRlcnMoZWFzaW5nKTtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnc3ByaW5nJyA6IHJldHVybiBzcHJpbmcoZWFzaW5nLCBkdXJhdGlvbik7XG4gICAgY2FzZSAnY3ViaWNCZXppZXInIDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKGJlemllciwgYXJncyk7XG4gICAgY2FzZSAnc3RlcHMnIDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKHN0ZXBzLCBhcmdzKTtcbiAgICBkZWZhdWx0IDogcmV0dXJuIGlzLmZuYyhlYXNlKSA/IGFwcGx5QXJndW1lbnRzKGVhc2UsIGFyZ3MpIDogYXBwbHlBcmd1bWVudHMoYmV6aWVyLCBlYXNlKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdzXG5cbmZ1bmN0aW9uIHNlbGVjdFN0cmluZyhzdHIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHN0cik7XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuLy8gQXJyYXlzXG5cbmZ1bmN0aW9uIGZpbHRlckFycmF5KGFyciwgY2FsbGJhY2spIHtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaSBpbiBhcnIpIHtcbiAgICAgIHZhciB2YWwgPSBhcnJbaV07XG4gICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWwsIGksIGFycikpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbkFycmF5KGFycikge1xuICByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jb25jYXQoaXMuYXJyKGIpID8gZmxhdHRlbkFycmF5KGIpIDogYik7IH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheShvKSB7XG4gIGlmIChpcy5hcnIobykpIHsgcmV0dXJuIG87IH1cbiAgaWYgKGlzLnN0cihvKSkgeyBvID0gc2VsZWN0U3RyaW5nKG8pIHx8IG87IH1cbiAgaWYgKG8gaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBvIGluc3RhbmNlb2YgSFRNTENvbGxlY3Rpb24pIHsgcmV0dXJuIFtdLnNsaWNlLmNhbGwobyk7IH1cbiAgcmV0dXJuIFtvXTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDb250YWlucyhhcnIsIHZhbCkge1xuICByZXR1cm4gYXJyLnNvbWUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgPT09IHZhbDsgfSk7XG59XG5cbi8vIE9iamVjdHNcblxuZnVuY3Rpb24gY2xvbmVPYmplY3Qobykge1xuICB2YXIgY2xvbmUgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBvKSB7IGNsb25lW3BdID0gb1twXTsgfVxuICByZXR1cm4gY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VPYmplY3RQcm9wcyhvMSwgbzIpIHtcbiAgdmFyIG8gPSBjbG9uZU9iamVjdChvMSk7XG4gIGZvciAodmFyIHAgaW4gbzEpIHsgb1twXSA9IG8yLmhhc093blByb3BlcnR5KHApID8gbzJbcF0gOiBvMVtwXTsgfVxuICByZXR1cm4gbztcbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG8xLCBvMikge1xuICB2YXIgbyA9IGNsb25lT2JqZWN0KG8xKTtcbiAgZm9yICh2YXIgcCBpbiBvMikgeyBvW3BdID0gaXMudW5kKG8xW3BdKSA/IG8yW3BdIDogbzFbcF07IH1cbiAgcmV0dXJuIG87XG59XG5cbi8vIENvbG9yc1xuXG5mdW5jdGlvbiByZ2JUb1JnYmEocmdiVmFsdWUpIHtcbiAgdmFyIHJnYiA9IC9yZ2JcXCgoXFxkKyxcXHMqW1xcZF0rLFxccypbXFxkXSspXFwpL2cuZXhlYyhyZ2JWYWx1ZSk7XG4gIHJldHVybiByZ2IgPyAoXCJyZ2JhKFwiICsgKHJnYlsxXSkgKyBcIiwxKVwiKSA6IHJnYlZhbHVlO1xufVxuXG5mdW5jdGlvbiBoZXhUb1JnYmEoaGV4VmFsdWUpIHtcbiAgdmFyIHJneCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG4gIHZhciBoZXggPSBoZXhWYWx1ZS5yZXBsYWNlKHJneCwgZnVuY3Rpb24gKG0sIHIsIGcsIGIpIHsgcmV0dXJuIHIgKyByICsgZyArIGcgKyBiICsgYjsgfSApO1xuICB2YXIgcmdiID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGhleCk7XG4gIHZhciByID0gcGFyc2VJbnQocmdiWzFdLCAxNik7XG4gIHZhciBnID0gcGFyc2VJbnQocmdiWzJdLCAxNik7XG4gIHZhciBiID0gcGFyc2VJbnQocmdiWzNdLCAxNik7XG4gIHJldHVybiAoXCJyZ2JhKFwiICsgciArIFwiLFwiICsgZyArIFwiLFwiICsgYiArIFwiLDEpXCIpO1xufVxuXG5mdW5jdGlvbiBoc2xUb1JnYmEoaHNsVmFsdWUpIHtcbiAgdmFyIGhzbCA9IC9oc2xcXCgoXFxkKyksXFxzKihbXFxkLl0rKSUsXFxzKihbXFxkLl0rKSVcXCkvZy5leGVjKGhzbFZhbHVlKSB8fCAvaHNsYVxcKChcXGQrKSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspXFwpL2cuZXhlYyhoc2xWYWx1ZSk7XG4gIHZhciBoID0gcGFyc2VJbnQoaHNsWzFdLCAxMCkgLyAzNjA7XG4gIHZhciBzID0gcGFyc2VJbnQoaHNsWzJdLCAxMCkgLyAxMDA7XG4gIHZhciBsID0gcGFyc2VJbnQoaHNsWzNdLCAxMCkgLyAxMDA7XG4gIHZhciBhID0gaHNsWzRdIHx8IDE7XG4gIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgIGlmICh0IDwgMCkgeyB0ICs9IDE7IH1cbiAgICBpZiAodCA+IDEpIHsgdCAtPSAxOyB9XG4gICAgaWYgKHQgPCAxLzYpIHsgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7IH1cbiAgICBpZiAodCA8IDEvMikgeyByZXR1cm4gcTsgfVxuICAgIGlmICh0IDwgMi8zKSB7IHJldHVybiBwICsgKHEgLSBwKSAqICgyLzMgLSB0KSAqIDY7IH1cbiAgICByZXR1cm4gcDtcbiAgfVxuICB2YXIgciwgZywgYjtcbiAgaWYgKHMgPT0gMCkge1xuICAgIHIgPSBnID0gYiA9IGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxLzMpO1xuICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxLzMpO1xuICB9XG4gIHJldHVybiAoXCJyZ2JhKFwiICsgKHIgKiAyNTUpICsgXCIsXCIgKyAoZyAqIDI1NSkgKyBcIixcIiArIChiICogMjU1KSArIFwiLFwiICsgYSArIFwiKVwiKTtcbn1cblxuZnVuY3Rpb24gY29sb3JUb1JnYih2YWwpIHtcbiAgaWYgKGlzLnJnYih2YWwpKSB7IHJldHVybiByZ2JUb1JnYmEodmFsKTsgfVxuICBpZiAoaXMuaGV4KHZhbCkpIHsgcmV0dXJuIGhleFRvUmdiYSh2YWwpOyB9XG4gIGlmIChpcy5oc2wodmFsKSkgeyByZXR1cm4gaHNsVG9SZ2JhKHZhbCk7IH1cbn1cblxuLy8gVW5pdHNcblxuZnVuY3Rpb24gZ2V0VW5pdCh2YWwpIHtcbiAgdmFyIHNwbGl0ID0gLyhbXFwrXFwtXT9bMC05I1xcLl0rKSglfHB4fHB0fGVtfHJlbXxpbnxjbXxtbXxleHxjaHxwY3x2d3x2aHx2bWlufHZtYXh8ZGVnfHJhZHx0dXJuKT8kLy5leGVjKHZhbCk7XG4gIGlmIChzcGxpdCkgeyByZXR1cm4gc3BsaXRbMl07IH1cbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtVW5pdChwcm9wTmFtZSkge1xuICBpZiAoc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICd0cmFuc2xhdGUnKSB8fCBwcm9wTmFtZSA9PT0gJ3BlcnNwZWN0aXZlJykgeyByZXR1cm4gJ3B4JzsgfVxuICBpZiAoc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICdyb3RhdGUnKSB8fCBzdHJpbmdDb250YWlucyhwcm9wTmFtZSwgJ3NrZXcnKSkgeyByZXR1cm4gJ2RlZyc7IH1cbn1cblxuLy8gVmFsdWVzXG5cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uVmFsdWUodmFsLCBhbmltYXRhYmxlKSB7XG4gIGlmICghaXMuZm5jKHZhbCkpIHsgcmV0dXJuIHZhbDsgfVxuICByZXR1cm4gdmFsKGFuaW1hdGFibGUudGFyZ2V0LCBhbmltYXRhYmxlLmlkLCBhbmltYXRhYmxlLnRvdGFsKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGVsLCBwcm9wKSB7XG4gIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUocHJvcCk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRQeFRvVW5pdChlbCwgdmFsdWUsIHVuaXQpIHtcbiAgdmFyIHZhbHVlVW5pdCA9IGdldFVuaXQodmFsdWUpO1xuICBpZiAoYXJyYXlDb250YWlucyhbdW5pdCwgJ2RlZycsICdyYWQnLCAndHVybiddLCB2YWx1ZVVuaXQpKSB7IHJldHVybiB2YWx1ZTsgfVxuICB2YXIgY2FjaGVkID0gY2FjaGUuQ1NTW3ZhbHVlICsgdW5pdF07XG4gIGlmICghaXMudW5kKGNhY2hlZCkpIHsgcmV0dXJuIGNhY2hlZDsgfVxuICB2YXIgYmFzZWxpbmUgPSAxMDA7XG4gIHZhciB0ZW1wRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsLnRhZ05hbWUpO1xuICB2YXIgcGFyZW50RWwgPSAoZWwucGFyZW50Tm9kZSAmJiAoZWwucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQpKSA/IGVsLnBhcmVudE5vZGUgOiBkb2N1bWVudC5ib2R5O1xuICBwYXJlbnRFbC5hcHBlbmRDaGlsZCh0ZW1wRWwpO1xuICB0ZW1wRWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICB0ZW1wRWwuc3R5bGUud2lkdGggPSBiYXNlbGluZSArIHVuaXQ7XG4gIHZhciBmYWN0b3IgPSBiYXNlbGluZSAvIHRlbXBFbC5vZmZzZXRXaWR0aDtcbiAgcGFyZW50RWwucmVtb3ZlQ2hpbGQodGVtcEVsKTtcbiAgdmFyIGNvbnZlcnRlZFVuaXQgPSBmYWN0b3IgKiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgY2FjaGUuQ1NTW3ZhbHVlICsgdW5pdF0gPSBjb252ZXJ0ZWRVbml0O1xuICByZXR1cm4gY29udmVydGVkVW5pdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q1NTVmFsdWUoZWwsIHByb3AsIHVuaXQpIHtcbiAgaWYgKHByb3AgaW4gZWwuc3R5bGUpIHtcbiAgICB2YXIgdXBwZXJjYXNlUHJvcE5hbWUgPSBwcm9wLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHZhbHVlID0gZWwuc3R5bGVbcHJvcF0gfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZSh1cHBlcmNhc2VQcm9wTmFtZSkgfHwgJzAnO1xuICAgIHJldHVybiB1bml0ID8gY29udmVydFB4VG9Vbml0KGVsLCB2YWx1ZSwgdW5pdCkgOiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRpb25UeXBlKGVsLCBwcm9wKSB7XG4gIGlmIChpcy5kb20oZWwpICYmICFpcy5pbnAoZWwpICYmIChnZXRBdHRyaWJ1dGUoZWwsIHByb3ApIHx8IChpcy5zdmcoZWwpICYmIGVsW3Byb3BdKSkpIHsgcmV0dXJuICdhdHRyaWJ1dGUnOyB9XG4gIGlmIChpcy5kb20oZWwpICYmIGFycmF5Q29udGFpbnModmFsaWRUcmFuc2Zvcm1zLCBwcm9wKSkgeyByZXR1cm4gJ3RyYW5zZm9ybSc7IH1cbiAgaWYgKGlzLmRvbShlbCkgJiYgKHByb3AgIT09ICd0cmFuc2Zvcm0nICYmIGdldENTU1ZhbHVlKGVsLCBwcm9wKSkpIHsgcmV0dXJuICdjc3MnOyB9XG4gIGlmIChlbFtwcm9wXSAhPSBudWxsKSB7IHJldHVybiAnb2JqZWN0JzsgfVxufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50VHJhbnNmb3JtcyhlbCkge1xuICBpZiAoIWlzLmRvbShlbCkpIHsgcmV0dXJuOyB9XG4gIHZhciBzdHIgPSBlbC5zdHlsZS50cmFuc2Zvcm0gfHwgJyc7XG4gIHZhciByZWcgID0gLyhcXHcrKVxcKChbXildKilcXCkvZztcbiAgdmFyIHRyYW5zZm9ybXMgPSBuZXcgTWFwKCk7XG4gIHZhciBtOyB3aGlsZSAobSA9IHJlZy5leGVjKHN0cikpIHsgdHJhbnNmb3Jtcy5zZXQobVsxXSwgbVsyXSk7IH1cbiAgcmV0dXJuIHRyYW5zZm9ybXM7XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybVZhbHVlKGVsLCBwcm9wTmFtZSwgYW5pbWF0YWJsZSwgdW5pdCkge1xuICB2YXIgZGVmYXVsdFZhbCA9IHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAnc2NhbGUnKSA/IDEgOiAwICsgZ2V0VHJhbnNmb3JtVW5pdChwcm9wTmFtZSk7XG4gIHZhciB2YWx1ZSA9IGdldEVsZW1lbnRUcmFuc2Zvcm1zKGVsKS5nZXQocHJvcE5hbWUpIHx8IGRlZmF1bHRWYWw7XG4gIGlmIChhbmltYXRhYmxlKSB7XG4gICAgYW5pbWF0YWJsZS50cmFuc2Zvcm1zLmxpc3Quc2V0KHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgYW5pbWF0YWJsZS50cmFuc2Zvcm1zWydsYXN0J10gPSBwcm9wTmFtZTtcbiAgfVxuICByZXR1cm4gdW5pdCA/IGNvbnZlcnRQeFRvVW5pdChlbCwgdmFsdWUsIHVuaXQpIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldE9yaWdpbmFsVGFyZ2V0VmFsdWUodGFyZ2V0LCBwcm9wTmFtZSwgdW5pdCwgYW5pbWF0YWJsZSkge1xuICBzd2l0Y2ggKGdldEFuaW1hdGlvblR5cGUodGFyZ2V0LCBwcm9wTmFtZSkpIHtcbiAgICBjYXNlICd0cmFuc2Zvcm0nOiByZXR1cm4gZ2V0VHJhbnNmb3JtVmFsdWUodGFyZ2V0LCBwcm9wTmFtZSwgYW5pbWF0YWJsZSwgdW5pdCk7XG4gICAgY2FzZSAnY3NzJzogcmV0dXJuIGdldENTU1ZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHVuaXQpO1xuICAgIGNhc2UgJ2F0dHJpYnV0ZSc6IHJldHVybiBnZXRBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wTmFtZSk7XG4gICAgZGVmYXVsdDogcmV0dXJuIHRhcmdldFtwcm9wTmFtZV0gfHwgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVZhbHVlKHRvLCBmcm9tKSB7XG4gIHZhciBvcGVyYXRvciA9IC9eKFxcKj18XFwrPXwtPSkvLmV4ZWModG8pO1xuICBpZiAoIW9wZXJhdG9yKSB7IHJldHVybiB0bzsgfVxuICB2YXIgdSA9IGdldFVuaXQodG8pIHx8IDA7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChmcm9tKTtcbiAgdmFyIHkgPSBwYXJzZUZsb2F0KHRvLnJlcGxhY2Uob3BlcmF0b3JbMF0sICcnKSk7XG4gIHN3aXRjaCAob3BlcmF0b3JbMF1bMF0pIHtcbiAgICBjYXNlICcrJzogcmV0dXJuIHggKyB5ICsgdTtcbiAgICBjYXNlICctJzogcmV0dXJuIHggLSB5ICsgdTtcbiAgICBjYXNlICcqJzogcmV0dXJuIHggKiB5ICsgdTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVZhbHVlKHZhbCwgdW5pdCkge1xuICBpZiAoaXMuY29sKHZhbCkpIHsgcmV0dXJuIGNvbG9yVG9SZ2IodmFsKTsgfVxuICB2YXIgb3JpZ2luYWxVbml0ID0gZ2V0VW5pdCh2YWwpO1xuICB2YXIgdW5pdExlc3MgPSBvcmlnaW5hbFVuaXQgPyB2YWwuc3Vic3RyKDAsIHZhbC5sZW5ndGggLSBvcmlnaW5hbFVuaXQubGVuZ3RoKSA6IHZhbDtcbiAgcmV0dXJuIHVuaXQgJiYgIS9cXHMvZy50ZXN0KHZhbCkgPyB1bml0TGVzcyArIHVuaXQgOiB1bml0TGVzcztcbn1cblxuLy8gZ2V0VG90YWxMZW5ndGgoKSBlcXVpdmFsZW50IGZvciBjaXJjbGUsIHJlY3QsIHBvbHlsaW5lLCBwb2x5Z29uIGFuZCBsaW5lIHNoYXBlc1xuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1NlYkxhbWJsYS8zZTA1NTBjNDk2YzIzNjcwOTc0NFxuXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwMi54IC0gcDEueCwgMikgKyBNYXRoLnBvdyhwMi55IC0gcDEueSwgMikpO1xufVxuXG5mdW5jdGlvbiBnZXRDaXJjbGVMZW5ndGgoZWwpIHtcbiAgcmV0dXJuIE1hdGguUEkgKiAyICogZ2V0QXR0cmlidXRlKGVsLCAncicpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0TGVuZ3RoKGVsKSB7XG4gIHJldHVybiAoZ2V0QXR0cmlidXRlKGVsLCAnd2lkdGgnKSAqIDIpICsgKGdldEF0dHJpYnV0ZShlbCwgJ2hlaWdodCcpICogMik7XG59XG5cbmZ1bmN0aW9uIGdldExpbmVMZW5ndGgoZWwpIHtcbiAgcmV0dXJuIGdldERpc3RhbmNlKFxuICAgIHt4OiBnZXRBdHRyaWJ1dGUoZWwsICd4MScpLCB5OiBnZXRBdHRyaWJ1dGUoZWwsICd5MScpfSwgXG4gICAge3g6IGdldEF0dHJpYnV0ZShlbCwgJ3gyJyksIHk6IGdldEF0dHJpYnV0ZShlbCwgJ3kyJyl9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFBvbHlsaW5lTGVuZ3RoKGVsKSB7XG4gIHZhciBwb2ludHMgPSBlbC5wb2ludHM7XG4gIHZhciB0b3RhbExlbmd0aCA9IDA7XG4gIHZhciBwcmV2aW91c1BvcztcbiAgZm9yICh2YXIgaSA9IDAgOyBpIDwgcG9pbnRzLm51bWJlck9mSXRlbXM7IGkrKykge1xuICAgIHZhciBjdXJyZW50UG9zID0gcG9pbnRzLmdldEl0ZW0oaSk7XG4gICAgaWYgKGkgPiAwKSB7IHRvdGFsTGVuZ3RoICs9IGdldERpc3RhbmNlKHByZXZpb3VzUG9zLCBjdXJyZW50UG9zKTsgfVxuICAgIHByZXZpb3VzUG9zID0gY3VycmVudFBvcztcbiAgfVxuICByZXR1cm4gdG90YWxMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGdldFBvbHlnb25MZW5ndGgoZWwpIHtcbiAgdmFyIHBvaW50cyA9IGVsLnBvaW50cztcbiAgcmV0dXJuIGdldFBvbHlsaW5lTGVuZ3RoKGVsKSArIGdldERpc3RhbmNlKHBvaW50cy5nZXRJdGVtKHBvaW50cy5udW1iZXJPZkl0ZW1zIC0gMSksIHBvaW50cy5nZXRJdGVtKDApKTtcbn1cblxuLy8gUGF0aCBhbmltYXRpb25cblxuZnVuY3Rpb24gZ2V0VG90YWxMZW5ndGgoZWwpIHtcbiAgaWYgKGVsLmdldFRvdGFsTGVuZ3RoKSB7IHJldHVybiBlbC5nZXRUb3RhbExlbmd0aCgpOyB9XG4gIHN3aXRjaChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdjaXJjbGUnOiByZXR1cm4gZ2V0Q2lyY2xlTGVuZ3RoKGVsKTtcbiAgICBjYXNlICdyZWN0JzogcmV0dXJuIGdldFJlY3RMZW5ndGgoZWwpO1xuICAgIGNhc2UgJ2xpbmUnOiByZXR1cm4gZ2V0TGluZUxlbmd0aChlbCk7XG4gICAgY2FzZSAncG9seWxpbmUnOiByZXR1cm4gZ2V0UG9seWxpbmVMZW5ndGgoZWwpO1xuICAgIGNhc2UgJ3BvbHlnb24nOiByZXR1cm4gZ2V0UG9seWdvbkxlbmd0aChlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0RGFzaG9mZnNldChlbCkge1xuICB2YXIgcGF0aExlbmd0aCA9IGdldFRvdGFsTGVuZ3RoKGVsKTtcbiAgZWwuc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5JywgcGF0aExlbmd0aCk7XG4gIHJldHVybiBwYXRoTGVuZ3RoO1xufVxuXG4vLyBNb3Rpb24gcGF0aFxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTdmdFbChlbCkge1xuICB2YXIgcGFyZW50RWwgPSBlbC5wYXJlbnROb2RlO1xuICB3aGlsZSAoaXMuc3ZnKHBhcmVudEVsKSkge1xuICAgIHBhcmVudEVsID0gcGFyZW50RWwucGFyZW50Tm9kZTtcbiAgICBpZiAoIWlzLnN2ZyhwYXJlbnRFbC5wYXJlbnROb2RlKSkgeyBicmVhazsgfVxuICB9XG4gIHJldHVybiBwYXJlbnRFbDtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50U3ZnKHBhdGhFbCwgc3ZnRGF0YSkge1xuICB2YXIgc3ZnID0gc3ZnRGF0YSB8fCB7fTtcbiAgdmFyIHBhcmVudFN2Z0VsID0gc3ZnLmVsIHx8IGdldFBhcmVudFN2Z0VsKHBhdGhFbCk7XG4gIHZhciByZWN0ID0gcGFyZW50U3ZnRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciB2aWV3Qm94QXR0ciA9IGdldEF0dHJpYnV0ZShwYXJlbnRTdmdFbCwgJ3ZpZXdCb3gnKTtcbiAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB2YXIgdmlld0JveCA9IHN2Zy52aWV3Qm94IHx8ICh2aWV3Qm94QXR0ciA/IHZpZXdCb3hBdHRyLnNwbGl0KCcgJykgOiBbMCwgMCwgd2lkdGgsIGhlaWdodF0pO1xuICByZXR1cm4ge1xuICAgIGVsOiBwYXJlbnRTdmdFbCxcbiAgICB2aWV3Qm94OiB2aWV3Qm94LFxuICAgIHg6IHZpZXdCb3hbMF0gLyAxLFxuICAgIHk6IHZpZXdCb3hbMV0gLyAxLFxuICAgIHc6IHdpZHRoIC8gdmlld0JveFsyXSxcbiAgICBoOiBoZWlnaHQgLyB2aWV3Qm94WzNdXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UGF0aChwYXRoLCBwZXJjZW50KSB7XG4gIHZhciBwYXRoRWwgPSBpcy5zdHIocGF0aCkgPyBzZWxlY3RTdHJpbmcocGF0aClbMF0gOiBwYXRoO1xuICB2YXIgcCA9IHBlcmNlbnQgfHwgMTAwO1xuICByZXR1cm4gZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxuICAgICAgZWw6IHBhdGhFbCxcbiAgICAgIHN2ZzogZ2V0UGFyZW50U3ZnKHBhdGhFbCksXG4gICAgICB0b3RhbExlbmd0aDogZ2V0VG90YWxMZW5ndGgocGF0aEVsKSAqIChwIC8gMTAwKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYXRoUHJvZ3Jlc3MocGF0aCwgcHJvZ3Jlc3MpIHtcbiAgZnVuY3Rpb24gcG9pbnQob2Zmc2V0KSB7XG4gICAgaWYgKCBvZmZzZXQgPT09IHZvaWQgMCApIG9mZnNldCA9IDA7XG5cbiAgICB2YXIgbCA9IHByb2dyZXNzICsgb2Zmc2V0ID49IDEgPyBwcm9ncmVzcyArIG9mZnNldCA6IDA7XG4gICAgcmV0dXJuIHBhdGguZWwuZ2V0UG9pbnRBdExlbmd0aChsKTtcbiAgfVxuICB2YXIgc3ZnID0gZ2V0UGFyZW50U3ZnKHBhdGguZWwsIHBhdGguc3ZnKTtcbiAgdmFyIHAgPSBwb2ludCgpO1xuICB2YXIgcDAgPSBwb2ludCgtMSk7XG4gIHZhciBwMSA9IHBvaW50KCsxKTtcbiAgc3dpdGNoIChwYXRoLnByb3BlcnR5KSB7XG4gICAgY2FzZSAneCc6IHJldHVybiAocC54IC0gc3ZnLngpICogc3ZnLnc7XG4gICAgY2FzZSAneSc6IHJldHVybiAocC55IC0gc3ZnLnkpICogc3ZnLmg7XG4gICAgY2FzZSAnYW5nbGUnOiByZXR1cm4gTWF0aC5hdGFuMihwMS55IC0gcDAueSwgcDEueCAtIHAwLngpICogMTgwIC8gTWF0aC5QSTtcbiAgfVxufVxuXG4vLyBEZWNvbXBvc2UgdmFsdWVcblxuZnVuY3Rpb24gZGVjb21wb3NlVmFsdWUodmFsLCB1bml0KSB7XG4gIHZhciByZ3ggPSAvLT9cXGQqXFwuP1xcZCsvZztcbiAgdmFyIHZhbHVlID0gdmFsaWRhdGVWYWx1ZSgoaXMucHRoKHZhbCkgPyB2YWwudG90YWxMZW5ndGggOiB2YWwpLCB1bml0KSArICcnO1xuICByZXR1cm4ge1xuICAgIG9yaWdpbmFsOiB2YWx1ZSxcbiAgICBudW1iZXJzOiB2YWx1ZS5tYXRjaChyZ3gpID8gdmFsdWUubWF0Y2gocmd4KS5tYXAoTnVtYmVyKSA6IFswXSxcbiAgICBzdHJpbmdzOiAoaXMuc3RyKHZhbCkgfHwgdW5pdCkgPyB2YWx1ZS5zcGxpdChyZ3gpIDogW11cbiAgfVxufVxuXG4vLyBBbmltYXRhYmxlc1xuXG5mdW5jdGlvbiBwYXJzZVRhcmdldHModGFyZ2V0cykge1xuICB2YXIgdGFyZ2V0c0FycmF5ID0gdGFyZ2V0cyA/IChmbGF0dGVuQXJyYXkoaXMuYXJyKHRhcmdldHMpID8gdGFyZ2V0cy5tYXAodG9BcnJheSkgOiB0b0FycmF5KHRhcmdldHMpKSkgOiBbXTtcbiAgcmV0dXJuIGZpbHRlckFycmF5KHRhcmdldHNBcnJheSwgZnVuY3Rpb24gKGl0ZW0sIHBvcywgc2VsZikgeyByZXR1cm4gc2VsZi5pbmRleE9mKGl0ZW0pID09PSBwb3M7IH0pO1xufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRhYmxlcyh0YXJnZXRzKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZVRhcmdldHModGFyZ2V0cyk7XG4gIHJldHVybiBwYXJzZWQubWFwKGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgcmV0dXJuIHt0YXJnZXQ6IHQsIGlkOiBpLCB0b3RhbDogcGFyc2VkLmxlbmd0aCwgdHJhbnNmb3JtczogeyBsaXN0OiBnZXRFbGVtZW50VHJhbnNmb3Jtcyh0KSB9IH07XG4gIH0pO1xufVxuXG4vLyBQcm9wZXJ0aWVzXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BlcnR5VHdlZW5zKHByb3AsIHR3ZWVuU2V0dGluZ3MpIHtcbiAgdmFyIHNldHRpbmdzID0gY2xvbmVPYmplY3QodHdlZW5TZXR0aW5ncyk7XG4gIC8vIE92ZXJyaWRlIGR1cmF0aW9uIGlmIGVhc2luZyBpcyBhIHNwcmluZ1xuICBpZiAoL15zcHJpbmcvLnRlc3Qoc2V0dGluZ3MuZWFzaW5nKSkgeyBzZXR0aW5ncy5kdXJhdGlvbiA9IHNwcmluZyhzZXR0aW5ncy5lYXNpbmcpOyB9XG4gIGlmIChpcy5hcnIocHJvcCkpIHtcbiAgICB2YXIgbCA9IHByb3AubGVuZ3RoO1xuICAgIHZhciBpc0Zyb21UbyA9IChsID09PSAyICYmICFpcy5vYmoocHJvcFswXSkpO1xuICAgIGlmICghaXNGcm9tVG8pIHtcbiAgICAgIC8vIER1cmF0aW9uIGRpdmlkZWQgYnkgdGhlIG51bWJlciBvZiB0d2VlbnNcbiAgICAgIGlmICghaXMuZm5jKHR3ZWVuU2V0dGluZ3MuZHVyYXRpb24pKSB7IHNldHRpbmdzLmR1cmF0aW9uID0gdHdlZW5TZXR0aW5ncy5kdXJhdGlvbiAvIGw7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJhbnNmb3JtIFtmcm9tLCB0b10gdmFsdWVzIHNob3J0aGFuZCB0byBhIHZhbGlkIHR3ZWVuIHZhbHVlXG4gICAgICBwcm9wID0ge3ZhbHVlOiBwcm9wfTtcbiAgICB9XG4gIH1cbiAgdmFyIHByb3BBcnJheSA9IGlzLmFycihwcm9wKSA/IHByb3AgOiBbcHJvcF07XG4gIHJldHVybiBwcm9wQXJyYXkubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgdmFyIG9iaiA9IChpcy5vYmoodikgJiYgIWlzLnB0aCh2KSkgPyB2IDoge3ZhbHVlOiB2fTtcbiAgICAvLyBEZWZhdWx0IGRlbGF5IHZhbHVlIHNob3VsZCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGZpcnN0IHR3ZWVuXG4gICAgaWYgKGlzLnVuZChvYmouZGVsYXkpKSB7IG9iai5kZWxheSA9ICFpID8gdHdlZW5TZXR0aW5ncy5kZWxheSA6IDA7IH1cbiAgICAvLyBEZWZhdWx0IGVuZERlbGF5IHZhbHVlIHNob3VsZCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGxhc3QgdHdlZW5cbiAgICBpZiAoaXMudW5kKG9iai5lbmREZWxheSkpIHsgb2JqLmVuZERlbGF5ID0gaSA9PT0gcHJvcEFycmF5Lmxlbmd0aCAtIDEgPyB0d2VlblNldHRpbmdzLmVuZERlbGF5IDogMDsgfVxuICAgIHJldHVybiBvYmo7XG4gIH0pLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gbWVyZ2VPYmplY3RzKGssIHNldHRpbmdzKTsgfSk7XG59XG5cblxuZnVuY3Rpb24gZmxhdHRlbktleWZyYW1lcyhrZXlmcmFtZXMpIHtcbiAgdmFyIHByb3BlcnR5TmFtZXMgPSBmaWx0ZXJBcnJheShmbGF0dGVuQXJyYXkoa2V5ZnJhbWVzLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBPYmplY3Qua2V5cyhrZXkpOyB9KSksIGZ1bmN0aW9uIChwKSB7IHJldHVybiBpcy5rZXkocCk7IH0pXG4gIC5yZWR1Y2UoZnVuY3Rpb24gKGEsYikgeyBpZiAoYS5pbmRleE9mKGIpIDwgMCkgeyBhLnB1c2goYik7IH0gcmV0dXJuIGE7IH0sIFtdKTtcbiAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlOYW1lc1tpXTtcbiAgICBwcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IGtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG5ld0tleSA9IHt9O1xuICAgICAgZm9yICh2YXIgcCBpbiBrZXkpIHtcbiAgICAgICAgaWYgKGlzLmtleShwKSkge1xuICAgICAgICAgIGlmIChwID09IHByb3BOYW1lKSB7IG5ld0tleS52YWx1ZSA9IGtleVtwXTsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0tleVtwXSA9IGtleVtwXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0tleTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5TmFtZXMubGVuZ3RoOyBpKyspIGxvb3AoIGkgKTtcbiAgcmV0dXJuIHByb3BlcnRpZXM7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnRpZXModHdlZW5TZXR0aW5ncywgcGFyYW1zKSB7XG4gIHZhciBwcm9wZXJ0aWVzID0gW107XG4gIHZhciBrZXlmcmFtZXMgPSBwYXJhbXMua2V5ZnJhbWVzO1xuICBpZiAoa2V5ZnJhbWVzKSB7IHBhcmFtcyA9IG1lcmdlT2JqZWN0cyhmbGF0dGVuS2V5ZnJhbWVzKGtleWZyYW1lcyksIHBhcmFtcyk7IH1cbiAgZm9yICh2YXIgcCBpbiBwYXJhbXMpIHtcbiAgICBpZiAoaXMua2V5KHApKSB7XG4gICAgICBwcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICBuYW1lOiBwLFxuICAgICAgICB0d2VlbnM6IG5vcm1hbGl6ZVByb3BlcnR5VHdlZW5zKHBhcmFtc1twXSwgdHdlZW5TZXR0aW5ncylcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcGVydGllcztcbn1cblxuLy8gVHdlZW5zXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVR3ZWVuVmFsdWVzKHR3ZWVuLCBhbmltYXRhYmxlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gdHdlZW4pIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRGdW5jdGlvblZhbHVlKHR3ZWVuW3BdLCBhbmltYXRhYmxlKTtcbiAgICBpZiAoaXMuYXJyKHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGdldEZ1bmN0aW9uVmFsdWUodiwgYW5pbWF0YWJsZSk7IH0pO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMSkgeyB2YWx1ZSA9IHZhbHVlWzBdOyB9XG4gICAgfVxuICAgIHRbcF0gPSB2YWx1ZTtcbiAgfVxuICB0LmR1cmF0aW9uID0gcGFyc2VGbG9hdCh0LmR1cmF0aW9uKTtcbiAgdC5kZWxheSA9IHBhcnNlRmxvYXQodC5kZWxheSk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVUd2VlbnMocHJvcCwgYW5pbWF0YWJsZSkge1xuICB2YXIgcHJldmlvdXNUd2VlbjtcbiAgcmV0dXJuIHByb3AudHdlZW5zLm1hcChmdW5jdGlvbiAodCkge1xuICAgIHZhciB0d2VlbiA9IG5vcm1hbGl6ZVR3ZWVuVmFsdWVzKHQsIGFuaW1hdGFibGUpO1xuICAgIHZhciB0d2VlblZhbHVlID0gdHdlZW4udmFsdWU7XG4gICAgdmFyIHRvID0gaXMuYXJyKHR3ZWVuVmFsdWUpID8gdHdlZW5WYWx1ZVsxXSA6IHR3ZWVuVmFsdWU7XG4gICAgdmFyIHRvVW5pdCA9IGdldFVuaXQodG8pO1xuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZShhbmltYXRhYmxlLnRhcmdldCwgcHJvcC5uYW1lLCB0b1VuaXQsIGFuaW1hdGFibGUpO1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gcHJldmlvdXNUd2VlbiA/IHByZXZpb3VzVHdlZW4udG8ub3JpZ2luYWwgOiBvcmlnaW5hbFZhbHVlO1xuICAgIHZhciBmcm9tID0gaXMuYXJyKHR3ZWVuVmFsdWUpID8gdHdlZW5WYWx1ZVswXSA6IHByZXZpb3VzVmFsdWU7XG4gICAgdmFyIGZyb21Vbml0ID0gZ2V0VW5pdChmcm9tKSB8fCBnZXRVbml0KG9yaWdpbmFsVmFsdWUpO1xuICAgIHZhciB1bml0ID0gdG9Vbml0IHx8IGZyb21Vbml0O1xuICAgIGlmIChpcy51bmQodG8pKSB7IHRvID0gcHJldmlvdXNWYWx1ZTsgfVxuICAgIHR3ZWVuLmZyb20gPSBkZWNvbXBvc2VWYWx1ZShmcm9tLCB1bml0KTtcbiAgICB0d2Vlbi50byA9IGRlY29tcG9zZVZhbHVlKGdldFJlbGF0aXZlVmFsdWUodG8sIGZyb20pLCB1bml0KTtcbiAgICB0d2Vlbi5zdGFydCA9IHByZXZpb3VzVHdlZW4gPyBwcmV2aW91c1R3ZWVuLmVuZCA6IDA7XG4gICAgdHdlZW4uZW5kID0gdHdlZW4uc3RhcnQgKyB0d2Vlbi5kZWxheSArIHR3ZWVuLmR1cmF0aW9uICsgdHdlZW4uZW5kRGVsYXk7XG4gICAgdHdlZW4uZWFzaW5nID0gcGFyc2VFYXNpbmdzKHR3ZWVuLmVhc2luZywgdHdlZW4uZHVyYXRpb24pO1xuICAgIHR3ZWVuLmlzUGF0aCA9IGlzLnB0aCh0d2VlblZhbHVlKTtcbiAgICB0d2Vlbi5pc0NvbG9yID0gaXMuY29sKHR3ZWVuLmZyb20ub3JpZ2luYWwpO1xuICAgIGlmICh0d2Vlbi5pc0NvbG9yKSB7IHR3ZWVuLnJvdW5kID0gMTsgfVxuICAgIHByZXZpb3VzVHdlZW4gPSB0d2VlbjtcbiAgICByZXR1cm4gdHdlZW47XG4gIH0pO1xufVxuXG4vLyBUd2VlbiBwcm9ncmVzc1xuXG52YXIgc2V0UHJvZ3Jlc3NWYWx1ZSA9IHtcbiAgY3NzOiBmdW5jdGlvbiAodCwgcCwgdikgeyByZXR1cm4gdC5zdHlsZVtwXSA9IHY7IH0sXG4gIGF0dHJpYnV0ZTogZnVuY3Rpb24gKHQsIHAsIHYpIHsgcmV0dXJuIHQuc2V0QXR0cmlidXRlKHAsIHYpOyB9LFxuICBvYmplY3Q6IGZ1bmN0aW9uICh0LCBwLCB2KSB7IHJldHVybiB0W3BdID0gdjsgfSxcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiAodCwgcCwgdiwgdHJhbnNmb3JtcywgbWFudWFsKSB7XG4gICAgdHJhbnNmb3Jtcy5saXN0LnNldChwLCB2KTtcbiAgICBpZiAocCA9PT0gdHJhbnNmb3Jtcy5sYXN0IHx8IG1hbnVhbCkge1xuICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgdHJhbnNmb3Jtcy5saXN0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBwcm9wKSB7IHN0ciArPSBwcm9wICsgXCIoXCIgKyB2YWx1ZSArIFwiKSBcIjsgfSk7XG4gICAgICB0LnN0eWxlLnRyYW5zZm9ybSA9IHN0cjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIFNldCBWYWx1ZSBoZWxwZXJcblxuZnVuY3Rpb24gc2V0VGFyZ2V0c1ZhbHVlKHRhcmdldHMsIHByb3BlcnRpZXMpIHtcbiAgdmFyIGFuaW1hdGFibGVzID0gZ2V0QW5pbWF0YWJsZXModGFyZ2V0cyk7XG4gIGFuaW1hdGFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGFibGUpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRGdW5jdGlvblZhbHVlKHByb3BlcnRpZXNbcHJvcGVydHldLCBhbmltYXRhYmxlKTtcbiAgICAgIHZhciB0YXJnZXQgPSBhbmltYXRhYmxlLnRhcmdldDtcbiAgICAgIHZhciB2YWx1ZVVuaXQgPSBnZXRVbml0KHZhbHVlKTtcbiAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZVVuaXQsIGFuaW1hdGFibGUpO1xuICAgICAgdmFyIHVuaXQgPSB2YWx1ZVVuaXQgfHwgZ2V0VW5pdChvcmlnaW5hbFZhbHVlKTtcbiAgICAgIHZhciB0byA9IGdldFJlbGF0aXZlVmFsdWUodmFsaWRhdGVWYWx1ZSh2YWx1ZSwgdW5pdCksIG9yaWdpbmFsVmFsdWUpO1xuICAgICAgdmFyIGFuaW1UeXBlID0gZ2V0QW5pbWF0aW9uVHlwZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIHNldFByb2dyZXNzVmFsdWVbYW5pbVR5cGVdKHRhcmdldCwgcHJvcGVydHksIHRvLCBhbmltYXRhYmxlLnRyYW5zZm9ybXMsIHRydWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIEFuaW1hdGlvbnNcblxuZnVuY3Rpb24gY3JlYXRlQW5pbWF0aW9uKGFuaW1hdGFibGUsIHByb3ApIHtcbiAgdmFyIGFuaW1UeXBlID0gZ2V0QW5pbWF0aW9uVHlwZShhbmltYXRhYmxlLnRhcmdldCwgcHJvcC5uYW1lKTtcbiAgaWYgKGFuaW1UeXBlKSB7XG4gICAgdmFyIHR3ZWVucyA9IG5vcm1hbGl6ZVR3ZWVucyhwcm9wLCBhbmltYXRhYmxlKTtcbiAgICB2YXIgbGFzdFR3ZWVuID0gdHdlZW5zW3R3ZWVucy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogYW5pbVR5cGUsXG4gICAgICBwcm9wZXJ0eTogcHJvcC5uYW1lLFxuICAgICAgYW5pbWF0YWJsZTogYW5pbWF0YWJsZSxcbiAgICAgIHR3ZWVuczogdHdlZW5zLFxuICAgICAgZHVyYXRpb246IGxhc3RUd2Vlbi5lbmQsXG4gICAgICBkZWxheTogdHdlZW5zWzBdLmRlbGF5LFxuICAgICAgZW5kRGVsYXk6IGxhc3RUd2Vlbi5lbmREZWxheVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRpb25zKGFuaW1hdGFibGVzLCBwcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBmaWx0ZXJBcnJheShmbGF0dGVuQXJyYXkoYW5pbWF0YWJsZXMubWFwKGZ1bmN0aW9uIChhbmltYXRhYmxlKSB7XG4gICAgcmV0dXJuIHByb3BlcnRpZXMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQW5pbWF0aW9uKGFuaW1hdGFibGUsIHByb3ApO1xuICAgIH0pO1xuICB9KSksIGZ1bmN0aW9uIChhKSB7IHJldHVybiAhaXMudW5kKGEpOyB9KTtcbn1cblxuLy8gQ3JlYXRlIEluc3RhbmNlXG5cbmZ1bmN0aW9uIGdldEluc3RhbmNlVGltaW5ncyhhbmltYXRpb25zLCB0d2VlblNldHRpbmdzKSB7XG4gIHZhciBhbmltTGVuZ3RoID0gYW5pbWF0aW9ucy5sZW5ndGg7XG4gIHZhciBnZXRUbE9mZnNldCA9IGZ1bmN0aW9uIChhbmltKSB7IHJldHVybiBhbmltLnRpbWVsaW5lT2Zmc2V0ID8gYW5pbS50aW1lbGluZU9mZnNldCA6IDA7IH07XG4gIHZhciB0aW1pbmdzID0ge307XG4gIHRpbWluZ3MuZHVyYXRpb24gPSBhbmltTGVuZ3RoID8gTWF0aC5tYXguYXBwbHkoTWF0aCwgYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGdldFRsT2Zmc2V0KGFuaW0pICsgYW5pbS5kdXJhdGlvbjsgfSkpIDogdHdlZW5TZXR0aW5ncy5kdXJhdGlvbjtcbiAgdGltaW5ncy5kZWxheSA9IGFuaW1MZW5ndGggPyBNYXRoLm1pbi5hcHBseShNYXRoLCBhbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gZ2V0VGxPZmZzZXQoYW5pbSkgKyBhbmltLmRlbGF5OyB9KSkgOiB0d2VlblNldHRpbmdzLmRlbGF5O1xuICB0aW1pbmdzLmVuZERlbGF5ID0gYW5pbUxlbmd0aCA/IHRpbWluZ3MuZHVyYXRpb24gLSBNYXRoLm1heC5hcHBseShNYXRoLCBhbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gZ2V0VGxPZmZzZXQoYW5pbSkgKyBhbmltLmR1cmF0aW9uIC0gYW5pbS5lbmREZWxheTsgfSkpIDogdHdlZW5TZXR0aW5ncy5lbmREZWxheTtcbiAgcmV0dXJuIHRpbWluZ3M7XG59XG5cbnZhciBpbnN0YW5jZUlEID0gMDtcblxuZnVuY3Rpb24gY3JlYXRlTmV3SW5zdGFuY2UocGFyYW1zKSB7XG4gIHZhciBpbnN0YW5jZVNldHRpbmdzID0gcmVwbGFjZU9iamVjdFByb3BzKGRlZmF1bHRJbnN0YW5jZVNldHRpbmdzLCBwYXJhbXMpO1xuICB2YXIgdHdlZW5TZXR0aW5ncyA9IHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0VHdlZW5TZXR0aW5ncywgcGFyYW1zKTtcbiAgdmFyIHByb3BlcnRpZXMgPSBnZXRQcm9wZXJ0aWVzKHR3ZWVuU2V0dGluZ3MsIHBhcmFtcyk7XG4gIHZhciBhbmltYXRhYmxlcyA9IGdldEFuaW1hdGFibGVzKHBhcmFtcy50YXJnZXRzKTtcbiAgdmFyIGFuaW1hdGlvbnMgPSBnZXRBbmltYXRpb25zKGFuaW1hdGFibGVzLCBwcm9wZXJ0aWVzKTtcbiAgdmFyIHRpbWluZ3MgPSBnZXRJbnN0YW5jZVRpbWluZ3MoYW5pbWF0aW9ucywgdHdlZW5TZXR0aW5ncyk7XG4gIHZhciBpZCA9IGluc3RhbmNlSUQ7XG4gIGluc3RhbmNlSUQrKztcbiAgcmV0dXJuIG1lcmdlT2JqZWN0cyhpbnN0YW5jZVNldHRpbmdzLCB7XG4gICAgaWQ6IGlkLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBhbmltYXRhYmxlczogYW5pbWF0YWJsZXMsXG4gICAgYW5pbWF0aW9uczogYW5pbWF0aW9ucyxcbiAgICBkdXJhdGlvbjogdGltaW5ncy5kdXJhdGlvbixcbiAgICBkZWxheTogdGltaW5ncy5kZWxheSxcbiAgICBlbmREZWxheTogdGltaW5ncy5lbmREZWxheVxuICB9KTtcbn1cblxuLy8gQ29yZVxuXG52YXIgYWN0aXZlSW5zdGFuY2VzID0gW107XG52YXIgcGF1c2VkSW5zdGFuY2VzID0gW107XG52YXIgcmFmO1xuXG52YXIgZW5naW5lID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gcGxheSgpIHsgXG4gICAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICB9XG4gIGZ1bmN0aW9uIHN0ZXAodCkge1xuICAgIHZhciBhY3RpdmVJbnN0YW5jZXNMZW5ndGggPSBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoO1xuICAgIGlmIChhY3RpdmVJbnN0YW5jZXNMZW5ndGgpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgYWN0aXZlSW5zdGFuY2VzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlc1tpXTtcbiAgICAgICAgaWYgKCFhY3RpdmVJbnN0YW5jZS5wYXVzZWQpIHtcbiAgICAgICAgICBhY3RpdmVJbnN0YW5jZS50aWNrKHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpbnN0YW5jZUluZGV4ID0gYWN0aXZlSW5zdGFuY2VzLmluZGV4T2YoYWN0aXZlSW5zdGFuY2UpO1xuICAgICAgICAgIGlmIChpbnN0YW5jZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGFjdGl2ZUluc3RhbmNlcy5zcGxpY2UoaW5zdGFuY2VJbmRleCwgMSk7XG4gICAgICAgICAgICBhY3RpdmVJbnN0YW5jZXNMZW5ndGggPSBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBwbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhZiA9IGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG4gICAgfVxuICB9XG4gIHJldHVybiBwbGF5O1xufSkoKTtcblxuZnVuY3Rpb24gaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgIGFjdGl2ZUluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnMpIHsgcmV0dXJuIGlucy5wYXVzZSgpOyB9KTtcbiAgICBwYXVzZWRJbnN0YW5jZXMgPSBhY3RpdmVJbnN0YW5jZXMuc2xpY2UoMCk7XG4gICAgYWN0aXZlSW5zdGFuY2VzID0gW107XG4gIH0gZWxzZSB7XG4gICAgcGF1c2VkSW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGlucykgeyByZXR1cm4gaW5zLnBsYXkoKTsgfSk7XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xufVxuXG4vLyBQdWJsaWMgSW5zdGFuY2VcblxuZnVuY3Rpb24gYW5pbWUocGFyYW1zKSB7XG4gIGlmICggcGFyYW1zID09PSB2b2lkIDAgKSBwYXJhbXMgPSB7fTtcblxuXG4gIHZhciBzdGFydFRpbWUgPSAwLCBsYXN0VGltZSA9IDAsIG5vdyA9IDA7XG4gIHZhciBjaGlsZHJlbiwgY2hpbGRyZW5MZW5ndGggPSAwO1xuICB2YXIgcmVzb2x2ZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbWFrZVByb21pc2UoaW5zdGFuY2UpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHdpbmRvdy5Qcm9taXNlICYmIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChfcmVzb2x2ZSkgeyByZXR1cm4gcmVzb2x2ZSA9IF9yZXNvbHZlOyB9KTtcbiAgICBpbnN0YW5jZS5maW5pc2hlZCA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVOZXdJbnN0YW5jZShwYXJhbXMpO1xuICB2YXIgcHJvbWlzZSA9IG1ha2VQcm9taXNlKGluc3RhbmNlKTtcblxuICBmdW5jdGlvbiB0b2dnbGVJbnN0YW5jZURpcmVjdGlvbigpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gaW5zdGFuY2UuZGlyZWN0aW9uO1xuICAgIGlmIChkaXJlY3Rpb24gIT09ICdhbHRlcm5hdGUnKSB7XG4gICAgICBpbnN0YW5jZS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24gIT09ICdub3JtYWwnID8gJ25vcm1hbCcgOiAncmV2ZXJzZSc7XG4gICAgfVxuICAgIGluc3RhbmNlLnJldmVyc2VkID0gIWluc3RhbmNlLnJldmVyc2VkO1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5yZXZlcnNlZCA9IGluc3RhbmNlLnJldmVyc2VkOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkanVzdFRpbWUodGltZSkge1xuICAgIHJldHVybiBpbnN0YW5jZS5yZXZlcnNlZCA/IGluc3RhbmNlLmR1cmF0aW9uIC0gdGltZSA6IHRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRpbWUoKSB7XG4gICAgc3RhcnRUaW1lID0gMDtcbiAgICBsYXN0VGltZSA9IGFkanVzdFRpbWUoaW5zdGFuY2UuY3VycmVudFRpbWUpICogKDEgLyBhbmltZS5zcGVlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWVrQ2lsZCh0aW1lLCBjaGlsZCkge1xuICAgIGlmIChjaGlsZCkgeyBjaGlsZC5zZWVrKHRpbWUgLSBjaGlsZC50aW1lbGluZU9mZnNldCk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN5bmNJbnN0YW5jZUNoaWxkcmVuKHRpbWUpIHtcbiAgICBpZiAoIWluc3RhbmNlLnJldmVyc2VQbGF5YmFjaykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7IHNlZWtDaWxkKHRpbWUsIGNoaWxkcmVuW2ldKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSBjaGlsZHJlbkxlbmd0aDsgaSQxLS07KSB7IHNlZWtDaWxkKHRpbWUsIGNoaWxkcmVuW2kkMV0pOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc1RpbWUpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFuaW1hdGlvbnMgPSBpbnN0YW5jZS5hbmltYXRpb25zO1xuICAgIHZhciBhbmltYXRpb25zTGVuZ3RoID0gYW5pbWF0aW9ucy5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBhbmltYXRpb25zTGVuZ3RoKSB7XG4gICAgICB2YXIgYW5pbSA9IGFuaW1hdGlvbnNbaV07XG4gICAgICB2YXIgYW5pbWF0YWJsZSA9IGFuaW0uYW5pbWF0YWJsZTtcbiAgICAgIHZhciB0d2VlbnMgPSBhbmltLnR3ZWVucztcbiAgICAgIHZhciB0d2Vlbkxlbmd0aCA9IHR3ZWVucy5sZW5ndGggLSAxO1xuICAgICAgdmFyIHR3ZWVuID0gdHdlZW5zW3R3ZWVuTGVuZ3RoXTtcbiAgICAgIC8vIE9ubHkgY2hlY2sgZm9yIGtleWZyYW1lcyBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHR3ZWVuXG4gICAgICBpZiAodHdlZW5MZW5ndGgpIHsgdHdlZW4gPSBmaWx0ZXJBcnJheSh0d2VlbnMsIGZ1bmN0aW9uICh0KSB7IHJldHVybiAoaW5zVGltZSA8IHQuZW5kKTsgfSlbMF0gfHwgdHdlZW47IH1cbiAgICAgIHZhciBlbGFwc2VkID0gbWluTWF4KGluc1RpbWUgLSB0d2Vlbi5zdGFydCAtIHR3ZWVuLmRlbGF5LCAwLCB0d2Vlbi5kdXJhdGlvbikgLyB0d2Vlbi5kdXJhdGlvbjtcbiAgICAgIHZhciBlYXNlZCA9IGlzTmFOKGVsYXBzZWQpID8gMSA6IHR3ZWVuLmVhc2luZyhlbGFwc2VkKTtcbiAgICAgIHZhciBzdHJpbmdzID0gdHdlZW4udG8uc3RyaW5ncztcbiAgICAgIHZhciByb3VuZCA9IHR3ZWVuLnJvdW5kO1xuICAgICAgdmFyIG51bWJlcnMgPSBbXTtcbiAgICAgIHZhciB0b051bWJlcnNMZW5ndGggPSB0d2Vlbi50by5udW1iZXJzLmxlbmd0aDtcbiAgICAgIHZhciBwcm9ncmVzcyA9ICh2b2lkIDApO1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0b051bWJlcnNMZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgdmFsdWUgPSAodm9pZCAwKTtcbiAgICAgICAgdmFyIHRvTnVtYmVyID0gdHdlZW4udG8ubnVtYmVyc1tuXTtcbiAgICAgICAgdmFyIGZyb21OdW1iZXIgPSB0d2Vlbi5mcm9tLm51bWJlcnNbbl0gfHwgMDtcbiAgICAgICAgaWYgKCF0d2Vlbi5pc1BhdGgpIHtcbiAgICAgICAgICB2YWx1ZSA9IGZyb21OdW1iZXIgKyAoZWFzZWQgKiAodG9OdW1iZXIgLSBmcm9tTnVtYmVyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBnZXRQYXRoUHJvZ3Jlc3ModHdlZW4udmFsdWUsIGVhc2VkICogdG9OdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3VuZCkge1xuICAgICAgICAgIGlmICghKHR3ZWVuLmlzQ29sb3IgJiYgbiA+IDIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiByb3VuZCkgLyByb3VuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbnVtYmVycy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIE1hbnVhbCBBcnJheS5yZWR1Y2UgZm9yIGJldHRlciBwZXJmb3JtYW5jZXNcbiAgICAgIHZhciBzdHJpbmdzTGVuZ3RoID0gc3RyaW5ncy5sZW5ndGg7XG4gICAgICBpZiAoIXN0cmluZ3NMZW5ndGgpIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSBudW1iZXJzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSBzdHJpbmdzWzBdO1xuICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHN0cmluZ3NMZW5ndGg7IHMrKykge1xuICAgICAgICAgIHZhciBhID0gc3RyaW5nc1tzXTtcbiAgICAgICAgICB2YXIgYiA9IHN0cmluZ3NbcyArIDFdO1xuICAgICAgICAgIHZhciBuJDEgPSBudW1iZXJzW3NdO1xuICAgICAgICAgIGlmICghaXNOYU4obiQxKSkge1xuICAgICAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAgIHByb2dyZXNzICs9IG4kMSArICcgJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByb2dyZXNzICs9IG4kMSArIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRQcm9ncmVzc1ZhbHVlW2FuaW0udHlwZV0oYW5pbWF0YWJsZS50YXJnZXQsIGFuaW0ucHJvcGVydHksIHByb2dyZXNzLCBhbmltYXRhYmxlLnRyYW5zZm9ybXMpO1xuICAgICAgYW5pbS5jdXJyZW50VmFsdWUgPSBwcm9ncmVzcztcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDYWxsYmFjayhjYikge1xuICAgIGlmIChpbnN0YW5jZVtjYl0gJiYgIWluc3RhbmNlLnBhc3NUaHJvdWdoKSB7IGluc3RhbmNlW2NiXShpbnN0YW5jZSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvdW50SXRlcmF0aW9uKCkge1xuICAgIGlmIChpbnN0YW5jZS5yZW1haW5pbmcgJiYgaW5zdGFuY2UucmVtYWluaW5nICE9PSB0cnVlKSB7XG4gICAgICBpbnN0YW5jZS5yZW1haW5pbmctLTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRJbnN0YW5jZVByb2dyZXNzKGVuZ2luZVRpbWUpIHtcbiAgICB2YXIgaW5zRHVyYXRpb24gPSBpbnN0YW5jZS5kdXJhdGlvbjtcbiAgICB2YXIgaW5zRGVsYXkgPSBpbnN0YW5jZS5kZWxheTtcbiAgICB2YXIgaW5zRW5kRGVsYXkgPSBpbnNEdXJhdGlvbiAtIGluc3RhbmNlLmVuZERlbGF5O1xuICAgIHZhciBpbnNUaW1lID0gYWRqdXN0VGltZShlbmdpbmVUaW1lKTtcbiAgICBpbnN0YW5jZS5wcm9ncmVzcyA9IG1pbk1heCgoaW5zVGltZSAvIGluc0R1cmF0aW9uKSAqIDEwMCwgMCwgMTAwKTtcbiAgICBpbnN0YW5jZS5yZXZlcnNlUGxheWJhY2sgPSBpbnNUaW1lIDwgaW5zdGFuY2UuY3VycmVudFRpbWU7XG4gICAgaWYgKGNoaWxkcmVuKSB7IHN5bmNJbnN0YW5jZUNoaWxkcmVuKGluc1RpbWUpOyB9XG4gICAgaWYgKCFpbnN0YW5jZS5iZWdhbiAmJiBpbnN0YW5jZS5jdXJyZW50VGltZSA+IDApIHtcbiAgICAgIGluc3RhbmNlLmJlZ2FuID0gdHJ1ZTtcbiAgICAgIHNldENhbGxiYWNrKCdiZWdpbicpO1xuICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BCZWdpbicpO1xuICAgIH1cbiAgICBpZiAoaW5zVGltZSA8PSBpbnNEZWxheSAmJiBpbnN0YW5jZS5jdXJyZW50VGltZSAhPT0gMCkge1xuICAgICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKDApO1xuICAgIH1cbiAgICBpZiAoKGluc1RpbWUgPj0gaW5zRW5kRGVsYXkgJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgIT09IGluc0R1cmF0aW9uKSB8fCAhaW5zRHVyYXRpb24pIHtcbiAgICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcyhpbnNEdXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChpbnNUaW1lID4gaW5zRGVsYXkgJiYgaW5zVGltZSA8IGluc0VuZERlbGF5KSB7XG4gICAgICBpZiAoIWluc3RhbmNlLmNoYW5nZUJlZ2FuKSB7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUJlZ2FuID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHNldENhbGxiYWNrKCdjaGFuZ2VCZWdpbicpO1xuICAgICAgfVxuICAgICAgc2V0Q2FsbGJhY2soJ2NoYW5nZScpO1xuICAgICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc1RpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5zdGFuY2UuY2hhbmdlQmVnYW4pIHtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQmVnYW4gPSBmYWxzZTtcbiAgICAgICAgc2V0Q2FsbGJhY2soJ2NoYW5nZUNvbXBsZXRlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLmN1cnJlbnRUaW1lID0gbWluTWF4KGluc1RpbWUsIDAsIGluc0R1cmF0aW9uKTtcbiAgICBpZiAoaW5zdGFuY2UuYmVnYW4pIHsgc2V0Q2FsbGJhY2soJ3VwZGF0ZScpOyB9XG4gICAgaWYgKGVuZ2luZVRpbWUgPj0gaW5zRHVyYXRpb24pIHtcbiAgICAgIGxhc3RUaW1lID0gMDtcbiAgICAgIGNvdW50SXRlcmF0aW9uKCk7XG4gICAgICBpZiAoaW5zdGFuY2UucmVtYWluaW5nKSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IG5vdztcbiAgICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BDb21wbGV0ZScpO1xuICAgICAgICBzZXRDYWxsYmFjaygnbG9vcEJlZ2luJyk7XG4gICAgICAgIGlmIChpbnN0YW5jZS5kaXJlY3Rpb24gPT09ICdhbHRlcm5hdGUnKSB7IHRvZ2dsZUluc3RhbmNlRGlyZWN0aW9uKCk7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLnBhdXNlZCA9IHRydWU7XG4gICAgICAgIGlmICghaW5zdGFuY2UuY29tcGxldGVkKSB7XG4gICAgICAgICAgaW5zdGFuY2UuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDYWxsYmFjaygnbG9vcENvbXBsZXRlJyk7XG4gICAgICAgICAgc2V0Q2FsbGJhY2soJ2NvbXBsZXRlJyk7XG4gICAgICAgICAgaWYgKCFpbnN0YW5jZS5wYXNzVGhyb3VnaCAmJiAnUHJvbWlzZScgaW4gd2luZG93KSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICBwcm9taXNlID0gbWFrZVByb21pc2UoaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluc3RhbmNlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGluc3RhbmNlLmRpcmVjdGlvbjtcbiAgICBpbnN0YW5jZS5wYXNzVGhyb3VnaCA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmN1cnJlbnRUaW1lID0gMDtcbiAgICBpbnN0YW5jZS5wcm9ncmVzcyA9IDA7XG4gICAgaW5zdGFuY2UucGF1c2VkID0gdHJ1ZTtcbiAgICBpbnN0YW5jZS5iZWdhbiA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmNoYW5nZUJlZ2FuID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY29tcGxldGVkID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gZmFsc2U7XG4gICAgaW5zdGFuY2UucmV2ZXJzZVBsYXliYWNrID0gZmFsc2U7XG4gICAgaW5zdGFuY2UucmV2ZXJzZWQgPSBkaXJlY3Rpb24gPT09ICdyZXZlcnNlJztcbiAgICBpbnN0YW5jZS5yZW1haW5pbmcgPSBpbnN0YW5jZS5sb29wO1xuICAgIGNoaWxkcmVuID0gaW5zdGFuY2UuY2hpbGRyZW47XG4gICAgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuTGVuZ3RoOyBpLS07KSB7IGluc3RhbmNlLmNoaWxkcmVuW2ldLnJlc2V0KCk7IH1cbiAgICBpZiAoaW5zdGFuY2UucmV2ZXJzZWQgJiYgaW5zdGFuY2UubG9vcCAhPT0gdHJ1ZSB8fCAoZGlyZWN0aW9uID09PSAnYWx0ZXJuYXRlJyAmJiBpbnN0YW5jZS5sb29wID09PSAxKSkgeyBpbnN0YW5jZS5yZW1haW5pbmcrKzsgfVxuICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcygwKTtcbiAgfTtcblxuICAvLyBTZXQgVmFsdWUgaGVscGVyXG5cbiAgaW5zdGFuY2Uuc2V0ID0gZnVuY3Rpb24odGFyZ2V0cywgcHJvcGVydGllcykge1xuICAgIHNldFRhcmdldHNWYWx1ZSh0YXJnZXRzLCBwcm9wZXJ0aWVzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgaW5zdGFuY2UudGljayA9IGZ1bmN0aW9uKHQpIHtcbiAgICBub3cgPSB0O1xuICAgIGlmICghc3RhcnRUaW1lKSB7IHN0YXJ0VGltZSA9IG5vdzsgfVxuICAgIHNldEluc3RhbmNlUHJvZ3Jlc3MoKG5vdyArIChsYXN0VGltZSAtIHN0YXJ0VGltZSkpICogYW5pbWUuc3BlZWQpO1xuICB9O1xuXG4gIGluc3RhbmNlLnNlZWsgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgc2V0SW5zdGFuY2VQcm9ncmVzcyhhZGp1c3RUaW1lKHRpbWUpKTtcbiAgfTtcblxuICBpbnN0YW5jZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIGluc3RhbmNlLnBhdXNlZCA9IHRydWU7XG4gICAgcmVzZXRUaW1lKCk7XG4gIH07XG5cbiAgaW5zdGFuY2UucGxheSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghaW5zdGFuY2UucGF1c2VkKSB7IHJldHVybjsgfVxuICAgIGlmIChpbnN0YW5jZS5jb21wbGV0ZWQpIHsgaW5zdGFuY2UucmVzZXQoKTsgfVxuICAgIGluc3RhbmNlLnBhdXNlZCA9IGZhbHNlO1xuICAgIGFjdGl2ZUluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcbiAgICByZXNldFRpbWUoKTtcbiAgICBpZiAoIXJhZikgeyBlbmdpbmUoKTsgfVxuICB9O1xuXG4gIGluc3RhbmNlLnJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgICB0b2dnbGVJbnN0YW5jZURpcmVjdGlvbigpO1xuICAgIHJlc2V0VGltZSgpO1xuICB9O1xuXG4gIGluc3RhbmNlLnJlc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpbnN0YW5jZS5yZXNldCgpO1xuICAgIGluc3RhbmNlLnBsYXkoKTtcbiAgfTtcblxuICBpbnN0YW5jZS5yZXNldCgpO1xuXG4gIGlmIChpbnN0YW5jZS5hdXRvcGxheSkgeyBpbnN0YW5jZS5wbGF5KCk7IH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG5cbn1cblxuLy8gUmVtb3ZlIHRhcmdldHMgZnJvbSBhbmltYXRpb25cblxuZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0c0Zyb21BbmltYXRpb25zKHRhcmdldHNBcnJheSwgYW5pbWF0aW9ucykge1xuICBmb3IgKHZhciBhID0gYW5pbWF0aW9ucy5sZW5ndGg7IGEtLTspIHtcbiAgICBpZiAoYXJyYXlDb250YWlucyh0YXJnZXRzQXJyYXksIGFuaW1hdGlvbnNbYV0uYW5pbWF0YWJsZS50YXJnZXQpKSB7XG4gICAgICBhbmltYXRpb25zLnNwbGljZShhLCAxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0cyh0YXJnZXRzKSB7XG4gIHZhciB0YXJnZXRzQXJyYXkgPSBwYXJzZVRhcmdldHModGFyZ2V0cyk7XG4gIGZvciAodmFyIGkgPSBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgdmFyIGluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2VzW2ldO1xuICAgIHZhciBhbmltYXRpb25zID0gaW5zdGFuY2UuYW5pbWF0aW9ucztcbiAgICB2YXIgY2hpbGRyZW4gPSBpbnN0YW5jZS5jaGlsZHJlbjtcbiAgICByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbnModGFyZ2V0c0FycmF5LCBhbmltYXRpb25zKTtcbiAgICBmb3IgKHZhciBjID0gY2hpbGRyZW4ubGVuZ3RoOyBjLS07KSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltjXTtcbiAgICAgIHZhciBjaGlsZEFuaW1hdGlvbnMgPSBjaGlsZC5hbmltYXRpb25zO1xuICAgICAgcmVtb3ZlVGFyZ2V0c0Zyb21BbmltYXRpb25zKHRhcmdldHNBcnJheSwgY2hpbGRBbmltYXRpb25zKTtcbiAgICAgIGlmICghY2hpbGRBbmltYXRpb25zLmxlbmd0aCAmJiAhY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7IGNoaWxkcmVuLnNwbGljZShjLCAxKTsgfVxuICAgIH1cbiAgICBpZiAoIWFuaW1hdGlvbnMubGVuZ3RoICYmICFjaGlsZHJlbi5sZW5ndGgpIHsgaW5zdGFuY2UucGF1c2UoKTsgfVxuICB9XG59XG5cbi8vIFN0YWdnZXIgaGVscGVyc1xuXG5mdW5jdGlvbiBzdGFnZ2VyKHZhbCwgcGFyYW1zKSB7XG4gIGlmICggcGFyYW1zID09PSB2b2lkIDAgKSBwYXJhbXMgPSB7fTtcblxuICB2YXIgZGlyZWN0aW9uID0gcGFyYW1zLmRpcmVjdGlvbiB8fCAnbm9ybWFsJztcbiAgdmFyIGVhc2luZyA9IHBhcmFtcy5lYXNpbmcgPyBwYXJzZUVhc2luZ3MocGFyYW1zLmVhc2luZykgOiBudWxsO1xuICB2YXIgZ3JpZCA9IHBhcmFtcy5ncmlkO1xuICB2YXIgYXhpcyA9IHBhcmFtcy5heGlzO1xuICB2YXIgZnJvbUluZGV4ID0gcGFyYW1zLmZyb20gfHwgMDtcbiAgdmFyIGZyb21GaXJzdCA9IGZyb21JbmRleCA9PT0gJ2ZpcnN0JztcbiAgdmFyIGZyb21DZW50ZXIgPSBmcm9tSW5kZXggPT09ICdjZW50ZXInO1xuICB2YXIgZnJvbUxhc3QgPSBmcm9tSW5kZXggPT09ICdsYXN0JztcbiAgdmFyIGlzUmFuZ2UgPSBpcy5hcnIodmFsKTtcbiAgdmFyIHZhbDEgPSBpc1JhbmdlID8gcGFyc2VGbG9hdCh2YWxbMF0pIDogcGFyc2VGbG9hdCh2YWwpO1xuICB2YXIgdmFsMiA9IGlzUmFuZ2UgPyBwYXJzZUZsb2F0KHZhbFsxXSkgOiAwO1xuICB2YXIgdW5pdCA9IGdldFVuaXQoaXNSYW5nZSA/IHZhbFsxXSA6IHZhbCkgfHwgMDtcbiAgdmFyIHN0YXJ0ID0gcGFyYW1zLnN0YXJ0IHx8IDAgKyAoaXNSYW5nZSA/IHZhbDEgOiAwKTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgbWF4VmFsdWUgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKGVsLCBpLCB0KSB7XG4gICAgaWYgKGZyb21GaXJzdCkgeyBmcm9tSW5kZXggPSAwOyB9XG4gICAgaWYgKGZyb21DZW50ZXIpIHsgZnJvbUluZGV4ID0gKHQgLSAxKSAvIDI7IH1cbiAgICBpZiAoZnJvbUxhc3QpIHsgZnJvbUluZGV4ID0gdCAtIDE7IH1cbiAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0OyBpbmRleCsrKSB7XG4gICAgICAgIGlmICghZ3JpZCkge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKE1hdGguYWJzKGZyb21JbmRleCAtIGluZGV4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZyb21YID0gIWZyb21DZW50ZXIgPyBmcm9tSW5kZXglZ3JpZFswXSA6IChncmlkWzBdLTEpLzI7XG4gICAgICAgICAgdmFyIGZyb21ZID0gIWZyb21DZW50ZXIgPyBNYXRoLmZsb29yKGZyb21JbmRleC9ncmlkWzBdKSA6IChncmlkWzFdLTEpLzI7XG4gICAgICAgICAgdmFyIHRvWCA9IGluZGV4JWdyaWRbMF07XG4gICAgICAgICAgdmFyIHRvWSA9IE1hdGguZmxvb3IoaW5kZXgvZ3JpZFswXSk7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlWCA9IGZyb21YIC0gdG9YO1xuICAgICAgICAgIHZhciBkaXN0YW5jZVkgPSBmcm9tWSAtIHRvWTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBNYXRoLnNxcnQoZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZKTtcbiAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnKSB7IHZhbHVlID0gLWRpc3RhbmNlWDsgfVxuICAgICAgICAgIGlmIChheGlzID09PSAneScpIHsgdmFsdWUgPSAtZGlzdGFuY2VZOyB9XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG1heFZhbHVlID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChlYXNpbmcpIHsgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBlYXNpbmcodmFsIC8gbWF4VmFsdWUpICogbWF4VmFsdWU7IH0pOyB9XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAncmV2ZXJzZScpIHsgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBheGlzID8gKHZhbCA8IDApID8gdmFsICogLTEgOiAtdmFsIDogTWF0aC5hYnMobWF4VmFsdWUgLSB2YWwpOyB9KTsgfVxuICAgIH1cbiAgICB2YXIgc3BhY2luZyA9IGlzUmFuZ2UgPyAodmFsMiAtIHZhbDEpIC8gbWF4VmFsdWUgOiB2YWwxO1xuICAgIHJldHVybiBzdGFydCArIChzcGFjaW5nICogKE1hdGgucm91bmQodmFsdWVzW2ldICogMTAwKSAvIDEwMCkpICsgdW5pdDtcbiAgfVxufVxuXG4vLyBUaW1lbGluZVxuXG5mdW5jdGlvbiB0aW1lbGluZShwYXJhbXMpIHtcbiAgaWYgKCBwYXJhbXMgPT09IHZvaWQgMCApIHBhcmFtcyA9IHt9O1xuXG4gIHZhciB0bCA9IGFuaW1lKHBhcmFtcyk7XG4gIHRsLmR1cmF0aW9uID0gMDtcbiAgdGwuYWRkID0gZnVuY3Rpb24oaW5zdGFuY2VQYXJhbXMsIHRpbWVsaW5lT2Zmc2V0KSB7XG4gICAgdmFyIHRsSW5kZXggPSBhY3RpdmVJbnN0YW5jZXMuaW5kZXhPZih0bCk7XG4gICAgdmFyIGNoaWxkcmVuID0gdGwuY2hpbGRyZW47XG4gICAgaWYgKHRsSW5kZXggPiAtMSkgeyBhY3RpdmVJbnN0YW5jZXMuc3BsaWNlKHRsSW5kZXgsIDEpOyB9XG4gICAgZnVuY3Rpb24gcGFzc1Rocm91Z2goaW5zKSB7IGlucy5wYXNzVGhyb3VnaCA9IHRydWU7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7IHBhc3NUaHJvdWdoKGNoaWxkcmVuW2ldKTsgfVxuICAgIHZhciBpbnNQYXJhbXMgPSBtZXJnZU9iamVjdHMoaW5zdGFuY2VQYXJhbXMsIHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0VHdlZW5TZXR0aW5ncywgcGFyYW1zKSk7XG4gICAgaW5zUGFyYW1zLnRhcmdldHMgPSBpbnNQYXJhbXMudGFyZ2V0cyB8fCBwYXJhbXMudGFyZ2V0cztcbiAgICB2YXIgdGxEdXJhdGlvbiA9IHRsLmR1cmF0aW9uO1xuICAgIGluc1BhcmFtcy5hdXRvcGxheSA9IGZhbHNlO1xuICAgIGluc1BhcmFtcy5kaXJlY3Rpb24gPSB0bC5kaXJlY3Rpb247XG4gICAgaW5zUGFyYW1zLnRpbWVsaW5lT2Zmc2V0ID0gaXMudW5kKHRpbWVsaW5lT2Zmc2V0KSA/IHRsRHVyYXRpb24gOiBnZXRSZWxhdGl2ZVZhbHVlKHRpbWVsaW5lT2Zmc2V0LCB0bER1cmF0aW9uKTtcbiAgICBwYXNzVGhyb3VnaCh0bCk7XG4gICAgdGwuc2VlayhpbnNQYXJhbXMudGltZWxpbmVPZmZzZXQpO1xuICAgIHZhciBpbnMgPSBhbmltZShpbnNQYXJhbXMpO1xuICAgIHBhc3NUaHJvdWdoKGlucyk7XG4gICAgY2hpbGRyZW4ucHVzaChpbnMpO1xuICAgIHZhciB0aW1pbmdzID0gZ2V0SW5zdGFuY2VUaW1pbmdzKGNoaWxkcmVuLCBwYXJhbXMpO1xuICAgIHRsLmRlbGF5ID0gdGltaW5ncy5kZWxheTtcbiAgICB0bC5lbmREZWxheSA9IHRpbWluZ3MuZW5kRGVsYXk7XG4gICAgdGwuZHVyYXRpb24gPSB0aW1pbmdzLmR1cmF0aW9uO1xuICAgIHRsLnNlZWsoMCk7XG4gICAgdGwucmVzZXQoKTtcbiAgICBpZiAodGwuYXV0b3BsYXkpIHsgdGwucGxheSgpOyB9XG4gICAgcmV0dXJuIHRsO1xuICB9O1xuICByZXR1cm4gdGw7XG59XG5cbmFuaW1lLnZlcnNpb24gPSAnMy4wLjEnO1xuYW5pbWUuc3BlZWQgPSAxO1xuYW5pbWUucnVubmluZyA9IGFjdGl2ZUluc3RhbmNlcztcbmFuaW1lLnJlbW92ZSA9IHJlbW92ZVRhcmdldHM7XG5hbmltZS5nZXQgPSBnZXRPcmlnaW5hbFRhcmdldFZhbHVlO1xuYW5pbWUuc2V0ID0gc2V0VGFyZ2V0c1ZhbHVlO1xuYW5pbWUuY29udmVydFB4ID0gY29udmVydFB4VG9Vbml0O1xuYW5pbWUucGF0aCA9IGdldFBhdGg7XG5hbmltZS5zZXREYXNob2Zmc2V0ID0gc2V0RGFzaG9mZnNldDtcbmFuaW1lLnN0YWdnZXIgPSBzdGFnZ2VyO1xuYW5pbWUudGltZWxpbmUgPSB0aW1lbGluZTtcbmFuaW1lLmVhc2luZyA9IHBhcnNlRWFzaW5ncztcbmFuaW1lLnBlbm5lciA9IHBlbm5lcjtcbmFuaW1lLnJhbmRvbSA9IGZ1bmN0aW9uIChtaW4sIG1heCkgeyByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjsgfTtcblxuZXhwb3J0IGRlZmF1bHQgYW5pbWU7XG4iLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSB1bmxlc3MgYW1kTW9kdWxlSWQgaXMgc2V0XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHJvb3RbJ0F1dG9saW5rZXInXSA9IGZhY3RvcnkoKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgLy8gbGlrZSBOb2RlLlxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHJvb3RbJ0F1dG9saW5rZXInXSA9IGZhY3RvcnkoKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbi8qIVxuICogQXV0b2xpbmtlci5qc1xuICogMC4xNS4zXG4gKlxuICogQ29weXJpZ2h0KGMpIDIwMTUgR3JlZ29yeSBKYWNvYnMgPGdyZWdAZ3JlZy1qYWNvYnMuY29tPlxuICogTUlUIExpY2Vuc2VkLiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVnamFjb2JzL0F1dG9saW5rZXIuanNcbiAqL1xuLyoqXG4gKiBAY2xhc3MgQXV0b2xpbmtlclxuICogQGV4dGVuZHMgT2JqZWN0XG4gKiBcbiAqIFV0aWxpdHkgY2xhc3MgdXNlZCB0byBwcm9jZXNzIGEgZ2l2ZW4gc3RyaW5nIG9mIHRleHQsIGFuZCB3cmFwIHRoZSBVUkxzLCBlbWFpbCBhZGRyZXNzZXMsIGFuZCBUd2l0dGVyIGhhbmRsZXMgaW4gXG4gKiB0aGUgYXBwcm9wcmlhdGUgYW5jaG9yICgmbHQ7YSZndDspIHRhZ3MgdG8gdHVybiB0aGVtIGludG8gbGlua3MuXG4gKiBcbiAqIEFueSBvZiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG1heSBiZSBwcm92aWRlZCBpbiBhbiBPYmplY3QgKG1hcCkgcHJvdmlkZWQgdG8gdGhlIEF1dG9saW5rZXIgY29uc3RydWN0b3IsIHdoaWNoXG4gKiB3aWxsIGNvbmZpZ3VyZSBob3cgdGhlIHtAbGluayAjbGluayBsaW5rKCl9IG1ldGhvZCB3aWxsIHByb2Nlc3MgdGhlIGxpbmtzLlxuICogXG4gKiBGb3IgZXhhbXBsZTpcbiAqIFxuICogICAgIHZhciBhdXRvbGlua2VyID0gbmV3IEF1dG9saW5rZXIoIHtcbiAqICAgICAgICAgbmV3V2luZG93IDogZmFsc2UsXG4gKiAgICAgICAgIHRydW5jYXRlICA6IDMwXG4gKiAgICAgfSApO1xuICogICAgIFxuICogICAgIHZhciBodG1sID0gYXV0b2xpbmtlci5saW5rKCBcIkpvZSB3ZW50IHRvIHd3dy55YWhvby5jb21cIiApO1xuICogICAgIC8vIHByb2R1Y2VzOiAnSm9lIHdlbnQgdG8gPGEgaHJlZj1cImh0dHA6Ly93d3cueWFob28uY29tXCI+eWFob28uY29tPC9hPidcbiAqIFxuICogXG4gKiBUaGUge0BsaW5rICNzdGF0aWMtbGluayBzdGF0aWMgbGluaygpfSBtZXRob2QgbWF5IGFsc28gYmUgdXNlZCB0byBpbmxpbmUgb3B0aW9ucyBpbnRvIGEgc2luZ2xlIGNhbGwsIHdoaWNoIG1heVxuICogYmUgbW9yZSBjb252ZW5pZW50IGZvciBvbmUtb2ZmIHVzZXMuIEZvciBleGFtcGxlOlxuICogXG4gKiAgICAgdmFyIGh0bWwgPSBBdXRvbGlua2VyLmxpbmsoIFwiSm9lIHdlbnQgdG8gd3d3LnlhaG9vLmNvbVwiLCB7XG4gKiAgICAgICAgIG5ld1dpbmRvdyA6IGZhbHNlLFxuICogICAgICAgICB0cnVuY2F0ZSAgOiAzMFxuICogICAgIH0gKTtcbiAqICAgICAvLyBwcm9kdWNlczogJ0pvZSB3ZW50IHRvIDxhIGhyZWY9XCJodHRwOi8vd3d3LnlhaG9vLmNvbVwiPnlhaG9vLmNvbTwvYT4nXG4gKiBcbiAqIFxuICogIyMgQ3VzdG9tIFJlcGxhY2VtZW50cyBvZiBMaW5rc1xuICogXG4gKiBJZiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGRvIG5vdCBwcm92aWRlIGVub3VnaCBmbGV4aWJpbGl0eSwgYSB7QGxpbmsgI3JlcGxhY2VGbn0gbWF5IGJlIHByb3ZpZGVkIHRvIGZ1bGx5IGN1c3RvbWl6ZVxuICogdGhlIG91dHB1dCBvZiBBdXRvbGlua2VyLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIGZvciBlYWNoIFVSTC9FbWFpbC9Ud2l0dGVyIGhhbmRsZSBtYXRjaCB0aGF0IGlzIGVuY291bnRlcmVkLlxuICogXG4gKiBGb3IgZXhhbXBsZTpcbiAqIFxuICogICAgIHZhciBpbnB1dCA9IFwiLi4uXCI7ICAvLyBzdHJpbmcgd2l0aCBVUkxzLCBFbWFpbCBBZGRyZXNzZXMsIGFuZCBUd2l0dGVyIEhhbmRsZXNcbiAqICAgICBcbiAqICAgICB2YXIgbGlua2VkVGV4dCA9IEF1dG9saW5rZXIubGluayggaW5wdXQsIHtcbiAqICAgICAgICAgcmVwbGFjZUZuIDogZnVuY3Rpb24oIGF1dG9saW5rZXIsIG1hdGNoICkge1xuICogICAgICAgICAgICAgY29uc29sZS5sb2coIFwiaHJlZiA9IFwiLCBtYXRjaC5nZXRBbmNob3JIcmVmKCkgKTtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcInRleHQgPSBcIiwgbWF0Y2guZ2V0QW5jaG9yVGV4dCgpICk7XG4gKiAgICAgICAgIFxuICogICAgICAgICAgICAgc3dpdGNoKCBtYXRjaC5nZXRUeXBlKCkgKSB7XG4gKiAgICAgICAgICAgICAgICAgY2FzZSAndXJsJyA6IFxuICogICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJ1cmw6IFwiLCBtYXRjaC5nZXRVcmwoKSApO1xuICogICAgICAgICAgICAgICAgICAgICBcbiAqICAgICAgICAgICAgICAgICAgICAgaWYoIG1hdGNoLmdldFVybCgpLmluZGV4T2YoICdteXNpdGUuY29tJyApID09PSAtMSApIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSBhdXRvbGlua2VyLmdldFRhZ0J1aWxkZXIoKS5idWlsZCggbWF0Y2ggKTsgIC8vIHJldHVybnMgYW4gYEF1dG9saW5rZXIuSHRtbFRhZ2AgaW5zdGFuY2UsIHdoaWNoIHByb3ZpZGVzIG11dGF0b3IgbWV0aG9kcyBmb3IgZWFzeSBjaGFuZ2VzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICB0YWcuc2V0QXR0ciggJ3JlbCcsICdub2ZvbGxvdycgKTtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHRhZy5hZGRDbGFzcyggJ2V4dGVybmFsLWxpbmsnICk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWc7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBcbiAqICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAgLy8gbGV0IEF1dG9saW5rZXIgcGVyZm9ybSBpdHMgbm9ybWFsIGFuY2hvciB0YWcgcmVwbGFjZW1lbnRcbiAqICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgICAgICBcbiAqICAgICAgICAgICAgICAgICBjYXNlICdlbWFpbCcgOlxuICogICAgICAgICAgICAgICAgICAgICB2YXIgZW1haWwgPSBtYXRjaC5nZXRFbWFpbCgpO1xuICogICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJlbWFpbDogXCIsIGVtYWlsICk7XG4gKiAgICAgICAgICAgICAgICAgICAgIFxuICogICAgICAgICAgICAgICAgICAgICBpZiggZW1haWwgPT09IFwibXlAb3duLmFkZHJlc3NcIiApIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgIC8vIGRvbid0IGF1dG8tbGluayB0aGlzIHBhcnRpY3VsYXIgZW1haWwgYWRkcmVzczsgbGVhdmUgYXMtaXNcbiAqICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgIC8vIG5vIHJldHVybiB2YWx1ZSB3aWxsIGhhdmUgQXV0b2xpbmtlciBwZXJmb3JtIGl0cyBub3JtYWwgYW5jaG9yIHRhZyByZXBsYWNlbWVudCAoc2FtZSBhcyByZXR1cm5pbmcgYHRydWVgKVxuICogICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgICAgICAgXG4gKiAgICAgICAgICAgICAgICAgY2FzZSAndHdpdHRlcicgOlxuICogICAgICAgICAgICAgICAgICAgICB2YXIgdHdpdHRlckhhbmRsZSA9IG1hdGNoLmdldFR3aXR0ZXJIYW5kbGUoKTtcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIHR3aXR0ZXJIYW5kbGUgKTtcbiAqICAgICAgICAgICAgICAgICAgICAgXG4gKiAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnPGEgaHJlZj1cImh0dHA6Ly9uZXdwbGFjZS50by5saW5rLnR3aXR0ZXIuaGFuZGxlcy50by9cIj4nICsgdHdpdHRlckhhbmRsZSArICc8L2E+JztcbiAqICAgICAgICAgICAgIH1cbiAqICAgICAgICAgfVxuICogICAgIH0gKTtcbiAqIFxuICogXG4gKiBUaGUgZnVuY3Rpb24gbWF5IHJldHVybiB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAqIFxuICogLSBgdHJ1ZWAgKEJvb2xlYW4pOiBBbGxvdyBBdXRvbGlua2VyIHRvIHJlcGxhY2UgdGhlIG1hdGNoIGFzIGl0IG5vcm1hbGx5IHdvdWxkLlxuICogLSBgZmFsc2VgIChCb29sZWFuKTogRG8gbm90IHJlcGxhY2UgdGhlIGN1cnJlbnQgbWF0Y2ggYXQgYWxsIC0gbGVhdmUgYXMtaXMuXG4gKiAtIEFueSBTdHJpbmc6IElmIGEgc3RyaW5nIGlzIHJldHVybmVkIGZyb20gdGhlIGZ1bmN0aW9uLCB0aGUgc3RyaW5nIHdpbGwgYmUgdXNlZCBkaXJlY3RseSBhcyB0aGUgcmVwbGFjZW1lbnQgSFRNTCBmb3JcbiAqICAgdGhlIG1hdGNoLlxuICogLSBBbiB7QGxpbmsgQXV0b2xpbmtlci5IdG1sVGFnfSBpbnN0YW5jZSwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gYnVpbGQvbW9kaWZ5IGFuIEhUTUwgdGFnIGJlZm9yZSB3cml0aW5nIG91dCBpdHMgSFRNTCB0ZXh0LlxuICogXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgQXV0b2xpbmtlciBpbnN0YW5jZSwgc3BlY2lmaWVkIGluIGFuIE9iamVjdCAobWFwKS5cbiAqL1xudmFyIEF1dG9saW5rZXIgPSBmdW5jdGlvbiggY2ZnICkge1xuXHRBdXRvbGlua2VyLlV0aWwuYXNzaWduKCB0aGlzLCBjZmcgKTsgIC8vIGFzc2lnbiB0aGUgcHJvcGVydGllcyBvZiBgY2ZnYCBvbnRvIHRoZSBBdXRvbGlua2VyIGluc3RhbmNlLiBQcm90b3R5cGUgcHJvcGVydGllcyB3aWxsIGJlIHVzZWQgZm9yIG1pc3NpbmcgY29uZmlncy5cbn07XG5cblxuQXV0b2xpbmtlci5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yIDogQXV0b2xpbmtlciwgIC8vIGZpeCBjb25zdHJ1Y3RvciBwcm9wZXJ0eVxuXHRcblx0LyoqXG5cdCAqIEBjZmcge0Jvb2xlYW59IHVybHNcblx0ICogXG5cdCAqIGB0cnVlYCBpZiBtaXNjZWxsYW5lb3VzIFVSTHMgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgbGlua2VkLCBgZmFsc2VgIGlmIHRoZXkgc2hvdWxkIG5vdCBiZS5cblx0ICovXG5cdHVybHMgOiB0cnVlLFxuXHRcblx0LyoqXG5cdCAqIEBjZmcge0Jvb2xlYW59IGVtYWlsXG5cdCAqIFxuXHQgKiBgdHJ1ZWAgaWYgZW1haWwgYWRkcmVzc2VzIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGxpbmtlZCwgYGZhbHNlYCBpZiB0aGV5IHNob3VsZCBub3QgYmUuXG5cdCAqL1xuXHRlbWFpbCA6IHRydWUsXG5cdFxuXHQvKipcblx0ICogQGNmZyB7Qm9vbGVhbn0gdHdpdHRlclxuXHQgKiBcblx0ICogYHRydWVgIGlmIFR3aXR0ZXIgaGFuZGxlcyAoXCJAZXhhbXBsZVwiKSBzaG91bGQgYmUgYXV0b21hdGljYWxseSBsaW5rZWQsIGBmYWxzZWAgaWYgdGhleSBzaG91bGQgbm90IGJlLlxuXHQgKi9cblx0dHdpdHRlciA6IHRydWUsXG5cdFxuXHQvKipcblx0ICogQGNmZyB7Qm9vbGVhbn0gbmV3V2luZG93XG5cdCAqIFxuXHQgKiBgdHJ1ZWAgaWYgdGhlIGxpbmtzIHNob3VsZCBvcGVuIGluIGEgbmV3IHdpbmRvdywgYGZhbHNlYCBvdGhlcndpc2UuXG5cdCAqL1xuXHRuZXdXaW5kb3cgOiB0cnVlLFxuXHRcblx0LyoqXG5cdCAqIEBjZmcge0Jvb2xlYW59IHN0cmlwUHJlZml4XG5cdCAqIFxuXHQgKiBgdHJ1ZWAgaWYgJ2h0dHA6Ly8nIG9yICdodHRwczovLycgYW5kL29yIHRoZSAnd3d3Licgc2hvdWxkIGJlIHN0cmlwcGVkIGZyb20gdGhlIGJlZ2lubmluZyBvZiBVUkwgbGlua3MnIHRleHQsIFxuXHQgKiBgZmFsc2VgIG90aGVyd2lzZS5cblx0ICovXG5cdHN0cmlwUHJlZml4IDogdHJ1ZSxcblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtOdW1iZXJ9IHRydW5jYXRlXG5cdCAqIFxuXHQgKiBBIG51bWJlciBmb3IgaG93IG1hbnkgY2hhcmFjdGVycyBsb25nIFVSTHMvZW1haWxzL3R3aXR0ZXIgaGFuZGxlcyBzaG91bGQgYmUgdHJ1bmNhdGVkIHRvIGluc2lkZSB0aGUgdGV4dCBvZiBcblx0ICogYSBsaW5rLiBJZiB0aGUgVVJML2VtYWlsL3R3aXR0ZXIgaXMgb3ZlciB0aGlzIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBpdCB3aWxsIGJlIHRydW5jYXRlZCB0byB0aGlzIGxlbmd0aCBieSBcblx0ICogYWRkaW5nIGEgdHdvIHBlcmlvZCBlbGxpcHNpcyAoJy4uJykgdG8gdGhlIGVuZCBvZiB0aGUgc3RyaW5nLlxuXHQgKiBcblx0ICogRm9yIGV4YW1wbGU6IEEgdXJsIGxpa2UgJ2h0dHA6Ly93d3cueWFob28uY29tL3NvbWUvbG9uZy9wYXRoL3RvL2EvZmlsZScgdHJ1bmNhdGVkIHRvIDI1IGNoYXJhY3RlcnMgbWlnaHQgbG9va1xuXHQgKiBzb21ldGhpbmcgbGlrZSB0aGlzOiAneWFob28uY29tL3NvbWUvbG9uZy9wYXQuLidcblx0ICovXG5cdHRydW5jYXRlIDogdW5kZWZpbmVkLFxuXHRcblx0LyoqXG5cdCAqIEBjZmcge1N0cmluZ30gY2xhc3NOYW1lXG5cdCAqIFxuXHQgKiBBIENTUyBjbGFzcyBuYW1lIHRvIGFkZCB0byB0aGUgZ2VuZXJhdGVkIGxpbmtzLiBUaGlzIGNsYXNzIHdpbGwgYmUgYWRkZWQgdG8gYWxsIGxpbmtzLCBhcyB3ZWxsIGFzIHRoaXMgY2xhc3Ncblx0ICogcGx1cyB1cmwvZW1haWwvdHdpdHRlciBzdWZmaXhlcyBmb3Igc3R5bGluZyB1cmwvZW1haWwvdHdpdHRlciBsaW5rcyBkaWZmZXJlbnRseS5cblx0ICogXG5cdCAqIEZvciBleGFtcGxlLCBpZiB0aGlzIGNvbmZpZyBpcyBwcm92aWRlZCBhcyBcIm15TGlua1wiLCB0aGVuOlxuXHQgKiBcblx0ICogLSBVUkwgbGlua3Mgd2lsbCBoYXZlIHRoZSBDU1MgY2xhc3NlczogXCJteUxpbmsgbXlMaW5rLXVybFwiXG5cdCAqIC0gRW1haWwgbGlua3Mgd2lsbCBoYXZlIHRoZSBDU1MgY2xhc3NlczogXCJteUxpbmsgbXlMaW5rLWVtYWlsXCIsIGFuZFxuXHQgKiAtIFR3aXR0ZXIgbGlua3Mgd2lsbCBoYXZlIHRoZSBDU1MgY2xhc3NlczogXCJteUxpbmsgbXlMaW5rLXR3aXR0ZXJcIlxuXHQgKi9cblx0Y2xhc3NOYW1lIDogXCJcIixcblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtGdW5jdGlvbn0gcmVwbGFjZUZuXG5cdCAqIFxuXHQgKiBBIGZ1bmN0aW9uIHRvIGluZGl2aWR1YWxseSBwcm9jZXNzIGVhY2ggVVJML0VtYWlsL1R3aXR0ZXIgbWF0Y2ggZm91bmQgaW4gdGhlIGlucHV0IHN0cmluZy5cblx0ICogXG5cdCAqIFNlZSB0aGUgY2xhc3MncyBkZXNjcmlwdGlvbiBmb3IgdXNhZ2UuXG5cdCAqIFxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcblx0ICogXG5cdCAqIEBjZmcge0F1dG9saW5rZXJ9IHJlcGxhY2VGbi5hdXRvbGlua2VyIFRoZSBBdXRvbGlua2VyIGluc3RhbmNlLCB3aGljaCBtYXkgYmUgdXNlZCB0byByZXRyaWV2ZSBjaGlsZCBvYmplY3RzIGZyb20gKHN1Y2hcblx0ICogICBhcyB0aGUgaW5zdGFuY2UncyB7QGxpbmsgI2dldFRhZ0J1aWxkZXIgdGFnIGJ1aWxkZXJ9KS5cblx0ICogQGNmZyB7QXV0b2xpbmtlci5tYXRjaC5NYXRjaH0gcmVwbGFjZUZuLm1hdGNoIFRoZSBNYXRjaCBpbnN0YW5jZSB3aGljaCBjYW4gYmUgdXNlZCB0byByZXRyaWV2ZSBpbmZvcm1hdGlvbiBhYm91dCB0aGVcblx0ICogICB7QGxpbmsgQXV0b2xpbmtlci5tYXRjaC5VcmwgVVJMfS97QGxpbmsgQXV0b2xpbmtlci5tYXRjaC5FbWFpbCBlbWFpbH0ve0BsaW5rIEF1dG9saW5rZXIubWF0Y2guVHdpdHRlciBUd2l0dGVyfVxuXHQgKiAgIG1hdGNoIHRoYXQgdGhlIGByZXBsYWNlRm5gIGlzIGN1cnJlbnRseSBwcm9jZXNzaW5nLlxuXHQgKi9cblx0XG5cdFxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHByb3BlcnR5IHtBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbFBhcnNlcn0gaHRtbFBhcnNlclxuXHQgKiBcblx0ICogVGhlIEh0bWxQYXJzZXIgaW5zdGFuY2UgdXNlZCB0byBza2lwIG92ZXIgSFRNTCB0YWdzLCB3aGlsZSBmaW5kaW5nIHRleHQgbm9kZXMgdG8gcHJvY2Vzcy4gVGhpcyBpcyBsYXppbHkgaW5zdGFudGlhdGVkXG5cdCAqIGluIHRoZSB7QGxpbmsgI2dldEh0bWxQYXJzZXJ9IG1ldGhvZC5cblx0ICovXG5cdGh0bWxQYXJzZXIgOiB1bmRlZmluZWQsXG5cdFxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHByb3BlcnR5IHtBdXRvbGlua2VyLm1hdGNoUGFyc2VyLk1hdGNoUGFyc2VyfSBtYXRjaFBhcnNlclxuXHQgKiBcblx0ICogVGhlIE1hdGNoUGFyc2VyIGluc3RhbmNlIHVzZWQgdG8gZmluZCBVUkwvZW1haWwvVHdpdHRlciBtYXRjaGVzIGluIHRoZSB0ZXh0IG5vZGVzIG9mIGFuIGlucHV0IHN0cmluZyBwYXNzZWQgdG9cblx0ICoge0BsaW5rICNsaW5rfS4gVGhpcyBpcyBsYXppbHkgaW5zdGFudGlhdGVkIGluIHRoZSB7QGxpbmsgI2dldE1hdGNoUGFyc2VyfSBtZXRob2QuXG5cdCAqL1xuXHRtYXRjaFBhcnNlciA6IHVuZGVmaW5lZCxcblx0XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcHJvcGVydHkge0F1dG9saW5rZXIuQW5jaG9yVGFnQnVpbGRlcn0gdGFnQnVpbGRlclxuXHQgKiBcblx0ICogVGhlIEFuY2hvclRhZ0J1aWxkZXIgaW5zdGFuY2UgdXNlZCB0byBidWlsZCB0aGUgVVJML2VtYWlsL1R3aXR0ZXIgcmVwbGFjZW1lbnQgYW5jaG9yIHRhZ3MuIFRoaXMgaXMgbGF6aWx5IGluc3RhbnRpYXRlZFxuXHQgKiBpbiB0aGUge0BsaW5rICNnZXRUYWdCdWlsZGVyfSBtZXRob2QuXG5cdCAqL1xuXHR0YWdCdWlsZGVyIDogdW5kZWZpbmVkLFxuXHRcblx0XG5cdC8qKlxuXHQgKiBBdXRvbWF0aWNhbGx5IGxpbmtzIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgaGFuZGxlcyBmb3VuZCBpbiB0aGUgZ2l2ZW4gY2h1bmsgb2YgSFRNTC4gXG5cdCAqIERvZXMgbm90IGxpbmsgVVJMcyBmb3VuZCB3aXRoaW4gSFRNTCB0YWdzLlxuXHQgKiBcblx0ICogRm9yIGluc3RhbmNlLCBpZiBnaXZlbiB0aGUgdGV4dDogYFlvdSBzaG91bGQgZ28gdG8gaHR0cDovL3d3dy55YWhvby5jb21gLCB0aGVuIHRoZSByZXN1bHRcblx0ICogd2lsbCBiZSBgWW91IHNob3VsZCBnbyB0byAmbHQ7YSBocmVmPVwiaHR0cDovL3d3dy55YWhvby5jb21cIiZndDtodHRwOi8vd3d3LnlhaG9vLmNvbSZsdDsvYSZndDtgXG5cdCAqIFxuXHQgKiBUaGlzIG1ldGhvZCBmaW5kcyB0aGUgdGV4dCBhcm91bmQgYW55IEhUTUwgZWxlbWVudHMgaW4gdGhlIGlucHV0IGB0ZXh0T3JIdG1sYCwgd2hpY2ggd2lsbCBiZSB0aGUgdGV4dCB0aGF0IGlzIHByb2Nlc3NlZC5cblx0ICogQW55IG9yaWdpbmFsIEhUTUwgZWxlbWVudHMgd2lsbCBiZSBsZWZ0IGFzLWlzLCBhcyB3ZWxsIGFzIHRoZSB0ZXh0IHRoYXQgaXMgYWxyZWFkeSB3cmFwcGVkIGluIGFuY2hvciAoJmx0O2EmZ3Q7KSB0YWdzLlxuXHQgKiBcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRPckh0bWwgVGhlIEhUTUwgb3IgdGV4dCB0byBsaW5rIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgaGFuZGxlcyB3aXRoaW4gKGRlcGVuZGluZyBvbiBpZlxuXHQgKiAgIHRoZSB7QGxpbmsgI3VybHN9LCB7QGxpbmsgI2VtYWlsfSwgYW5kIHtAbGluayAjdHdpdHRlcn0gb3B0aW9ucyBhcmUgZW5hYmxlZCkuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIEhUTUwsIHdpdGggVVJMcy9lbWFpbHMvVHdpdHRlciBoYW5kbGVzIGF1dG9tYXRpY2FsbHkgbGlua2VkLlxuXHQgKi9cblx0bGluayA6IGZ1bmN0aW9uKCB0ZXh0T3JIdG1sICkge1xuXHRcdHZhciBodG1sUGFyc2VyID0gdGhpcy5nZXRIdG1sUGFyc2VyKCksXG5cdFx0ICAgIGh0bWxOb2RlcyA9IGh0bWxQYXJzZXIucGFyc2UoIHRleHRPckh0bWwgKSxcblx0XHQgICAgYW5jaG9yVGFnU3RhY2tDb3VudCA9IDAsICAvLyB1c2VkIHRvIG9ubHkgcHJvY2VzcyB0ZXh0IGFyb3VuZCBhbmNob3IgdGFncywgYW5kIGFueSBpbm5lciB0ZXh0L2h0bWwgdGhleSBtYXkgaGF2ZVxuXHRcdCAgICByZXN1bHRIdG1sID0gW107XG5cdFx0XG5cdFx0Zm9yKCB2YXIgaSA9IDAsIGxlbiA9IGh0bWxOb2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdHZhciBub2RlID0gaHRtbE5vZGVzWyBpIF0sXG5cdFx0XHQgICAgbm9kZVR5cGUgPSBub2RlLmdldFR5cGUoKSxcblx0XHRcdCAgICBub2RlVGV4dCA9IG5vZGUuZ2V0VGV4dCgpO1xuXHRcdFx0XG5cdFx0XHRpZiggbm9kZVR5cGUgPT09ICdlbGVtZW50JyApIHtcblx0XHRcdFx0Ly8gUHJvY2VzcyBIVE1MIG5vZGVzIGluIHRoZSBpbnB1dCBgdGV4dE9ySHRtbGBcblx0XHRcdFx0aWYoIG5vZGUuZ2V0VGFnTmFtZSgpID09PSAnYScgKSB7XG5cdFx0XHRcdFx0aWYoICFub2RlLmlzQ2xvc2luZygpICkgeyAgLy8gaXQncyB0aGUgc3RhcnQgPGE+IHRhZ1xuXHRcdFx0XHRcdFx0YW5jaG9yVGFnU3RhY2tDb3VudCsrO1xuXHRcdFx0XHRcdH0gZWxzZSB7ICAgLy8gaXQncyB0aGUgZW5kIDwvYT4gdGFnXG5cdFx0XHRcdFx0XHRhbmNob3JUYWdTdGFja0NvdW50ID0gTWF0aC5tYXgoIGFuY2hvclRhZ1N0YWNrQ291bnQgLSAxLCAwICk7ICAvLyBhdHRlbXB0IHRvIGhhbmRsZSBleHRyYW5lb3VzIDwvYT4gdGFncyBieSBtYWtpbmcgc3VyZSB0aGUgc3RhY2sgY291bnQgbmV2ZXIgZ29lcyBiZWxvdyAwXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdEh0bWwucHVzaCggbm9kZVRleHQgKTsgIC8vIG5vdyBhZGQgdGhlIHRleHQgb2YgdGhlIHRhZyBpdHNlbGYgdmVyYmF0aW1cblx0XHRcdFx0XG5cdFx0XHR9IGVsc2UgaWYoIG5vZGVUeXBlID09PSAnZW50aXR5JyApIHtcblx0XHRcdFx0cmVzdWx0SHRtbC5wdXNoKCBub2RlVGV4dCApOyAgLy8gYXBwZW5kIEhUTUwgZW50aXR5IG5vZGVzIChzdWNoIGFzICcmbmJzcDsnKSB2ZXJiYXRpbVxuXHRcdFx0XHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFByb2Nlc3MgdGV4dCBub2RlcyBpbiB0aGUgaW5wdXQgYHRleHRPckh0bWxgXG5cdFx0XHRcdGlmKCBhbmNob3JUYWdTdGFja0NvdW50ID09PSAwICkge1xuXHRcdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCB3aXRoaW4gYW4gPGE+IHRhZywgcHJvY2VzcyB0aGUgdGV4dCBub2RlIHRvIGxpbmtpZnlcblx0XHRcdFx0XHR2YXIgbGlua2lmaWVkU3RyID0gdGhpcy5saW5raWZ5U3RyKCBub2RlVGV4dCApO1xuXHRcdFx0XHRcdHJlc3VsdEh0bWwucHVzaCggbGlua2lmaWVkU3RyICk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gYHRleHRgIGlzIHdpdGhpbiBhbiA8YT4gdGFnLCBzaW1wbHkgYXBwZW5kIHRoZSB0ZXh0IC0gd2UgZG8gbm90IHdhbnQgdG8gYXV0b2xpbmsgYW55dGhpbmcgXG5cdFx0XHRcdFx0Ly8gYWxyZWFkeSB3aXRoaW4gYW4gPGE+Li4uPC9hPiB0YWdcblx0XHRcdFx0XHRyZXN1bHRIdG1sLnB1c2goIG5vZGVUZXh0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHJlc3VsdEh0bWwuam9pbiggXCJcIiApO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBQcm9jZXNzIHRoZSB0ZXh0IHRoYXQgbGllcyBpbiBiZXR3ZWVuIEhUTUwgdGFncywgcGVyZm9ybWluZyB0aGUgYW5jaG9yIHRhZyByZXBsYWNlbWVudHMgZm9yIG1hdGNoZWQgXG5cdCAqIFVSTHMvZW1haWxzL1R3aXR0ZXIgaGFuZGxlcywgYW5kIHJldHVybnMgdGhlIHN0cmluZyB3aXRoIHRoZSByZXBsYWNlbWVudHMgbWFkZS4gXG5cdCAqIFxuXHQgKiBUaGlzIG1ldGhvZCBkb2VzIHRoZSBhY3R1YWwgd3JhcHBpbmcgb2YgVVJMcy9lbWFpbHMvVHdpdHRlciBoYW5kbGVzIHdpdGggYW5jaG9yIHRhZ3MuXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgb2YgdGV4dCB0byBhdXRvLWxpbmsuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHRleHQgd2l0aCBhbmNob3IgdGFncyBhdXRvLWZpbGxlZC5cblx0ICovXG5cdGxpbmtpZnlTdHIgOiBmdW5jdGlvbiggc3RyICkge1xuXHRcdHJldHVybiB0aGlzLmdldE1hdGNoUGFyc2VyKCkucmVwbGFjZSggc3RyLCB0aGlzLmNyZWF0ZU1hdGNoUmV0dXJuVmFsLCB0aGlzICk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZXMgdGhlIHJldHVybiBzdHJpbmcgdmFsdWUgZm9yIGEgZ2l2ZW4gbWF0Y2ggaW4gdGhlIGlucHV0IHN0cmluZywgZm9yIHRoZSB7QGxpbmsgI3Byb2Nlc3NUZXh0Tm9kZX0gbWV0aG9kLlxuXHQgKiBcblx0ICogVGhpcyBtZXRob2QgaGFuZGxlcyB0aGUge0BsaW5rICNyZXBsYWNlRm59LCBpZiBvbmUgd2FzIHByb3ZpZGVkLlxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBdXRvbGlua2VyLm1hdGNoLk1hdGNofSBtYXRjaCBUaGUgTWF0Y2ggb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgbWF0Y2guXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHN0cmluZyB0aGF0IHRoZSBgbWF0Y2hgIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoLiBUaGlzIGlzIHVzdWFsbHkgdGhlIGFuY2hvciB0YWcgc3RyaW5nLCBidXRcblx0ICogICBtYXkgYmUgdGhlIGBtYXRjaFN0cmAgaXRzZWxmIGlmIHRoZSBtYXRjaCBpcyBub3QgdG8gYmUgcmVwbGFjZWQuXG5cdCAqL1xuXHRjcmVhdGVNYXRjaFJldHVyblZhbCA6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHQvLyBIYW5kbGUgYSBjdXN0b20gYHJlcGxhY2VGbmAgYmVpbmcgcHJvdmlkZWRcblx0XHR2YXIgcmVwbGFjZUZuUmVzdWx0O1xuXHRcdGlmKCB0aGlzLnJlcGxhY2VGbiApIHtcblx0XHRcdHJlcGxhY2VGblJlc3VsdCA9IHRoaXMucmVwbGFjZUZuLmNhbGwoIHRoaXMsIHRoaXMsIG1hdGNoICk7ICAvLyBBdXRvbGlua2VyIGluc3RhbmNlIGlzIHRoZSBjb250ZXh0LCBhbmQgdGhlIGZpcnN0IGFyZ1xuXHRcdH1cblx0XHRcblx0XHRpZiggdHlwZW9mIHJlcGxhY2VGblJlc3VsdCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRyZXR1cm4gcmVwbGFjZUZuUmVzdWx0OyAgLy8gYHJlcGxhY2VGbmAgcmV0dXJuZWQgYSBzdHJpbmcsIHVzZSB0aGF0XG5cdFx0XHRcblx0XHR9IGVsc2UgaWYoIHJlcGxhY2VGblJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm4gbWF0Y2guZ2V0TWF0Y2hlZFRleHQoKTsgIC8vIG5vIHJlcGxhY2VtZW50IGZvciB0aGUgbWF0Y2hcblx0XHRcdFxuXHRcdH0gZWxzZSBpZiggcmVwbGFjZUZuUmVzdWx0IGluc3RhbmNlb2YgQXV0b2xpbmtlci5IdG1sVGFnICkge1xuXHRcdFx0cmV0dXJuIHJlcGxhY2VGblJlc3VsdC50b1N0cmluZygpO1xuXHRcdFxuXHRcdH0gZWxzZSB7ICAvLyByZXBsYWNlRm5SZXN1bHQgPT09IHRydWUsIG9yIG5vL3Vua25vd24gcmV0dXJuIHZhbHVlIGZyb20gZnVuY3Rpb25cblx0XHRcdC8vIFBlcmZvcm0gQXV0b2xpbmtlcidzIGRlZmF1bHQgYW5jaG9yIHRhZyBnZW5lcmF0aW9uXG5cdFx0XHR2YXIgdGFnQnVpbGRlciA9IHRoaXMuZ2V0VGFnQnVpbGRlcigpLFxuXHRcdFx0ICAgIGFuY2hvclRhZyA9IHRhZ0J1aWxkZXIuYnVpbGQoIG1hdGNoICk7ICAvLyByZXR1cm5zIGFuIEF1dG9saW5rZXIuSHRtbFRhZyBpbnN0YW5jZVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gYW5jaG9yVGFnLnRvU3RyaW5nKCk7XG5cdFx0fVxuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBMYXppbHkgaW5zdGFudGlhdGVzIGFuZCByZXR1cm5zIHRoZSB7QGxpbmsgI2h0bWxQYXJzZXJ9IGluc3RhbmNlIGZvciB0aGlzIEF1dG9saW5rZXIgaW5zdGFuY2UuXG5cdCAqIFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sUGFyc2VyfVxuXHQgKi9cblx0Z2V0SHRtbFBhcnNlciA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBodG1sUGFyc2VyID0gdGhpcy5odG1sUGFyc2VyO1xuXHRcdFxuXHRcdGlmKCAhaHRtbFBhcnNlciApIHtcblx0XHRcdGh0bWxQYXJzZXIgPSB0aGlzLmh0bWxQYXJzZXIgPSBuZXcgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxQYXJzZXIoKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGh0bWxQYXJzZXI7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIExhemlseSBpbnN0YW50aWF0ZXMgYW5kIHJldHVybnMgdGhlIHtAbGluayAjbWF0Y2hQYXJzZXJ9IGluc3RhbmNlIGZvciB0aGlzIEF1dG9saW5rZXIgaW5zdGFuY2UuXG5cdCAqIFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIubWF0Y2hQYXJzZXIuTWF0Y2hQYXJzZXJ9XG5cdCAqL1xuXHRnZXRNYXRjaFBhcnNlciA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXRjaFBhcnNlciA9IHRoaXMubWF0Y2hQYXJzZXI7XG5cdFx0XG5cdFx0aWYoICFtYXRjaFBhcnNlciApIHtcblx0XHRcdG1hdGNoUGFyc2VyID0gdGhpcy5tYXRjaFBhcnNlciA9IG5ldyBBdXRvbGlua2VyLm1hdGNoUGFyc2VyLk1hdGNoUGFyc2VyKCB7XG5cdFx0XHRcdHVybHMgOiB0aGlzLnVybHMsXG5cdFx0XHRcdGVtYWlsIDogdGhpcy5lbWFpbCxcblx0XHRcdFx0dHdpdHRlciA6IHRoaXMudHdpdHRlcixcblx0XHRcdFx0c3RyaXBQcmVmaXggOiB0aGlzLnN0cmlwUHJlZml4XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBtYXRjaFBhcnNlcjtcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUge0BsaW5rICN0YWdCdWlsZGVyfSBpbnN0YW5jZSBmb3IgdGhpcyBBdXRvbGlua2VyIGluc3RhbmNlLCBsYXppbHkgaW5zdGFudGlhdGluZyBpdFxuXHQgKiBpZiBpdCBkb2VzIG5vdCB5ZXQgZXhpc3QuXG5cdCAqIFxuXHQgKiBUaGlzIG1ldGhvZCBtYXkgYmUgdXNlZCBpbiBhIHtAbGluayAjcmVwbGFjZUZufSB0byBnZW5lcmF0ZSB0aGUge0BsaW5rIEF1dG9saW5rZXIuSHRtbFRhZyBIdG1sVGFnfSBpbnN0YW5jZSB0aGF0IFxuXHQgKiBBdXRvbGlua2VyIHdvdWxkIG5vcm1hbGx5IGdlbmVyYXRlLCBhbmQgdGhlbiBhbGxvdyBmb3IgbW9kaWZpY2F0aW9ucyBiZWZvcmUgcmV0dXJuaW5nIGl0LiBGb3IgZXhhbXBsZTpcblx0ICogXG5cdCAqICAgICB2YXIgaHRtbCA9IEF1dG9saW5rZXIubGluayggXCJUZXN0IGdvb2dsZS5jb21cIiwge1xuXHQgKiAgICAgICAgIHJlcGxhY2VGbiA6IGZ1bmN0aW9uKCBhdXRvbGlua2VyLCBtYXRjaCApIHtcblx0ICogICAgICAgICAgICAgdmFyIHRhZyA9IGF1dG9saW5rZXIuZ2V0VGFnQnVpbGRlcigpLmJ1aWxkKCBtYXRjaCApOyAgLy8gcmV0dXJucyBhbiB7QGxpbmsgQXV0b2xpbmtlci5IdG1sVGFnfSBpbnN0YW5jZVxuXHQgKiAgICAgICAgICAgICB0YWcuc2V0QXR0ciggJ3JlbCcsICdub2ZvbGxvdycgKTtcblx0ICogICAgICAgICAgICAgXG5cdCAqICAgICAgICAgICAgIHJldHVybiB0YWc7XG5cdCAqICAgICAgICAgfVxuXHQgKiAgICAgfSApO1xuXHQgKiAgICAgXG5cdCAqICAgICAvLyBnZW5lcmF0ZWQgaHRtbDpcblx0ICogICAgIC8vICAgVGVzdCA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub2ZvbGxvd1wiPmdvb2dsZS5jb208L2E+XG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkFuY2hvclRhZ0J1aWxkZXJ9XG5cdCAqL1xuXHRnZXRUYWdCdWlsZGVyIDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRhZ0J1aWxkZXIgPSB0aGlzLnRhZ0J1aWxkZXI7XG5cdFx0XG5cdFx0aWYoICF0YWdCdWlsZGVyICkge1xuXHRcdFx0dGFnQnVpbGRlciA9IHRoaXMudGFnQnVpbGRlciA9IG5ldyBBdXRvbGlua2VyLkFuY2hvclRhZ0J1aWxkZXIoIHtcblx0XHRcdFx0bmV3V2luZG93ICAgOiB0aGlzLm5ld1dpbmRvdyxcblx0XHRcdFx0dHJ1bmNhdGUgICAgOiB0aGlzLnRydW5jYXRlLFxuXHRcdFx0XHRjbGFzc05hbWUgICA6IHRoaXMuY2xhc3NOYW1lXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0YWdCdWlsZGVyO1xuXHR9XG5cbn07XG5cblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IGxpbmtzIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgaGFuZGxlcyBmb3VuZCBpbiB0aGUgZ2l2ZW4gY2h1bmsgb2YgSFRNTC4gXG4gKiBEb2VzIG5vdCBsaW5rIFVSTHMgZm91bmQgd2l0aGluIEhUTUwgdGFncy5cbiAqIFxuICogRm9yIGluc3RhbmNlLCBpZiBnaXZlbiB0aGUgdGV4dDogYFlvdSBzaG91bGQgZ28gdG8gaHR0cDovL3d3dy55YWhvby5jb21gLCB0aGVuIHRoZSByZXN1bHRcbiAqIHdpbGwgYmUgYFlvdSBzaG91bGQgZ28gdG8gJmx0O2EgaHJlZj1cImh0dHA6Ly93d3cueWFob28uY29tXCImZ3Q7aHR0cDovL3d3dy55YWhvby5jb20mbHQ7L2EmZ3Q7YFxuICogXG4gKiBFeGFtcGxlOlxuICogXG4gKiAgICAgdmFyIGxpbmtlZFRleHQgPSBBdXRvbGlua2VyLmxpbmsoIFwiR28gdG8gZ29vZ2xlLmNvbVwiLCB7IG5ld1dpbmRvdzogZmFsc2UgfSApO1xuICogICAgIC8vIFByb2R1Y2VzOiBcIkdvIHRvIDxhIGhyZWY9XCJodHRwOi8vZ29vZ2xlLmNvbVwiPmdvb2dsZS5jb208L2E+XCJcbiAqIFxuICogQHN0YXRpY1xuICogQHBhcmFtIHtTdHJpbmd9IHRleHRPckh0bWwgVGhlIEhUTUwgb3IgdGV4dCB0byBmaW5kIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgaGFuZGxlcyB3aXRoaW4gKGRlcGVuZGluZyBvbiBpZlxuICogICB0aGUge0BsaW5rICN1cmxzfSwge0BsaW5rICNlbWFpbH0sIGFuZCB7QGxpbmsgI3R3aXR0ZXJ9IG9wdGlvbnMgYXJlIGVuYWJsZWQpLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbnkgb2YgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIEF1dG9saW5rZXIgY2xhc3MsIHNwZWNpZmllZCBpbiBhbiBPYmplY3QgKG1hcCkuXG4gKiAgIFNlZSB0aGUgY2xhc3MgZGVzY3JpcHRpb24gZm9yIGFuIGV4YW1wbGUgY2FsbC5cbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIEhUTUwgdGV4dCwgd2l0aCBVUkxzIGF1dG9tYXRpY2FsbHkgbGlua2VkXG4gKi9cbkF1dG9saW5rZXIubGluayA9IGZ1bmN0aW9uKCB0ZXh0T3JIdG1sLCBvcHRpb25zICkge1xuXHR2YXIgYXV0b2xpbmtlciA9IG5ldyBBdXRvbGlua2VyKCBvcHRpb25zICk7XG5cdHJldHVybiBhdXRvbGlua2VyLmxpbmsoIHRleHRPckh0bWwgKTtcbn07XG5cblxuLy8gQXV0b2xpbmtlciBOYW1lc3BhY2VzXG5BdXRvbGlua2VyLm1hdGNoID0ge307XG5BdXRvbGlua2VyLmh0bWxQYXJzZXIgPSB7fTtcbkF1dG9saW5rZXIubWF0Y2hQYXJzZXIgPSB7fTtcbi8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cbi8qanNoaW50IGVxbnVsbDp0cnVlLCBib3NzOnRydWUgKi9cbi8qKlxuICogQGNsYXNzIEF1dG9saW5rZXIuVXRpbFxuICogQHNpbmdsZXRvblxuICogXG4gKiBBIGZldyB1dGlsaXR5IG1ldGhvZHMgZm9yIEF1dG9saW5rZXIuXG4gKi9cbkF1dG9saW5rZXIuVXRpbCA9IHtcblx0XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBhYnN0cmFjdE1ldGhvZFxuXHQgKiBcblx0ICogQSBmdW5jdGlvbiBvYmplY3Qgd2hpY2ggcmVwcmVzZW50cyBhbiBhYnN0cmFjdCBtZXRob2QuXG5cdCAqL1xuXHRhYnN0cmFjdE1ldGhvZCA6IGZ1bmN0aW9uKCkgeyB0aHJvdyBcImFic3RyYWN0XCI7IH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIEFzc2lnbnMgKHNoYWxsb3cgY29waWVzKSB0aGUgcHJvcGVydGllcyBvZiBgc3JjYCBvbnRvIGBkZXN0YC5cblx0ICogXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgVGhlIHNvdXJjZSBvYmplY3QuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlc3RpbmF0aW9uIG9iamVjdCAoYGRlc3RgKVxuXHQgKi9cblx0YXNzaWduIDogZnVuY3Rpb24oIGRlc3QsIHNyYyApIHtcblx0XHRmb3IoIHZhciBwcm9wIGluIHNyYyApIHtcblx0XHRcdGlmKCBzcmMuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcblx0XHRcdFx0ZGVzdFsgcHJvcCBdID0gc3JjWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBkZXN0O1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBFeHRlbmRzIGBzdXBlcmNsYXNzYCB0byBjcmVhdGUgYSBuZXcgc3ViY2xhc3MsIGFkZGluZyB0aGUgYHByb3RvUHJvcHNgIHRvIHRoZSBuZXcgc3ViY2xhc3MncyBwcm90b3R5cGUuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdXBlcmNsYXNzIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIHN1cGVyY2xhc3MuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1Byb3BzIFRoZSBtZXRob2RzL3Byb3BlcnRpZXMgdG8gYWRkIHRvIHRoZSBzdWJjbGFzcydzIHByb3RvdHlwZS4gVGhpcyBtYXkgY29udGFpbiB0aGVcblx0ICogICBzcGVjaWFsIHByb3BlcnR5IGBjb25zdHJ1Y3RvcmAsIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyB0aGUgbmV3IHN1YmNsYXNzJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgbmV3IHN1YmNsYXNzIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZXh0ZW5kIDogZnVuY3Rpb24oIHN1cGVyY2xhc3MsIHByb3RvUHJvcHMgKSB7XG5cdFx0dmFyIHN1cGVyY2xhc3NQcm90byA9IHN1cGVyY2xhc3MucHJvdG90eXBlO1xuXHRcdFxuXHRcdHZhciBGID0gZnVuY3Rpb24oKSB7fTtcblx0XHRGLnByb3RvdHlwZSA9IHN1cGVyY2xhc3NQcm90bztcblx0XHRcblx0XHR2YXIgc3ViY2xhc3M7XG5cdFx0aWYoIHByb3RvUHJvcHMuaGFzT3duUHJvcGVydHkoICdjb25zdHJ1Y3RvcicgKSApIHtcblx0XHRcdHN1YmNsYXNzID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3Rvcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3ViY2xhc3MgPSBmdW5jdGlvbigpIHsgc3VwZXJjbGFzc1Byb3RvLmNvbnN0cnVjdG9yLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTsgfTtcblx0XHR9XG5cdFx0XG5cdFx0dmFyIHN1YmNsYXNzUHJvdG8gPSBzdWJjbGFzcy5wcm90b3R5cGUgPSBuZXcgRigpOyAgLy8gc2V0IHVwIHByb3RvdHlwZSBjaGFpblxuXHRcdHN1YmNsYXNzUHJvdG8uY29uc3RydWN0b3IgPSBzdWJjbGFzczsgIC8vIGZpeCBjb25zdHJ1Y3RvciBwcm9wZXJ0eVxuXHRcdHN1YmNsYXNzUHJvdG8uc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3NQcm90bztcblx0XHRcblx0XHRkZWxldGUgcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjsgIC8vIGRvbid0IHJlLWFzc2lnbiBjb25zdHJ1Y3RvciBwcm9wZXJ0eSB0byB0aGUgcHJvdG90eXBlLCBzaW5jZSBhIG5ldyBmdW5jdGlvbiBtYXkgaGF2ZSBiZWVuIGNyZWF0ZWQgKGBzdWJjbGFzc2ApLCB3aGljaCBpcyBub3cgYWxyZWFkeSB0aGVyZVxuXHRcdEF1dG9saW5rZXIuVXRpbC5hc3NpZ24oIHN1YmNsYXNzUHJvdG8sIHByb3RvUHJvcHMgKTtcblx0XHRcblx0XHRyZXR1cm4gc3ViY2xhc3M7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFRydW5jYXRlcyB0aGUgYHN0cmAgYXQgYGxlbiAtIGVsbGlwc2lzQ2hhcnMubGVuZ3RoYCwgYW5kIGFkZHMgdGhlIGBlbGxpcHNpc0NoYXJzYCB0byB0aGVcblx0ICogZW5kIG9mIHRoZSBzdHJpbmcgKGJ5IGRlZmF1bHQsIHR3byBwZXJpb2RzOiAnLi4nKS4gSWYgdGhlIGBzdHJgIGxlbmd0aCBkb2VzIG5vdCBleGNlZWQgXG5cdCAqIGBsZW5gLCB0aGUgc3RyaW5nIHdpbGwgYmUgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuXHQgKiBcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHRydW5jYXRlIGFuZCBhZGQgYW4gZWxsaXBzaXMgdG8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0cnVuY2F0ZUxlbiBUaGUgbGVuZ3RoIHRvIHRydW5jYXRlIHRoZSBzdHJpbmcgYXQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbZWxsaXBzaXNDaGFycz0uLl0gVGhlIGVsbGlwc2lzIGNoYXJhY3RlcihzKSB0byBhZGQgdG8gdGhlIGVuZCBvZiBgc3RyYFxuXHQgKiAgIHdoZW4gdHJ1bmNhdGVkLiBEZWZhdWx0cyB0byAnLi4nXG5cdCAqL1xuXHRlbGxpcHNpcyA6IGZ1bmN0aW9uKCBzdHIsIHRydW5jYXRlTGVuLCBlbGxpcHNpc0NoYXJzICkge1xuXHRcdGlmKCBzdHIubGVuZ3RoID4gdHJ1bmNhdGVMZW4gKSB7XG5cdFx0XHRlbGxpcHNpc0NoYXJzID0gKCBlbGxpcHNpc0NoYXJzID09IG51bGwgKSA/ICcuLicgOiBlbGxpcHNpc0NoYXJzO1xuXHRcdFx0c3RyID0gc3RyLnN1YnN0cmluZyggMCwgdHJ1bmNhdGVMZW4gLSBlbGxpcHNpc0NoYXJzLmxlbmd0aCApICsgZWxsaXBzaXNDaGFycztcblx0XHR9XG5cdFx0cmV0dXJuIHN0cjtcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogU3VwcG9ydHMgYEFycmF5LnByb3RvdHlwZS5pbmRleE9mKClgIGZ1bmN0aW9uYWxpdHkgZm9yIG9sZCBJRSAoSUU4IGFuZCBiZWxvdykuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnIgVGhlIGFycmF5IHRvIGZpbmQgYW4gZWxlbWVudCBvZi5cblx0ICogQHBhcmFtIHsqfSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGZpbmQgaW4gdGhlIGFycmF5LCBhbmQgcmV0dXJuIHRoZSBpbmRleCBvZi5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGBlbGVtZW50YCwgb3IgLTEgaWYgaXQgd2FzIG5vdCBmb3VuZC5cblx0ICovXG5cdGluZGV4T2YgOiBmdW5jdGlvbiggYXJyLCBlbGVtZW50ICkge1xuXHRcdGlmKCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiApIHtcblx0XHRcdHJldHVybiBhcnIuaW5kZXhPZiggZWxlbWVudCApO1xuXHRcdFx0XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciggdmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGlmKCBhcnJbIGkgXSA9PT0gZWxlbWVudCApIHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH1cblx0fSxcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIFBlcmZvcm1zIHRoZSBmdW5jdGlvbmFsaXR5IG9mIHdoYXQgbW9kZXJuIGJyb3dzZXJzIGRvIHdoZW4gYFN0cmluZy5wcm90b3R5cGUuc3BsaXQoKWAgaXMgY2FsbGVkXG5cdCAqIHdpdGggYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBjb250YWlucyBjYXB0dXJpbmcgcGFyZW50aGVzaXMuXG5cdCAqIFxuXHQgKiBGb3IgZXhhbXBsZTpcblx0ICogXG5cdCAqICAgICAvLyBNb2Rlcm4gYnJvd3NlcnM6IFxuXHQgKiAgICAgXCJhLGIsY1wiLnNwbGl0KCAvKCwpLyApOyAgLy8gLS0+IFsgJ2EnLCAnLCcsICdiJywgJywnLCAnYycgXVxuXHQgKiAgICAgXG5cdCAqICAgICAvLyBPbGQgSUUgKGluY2x1ZGluZyBJRTgpOlxuXHQgKiAgICAgXCJhLGIsY1wiLnNwbGl0KCAvKCwpLyApOyAgLy8gLS0+IFsgJ2EnLCAnYicsICdjJyBdXG5cdCAqICAgICBcblx0ICogVGhpcyBtZXRob2QgZW11bGF0ZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgbW9kZXJuIGJyb3dzZXJzIGZvciB0aGUgb2xkIElFIGNhc2UuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gc3BsaXQuXG5cdCAqIEBwYXJhbSB7UmVnRXhwfSBzcGxpdFJlZ2V4IFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gc3BsaXQgdGhlIGlucHV0IGBzdHJgIG9uLiBUaGUgc3BsaXR0aW5nXG5cdCAqICAgY2hhcmFjdGVyKHMpIHdpbGwgYmUgc3BsaWNlZCBpbnRvIHRoZSBhcnJheSwgYXMgaW4gdGhlIFwibW9kZXJuIGJyb3dzZXJzXCIgZXhhbXBsZSBpbiB0aGUgXG5cdCAqICAgZGVzY3JpcHRpb24gb2YgdGhpcyBtZXRob2QuIFxuXHQgKiAgIE5vdGUgIzE6IHRoZSBzdXBwbGllZCByZWd1bGFyIGV4cHJlc3Npb24gKiptdXN0KiogaGF2ZSB0aGUgJ2cnIGZsYWcgc3BlY2lmaWVkLlxuXHQgKiAgIE5vdGUgIzI6IGZvciBzaW1wbGljaXR5J3Mgc2FrZSwgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBkb2VzIG5vdCBuZWVkIFxuXHQgKiAgIHRvIGNvbnRhaW4gY2FwdHVyaW5nIHBhcmVudGhlc2lzIC0gaXQgd2lsbCBiZSBhc3N1bWVkIHRoYXQgYW55IG1hdGNoIGhhcyB0aGVtLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmdbXX0gVGhlIHNwbGl0IGFycmF5IG9mIHN0cmluZ3MsIHdpdGggdGhlIHNwbGl0dGluZyBjaGFyYWN0ZXIocykgaW5jbHVkZWQuXG5cdCAqL1xuXHRzcGxpdEFuZENhcHR1cmUgOiBmdW5jdGlvbiggc3RyLCBzcGxpdFJlZ2V4ICkge1xuXHRcdGlmKCAhc3BsaXRSZWdleC5nbG9iYWwgKSB0aHJvdyBuZXcgRXJyb3IoIFwiYHNwbGl0UmVnZXhgIG11c3QgaGF2ZSB0aGUgJ2cnIGZsYWcgc2V0XCIgKTtcblx0XHRcblx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0ICAgIGxhc3RJZHggPSAwLFxuXHRcdCAgICBtYXRjaDtcblx0XHRcblx0XHR3aGlsZSggbWF0Y2ggPSBzcGxpdFJlZ2V4LmV4ZWMoIHN0ciApICkge1xuXHRcdFx0cmVzdWx0LnB1c2goIHN0ci5zdWJzdHJpbmcoIGxhc3RJZHgsIG1hdGNoLmluZGV4ICkgKTtcblx0XHRcdHJlc3VsdC5wdXNoKCBtYXRjaFsgMCBdICk7ICAvLyBwdXNoIHRoZSBzcGxpdHRpbmcgY2hhcihzKVxuXHRcdFx0XG5cdFx0XHRsYXN0SWR4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFsgMCBdLmxlbmd0aDtcblx0XHR9XG5cdFx0cmVzdWx0LnB1c2goIHN0ci5zdWJzdHJpbmcoIGxhc3RJZHggKSApO1xuXHRcdFxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblx0XG59O1xuLypnbG9iYWwgQXV0b2xpbmtlciAqL1xuLypqc2hpbnQgYm9zczp0cnVlICovXG4vKipcbiAqIEBjbGFzcyBBdXRvbGlua2VyLkh0bWxUYWdcbiAqIEBleHRlbmRzIE9iamVjdFxuICogXG4gKiBSZXByZXNlbnRzIGFuIEhUTUwgdGFnLCB3aGljaCBjYW4gYmUgdXNlZCB0byBlYXNpbHkgYnVpbGQvbW9kaWZ5IEhUTUwgdGFncyBwcm9ncmFtbWF0aWNhbGx5LlxuICogXG4gKiBBdXRvbGlua2VyIHVzZXMgdGhpcyBhYnN0cmFjdGlvbiB0byBjcmVhdGUgSFRNTCB0YWdzLCBhbmQgdGhlbiB3cml0ZSB0aGVtIG91dCBhcyBzdHJpbmdzLiBZb3UgbWF5IGFsc28gdXNlXG4gKiB0aGlzIGNsYXNzIGluIHlvdXIgY29kZSwgZXNwZWNpYWxseSB3aXRoaW4gYSB7QGxpbmsgQXV0b2xpbmtlciNyZXBsYWNlRm4gcmVwbGFjZUZufS5cbiAqIFxuICogIyMgRXhhbXBsZXNcbiAqIFxuICogRXhhbXBsZSBpbnN0YW50aWF0aW9uOlxuICogXG4gKiAgICAgdmFyIHRhZyA9IG5ldyBBdXRvbGlua2VyLkh0bWxUYWcoIHtcbiAqICAgICAgICAgdGFnTmFtZSA6ICdhJyxcbiAqICAgICAgICAgYXR0cnMgICA6IHsgJ2hyZWYnOiAnaHR0cDovL2dvb2dsZS5jb20nLCAnY2xhc3MnOiAnZXh0ZXJuYWwtbGluaycgfSxcbiAqICAgICAgICAgaW5uZXJIdG1sIDogJ0dvb2dsZSdcbiAqICAgICB9ICk7XG4gKiAgICAgXG4gKiAgICAgdGFnLnRvU3RyaW5nKCk7ICAvLyA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIiBjbGFzcz1cImV4dGVybmFsLWxpbmtcIj5Hb29nbGU8L2E+XG4gKiAgICAgXG4gKiAgICAgLy8gSW5kaXZpZHVhbCBhY2Nlc3NvciBtZXRob2RzXG4gKiAgICAgdGFnLmdldFRhZ05hbWUoKTsgICAgICAgICAgICAgICAgIC8vICdhJ1xuICogICAgIHRhZy5nZXRBdHRyKCAnaHJlZicgKTsgICAgICAgICAgICAvLyAnaHR0cDovL2dvb2dsZS5jb20nXG4gKiAgICAgdGFnLmhhc0NsYXNzKCAnZXh0ZXJuYWwtbGluaycgKTsgIC8vIHRydWVcbiAqIFxuICogXG4gKiBVc2luZyBtdXRhdG9yIG1ldGhvZHMgKHdoaWNoIG1heSBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggaW5zdGFudGlhdGlvbiBjb25maWcgcHJvcGVydGllcyk6XG4gKiBcbiAqICAgICB2YXIgdGFnID0gbmV3IEF1dG9saW5rZXIuSHRtbFRhZygpO1xuICogICAgIHRhZy5zZXRUYWdOYW1lKCAnYScgKTtcbiAqICAgICB0YWcuc2V0QXR0ciggJ2hyZWYnLCAnaHR0cDovL2dvb2dsZS5jb20nICk7XG4gKiAgICAgdGFnLmFkZENsYXNzKCAnZXh0ZXJuYWwtbGluaycgKTtcbiAqICAgICB0YWcuc2V0SW5uZXJIdG1sKCAnR29vZ2xlJyApO1xuICogICAgIFxuICogICAgIHRhZy5nZXRUYWdOYW1lKCk7ICAgICAgICAgICAgICAgICAvLyAnYSdcbiAqICAgICB0YWcuZ2V0QXR0ciggJ2hyZWYnICk7ICAgICAgICAgICAgLy8gJ2h0dHA6Ly9nb29nbGUuY29tJ1xuICogICAgIHRhZy5oYXNDbGFzcyggJ2V4dGVybmFsLWxpbmsnICk7ICAvLyB0cnVlXG4gKiAgICAgXG4gKiAgICAgdGFnLnRvU3RyaW5nKCk7ICAvLyA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIiBjbGFzcz1cImV4dGVybmFsLWxpbmtcIj5Hb29nbGU8L2E+XG4gKiAgICAgXG4gKiBcbiAqICMjIEV4YW1wbGUgdXNlIHdpdGhpbiBhIHtAbGluayBBdXRvbGlua2VyI3JlcGxhY2VGbiByZXBsYWNlRm59XG4gKiBcbiAqICAgICB2YXIgaHRtbCA9IEF1dG9saW5rZXIubGluayggXCJUZXN0IGdvb2dsZS5jb21cIiwge1xuICogICAgICAgICByZXBsYWNlRm4gOiBmdW5jdGlvbiggYXV0b2xpbmtlciwgbWF0Y2ggKSB7XG4gKiAgICAgICAgICAgICB2YXIgdGFnID0gYXV0b2xpbmtlci5nZXRUYWdCdWlsZGVyKCkuYnVpbGQoIG1hdGNoICk7ICAvLyByZXR1cm5zIGFuIHtAbGluayBBdXRvbGlua2VyLkh0bWxUYWd9IGluc3RhbmNlLCBjb25maWd1cmVkIHdpdGggdGhlIE1hdGNoJ3MgaHJlZiBhbmQgYW5jaG9yIHRleHRcbiAqICAgICAgICAgICAgIHRhZy5zZXRBdHRyKCAncmVsJywgJ25vZm9sbG93JyApO1xuICogICAgICAgICAgICAgXG4gKiAgICAgICAgICAgICByZXR1cm4gdGFnO1xuICogICAgICAgICB9XG4gKiAgICAgfSApO1xuICogICAgIFxuICogICAgIC8vIGdlbmVyYXRlZCBodG1sOlxuICogICAgIC8vICAgVGVzdCA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub2ZvbGxvd1wiPmdvb2dsZS5jb208L2E+XG4gKiAgICAgXG4gKiAgICAgXG4gKiAjIyBFeGFtcGxlIHVzZSB3aXRoIGEgbmV3IHRhZyBmb3IgdGhlIHJlcGxhY2VtZW50XG4gKiBcbiAqICAgICB2YXIgaHRtbCA9IEF1dG9saW5rZXIubGluayggXCJUZXN0IGdvb2dsZS5jb21cIiwge1xuICogICAgICAgICByZXBsYWNlRm4gOiBmdW5jdGlvbiggYXV0b2xpbmtlciwgbWF0Y2ggKSB7XG4gKiAgICAgICAgICAgICB2YXIgdGFnID0gbmV3IEF1dG9saW5rZXIuSHRtbFRhZygge1xuICogICAgICAgICAgICAgICAgIHRhZ05hbWUgOiAnYnV0dG9uJyxcbiAqICAgICAgICAgICAgICAgICBhdHRycyAgIDogeyAndGl0bGUnOiAnTG9hZCBVUkw6ICcgKyBtYXRjaC5nZXRBbmNob3JIcmVmKCkgfSxcbiAqICAgICAgICAgICAgICAgICBpbm5lckh0bWwgOiAnTG9hZCBVUkw6ICcgKyBtYXRjaC5nZXRBbmNob3JUZXh0KClcbiAqICAgICAgICAgICAgIH0gKTtcbiAqICAgICAgICAgICAgIFxuICogICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAqICAgICAgICAgfVxuICogICAgIH0gKTtcbiAqICAgICBcbiAqICAgICAvLyBnZW5lcmF0ZWQgaHRtbDpcbiAqICAgICAvLyAgIFRlc3QgPGJ1dHRvbiB0aXRsZT1cIkxvYWQgVVJMOiBodHRwOi8vZ29vZ2xlLmNvbVwiPkxvYWQgVVJMOiBnb29nbGUuY29tPC9idXR0b24+XG4gKi9cbkF1dG9saW5rZXIuSHRtbFRhZyA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge1N0cmluZ30gdGFnTmFtZVxuXHQgKiBcblx0ICogVGhlIHRhZyBuYW1lLiBFeDogJ2EnLCAnYnV0dG9uJywgZXRjLlxuXHQgKiBcblx0ICogTm90IHJlcXVpcmVkIGF0IGluc3RhbnRpYXRpb24gdGltZSwgYnV0IHNob3VsZCBiZSBzZXQgdXNpbmcge0BsaW5rICNzZXRUYWdOYW1lfSBiZWZvcmUge0BsaW5rICN0b1N0cmluZ31cblx0ICogaXMgZXhlY3V0ZWQuXG5cdCAqL1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBhdHRyc1xuXHQgKiBcblx0ICogQW4ga2V5L3ZhbHVlIE9iamVjdCAobWFwKSBvZiBhdHRyaWJ1dGVzIHRvIGNyZWF0ZSB0aGUgdGFnIHdpdGguIFRoZSBrZXlzIGFyZSB0aGUgYXR0cmlidXRlIG5hbWVzLCBhbmQgdGhlXG5cdCAqIHZhbHVlcyBhcmUgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMuXG5cdCAqL1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge1N0cmluZ30gaW5uZXJIdG1sXG5cdCAqIFxuXHQgKiBUaGUgaW5uZXIgSFRNTCBmb3IgdGhlIHRhZy4gXG5cdCAqIFxuXHQgKiBOb3RlIHRoZSBjYW1lbCBjYXNlIG5hbWUgb24gYGlubmVySHRtbGAuIEFjcm9ueW1zIGFyZSBjYW1lbENhc2VkIGluIHRoaXMgdXRpbGl0eSAoc3VjaCBhcyBub3QgdG8gcnVuIGludG8gdGhlIGFjcm9ueW0gXG5cdCAqIG5hbWluZyBpbmNvbnNpc3RlbmN5IHRoYXQgdGhlIERPTSBkZXZlbG9wZXJzIGNyZWF0ZWQgd2l0aCBgWE1MSHR0cFJlcXVlc3RgKS4gWW91IG1heSBhbHRlcm5hdGl2ZWx5IHVzZSB7QGxpbmsgI2lubmVySFRNTH1cblx0ICogaWYgeW91IHByZWZlciwgYnV0IHRoaXMgb25lIGlzIHJlY29tbWVuZGVkLlxuXHQgKi9cblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtTdHJpbmd9IGlubmVySFRNTFxuXHQgKiBcblx0ICogQWxpYXMgb2Yge0BsaW5rICNpbm5lckh0bWx9LCBhY2NlcHRlZCBmb3IgY29uc2lzdGVuY3kgd2l0aCB0aGUgYnJvd3NlciBET00gYXBpLCBidXQgcHJlZmVyIHRoZSBjYW1lbENhc2VkIHZlcnNpb25cblx0ICogZm9yIGFjcm9ueW0gbmFtZXMuXG5cdCAqL1xuXHRcblx0XG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSB3aGl0ZXNwYWNlUmVnZXhcblx0ICogXG5cdCAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIG1hdGNoIHdoaXRlc3BhY2UgaW4gYSBzdHJpbmcgb2YgQ1NTIGNsYXNzZXMuXG5cdCAqL1xuXHR3aGl0ZXNwYWNlUmVnZXggOiAvXFxzKy8sXG5cdFxuXHRcblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2NmZ10gVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBmb3IgdGhpcyBjbGFzcywgaW4gYW4gT2JqZWN0IChtYXApXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKCBjZmcgKSB7XG5cdFx0QXV0b2xpbmtlci5VdGlsLmFzc2lnbiggdGhpcywgY2ZnICk7XG5cdFx0XG5cdFx0dGhpcy5pbm5lckh0bWwgPSB0aGlzLmlubmVySHRtbCB8fCB0aGlzLmlubmVySFRNTDsgIC8vIGFjY2VwdCBlaXRoZXIgdGhlIGNhbWVsQ2FzZWQgZm9ybSBvciB0aGUgZnVsbHkgY2FwaXRhbGl6ZWQgYWNyb255bVxuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB0YWcgbmFtZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGFnIHdpdGguXG5cdCAqIFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGFnTmFtZVxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkh0bWxUYWd9IFRoaXMgSHRtbFRhZyBpbnN0YW5jZSwgc28gdGhhdCBtZXRob2QgY2FsbHMgbWF5IGJlIGNoYWluZWQuXG5cdCAqL1xuXHRzZXRUYWdOYW1lIDogZnVuY3Rpb24oIHRhZ05hbWUgKSB7XG5cdFx0dGhpcy50YWdOYW1lID0gdGFnTmFtZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogUmV0cmlldmVzIHRoZSB0YWcgbmFtZS5cblx0ICogXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldFRhZ05hbWUgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50YWdOYW1lIHx8IFwiXCI7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFNldHMgYW4gYXR0cmlidXRlIG9uIHRoZSBIdG1sVGFnLlxuXHQgKiBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGF0dHJOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyVmFsdWUgVGhlIGF0dHJpYnV0ZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhpcyBIdG1sVGFnIGluc3RhbmNlLCBzbyB0aGF0IG1ldGhvZCBjYWxscyBtYXkgYmUgY2hhaW5lZC5cblx0ICovXG5cdHNldEF0dHIgOiBmdW5jdGlvbiggYXR0ck5hbWUsIGF0dHJWYWx1ZSApIHtcblx0XHR2YXIgdGFnQXR0cnMgPSB0aGlzLmdldEF0dHJzKCk7XG5cdFx0dGFnQXR0cnNbIGF0dHJOYW1lIF0gPSBhdHRyVmFsdWU7XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHJpZXZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgSHRtbFRhZy4gSWYgdGhlIGF0dHJpYnV0ZSBkb2VzIG5vdCBleGlzdCwgcmV0dXJucyBgdW5kZWZpbmVkYC5cblx0ICogXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byByZXRyaWV2ZS5cblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgYXR0cmlidXRlJ3MgdmFsdWUsIG9yIGB1bmRlZmluZWRgIGlmIGl0IGRvZXMgbm90IGV4aXN0IG9uIHRoZSBIdG1sVGFnLlxuXHQgKi9cblx0Z2V0QXR0ciA6IGZ1bmN0aW9uKCBhdHRyTmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRBdHRycygpWyBhdHRyTmFtZSBdO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBTZXRzIG9uZSBvciBtb3JlIGF0dHJpYnV0ZXMgb24gdGhlIEh0bWxUYWcuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBhdHRycyBBIGtleS92YWx1ZSBPYmplY3QgKG1hcCkgb2YgdGhlIGF0dHJpYnV0ZXMgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkh0bWxUYWd9IFRoaXMgSHRtbFRhZyBpbnN0YW5jZSwgc28gdGhhdCBtZXRob2QgY2FsbHMgbWF5IGJlIGNoYWluZWQuXG5cdCAqL1xuXHRzZXRBdHRycyA6IGZ1bmN0aW9uKCBhdHRycyApIHtcblx0XHR2YXIgdGFnQXR0cnMgPSB0aGlzLmdldEF0dHJzKCk7XG5cdFx0QXV0b2xpbmtlci5VdGlsLmFzc2lnbiggdGFnQXR0cnMsIGF0dHJzICk7XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgYXR0cmlidXRlcyBPYmplY3QgKG1hcCkgZm9yIHRoZSBIdG1sVGFnLlxuXHQgKiBcblx0ICogQHJldHVybiB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IEEga2V5L3ZhbHVlIG9iamVjdCBvZiB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIEh0bWxUYWcuXG5cdCAqL1xuXHRnZXRBdHRycyA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmF0dHJzIHx8ICggdGhpcy5hdHRycyA9IHt9ICk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFNldHMgdGhlIHByb3ZpZGVkIGBjc3NDbGFzc2AsIG92ZXJ3cml0aW5nIGFueSBjdXJyZW50IENTUyBjbGFzc2VzIG9uIHRoZSBIdG1sVGFnLlxuXHQgKiBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNzc0NsYXNzIE9uZSBvciBtb3JlIHNwYWNlLXNlcGFyYXRlZCBDU1MgY2xhc3NlcyB0byBzZXQgKG92ZXJ3cml0ZSkuXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhpcyBIdG1sVGFnIGluc3RhbmNlLCBzbyB0aGF0IG1ldGhvZCBjYWxscyBtYXkgYmUgY2hhaW5lZC5cblx0ICovXG5cdHNldENsYXNzIDogZnVuY3Rpb24oIGNzc0NsYXNzICkge1xuXHRcdHJldHVybiB0aGlzLnNldEF0dHIoICdjbGFzcycsIGNzc0NsYXNzICk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhZGQgb25lIG9yIG1vcmUgQ1NTIGNsYXNzZXMgdG8gdGhlIEh0bWxUYWcuIFdpbGwgbm90IGFkZCBkdXBsaWNhdGUgQ1NTIGNsYXNzZXMuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY3NzQ2xhc3MgT25lIG9yIG1vcmUgc3BhY2Utc2VwYXJhdGVkIENTUyBjbGFzc2VzIHRvIGFkZC5cblx0ICogQHJldHVybiB7QXV0b2xpbmtlci5IdG1sVGFnfSBUaGlzIEh0bWxUYWcgaW5zdGFuY2UsIHNvIHRoYXQgbWV0aG9kIGNhbGxzIG1heSBiZSBjaGFpbmVkLlxuXHQgKi9cblx0YWRkQ2xhc3MgOiBmdW5jdGlvbiggY3NzQ2xhc3MgKSB7XG5cdFx0dmFyIGNsYXNzQXR0ciA9IHRoaXMuZ2V0Q2xhc3MoKSxcblx0XHQgICAgd2hpdGVzcGFjZVJlZ2V4ID0gdGhpcy53aGl0ZXNwYWNlUmVnZXgsXG5cdFx0ICAgIGluZGV4T2YgPSBBdXRvbGlua2VyLlV0aWwuaW5kZXhPZiwgIC8vIHRvIHN1cHBvcnQgSUU4IGFuZCBiZWxvd1xuXHRcdCAgICBjbGFzc2VzID0gKCAhY2xhc3NBdHRyICkgPyBbXSA6IGNsYXNzQXR0ci5zcGxpdCggd2hpdGVzcGFjZVJlZ2V4ICksXG5cdFx0ICAgIG5ld0NsYXNzZXMgPSBjc3NDbGFzcy5zcGxpdCggd2hpdGVzcGFjZVJlZ2V4ICksXG5cdFx0ICAgIG5ld0NsYXNzO1xuXHRcdFxuXHRcdHdoaWxlKCBuZXdDbGFzcyA9IG5ld0NsYXNzZXMuc2hpZnQoKSApIHtcblx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBuZXdDbGFzcyApID09PSAtMSApIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKCBuZXdDbGFzcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHR0aGlzLmdldEF0dHJzKClbICdjbGFzcycgXSA9IGNsYXNzZXMuam9pbiggXCIgXCIgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSBvbmUgb3IgbW9yZSBDU1MgY2xhc3NlcyBmcm9tIHRoZSBIdG1sVGFnLlxuXHQgKiBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNzc0NsYXNzIE9uZSBvciBtb3JlIHNwYWNlLXNlcGFyYXRlZCBDU1MgY2xhc3NlcyB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhpcyBIdG1sVGFnIGluc3RhbmNlLCBzbyB0aGF0IG1ldGhvZCBjYWxscyBtYXkgYmUgY2hhaW5lZC5cblx0ICovXG5cdHJlbW92ZUNsYXNzIDogZnVuY3Rpb24oIGNzc0NsYXNzICkge1xuXHRcdHZhciBjbGFzc0F0dHIgPSB0aGlzLmdldENsYXNzKCksXG5cdFx0ICAgIHdoaXRlc3BhY2VSZWdleCA9IHRoaXMud2hpdGVzcGFjZVJlZ2V4LFxuXHRcdCAgICBpbmRleE9mID0gQXV0b2xpbmtlci5VdGlsLmluZGV4T2YsICAvLyB0byBzdXBwb3J0IElFOCBhbmQgYmVsb3dcblx0XHQgICAgY2xhc3NlcyA9ICggIWNsYXNzQXR0ciApID8gW10gOiBjbGFzc0F0dHIuc3BsaXQoIHdoaXRlc3BhY2VSZWdleCApLFxuXHRcdCAgICByZW1vdmVDbGFzc2VzID0gY3NzQ2xhc3Muc3BsaXQoIHdoaXRlc3BhY2VSZWdleCApLFxuXHRcdCAgICByZW1vdmVDbGFzcztcblx0XHRcblx0XHR3aGlsZSggY2xhc3Nlcy5sZW5ndGggJiYgKCByZW1vdmVDbGFzcyA9IHJlbW92ZUNsYXNzZXMuc2hpZnQoKSApICkge1xuXHRcdFx0dmFyIGlkeCA9IGluZGV4T2YoIGNsYXNzZXMsIHJlbW92ZUNsYXNzICk7XG5cdFx0XHRpZiggaWR4ICE9PSAtMSApIHtcblx0XHRcdFx0Y2xhc3Nlcy5zcGxpY2UoIGlkeCwgMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHR0aGlzLmdldEF0dHJzKClbICdjbGFzcycgXSA9IGNsYXNzZXMuam9pbiggXCIgXCIgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHJpZXZlIHRoZSBDU1MgY2xhc3MoZXMpIGZvciB0aGUgSHRtbFRhZywgd2hpY2ggd2lsbCBlYWNoIGJlIHNlcGFyYXRlZCBieSBzcGFjZXMgd2hlblxuXHQgKiB0aGVyZSBhcmUgbXVsdGlwbGUuXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRDbGFzcyA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEF0dHJzKClbICdjbGFzcycgXSB8fCBcIlwiO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gY2hlY2sgaWYgdGhlIHRhZyBoYXMgYSBDU1MgY2xhc3Mgb3Igbm90LlxuXHQgKiBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNzc0NsYXNzIFRoZSBDU1MgY2xhc3MgdG8gY2hlY2sgZm9yLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIEh0bWxUYWcgaGFzIHRoZSBDU1MgY2xhc3MsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuXHQgKi9cblx0aGFzQ2xhc3MgOiBmdW5jdGlvbiggY3NzQ2xhc3MgKSB7XG5cdFx0cmV0dXJuICggJyAnICsgdGhpcy5nZXRDbGFzcygpICsgJyAnICkuaW5kZXhPZiggJyAnICsgY3NzQ2xhc3MgKyAnICcgKSAhPT0gLTE7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFNldHMgdGhlIGlubmVyIEhUTUwgZm9yIHRoZSB0YWcuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCBUaGUgaW5uZXIgSFRNTCB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhpcyBIdG1sVGFnIGluc3RhbmNlLCBzbyB0aGF0IG1ldGhvZCBjYWxscyBtYXkgYmUgY2hhaW5lZC5cblx0ICovXG5cdHNldElubmVySHRtbCA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHRoaXMuaW5uZXJIdG1sID0gaHRtbDtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogUmV0cmlldmVzIHRoZSBpbm5lciBIVE1MIGZvciB0aGUgdGFnLlxuXHQgKiBcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0SW5uZXJIdG1sIDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5uZXJIdG1sIHx8IFwiXCI7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIE92ZXJyaWRlIG9mIHN1cGVyY2xhc3MgbWV0aG9kIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIEhUTUwgc3RyaW5nIGZvciB0aGUgdGFnLlxuXHQgKiBcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcgOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGFnTmFtZSA9IHRoaXMuZ2V0VGFnTmFtZSgpLFxuXHRcdCAgICBhdHRyc1N0ciA9IHRoaXMuYnVpbGRBdHRyc1N0cigpO1xuXHRcdFxuXHRcdGF0dHJzU3RyID0gKCBhdHRyc1N0ciApID8gJyAnICsgYXR0cnNTdHIgOiAnJzsgIC8vIHByZXBlbmQgYSBzcGFjZSBpZiB0aGVyZSBhcmUgYWN0dWFsbHkgYXR0cmlidXRlc1xuXHRcdFxuXHRcdHJldHVybiBbICc8JywgdGFnTmFtZSwgYXR0cnNTdHIsICc+JywgdGhpcy5nZXRJbm5lckh0bWwoKSwgJzwvJywgdGFnTmFtZSwgJz4nIF0uam9pbiggXCJcIiApO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBTdXBwb3J0IG1ldGhvZCBmb3Ige0BsaW5rICN0b1N0cmluZ30sIHJldHVybnMgdGhlIHN0cmluZyBzcGFjZS1zZXBhcmF0ZWQga2V5PVwidmFsdWVcIiBwYWlycywgdXNlZCB0byBwb3B1bGF0ZSBcblx0ICogdGhlIHN0cmluZ2lmaWVkIEh0bWxUYWcuXG5cdCAqIFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gRXhhbXBsZSByZXR1cm46IGBhdHRyMT1cInZhbHVlMVwiIGF0dHIyPVwidmFsdWUyXCJgXG5cdCAqL1xuXHRidWlsZEF0dHJzU3RyIDogZnVuY3Rpb24oKSB7XG5cdFx0aWYoICF0aGlzLmF0dHJzICkgcmV0dXJuIFwiXCI7ICAvLyBubyBgYXR0cnNgIE9iamVjdCAobWFwKSBoYXMgYmVlbiBzZXQsIHJldHVybiBlbXB0eSBzdHJpbmdcblx0XHRcblx0XHR2YXIgYXR0cnMgPSB0aGlzLmdldEF0dHJzKCksXG5cdFx0ICAgIGF0dHJzQXJyID0gW107XG5cdFx0XG5cdFx0Zm9yKCB2YXIgcHJvcCBpbiBhdHRycyApIHtcblx0XHRcdGlmKCBhdHRycy5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkge1xuXHRcdFx0XHRhdHRyc0Fyci5wdXNoKCBwcm9wICsgJz1cIicgKyBhdHRyc1sgcHJvcCBdICsgJ1wiJyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYXR0cnNBcnIuam9pbiggXCIgXCIgKTtcblx0fVxuXHRcbn0gKTtcbi8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cbi8qanNoaW50IHN1Yjp0cnVlICovXG4vKipcbiAqIEBwcm90ZWN0ZWRcbiAqIEBjbGFzcyBBdXRvbGlua2VyLkFuY2hvclRhZ0J1aWxkZXJcbiAqIEBleHRlbmRzIE9iamVjdFxuICogXG4gKiBCdWlsZHMgYW5jaG9yICgmbHQ7YSZndDspIHRhZ3MgZm9yIHRoZSBBdXRvbGlua2VyIHV0aWxpdHkgd2hlbiBhIG1hdGNoIGlzIGZvdW5kLlxuICogXG4gKiBOb3JtYWxseSB0aGlzIGNsYXNzIGlzIGluc3RhbnRpYXRlZCwgY29uZmlndXJlZCwgYW5kIHVzZWQgaW50ZXJuYWxseSBieSBhbiB7QGxpbmsgQXV0b2xpbmtlcn0gaW5zdGFuY2UsIGJ1dCBtYXkgXG4gKiBhY3R1YWxseSBiZSByZXRyaWV2ZWQgaW4gYSB7QGxpbmsgQXV0b2xpbmtlciNyZXBsYWNlRm4gcmVwbGFjZUZufSB0byBjcmVhdGUge0BsaW5rIEF1dG9saW5rZXIuSHRtbFRhZyBIdG1sVGFnfSBpbnN0YW5jZXNcbiAqIHdoaWNoIG1heSBiZSBtb2RpZmllZCBiZWZvcmUgcmV0dXJuaW5nIGZyb20gdGhlIHtAbGluayBBdXRvbGlua2VyI3JlcGxhY2VGbiByZXBsYWNlRm59LiBGb3IgZXhhbXBsZTpcbiAqIFxuICogICAgIHZhciBodG1sID0gQXV0b2xpbmtlci5saW5rKCBcIlRlc3QgZ29vZ2xlLmNvbVwiLCB7XG4gKiAgICAgICAgIHJlcGxhY2VGbiA6IGZ1bmN0aW9uKCBhdXRvbGlua2VyLCBtYXRjaCApIHtcbiAqICAgICAgICAgICAgIHZhciB0YWcgPSBhdXRvbGlua2VyLmdldFRhZ0J1aWxkZXIoKS5idWlsZCggbWF0Y2ggKTsgIC8vIHJldHVybnMgYW4ge0BsaW5rIEF1dG9saW5rZXIuSHRtbFRhZ30gaW5zdGFuY2VcbiAqICAgICAgICAgICAgIHRhZy5zZXRBdHRyKCAncmVsJywgJ25vZm9sbG93JyApO1xuICogICAgICAgICAgICAgXG4gKiAgICAgICAgICAgICByZXR1cm4gdGFnO1xuICogICAgICAgICB9XG4gKiAgICAgfSApO1xuICogICAgIFxuICogICAgIC8vIGdlbmVyYXRlZCBodG1sOlxuICogICAgIC8vICAgVGVzdCA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub2ZvbGxvd1wiPmdvb2dsZS5jb208L2E+XG4gKi9cbkF1dG9saW5rZXIuQW5jaG9yVGFnQnVpbGRlciA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge0Jvb2xlYW59IG5ld1dpbmRvd1xuXHQgKiBAaW5oZXJpdGRvYyBBdXRvbGlua2VyI25ld1dpbmRvd1xuXHQgKi9cblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtOdW1iZXJ9IHRydW5jYXRlXG5cdCAqIEBpbmhlcml0ZG9jIEF1dG9saW5rZXIjdHJ1bmNhdGVcblx0ICovXG5cdFxuXHQvKipcblx0ICogQGNmZyB7U3RyaW5nfSBjbGFzc05hbWVcblx0ICogQGluaGVyaXRkb2MgQXV0b2xpbmtlciNjbGFzc05hbWVcblx0ICovXG5cdFxuXHRcblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2NmZ10gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIEFuY2hvclRhZ0J1aWxkZXIgaW5zdGFuY2UsIHNwZWNpZmllZCBpbiBhbiBPYmplY3QgKG1hcCkuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKCBjZmcgKSB7XG5cdFx0QXV0b2xpbmtlci5VdGlsLmFzc2lnbiggdGhpcywgY2ZnICk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIEdlbmVyYXRlcyB0aGUgYWN0dWFsIGFuY2hvciAoJmx0O2EmZ3Q7KSB0YWcgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBtYXRjaGVkIFVSTC9lbWFpbC9Ud2l0dGVyIHRleHQsXG5cdCAqIHZpYSBpdHMgYG1hdGNoYCBvYmplY3QuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge0F1dG9saW5rZXIubWF0Y2guTWF0Y2h9IG1hdGNoIFRoZSBNYXRjaCBpbnN0YW5jZSB0byBnZW5lcmF0ZSBhbiBhbmNob3IgdGFnIGZyb20uXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhlIEh0bWxUYWcgaW5zdGFuY2UgZm9yIHRoZSBhbmNob3IgdGFnLlxuXHQgKi9cblx0YnVpbGQgOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0dmFyIHRhZyA9IG5ldyBBdXRvbGlua2VyLkh0bWxUYWcoIHtcblx0XHRcdHRhZ05hbWUgICA6ICdhJyxcblx0XHRcdGF0dHJzICAgICA6IHRoaXMuY3JlYXRlQXR0cnMoIG1hdGNoLmdldFR5cGUoKSwgbWF0Y2guZ2V0QW5jaG9ySHJlZigpICksXG5cdFx0XHRpbm5lckh0bWwgOiB0aGlzLnByb2Nlc3NBbmNob3JUZXh0KCBtYXRjaC5nZXRBbmNob3JUZXh0KCkgKVxuXHRcdH0gKTtcblx0XHRcblx0XHRyZXR1cm4gdGFnO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBDcmVhdGVzIHRoZSBPYmplY3QgKG1hcCkgb2YgdGhlIEhUTUwgYXR0cmlidXRlcyBmb3IgdGhlIGFuY2hvciAoJmx0O2EmZ3Q7KSB0YWcgYmVpbmcgZ2VuZXJhdGVkLlxuXHQgKiBcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge1widXJsXCIvXCJlbWFpbFwiL1widHdpdHRlclwifSBtYXRjaFR5cGUgVGhlIHR5cGUgb2YgbWF0Y2ggdGhhdCBhbiBhbmNob3IgdGFnIGlzIGJlaW5nIGdlbmVyYXRlZCBmb3IuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBocmVmIFRoZSBocmVmIGZvciB0aGUgYW5jaG9yIHRhZy5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBIGtleS92YWx1ZSBPYmplY3QgKG1hcCkgb2YgdGhlIGFuY2hvciB0YWcncyBhdHRyaWJ1dGVzLiBcblx0ICovXG5cdGNyZWF0ZUF0dHJzIDogZnVuY3Rpb24oIG1hdGNoVHlwZSwgYW5jaG9ySHJlZiApIHtcblx0XHR2YXIgYXR0cnMgPSB7XG5cdFx0XHQnaHJlZicgOiBhbmNob3JIcmVmICAvLyB3ZSdsbCBhbHdheXMgaGF2ZSB0aGUgYGhyZWZgIGF0dHJpYnV0ZVxuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGNzc0NsYXNzID0gdGhpcy5jcmVhdGVDc3NDbGFzcyggbWF0Y2hUeXBlICk7XG5cdFx0aWYoIGNzc0NsYXNzICkge1xuXHRcdFx0YXR0cnNbICdjbGFzcycgXSA9IGNzc0NsYXNzO1xuXHRcdH1cblx0XHRpZiggdGhpcy5uZXdXaW5kb3cgKSB7XG5cdFx0XHRhdHRyc1sgJ3RhcmdldCcgXSA9IFwiX2JsYW5rXCI7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBhdHRycztcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyB0aGUgQ1NTIGNsYXNzIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhIGdpdmVuIGFuY2hvciB0YWcsIGJhc2VkIG9uIHRoZSBgbWF0Y2hUeXBlYCBhbmQgdGhlIHtAbGluayAjY2xhc3NOYW1lfVxuXHQgKiBjb25maWcuXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1widXJsXCIvXCJlbWFpbFwiL1widHdpdHRlclwifSBtYXRjaFR5cGUgVGhlIHR5cGUgb2YgbWF0Y2ggdGhhdCBhbiBhbmNob3IgdGFnIGlzIGJlaW5nIGdlbmVyYXRlZCBmb3IuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIENTUyBjbGFzcyBzdHJpbmcgZm9yIHRoZSBsaW5rLiBFeGFtcGxlIHJldHVybjogXCJteUxpbmsgbXlMaW5rLXVybFwiLiBJZiBubyB7QGxpbmsgI2NsYXNzTmFtZX1cblx0ICogICB3YXMgY29uZmlndXJlZCwgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG5cdCAqL1xuXHRjcmVhdGVDc3NDbGFzcyA6IGZ1bmN0aW9uKCBtYXRjaFR5cGUgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuXHRcdFxuXHRcdGlmKCAhY2xhc3NOYW1lICkgXG5cdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc05hbWUgKyBcIi1cIiArIG1hdGNoVHlwZTsgIC8vIGV4OiBcIm15TGluayBteUxpbmstdXJsXCIsIFwibXlMaW5rIG15TGluay1lbWFpbFwiLCBvciBcIm15TGluayBteUxpbmstdHdpdHRlclwiXG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFByb2Nlc3NlcyB0aGUgYGFuY2hvclRleHRgIGJ5IHRydW5jYXRpbmcgdGhlIHRleHQgYWNjb3JkaW5nIHRvIHRoZSB7QGxpbmsgI3RydW5jYXRlfSBjb25maWcuXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYW5jaG9yVGV4dCBUaGUgYW5jaG9yIHRhZydzIHRleHQgKGkuZS4gd2hhdCB3aWxsIGJlIGRpc3BsYXllZCkuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHByb2Nlc3NlZCBgYW5jaG9yVGV4dGAuXG5cdCAqL1xuXHRwcm9jZXNzQW5jaG9yVGV4dCA6IGZ1bmN0aW9uKCBhbmNob3JUZXh0ICkge1xuXHRcdGFuY2hvclRleHQgPSB0aGlzLmRvVHJ1bmNhdGUoIGFuY2hvclRleHQgKTtcblx0XHRcblx0XHRyZXR1cm4gYW5jaG9yVGV4dDtcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogUGVyZm9ybXMgdGhlIHRydW5jYXRpb24gb2YgdGhlIGBhbmNob3JUZXh0YCwgaWYgdGhlIGBhbmNob3JUZXh0YCBpcyBsb25nZXIgdGhhbiB0aGUge0BsaW5rICN0cnVuY2F0ZX0gb3B0aW9uLlxuXHQgKiBUcnVuY2F0ZXMgdGhlIHRleHQgdG8gMiBjaGFyYWN0ZXJzIGZld2VyIHRoYW4gdGhlIHtAbGluayAjdHJ1bmNhdGV9IG9wdGlvbiwgYW5kIGFkZHMgXCIuLlwiIHRvIHRoZSBlbmQuXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgYW5jaG9yIHRhZydzIHRleHQgKGkuZS4gd2hhdCB3aWxsIGJlIGRpc3BsYXllZCkuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHRydW5jYXRlZCBhbmNob3IgdGV4dC5cblx0ICovXG5cdGRvVHJ1bmNhdGUgOiBmdW5jdGlvbiggYW5jaG9yVGV4dCApIHtcblx0XHRyZXR1cm4gQXV0b2xpbmtlci5VdGlsLmVsbGlwc2lzKCBhbmNob3JUZXh0LCB0aGlzLnRydW5jYXRlIHx8IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSApO1xuXHR9XG5cdFxufSApO1xuLypnbG9iYWwgQXV0b2xpbmtlciAqL1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGNsYXNzIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sUGFyc2VyXG4gKiBAZXh0ZW5kcyBPYmplY3RcbiAqIFxuICogQW4gSFRNTCBwYXJzZXIgaW1wbGVtZW50YXRpb24gd2hpY2ggc2ltcGx5IHdhbGtzIGFuIEhUTUwgc3RyaW5nIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIFxuICoge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZSBIdG1sTm9kZXN9IHRoYXQgcmVwcmVzZW50IHRoZSBiYXNpYyBIVE1MIHN0cnVjdHVyZSBvZiB0aGUgaW5wdXQgc3RyaW5nLlxuICogXG4gKiBBdXRvbGlua2VyIHVzZXMgdGhpcyB0byBvbmx5IGxpbmsgVVJMcy9lbWFpbHMvVHdpdHRlciBoYW5kbGVzIHdpdGhpbiB0ZXh0IG5vZGVzLCBlZmZlY3RpdmVseSBpZ25vcmluZyAvIFwid2Fsa2luZ1xuICogYXJvdW5kXCIgSFRNTCB0YWdzLlxuICovXG5BdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbFBhcnNlciA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xuXHRcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBodG1sUmVnZXhcblx0ICogXG5cdCAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBwdWxsIG91dCBIVE1MIHRhZ3MgZnJvbSBhIHN0cmluZy4gSGFuZGxlcyBuYW1lc3BhY2VkIEhUTUwgdGFncyBhbmRcblx0ICogYXR0cmlidXRlIG5hbWVzLCBhcyBzcGVjaWZpZWQgYnkgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1tYXJrdXAvc3ludGF4Lmh0bWwuXG5cdCAqIFxuXHQgKiBDYXB0dXJpbmcgZ3JvdXBzOlxuXHQgKiBcblx0ICogMS4gVGhlIFwiIURPQ1RZUEVcIiB0YWcgbmFtZSwgaWYgYSB0YWcgaXMgYSAmbHQ7IURPQ1RZUEUmZ3Q7IHRhZy5cblx0ICogMi4gSWYgaXQgaXMgYW4gZW5kIHRhZywgdGhpcyBncm91cCB3aWxsIGhhdmUgdGhlICcvJy5cblx0ICogMy4gVGhlIHRhZyBuYW1lIGZvciBhbGwgdGFncyAob3RoZXIgdGhhbiB0aGUgJmx0OyFET0NUWVBFJmd0OyB0YWcpXG5cdCAqL1xuXHRodG1sUmVnZXggOiAoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRhZ05hbWVSZWdleCA9IC9bMC05YS16QS1aXVswLTlhLXpBLVo6XSovLFxuXHRcdCAgICBhdHRyTmFtZVJlZ2V4ID0gL1teXFxzXFwwXCInPlxcLz1cXHgwMS1cXHgxRlxceDdGXSsvLCAgIC8vIHRoZSB1bmljb2RlIHJhbmdlIGFjY291bnRzIGZvciBleGNsdWRpbmcgY29udHJvbCBjaGFycywgYW5kIHRoZSBkZWxldGUgY2hhclxuXHRcdCAgICBhdHRyVmFsdWVSZWdleCA9IC8oPzpcIlteXCJdKj9cInwnW14nXSo/J3xbXidcIj08PmBcXHNdKykvLCAvLyBkb3VibGUgcXVvdGVkLCBzaW5nbGUgcXVvdGVkLCBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVzXG5cdFx0ICAgIG5hbWVFcXVhbHNWYWx1ZVJlZ2V4ID0gYXR0ck5hbWVSZWdleC5zb3VyY2UgKyAnKD86XFxcXHMqPVxcXFxzKicgKyBhdHRyVmFsdWVSZWdleC5zb3VyY2UgKyAnKT8nOyAgLy8gb3B0aW9uYWwgJz1bdmFsdWVdJ1xuXHRcdFxuXHRcdHJldHVybiBuZXcgUmVnRXhwKCBbXG5cdFx0XHQvLyBmb3IgPCFET0NUWVBFPiB0YWcuIEV4OiA8IURPQ1RZUEUgaHRtbCBQVUJMSUMgXCItLy9XM0MvL0RURCBYSFRNTCAxLjAgU3RyaWN0Ly9FTlwiIFwiaHR0cDovL3d3dy53My5vcmcvVFIveGh0bWwxL0RURC94aHRtbDEtc3RyaWN0LmR0ZFwiPikgXG5cdFx0XHQnKD86Jyxcblx0XHRcdFx0JzwoIURPQ1RZUEUpJywgIC8vICoqKiBDYXB0dXJpbmcgR3JvdXAgMSAtIElmIGl0J3MgYSBkb2N0eXBlIHRhZ1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFplcm8gb3IgbW9yZSBhdHRyaWJ1dGVzIGZvbGxvd2luZyB0aGUgdGFnIG5hbWVcblx0XHRcdFx0XHQnKD86Jyxcblx0XHRcdFx0XHRcdCdcXFxccysnLCAgLy8gb25lIG9yIG1vcmUgd2hpdGVzcGFjZSBjaGFycyBiZWZvcmUgYW4gYXR0cmlidXRlXG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIEVpdGhlcjpcblx0XHRcdFx0XHRcdC8vIEEuIGF0dHI9XCJ2YWx1ZVwiLCBvciBcblx0XHRcdFx0XHRcdC8vIEIuIFwidmFsdWVcIiBhbG9uZSAoVG8gY292ZXIgZXhhbXBsZSBkb2N0eXBlIHRhZzogPCFET0NUWVBFIGh0bWwgUFVCTElDIFwiLS8vVzNDLy9EVEQgWEhUTUwgMS4wIFN0cmljdC8vRU5cIiBcImh0dHA6Ly93d3cudzMub3JnL1RSL3hodG1sMS9EVEQveGh0bWwxLXN0cmljdC5kdGRcIj4pIFxuXHRcdFx0XHRcdFx0Jyg/OicsIG5hbWVFcXVhbHNWYWx1ZVJlZ2V4LCAnfCcsIGF0dHJWYWx1ZVJlZ2V4LnNvdXJjZSArICcpJyxcblx0XHRcdFx0XHQnKSonLFxuXHRcdFx0XHQnPicsXG5cdFx0XHQnKScsXG5cdFx0XHRcblx0XHRcdCd8Jyxcblx0XHRcdFxuXHRcdFx0Ly8gQWxsIG90aGVyIEhUTUwgdGFncyAoaS5lLiB0YWdzIHRoYXQgYXJlIG5vdCA8IURPQ1RZUEU+KVxuXHRcdFx0Jyg/OicsXG5cdFx0XHRcdCc8KC8pPycsICAvLyBCZWdpbm5pbmcgb2YgYSB0YWcuIEVpdGhlciAnPCcgZm9yIGEgc3RhcnQgdGFnLCBvciAnPC8nIGZvciBhbiBlbmQgdGFnLiBcblx0XHRcdFx0ICAgICAgICAgIC8vICoqKiBDYXB0dXJpbmcgR3JvdXAgMjogVGhlIHNsYXNoIG9yIGFuIGVtcHR5IHN0cmluZy4gU2xhc2ggKCcvJykgZm9yIGVuZCB0YWcsIGVtcHR5IHN0cmluZyBmb3Igc3RhcnQgb3Igc2VsZi1jbG9zaW5nIHRhZy5cblx0XHRcdFxuXHRcdFx0XHRcdC8vICoqKiBDYXB0dXJpbmcgR3JvdXAgMyAtIFRoZSB0YWcgbmFtZVxuXHRcdFx0XHRcdCcoJyArIHRhZ05hbWVSZWdleC5zb3VyY2UgKyAnKScsXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gWmVybyBvciBtb3JlIGF0dHJpYnV0ZXMgZm9sbG93aW5nIHRoZSB0YWcgbmFtZVxuXHRcdFx0XHRcdCcoPzonLFxuXHRcdFx0XHRcdFx0J1xcXFxzKycsICAgICAgICAgICAgICAgIC8vIG9uZSBvciBtb3JlIHdoaXRlc3BhY2UgY2hhcnMgYmVmb3JlIGFuIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdFx0bmFtZUVxdWFsc1ZhbHVlUmVnZXgsICAvLyBhdHRyPVwidmFsdWVcIiAod2l0aCBvcHRpb25hbCA9XCJ2YWx1ZVwiIHBhcnQpXG5cdFx0XHRcdFx0JykqJyxcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQnXFxcXHMqLz8nLCAgLy8gYW55IHRyYWlsaW5nIHNwYWNlcyBhbmQgb3B0aW9uYWwgJy8nIGJlZm9yZSB0aGUgY2xvc2luZyAnPidcblx0XHRcdFx0Jz4nLFxuXHRcdFx0JyknXG5cdFx0XS5qb2luKCBcIlwiICksICdnaScgKTtcblx0fSApKCksXG5cdFxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHByb3BlcnR5IHtSZWdFeHB9IGh0bWxDaGFyYWN0ZXJFbnRpdGllc1JlZ2V4XG5cdCAqXG5cdCAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGNvbW1vbiBIVE1MIGNoYXJhY3RlciBlbnRpdGllcy5cblx0ICogXG5cdCAqIElnbm9yaW5nICZhbXA7IGFzIGl0IGNvdWxkIGJlIHBhcnQgb2YgYSBxdWVyeSBzdHJpbmcgLS0gaGFuZGxpbmcgaXQgc2VwYXJhdGVseS5cblx0ICovXG5cdGh0bWxDaGFyYWN0ZXJFbnRpdGllc1JlZ2V4OiAvKCZuYnNwO3wmIzE2MDt8Jmx0O3wmIzYwO3wmZ3Q7fCYjNjI7fCZxdW90O3wmIzM0O3wmIzM5OykvZ2ksXG5cdFxuXHRcblx0LyoqXG5cdCAqIFBhcnNlcyBhbiBIVE1MIHN0cmluZyBhbmQgcmV0dXJucyBhIHNpbXBsZSBhcnJheSBvZiB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxOb2RlIEh0bWxOb2Rlc30gdG8gcmVwcmVzZW50XG5cdCAqIHRoZSBIVE1MIHN0cnVjdHVyZSBvZiB0aGUgaW5wdXQgc3RyaW5nLiBcblx0ICogXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIFRoZSBIVE1MIHRvIHBhcnNlLlxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGVbXX1cblx0ICovXG5cdHBhcnNlIDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxSZWdleCA9IHRoaXMuaHRtbFJlZ2V4LFxuXHRcdCAgICBjdXJyZW50UmVzdWx0LFxuXHRcdCAgICBsYXN0SW5kZXggPSAwLFxuXHRcdCAgICB0ZXh0QW5kRW50aXR5Tm9kZXMsXG5cdFx0ICAgIG5vZGVzID0gW107ICAvLyB3aWxsIGJlIHRoZSByZXN1bHQgb2YgdGhlIG1ldGhvZFxuXHRcdFxuXHRcdHdoaWxlKCAoIGN1cnJlbnRSZXN1bHQgPSBodG1sUmVnZXguZXhlYyggaHRtbCApICkgIT09IG51bGwgKSB7XG5cdFx0XHR2YXIgdGFnVGV4dCA9IGN1cnJlbnRSZXN1bHRbIDAgXSxcblx0XHRcdCAgICB0YWdOYW1lID0gY3VycmVudFJlc3VsdFsgMSBdIHx8IGN1cnJlbnRSZXN1bHRbIDMgXSwgIC8vIFRoZSA8IURPQ1RZUEU+IHRhZyAoZXg6IFwiIURPQ1RZUEVcIiksIG9yIGFub3RoZXIgdGFnIChleDogXCJhXCIgb3IgXCJpbWdcIikgXG5cdFx0XHQgICAgaXNDbG9zaW5nVGFnID0gISFjdXJyZW50UmVzdWx0WyAyIF0sXG5cdFx0XHQgICAgaW5CZXR3ZWVuVGFnc1RleHQgPSBodG1sLnN1YnN0cmluZyggbGFzdEluZGV4LCBjdXJyZW50UmVzdWx0LmluZGV4ICk7XG5cdFx0XHRcblx0XHRcdC8vIFB1c2ggVGV4dE5vZGVzIGFuZCBFbnRpdHlOb2RlcyBmb3IgYW55IHRleHQgZm91bmQgYmV0d2VlbiB0YWdzXG5cdFx0XHRpZiggaW5CZXR3ZWVuVGFnc1RleHQgKSB7XG5cdFx0XHRcdHRleHRBbmRFbnRpdHlOb2RlcyA9IHRoaXMucGFyc2VUZXh0QW5kRW50aXR5Tm9kZXMoIGluQmV0d2VlblRhZ3NUZXh0ICk7XG5cdFx0XHRcdG5vZGVzLnB1c2guYXBwbHkoIG5vZGVzLCB0ZXh0QW5kRW50aXR5Tm9kZXMgKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gUHVzaCB0aGUgRWxlbWVudE5vZGVcblx0XHRcdG5vZGVzLnB1c2goIHRoaXMuY3JlYXRlRWxlbWVudE5vZGUoIHRhZ1RleHQsIHRhZ05hbWUsIGlzQ2xvc2luZ1RhZyApICk7XG5cdFx0XHRcblx0XHRcdGxhc3RJbmRleCA9IGN1cnJlbnRSZXN1bHQuaW5kZXggKyB0YWdUZXh0Lmxlbmd0aDtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gUHJvY2VzcyBhbnkgcmVtYWluaW5nIHRleHQgYWZ0ZXIgdGhlIGxhc3QgSFRNTCBlbGVtZW50LiBXaWxsIHByb2Nlc3MgYWxsIG9mIHRoZSB0ZXh0IGlmIHRoZXJlIHdlcmUgbm8gSFRNTCBlbGVtZW50cy5cblx0XHRpZiggbGFzdEluZGV4IDwgaHRtbC5sZW5ndGggKSB7XG5cdFx0XHR2YXIgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKCBsYXN0SW5kZXggKTtcblx0XHRcdFxuXHRcdFx0Ly8gUHVzaCBUZXh0Tm9kZXMgYW5kIEVudGl0eU5vZGVzIGZvciBhbnkgdGV4dCBmb3VuZCBiZXR3ZWVuIHRhZ3Ncblx0XHRcdGlmKCB0ZXh0ICkge1xuXHRcdFx0XHR0ZXh0QW5kRW50aXR5Tm9kZXMgPSB0aGlzLnBhcnNlVGV4dEFuZEVudGl0eU5vZGVzKCB0ZXh0ICk7XG5cdFx0XHRcdG5vZGVzLnB1c2guYXBwbHkoIG5vZGVzLCB0ZXh0QW5kRW50aXR5Tm9kZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG5vZGVzO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBQYXJzZXMgdGV4dCBhbmQgSFRNTCBlbnRpdHkgbm9kZXMgZnJvbSBhIGdpdmVuIHN0cmluZy4gVGhlIGlucHV0IHN0cmluZyBzaG91bGQgbm90IGhhdmUgYW55IEhUTUwgdGFncyAoZWxlbWVudHMpXG5cdCAqIHdpdGhpbiBpdC5cblx0ICogXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHBhcnNlLlxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGVbXX0gQW4gYXJyYXkgb2YgSHRtbE5vZGVzIHRvIHJlcHJlc2VudCB0aGUgXG5cdCAqICAge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5UZXh0Tm9kZSBUZXh0Tm9kZXN9IGFuZCB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkVudGl0eU5vZGUgRW50aXR5Tm9kZXN9IGZvdW5kLlxuXHQgKi9cblx0cGFyc2VUZXh0QW5kRW50aXR5Tm9kZXMgOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHR2YXIgbm9kZXMgPSBbXSxcblx0XHQgICAgdGV4dEFuZEVudGl0eVRva2VucyA9IEF1dG9saW5rZXIuVXRpbC5zcGxpdEFuZENhcHR1cmUoIHRleHQsIHRoaXMuaHRtbENoYXJhY3RlckVudGl0aWVzUmVnZXggKTsgIC8vIHNwbGl0IGF0IEhUTUwgZW50aXRpZXMsIGJ1dCBpbmNsdWRlIHRoZSBIVE1MIGVudGl0aWVzIGluIHRoZSByZXN1bHRzIGFycmF5XG5cdFx0XG5cdFx0Ly8gRXZlcnkgZXZlbiBudW1iZXJlZCB0b2tlbiBpcyBhIFRleHROb2RlLCBhbmQgZXZlcnkgb2RkIG51bWJlcmVkIHRva2VuIGlzIGFuIEVudGl0eU5vZGVcblx0XHQvLyBGb3IgZXhhbXBsZTogYW4gaW5wdXQgYHRleHRgIG9mIFwiVGVzdCAmcXVvdDt0aGlzJnF1b3Q7IHRvZGF5XCIgd291bGQgdHVybiBpbnRvIHRoZSBcblx0XHQvLyAgIGB0ZXh0QW5kRW50aXR5VG9rZW5zYDogWyAnVGVzdCAnLCAnJnF1b3Q7JywgJ3RoaXMnLCAnJnF1b3Q7JywgJyB0b2RheScgXVxuXHRcdGZvciggdmFyIGkgPSAwLCBsZW4gPSB0ZXh0QW5kRW50aXR5VG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyICkge1xuXHRcdFx0dmFyIHRleHRUb2tlbiA9IHRleHRBbmRFbnRpdHlUb2tlbnNbIGkgXSxcblx0XHRcdCAgICBlbnRpdHlUb2tlbiA9IHRleHRBbmRFbnRpdHlUb2tlbnNbIGkgKyAxIF07XG5cdFx0XHRcblx0XHRcdGlmKCB0ZXh0VG9rZW4gKSBub2Rlcy5wdXNoKCB0aGlzLmNyZWF0ZVRleHROb2RlKCB0ZXh0VG9rZW4gKSApO1xuXHRcdFx0aWYoIGVudGl0eVRva2VuICkgbm9kZXMucHVzaCggdGhpcy5jcmVhdGVFbnRpdHlOb2RlKCBlbnRpdHlUb2tlbiApICk7XG5cdFx0fVxuXHRcdHJldHVybiBub2Rlcztcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGFuIHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRWxlbWVudE5vZGUgRWxlbWVudE5vZGV9LlxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRhZ1RleHQgVGhlIGZ1bGwgdGV4dCBvZiB0aGUgdGFnIChlbGVtZW50KSB0aGF0IHdhcyBtYXRjaGVkLCBpbmNsdWRpbmcgaXRzIGF0dHJpYnV0ZXMuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0YWdOYW1lIFRoZSBuYW1lIG9mIHRoZSB0YWcuIEV4OiBBbiAmbHQ7aW1nJmd0OyB0YWcgd291bGQgYmUgcGFzc2VkIHRvIHRoaXMgbWV0aG9kIGFzIFwiaW1nXCIuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNDbG9zaW5nVGFnIGB0cnVlYCBpZiBpdCdzIGEgY2xvc2luZyB0YWcsIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHJldHVybiB7QXV0b2xpbmtlci5odG1sUGFyc2VyLkVsZW1lbnROb2RlfVxuXHQgKi9cblx0Y3JlYXRlRWxlbWVudE5vZGUgOiBmdW5jdGlvbiggdGFnVGV4dCwgdGFnTmFtZSwgaXNDbG9zaW5nVGFnICkge1xuXHRcdHJldHVybiBuZXcgQXV0b2xpbmtlci5odG1sUGFyc2VyLkVsZW1lbnROb2RlKCB7XG5cdFx0XHR0ZXh0ICAgIDogdGFnVGV4dCxcblx0XHRcdHRhZ05hbWUgOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRjbG9zaW5nIDogaXNDbG9zaW5nVGFnXG5cdFx0fSApO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkVudGl0eU5vZGUgRW50aXR5Tm9kZX0uXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCB0aGF0IHdhcyBtYXRjaGVkIGZvciB0aGUgSFRNTCBlbnRpdHkgKHN1Y2ggYXMgJyZhbXA7bmJzcDsnKS5cblx0ICogQHJldHVybiB7QXV0b2xpbmtlci5odG1sUGFyc2VyLkVudGl0eU5vZGV9XG5cdCAqL1xuXHRjcmVhdGVFbnRpdHlOb2RlIDogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIG5ldyBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRW50aXR5Tm9kZSggeyB0ZXh0OiB0ZXh0IH0gKTtcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5UZXh0Tm9kZSBUZXh0Tm9kZX0uXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCB0aGF0IHdhcyBtYXRjaGVkLlxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLmh0bWxQYXJzZXIuVGV4dE5vZGV9XG5cdCAqL1xuXHRjcmVhdGVUZXh0Tm9kZSA6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiBuZXcgQXV0b2xpbmtlci5odG1sUGFyc2VyLlRleHROb2RlKCB7IHRleHQ6IHRleHQgfSApO1xuXHR9XG5cdFxufSApO1xuLypnbG9iYWwgQXV0b2xpbmtlciAqL1xuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzcyBBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGVcbiAqIFxuICogUmVwcmVzZW50cyBhbiBIVE1MIG5vZGUgZm91bmQgaW4gYW4gaW5wdXQgc3RyaW5nLiBBbiBIVE1MIG5vZGUgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gKiBcbiAqIDEuIEFuIHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRWxlbWVudE5vZGUgRWxlbWVudE5vZGV9LCB3aGljaCByZXByZXNlbnRzIEhUTUwgdGFncy5cbiAqIDIuIEEge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5UZXh0Tm9kZSBUZXh0Tm9kZX0sIHdoaWNoIHJlcHJlc2VudHMgdGV4dCBvdXRzaWRlIG9yIHdpdGhpbiBIVE1MIHRhZ3MuXG4gKiAzLiBBIHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRW50aXR5Tm9kZSBFbnRpdHlOb2RlfSwgd2hpY2ggcmVwcmVzZW50cyBvbmUgb2YgdGhlIGtub3duIEhUTUxcbiAqICAgIGVudGl0aWVzIHRoYXQgQXV0b2xpbmtlciBsb29rcyBmb3IuIFRoaXMgaW5jbHVkZXMgY29tbW9uIG9uZXMgc3VjaCBhcyAmYW1wO3F1b3Q7IGFuZCAmYW1wO25ic3A7XG4gKi9cbkF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZSA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge1N0cmluZ30gdGV4dCAocmVxdWlyZWQpXG5cdCAqIFxuXHQgKiBUaGUgb3JpZ2luYWwgdGV4dCB0aGF0IHdhcyBtYXRjaGVkIGZvciB0aGUgSHRtbE5vZGUuIFxuXHQgKiBcblx0ICogLSBJbiB0aGUgY2FzZSBvZiBhbiB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkVsZW1lbnROb2RlIEVsZW1lbnROb2RlfSwgdGhpcyB3aWxsIGJlIHRoZSB0YWcnc1xuXHQgKiAgIHRleHQuXG5cdCAqIC0gSW4gdGhlIGNhc2Ugb2YgYSB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLlRleHROb2RlIFRleHROb2RlfSwgdGhpcyB3aWxsIGJlIHRoZSB0ZXh0IGl0c2VsZi5cblx0ICogLSBJbiB0aGUgY2FzZSBvZiBhIHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRW50aXR5Tm9kZSBFbnRpdHlOb2RlfSwgdGhpcyB3aWxsIGJlIHRoZSB0ZXh0IG9mXG5cdCAqICAgdGhlIEhUTUwgZW50aXR5LlxuXHQgKi9cblx0dGV4dCA6IFwiXCIsXG5cdFxuXHRcblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gY2ZnIFRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgZm9yIHRoZSBNYXRjaCBpbnN0YW5jZSwgc3BlY2lmaWVkIGluIGFuIE9iamVjdCAobWFwKS5cblx0ICovXG5cdGNvbnN0cnVjdG9yIDogZnVuY3Rpb24oIGNmZyApIHtcblx0XHRBdXRvbGlua2VyLlV0aWwuYXNzaWduKCB0aGlzLCBjZmcgKTtcblx0fSxcblxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgbmFtZSBmb3IgdGhlIHR5cGUgb2Ygbm9kZSB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cblx0ICogXG5cdCAqIEBhYnN0cmFjdFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRUeXBlIDogQXV0b2xpbmtlci5VdGlsLmFic3RyYWN0TWV0aG9kLFxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIHtAbGluayAjdGV4dH0gZm9yIHRoZSBIdG1sTm9kZS5cblx0ICogXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldFRleHQgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50ZXh0O1xuXHR9XG5cbn0gKTtcbi8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cbi8qKlxuICogQGNsYXNzIEF1dG9saW5rZXIuaHRtbFBhcnNlci5FbGVtZW50Tm9kZVxuICogQGV4dGVuZHMgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxOb2RlXG4gKiBcbiAqIFJlcHJlc2VudHMgYW4gSFRNTCBlbGVtZW50IG5vZGUgdGhhdCBoYXMgYmVlbiBwYXJzZWQgYnkgdGhlIHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbFBhcnNlcn0uXG4gKiBcbiAqIFNlZSB0aGlzIGNsYXNzJ3Mgc3VwZXJjbGFzcyAoe0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZX0pIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbkF1dG9saW5rZXIuaHRtbFBhcnNlci5FbGVtZW50Tm9kZSA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZSwge1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge1N0cmluZ30gdGFnTmFtZSAocmVxdWlyZWQpXG5cdCAqIFxuXHQgKiBUaGUgbmFtZSBvZiB0aGUgdGFnIHRoYXQgd2FzIG1hdGNoZWQuXG5cdCAqL1xuXHR0YWdOYW1lIDogJycsXG5cdFxuXHQvKipcblx0ICogQGNmZyB7Qm9vbGVhbn0gY2xvc2luZyAocmVxdWlyZWQpXG5cdCAqIFxuXHQgKiBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQgKHRhZykgaXMgYSBjbG9zaW5nIHRhZywgYGZhbHNlYCBpZiBpdHMgYW4gb3BlbmluZyB0YWcuXG5cdCAqL1xuXHRjbG9zaW5nIDogZmFsc2UsXG5cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlIG9mIG5vZGUgdGhhdCB0aGlzIGNsYXNzIHJlcHJlc2VudHMuXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRUeXBlIDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdlbGVtZW50Jztcblx0fSxcblx0XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCdzICh0YWcncykgbmFtZS4gRXg6IGZvciBhbiAmbHQ7aW1nJmd0OyB0YWcsIHJldHVybnMgXCJpbWdcIi5cblx0ICogXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldFRhZ05hbWUgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50YWdOYW1lO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBIVE1MIGVsZW1lbnQgKHRhZykgaXMgYSBjbG9zaW5nIHRhZy4gRXg6ICZsdDtkaXYmZ3Q7IHJldHVybnNcblx0ICogYGZhbHNlYCwgd2hpbGUgJmx0Oy9kaXYmZ3Q7IHJldHVybnMgYHRydWVgLlxuXHQgKiBcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGlzQ2xvc2luZyA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNsb3Npbmc7XG5cdH1cblx0XG59ICk7XG4vKmdsb2JhbCBBdXRvbGlua2VyICovXG4vKipcbiAqIEBjbGFzcyBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRW50aXR5Tm9kZVxuICogQGV4dGVuZHMgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxOb2RlXG4gKiBcbiAqIFJlcHJlc2VudHMgYSBrbm93biBIVE1MIGVudGl0eSBub2RlIHRoYXQgaGFzIGJlZW4gcGFyc2VkIGJ5IHRoZSB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxQYXJzZXJ9LlxuICogRXg6ICcmYW1wO25ic3A7Jywgb3IgJyZhbXAjMTYwOycgKHdoaWNoIHdpbGwgYmUgcmV0cmlldmFibGUgZnJvbSB0aGUge0BsaW5rICNnZXRUZXh0fSBtZXRob2QuXG4gKiBcbiAqIE5vdGUgdGhhdCB0aGlzIGNsYXNzIHdpbGwgb25seSBiZSByZXR1cm5lZCBmcm9tIHRoZSBIdG1sUGFyc2VyIGZvciB0aGUgc2V0IG9mIGNoZWNrZWQgSFRNTCBlbnRpdHkgbm9kZXMgXG4gKiBkZWZpbmVkIGJ5IHRoZSB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxQYXJzZXIjaHRtbENoYXJhY3RlckVudGl0aWVzUmVnZXh9LlxuICogXG4gKiBTZWUgdGhpcyBjbGFzcydzIHN1cGVyY2xhc3MgKHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGV9KSBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG5BdXRvbGlua2VyLmh0bWxQYXJzZXIuRW50aXR5Tm9kZSA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZSwge1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgbmFtZSBmb3IgdGhlIHR5cGUgb2Ygbm9kZSB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cblx0ICogXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldFR5cGUgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ2VudGl0eSc7XG5cdH1cblx0XG59ICk7XG4vKmdsb2JhbCBBdXRvbGlua2VyICovXG4vKipcbiAqIEBjbGFzcyBBdXRvbGlua2VyLmh0bWxQYXJzZXIuVGV4dE5vZGVcbiAqIEBleHRlbmRzIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZVxuICogXG4gKiBSZXByZXNlbnRzIGEgdGV4dCBub2RlIHRoYXQgaGFzIGJlZW4gcGFyc2VkIGJ5IHRoZSB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxQYXJzZXJ9LlxuICogXG4gKiBTZWUgdGhpcyBjbGFzcydzIHN1cGVyY2xhc3MgKHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGV9KSBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG5BdXRvbGlua2VyLmh0bWxQYXJzZXIuVGV4dE5vZGUgPSBBdXRvbGlua2VyLlV0aWwuZXh0ZW5kKCBBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGUsIHtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlIG9mIG5vZGUgdGhhdCB0aGlzIGNsYXNzIHJlcHJlc2VudHMuXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRUeXBlIDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICd0ZXh0Jztcblx0fVxuXHRcbn0gKTtcbi8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cbi8qKlxuICogQHByaXZhdGVcbiAqIEBjbGFzcyBBdXRvbGlua2VyLm1hdGNoUGFyc2VyLk1hdGNoUGFyc2VyXG4gKiBAZXh0ZW5kcyBPYmplY3RcbiAqIFxuICogVXNlZCBieSBBdXRvbGlua2VyIHRvIHBhcnNlIHtAbGluayAjdXJscyBVUkxzfSwge0BsaW5rICNlbWFpbHMgZW1haWwgYWRkcmVzc2VzfSwgYW5kIHtAbGluayAjdHdpdHRlciBUd2l0dGVyIGhhbmRsZXN9LCBcbiAqIGdpdmVuIGFuIGlucHV0IHN0cmluZyBvZiB0ZXh0LlxuICogXG4gKiBUaGUgTWF0Y2hQYXJzZXIgaXMgZmVkIGEgbm9uLUhUTUwgc3RyaW5nIGluIG9yZGVyIHRvIHNlYXJjaCBvdXQgVVJMcywgZW1haWwgYWRkcmVzc2VzIGFuZCBUd2l0dGVyIGhhbmRsZXMuIEF1dG9saW5rZXJcbiAqIGZpcnN0IHVzZXMgdGhlIHtAbGluayBIdG1sUGFyc2VyfSB0byBcIndhbGsgYXJvdW5kXCIgSFRNTCB0YWdzLCBhbmQgdGhlbiB0aGUgdGV4dCBhcm91bmQgdGhlIEhUTUwgdGFncyBpcyBwYXNzZWQgaW50b1xuICogdGhlIE1hdGNoUGFyc2VyIGluIG9yZGVyIHRvIGZpbmQgdGhlIGFjdHVhbCBtYXRjaGVzLlxuICovXG5BdXRvbGlua2VyLm1hdGNoUGFyc2VyLk1hdGNoUGFyc2VyID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggT2JqZWN0LCB7XG5cdFxuXHQvKipcblx0ICogQGNmZyB7Qm9vbGVhbn0gdXJsc1xuXHQgKiBcblx0ICogYHRydWVgIGlmIG1pc2NlbGxhbmVvdXMgVVJMcyBzaG91bGQgYmUgYXV0b21hdGljYWxseSBsaW5rZWQsIGBmYWxzZWAgaWYgdGhleSBzaG91bGQgbm90IGJlLlxuXHQgKi9cblx0dXJscyA6IHRydWUsXG5cdFxuXHQvKipcblx0ICogQGNmZyB7Qm9vbGVhbn0gZW1haWxcblx0ICogXG5cdCAqIGB0cnVlYCBpZiBlbWFpbCBhZGRyZXNzZXMgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgbGlua2VkLCBgZmFsc2VgIGlmIHRoZXkgc2hvdWxkIG5vdCBiZS5cblx0ICovXG5cdGVtYWlsIDogdHJ1ZSxcblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtCb29sZWFufSB0d2l0dGVyXG5cdCAqIFxuXHQgKiBgdHJ1ZWAgaWYgVHdpdHRlciBoYW5kbGVzIChcIkBleGFtcGxlXCIpIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGxpbmtlZCwgYGZhbHNlYCBpZiB0aGV5IHNob3VsZCBub3QgYmUuXG5cdCAqL1xuXHR0d2l0dGVyIDogdHJ1ZSxcblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtCb29sZWFufSBzdHJpcFByZWZpeFxuXHQgKiBcblx0ICogYHRydWVgIGlmICdodHRwOi8vJyBvciAnaHR0cHM6Ly8nIGFuZC9vciB0aGUgJ3d3dy4nIHNob3VsZCBiZSBzdHJpcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgVVJMIGxpbmtzJyB0ZXh0XG5cdCAqIGluIHtAbGluayBBdXRvbGlua2VyLm1hdGNoLlVybCBVUkwgbWF0Y2hlc30sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuXHQgKiBcblx0ICogVE9ETzogSGFuZGxlIHRoaXMgYmVmb3JlIGEgVVJMIE1hdGNoIG9iamVjdCBpcyBpbnN0YW50aWF0ZWQuXG5cdCAqL1xuXHRzdHJpcFByZWZpeCA6IHRydWUsXG5cdFxuXHRcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBtYXRjaGVyUmVnZXhcblx0ICogXG5cdCAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgaGFuZGxlcy5cblx0ICogXG5cdCAqIFRoaXMgcmVndWxhciBleHByZXNzaW9uIGhhcyB0aGUgZm9sbG93aW5nIGNhcHR1cmluZyBncm91cHM6XG5cdCAqIFxuXHQgKiAxLiBHcm91cCB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZXJlIGlzIGEgVHdpdHRlciBoYW5kbGUgbWF0Y2ggKGkuZS4gXFxAc29tZVR3aXR0ZXJVc2VyKS4gU2ltcGx5IGNoZWNrIGZvciBpdHMgXG5cdCAqICAgIGV4aXN0ZW5jZSB0byBkZXRlcm1pbmUgaWYgdGhlcmUgaXMgYSBUd2l0dGVyIGhhbmRsZSBtYXRjaC4gVGhlIG5leHQgY291cGxlIG9mIGNhcHR1cmluZyBncm91cHMgZ2l2ZSBpbmZvcm1hdGlvbiBcblx0ICogICAgYWJvdXQgdGhlIFR3aXR0ZXIgaGFuZGxlIG1hdGNoLlxuXHQgKiAyLiBUaGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBcXEBzaWduIGluIGEgVHdpdHRlciBoYW5kbGUuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgdGhlcmUgYXJlIG5vIGxvb2tiZWhpbmRzIGluXG5cdCAqICAgIEpTIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGFuZCBjYW4gYmUgdXNlZCB0byByZWNvbnN0cnVjdCB0aGUgb3JpZ2luYWwgc3RyaW5nIGluIGEgcmVwbGFjZSgpLlxuXHQgKiAzLiBUaGUgVHdpdHRlciBoYW5kbGUgaXRzZWxmIGluIGEgVHdpdHRlciBtYXRjaC4gSWYgdGhlIG1hdGNoIGlzICdAc29tZVR3aXR0ZXJVc2VyJywgdGhlIGhhbmRsZSBpcyAnc29tZVR3aXR0ZXJVc2VyJy5cblx0ICogNC4gR3JvdXAgdGhhdCBtYXRjaGVzIGFuIGVtYWlsIGFkZHJlc3MuIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBtYXRjaCBpcyBhbiBlbWFpbCBhZGRyZXNzLCBhcyB3ZWxsIGFzIGhvbGRpbmcgdGhlIGZ1bGwgXG5cdCAqICAgIGFkZHJlc3MuIEV4OiAnbWVAbXkuY29tJ1xuXHQgKiA1LiBHcm91cCB0aGF0IG1hdGNoZXMgYSBVUkwgaW4gdGhlIGlucHV0IHRleHQuIEV4OiAnaHR0cDovL2dvb2dsZS5jb20nLCAnd3d3Lmdvb2dsZS5jb20nLCBvciBqdXN0ICdnb29nbGUuY29tJy5cblx0ICogICAgVGhpcyBhbHNvIGluY2x1ZGVzIGEgcGF0aCwgdXJsIHBhcmFtZXRlcnMsIG9yIGhhc2ggYW5jaG9ycy4gRXg6IGdvb2dsZS5jb20vcGF0aC90by9maWxlP3ExPTEmcTI9MiNteUFuY2hvclxuXHQgKiA2LiBHcm91cCB0aGF0IG1hdGNoZXMgYSBwcm90b2NvbCBVUkwgKGkuZS4gJ2h0dHA6Ly9nb29nbGUuY29tJykuIFRoaXMgaXMgdXNlZCB0byBtYXRjaCBwcm90b2NvbCBVUkxzIHdpdGgganVzdCBhIHNpbmdsZVxuXHQgKiAgICB3b3JkLCBsaWtlICdodHRwOi8vbG9jYWxob3N0Jywgd2hlcmUgd2Ugd29uJ3QgZG91YmxlIGNoZWNrIHRoYXQgdGhlIGRvbWFpbiBuYW1lIGhhcyBhdCBsZWFzdCBvbmUgJy4nIGluIGl0LlxuXHQgKiA3LiBBIHByb3RvY29sLXJlbGF0aXZlICgnLy8nKSBtYXRjaCBmb3IgdGhlIGNhc2Ugb2YgYSAnd3d3LicgcHJlZml4ZWQgVVJMLiBXaWxsIGJlIGFuIGVtcHR5IHN0cmluZyBpZiBpdCBpcyBub3QgYSBcblx0ICogICAgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2guIFdlIG5lZWQgdG8ga25vdyB0aGUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgJy8vJyBpbiBvcmRlciB0byBkZXRlcm1pbmUgaWYgaXQgaXMgYSB2YWxpZCBtYXRjaFxuXHQgKiAgICBvciB0aGUgLy8gd2FzIGluIGEgc3RyaW5nIHdlIGRvbid0IHdhbnQgdG8gYXV0by1saW5rLlxuXHQgKiA4LiBBIHByb3RvY29sLXJlbGF0aXZlICgnLy8nKSBtYXRjaCBmb3IgdGhlIGNhc2Ugb2YgYSBrbm93biBUTEQgcHJlZml4ZWQgVVJMLiBXaWxsIGJlIGFuIGVtcHR5IHN0cmluZyBpZiBpdCBpcyBub3QgYSBcblx0ICogICAgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2guIFNlZSAjNiBmb3IgbW9yZSBpbmZvLiBcblx0ICovXG5cdG1hdGNoZXJSZWdleCA6IChmdW5jdGlvbigpIHtcblx0XHR2YXIgdHdpdHRlclJlZ2V4ID0gLyhefFteXFx3XSlAKFxcd3sxLDE1fSkvLCAgICAgICAgICAgICAgLy8gRm9yIG1hdGNoaW5nIGEgdHdpdHRlciBoYW5kbGUuIEV4OiBAZ3JlZ29yeV9qYWNvYnNcblx0XHQgICAgXG5cdFx0ICAgIGVtYWlsUmVnZXggPSAvKD86W1xcLTs6Jj1cXCtcXCQsXFx3XFwuXStAKS8sICAgICAgICAgICAgIC8vIHNvbWV0aGluZ0AgZm9yIGVtYWlsIGFkZHJlc3NlcyAoYS5rLmEuIGxvY2FsLXBhcnQpXG5cdFx0ICAgIFxuXHRcdCAgICBwcm90b2NvbFJlZ2V4ID0gLyg/OltBLVphLXpdWy0uK0EtWmEtejAtOV0rOig/IVtBLVphLXpdWy0uK0EtWmEtejAtOV0rOlxcL1xcLykoPyFcXGQrXFwvPykoPzpcXC9cXC8pPykvLCAgLy8gbWF0Y2ggcHJvdG9jb2wsIGFsbG93IGluIGZvcm1hdCBcImh0dHA6Ly9cIiBvciBcIm1haWx0bzpcIi4gSG93ZXZlciwgZG8gbm90IG1hdGNoIHRoZSBmaXJzdCBwYXJ0IG9mIHNvbWV0aGluZyBsaWtlICdsaW5rOmh0dHA6Ly93d3cuZ29vZ2xlLmNvbScgKGkuZS4gZG9uJ3QgbWF0Y2ggXCJsaW5rOlwiKS4gQWxzbywgbWFrZSBzdXJlIHdlIGRvbid0IGludGVycHJldCAnZ29vZ2xlLmNvbTo4MDAwJyBhcyBpZiAnZ29vZ2xlLmNvbScgd2FzIGEgcHJvdG9jb2wgaGVyZSAoaS5lLiBpZ25vcmUgYSB0cmFpbGluZyBwb3J0IG51bWJlciBpbiB0aGlzIHJlZ2V4KVxuXHRcdCAgICB3d3dSZWdleCA9IC8oPzp3d3dcXC4pLywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHdpdGggJ3d3dy4nXG5cdFx0ICAgIGRvbWFpbk5hbWVSZWdleCA9IC9bQS1aYS16MC05XFwuXFwtXSpbQS1aYS16MC05XFwtXS8sICAvLyBhbnl0aGluZyBsb29raW5nIGF0IGFsbCBsaWtlIGEgZG9tYWluLCBub24tdW5pY29kZSBkb21haW5zLCBub3QgZW5kaW5nIGluIGEgcGVyaW9kXG5cdFx0ICAgIHRsZFJlZ2V4ID0gL1xcLig/OmludGVybmF0aW9uYWx8Y29uc3RydWN0aW9ufGNvbnRyYWN0b3JzfGVudGVycHJpc2VzfHBob3RvZ3JhcGh5fHByb2R1Y3Rpb25zfGZvdW5kYXRpb258aW1tb2JpbGllbnxpbmR1c3RyaWVzfG1hbmFnZW1lbnR8cHJvcGVydGllc3x0ZWNobm9sb2d5fGNocmlzdG1hc3xjb21tdW5pdHl8ZGlyZWN0b3J5fGVkdWNhdGlvbnxlcXVpcG1lbnR8aW5zdGl0dXRlfG1hcmtldGluZ3xzb2x1dGlvbnN8dmFjYXRpb25zfGJhcmdhaW5zfGJvdXRpcXVlfGJ1aWxkZXJzfGNhdGVyaW5nfGNsZWFuaW5nfGNsb3RoaW5nfGNvbXB1dGVyfGRlbW9jcmF0fGRpYW1vbmRzfGdyYXBoaWNzfGhvbGRpbmdzfGxpZ2h0aW5nfHBhcnRuZXJzfHBsdW1iaW5nfHN1cHBsaWVzfHRyYWluaW5nfHZlbnR1cmVzfGFjYWRlbXl8Y2FyZWVyc3xjb21wYW55fGNydWlzZXN8ZG9tYWluc3xleHBvc2VkfGZsaWdodHN8ZmxvcmlzdHxnYWxsZXJ5fGd1aXRhcnN8aG9saWRheXxraXRjaGVufG5ldXN0YXJ8b2tpbmF3YXxyZWNpcGVzfHJlbnRhbHN8cmV2aWV3c3xzaGlrc2hhfHNpbmdsZXN8c3VwcG9ydHxzeXN0ZW1zfGFnZW5jeXxiZXJsaW58Y2FtZXJhfGNlbnRlcnxjb2ZmZWV8Y29uZG9zfGRhdGluZ3xlc3RhdGV8ZXZlbnRzfGV4cGVydHxmdXRib2x8a2F1ZmVufGx1eHVyeXxtYWlzb258bW9uYXNofG11c2V1bXxuYWdveWF8cGhvdG9zfHJlcGFpcnxyZXBvcnR8c29jaWFsfHN1cHBseXx0YXR0b298dGllbmRhfHRyYXZlbHx2aWFqZXN8dmlsbGFzfHZpc2lvbnx2b3Rpbmd8dm95YWdlfGFjdG9yfGJ1aWxkfGNhcmRzfGNoZWFwfGNvZGVzfGRhbmNlfGVtYWlsfGdsYXNzfGhvdXNlfG1hbmdvfG5pbmphfHBhcnRzfHBob3RvfHNob2VzfHNvbGFyfHRvZGF5fHRva3lvfHRvb2xzfHdhdGNofHdvcmtzfGFlcm98YXJwYXxhc2lhfGJlc3R8YmlrZXxibHVlfGJ1enp8Y2FtcHxjbHVifGNvb2x8Y29vcHxmYXJtfGZpc2h8Z2lmdHxndXJ1fGluZm98am9ic3xraXdpfGtyZWR8bGFuZHxsaW1vfGxpbmt8bWVudXxtb2JpfG1vZGF8bmFtZXxwaWNzfHBpbmt8cG9zdHxxcG9ufHJpY2h8cnVocnxzZXh5fHRpcHN8dm90ZXx2b3RvfHdhbmd8d2llbnx3aWtpfHpvbmV8YmFyfGJpZHxiaXp8Y2FifGNhdHxjZW98Y29tfGVkdXxnb3Z8aW50fGtpbXxtaWx8bmV0fG9ubHxvcmd8cHJvfHB1YnxyZWR8dGVsfHVub3x3ZWR8eHh4fHh5enxhY3xhZHxhZXxhZnxhZ3xhaXxhbHxhbXxhbnxhb3xhcXxhcnxhc3xhdHxhdXxhd3xheHxhenxiYXxiYnxiZHxiZXxiZnxiZ3xiaHxiaXxianxibXxibnxib3xicnxic3xidHxidnxid3xieXxienxjYXxjY3xjZHxjZnxjZ3xjaHxjaXxja3xjbHxjbXxjbnxjb3xjcnxjdXxjdnxjd3xjeHxjeXxjenxkZXxkanxka3xkbXxkb3xkenxlY3xlZXxlZ3xlcnxlc3xldHxldXxmaXxmanxma3xmbXxmb3xmcnxnYXxnYnxnZHxnZXxnZnxnZ3xnaHxnaXxnbHxnbXxnbnxncHxncXxncnxnc3xndHxndXxnd3xneXxoa3xobXxobnxocnxodHxodXxpZHxpZXxpbHxpbXxpbnxpb3xpcXxpcnxpc3xpdHxqZXxqbXxqb3xqcHxrZXxrZ3xraHxraXxrbXxrbnxrcHxrcnxrd3xreXxrenxsYXxsYnxsY3xsaXxsa3xscnxsc3xsdHxsdXxsdnxseXxtYXxtY3xtZHxtZXxtZ3xtaHxta3xtbHxtbXxtbnxtb3xtcHxtcXxtcnxtc3xtdHxtdXxtdnxtd3xteHxteXxtenxuYXxuY3xuZXxuZnxuZ3xuaXxubHxub3xucHxucnxudXxuenxvbXxwYXxwZXxwZnxwZ3xwaHxwa3xwbHxwbXxwbnxwcnxwc3xwdHxwd3xweXxxYXxyZXxyb3xyc3xydXxyd3xzYXxzYnxzY3xzZHxzZXxzZ3xzaHxzaXxzanxza3xzbHxzbXxzbnxzb3xzcnxzdHxzdXxzdnxzeHxzeXxzenx0Y3x0ZHx0Znx0Z3x0aHx0anx0a3x0bHx0bXx0bnx0b3x0cHx0cnx0dHx0dnx0d3x0enx1YXx1Z3x1a3x1c3x1eXx1enx2YXx2Y3x2ZXx2Z3x2aXx2bnx2dXx3Znx3c3x5ZXx5dHx6YXx6bXx6dylcXGIvLCAgIC8vIG1hdGNoIG91ciBrbm93biB0b3AgbGV2ZWwgZG9tYWlucyAoVExEcylcblx0XHQgICAgXG5cdFx0ICAgIC8vIEFsbG93IG9wdGlvbmFsIHBhdGgsIHF1ZXJ5IHN0cmluZywgYW5kIGhhc2ggYW5jaG9yLCBub3QgZW5kaW5nIGluIHRoZSBmb2xsb3dpbmcgY2hhcmFjdGVyczogXCI/ITosLjtcIlxuXHRcdCAgICAvLyBodHRwOi8vYmxvZy5jb2Rpbmdob3Jyb3IuY29tL3RoZS1wcm9ibGVtLXdpdGgtdXJscy9cblx0XHQgICAgdXJsU3VmZml4UmVnZXggPSAvW1xcLUEtWmEtejAtOSsmQCNcXC8lPX5fKCl8JyQqXFxbXFxdPyE6LC47XSpbXFwtQS1aYS16MC05KyZAI1xcLyU9fl8oKXwnJCpcXFtcXF1dLztcblx0XHRcblx0XHRyZXR1cm4gbmV3IFJlZ0V4cCggW1xuXHRcdFx0JygnLCAgLy8gKioqIENhcHR1cmluZyBncm91cCAkMSwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2hlY2sgZm9yIGEgdHdpdHRlciBoYW5kbGUgbWF0Y2guIFVzZSBncm91cCAkMyBmb3IgdGhlIGFjdHVhbCB0d2l0dGVyIGhhbmRsZSB0aG91Z2guICQyIG1heSBiZSB1c2VkIHRvIHJlY29uc3RydWN0IHRoZSBvcmlnaW5hbCBzdHJpbmcgaW4gYSByZXBsYWNlKCkgXG5cdFx0XHRcdC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDIsIHdoaWNoIG1hdGNoZXMgdGhlIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGJlZm9yZSB0aGUgJ0AnIHNpZ24gKG5lZWRlZCBiZWNhdXNlIG9mIG5vIGxvb2tiZWhpbmRzKSwgYW5kIFxuXHRcdFx0XHQvLyAqKiogQ2FwdHVyaW5nIGdyb3VwICQzLCB3aGljaCBtYXRjaGVzIHRoZSBhY3R1YWwgdHdpdHRlciBoYW5kbGVcblx0XHRcdFx0dHdpdHRlclJlZ2V4LnNvdXJjZSxcblx0XHRcdCcpJyxcblx0XHRcdFxuXHRcdFx0J3wnLFxuXHRcdFx0XG5cdFx0XHQnKCcsICAvLyAqKiogQ2FwdHVyaW5nIGdyb3VwICQ0LCB3aGljaCBpcyB1c2VkIHRvIGRldGVybWluZSBhbiBlbWFpbCBtYXRjaFxuXHRcdFx0XHRlbWFpbFJlZ2V4LnNvdXJjZSxcblx0XHRcdFx0ZG9tYWluTmFtZVJlZ2V4LnNvdXJjZSxcblx0XHRcdFx0dGxkUmVnZXguc291cmNlLFxuXHRcdFx0JyknLFxuXHRcdFx0XG5cdFx0XHQnfCcsXG5cdFx0XHRcblx0XHRcdCcoJywgIC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDUsIHdoaWNoIGlzIHVzZWQgdG8gbWF0Y2ggYSBVUkxcblx0XHRcdFx0Jyg/OicsIC8vIHBhcmVucyB0byBjb3ZlciBtYXRjaCBmb3IgcHJvdG9jb2wgKG9wdGlvbmFsKSwgYW5kIGRvbWFpblxuXHRcdFx0XHRcdCcoJywgIC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDYsIGZvciBhIHByb3RvY29sLXByZWZpeGVkIHVybCAoZXg6IGh0dHA6Ly9nb29nbGUuY29tKVxuXHRcdFx0XHRcdFx0cHJvdG9jb2xSZWdleC5zb3VyY2UsXG5cdFx0XHRcdFx0XHRkb21haW5OYW1lUmVnZXguc291cmNlLFxuXHRcdFx0XHRcdCcpJyxcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQnfCcsXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Jyg/OicsICAvLyBub24tY2FwdHVyaW5nIHBhcmVuIGZvciBhICd3d3cuJyBwcmVmaXhlZCB1cmwgKGV4OiB3d3cuZ29vZ2xlLmNvbSlcblx0XHRcdFx0XHRcdCcoLj8vLyk/JywgIC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDcgZm9yIGFuIG9wdGlvbmFsIHByb3RvY29sLXJlbGF0aXZlIFVSTC4gTXVzdCBiZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcgb3Igc3RhcnQgd2l0aCBhIG5vbi13b3JkIGNoYXJhY3RlclxuXHRcdFx0XHRcdFx0d3d3UmVnZXguc291cmNlLFxuXHRcdFx0XHRcdFx0ZG9tYWluTmFtZVJlZ2V4LnNvdXJjZSxcblx0XHRcdFx0XHQnKScsXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0J3wnLFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdCcoPzonLCAgLy8gbm9uLWNhcHR1cmluZyBwYXJlbiBmb3Iga25vd24gYSBUTEQgdXJsIChleDogZ29vZ2xlLmNvbSlcblx0XHRcdFx0XHRcdCcoLj8vLyk/JywgIC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDggZm9yIGFuIG9wdGlvbmFsIHByb3RvY29sLXJlbGF0aXZlIFVSTC4gTXVzdCBiZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcgb3Igc3RhcnQgd2l0aCBhIG5vbi13b3JkIGNoYXJhY3RlclxuXHRcdFx0XHRcdFx0ZG9tYWluTmFtZVJlZ2V4LnNvdXJjZSxcblx0XHRcdFx0XHRcdHRsZFJlZ2V4LnNvdXJjZSxcblx0XHRcdFx0XHQnKScsXG5cdFx0XHRcdCcpJyxcblx0XHRcdFx0XG5cdFx0XHRcdCcoPzonICsgdXJsU3VmZml4UmVnZXguc291cmNlICsgJyk/JywgIC8vIG1hdGNoIGZvciBwYXRoLCBxdWVyeSBzdHJpbmcsIGFuZC9vciBoYXNoIGFuY2hvciAtIG9wdGlvbmFsXG5cdFx0XHQnKSdcblx0XHRdLmpvaW4oIFwiXCIgKSwgJ2dpJyApO1xuXHR9ICkoKSxcblx0XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gY2hhckJlZm9yZVByb3RvY29sUmVsTWF0Y2hSZWdleFxuXHQgKiBcblx0ICogVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHJldHJpZXZlIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIGEgcHJvdG9jb2wtcmVsYXRpdmUgVVJMIG1hdGNoLlxuXHQgKiBcblx0ICogVGhpcyBpcyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIHtAbGluayAjbWF0Y2hlclJlZ2V4fSwgd2hpY2ggbmVlZHMgdG8gZ3JhYiB0aGUgY2hhcmFjdGVyIGJlZm9yZSBhIHByb3RvY29sLXJlbGF0aXZlXG5cdCAqICcvLycgZHVlIHRvIHRoZSBsYWNrIG9mIGEgbmVnYXRpdmUgbG9vay1iZWhpbmQgaW4gSmF2YVNjcmlwdCByZWd1bGFyIGV4cHJlc3Npb25zLiBUaGUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgbWF0Y2ggaXMgc3RyaXBwZWRcblx0ICogZnJvbSB0aGUgVVJMLlxuXHQgKi9cblx0Y2hhckJlZm9yZVByb3RvY29sUmVsTWF0Y2hSZWdleCA6IC9eKC4pP1xcL1xcLy8sXG5cdFxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHByb3BlcnR5IHtBdXRvbGlua2VyLk1hdGNoVmFsaWRhdG9yfSBtYXRjaFZhbGlkYXRvclxuXHQgKiBcblx0ICogVGhlIE1hdGNoVmFsaWRhdG9yIG9iamVjdCwgdXNlZCB0byBmaWx0ZXIgb3V0IGFueSBmYWxzZSBwb3NpdGl2ZXMgZnJvbSB0aGUge0BsaW5rICNtYXRjaGVyUmVnZXh9LiBTZWVcblx0ICoge0BsaW5rIEF1dG9saW5rZXIuTWF0Y2hWYWxpZGF0b3J9IGZvciBkZXRhaWxzLlxuXHQgKi9cblx0XG5cdFxuXHQvKipcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbY2ZnXSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgQW5jaG9yVGFnQnVpbGRlciBpbnN0YW5jZSwgc3BlY2lmaWVkIGluIGFuIE9iamVjdCAobWFwKS5cblx0ICovXG5cdGNvbnN0cnVjdG9yIDogZnVuY3Rpb24oIGNmZyApIHtcblx0XHRBdXRvbGlua2VyLlV0aWwuYXNzaWduKCB0aGlzLCBjZmcgKTtcblx0XG5cdFx0dGhpcy5tYXRjaFZhbGlkYXRvciA9IG5ldyBBdXRvbGlua2VyLk1hdGNoVmFsaWRhdG9yKCk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgaW5wdXQgYHRleHRgIHRvIHNlYXJjaCBmb3IgVVJMcy9lbWFpbHMvVHdpdHRlciBoYW5kbGVzLCBhbmQgY2FsbHMgdGhlIGByZXBsYWNlRm5gXG5cdCAqIHRvIGFsbG93IHJlcGxhY2VtZW50cyBvZiB0aGUgbWF0Y2hlcy4gUmV0dXJucyB0aGUgYHRleHRgIHdpdGggbWF0Y2hlcyByZXBsYWNlZC5cblx0ICogXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHNlYXJjaCBhbmQgcmVwYWNlIG1hdGNoZXMgaW4uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcGxhY2VGbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSByZXBsYWNlbWVudHMuIFRoZSBmdW5jdGlvbiB0YWtlcyBhXG5cdCAqICAgc2luZ2xlIGFyZ3VtZW50LCBhIHtAbGluayBBdXRvbGlua2VyLm1hdGNoLk1hdGNofSBvYmplY3QsIGFuZCBzaG91bGQgcmV0dXJuIHRoZSB0ZXh0IHRoYXQgc2hvdWxkXG5cdCAqICAgbWFrZSB0aGUgcmVwbGFjZW1lbnQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dE9iaj13aW5kb3ddIFRoZSBjb250ZXh0IG9iamVjdCAoXCJzY29wZVwiKSB0byBydW4gdGhlIGByZXBsYWNlRm5gIGluLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRyZXBsYWNlIDogZnVuY3Rpb24oIHRleHQsIHJlcGxhY2VGbiwgY29udGV4dE9iaiApIHtcblx0XHR2YXIgbWUgPSB0aGlzOyAgLy8gZm9yIGNsb3N1cmVcblx0XHRcblx0XHRyZXR1cm4gdGV4dC5yZXBsYWNlKCB0aGlzLm1hdGNoZXJSZWdleCwgZnVuY3Rpb24oIG1hdGNoU3RyLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDggKSB7XG5cdFx0XHR2YXIgbWF0Y2hEZXNjT2JqID0gbWUucHJvY2Vzc0NhbmRpZGF0ZU1hdGNoKCBtYXRjaFN0ciwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcsICQ4ICk7ICAvLyBcIm1hdGNoIGRlc2NyaXB0aW9uXCIgb2JqZWN0XG5cdFx0XHRcblx0XHRcdC8vIFJldHVybiBvdXQgd2l0aCBubyBjaGFuZ2VzIGZvciBtYXRjaCB0eXBlcyB0aGF0IGFyZSBkaXNhYmxlZCAodXJsLCBlbWFpbCwgdHdpdHRlciksIG9yIGZvciBtYXRjaGVzIHRoYXQgYXJlIFxuXHRcdFx0Ly8gaW52YWxpZCAoZmFsc2UgcG9zaXRpdmVzIGZyb20gdGhlIG1hdGNoZXJSZWdleCwgd2hpY2ggY2FuJ3QgdXNlIGxvb2stYmVoaW5kcyBzaW5jZSB0aGV5IGFyZSB1bmF2YWlsYWJsZSBpbiBKUykuXG5cdFx0XHRpZiggIW1hdGNoRGVzY09iaiApIHtcblx0XHRcdFx0cmV0dXJuIG1hdGNoU3RyO1xuXHRcdFx0XHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEdlbmVyYXRlIHJlcGxhY2VtZW50IHRleHQgZm9yIHRoZSBtYXRjaCBmcm9tIHRoZSBgcmVwbGFjZUZuYFxuXHRcdFx0XHR2YXIgcmVwbGFjZVN0ciA9IHJlcGxhY2VGbi5jYWxsKCBjb250ZXh0T2JqLCBtYXRjaERlc2NPYmoubWF0Y2ggKTtcblx0XHRcdFx0cmV0dXJuIG1hdGNoRGVzY09iai5wcmVmaXhTdHIgKyByZXBsYWNlU3RyICsgbWF0Y2hEZXNjT2JqLnN1ZmZpeFN0cjtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFByb2Nlc3NlcyBhIGNhbmRpZGF0ZSBtYXRjaCBmcm9tIHRoZSB7QGxpbmsgI21hdGNoZXJSZWdleH0uIFxuXHQgKiBcblx0ICogTm90IGFsbCBtYXRjaGVzIGZvdW5kIGJ5IHRoZSByZWdleCBhcmUgYWN0dWFsIFVSTC9lbWFpbC9Ud2l0dGVyIG1hdGNoZXMsIGFzIGRldGVybWluZWQgYnkgdGhlIHtAbGluayAjbWF0Y2hWYWxpZGF0b3J9LiBJblxuXHQgKiB0aGlzIGNhc2UsIHRoZSBtZXRob2QgcmV0dXJucyBgbnVsbGAuIE90aGVyd2lzZSwgYSB2YWxpZCBPYmplY3Qgd2l0aCBgcHJlZml4U3RyYCwgYG1hdGNoYCwgYW5kIGBzdWZmaXhTdHJgIGlzIHJldHVybmVkLlxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoU3RyIFRoZSBmdWxsIG1hdGNoIHRoYXQgd2FzIGZvdW5kIGJ5IHRoZSB7QGxpbmsgI21hdGNoZXJSZWdleH0uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0d2l0dGVyTWF0Y2ggVGhlIG1hdGNoZWQgdGV4dCBvZiBhIFR3aXR0ZXIgaGFuZGxlLCBpZiB0aGUgbWF0Y2ggaXMgYSBUd2l0dGVyIG1hdGNoLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHdpdHRlckhhbmRsZVByZWZpeFdoaXRlc3BhY2VDaGFyIFRoZSB3aGl0ZXNwYWNlIGNoYXIgYmVmb3JlIHRoZSBAIHNpZ24gaW4gYSBUd2l0dGVyIGhhbmRsZSBtYXRjaC4gVGhpcyBcblx0ICogICBpcyBuZWVkZWQgYmVjYXVzZSBvZiBubyBsb29rYmVoaW5kcyBpbiBKUyByZWdleGVzLCBhbmQgaXMgbmVlZCB0byByZS1pbmNsdWRlIHRoZSBjaGFyYWN0ZXIgZm9yIHRoZSBhbmNob3IgdGFnIHJlcGxhY2VtZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHdpdHRlckhhbmRsZSBUaGUgYWN0dWFsIFR3aXR0ZXIgdXNlciAoaS5lIHRoZSB3b3JkIGFmdGVyIHRoZSBAIHNpZ24gaW4gYSBUd2l0dGVyIG1hdGNoKS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGVtYWlsQWRkcmVzc01hdGNoIFRoZSBtYXRjaGVkIGVtYWlsIGFkZHJlc3MgZm9yIGFuIGVtYWlsIGFkZHJlc3MgbWF0Y2guXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxNYXRjaCBUaGUgbWF0Y2hlZCBVUkwgc3RyaW5nIGZvciBhIFVSTCBtYXRjaC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sVXJsTWF0Y2ggVGhlIG1hdGNoIFVSTCBzdHJpbmcgZm9yIGEgcHJvdG9jb2wgbWF0Y2guIEV4OiAnaHR0cDovL3lhaG9vLmNvbScuIFRoaXMgaXMgdXNlZCB0byBtYXRjaFxuXHQgKiAgIHNvbWV0aGluZyBsaWtlICdodHRwOi8vbG9jYWxob3N0Jywgd2hlcmUgd2Ugd29uJ3QgZG91YmxlIGNoZWNrIHRoYXQgdGhlIGRvbWFpbiBuYW1lIGhhcyBhdCBsZWFzdCBvbmUgJy4nIGluIGl0LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gd3d3UHJvdG9jb2xSZWxhdGl2ZU1hdGNoIFRoZSAnLy8nIGZvciBhIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoIGZyb20gYSAnd3d3JyB1cmwsIHdpdGggdGhlIGNoYXJhY3RlciB0aGF0IFxuXHQgKiAgIGNvbWVzIGJlZm9yZSB0aGUgJy8vJy5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHRsZFByb3RvY29sUmVsYXRpdmVNYXRjaCBUaGUgJy8vJyBmb3IgYSBwcm90b2NvbC1yZWxhdGl2ZSBtYXRjaCBmcm9tIGEgVExEICh0b3AgbGV2ZWwgZG9tYWluKSBtYXRjaCwgd2l0aCBcblx0ICogICB0aGUgY2hhcmFjdGVyIHRoYXQgY29tZXMgYmVmb3JlIHRoZSAnLy8nLlxuXHQgKiAgIFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgXCJtYXRjaCBkZXNjcmlwdGlvbiBvYmplY3RcIi4gVGhpcyB3aWxsIGJlIGBudWxsYCBpZiB0aGUgbWF0Y2ggd2FzIGludmFsaWQsIG9yIGlmIGEgbWF0Y2ggdHlwZSBpcyBkaXNhYmxlZC5cblx0ICogICBPdGhlcndpc2UsIHRoaXMgd2lsbCBiZSBhbiBPYmplY3QgKG1hcCkgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cdCAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJuLnByZWZpeFN0ciBUaGUgY2hhcihzKSB0aGF0IHNob3VsZCBiZSBwcmVwZW5kZWQgdG8gdGhlIHJlcGxhY2VtZW50IHN0cmluZy4gVGhlc2UgYXJlIGNoYXIocykgdGhhdFxuXHQgKiAgIHdlcmUgbmVlZGVkIHRvIGJlIGluY2x1ZGVkIGZyb20gdGhlIHJlZ2V4IG1hdGNoIHRoYXQgd2VyZSBpZ25vcmVkIGJ5IHByb2Nlc3NpbmcgY29kZSwgYW5kIHNob3VsZCBiZSByZS1pbnNlcnRlZCBpbnRvIFxuXHQgKiAgIHRoZSByZXBsYWNlbWVudCBzdHJlYW0uXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJuLnN1ZmZpeFN0ciBUaGUgY2hhcihzKSB0aGF0IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgcmVwbGFjZW1lbnQgc3RyaW5nLiBUaGVzZSBhcmUgY2hhcihzKSB0aGF0XG5cdCAqICAgd2VyZSBuZWVkZWQgdG8gYmUgaW5jbHVkZWQgZnJvbSB0aGUgcmVnZXggbWF0Y2ggdGhhdCB3ZXJlIGlnbm9yZWQgYnkgcHJvY2Vzc2luZyBjb2RlLCBhbmQgc2hvdWxkIGJlIHJlLWluc2VydGVkIGludG8gXG5cdCAqICAgdGhlIHJlcGxhY2VtZW50IHN0cmVhbS5cblx0ICogQHJldHVybiB7QXV0b2xpbmtlci5tYXRjaC5NYXRjaH0gcmV0dXJuLm1hdGNoIFRoZSBNYXRjaCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBtYXRjaCB0aGF0IHdhcyBmb3VuZC5cblx0ICovXG5cdHByb2Nlc3NDYW5kaWRhdGVNYXRjaCA6IGZ1bmN0aW9uKCBcblx0XHRtYXRjaFN0ciwgdHdpdHRlck1hdGNoLCB0d2l0dGVySGFuZGxlUHJlZml4V2hpdGVzcGFjZUNoYXIsIHR3aXR0ZXJIYW5kbGUsIFxuXHRcdGVtYWlsQWRkcmVzc01hdGNoLCB1cmxNYXRjaCwgcHJvdG9jb2xVcmxNYXRjaCwgd3d3UHJvdG9jb2xSZWxhdGl2ZU1hdGNoLCB0bGRQcm90b2NvbFJlbGF0aXZlTWF0Y2hcblx0KSB7XG5cdFx0Ly8gTm90ZTogVGhlIGBtYXRjaFN0cmAgdmFyaWFibGUgd2lsIGJlIGZpeGVkIHVwIHRvIHJlbW92ZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vIGxvbmdlciBuZWVkZWQgKHdoaWNoIHdpbGwgXG5cdFx0Ly8gYmUgYWRkZWQgdG8gYHByZWZpeFN0cmAgYW5kIGBzdWZmaXhTdHJgKS5cblx0XHRcblx0XHR2YXIgcHJvdG9jb2xSZWxhdGl2ZU1hdGNoID0gd3d3UHJvdG9jb2xSZWxhdGl2ZU1hdGNoIHx8IHRsZFByb3RvY29sUmVsYXRpdmVNYXRjaCxcblx0XHQgICAgbWF0Y2gsICAvLyBXaWxsIGJlIGFuIEF1dG9saW5rZXIubWF0Y2guTWF0Y2ggb2JqZWN0XG5cdFx0ICAgIFxuXHRcdCAgICBwcmVmaXhTdHIgPSBcIlwiLCAgICAgICAvLyBBIHN0cmluZyB0byB1c2UgdG8gcHJlZml4IHRoZSBhbmNob3IgdGFnIHRoYXQgaXMgY3JlYXRlZC4gVGhpcyBpcyBuZWVkZWQgZm9yIHRoZSBUd2l0dGVyIGhhbmRsZSBtYXRjaFxuXHRcdCAgICBzdWZmaXhTdHIgPSBcIlwiOyAgICAgICAvLyBBIHN0cmluZyB0byBzdWZmaXggdGhlIGFuY2hvciB0YWcgdGhhdCBpcyBjcmVhdGVkLiBUaGlzIGlzIHVzZWQgaWYgdGhlcmUgaXMgYSB0cmFpbGluZyBwYXJlbnRoZXNpcyB0aGF0IHNob3VsZCBub3QgYmUgYXV0by1saW5rZWQuXG5cdFx0ICAgIFxuXHRcdFxuXHRcdC8vIFJldHVybiBvdXQgd2l0aCBgbnVsbGAgZm9yIG1hdGNoIHR5cGVzIHRoYXQgYXJlIGRpc2FibGVkICh1cmwsIGVtYWlsLCB0d2l0dGVyKSwgb3IgZm9yIG1hdGNoZXMgdGhhdCBhcmUgXG5cdFx0Ly8gaW52YWxpZCAoZmFsc2UgcG9zaXRpdmVzIGZyb20gdGhlIG1hdGNoZXJSZWdleCwgd2hpY2ggY2FuJ3QgdXNlIGxvb2stYmVoaW5kcyBzaW5jZSB0aGV5IGFyZSB1bmF2YWlsYWJsZSBpbiBKUykuXG5cdFx0aWYoXG5cdFx0XHQoIHR3aXR0ZXJNYXRjaCAmJiAhdGhpcy50d2l0dGVyICkgfHwgKCBlbWFpbEFkZHJlc3NNYXRjaCAmJiAhdGhpcy5lbWFpbCApIHx8ICggdXJsTWF0Y2ggJiYgIXRoaXMudXJscyApIHx8XG5cdFx0XHQhdGhpcy5tYXRjaFZhbGlkYXRvci5pc1ZhbGlkTWF0Y2goIHVybE1hdGNoLCBwcm90b2NvbFVybE1hdGNoLCBwcm90b2NvbFJlbGF0aXZlTWF0Y2ggKSBcblx0XHQpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRcblx0XHQvLyBIYW5kbGUgYSBjbG9zaW5nIHBhcmVudGhlc2lzIGF0IHRoZSBlbmQgb2YgdGhlIG1hdGNoLCBhbmQgZXhjbHVkZSBpdCBpZiB0aGVyZSBpcyBub3QgYSBtYXRjaGluZyBvcGVuIHBhcmVudGhlc2lzXG5cdFx0Ly8gaW4gdGhlIG1hdGNoIGl0c2VsZi4gXG5cdFx0aWYoIHRoaXMubWF0Y2hIYXNVbmJhbGFuY2VkQ2xvc2luZ1BhcmVuKCBtYXRjaFN0ciApICkge1xuXHRcdFx0bWF0Y2hTdHIgPSBtYXRjaFN0ci5zdWJzdHIoIDAsIG1hdGNoU3RyLmxlbmd0aCAtIDEgKTsgIC8vIHJlbW92ZSB0aGUgdHJhaWxpbmcgXCIpXCJcblx0XHRcdHN1ZmZpeFN0ciA9IFwiKVwiOyAgLy8gdGhpcyB3aWxsIGJlIGFkZGVkIGFmdGVyIHRoZSBnZW5lcmF0ZWQgPGE+IHRhZ1xuXHRcdH1cblx0XHRcblx0XHRcblx0XHRpZiggZW1haWxBZGRyZXNzTWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IG5ldyBBdXRvbGlua2VyLm1hdGNoLkVtYWlsKCB7IG1hdGNoZWRUZXh0OiBtYXRjaFN0ciwgZW1haWw6IGVtYWlsQWRkcmVzc01hdGNoIH0gKTtcblx0XHRcdFxuXHRcdH0gZWxzZSBpZiggdHdpdHRlck1hdGNoICkge1xuXHRcdFx0Ly8gZml4IHVwIHRoZSBgbWF0Y2hTdHJgIGlmIHRoZXJlIHdhcyBhIHByZWNlZGluZyB3aGl0ZXNwYWNlIGNoYXIsIHdoaWNoIHdhcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIHRoZSBtYXRjaCBcblx0XHRcdC8vIGl0c2VsZiAoc2luY2UgdGhlcmUgYXJlIG5vIGxvb2stYmVoaW5kcyBpbiBKUyByZWdleGVzKVxuXHRcdFx0aWYoIHR3aXR0ZXJIYW5kbGVQcmVmaXhXaGl0ZXNwYWNlQ2hhciApIHtcblx0XHRcdFx0cHJlZml4U3RyID0gdHdpdHRlckhhbmRsZVByZWZpeFdoaXRlc3BhY2VDaGFyO1xuXHRcdFx0XHRtYXRjaFN0ciA9IG1hdGNoU3RyLnNsaWNlKCAxICk7ICAvLyByZW1vdmUgdGhlIHByZWZpeGVkIHdoaXRlc3BhY2UgY2hhciBmcm9tIHRoZSBtYXRjaFxuXHRcdFx0fVxuXHRcdFx0bWF0Y2ggPSBuZXcgQXV0b2xpbmtlci5tYXRjaC5Ud2l0dGVyKCB7IG1hdGNoZWRUZXh0OiBtYXRjaFN0ciwgdHdpdHRlckhhbmRsZTogdHdpdHRlckhhbmRsZSB9ICk7XG5cdFx0XHRcblx0XHR9IGVsc2UgeyAgLy8gdXJsIG1hdGNoXG5cdFx0XHQvLyBJZiBpdCdzIGEgcHJvdG9jb2wtcmVsYXRpdmUgJy8vJyBtYXRjaCwgcmVtb3ZlIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSAnLy8nICh3aGljaCB0aGUgbWF0Y2hlclJlZ2V4IG5lZWRlZFxuXHRcdFx0Ly8gdG8gbWF0Y2ggZHVlIHRvIHRoZSBsYWNrIG9mIGEgbmVnYXRpdmUgbG9vay1iZWhpbmQgaW4gSmF2YVNjcmlwdCByZWd1bGFyIGV4cHJlc3Npb25zKVxuXHRcdFx0aWYoIHByb3RvY29sUmVsYXRpdmVNYXRjaCApIHtcblx0XHRcdFx0dmFyIGNoYXJCZWZvcmVNYXRjaCA9IHByb3RvY29sUmVsYXRpdmVNYXRjaC5tYXRjaCggdGhpcy5jaGFyQmVmb3JlUHJvdG9jb2xSZWxNYXRjaFJlZ2V4IClbIDEgXSB8fCBcIlwiO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYoIGNoYXJCZWZvcmVNYXRjaCApIHsgIC8vIGZpeCB1cCB0aGUgYG1hdGNoU3RyYCBpZiB0aGVyZSB3YXMgYSBwcmVjZWRpbmcgY2hhciBiZWZvcmUgYSBwcm90b2NvbC1yZWxhdGl2ZSBtYXRjaCwgd2hpY2ggd2FzIG5lZWRlZCB0byBkZXRlcm1pbmUgdGhlIG1hdGNoIGl0c2VsZiAoc2luY2UgdGhlcmUgYXJlIG5vIGxvb2stYmVoaW5kcyBpbiBKUyByZWdleGVzKVxuXHRcdFx0XHRcdHByZWZpeFN0ciA9IGNoYXJCZWZvcmVNYXRjaDtcblx0XHRcdFx0XHRtYXRjaFN0ciA9IG1hdGNoU3RyLnNsaWNlKCAxICk7ICAvLyByZW1vdmUgdGhlIHByZWZpeGVkIGNoYXIgZnJvbSB0aGUgbWF0Y2hcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRtYXRjaCA9IG5ldyBBdXRvbGlua2VyLm1hdGNoLlVybCgge1xuXHRcdFx0XHRtYXRjaGVkVGV4dCA6IG1hdGNoU3RyLFxuXHRcdFx0XHR1cmwgOiBtYXRjaFN0cixcblx0XHRcdFx0cHJvdG9jb2xVcmxNYXRjaCA6ICEhcHJvdG9jb2xVcmxNYXRjaCxcblx0XHRcdFx0cHJvdG9jb2xSZWxhdGl2ZU1hdGNoIDogISFwcm90b2NvbFJlbGF0aXZlTWF0Y2gsXG5cdFx0XHRcdHN0cmlwUHJlZml4IDogdGhpcy5zdHJpcFByZWZpeFxuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4ge1xuXHRcdFx0cHJlZml4U3RyIDogcHJlZml4U3RyLFxuXHRcdFx0c3VmZml4U3RyIDogc3VmZml4U3RyLFxuXHRcdFx0bWF0Y2ggICAgIDogbWF0Y2hcblx0XHR9O1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIGEgbWF0Y2ggZm91bmQgaGFzIGFuIHVubWF0Y2hlZCBjbG9zaW5nIHBhcmVudGhlc2lzLiBJZiBzbywgdGhpcyBwYXJlbnRoZXNpcyB3aWxsIGJlIHJlbW92ZWRcblx0ICogZnJvbSB0aGUgbWF0Y2ggaXRzZWxmLCBhbmQgYXBwZW5kZWQgYWZ0ZXIgdGhlIGdlbmVyYXRlZCBhbmNob3IgdGFnIGluIHtAbGluayAjcHJvY2Vzc1RleHROb2RlfS5cblx0ICogXG5cdCAqIEEgbWF0Y2ggbWF5IGhhdmUgYW4gZXh0cmEgY2xvc2luZyBwYXJlbnRoZXNpcyBhdCB0aGUgZW5kIG9mIHRoZSBtYXRjaCBiZWNhdXNlIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gbXVzdCBpbmNsdWRlIHBhcmVudGhlc2lzXG5cdCAqIGZvciBVUkxzIHN1Y2ggYXMgXCJ3aWtpcGVkaWEuY29tL3NvbWV0aGluZ18oZGlzYW1iaWd1YXRpb24pXCIsIHdoaWNoIHNob3VsZCBiZSBhdXRvLWxpbmtlZC4gXG5cdCAqIFxuXHQgKiBIb3dldmVyLCBhbiBleHRyYSBwYXJlbnRoZXNpcyAqd2lsbCogYmUgaW5jbHVkZWQgd2hlbiB0aGUgVVJMIGl0c2VsZiBpcyB3cmFwcGVkIGluIHBhcmVudGhlc2lzLCBzdWNoIGFzIGluIHRoZSBjYXNlIG9mXG5cdCAqIFwiKHdpa2lwZWRpYS5jb20vc29tZXRoaW5nXyhkaXNhbWJpZ3VhdGlvbikpXCIuIEluIHRoaXMgY2FzZSwgdGhlIGxhc3QgY2xvc2luZyBwYXJlbnRoZXNpcyBzaG91bGQgKm5vdCogYmUgcGFydCBvZiB0aGUgVVJMIFxuXHQgKiBpdHNlbGYsIGFuZCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiBgdHJ1ZWAuXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbWF0Y2hTdHIgVGhlIGZ1bGwgbWF0Y2ggc3RyaW5nIGZyb20gdGhlIHtAbGluayAjbWF0Y2hlclJlZ2V4fS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZXJlIGlzIGFuIHVuYmFsYW5jZWQgY2xvc2luZyBwYXJlbnRoZXNpcyBhdCB0aGUgZW5kIG9mIHRoZSBgbWF0Y2hTdHJgLCBgZmFsc2VgIG90aGVyd2lzZS5cblx0ICovXG5cdG1hdGNoSGFzVW5iYWxhbmNlZENsb3NpbmdQYXJlbiA6IGZ1bmN0aW9uKCBtYXRjaFN0ciApIHtcblx0XHR2YXIgbGFzdENoYXIgPSBtYXRjaFN0ci5jaGFyQXQoIG1hdGNoU3RyLmxlbmd0aCAtIDEgKTtcblx0XHRcblx0XHRpZiggbGFzdENoYXIgPT09ICcpJyApIHtcblx0XHRcdHZhciBvcGVuUGFyZW5zTWF0Y2ggPSBtYXRjaFN0ci5tYXRjaCggL1xcKC9nICksXG5cdFx0XHQgICAgY2xvc2VQYXJlbnNNYXRjaCA9IG1hdGNoU3RyLm1hdGNoKCAvXFwpL2cgKSxcblx0XHRcdCAgICBudW1PcGVuUGFyZW5zID0gKCBvcGVuUGFyZW5zTWF0Y2ggJiYgb3BlblBhcmVuc01hdGNoLmxlbmd0aCApIHx8IDAsXG5cdFx0XHQgICAgbnVtQ2xvc2VQYXJlbnMgPSAoIGNsb3NlUGFyZW5zTWF0Y2ggJiYgY2xvc2VQYXJlbnNNYXRjaC5sZW5ndGggKSB8fCAwO1xuXHRcdFx0XG5cdFx0XHRpZiggbnVtT3BlblBhcmVucyA8IG51bUNsb3NlUGFyZW5zICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdFxufSApO1xuLypnbG9iYWwgQXV0b2xpbmtlciAqL1xuLypqc2hpbnQgc2NyaXB0dXJsOnRydWUgKi9cbi8qKlxuICogQHByaXZhdGVcbiAqIEBjbGFzcyBBdXRvbGlua2VyLk1hdGNoVmFsaWRhdG9yXG4gKiBAZXh0ZW5kcyBPYmplY3RcbiAqIFxuICogVXNlZCBieSBBdXRvbGlua2VyIHRvIGZpbHRlciBvdXQgZmFsc2UgcG9zaXRpdmVzIGZyb20gdGhlIHtAbGluayBBdXRvbGlua2VyI21hdGNoZXJSZWdleH0uXG4gKiBcbiAqIER1ZSB0byB0aGUgbGltaXRhdGlvbnMgb2YgcmVndWxhciBleHByZXNzaW9ucyAoaW5jbHVkaW5nIHRoZSBtaXNzaW5nIGZlYXR1cmUgb2YgbG9vay1iZWhpbmRzIGluIEpTIHJlZ3VsYXIgZXhwcmVzc2lvbnMpLFxuICogd2UgY2Fubm90IGFsd2F5cyBkZXRlcm1pbmUgdGhlIHZhbGlkaXR5IG9mIGEgZ2l2ZW4gbWF0Y2guIFRoaXMgY2xhc3MgYXBwbGllcyBhIGJpdCBvZiBhZGRpdGlvbmFsIGxvZ2ljIHRvIGZpbHRlciBvdXQgYW55XG4gKiBmYWxzZSBwb3NpdGl2ZXMgdGhhdCBoYXZlIGJlZW4gbWF0Y2hlZCBieSB0aGUge0BsaW5rIEF1dG9saW5rZXIjbWF0Y2hlclJlZ2V4fS5cbiAqL1xuQXV0b2xpbmtlci5NYXRjaFZhbGlkYXRvciA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xuXHRcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBpbnZhbGlkUHJvdG9jb2xSZWxNYXRjaFJlZ2V4XG5cdCAqIFxuXHQgKiBUaGUgcmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gY2hlY2sgYSBwb3RlbnRpYWwgcHJvdG9jb2wtcmVsYXRpdmUgVVJMIG1hdGNoLCBjb21pbmcgZnJvbSB0aGUgXG5cdCAqIHtAbGluayBBdXRvbGlua2VyI21hdGNoZXJSZWdleH0uIEEgcHJvdG9jb2wtcmVsYXRpdmUgVVJMIGlzLCBmb3IgZXhhbXBsZSwgXCIvL3lhaG9vLmNvbVwiXG5cdCAqIFxuXHQgKiBUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBjaGVja3MgdG8gc2VlIGlmIHRoZXJlIGlzIGEgd29yZCBjaGFyYWN0ZXIgYmVmb3JlIHRoZSAnLy8nIG1hdGNoIGluIG9yZGVyIHRvIGRldGVybWluZSBpZiBcblx0ICogd2Ugc2hvdWxkIGFjdHVhbGx5IGF1dG9saW5rIGEgcHJvdG9jb2wtcmVsYXRpdmUgVVJMLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHRoZXJlIGlzIG5vIG5lZ2F0aXZlIGxvb2stYmVoaW5kIGluIFxuXHQgKiBKYXZhU2NyaXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnMuIFxuXHQgKiBcblx0ICogRm9yIGluc3RhbmNlLCB3ZSB3YW50IHRvIGF1dG9saW5rIHNvbWV0aGluZyBsaWtlIFwiR28gdG86IC8vZ29vZ2xlLmNvbVwiLCBidXQgd2UgZG9uJ3Qgd2FudCB0byBhdXRvbGluayBzb21ldGhpbmcgXG5cdCAqIGxpa2UgXCJhYmMvL2dvb2dsZS5jb21cIlxuXHQgKi9cblx0aW52YWxpZFByb3RvY29sUmVsTWF0Y2hSZWdleCA6IC9eW1xcd11cXC9cXC8vLFxuXHRcblx0LyoqXG5cdCAqIFJlZ2V4IHRvIHRlc3QgZm9yIGEgZnVsbCBwcm90b2NvbCwgd2l0aCB0aGUgdHdvIHRyYWlsaW5nIHNsYXNoZXMuIEV4OiAnaHR0cDovLydcblx0ICogXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBoYXNGdWxsUHJvdG9jb2xSZWdleFxuXHQgKi9cblx0aGFzRnVsbFByb3RvY29sUmVnZXggOiAvXltBLVphLXpdWy0uK0EtWmEtejAtOV0rOlxcL1xcLy8sXG5cdFxuXHQvKipcblx0ICogUmVnZXggdG8gZmluZCB0aGUgVVJJIHNjaGVtZSwgc3VjaCBhcyAnbWFpbHRvOicuXG5cdCAqIFxuXHQgKiBUaGlzIGlzIHVzZWQgdG8gZmlsdGVyIG91dCAnamF2YXNjcmlwdDonIGFuZCAndmJzY3JpcHQ6JyBzY2hlbWVzLlxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHByb3BlcnR5IHtSZWdFeHB9IHVyaVNjaGVtZVJlZ2V4XG5cdCAqL1xuXHR1cmlTY2hlbWVSZWdleCA6IC9eW0EtWmEtel1bLS4rQS1aYS16MC05XSs6Lyxcblx0XG5cdC8qKlxuXHQgKiBSZWdleCB0byBkZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIHdvcmQgY2hhciBleGlzdHMgYWZ0ZXIgdGhlIHByb3RvY29sIChpLmUuIGFmdGVyIHRoZSAnOicpXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gaGFzV29yZENoYXJBZnRlclByb3RvY29sUmVnZXhcblx0ICovXG5cdGhhc1dvcmRDaGFyQWZ0ZXJQcm90b2NvbFJlZ2V4IDogLzpbXlxcc10qP1tBLVphLXpdLyxcblx0XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIG1hdGNoIGZvdW5kIGJ5IHtAbGluayBBdXRvbGlua2VyI3Byb2Nlc3NUZXh0Tm9kZX0gaXMgdmFsaWQuIFdpbGwgcmV0dXJuIGBmYWxzZWAgZm9yOlxuXHQgKiBcblx0ICogMSkgVVJMIG1hdGNoZXMgd2hpY2ggZG8gbm90IGhhdmUgYXQgbGVhc3QgaGF2ZSBvbmUgcGVyaW9kICgnLicpIGluIHRoZSBkb21haW4gbmFtZSAoZWZmZWN0aXZlbHkgc2tpcHBpbmcgb3ZlciBcblx0ICogICAgbWF0Y2hlcyBsaWtlIFwiYWJjOmRlZlwiKS4gSG93ZXZlciwgVVJMIG1hdGNoZXMgd2l0aCBhIHByb3RvY29sIHdpbGwgYmUgYWxsb3dlZCAoZXg6ICdodHRwOi8vbG9jYWxob3N0Jylcblx0ICogMikgVVJMIG1hdGNoZXMgd2hpY2ggZG8gbm90IGhhdmUgYXQgbGVhc3Qgb25lIHdvcmQgY2hhcmFjdGVyIGluIHRoZSBkb21haW4gbmFtZSAoZWZmZWN0aXZlbHkgc2tpcHBpbmcgb3ZlclxuXHQgKiAgICBtYXRjaGVzIGxpa2UgXCJnaXQ6MS4wXCIpLlxuXHQgKiAzKSBBIHByb3RvY29sLXJlbGF0aXZlIHVybCBtYXRjaCAoYSBVUkwgYmVnaW5uaW5nIHdpdGggJy8vJykgd2hvc2UgcHJldmlvdXMgY2hhcmFjdGVyIGlzIGEgd29yZCBjaGFyYWN0ZXIgXG5cdCAqICAgIChlZmZlY3RpdmVseSBza2lwcGluZyBvdmVyIHN0cmluZ3MgbGlrZSBcImFiYy8vZ29vZ2xlLmNvbVwiKVxuXHQgKiBcblx0ICogT3RoZXJ3aXNlLCByZXR1cm5zIGB0cnVlYC5cblx0ICogXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxNYXRjaCBUaGUgbWF0Y2hlZCBVUkwsIGlmIHRoZXJlIHdhcyBvbmUuIFdpbGwgYmUgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSBtYXRjaCBpcyBub3QgYSBVUkwgbWF0Y2guXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbFVybE1hdGNoIFRoZSBtYXRjaCBVUkwgc3RyaW5nIGZvciBhIHByb3RvY29sIG1hdGNoLiBFeDogJ2h0dHA6Ly95YWhvby5jb20nLiBUaGlzIGlzIHVzZWQgdG8gbWF0Y2hcblx0ICogICBzb21ldGhpbmcgbGlrZSAnaHR0cDovL2xvY2FsaG9zdCcsIHdoZXJlIHdlIHdvbid0IGRvdWJsZSBjaGVjayB0aGF0IHRoZSBkb21haW4gbmFtZSBoYXMgYXQgbGVhc3Qgb25lICcuJyBpbiBpdC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sUmVsYXRpdmVNYXRjaCBUaGUgcHJvdG9jb2wtcmVsYXRpdmUgc3RyaW5nIGZvciBhIFVSTCBtYXRjaCAoaS5lLiAnLy8nKSwgcG9zc2libHkgd2l0aCBhIHByZWNlZGluZ1xuXHQgKiAgIGNoYXJhY3RlciAoZXgsIGEgc3BhY2UsIHN1Y2ggYXM6ICcgLy8nLCBvciBhIGxldHRlciwgc3VjaCBhczogJ2EvLycpLiBUaGUgbWF0Y2ggaXMgaW52YWxpZCBpZiB0aGVyZSBpcyBhIHdvcmQgY2hhcmFjdGVyXG5cdCAqICAgcHJlY2VkaW5nIHRoZSAnLy8nLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIG1hdGNoIGdpdmVuIGlzIHZhbGlkIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBvciBgZmFsc2VgIGlmIHRoZSBtYXRjaCBpcyBpbnZhbGlkIGFuZC9vciBcblx0ICogICBzaG91bGQganVzdCBub3QgYmUgcHJvY2Vzc2VkLlxuXHQgKi9cblx0aXNWYWxpZE1hdGNoIDogZnVuY3Rpb24oIHVybE1hdGNoLCBwcm90b2NvbFVybE1hdGNoLCBwcm90b2NvbFJlbGF0aXZlTWF0Y2ggKSB7XG5cdFx0aWYoXG5cdFx0XHQoIHByb3RvY29sVXJsTWF0Y2ggJiYgIXRoaXMuaXNWYWxpZFVyaVNjaGVtZSggcHJvdG9jb2xVcmxNYXRjaCApICkgfHxcblx0XHRcdHRoaXMudXJsTWF0Y2hEb2VzTm90SGF2ZVByb3RvY29sT3JEb3QoIHVybE1hdGNoLCBwcm90b2NvbFVybE1hdGNoICkgfHwgICAgICAgLy8gQXQgbGVhc3Qgb25lIHBlcmlvZCAoJy4nKSBtdXN0IGV4aXN0IGluIHRoZSBVUkwgbWF0Y2ggZm9yIHVzIHRvIGNvbnNpZGVyIGl0IGFuIGFjdHVhbCBVUkwsICp1bmxlc3MqIGl0IHdhcyBhIGZ1bGwgcHJvdG9jb2wgbWF0Y2ggKGxpa2UgJ2h0dHA6Ly9sb2NhbGhvc3QnKVxuXHRcdFx0dGhpcy51cmxNYXRjaERvZXNOb3RIYXZlQXRMZWFzdE9uZVdvcmRDaGFyKCB1cmxNYXRjaCwgcHJvdG9jb2xVcmxNYXRjaCApIHx8ICAvLyBBdCBsZWFzdCBvbmUgbGV0dGVyIGNoYXJhY3RlciBtdXN0IGV4aXN0IGluIHRoZSBkb21haW4gbmFtZSBhZnRlciBhIHByb3RvY29sIG1hdGNoLiBFeDogc2tpcCBvdmVyIHNvbWV0aGluZyBsaWtlIFwiZ2l0OjEuMFwiXG5cdFx0XHR0aGlzLmlzSW52YWxpZFByb3RvY29sUmVsYXRpdmVNYXRjaCggcHJvdG9jb2xSZWxhdGl2ZU1hdGNoICkgICAgICAgICAgICAgICAgIC8vIEEgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2ggd2hpY2ggaGFzIGEgd29yZCBjaGFyYWN0ZXIgaW4gZnJvbnQgb2YgaXQgKHNvIHdlIGNhbiBza2lwIHNvbWV0aGluZyBsaWtlIFwiYWJjLy9nb29nbGUuY29tXCIpXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBVUkkgc2NoZW1lIGlzIGEgdmFsaWQgc2NoZW1lIHRvIGJlIGF1dG9saW5rZWQuIFJldHVybnMgYGZhbHNlYCBpZiB0aGUgc2NoZW1lIGlzIFxuXHQgKiAnamF2YXNjcmlwdDonIG9yICd2YnNjcmlwdDonXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdXJpU2NoZW1lTWF0Y2ggVGhlIG1hdGNoIFVSTCBzdHJpbmcgZm9yIGEgZnVsbCBVUkkgc2NoZW1lIG1hdGNoLiBFeDogJ2h0dHA6Ly95YWhvby5jb20nIFxuXHQgKiAgIG9yICdtYWlsdG86YUBhLmNvbScuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgc2NoZW1lIGlzIGEgdmFsaWQgb25lLCBgZmFsc2VgIG90aGVyd2lzZS5cblx0ICovXG5cdGlzVmFsaWRVcmlTY2hlbWUgOiBmdW5jdGlvbiggdXJpU2NoZW1lTWF0Y2ggKSB7XG5cdFx0dmFyIHVyaVNjaGVtZSA9IHVyaVNjaGVtZU1hdGNoLm1hdGNoKCB0aGlzLnVyaVNjaGVtZVJlZ2V4IClbIDAgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFxuXHRcdHJldHVybiAoIHVyaVNjaGVtZSAhPT0gJ2phdmFzY3JpcHQ6JyAmJiB1cmlTY2hlbWUgIT09ICd2YnNjcmlwdDonICk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgYSBVUkwgbWF0Y2ggZG9lcyBub3QgaGF2ZSBlaXRoZXI6XG5cdCAqIFxuXHQgKiBhKSBhIGZ1bGwgcHJvdG9jb2wgKGkuZS4gJ2h0dHA6Ly8nKSwgb3Jcblx0ICogYikgYXQgbGVhc3Qgb25lIGRvdCAoJy4nKSBpbiB0aGUgZG9tYWluIG5hbWUgKGZvciBhIG5vbi1mdWxsLXByb3RvY29sIG1hdGNoKS5cblx0ICogXG5cdCAqIEVpdGhlciBzaXR1YXRpb24gaXMgY29uc2lkZXJlZCBhbiBpbnZhbGlkIFVSTCAoZXg6ICdnaXQ6ZCcgZG9lcyBub3QgaGF2ZSBlaXRoZXIgdGhlICc6Ly8nIHBhcnQsIG9yIGF0IGxlYXN0IG9uZSBkb3Rcblx0ICogaW4gdGhlIGRvbWFpbiBuYW1lLiBJZiB0aGUgbWF0Y2ggd2FzICdnaXQ6YWJjLmNvbScsIHdlIHdvdWxkIGNvbnNpZGVyIHRoaXMgdmFsaWQuKVxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVybE1hdGNoIFRoZSBtYXRjaGVkIFVSTCwgaWYgdGhlcmUgd2FzIG9uZS4gV2lsbCBiZSBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIG1hdGNoIGlzIG5vdCBhIFVSTCBtYXRjaC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sVXJsTWF0Y2ggVGhlIG1hdGNoIFVSTCBzdHJpbmcgZm9yIGEgcHJvdG9jb2wgbWF0Y2guIEV4OiAnaHR0cDovL3lhaG9vLmNvbScuIFRoaXMgaXMgdXNlZCB0byBtYXRjaFxuXHQgKiAgIHNvbWV0aGluZyBsaWtlICdodHRwOi8vbG9jYWxob3N0Jywgd2hlcmUgd2Ugd29uJ3QgZG91YmxlIGNoZWNrIHRoYXQgdGhlIGRvbWFpbiBuYW1lIGhhcyBhdCBsZWFzdCBvbmUgJy4nIGluIGl0LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIFVSTCBtYXRjaCBkb2VzIG5vdCBoYXZlIGEgZnVsbCBwcm90b2NvbCwgb3IgYXQgbGVhc3Qgb25lIGRvdCAoJy4nKSBpbiBhIG5vbi1mdWxsLXByb3RvY29sXG5cdCAqICAgbWF0Y2guXG5cdCAqL1xuXHR1cmxNYXRjaERvZXNOb3RIYXZlUHJvdG9jb2xPckRvdCA6IGZ1bmN0aW9uKCB1cmxNYXRjaCwgcHJvdG9jb2xVcmxNYXRjaCApIHtcblx0XHRyZXR1cm4gKCAhIXVybE1hdGNoICYmICggIXByb3RvY29sVXJsTWF0Y2ggfHwgIXRoaXMuaGFzRnVsbFByb3RvY29sUmVnZXgudGVzdCggcHJvdG9jb2xVcmxNYXRjaCApICkgJiYgdXJsTWF0Y2guaW5kZXhPZiggJy4nICkgPT09IC0xICk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgYSBVUkwgbWF0Y2ggZG9lcyBub3QgaGF2ZSBhdCBsZWFzdCBvbmUgd29yZCBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIHByb3RvY29sIChpLmUuIGluIHRoZSBkb21haW4gbmFtZSkuXG5cdCAqIFxuXHQgKiBBdCBsZWFzdCBvbmUgbGV0dGVyIGNoYXJhY3RlciBtdXN0IGV4aXN0IGluIHRoZSBkb21haW4gbmFtZSBhZnRlciBhIHByb3RvY29sIG1hdGNoLiBFeDogc2tpcCBvdmVyIHNvbWV0aGluZyBcblx0ICogbGlrZSBcImdpdDoxLjBcIlxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVybE1hdGNoIFRoZSBtYXRjaGVkIFVSTCwgaWYgdGhlcmUgd2FzIG9uZS4gV2lsbCBiZSBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIG1hdGNoIGlzIG5vdCBhIFVSTCBtYXRjaC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sVXJsTWF0Y2ggVGhlIG1hdGNoIFVSTCBzdHJpbmcgZm9yIGEgcHJvdG9jb2wgbWF0Y2guIEV4OiAnaHR0cDovL3lhaG9vLmNvbScuIFRoaXMgaXMgdXNlZCB0b1xuXHQgKiAgIGtub3cgd2hldGhlciBvciBub3Qgd2UgaGF2ZSBhIHByb3RvY29sIGluIHRoZSBVUkwgc3RyaW5nLCBpbiBvcmRlciB0byBjaGVjayBmb3IgYSB3b3JkIGNoYXJhY3RlciBhZnRlciB0aGUgcHJvdG9jb2xcblx0ICogICBzZXBhcmF0b3IgKCc6JykuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgVVJMIG1hdGNoIGRvZXMgbm90IGhhdmUgYXQgbGVhc3Qgb25lIHdvcmQgY2hhcmFjdGVyIGluIGl0IGFmdGVyIHRoZSBwcm90b2NvbCwgYGZhbHNlYFxuXHQgKiAgIG90aGVyd2lzZS5cblx0ICovXG5cdHVybE1hdGNoRG9lc05vdEhhdmVBdExlYXN0T25lV29yZENoYXIgOiBmdW5jdGlvbiggdXJsTWF0Y2gsIHByb3RvY29sVXJsTWF0Y2ggKSB7XG5cdFx0aWYoIHVybE1hdGNoICYmIHByb3RvY29sVXJsTWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gIXRoaXMuaGFzV29yZENoYXJBZnRlclByb3RvY29sUmVnZXgudGVzdCggdXJsTWF0Y2ggKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiBhIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoIGlzIGFuIGludmFsaWQgb25lLiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSBpcyBhIGBwcm90b2NvbFJlbGF0aXZlTWF0Y2hgLFxuXHQgKiBhbmQgdGhhdCBtYXRjaCBjb250YWlucyBhIHdvcmQgY2hhcmFjdGVyIGJlZm9yZSB0aGUgJy8vJyAoaS5lLiBpdCBtdXN0IGNvbnRhaW4gd2hpdGVzcGFjZSBvciBub3RoaW5nIGJlZm9yZSB0aGUgJy8vJyBpblxuXHQgKiBvcmRlciB0byBiZSBjb25zaWRlcmVkIHZhbGlkKS5cblx0ICogXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbFJlbGF0aXZlTWF0Y2ggVGhlIHByb3RvY29sLXJlbGF0aXZlIHN0cmluZyBmb3IgYSBVUkwgbWF0Y2ggKGkuZS4gJy8vJyksIHBvc3NpYmx5IHdpdGggYSBwcmVjZWRpbmdcblx0ICogICBjaGFyYWN0ZXIgKGV4LCBhIHNwYWNlLCBzdWNoIGFzOiAnIC8vJywgb3IgYSBsZXR0ZXIsIHN1Y2ggYXM6ICdhLy8nKS4gVGhlIG1hdGNoIGlzIGludmFsaWQgaWYgdGhlcmUgaXMgYSB3b3JkIGNoYXJhY3RlclxuXHQgKiAgIHByZWNlZGluZyB0aGUgJy8vJy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGl0IGlzIGFuIGludmFsaWQgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2gsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuXHQgKi9cblx0aXNJbnZhbGlkUHJvdG9jb2xSZWxhdGl2ZU1hdGNoIDogZnVuY3Rpb24oIHByb3RvY29sUmVsYXRpdmVNYXRjaCApIHtcblx0XHRyZXR1cm4gKCAhIXByb3RvY29sUmVsYXRpdmVNYXRjaCAmJiB0aGlzLmludmFsaWRQcm90b2NvbFJlbE1hdGNoUmVnZXgudGVzdCggcHJvdG9jb2xSZWxhdGl2ZU1hdGNoICkgKTtcblx0fVxuXG59ICk7XG4vKmdsb2JhbCBBdXRvbGlua2VyICovXG4vKipcbiAqIEBhYnN0cmFjdFxuICogQGNsYXNzIEF1dG9saW5rZXIubWF0Y2guTWF0Y2hcbiAqIFxuICogUmVwcmVzZW50cyBhIG1hdGNoIGZvdW5kIGluIGFuIGlucHV0IHN0cmluZyB3aGljaCBzaG91bGQgYmUgQXV0b2xpbmtlZC4gQSBNYXRjaCBvYmplY3QgaXMgd2hhdCBpcyBwcm92aWRlZCBpbiBhIFxuICoge0BsaW5rIEF1dG9saW5rZXIjcmVwbGFjZUZuIHJlcGxhY2VGbn0sIGFuZCBtYXkgYmUgdXNlZCB0byBxdWVyeSBmb3IgZGV0YWlscyBhYm91dCB0aGUgbWF0Y2guXG4gKiBcbiAqIEZvciBleGFtcGxlOlxuICogXG4gKiAgICAgdmFyIGlucHV0ID0gXCIuLi5cIjsgIC8vIHN0cmluZyB3aXRoIFVSTHMsIEVtYWlsIEFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgSGFuZGxlc1xuICogICAgIFxuICogICAgIHZhciBsaW5rZWRUZXh0ID0gQXV0b2xpbmtlci5saW5rKCBpbnB1dCwge1xuICogICAgICAgICByZXBsYWNlRm4gOiBmdW5jdGlvbiggYXV0b2xpbmtlciwgbWF0Y2ggKSB7XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJocmVmID0gXCIsIG1hdGNoLmdldEFuY2hvckhyZWYoKSApO1xuICogICAgICAgICAgICAgY29uc29sZS5sb2coIFwidGV4dCA9IFwiLCBtYXRjaC5nZXRBbmNob3JUZXh0KCkgKTtcbiAqICAgICAgICAgXG4gKiAgICAgICAgICAgICBzd2l0Y2goIG1hdGNoLmdldFR5cGUoKSApIHtcbiAqICAgICAgICAgICAgICAgICBjYXNlICd1cmwnIDogXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcInVybDogXCIsIG1hdGNoLmdldFVybCgpICk7XG4gKiAgICAgICAgICAgICAgICAgICAgIFxuICogICAgICAgICAgICAgICAgIGNhc2UgJ2VtYWlsJyA6XG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcImVtYWlsOiBcIiwgbWF0Y2guZ2V0RW1haWwoKSApO1xuICogICAgICAgICAgICAgICAgICAgICBcbiAqICAgICAgICAgICAgICAgICBjYXNlICd0d2l0dGVyJyA6XG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcInR3aXR0ZXI6IFwiLCBtYXRjaC5nZXRUd2l0dGVySGFuZGxlKCkgKTtcbiAqICAgICAgICAgICAgIH1cbiAqICAgICAgICAgfVxuICogICAgIH0gKTtcbiAqICAgICBcbiAqIFNlZSB0aGUge0BsaW5rIEF1dG9saW5rZXJ9IGNsYXNzIGZvciBtb3JlIGRldGFpbHMgb24gdXNpbmcgdGhlIHtAbGluayBBdXRvbGlua2VyI3JlcGxhY2VGbiByZXBsYWNlRm59LlxuICovXG5BdXRvbGlua2VyLm1hdGNoLk1hdGNoID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggT2JqZWN0LCB7XG5cdFxuXHQvKipcblx0ICogQGNmZyB7U3RyaW5nfSBtYXRjaGVkVGV4dCAocmVxdWlyZWQpXG5cdCAqIFxuXHQgKiBUaGUgb3JpZ2luYWwgdGV4dCB0aGF0IHdhcyBtYXRjaGVkLlxuXHQgKi9cblx0XG5cdFxuXHQvKipcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBmb3IgdGhlIE1hdGNoIGluc3RhbmNlLCBzcGVjaWZpZWQgaW4gYW4gT2JqZWN0IChtYXApLlxuXHQgKi9cblx0Y29uc3RydWN0b3IgOiBmdW5jdGlvbiggY2ZnICkge1xuXHRcdEF1dG9saW5rZXIuVXRpbC5hc3NpZ24oIHRoaXMsIGNmZyApO1xuXHR9LFxuXG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyBuYW1lIGZvciB0aGUgdHlwZSBvZiBtYXRjaCB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cblx0ICogXG5cdCAqIEBhYnN0cmFjdFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRUeXBlIDogQXV0b2xpbmtlci5VdGlsLmFic3RyYWN0TWV0aG9kLFxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCB0ZXh0IHRoYXQgd2FzIG1hdGNoZWQuXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRNYXRjaGVkVGV4dCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hdGNoZWRUZXh0O1xuXHR9LFxuXHRcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIGhyZWYgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXG5cdCAqIFxuXHQgKiBAYWJzdHJhY3Rcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0QW5jaG9ySHJlZiA6IEF1dG9saW5rZXIuVXRpbC5hYnN0cmFjdE1ldGhvZCxcblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIHRleHQgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXG5cdCAqIFxuXHQgKiBAYWJzdHJhY3Rcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0QW5jaG9yVGV4dCA6IEF1dG9saW5rZXIuVXRpbC5hYnN0cmFjdE1ldGhvZFxuXG59ICk7XG4vKmdsb2JhbCBBdXRvbGlua2VyICovXG4vKipcbiAqIEBjbGFzcyBBdXRvbGlua2VyLm1hdGNoLkVtYWlsXG4gKiBAZXh0ZW5kcyBBdXRvbGlua2VyLm1hdGNoLk1hdGNoXG4gKiBcbiAqIFJlcHJlc2VudHMgYSBFbWFpbCBtYXRjaCBmb3VuZCBpbiBhbiBpbnB1dCBzdHJpbmcgd2hpY2ggc2hvdWxkIGJlIEF1dG9saW5rZWQuXG4gKiBcbiAqIFNlZSB0aGlzIGNsYXNzJ3Mgc3VwZXJjbGFzcyAoe0BsaW5rIEF1dG9saW5rZXIubWF0Y2guTWF0Y2h9KSBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG5BdXRvbGlua2VyLm1hdGNoLkVtYWlsID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggQXV0b2xpbmtlci5tYXRjaC5NYXRjaCwge1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge1N0cmluZ30gZW1haWwgKHJlcXVpcmVkKVxuXHQgKiBcblx0ICogVGhlIGVtYWlsIGFkZHJlc3MgdGhhdCB3YXMgbWF0Y2hlZC5cblx0ICovXG5cdFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlIG9mIG1hdGNoIHRoYXQgdGhpcyBjbGFzcyByZXByZXNlbnRzLlxuXHQgKiBcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0VHlwZSA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAnZW1haWwnO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBlbWFpbCBhZGRyZXNzIHRoYXQgd2FzIG1hdGNoZWQuXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRFbWFpbCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVtYWlsO1xuXHR9LFxuXHRcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIGhyZWYgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRBbmNob3JIcmVmIDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdtYWlsdG86JyArIHRoaXMuZW1haWw7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFuY2hvciB0ZXh0IHRoYXQgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3IgdGhlIG1hdGNoLlxuXHQgKiBcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0QW5jaG9yVGV4dCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVtYWlsO1xuXHR9XG5cdFxufSApO1xuLypnbG9iYWwgQXV0b2xpbmtlciAqL1xuLyoqXG4gKiBAY2xhc3MgQXV0b2xpbmtlci5tYXRjaC5Ud2l0dGVyXG4gKiBAZXh0ZW5kcyBBdXRvbGlua2VyLm1hdGNoLk1hdGNoXG4gKiBcbiAqIFJlcHJlc2VudHMgYSBUd2l0dGVyIG1hdGNoIGZvdW5kIGluIGFuIGlucHV0IHN0cmluZyB3aGljaCBzaG91bGQgYmUgQXV0b2xpbmtlZC5cbiAqIFxuICogU2VlIHRoaXMgY2xhc3MncyBzdXBlcmNsYXNzICh7QGxpbmsgQXV0b2xpbmtlci5tYXRjaC5NYXRjaH0pIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbkF1dG9saW5rZXIubWF0Y2guVHdpdHRlciA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIEF1dG9saW5rZXIubWF0Y2guTWF0Y2gsIHtcblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtTdHJpbmd9IHR3aXR0ZXJIYW5kbGUgKHJlcXVpcmVkKVxuXHQgKiBcblx0ICogVGhlIFR3aXR0ZXIgaGFuZGxlIHRoYXQgd2FzIG1hdGNoZWQuXG5cdCAqL1xuXHRcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdHlwZSBvZiBtYXRjaCB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cblx0ICogXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldFR5cGUgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ3R3aXR0ZXInO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlIG9mIG1hdGNoIHRoYXQgdGhpcyBjbGFzcyByZXByZXNlbnRzLlxuXHQgKiBcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0VHdpdHRlckhhbmRsZSA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnR3aXR0ZXJIYW5kbGU7XG5cdH0sXG5cdFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhbmNob3IgaHJlZiB0aGF0IHNob3VsZCBiZSBnZW5lcmF0ZWQgZm9yIHRoZSBtYXRjaC5cblx0ICogXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldEFuY2hvckhyZWYgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ2h0dHBzOi8vdHdpdHRlci5jb20vJyArIHRoaXMudHdpdHRlckhhbmRsZTtcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIHRleHQgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRBbmNob3JUZXh0IDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdAJyArIHRoaXMudHdpdHRlckhhbmRsZTtcblx0fVxuXHRcbn0gKTtcbi8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cbi8qKlxuICogQGNsYXNzIEF1dG9saW5rZXIubWF0Y2guVXJsXG4gKiBAZXh0ZW5kcyBBdXRvbGlua2VyLm1hdGNoLk1hdGNoXG4gKiBcbiAqIFJlcHJlc2VudHMgYSBVcmwgbWF0Y2ggZm91bmQgaW4gYW4gaW5wdXQgc3RyaW5nIHdoaWNoIHNob3VsZCBiZSBBdXRvbGlua2VkLlxuICogXG4gKiBTZWUgdGhpcyBjbGFzcydzIHN1cGVyY2xhc3MgKHtAbGluayBBdXRvbGlua2VyLm1hdGNoLk1hdGNofSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xuQXV0b2xpbmtlci5tYXRjaC5VcmwgPSBBdXRvbGlua2VyLlV0aWwuZXh0ZW5kKCBBdXRvbGlua2VyLm1hdGNoLk1hdGNoLCB7XG5cdFxuXHQvKipcblx0ICogQGNmZyB7U3RyaW5nfSB1cmwgKHJlcXVpcmVkKVxuXHQgKiBcblx0ICogVGhlIHVybCB0aGF0IHdhcyBtYXRjaGVkLlxuXHQgKi9cblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtCb29sZWFufSBwcm90b2NvbFVybE1hdGNoIChyZXF1aXJlZClcblx0ICogXG5cdCAqIGB0cnVlYCBpZiB0aGUgVVJMIGlzIGEgbWF0Y2ggd2hpY2ggYWxyZWFkeSBoYXMgYSBwcm90b2NvbCAoaS5lLiAnaHR0cDovLycpLCBgZmFsc2VgIGlmIHRoZSBtYXRjaCB3YXMgZnJvbSBhICd3d3cnIG9yXG5cdCAqIGtub3duIFRMRCBtYXRjaC5cblx0ICovXG5cdFxuXHQvKipcblx0ICogQGNmZyB7Qm9vbGVhbn0gcHJvdG9jb2xSZWxhdGl2ZU1hdGNoIChyZXF1aXJlZClcblx0ICogXG5cdCAqIGB0cnVlYCBpZiB0aGUgVVJMIGlzIGEgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2guIEEgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2ggaXMgYSBVUkwgdGhhdCBzdGFydHMgd2l0aCAnLy8nLFxuXHQgKiBhbmQgd2lsbCBiZSBlaXRoZXIgaHR0cDovLyBvciBodHRwczovLyBiYXNlZCBvbiB0aGUgcHJvdG9jb2wgdGhhdCB0aGUgc2l0ZSBpcyBsb2FkZWQgdW5kZXIuXG5cdCAqL1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge0Jvb2xlYW59IHN0cmlwUHJlZml4IChyZXF1aXJlZClcblx0ICogQGluaGVyaXRkb2MgQXV0b2xpbmtlciNzdHJpcFByZWZpeFxuXHQgKi9cblx0XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSB1cmxQcmVmaXhSZWdleFxuXHQgKiBcblx0ICogQSByZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byByZW1vdmUgdGhlICdodHRwOi8vJyBvciAnaHR0cHM6Ly8nIGFuZC9vciB0aGUgJ3d3dy4nIGZyb20gVVJMcy5cblx0ICovXG5cdHVybFByZWZpeFJlZ2V4OiAvXihodHRwcz86XFwvXFwvKT8od3d3XFwuKT8vaSxcblx0XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gcHJvdG9jb2xSZWxhdGl2ZVJlZ2V4XG5cdCAqIFxuXHQgKiBUaGUgcmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gcmVtb3ZlIHRoZSBwcm90b2NvbC1yZWxhdGl2ZSAnLy8nIGZyb20gdGhlIHtAbGluayAjdXJsfSBzdHJpbmcsIGZvciBwdXJwb3Nlc1xuXHQgKiBvZiB7QGxpbmsgI2dldEFuY2hvclRleHR9LiBBIHByb3RvY29sLXJlbGF0aXZlIFVSTCBpcywgZm9yIGV4YW1wbGUsIFwiLy95YWhvby5jb21cIlxuXHQgKi9cblx0cHJvdG9jb2xSZWxhdGl2ZVJlZ2V4IDogL15cXC9cXC8vLFxuXHRcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gcHJvdG9jb2xQcmVwZW5kZWRcblx0ICogXG5cdCAqIFdpbGwgYmUgc2V0IHRvIGB0cnVlYCBpZiB0aGUgJ2h0dHA6Ly8nIHByb3RvY29sIGhhcyBiZWVuIHByZXBlbmRlZCB0byB0aGUge0BsaW5rICN1cmx9IChiZWNhdXNlIHRoZVxuXHQgKiB7QGxpbmsgI3VybH0gZGlkIG5vdCBoYXZlIGEgcHJvdG9jb2wpXG5cdCAqL1xuXHRwcm90b2NvbFByZXBlbmRlZCA6IGZhbHNlLFxuXHRcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyBuYW1lIGZvciB0aGUgdHlwZSBvZiBtYXRjaCB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cblx0ICogXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldFR5cGUgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ3VybCc7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHVybCB0aGF0IHdhcyBtYXRjaGVkLCBhc3N1bWluZyB0aGUgcHJvdG9jb2wgdG8gYmUgJ2h0dHA6Ly8nIGlmIHRoZSBvcmlnaW5hbFxuXHQgKiBtYXRjaCB3YXMgbWlzc2luZyBhIHByb3RvY29sLlxuXHQgKiBcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0VXJsIDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHVybCA9IHRoaXMudXJsO1xuXHRcdFxuXHRcdC8vIGlmIHRoZSB1cmwgc3RyaW5nIGRvZXNuJ3QgYmVnaW4gd2l0aCBhIHByb3RvY29sLCBhc3N1bWUgJ2h0dHA6Ly8nXG5cdFx0aWYoICF0aGlzLnByb3RvY29sUmVsYXRpdmVNYXRjaCAmJiAhdGhpcy5wcm90b2NvbFVybE1hdGNoICYmICF0aGlzLnByb3RvY29sUHJlcGVuZGVkICkge1xuXHRcdFx0dXJsID0gdGhpcy51cmwgPSAnaHR0cDovLycgKyB1cmw7XG5cdFx0XHRcblx0XHRcdHRoaXMucHJvdG9jb2xQcmVwZW5kZWQgPSB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gdXJsO1xuXHR9LFxuXHRcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIGhyZWYgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRBbmNob3JIcmVmIDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHVybCA9IHRoaXMuZ2V0VXJsKCk7XG5cdFx0XG5cdFx0cmV0dXJuIHVybC5yZXBsYWNlKCAvJmFtcDsvZywgJyYnICk7ICAvLyBhbnkgJmFtcDsncyBpbiB0aGUgVVJMIHNob3VsZCBiZSBjb252ZXJ0ZWQgYmFjayB0byAnJicgaWYgdGhleSB3ZXJlIGRpc3BsYXllZCBhcyAmYW1wOyBpbiB0aGUgc291cmNlIGh0bWwgXG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFuY2hvciB0ZXh0IHRoYXQgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3IgdGhlIG1hdGNoLlxuXHQgKiBcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0QW5jaG9yVGV4dCA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhbmNob3JUZXh0ID0gdGhpcy5nZXRVcmwoKTtcblx0XHRcblx0XHRpZiggdGhpcy5wcm90b2NvbFJlbGF0aXZlTWF0Y2ggKSB7XG5cdFx0XHQvLyBTdHJpcCBvZmYgYW55IHByb3RvY29sLXJlbGF0aXZlICcvLycgZnJvbSB0aGUgYW5jaG9yIHRleHRcblx0XHRcdGFuY2hvclRleHQgPSB0aGlzLnN0cmlwUHJvdG9jb2xSZWxhdGl2ZVByZWZpeCggYW5jaG9yVGV4dCApO1xuXHRcdH1cblx0XHRpZiggdGhpcy5zdHJpcFByZWZpeCApIHtcblx0XHRcdGFuY2hvclRleHQgPSB0aGlzLnN0cmlwVXJsUHJlZml4KCBhbmNob3JUZXh0ICk7XG5cdFx0fVxuXHRcdGFuY2hvclRleHQgPSB0aGlzLnJlbW92ZVRyYWlsaW5nU2xhc2goIGFuY2hvclRleHQgKTsgIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaCwgaWYgdGhlcmUgaXMgb25lXG5cdFx0XG5cdFx0cmV0dXJuIGFuY2hvclRleHQ7XG5cdH0sXG5cdFxuXHRcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFxuXHQvLyBVdGlsaXR5IEZ1bmN0aW9uYWxpdHlcblx0XG5cdC8qKlxuXHQgKiBTdHJpcHMgdGhlIFVSTCBwcmVmaXggKHN1Y2ggYXMgXCJodHRwOi8vXCIgb3IgXCJodHRwczovL1wiKSBmcm9tIHRoZSBnaXZlbiB0ZXh0LlxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgb2YgdGhlIGFuY2hvciB0aGF0IGlzIGJlaW5nIGdlbmVyYXRlZCwgZm9yIHdoaWNoIHRvIHN0cmlwIG9mZiB0aGVcblx0ICogICB1cmwgcHJlZml4IChzdWNoIGFzIHN0cmlwcGluZyBvZmYgXCJodHRwOi8vXCIpXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGBhbmNob3JUZXh0YCwgd2l0aCB0aGUgcHJlZml4IHN0cmlwcGVkLlxuXHQgKi9cblx0c3RyaXBVcmxQcmVmaXggOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dC5yZXBsYWNlKCB0aGlzLnVybFByZWZpeFJlZ2V4LCAnJyApO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBTdHJpcHMgYW55IHByb3RvY29sLXJlbGF0aXZlICcvLycgZnJvbSB0aGUgYW5jaG9yIHRleHQuXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCBvZiB0aGUgYW5jaG9yIHRoYXQgaXMgYmVpbmcgZ2VuZXJhdGVkLCBmb3Igd2hpY2ggdG8gc3RyaXAgb2ZmIHRoZVxuXHQgKiAgIHByb3RvY29sLXJlbGF0aXZlIHByZWZpeCAoc3VjaCBhcyBzdHJpcHBpbmcgb2ZmIFwiLy9cIilcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgYGFuY2hvclRleHRgLCB3aXRoIHRoZSBwcm90b2NvbC1yZWxhdGl2ZSBwcmVmaXggc3RyaXBwZWQuXG5cdCAqL1xuXHRzdHJpcFByb3RvY29sUmVsYXRpdmVQcmVmaXggOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dC5yZXBsYWNlKCB0aGlzLnByb3RvY29sUmVsYXRpdmVSZWdleCwgJycgKTtcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogUmVtb3ZlcyBhbnkgdHJhaWxpbmcgc2xhc2ggZnJvbSB0aGUgZ2l2ZW4gYGFuY2hvclRleHRgLCBpbiBwcmVwYXJhdGlvbiBmb3IgdGhlIHRleHQgdG8gYmUgZGlzcGxheWVkLlxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGFuY2hvclRleHQgVGhlIHRleHQgb2YgdGhlIGFuY2hvciB0aGF0IGlzIGJlaW5nIGdlbmVyYXRlZCwgZm9yIHdoaWNoIHRvIHJlbW92ZSBhbnkgdHJhaWxpbmdcblx0ICogICBzbGFzaCAoJy8nKSB0aGF0IG1heSBleGlzdC5cblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgYGFuY2hvclRleHRgLCB3aXRoIHRoZSB0cmFpbGluZyBzbGFzaCByZW1vdmVkLlxuXHQgKi9cblx0cmVtb3ZlVHJhaWxpbmdTbGFzaCA6IGZ1bmN0aW9uKCBhbmNob3JUZXh0ICkge1xuXHRcdGlmKCBhbmNob3JUZXh0LmNoYXJBdCggYW5jaG9yVGV4dC5sZW5ndGggLSAxICkgPT09ICcvJyApIHtcblx0XHRcdGFuY2hvclRleHQgPSBhbmNob3JUZXh0LnNsaWNlKCAwLCAtMSApO1xuXHRcdH1cblx0XHRyZXR1cm4gYW5jaG9yVGV4dDtcblx0fVxuXHRcbn0gKTtcbnJldHVybiBBdXRvbGlua2VyO1xuXG59KSk7XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKlxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG5DU1MzIEFOSU1BVElPTiBDSEVBVCBTSEVFVFxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG5cXHJcXG5NYWRlIGJ5IEp1c3RpbiBBZ3VpbGFyXFxyXFxuXFxyXFxud3d3Lmp1c3RpbmFndWlsYXIuY29tL2FuaW1hdGlvbnMvXFxyXFxuXFxyXFxuUXVlc3Rpb25zLCBjb21tZW50cywgY29uY2VybnMsIGxvdmUgbGV0dGVyczpcXHJcXG5qdXN0aW5AanVzdGluYWd1aWxhci5jb21cXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG4vKlxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG5zbGlkZURvd25cXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG5cXHJcXG4uc2xpZGVEb3due1xcclxcblxcdGFuaW1hdGlvbi1uYW1lOiBzbGlkZURvd247XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tbmFtZTogc2xpZGVEb3duO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMXM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDFzO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2U7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlO1xcclxcblxcclxcblxcdHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBzbGlkZURvd24ge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMCUpO1xcclxcblxcdH1cXHJcXG5cXHQ1MCV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDglKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjUle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNCUpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDQlKTtcXHJcXG5cXHR9XFxyXFxuXFx0OTUle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMiUpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIHNsaWRlRG93biB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDAlKTtcXHJcXG5cXHR9XFxyXFxuXFx0NTAle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDglKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjUle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC00JSk7XFxyXFxuXFx0fVxcclxcblxcdDgwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSg0JSk7XFxyXFxuXFx0fVxcclxcblxcdDk1JXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMiUpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG5zbGlkZVVwXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuXFxyXFxuLnNsaWRlVXB7XFxyXFxuXFx0YW5pbWF0aW9uLW5hbWU6IHNsaWRlVXA7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tbmFtZTogc2xpZGVVcDtcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDFzO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAxcztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZTtcXHJcXG5cXHJcXG5cXHR2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgc2xpZGVVcCB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgxMDAlKTtcXHJcXG5cXHR9XFxyXFxuXFx0NTAle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtOCUpO1xcclxcblxcdH1cXHJcXG5cXHQ2NSV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDQlKTtcXHJcXG5cXHR9XFxyXFxuXFx0ODAle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNCUpO1xcclxcblxcdH1cXHJcXG5cXHQ5NSV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIlKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBzbGlkZVVwIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMTAwJSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtOCUpO1xcclxcblxcdH1cXHJcXG5cXHQ2NSV7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoNCUpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCV7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTQlKTtcXHJcXG5cXHR9XFxyXFxuXFx0OTUle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIlKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuc2xpZGVMZWZ0XFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuXFxyXFxuLnNsaWRlTGVmdHtcXHJcXG5cXHRhbmltYXRpb24tbmFtZTogc2xpZGVMZWZ0O1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IHNsaWRlTGVmdDtcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDFzO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAxcztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluLW91dDtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2UtaW4tb3V0O1xcclxcblxcclxcblxcdHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBzbGlkZUxlZnQge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMTUwJSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTglKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjUle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWCg0JSk7XFxyXFxuXFx0fVxcclxcblxcdDgwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTQlKTtcXHJcXG5cXHR9XFxyXFxuXFx0OTUle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWCgyJSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwJSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG5ALXdlYmtpdC1rZXlmcmFtZXMgc2xpZGVMZWZ0IHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMTUwJSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtOCUpO1xcclxcblxcdH1cXHJcXG5cXHQ2NSV7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoNCUpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCV7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTQlKTtcXHJcXG5cXHR9XFxyXFxuXFx0OTUle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIlKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCUpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuc2xpZGVSaWdodFxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG4qL1xcclxcblxcclxcblxcclxcbi5zbGlkZVJpZ2h0e1xcclxcblxcdGFuaW1hdGlvbi1uYW1lOiBzbGlkZVJpZ2h0O1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IHNsaWRlUmlnaHQ7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLWR1cmF0aW9uOiAxcztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMXM7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbi1vdXQ7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluLW91dDtcXHJcXG5cXHJcXG5cXHR2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgc2xpZGVSaWdodCB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMTUwJSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoOCUpO1xcclxcblxcdH1cXHJcXG5cXHQ2NSV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVYKC00JSk7XFxyXFxuXFx0fVxcclxcblxcdDgwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoNCUpO1xcclxcblxcdH1cXHJcXG5cXHQ5NSV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yJSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwJSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG5ALXdlYmtpdC1rZXlmcmFtZXMgc2xpZGVSaWdodCB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0xNTAlKTtcXHJcXG5cXHR9XFxyXFxuXFx0NTAle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDglKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjUle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC00JSk7XFxyXFxuXFx0fVxcclxcblxcdDgwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCg0JSk7XFxyXFxuXFx0fVxcclxcblxcdDk1JXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMiUpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwJSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG5zbGlkZUV4cGFuZFVwXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuXFxyXFxuLnNsaWRlRXhwYW5kVXB7XFxyXFxuXFx0YW5pbWF0aW9uLW5hbWU6IHNsaWRlRXhwYW5kVXA7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tbmFtZTogc2xpZGVFeHBhbmRVcDtcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDEuNnM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDEuNnM7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1vdXQ7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlIC1vdXQ7XFxyXFxuXFxyXFxuXFx0dmlzaWJpbGl0eTogdmlzaWJsZSAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIHNsaWRlRXhwYW5kVXAge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMTAwJSkgc2NhbGVYKDAuNSk7XFxyXFxuXFx0fVxcclxcblxcdDMwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTglKSBzY2FsZVgoMC41KTtcXHJcXG5cXHR9XFxyXFxuXFx0NDAle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgyJSkgc2NhbGVYKDAuNSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWCgxLjEpO1xcclxcblxcdH1cXHJcXG5cXHQ2MCV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKSBzY2FsZVgoMC45KTtcXHJcXG5cXHR9XFxyXFxuXFx0NzAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWCgxLjA1KTtcXHJcXG5cXHR9XFxyXFxuXFx0ODAle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVYKDAuOTUpO1xcclxcblxcdH1cXHJcXG5cXHQ5MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVYKDEuMDIpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVYKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIHNsaWRlRXhwYW5kVXAge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgxMDAlKSBzY2FsZVgoMC41KTtcXHJcXG5cXHR9XFxyXFxuXFx0MzAle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC04JSkgc2NhbGVYKDAuNSk7XFxyXFxuXFx0fVxcclxcblxcdDQwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgyJSkgc2NhbGVYKDAuNSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVYKDEuMSk7XFxyXFxuXFx0fVxcclxcblxcdDYwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVYKDAuOSk7XFxyXFxuXFx0fVxcclxcblxcdDcwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWCgxLjA1KTtcXHJcXG5cXHR9XFxyXFxuXFx0ODAle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKSBzY2FsZVgoMC45NSk7XFxyXFxuXFx0fVxcclxcblxcdDkwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWCgxLjAyKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVYKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuZXhwYW5kVXBcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG5cXHJcXG4uZXhwYW5kVXB7XFxyXFxuXFx0YW5pbWF0aW9uLW5hbWU6IGV4cGFuZFVwO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGV4cGFuZFVwO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMC43cztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC43cztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZTtcXHJcXG5cXHJcXG5cXHR2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgZXhwYW5kVXAge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMTAwJSkgc2NhbGUoMC42KSBzY2FsZVkoMC41KTtcXHJcXG5cXHR9XFxyXFxuXFx0NjAle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNyUpIHNjYWxlWSgxLjEyKTtcXHJcXG5cXHR9XFxyXFxuXFx0NzUle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgzJSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGUoMSkgc2NhbGVZKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIGV4cGFuZFVwIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMTAwJSkgc2NhbGUoMC42KSBzY2FsZVkoMC41KTtcXHJcXG5cXHR9XFxyXFxuXFx0NjAle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC03JSkgc2NhbGVZKDEuMTIpO1xcclxcblxcdH1cXHJcXG5cXHQ3NSV7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMyUpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGUoMSkgc2NhbGVZKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuZmFkZUluXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuLmZhZGVJbntcXHJcXG5cXHRhbmltYXRpb24tbmFtZTogZmFkZUluO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGZhZGVJbjtcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDEuNXM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDEuNXM7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbi1vdXQ7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluLW91dDtcXHJcXG5cXHJcXG5cXHR2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgZmFkZUluIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZSgwKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAwLjA7XFxyXFxuXFx0fVxcclxcblxcdDYwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGUoMC45KTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcblxcdFxcdG9wYWNpdHk6IDE7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG5ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZUluIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcblxcdFxcdG9wYWNpdHk6IDAuMDtcXHJcXG5cXHR9XFxyXFxuXFx0NjAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMS4xKTtcXHJcXG5cXHR9XFxyXFxuXFx0ODAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC45KTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbmV4cGFuZE9wZW5cXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG5cXHJcXG4uZXhwYW5kT3BlbntcXHJcXG5cXHRhbmltYXRpb24tbmFtZTogZXhwYW5kT3BlbjtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBleHBhbmRPcGVuO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMS4ycztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMS4ycztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2Utb3V0O1xcclxcblxcclxcblxcdHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBleHBhbmRPcGVuIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZSgxLjgpO1xcclxcblxcdH1cXHJcXG5cXHQ1MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGUoMC45NSk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZSgxLjA1KTtcXHJcXG5cXHR9XFxyXFxuXFx0OTAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlKDAuOTgpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIGV4cGFuZE9wZW4ge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMS44KTtcXHJcXG5cXHR9XFxyXFxuXFx0NTAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC45NSk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEuMDUpO1xcclxcblxcdH1cXHJcXG5cXHQ5MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjk4KTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuYmlnRW50cmFuY2VcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG5cXHJcXG4uYmlnRW50cmFuY2V7XFxyXFxuXFx0YW5pbWF0aW9uLW5hbWU6IGJpZ0VudHJhbmNlO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGJpZ0VudHJhbmNlO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMS42cztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMS42cztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2Utb3V0O1xcclxcblxcclxcblxcdHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBiaWdFbnRyYW5jZSB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGUoMC4zKSByb3RhdGUoNmRlZykgdHJhbnNsYXRlWCgtMzAlKSB0cmFuc2xhdGVZKDMwJSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMC4yO1xcclxcblxcdH1cXHJcXG5cXHQzMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGUoMS4wMykgcm90YXRlKC0yZGVnKSB0cmFuc2xhdGVYKDIlKSB0cmFuc2xhdGVZKC0yJSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMTtcXHJcXG5cXHR9XFxyXFxuXFx0NDUlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlKDAuOTgpIHJvdGF0ZSgxZGVnKSB0cmFuc2xhdGVYKDAlKSB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG5cXHQ2MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGUoMS4wMSkgcm90YXRlKC0xZGVnKSB0cmFuc2xhdGVYKDAlKSB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG5cXHQ3NSUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGUoMC45OSkgcm90YXRlKDFkZWcpIHRyYW5zbGF0ZVgoMCUpIHRyYW5zbGF0ZVkoMCUpO1xcclxcblxcdFxcdG9wYWNpdHk6IDE7XFxyXFxuXFx0fVxcclxcblxcdDkwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZSgxLjAxKSByb3RhdGUoMGRlZykgdHJhbnNsYXRlWCgwJSkgdHJhbnNsYXRlWSgwJSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZSgxKSByb3RhdGUoMGRlZykgdHJhbnNsYXRlWCgwJSkgdHJhbnNsYXRlWSgwJSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBiaWdFbnRyYW5jZSB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjMpIHJvdGF0ZSg2ZGVnKSB0cmFuc2xhdGVYKC0zMCUpIHRyYW5zbGF0ZVkoMzAlKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAwLjI7XFxyXFxuXFx0fVxcclxcblxcdDMwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEuMDMpIHJvdGF0ZSgtMmRlZykgdHJhbnNsYXRlWCgyJSkgdHJhbnNsYXRlWSgtMiUpO1xcclxcblxcdFxcdG9wYWNpdHk6IDE7XFxyXFxuXFx0fVxcclxcblxcdDQ1JSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuOTgpIHJvdGF0ZSgxZGVnKSB0cmFuc2xhdGVYKDAlKSB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG5cXHQ2MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLjAxKSByb3RhdGUoLTFkZWcpIHRyYW5zbGF0ZVgoMCUpIHRyYW5zbGF0ZVkoMCUpO1xcclxcblxcdFxcdG9wYWNpdHk6IDE7XFxyXFxuXFx0fVxcclxcblxcdDc1JSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuOTkpIHJvdGF0ZSgxZGVnKSB0cmFuc2xhdGVYKDAlKSB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG5cXHQ5MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLjAxKSByb3RhdGUoMGRlZykgdHJhbnNsYXRlWCgwJSkgdHJhbnNsYXRlWSgwJSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpIHJvdGF0ZSgwZGVnKSB0cmFuc2xhdGVYKDAlKSB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuaGF0Y2hcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG4uaGF0Y2h7XFxyXFxuXFx0YW5pbWF0aW9uLW5hbWU6IGhhdGNoO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGhhdGNoO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMnM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDJzO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2UtaW4tb3V0O1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbi1vdXQ7XFxyXFxuXFxyXFxuXFx0dHJhbnNmb3JtLW9yaWdpbjogNTAlIDEwMCU7XFxyXFxuXFx0LW1zLXRyYW5zZm9ybS1vcmlnaW46IDUwJSAxMDAlO1xcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogNTAlIDEwMCU7XFxyXFxuXFxyXFxuXFx0dmlzaWJpbGl0eTogdmlzaWJsZSAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIGhhdGNoIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZykgc2NhbGVZKDAuNik7XFxyXFxuXFx0fVxcclxcblxcdDIwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiByb3RhdGUoLTJkZWcpIHNjYWxlWSgxLjA1KTtcXHJcXG5cXHR9XFxyXFxuXFx0MzUlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHJvdGF0ZSgyZGVnKSBzY2FsZVkoMSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiByb3RhdGUoLTJkZWcpO1xcclxcblxcdH1cXHJcXG5cXHQ2NSUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogcm90YXRlKDFkZWcpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogcm90YXRlKC0xZGVnKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG5ALXdlYmtpdC1rZXlmcmFtZXMgaGF0Y2gge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpIHNjYWxlWSgwLjYpO1xcclxcblxcdH1cXHJcXG5cXHQyMCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoLTJkZWcpIHNjYWxlWSgxLjA1KTtcXHJcXG5cXHR9XFxyXFxuXFx0MzUlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDJkZWcpIHNjYWxlWSgxKTtcXHJcXG5cXHR9XFxyXFxuXFx0NTAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKC0yZGVnKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjUlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDFkZWcpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoLTFkZWcpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuYm91bmNlXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuXFxyXFxuLmJvdW5jZXtcXHJcXG5cXHRhbmltYXRpb24tbmFtZTogYm91bmNlO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGJvdW5jZTtcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDEuNnM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDEuNnM7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZTtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2U7XFxyXFxuXFxyXFxuXFx0dHJhbnNmb3JtLW9yaWdpbjogNTAlIDEwMCU7XFxyXFxuXFx0LW1zLXRyYW5zZm9ybS1vcmlnaW46IDUwJSAxMDAlO1xcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogNTAlIDEwMCU7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgYm91bmNlIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKSBzY2FsZVkoMC42KTtcXHJcXG5cXHR9XFxyXFxuXFx0NjAle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTAwJSkgc2NhbGVZKDEuMSk7XFxyXFxuXFx0fVxcclxcblxcdDcwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWSgwLjk1KSBzY2FsZVgoMS4wNSk7XFxyXFxuXFx0fVxcclxcblxcdDgwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWSgxLjA1KSBzY2FsZVgoMSk7XFxyXFxuXFx0fVxcclxcblxcdDkwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWSgwLjk1KSBzY2FsZVgoMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKSBzY2FsZVkoMSkgc2NhbGVYKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIGJvdW5jZSB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKSBzY2FsZVkoMC42KTtcXHJcXG5cXHR9XFxyXFxuXFx0NjAle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDAlKSBzY2FsZVkoMS4xKTtcXHJcXG5cXHR9XFxyXFxuXFx0NzAle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKSBzY2FsZVkoMC45NSkgc2NhbGVYKDEuMDUpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCV7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWSgxLjA1KSBzY2FsZVgoMSk7XFxyXFxuXFx0fVxcclxcblxcdDkwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVZKDAuOTUpIHNjYWxlWCgxKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVZKDEpIHNjYWxlWCgxKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcblxcclxcbi8qXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbnB1bHNlXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuLnB1bHNle1xcclxcblxcdGFuaW1hdGlvbi1uYW1lOiBwdWxzZTtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBwdWxzZTtcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDEuNXM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDEuNXM7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBwdWxzZSB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGUoMC45KTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAwLjc7XFxyXFxuXFx0fVxcclxcblxcdDUwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZSgxKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlKDAuOSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMC43O1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIHB1bHNlIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuOTUpO1xcclxcblxcdFxcdG9wYWNpdHk6IDAuNztcXHJcXG5cXHR9XFxyXFxuXFx0NTAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuOTUpO1xcclxcblxcdFxcdG9wYWNpdHk6IDAuNztcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbmZsb2F0aW5nXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuLmZsb2F0aW5ne1xcclxcblxcdGFuaW1hdGlvbi1uYW1lOiBmbG9hdGluZztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmbG9hdGluZztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDEuNXM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDEuNXM7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBmbG9hdGluZyB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDglKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBmbG9hdGluZyB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHR9XFxyXFxuXFx0NTAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSg4JSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbnRvc3NpbmdcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG4udG9zc2luZ3tcXHJcXG5cXHRhbmltYXRpb24tbmFtZTogdG9zc2luZztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiB0b3NzaW5nO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMi41cztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMi41cztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIHRvc3Npbmcge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHJvdGF0ZSgtNGRlZyk7XFxyXFxuXFx0fVxcclxcblxcdDUwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiByb3RhdGUoNGRlZyk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogcm90YXRlKC00ZGVnKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyB0b3NzaW5nIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgtNGRlZyk7XFxyXFxuXFx0fVxcclxcblxcdDUwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0ZGVnKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgtNGRlZyk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG5wdWxsVXBcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG4ucHVsbFVwe1xcclxcblxcdGFuaW1hdGlvbi1uYW1lOiBwdWxsVXA7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tbmFtZTogcHVsbFVwO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMS4xcztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMS4xcztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2Utb3V0O1xcclxcblxcclxcblxcdHRyYW5zZm9ybS1vcmlnaW46IDUwJSAxMDAlO1xcclxcblxcdC1tcy10cmFuc2Zvcm0tb3JpZ2luOiA1MCUgMTAwJTtcXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDUwJSAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIHB1bGxVcCB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVZKDAuMSk7XFxyXFxuXFx0fVxcclxcblxcdDQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVkoMS4wMik7XFxyXFxuXFx0fVxcclxcblxcdDYwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVkoMC45OCk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVkoMS4wMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVZKDAuOTgpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVZKDEuMDEpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlWSgxKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBwdWxsVXAge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDAuMSk7XFxyXFxuXFx0fVxcclxcblxcdDQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxLjAyKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDAuOTgpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMS4wMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMC45OCk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxLjAxKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbnB1bGxEb3duXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuLnB1bGxEb3due1xcclxcblxcdGFuaW1hdGlvbi1uYW1lOiBwdWxsRG93bjtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBwdWxsRG93bjtcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDEuMXM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDEuMXM7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1vdXQ7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcXHJcXG5cXHJcXG5cXHR0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgMCU7XFxyXFxuXFx0LW1zLXRyYW5zZm9ybS1vcmlnaW46IDUwJSAwJTtcXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDUwJSAwJTtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBwdWxsRG93biB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVZKDAuMSk7XFxyXFxuXFx0fVxcclxcblxcdDQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVkoMS4wMik7XFxyXFxuXFx0fVxcclxcblxcdDYwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVkoMC45OCk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVkoMS4wMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVZKDAuOTgpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVZKDEuMDEpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlWSgxKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBwdWxsRG93biB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMC4xKTtcXHJcXG5cXHR9XFxyXFxuXFx0NDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDEuMDIpO1xcclxcblxcdH1cXHJcXG5cXHQ2MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMC45OCk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxLjAxKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgwLjk4KTtcXHJcXG5cXHR9XFxyXFxuXFx0ODAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDEuMDEpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuc3RyZXRjaExlZnRcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG4uc3RyZXRjaExlZnR7XFxyXFxuXFx0YW5pbWF0aW9uLW5hbWU6IHN0cmV0Y2hMZWZ0O1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IHN0cmV0Y2hMZWZ0O1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMS41cztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMS41cztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2Utb3V0O1xcclxcblxcclxcblxcdHRyYW5zZm9ybS1vcmlnaW46IDEwMCUgMCU7XFxyXFxuXFx0LW1zLXRyYW5zZm9ybS1vcmlnaW46IDEwMCUgMCU7XFxyXFxuXFx0LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiAxMDAlIDAlO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIHN0cmV0Y2hMZWZ0IHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVgoMC4zKTtcXHJcXG5cXHR9XFxyXFxuXFx0NDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlWCgxLjAyKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlWCgwLjk4KTtcXHJcXG5cXHR9XFxyXFxuXFx0ODAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlWCgxLjAxKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVgoMC45OCk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVgoMS4wMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVYKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIHN0cmV0Y2hMZWZ0IHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWCgwLjMpO1xcclxcblxcdH1cXHJcXG5cXHQ0MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVgoMS4wMik7XFxyXFxuXFx0fVxcclxcblxcdDYwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWCgwLjk4KTtcXHJcXG5cXHR9XFxyXFxuXFx0ODAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVYKDEuMDEpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVYKDAuOTgpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVgoMS4wMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVgoMSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG5zdHJldGNoUmlnaHRcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG4uc3RyZXRjaFJpZ2h0e1xcclxcblxcdGFuaW1hdGlvbi1uYW1lOiBzdHJldGNoUmlnaHQ7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tbmFtZTogc3RyZXRjaFJpZ2h0O1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMS41cztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMS41cztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2Utb3V0O1xcclxcblxcclxcblxcdHRyYW5zZm9ybS1vcmlnaW46IDAlIDAlO1xcclxcblxcdC1tcy10cmFuc2Zvcm0tb3JpZ2luOiAwJSAwJTtcXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDAlIDAlO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIHN0cmV0Y2hSaWdodCB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVYKDAuMyk7XFxyXFxuXFx0fVxcclxcblxcdDQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVgoMS4wMik7XFxyXFxuXFx0fVxcclxcblxcdDYwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVgoMC45OCk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVgoMS4wMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVYKDAuOTgpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVYKDEuMDEpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlWCgxKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBzdHJldGNoUmlnaHQge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVYKDAuMyk7XFxyXFxuXFx0fVxcclxcblxcdDQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWCgxLjAyKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVYKDAuOTgpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVgoMS4wMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVgoMC45OCk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWCgxLjAxKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWCgxKTtcXHJcXG5cXHR9XFxyXFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9jc3MtbG9hZGVyLzAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5lZGl0b3ItbGVmdCB7XFxyXFxuICBvdmVyZmxvdzogc2Nyb2xsO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZmxvdzogY29sdW1uO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcclxcbiAgYWxpZ24tY29udGVudDogY2VudGVyO1xcclxcbiAgaGVpZ2h0OiA4NXZoO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBwYWRkaW5nOiAycHg7XFxyXFxufVxcclxcblxcclxcbi5lZGl0b3ItbGVmdC5jYXJkID4gLmNhcmQtZm9vdGVyID4gLmNhcmQtYnRuIHtcXHJcXG4gIHdpZHRoOiA0OCU7XFxyXFxufVxcclxcblxcclxcbi5lZGl0b3ItcmlnaHQge1xcclxcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxyXFxuICBib3JkZXI6IDFweCBkYXNoZWQgZ3JlZW47XFxyXFxuICB3aWR0aDogOTAlO1xcclxcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcclxcbiAgaGVpZ2h0OiA4NXZoO1xcclxcbiAgcGFkZGluZzogMTBweDtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWZsb3c6IGNvbHVtbjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXHJcXG59XFxyXFxuXFxyXFxuLmVkaXRvci1pbnB1dCB7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uZWRpdG9yLXRleHQge1xcclxcbiAgaGVpZ2h0OiA1MDBweDtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDEwcHg7XFxyXFxufVxcclxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9jc3MtbG9hZGVyLzAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBpbXBvcnQgdXJsKGh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1SdWJpayk7XCIsIFwiXCJdKTtcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBpbXBvcnQgdXJsKGh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1JbmNvbnNvbGF0YSk7XCIsIFwiXCJdKTtcbmV4cG9ydHMuaShyZXF1aXJlKFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9jc3MtbG9hZGVyLzAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9hbmltYXRpb25zLmNzc1wiKSwgXCJcIik7XG5leHBvcnRzLmkocmVxdWlyZShcIi0hLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc2xpZGVzaG93LmNzc1wiKSwgXCJcIik7XG5leHBvcnRzLmkocmVxdWlyZShcIi0hLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vZWRpdG9yLmNzc1wiKSwgXCJcIik7XG5leHBvcnRzLmkocmVxdWlyZShcIi0hLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbW9kYWwuY3NzXCIpLCBcIlwiKTtcbmV4cG9ydHMuaShyZXF1aXJlKFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9jc3MtbG9hZGVyLzAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9wcmV2aWV3LmNzc1wiKSwgXCJcIik7XG5leHBvcnRzLmkocmVxdWlyZShcIi0hLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc2xpZGVzLmNzc1wiKSwgXCJcIik7XG5leHBvcnRzLmkocmVxdWlyZShcIi0hLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJlc2VudGF0aW9ucy5jc3NcIiksIFwiXCIpO1xuZXhwb3J0cy5pKHJlcXVpcmUoXCItIS4uLy4uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL2Nzcy1sb2FkZXIvMC4yOC4xMS9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3Rvb2xiYXIuY3NzXCIpLCBcIlwiKTtcblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiBpbmRleC5jc3MgKi9cXHJcXG5cXHJcXG5cXHJcXG4qIHtcXHJcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxufVxcclxcblxcclxcblxcclxcbmJvZHksXFxyXFxuaHRtbCB7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICBmb250LWZhbWlseTogXFxcIlJ1YmlrXFxcIiwgXFxcIkluY29uc29sYXRhXFxcIiwgc2Fucy1zZXJpZjtcXHJcXG59XFxyXFxuXFxyXFxuLm1haW4ge1xcclxcbiAgZGlzcGxheTogZ3JpZDtcXHJcXG4gIGdyaWQtdGVtcGxhdGUtYXJlYXM6IFxcXCJ0b29sYmFyXFxcIiBcXFwiYm9keVxcXCI7XFxyXFxufVxcclxcblxcclxcbi5jb250YWluZXIge1xcclxcblxcclxcbiAgcGFkZGluZzogNHB4O1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZmxvdzogY29sdW1uO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcclxcbiAgYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcXHJcXG59XFxyXFxuXFxyXFxuLmNhcmQge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZmxvdzogY29sdW1uO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzdHJldGNoO1xcclxcbiAgbWluLXdpZHRoOiAyMDBweDtcXHJcXG4gIG1heC13aWR0aDogMzAwcHg7XFxyXFxuICBoZWlnaHQ6IGZpdC1jb250ZW50O1xcclxcbiAgbWFyZ2luOiAxMHB4O1xcclxcbiAgYm9yZGVyLXJhZGl1czogMiU7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQ0LCA2MiwgODAsIDEpO1xcclxcbiAgYm94LXNoYWRvdzogMXB4IDFweCAycHggMXB4ICM5NWE1YTY7XFxyXFxuICBjb2xvcjogcmdiYSgyMzYsMjQwLDI0MSAsMSk7XFxyXFxufVxcclxcblxcclxcbi5jYXJkLWhlYWRlciB7XFxyXFxuICBtYXgtaGVpZ2h0OiAxMDBweDtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgcGFkZGluZzogNHB4O1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0NCwgNjIsIDgwLCAxKTtcXHJcXG4gIGJvcmRlci1ib3R0b206IDFweCAjMzQ0OTVlO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcclxcbiAgYWxpZ24tY29udGVudDogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZC1ib2R5IHtcXHJcXG4gIG1heC1oZWlnaHQ6IDIwMHB4O1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBwYWRkaW5nOiAycHg7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQ0LCA2MiwgODAsIDEpO1xcclxcbiAgYm9yZGVyLWJvdHRvbTogMXB4ICMzNDQ5NWU7XFxyXFxufVxcclxcblxcclxcbi5jYXJkOmhvdmVyIC5jYXJkLWRlbGV0ZSB7XFxyXFxuICBvcGFjaXR5OiAxO1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZC1mb290ZXIge1xcclxcbiAgbWF4LWhlaWdodDogMTAwcHg7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIHBhZGRpbmc6IDJweDtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDQsIDYyLCA4MCwgMSk7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1mbG93OiB3cmFwO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcclxcbiAgYWxpZ24tY29udGVudDogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZC1kZWxldGUge1xcclxcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcclxcbiAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgdG9wOiAtNXB4O1xcclxcbiAgcmlnaHQ6IC01cHg7XFxyXFxuICB3aWR0aDogMjBweDtcXHJcXG4gIGhlaWdodDogMjBweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXHJcXG4gIG9wYWNpdHk6IDA7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5jYXJkLWRlbGV0ZTpiZWZvcmUge1xcclxcbiAgZm9udC1zaXplOiAxMHB4O1xcclxcbiAgY29udGVudDogXFxcIlhcXFwiO1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZC1kZWxldGU6aG92ZXIge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogI2U3NGMzYztcXHJcXG4gIGNvbG9yOiByZ2JhKDQ0LCA2MiwgODAsIDEpO1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZC1idG4ge1xcclxcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcclxcbiAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcclxcbiAgaGVpZ2h0OiA0MHB4O1xcclxcbiAgbWFyZ2luOiAycHg7XFxyXFxuICBwYWRkaW5nOiAxMHB4O1xcclxcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgZm9udC1zaXplOiAxOHB4O1xcclxcbiAgdHJhbnNpdGlvbjogYWxsIDAuMnM7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1mbG93OiB3cmFwO1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZC1idG46aG92ZXIge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxODksMTk1LDE5OSwxKTtcXHJcXG4gICBjb2xvcjogcmdiYSg0NCwgNjIsIDgwLCAxKTtcXHJcXG59XFxyXFxuXFxyXFxuLmxhbmctanMge1xcclxcbiAgZGlzcGxheTogYmxvY2s7XFxyXFxuICBwYWRkaW5nOiAyMHB4O1xcclxcbiAgZm9udC1zaXplOiAxN3B4O1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuMmVtO1xcclxcbiAgYmFja2dyb3VuZDogcmdiYSg0NCwgNjIsIDgwLCAxKTtcXHJcXG4gIGNvbG9yOiByZ2JhKDM5LCAxNzQsIDk2LCAxKTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDZweDtcXHJcXG4gIGZvbnQtZmFtaWx5OiBJbmNvbnNvbGF0YTtcXHJcXG59XFxyXFxuXFxyXFxuLmxhbmctaHRtbCB7XFxyXFxuICBmb250LWZhbWlseTogY29kZTtcXHJcXG4gIGJhY2tncm91bmQ6IHJnYmEoNDQsIDYyLCA4MCwgMSk7XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTgwZGVnLCAjY2NjIDAsICNjY2MgMS4yZW0sICNlZWUgMCk7XFxyXFxuICBjb2xvcjogcmdiYSg0MSwgMTI4LCAxODUsIDEpO1xcclxcbn1cXHJcXG5cXHJcXG4uZnVsbC13aWR0aCB7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA2MDBweCkge1xcclxcbiAgLmNvbnRhaW5lciB7XFxyXFxuICAgIGZsZXgtZmxvdzogcm93O1xcclxcbiAgfVxcclxcbn1cXHJcXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubW9kYWwtY29udGFpbmVyIHtcXHJcXG4gIHBvc2l0aW9uOmFic29sdXRlO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IDEwMCU7XFxyXFxuICBiYWNrZ3JvdW5kOiByZ2JhKDQ0LCA2MiwgODAsLjkpO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZmxvdzogY29sdW1uO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICB6LWluZGV4OiAxMDtcXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxuLm1vZGFsLWNvbnRhaW5lciA+IC5jYXJkIHtcXHJcXG4gIG1hcmdpbjogMCBhdXRvO1xcclxcbn1cXHJcXG5cXHJcXG4ubW9kYWwtY29udGVudCB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1mbG93OiBjb2x1bW47XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIHdpZHRoOiA4MCU7XFxyXFxufVxcclxcblxcclxcbi5tb2RhbC1sYWJlbCB7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbi5tb2RhbC1pbnB1dCB7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbi5tb2RhbC1jbG9zZSB7XFxyXFxuICB3aWR0aDogMjAwcHg7XFxyXFxuICBoZWlnaHQ6IDQwcHg7XFxyXFxuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsLWNsb3NlOmJlZm9yZSB7XFxyXFxuICBjb250ZW50OiAnQ2FuY2VsJ1xcclxcbn1cXHJcXG5cXHJcXG4ubW9kYWwtc2F2ZUJ0biB7XFxyXFxuXFxyXFxufVxcclxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9jc3MtbG9hZGVyLzAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcclxcbkBrZXlmcmFtZXMgZmFkZUluIHtcXHJcXG4gIDAlIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIDEwMCUge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIGZhZGVPdXQge1xcclxcbiAgMCUge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcblxcclxcbiAgMTAwJSB7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcblxcclxcbi5wcmVzZW50YXRpb25zIHtcXHJcXG4gIGFuaW1hdGlvbjogZmFkZUluIC41cyBlYXNlLWluLW91dDtcXHJcXG59XFxyXFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL2Nzcy1sb2FkZXIvMC4yOC4xMS9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnByZXZpZXcge1xcclxcbiAgd2lkdGg6IDIwMHB4O1xcclxcbiAgaGVpZ2h0OiAyMDBweDtcXHJcXG4gIG1hcmdpbjogMTJweDtcXHJcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxyXFxufVxcclxcblxcclxcbi5jYXJkLnByZXZpZXcge1xcclxcbiAgY3Vyc29yOiBncmFiO1xcclxcbn1cXHJcXG5cXHJcXG4ucHJldmlldyA+IC5jYXJkLWhlYWRlciB7XFxyXFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG59XFxyXFxuXFxyXFxuLnByZXZpZXcgPiAuY2FyZC1ib2R5IHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG5cXHJcXG4ucHJldmlldyA+IC5jYXJkLWJvZHkgPiAqIHtcXHJcXG4gIG9wYWNpdHk6IDAuMTtcXHJcXG59XFxyXFxuXFxyXFxuLnByZXZpZXctZGVsZXRlIHtcXHJcXG4gIHRvcDogNHB4O1xcclxcbiAgcmlnaHQ6IDRweDtcXHJcXG4gIHotaW5kZXg6IDM7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5wcmV2aWV3LWRlbGV0ZTpiZWZvcmUge1xcclxcbiAgcGFkZGluZy1sZWZ0OiA0cHg7XFxyXFxufVxcclxcblxcclxcbi5zbGlkZVBvc2l0aW9uIHtcXHJcXG4gIGNvbG9yOiAjZTY3ZTIyO1xcclxcbiAgZm9udC1zaXplOiA2cmVtO1xcclxcbn1cXHJcXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuc2xpZGVzIHtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtZXZlbmx5O1xcclxcbiAgYW5pbWF0aW9uOiBmYWRlSW4gMC41cyBlYXNlLWluLW91dDtcXHJcXG59XFxyXFxuXFxyXFxuLmxlZnQtZHJhZyB7XFxyXFxuICBncmlkLWFyZWE6IGxlZnQtZHJhZztcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWZsb3c6IGNvbHVtbjtcXHJcXG4gIG9yZGVyOiAxO1xcclxcbiAgYm9yZGVyOiAxcHggZGFzaGVkIHJnYmEoNDQsIDYyLCA4MCwgMC4zKTtcXHJcXG4gIGhlaWdodDogODh2aDtcXHJcXG59XFxyXFxuXFxyXFxuLmxlZnQtZHJhZyAuY2FyZDpob3ZlciB7XFxyXFxuICBjdXJzb3I6IGdyYWI7XFxyXFxufVxcclxcblxcclxcbi5yaWdodC1kcmFnIHtcXHJcXG4gIG9yZGVyOiAyO1xcclxcbiAgZ3JpZC1hcmVhOiByaWdodC1kcmFnO1xcclxcbiAgZmxleC1mbG93OiB3cmFwO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIG1pbi13aWR0aDogMTAwJTtcXHJcXG4gIGJvcmRlcjogMXB4IGRhc2hlZCByZ2JhKDQ0LCA2MiwgODAsIDAuMyk7XFxyXFxufVxcclxcblxcclxcbi5pc0RyYWdnaW5nIHtcXHJcXG4gIGJhY2tncm91bmQ6IHJnYmEoNDQsIDYyLCA4MCwgMC4zKTtcXHJcXG4gIGJveC1zaGFkb3c6IGluc2V0IDAgMCAxcHggcmdiYSg0NCwgNjIsIDgwLCAxKTtcXHJcXG59XFxyXFxuXFxyXFxuLmRyb3Age1xcclxcbiAgY3Vyc29yOiBkcm9wO1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDYwMHB4KSB7XFxyXFxuICAuc2xpZGVzIHtcXHJcXG4gICAgZGlzcGxheTogaW5saW5lLWdyaWQ7XFxyXFxuICAgIGdyaWQtdGVtcGxhdGUtYXJlYXM6IFxcXCJsZWZ0LWRyYWcgcmlnaHQtZHJhZ1xcXCI7XFxyXFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDJmcjtcXHJcXG4gICAgbWF4LWhlaWdodDogOTB2aDtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL2Nzcy1sb2FkZXIvMC4yOC4xMS9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnNsaWRlc2hvdyB7XFxyXFxuICBoZWlnaHQ6IDkwdmg7XFxyXFxuICB3aWR0aDogOTAlO1xcclxcbiAgbWFyZ2luOiAwIGF1dG87XFxyXFxuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXHJcXG4gIG91dGxpbmU6IDA7XFxyXFxufVxcclxcblxcclxcbi5zbGlkZWNhcmQge1xcclxcbiAgYW5pbWF0aW9uOiBzdHJldGNoUmlnaHQgMXMgZWFzZS1pbi1vdXQgYm90aDtcXHJcXG4gIG91dGxpbmU6IDA7XFxyXFxufVxcclxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9jc3MtbG9hZGVyLzAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi50b29sYmFyIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWZsb3c6IGNvbHVtbjtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAyO1xcclxcbiAgYmFja2dyb3VuZDogI2VjZjBmMTtcXHJcXG4gIHBhZGRpbmc6IDJweDtcXHJcXG59XFxyXFxuXFxyXFxuLnRvb2xiYXItbGVmdCB7XFxyXFxuICBvcmRlcjogMTtcXHJcXG4gIGdyaWQtYXJlYTogdG9vbGJhci1sZWZ0O1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZmxvdzogd3JhcDtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxuLnRvb2xiYXItcmlnaHQge1xcclxcbiAgb3JkZXI6IDI7XFxyXFxuICBncmlkLWFyZWE6IHRvb2xiYXItcmlnaHQ7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1mbG93OiB3cmFwO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcclxcbn1cXHJcXG5cXHJcXG4udG9vbGJhci1pdGVtIHtcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG4gIGNvbG9yOiByZ2JhKDQ0LCA2MiwgODAsMSk7XFxyXFxuICBtYXJnaW46IDJweDtcXHJcXG4gIHBhZGRpbmc6IDEwcHg7XFxyXFxuICBib3JkZXItcmFkaXVzOjJweDtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gIHRyYW5zaXRpb246IGFsbCAuNXM7XFxyXFxufVxcclxcblxcclxcbi50b29sYmFyLWl0ZW06aG92ZXIge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0NCwgNjIsIDgwLDEpO1xcclxcbiAgY29sb3I6IHJnYmEoMjM2LCAyNDAsIDI0MSwxLjApO1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDYwMHB4KSB7XFxyXFxuICAudG9vbGJhciB7XFxyXFxuICAgIGRpc3BsYXk6IGlubGluZS1ncmlkO1xcclxcbiAgICBncmlkLXRlbXBsYXRlLWFyZWFzOiBcXFwidG9vbGJhci1sZWZ0IHRvb2xiYXItcmlnaHRcXFwiO1xcclxcbiAgICBsaW5lLWhlaWdodDogMjtcXHJcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyMzYsIDI0MCwgMjQxLDEuMCk7XFxyXFxuICAgIHBhZGRpbmc6IDJweDtcXHJcXG4gIH1cXHJcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3Rhc2snKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG4vKipcbiAqIEEgaGVscGVyIGZvciBkZWxheWluZyB0aGUgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHN1bW1hcnkgKEFueS4uLiAtPiBBbnkpIC0+IFZvaWRcbiAqL1xudmFyIGRlbGF5ZWQgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJz8gIHNldEltbWVkaWF0ZVxuICAgICAgICAgICAgOiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCc/ICAgICAgIHByb2Nlc3MubmV4dFRpY2tcbiAgICAgICAgICAgIDogLyogb3RoZXJ3aXNlICovICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0XG5cbi8qKlxuICogQG1vZHVsZSBsaWIvdGFza1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IFRhc2s7XG5cbi8vIC0tIEltcGxlbWVudGF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFRoZSBgVGFza1vOsSwgzrJdYCBzdHJ1Y3R1cmUgcmVwcmVzZW50cyB2YWx1ZXMgdGhhdCBkZXBlbmQgb24gdGltZS4gVGhpc1xuICogYWxsb3dzIG9uZSB0byBtb2RlbCB0aW1lLWJhc2VkIGVmZmVjdHMgZXhwbGljaXRseSwgc3VjaCB0aGF0IG9uZSBjYW4gaGF2ZVxuICogZnVsbCBrbm93bGVkZ2Ugb2Ygd2hlbiB0aGV5J3JlIGRlYWxpbmcgd2l0aCBkZWxheWVkIGNvbXB1dGF0aW9ucywgbGF0ZW5jeSxcbiAqIG9yIGFueXRoaW5nIHRoYXQgY2FuIG5vdCBiZSBjb21wdXRlZCBpbW1lZGlhdGVseS5cbiAqXG4gKiBBIGNvbW1vbiB1c2UgZm9yIHRoaXMgc3RydWN0dXJlIGlzIHRvIHJlcGxhY2UgdGhlIHVzdWFsIENvbnRpbnVhdGlvbi1QYXNzaW5nXG4gKiBTdHlsZSBmb3JtIG9mIHByb2dyYW1taW5nLCBpbiBvcmRlciB0byBiZSBhYmxlIHRvIGNvbXBvc2UgYW5kIHNlcXVlbmNlXG4gKiB0aW1lLWRlcGVuZGVudCBlZmZlY3RzIHVzaW5nIHRoZSBnZW5lcmljIGFuZCBwb3dlcmZ1bCBtb25hZGljIG9wZXJhdGlvbnMuXG4gKlxuICogQGNsYXNzXG4gKiBAc3VtbWFyeVxuICogKCjOsSDihpIgVm9pZCksICjOsiDihpIgVm9pZCkg4oaSIFZvaWQpLCAoVm9pZCDihpIgVm9pZCkg4oaSIFRhc2tbzrEsIM6yXVxuICpcbiAqIFRhc2tbzrEsIM6yXSA8OiBDaGFpblvOsl1cbiAqICAgICAgICAgICAgICAgLCBNb25hZFvOsl1cbiAqICAgICAgICAgICAgICAgLCBGdW5jdG9yW86yXVxuICogICAgICAgICAgICAgICAsIEFwcGxpY2F0aXZlW86yXVxuICogICAgICAgICAgICAgICAsIFNlbWlncm91cFvOsl1cbiAqICAgICAgICAgICAgICAgLCBNb25vaWRbzrJdXG4gKiAgICAgICAgICAgICAgICwgU2hvd1xuICovXG5mdW5jdGlvbiBUYXNrKGNvbXB1dGF0aW9uLCBjbGVhbnVwKSB7XG4gIHRoaXMuZm9yayA9IGNvbXB1dGF0aW9uO1xuXG4gIHRoaXMuY2xlYW51cCA9IGNsZWFudXAgfHwgZnVuY3Rpb24oKSB7fTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBUYXNrW86xLCDOsl1gIGNvbnRhaW5pbmcgdGhlIHNpbmdsZSB2YWx1ZSBgzrJgLlxuICpcbiAqIGDOsmAgY2FuIGJlIGFueSB2YWx1ZSwgaW5jbHVkaW5nIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yIGFub3RoZXJcbiAqIGBUYXNrW86xLCDOsl1gIHN0cnVjdHVyZS5cbiAqXG4gKiBAc3VtbWFyeSDOsiDihpIgVGFza1vOsSwgzrJdXG4gKi9cblRhc2sucHJvdG90eXBlLm9mID0gZnVuY3Rpb24gX29mKGIpIHtcbiAgcmV0dXJuIG5ldyBUYXNrKGZ1bmN0aW9uKF8sIHJlc29sdmUpIHtcbiAgICByZXR1cm4gcmVzb2x2ZShiKTtcbiAgfSk7XG59O1xuXG5UYXNrLm9mID0gVGFzay5wcm90b3R5cGUub2Y7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgVGFza1vOsSwgzrJdYCBjb250YWluaW5nIHRoZSBzaW5nbGUgdmFsdWUgYM6xYC5cbiAqXG4gKiBgzrFgIGNhbiBiZSBhbnkgdmFsdWUsIGluY2x1ZGluZyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvciBhbm90aGVyXG4gKiBgVGFza1vOsSwgzrJdYCBzdHJ1Y3R1cmUuXG4gKlxuICogQHN1bW1hcnkgzrEg4oaSIFRhc2tbzrEsIM6yXVxuICovXG5UYXNrLnByb3RvdHlwZS5yZWplY3RlZCA9IGZ1bmN0aW9uIF9yZWplY3RlZChhKSB7XG4gIHJldHVybiBuZXcgVGFzayhmdW5jdGlvbihyZWplY3QpIHtcbiAgICByZXR1cm4gcmVqZWN0KGEpO1xuICB9KTtcbn07XG5cblRhc2sucmVqZWN0ZWQgPSBUYXNrLnByb3RvdHlwZS5yZWplY3RlZDtcblxuLy8gLS0gRnVuY3RvciAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgc3VjY2Vzc2Z1bCB2YWx1ZSBvZiB0aGUgYFRhc2tbzrEsIM6yXWAgdXNpbmcgYSByZWd1bGFyIHVuYXJ5XG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBAc3VtbWFyeSBAVGFza1vOsSwgzrJdID0+ICjOsiDihpIgzrMpIOKGkiBUYXNrW86xLCDOs11cbiAqL1xuVGFzay5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gX21hcChmKSB7XG4gIHZhciBmb3JrID0gdGhpcy5mb3JrO1xuICB2YXIgY2xlYW51cCA9IHRoaXMuY2xlYW51cDtcblxuICByZXR1cm4gbmV3IFRhc2soZnVuY3Rpb24ocmVqZWN0LCByZXNvbHZlKSB7XG4gICAgcmV0dXJuIGZvcmsoZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHJlamVjdChhKTtcbiAgICB9LCBmdW5jdGlvbihiKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShmKGIpKTtcbiAgICB9KTtcbiAgfSwgY2xlYW51cCk7XG59O1xuXG4vLyAtLSBDaGFpbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBzdWNjZXNmdWwgdmFsdWUgb2YgdGhlIGBUYXNrW86xLCDOsl1gIHVzaW5nIGEgZnVuY3Rpb24gdG8gYVxuICogbW9uYWQuXG4gKlxuICogQHN1bW1hcnkgQFRhc2tbzrEsIM6yXSA9PiAozrIg4oaSIFRhc2tbzrEsIM6zXSkg4oaSIFRhc2tbzrEsIM6zXVxuICovXG5UYXNrLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uIF9jaGFpbihmKSB7XG4gIHZhciBmb3JrID0gdGhpcy5mb3JrO1xuICB2YXIgY2xlYW51cCA9IHRoaXMuY2xlYW51cDtcblxuICByZXR1cm4gbmV3IFRhc2soZnVuY3Rpb24ocmVqZWN0LCByZXNvbHZlKSB7XG4gICAgcmV0dXJuIGZvcmsoZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHJlamVjdChhKTtcbiAgICB9LCBmdW5jdGlvbihiKSB7XG4gICAgICByZXR1cm4gZihiKS5mb3JrKHJlamVjdCwgcmVzb2x2ZSk7XG4gICAgfSk7XG4gIH0sIGNsZWFudXApO1xufTtcblxuLy8gLS0gQXBwbHkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQXBwbHlzIHRoZSBzdWNjZXNzZnVsIHZhbHVlIG9mIHRoZSBgVGFza1vOsSwgKM6yIOKGkiDOsyldYCB0byB0aGUgc3VjY2Vzc2Z1bFxuICogdmFsdWUgb2YgdGhlIGBUYXNrW86xLCDOsl1gXG4gKlxuICogQHN1bW1hcnkgQFRhc2tbzrEsICjOsiDihpIgzrMpXSA9PiBUYXNrW86xLCDOsl0g4oaSIFRhc2tbzrEsIM6zXVxuICovXG5cblRhc2sucHJvdG90eXBlLmFwID0gZnVuY3Rpb24gX2FwKHRoYXQpIHtcbiAgdmFyIGZvcmtUaGlzID0gdGhpcy5mb3JrO1xuICB2YXIgZm9ya1RoYXQgPSB0aGF0LmZvcms7XG4gIHZhciBjbGVhbnVwVGhpcyA9IHRoaXMuY2xlYW51cDtcbiAgdmFyIGNsZWFudXBUaGF0ID0gdGhhdC5jbGVhbnVwO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXBCb3RoKHN0YXRlKSB7XG4gICAgY2xlYW51cFRoaXMoc3RhdGVbMF0pO1xuICAgIGNsZWFudXBUaGF0KHN0YXRlWzFdKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVGFzayhmdW5jdGlvbihyZWplY3QsIHJlc29sdmUpIHtcbiAgICB2YXIgZnVuYywgZnVuY0xvYWRlZCA9IGZhbHNlO1xuICAgIHZhciB2YWwsIHZhbExvYWRlZCA9IGZhbHNlO1xuICAgIHZhciByZWplY3RlZCA9IGZhbHNlO1xuICAgIHZhciBhbGxTdGF0ZTtcblxuICAgIHZhciB0aGlzU3RhdGUgPSBmb3JrVGhpcyhndWFyZFJlamVjdCwgZ3VhcmRSZXNvbHZlKGZ1bmN0aW9uKHgpIHtcbiAgICAgIGZ1bmNMb2FkZWQgPSB0cnVlO1xuICAgICAgZnVuYyA9IHg7XG4gICAgfSkpO1xuXG4gICAgdmFyIHRoYXRTdGF0ZSA9IGZvcmtUaGF0KGd1YXJkUmVqZWN0LCBndWFyZFJlc29sdmUoZnVuY3Rpb24oeCkge1xuICAgICAgdmFsTG9hZGVkID0gdHJ1ZTtcbiAgICAgIHZhbCA9IHg7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gZ3VhcmRSZXNvbHZlKHNldHRlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGVyKHgpO1xuICAgICAgICBpZiAoZnVuY0xvYWRlZCAmJiB2YWxMb2FkZWQpIHtcbiAgICAgICAgICBkZWxheWVkKGZ1bmN0aW9uKCl7IGNsZWFudXBCb3RoKGFsbFN0YXRlKSB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmdW5jKHZhbCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ3VhcmRSZWplY3QoeCkge1xuICAgICAgaWYgKCFyZWplY3RlZCkge1xuICAgICAgICByZWplY3RlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiByZWplY3QoeCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsbFN0YXRlID0gW3RoaXNTdGF0ZSwgdGhhdFN0YXRlXTtcbiAgfSwgY2xlYW51cEJvdGgpO1xufTtcblxuLy8gLS0gU2VtaWdyb3VwIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFNlbGVjdHMgdGhlIGVhcmxpZXIgb2YgdGhlIHR3byB0YXNrcyBgVGFza1vOsSwgzrJdYFxuICpcbiAqIEBzdW1tYXJ5IEBUYXNrW86xLCDOsl0gPT4gVGFza1vOsSwgzrJdIOKGkiBUYXNrW86xLCDOsl1cbiAqL1xuXG5UYXNrLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBfY29uY2F0KHRoYXQpIHtcbiAgdmFyIGZvcmtUaGlzID0gdGhpcy5mb3JrO1xuICB2YXIgZm9ya1RoYXQgPSB0aGF0LmZvcms7XG4gIHZhciBjbGVhbnVwVGhpcyA9IHRoaXMuY2xlYW51cDtcbiAgdmFyIGNsZWFudXBUaGF0ID0gdGhhdC5jbGVhbnVwO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXBCb3RoKHN0YXRlKSB7XG4gICAgY2xlYW51cFRoaXMoc3RhdGVbMF0pO1xuICAgIGNsZWFudXBUaGF0KHN0YXRlWzFdKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVGFzayhmdW5jdGlvbihyZWplY3QsIHJlc29sdmUpIHtcbiAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgIHZhciBhbGxTdGF0ZTtcbiAgICB2YXIgdGhpc1N0YXRlID0gZm9ya1RoaXMoZ3VhcmQocmVqZWN0KSwgZ3VhcmQocmVzb2x2ZSkpO1xuICAgIHZhciB0aGF0U3RhdGUgPSBmb3JrVGhhdChndWFyZChyZWplY3QpLCBndWFyZChyZXNvbHZlKSk7XG5cbiAgICByZXR1cm4gYWxsU3RhdGUgPSBbdGhpc1N0YXRlLCB0aGF0U3RhdGVdO1xuXG4gICAgZnVuY3Rpb24gZ3VhcmQoZikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgZGVsYXllZChmdW5jdGlvbigpeyBjbGVhbnVwQm90aChhbGxTdGF0ZSkgfSlcbiAgICAgICAgICByZXR1cm4gZih4KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIGNsZWFudXBCb3RoKTtcblxufTtcblxuLy8gLS0gTW9ub2lkIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFJldHVybnMgYSBUYXNrIHRoYXQgd2lsbCBuZXZlciByZXNvbHZlXG4gKlxuICogQHN1bW1hcnkgVm9pZCDihpIgVGFza1vOsSwgX11cbiAqL1xuVGFzay5lbXB0eSA9IGZ1bmN0aW9uIF9lbXB0eSgpIHtcbiAgcmV0dXJuIG5ldyBUYXNrKGZ1bmN0aW9uKCkge30pO1xufTtcblxuVGFzay5wcm90b3R5cGUuZW1wdHkgPSBUYXNrLmVtcHR5O1xuXG4vLyAtLSBTaG93IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYFRhc2tbzrEsIM6yXWBcbiAqXG4gKiBAc3VtbWFyeSBAVGFza1vOsSwgzrJdID0+IFZvaWQg4oaSIFN0cmluZ1xuICovXG5UYXNrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIF90b1N0cmluZygpIHtcbiAgcmV0dXJuICdUYXNrJztcbn07XG5cbi8vIC0tIEV4dHJhY3RpbmcgYW5kIHJlY292ZXJpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBmYWlsdXJlIHZhbHVlIGludG8gYSBuZXcgYFRhc2tbzrEsIM6yXWAuIERvZXMgbm90aGluZyBpZiB0aGVcbiAqIHN0cnVjdHVyZSBhbHJlYWR5IGNvbnRhaW5zIGEgc3VjY2Vzc2Z1bCB2YWx1ZS5cbiAqXG4gKiBAc3VtbWFyeSBAVGFza1vOsSwgzrJdID0+ICjOsSDihpIgVGFza1vOsywgzrJdKSDihpIgVGFza1vOsywgzrJdXG4gKi9cblRhc2sucHJvdG90eXBlLm9yRWxzZSA9IGZ1bmN0aW9uIF9vckVsc2UoZikge1xuICB2YXIgZm9yayA9IHRoaXMuZm9yaztcbiAgdmFyIGNsZWFudXAgPSB0aGlzLmNsZWFudXA7XG5cbiAgcmV0dXJuIG5ldyBUYXNrKGZ1bmN0aW9uKHJlamVjdCwgcmVzb2x2ZSkge1xuICAgIHJldHVybiBmb3JrKGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBmKGEpLmZvcmsocmVqZWN0LCByZXNvbHZlKTtcbiAgICB9LCBmdW5jdGlvbihiKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShiKTtcbiAgICB9KTtcbiAgfSwgY2xlYW51cCk7XG59O1xuXG4vLyAtLSBGb2xkcyBhbmQgZXh0ZW5kZWQgdHJhbnNmb3JtYXRpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBDYXRhbW9ycGhpc20uIFRha2VzIHR3byBmdW5jdGlvbnMsIGFwcGxpZXMgdGhlIGxlZnRtb3N0IG9uZSB0byB0aGUgZmFpbHVyZVxuICogdmFsdWUsIGFuZCB0aGUgcmlnaHRtb3N0IG9uZSB0byB0aGUgc3VjY2Vzc2Z1bCB2YWx1ZSwgZGVwZW5kaW5nIG9uIHdoaWNoIG9uZVxuICogaXMgcHJlc2VudC5cbiAqXG4gKiBAc3VtbWFyeSBAVGFza1vOsSwgzrJdID0+ICjOsSDihpIgzrMpLCAozrIg4oaSIM6zKSDihpIgVGFza1vOtCwgzrNdXG4gKi9cblRhc2sucHJvdG90eXBlLmZvbGQgPSBmdW5jdGlvbiBfZm9sZChmLCBnKSB7XG4gIHZhciBmb3JrID0gdGhpcy5mb3JrO1xuICB2YXIgY2xlYW51cCA9IHRoaXMuY2xlYW51cDtcblxuICByZXR1cm4gbmV3IFRhc2soZnVuY3Rpb24ocmVqZWN0LCByZXNvbHZlKSB7XG4gICAgcmV0dXJuIGZvcmsoZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUoZihhKSk7XG4gICAgfSwgZnVuY3Rpb24oYikge1xuICAgICAgcmV0dXJuIHJlc29sdmUoZyhiKSk7XG4gICAgfSk7XG4gIH0sIGNsZWFudXApO1xufTtcblxuLyoqXG4gKiBDYXRhbW9ycGhpc20uXG4gKlxuICogQHN1bW1hcnkgQFRhc2tbzrEsIM6yXSA9PiB7IFJlamVjdGVkOiDOsSDihpIgzrMsIFJlc29sdmVkOiDOsiDihpIgzrMgfSDihpIgVGFza1vOtCwgzrNdXG4gKi9cblRhc2sucHJvdG90eXBlLmNhdGEgPSBmdW5jdGlvbiBfY2F0YShwYXR0ZXJuKSB7XG4gIHJldHVybiB0aGlzLmZvbGQocGF0dGVybi5SZWplY3RlZCwgcGF0dGVybi5SZXNvbHZlZCk7XG59O1xuXG4vKipcbiAqIFN3YXBzIHRoZSBkaXNqdW5jdGlvbiB2YWx1ZXMuXG4gKlxuICogQHN1bW1hcnkgQFRhc2tbzrEsIM6yXSA9PiBWb2lkIOKGkiBUYXNrW86yLCDOsV1cbiAqL1xuVGFzay5wcm90b3R5cGUuc3dhcCA9IGZ1bmN0aW9uIF9zd2FwKCkge1xuICB2YXIgZm9yayA9IHRoaXMuZm9yaztcbiAgdmFyIGNsZWFudXAgPSB0aGlzLmNsZWFudXA7XG5cbiAgcmV0dXJuIG5ldyBUYXNrKGZ1bmN0aW9uKHJlamVjdCwgcmVzb2x2ZSkge1xuICAgIHJldHVybiBmb3JrKGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKGEpO1xuICAgIH0sIGZ1bmN0aW9uKGIpIHtcbiAgICAgIHJldHVybiByZWplY3QoYik7XG4gICAgfSk7XG4gIH0sIGNsZWFudXApO1xufTtcblxuLyoqXG4gKiBNYXBzIGJvdGggc2lkZXMgb2YgdGhlIGRpc2p1bmN0aW9uLlxuICpcbiAqIEBzdW1tYXJ5IEBUYXNrW86xLCDOsl0gPT4gKM6xIOKGkiDOsyksICjOsiDihpIgzrQpIOKGkiBUYXNrW86zLCDOtF1cbiAqL1xuVGFzay5wcm90b3R5cGUuYmltYXAgPSBmdW5jdGlvbiBfYmltYXAoZiwgZykge1xuICB2YXIgZm9yayA9IHRoaXMuZm9yaztcbiAgdmFyIGNsZWFudXAgPSB0aGlzLmNsZWFudXA7XG5cbiAgcmV0dXJuIG5ldyBUYXNrKGZ1bmN0aW9uKHJlamVjdCwgcmVzb2x2ZSkge1xuICAgIHJldHVybiBmb3JrKGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiByZWplY3QoZihhKSk7XG4gICAgfSwgZnVuY3Rpb24oYikge1xuICAgICAgcmV0dXJuIHJlc29sdmUoZyhiKSk7XG4gICAgfSk7XG4gIH0sIGNsZWFudXApO1xufTtcblxuLyoqXG4gKiBNYXBzIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGRpc2p1bmN0aW9uIChmYWlsdXJlKS5cbiAqXG4gKiBAc3VtbWFyeSBAVGFza1vOsSwgzrJdID0+ICjOsSDihpIgzrMpIOKGkiBUYXNrW86zLCDOsl1cbiAqL1xuVGFzay5wcm90b3R5cGUucmVqZWN0ZWRNYXAgPSBmdW5jdGlvbiBfcmVqZWN0ZWRNYXAoZikge1xuICB2YXIgZm9yayA9IHRoaXMuZm9yaztcbiAgdmFyIGNsZWFudXAgPSB0aGlzLmNsZWFudXA7XG5cbiAgcmV0dXJuIG5ldyBUYXNrKGZ1bmN0aW9uKHJlamVjdCwgcmVzb2x2ZSkge1xuICAgIHJldHVybiBmb3JrKGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiByZWplY3QoZihhKSk7XG4gICAgfSwgZnVuY3Rpb24oYikge1xuICAgICAgcmV0dXJuIHJlc29sdmUoYik7XG4gICAgfSk7XG4gIH0sIGNsZWFudXApO1xufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlICovXHJcbjsoZnVuY3Rpb24oKSB7XHJcblwidXNlIHN0cmljdFwiXHJcbi8qIGVzbGludC1lbmFibGUgKi9cclxuXHJcbnZhciBndWlkID0gMCwgSEFMVCA9IHt9XHJcbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbSgpIHtcclxuXHRmdW5jdGlvbiBzdHJlYW0oKSB7XHJcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSBIQUxUKSB1cGRhdGVTdHJlYW0oc3RyZWFtLCBhcmd1bWVudHNbMF0pXHJcblx0XHRyZXR1cm4gc3RyZWFtLl9zdGF0ZS52YWx1ZVxyXG5cdH1cclxuXHRpbml0U3RyZWFtKHN0cmVhbSlcclxuXHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gSEFMVCkgdXBkYXRlU3RyZWFtKHN0cmVhbSwgYXJndW1lbnRzWzBdKVxyXG5cclxuXHRyZXR1cm4gc3RyZWFtXHJcbn1cclxuZnVuY3Rpb24gaW5pdFN0cmVhbShzdHJlYW0pIHtcclxuXHRzdHJlYW0uY29uc3RydWN0b3IgPSBjcmVhdGVTdHJlYW1cclxuXHRzdHJlYW0uX3N0YXRlID0ge2lkOiBndWlkKyssIHZhbHVlOiB1bmRlZmluZWQsIHN0YXRlOiAwLCBkZXJpdmU6IHVuZGVmaW5lZCwgcmVjb3ZlcjogdW5kZWZpbmVkLCBkZXBzOiB7fSwgcGFyZW50czogW10sIGVuZFN0cmVhbTogdW5kZWZpbmVkLCB1bnJlZ2lzdGVyOiB1bmRlZmluZWR9XHJcblx0c3RyZWFtLm1hcCA9IHN0cmVhbVtcImZhbnRhc3ktbGFuZC9tYXBcIl0gPSBtYXAsIHN0cmVhbVtcImZhbnRhc3ktbGFuZC9hcFwiXSA9IGFwLCBzdHJlYW1bXCJmYW50YXN5LWxhbmQvb2ZcIl0gPSBjcmVhdGVTdHJlYW1cclxuXHRzdHJlYW0udmFsdWVPZiA9IHZhbHVlT2YsIHN0cmVhbS50b0pTT04gPSB0b0pTT04sIHN0cmVhbS50b1N0cmluZyA9IHZhbHVlT2ZcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RyZWFtLCB7XHJcblx0XHRlbmQ6IHtnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpZiAoIXN0cmVhbS5fc3RhdGUuZW5kU3RyZWFtKSB7XHJcblx0XHRcdFx0dmFyIGVuZFN0cmVhbSA9IGNyZWF0ZVN0cmVhbSgpXHJcblx0XHRcdFx0ZW5kU3RyZWFtLm1hcChmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSB0cnVlKSB7XHJcblx0XHRcdFx0XHRcdHVucmVnaXN0ZXJTdHJlYW0oc3RyZWFtKVxyXG5cdFx0XHRcdFx0XHRlbmRTdHJlYW0uX3N0YXRlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbigpe3VucmVnaXN0ZXJTdHJlYW0oZW5kU3RyZWFtKX1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZVxyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0c3RyZWFtLl9zdGF0ZS5lbmRTdHJlYW0gPSBlbmRTdHJlYW1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gc3RyZWFtLl9zdGF0ZS5lbmRTdHJlYW1cclxuXHRcdH19XHJcblx0fSlcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVTdHJlYW0oc3RyZWFtLCB2YWx1ZSkge1xyXG5cdHVwZGF0ZVN0YXRlKHN0cmVhbSwgdmFsdWUpXHJcblx0Zm9yICh2YXIgaWQgaW4gc3RyZWFtLl9zdGF0ZS5kZXBzKSB1cGRhdGVEZXBlbmRlbmN5KHN0cmVhbS5fc3RhdGUuZGVwc1tpZF0sIGZhbHNlKVxyXG5cdGlmIChzdHJlYW0uX3N0YXRlLnVucmVnaXN0ZXIgIT0gbnVsbCkgc3RyZWFtLl9zdGF0ZS51bnJlZ2lzdGVyKClcclxuXHRmaW5hbGl6ZShzdHJlYW0pXHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlU3RhdGUoc3RyZWFtLCB2YWx1ZSkge1xyXG5cdHN0cmVhbS5fc3RhdGUudmFsdWUgPSB2YWx1ZVxyXG5cdHN0cmVhbS5fc3RhdGUuY2hhbmdlZCA9IHRydWVcclxuXHRpZiAoc3RyZWFtLl9zdGF0ZS5zdGF0ZSAhPT0gMikgc3RyZWFtLl9zdGF0ZS5zdGF0ZSA9IDFcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVEZXBlbmRlbmN5KHN0cmVhbSwgbXVzdFN5bmMpIHtcclxuXHR2YXIgc3RhdGUgPSBzdHJlYW0uX3N0YXRlLCBwYXJlbnRzID0gc3RhdGUucGFyZW50c1xyXG5cdGlmIChwYXJlbnRzLmxlbmd0aCA+IDAgJiYgcGFyZW50cy5ldmVyeShhY3RpdmUpICYmIChtdXN0U3luYyB8fCBwYXJlbnRzLnNvbWUoY2hhbmdlZCkpKSB7XHJcblx0XHR2YXIgdmFsdWUgPSBzdHJlYW0uX3N0YXRlLmRlcml2ZSgpXHJcblx0XHRpZiAodmFsdWUgPT09IEhBTFQpIHJldHVybiBmYWxzZVxyXG5cdFx0dXBkYXRlU3RhdGUoc3RyZWFtLCB2YWx1ZSlcclxuXHR9XHJcbn1cclxuZnVuY3Rpb24gZmluYWxpemUoc3RyZWFtKSB7XHJcblx0c3RyZWFtLl9zdGF0ZS5jaGFuZ2VkID0gZmFsc2VcclxuXHRmb3IgKHZhciBpZCBpbiBzdHJlYW0uX3N0YXRlLmRlcHMpIHN0cmVhbS5fc3RhdGUuZGVwc1tpZF0uX3N0YXRlLmNoYW5nZWQgPSBmYWxzZVxyXG59XHJcblxyXG5mdW5jdGlvbiBjb21iaW5lKGZuLCBzdHJlYW1zKSB7XHJcblx0aWYgKCFzdHJlYW1zLmV2ZXJ5KHZhbGlkKSkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoYXQgZWFjaCBpdGVtIHBhc3NlZCB0byBzdHJlYW0uY29tYmluZS9zdHJlYW0ubWVyZ2UgaXMgYSBzdHJlYW1cIilcclxuXHRyZXR1cm4gaW5pdERlcGVuZGVuY3koY3JlYXRlU3RyZWFtKCksIHN0cmVhbXMsIGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIGZuLmFwcGx5KHRoaXMsIHN0cmVhbXMuY29uY2F0KFtzdHJlYW1zLmZpbHRlcihjaGFuZ2VkKV0pKVxyXG5cdH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXREZXBlbmRlbmN5KGRlcCwgc3RyZWFtcywgZGVyaXZlKSB7XHJcblx0dmFyIHN0YXRlID0gZGVwLl9zdGF0ZVxyXG5cdHN0YXRlLmRlcml2ZSA9IGRlcml2ZVxyXG5cdHN0YXRlLnBhcmVudHMgPSBzdHJlYW1zLmZpbHRlcihub3RFbmRlZClcclxuXHJcblx0cmVnaXN0ZXJEZXBlbmRlbmN5KGRlcCwgc3RhdGUucGFyZW50cylcclxuXHR1cGRhdGVEZXBlbmRlbmN5KGRlcCwgdHJ1ZSlcclxuXHJcblx0cmV0dXJuIGRlcFxyXG59XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVwZW5kZW5jeShzdHJlYW0sIHBhcmVudHMpIHtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHBhcmVudHNbaV0uX3N0YXRlLmRlcHNbc3RyZWFtLl9zdGF0ZS5pZF0gPSBzdHJlYW1cclxuXHRcdHJlZ2lzdGVyRGVwZW5kZW5jeShzdHJlYW0sIHBhcmVudHNbaV0uX3N0YXRlLnBhcmVudHMpXHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIHVucmVnaXN0ZXJTdHJlYW0oc3RyZWFtKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHJlYW0uX3N0YXRlLnBhcmVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBwYXJlbnQgPSBzdHJlYW0uX3N0YXRlLnBhcmVudHNbaV1cclxuXHRcdGRlbGV0ZSBwYXJlbnQuX3N0YXRlLmRlcHNbc3RyZWFtLl9zdGF0ZS5pZF1cclxuXHR9XHJcblx0Zm9yICh2YXIgaWQgaW4gc3RyZWFtLl9zdGF0ZS5kZXBzKSB7XHJcblx0XHR2YXIgZGVwZW5kZW50ID0gc3RyZWFtLl9zdGF0ZS5kZXBzW2lkXVxyXG5cdFx0dmFyIGluZGV4ID0gZGVwZW5kZW50Ll9zdGF0ZS5wYXJlbnRzLmluZGV4T2Yoc3RyZWFtKVxyXG5cdFx0aWYgKGluZGV4ID4gLTEpIGRlcGVuZGVudC5fc3RhdGUucGFyZW50cy5zcGxpY2UoaW5kZXgsIDEpXHJcblx0fVxyXG5cdHN0cmVhbS5fc3RhdGUuc3RhdGUgPSAyIC8vZW5kZWRcclxuXHRzdHJlYW0uX3N0YXRlLmRlcHMgPSB7fVxyXG59XHJcblxyXG5mdW5jdGlvbiBtYXAoZm4pIHtyZXR1cm4gY29tYmluZShmdW5jdGlvbihzdHJlYW0pIHtyZXR1cm4gZm4oc3RyZWFtKCkpfSwgW3RoaXNdKX1cclxuZnVuY3Rpb24gYXAoc3RyZWFtKSB7cmV0dXJuIGNvbWJpbmUoZnVuY3Rpb24oczEsIHMyKSB7cmV0dXJuIHMxKCkoczIoKSl9LCBbc3RyZWFtLCB0aGlzXSl9XHJcbmZ1bmN0aW9uIHZhbHVlT2YoKSB7cmV0dXJuIHRoaXMuX3N0YXRlLnZhbHVlfVxyXG5mdW5jdGlvbiB0b0pTT04oKSB7cmV0dXJuIHRoaXMuX3N0YXRlLnZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHRoaXMuX3N0YXRlLnZhbHVlLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5fc3RhdGUudmFsdWUudG9KU09OKCkgOiB0aGlzLl9zdGF0ZS52YWx1ZX1cclxuXHJcbmZ1bmN0aW9uIHZhbGlkKHN0cmVhbSkge3JldHVybiBzdHJlYW0uX3N0YXRlIH1cclxuZnVuY3Rpb24gYWN0aXZlKHN0cmVhbSkge3JldHVybiBzdHJlYW0uX3N0YXRlLnN0YXRlID09PSAxfVxyXG5mdW5jdGlvbiBjaGFuZ2VkKHN0cmVhbSkge3JldHVybiBzdHJlYW0uX3N0YXRlLmNoYW5nZWR9XHJcbmZ1bmN0aW9uIG5vdEVuZGVkKHN0cmVhbSkge3JldHVybiBzdHJlYW0uX3N0YXRlLnN0YXRlICE9PSAyfVxyXG5cclxuZnVuY3Rpb24gbWVyZ2Uoc3RyZWFtcykge1xyXG5cdHJldHVybiBjb21iaW5lKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHN0cmVhbXMubWFwKGZ1bmN0aW9uKHMpIHtyZXR1cm4gcygpfSlcclxuXHR9LCBzdHJlYW1zKVxyXG59XHJcblxyXG5mdW5jdGlvbiBzY2FuKHJlZHVjZXIsIHNlZWQsIHN0cmVhbSkge1xyXG5cdHZhciBuZXdTdHJlYW0gPSBjb21iaW5lKGZ1bmN0aW9uIChzKSB7XHJcblx0XHRyZXR1cm4gc2VlZCA9IHJlZHVjZXIoc2VlZCwgcy5fc3RhdGUudmFsdWUpXHJcblx0fSwgW3N0cmVhbV0pXHJcblxyXG5cdGlmIChuZXdTdHJlYW0uX3N0YXRlLnN0YXRlID09PSAwKSBuZXdTdHJlYW0oc2VlZClcclxuXHJcblx0cmV0dXJuIG5ld1N0cmVhbVxyXG59XHJcblxyXG5mdW5jdGlvbiBzY2FuTWVyZ2UodHVwbGVzLCBzZWVkKSB7XHJcblx0dmFyIHN0cmVhbXMgPSB0dXBsZXMubWFwKGZ1bmN0aW9uKHR1cGxlKSB7XHJcblx0XHR2YXIgc3RyZWFtID0gdHVwbGVbMF1cclxuXHRcdGlmIChzdHJlYW0uX3N0YXRlLnN0YXRlID09PSAwKSBzdHJlYW0odW5kZWZpbmVkKVxyXG5cdFx0cmV0dXJuIHN0cmVhbVxyXG5cdH0pXHJcblxyXG5cdHZhciBuZXdTdHJlYW0gPSBjb21iaW5lKGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGNoYW5nZWQgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdXHJcblxyXG5cdFx0c3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uKHN0cmVhbSwgaWR4KSB7XHJcblx0XHRcdGlmIChjaGFuZ2VkLmluZGV4T2Yoc3RyZWFtKSA+IC0xKSB7XHJcblx0XHRcdFx0c2VlZCA9IHR1cGxlc1tpZHhdWzFdKHNlZWQsIHN0cmVhbS5fc3RhdGUudmFsdWUpXHJcblx0XHRcdH1cclxuXHRcdH0pXHJcblxyXG5cdFx0cmV0dXJuIHNlZWRcclxuXHR9LCBzdHJlYW1zKVxyXG5cclxuXHRyZXR1cm4gbmV3U3RyZWFtXHJcbn1cclxuXHJcbmNyZWF0ZVN0cmVhbVtcImZhbnRhc3ktbGFuZC9vZlwiXSA9IGNyZWF0ZVN0cmVhbVxyXG5jcmVhdGVTdHJlYW0ubWVyZ2UgPSBtZXJnZVxyXG5jcmVhdGVTdHJlYW0uY29tYmluZSA9IGNvbWJpbmVcclxuY3JlYXRlU3RyZWFtLnNjYW4gPSBzY2FuXHJcbmNyZWF0ZVN0cmVhbS5zY2FuTWVyZ2UgPSBzY2FuTWVyZ2VcclxuY3JlYXRlU3RyZWFtLkhBTFQgPSBIQUxUXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlW1wiZXhwb3J0c1wiXSA9IGNyZWF0ZVN0cmVhbVxyXG5lbHNlIGlmICh0eXBlb2Ygd2luZG93Lm0gPT09IFwiZnVuY3Rpb25cIiAmJiAhKFwic3RyZWFtXCIgaW4gd2luZG93Lm0pKSB3aW5kb3cubS5zdHJlYW0gPSBjcmVhdGVTdHJlYW1cclxuZWxzZSB3aW5kb3cubSA9IHtzdHJlYW0gOiBjcmVhdGVTdHJlYW19XHJcblxyXG59KCkpO1xyXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgVm5vZGUgPSByZXF1aXJlKFwiLi4vcmVuZGVyL3Zub2RlXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmVkcmF3U2VydmljZSkge1xuXHRyZXR1cm4gZnVuY3Rpb24ocm9vdCwgY29tcG9uZW50KSB7XG5cdFx0aWYgKGNvbXBvbmVudCA9PT0gbnVsbCkge1xuXHRcdFx0cmVkcmF3U2VydmljZS51bnN1YnNjcmliZShyb290KVxuXHRcdH0gZWxzZSBpZiAoY29tcG9uZW50LnZpZXcgPT0gbnVsbCAmJiB0eXBlb2YgY29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm0ubW91bnQoZWxlbWVudCwgY29tcG9uZW50KSBleHBlY3RzIGEgY29tcG9uZW50LCBub3QgYSB2bm9kZVwiKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlLnN1YnNjcmliZShyb290LCBmdW5jdGlvbigpIHsgcmV0dXJuIFZub2RlKGNvbXBvbmVudCkgfSlcblx0XHR9XG5cdH1cbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBjb3JlUmVuZGVyZXIgPSByZXF1aXJlKFwiLi4vcmVuZGVyL3JlbmRlclwiKVxuXG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaykge1xuXHR2YXIgcGVuZGluZyA9IG51bGxcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdGlmIChwZW5kaW5nID09PSBudWxsKSB7XG5cdFx0XHRwZW5kaW5nID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwZW5kaW5nID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjaygpXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCR3aW5kb3csIHRocm90dGxlTW9jaykge1xuXHR2YXIgcmVuZGVyU2VydmljZSA9IGNvcmVSZW5kZXJlcigkd2luZG93KVxuXHR2YXIgc3Vic2NyaXB0aW9ucyA9IFtdXG5cdHZhciByZW5kZXJpbmcgPSBmYWxzZVxuXG5cdGZ1bmN0aW9uIHJ1bihzdWIpIHtcblx0XHR2YXIgdm5vZGUgPSBzdWIuYyhzdWIpXG5cdFx0aWYgKHZub2RlICE9PSBzdWIpIHJlbmRlclNlcnZpY2UucmVuZGVyKHN1Yi5rLCB2bm9kZSlcblx0fVxuXHRmdW5jdGlvbiBzdWJzY3JpYmUoa2V5LCBjYWxsYmFjaywgb25yZW1vdmUpIHtcblx0XHR2YXIgc3ViID0ge2s6IGtleSwgYzogY2FsbGJhY2ssIHI6IG9ucmVtb3ZlfVxuXHRcdHVuc3Vic2NyaWJlKGtleSlcblx0XHRzdWJzY3JpcHRpb25zLnB1c2goc3ViKVxuXHRcdHZhciB2bm9kZSA9IHN1Yi5jKHN1Yilcblx0XHRpZiAodm5vZGUgIT09IHN1YikgcmVuZGVyU2VydmljZS5yZW5kZXIoc3ViLmssIHZub2RlKVxuXHR9XG5cdGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGtleSkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHN1YiA9IHN1YnNjcmlwdGlvbnNbaV1cblx0XHRcdGlmIChzdWIuayA9PT0ga2V5KSB7XG5cdFx0XHRcdHN1YnNjcmlwdGlvbnMuc3BsaWNlKGksIDEpXG5cdFx0XHRcdHJlbmRlclNlcnZpY2UucmVuZGVyKHN1Yi5rLCBbXSlcblx0XHRcdFx0aWYgKHR5cGVvZiBzdWIuciA9PT0gXCJmdW5jdGlvblwiKSBzdWIucigpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHN5bmMoKSB7XG5cdFx0aWYgKHJlbmRlcmluZykgdGhyb3cgbmV3IEVycm9yKFwiTmVzdGVkIG0ucmVkcmF3LnN5bmMoKSBjYWxsXCIpXG5cdFx0cmVuZGVyaW5nID0gdHJ1ZVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dHJ5IHsgcnVuKHN1YnNjcmlwdGlvbnNbaV0pIH1cblx0XHRcdGNhdGNoIChlKSB7IGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS5lcnJvcihlKSB9XG5cdFx0fVxuXHRcdHJlbmRlcmluZyA9IGZhbHNlXG5cdH1cblxuXHR2YXIgcmVkcmF3ID0gKHRocm90dGxlTW9jayB8fCB0aHJvdHRsZSkoc3luYylcblx0cmVkcmF3LnN5bmMgPSBzeW5jXG5cdHJlbmRlclNlcnZpY2Uuc2V0UmVkcmF3KHJlZHJhdylcblx0cmV0dXJuIHtzdWJzY3JpYmU6IHN1YnNjcmliZSwgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlLCByZWRyYXc6IHJlZHJhdywgcmVuZGVyOiByZW5kZXJTZXJ2aWNlLnJlbmRlcn1cbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBWbm9kZSA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvdm5vZGVcIilcbnZhciBQcm9taXNlID0gcmVxdWlyZShcIi4uL3Byb21pc2UvcHJvbWlzZVwiKVxudmFyIGNvcmVSb3V0ZXIgPSByZXF1aXJlKFwiLi4vcm91dGVyL3JvdXRlclwiKVxuXG52YXIgc2VudGluZWwgPSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCR3aW5kb3csIHJlZHJhd1NlcnZpY2UpIHtcblx0dmFyIHJvdXRlU2VydmljZSA9IGNvcmVSb3V0ZXIoJHdpbmRvdylcblxuXHR2YXIgY3VycmVudFJlc29sdmVyID0gc2VudGluZWwsIGNvbXBvbmVudCwgYXR0cnMsIGN1cnJlbnRQYXRoLCBsYXN0VXBkYXRlXG5cdHZhciByb3V0ZSA9IGZ1bmN0aW9uKHJvb3QsIGRlZmF1bHRSb3V0ZSwgcm91dGVzKSB7XG5cdFx0aWYgKHJvb3QgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgdG8gYG0ucm91dGVgIGlzIG5vdCB1bmRlZmluZWRcIilcblx0XHR2YXIgaW5pdCA9IGZhbHNlXG5cdFx0dmFyIGJhaWwgPSBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRpZiAocGF0aCAhPT0gZGVmYXVsdFJvdXRlKSByb3V0ZVNlcnZpY2Uuc2V0UGF0aChkZWZhdWx0Um91dGUsIG51bGwsIHtyZXBsYWNlOiB0cnVlfSlcblx0XHRcdGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgZGVmYXVsdCByb3V0ZSBcIiArIGRlZmF1bHRSb3V0ZSlcblx0XHR9XG5cdFx0ZnVuY3Rpb24gcnVuKCkge1xuXHRcdFx0aW5pdCA9IHRydWVcblx0XHRcdGlmIChzZW50aW5lbCAhPT0gY3VycmVudFJlc29sdmVyKSB7XG5cdFx0XHRcdHZhciB2bm9kZSA9IFZub2RlKGNvbXBvbmVudCwgYXR0cnMua2V5LCBhdHRycylcblx0XHRcdFx0aWYgKGN1cnJlbnRSZXNvbHZlcikgdm5vZGUgPSBjdXJyZW50UmVzb2x2ZXIucmVuZGVyKHZub2RlKVxuXHRcdFx0XHRyZXR1cm4gdm5vZGVcblx0XHRcdH1cblx0XHR9XG5cdFx0cm91dGVTZXJ2aWNlLmRlZmluZVJvdXRlcyhyb3V0ZXMsIGZ1bmN0aW9uKHBheWxvYWQsIHBhcmFtcywgcGF0aCwgcm91dGUpIHtcblx0XHRcdHZhciB1cGRhdGUgPSBsYXN0VXBkYXRlID0gZnVuY3Rpb24ocm91dGVSZXNvbHZlciwgY29tcCkge1xuXHRcdFx0XHRpZiAodXBkYXRlICE9PSBsYXN0VXBkYXRlKSByZXR1cm5cblx0XHRcdFx0Y29tcG9uZW50ID0gY29tcCAhPSBudWxsICYmICh0eXBlb2YgY29tcC52aWV3ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGNvbXAgPT09IFwiZnVuY3Rpb25cIik/IGNvbXAgOiBcImRpdlwiXG5cdFx0XHRcdGF0dHJzID0gcGFyYW1zLCBjdXJyZW50UGF0aCA9IHBhdGgsIGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0XHRcdGN1cnJlbnRSZXNvbHZlciA9IHJvdXRlUmVzb2x2ZXIucmVuZGVyID8gcm91dGVSZXNvbHZlciA6IG51bGxcblx0XHRcdFx0aWYgKGluaXQpIHJlZHJhd1NlcnZpY2UucmVkcmF3KClcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aW5pdCA9IHRydWVcblx0XHRcdFx0XHRyZWRyYXdTZXJ2aWNlLnJlZHJhdy5zeW5jKClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBheWxvYWQudmlldyB8fCB0eXBlb2YgcGF5bG9hZCA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGUoe30sIHBheWxvYWQpXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKHBheWxvYWQub25tYXRjaCkge1xuXHRcdFx0XHRcdFByb21pc2UucmVzb2x2ZShwYXlsb2FkLm9ubWF0Y2gocGFyYW1zLCBwYXRoLCByb3V0ZSkpLnRoZW4oZnVuY3Rpb24ocmVzb2x2ZWQpIHtcblx0XHRcdFx0XHRcdHVwZGF0ZShwYXlsb2FkLCByZXNvbHZlZClcblx0XHRcdFx0XHR9LCBmdW5jdGlvbiAoKSB7IGJhaWwocGF0aCkgfSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHVwZGF0ZShwYXlsb2FkLCBcImRpdlwiKVxuXHRcdFx0fVxuXHRcdH0sIGJhaWwsIGRlZmF1bHRSb3V0ZSwgZnVuY3Rpb24gKHVuc3Vic2NyaWJlKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlLnN1YnNjcmliZShyb290LCBmdW5jdGlvbihzdWIpIHtcblx0XHRcdFx0c3ViLmMgPSBydW5cblx0XHRcdFx0cmV0dXJuIHN1YlxuXHRcdFx0fSwgdW5zdWJzY3JpYmUpXG5cdFx0fSlcblx0fVxuXHRyb3V0ZS5zZXQgPSBmdW5jdGlvbihwYXRoLCBkYXRhLCBvcHRpb25zKSB7XG5cdFx0aWYgKGxhc3RVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblx0XHRcdG9wdGlvbnMucmVwbGFjZSA9IHRydWVcblx0XHR9XG5cdFx0bGFzdFVwZGF0ZSA9IG51bGxcblx0XHRyb3V0ZVNlcnZpY2Uuc2V0UGF0aChwYXRoLCBkYXRhLCBvcHRpb25zKVxuXHR9XG5cdHJvdXRlLmdldCA9IGZ1bmN0aW9uKCkge3JldHVybiBjdXJyZW50UGF0aH1cblx0cm91dGUucHJlZml4ID0gZnVuY3Rpb24ocHJlZml4KSB7cm91dGVTZXJ2aWNlLnByZWZpeCA9IHByZWZpeH1cblx0dmFyIGxpbmsgPSBmdW5jdGlvbihvcHRpb25zLCB2bm9kZSkge1xuXHRcdHZub2RlLmRvbS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHJvdXRlU2VydmljZS5wcmVmaXggKyB2bm9kZS5hdHRycy5ocmVmKVxuXHRcdHZub2RlLmRvbS5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSB8fCBlLndoaWNoID09PSAyKSByZXR1cm5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKVxuXHRcdFx0ZS5yZWRyYXcgPSBmYWxzZVxuXHRcdFx0dmFyIGhyZWYgPSB0aGlzLmdldEF0dHJpYnV0ZShcImhyZWZcIilcblx0XHRcdGlmIChocmVmLmluZGV4T2Yocm91dGVTZXJ2aWNlLnByZWZpeCkgPT09IDApIGhyZWYgPSBocmVmLnNsaWNlKHJvdXRlU2VydmljZS5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0cm91dGUuc2V0KGhyZWYsIHVuZGVmaW5lZCwgb3B0aW9ucylcblx0XHR9XG5cdH1cblx0cm91dGUubGluayA9IGZ1bmN0aW9uKGFyZ3MpIHtcblx0XHRpZiAoYXJncy50YWcgPT0gbnVsbCkgcmV0dXJuIGxpbmsuYmluZChsaW5rLCBhcmdzKVxuXHRcdHJldHVybiBsaW5rKHt9LCBhcmdzKVxuXHR9XG5cdHJvdXRlLnBhcmFtID0gZnVuY3Rpb24oa2V5KSB7XG5cdFx0aWYodHlwZW9mIGF0dHJzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBrZXkgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBhdHRyc1trZXldXG5cdFx0cmV0dXJuIGF0dHJzXG5cdH1cblxuXHRyZXR1cm4gcm91dGVcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBoeXBlcnNjcmlwdCA9IHJlcXVpcmUoXCIuL3JlbmRlci9oeXBlcnNjcmlwdFwiKVxuXG5oeXBlcnNjcmlwdC50cnVzdCA9IHJlcXVpcmUoXCIuL3JlbmRlci90cnVzdFwiKVxuaHlwZXJzY3JpcHQuZnJhZ21lbnQgPSByZXF1aXJlKFwiLi9yZW5kZXIvZnJhZ21lbnRcIilcblxubW9kdWxlLmV4cG9ydHMgPSBoeXBlcnNjcmlwdFxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGh5cGVyc2NyaXB0ID0gcmVxdWlyZShcIi4vaHlwZXJzY3JpcHRcIilcbnZhciBtID0gZnVuY3Rpb24gbSgpIHsgcmV0dXJuIGh5cGVyc2NyaXB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxubS5tID0gaHlwZXJzY3JpcHRcbm0udHJ1c3QgPSBoeXBlcnNjcmlwdC50cnVzdFxubS5mcmFnbWVudCA9IGh5cGVyc2NyaXB0LmZyYWdtZW50XG5cbnZhciByZXF1ZXN0U2VydmljZSA9IHJlcXVpcmUoXCIuL3JlcXVlc3RcIilcbnZhciByZWRyYXdTZXJ2aWNlID0gcmVxdWlyZShcIi4vcmVkcmF3XCIpXG5cbnJlcXVlc3RTZXJ2aWNlLnNldENvbXBsZXRpb25DYWxsYmFjayhyZWRyYXdTZXJ2aWNlLnJlZHJhdylcblxubS5tb3VudCA9IHJlcXVpcmUoXCIuL21vdW50XCIpXG5tLnJvdXRlID0gcmVxdWlyZShcIi4vcm91dGVcIilcbm0ucmVuZGVyID0gcmVxdWlyZShcIi4vcmVuZGVyXCIpLnJlbmRlclxubS5yZWRyYXcgPSByZWRyYXdTZXJ2aWNlLnJlZHJhd1xubS5yZXF1ZXN0ID0gcmVxdWVzdFNlcnZpY2UucmVxdWVzdFxubS5qc29ucCA9IHJlcXVlc3RTZXJ2aWNlLmpzb25wXG5tLnBhcnNlUXVlcnlTdHJpbmcgPSByZXF1aXJlKFwiLi9xdWVyeXN0cmluZy9wYXJzZVwiKVxubS5idWlsZFF1ZXJ5U3RyaW5nID0gcmVxdWlyZShcIi4vcXVlcnlzdHJpbmcvYnVpbGRcIilcbm0ucGFyc2VQYXRobmFtZSA9IHJlcXVpcmUoXCIuL3BhdGhuYW1lL3BhcnNlXCIpXG5tLmJ1aWxkUGF0aG5hbWUgPSByZXF1aXJlKFwiLi9wYXRobmFtZS9idWlsZFwiKVxubS52ZXJzaW9uID0gcmVxdWlyZShcIi4vcGFja2FnZS5qc29uXCIpLnZlcnNpb25cbm0udm5vZGUgPSByZXF1aXJlKFwiLi9yZW5kZXIvdm5vZGVcIilcbm0uUHJvbWlzZVBvbHlmaWxsID0gcmVxdWlyZShcIi4vcHJvbWlzZS9wb2x5ZmlsbFwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciByZWRyYXdTZXJ2aWNlID0gcmVxdWlyZShcIi4vcmVkcmF3XCIpXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vYXBpL21vdW50XCIpKHJlZHJhd1NlcnZpY2UpXG4iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UpIHtcblx0aWYoc291cmNlKSBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV0gfSlcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBidWlsZFF1ZXJ5U3RyaW5nID0gcmVxdWlyZShcIi4uL3F1ZXJ5c3RyaW5nL2J1aWxkXCIpXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vYXNzaWduXCIpXG5cbi8vIFJldHVybnMgYHBhdGhgIGZyb20gYHRlbXBsYXRlYCArIGBwYXJhbXNgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRlbXBsYXRlLCBwYXJhbXMpIHtcblx0aWYgKCgvOihbXlxcL1xcLi1dKykoXFwuezN9KT86LykudGVzdCh0ZW1wbGF0ZSkpIHtcblx0XHR0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUZW1wbGF0ZSBwYXJhbWV0ZXIgbmFtZXMgKm11c3QqIGJlIHNlcGFyYXRlZFwiKVxuXHR9XG5cdGlmIChwYXJhbXMgPT0gbnVsbCkgcmV0dXJuIHRlbXBsYXRlXG5cdHZhciBxdWVyeUluZGV4ID0gdGVtcGxhdGUuaW5kZXhPZihcIj9cIilcblx0dmFyIGhhc2hJbmRleCA9IHRlbXBsYXRlLmluZGV4T2YoXCIjXCIpXG5cdHZhciBxdWVyeUVuZCA9IGhhc2hJbmRleCA8IDAgPyB0ZW1wbGF0ZS5sZW5ndGggOiBoYXNoSW5kZXhcblx0dmFyIHBhdGhFbmQgPSBxdWVyeUluZGV4IDwgMCA/IHF1ZXJ5RW5kIDogcXVlcnlJbmRleFxuXHR2YXIgcGF0aCA9IHRlbXBsYXRlLnNsaWNlKDAsIHBhdGhFbmQpXG5cdHZhciBxdWVyeSA9IHt9XG5cblx0YXNzaWduKHF1ZXJ5LCBwYXJhbXMpXG5cblx0dmFyIHJlc29sdmVkID0gcGF0aC5yZXBsYWNlKC86KFteXFwvXFwuLV0rKShcXC57M30pPy9nLCBmdW5jdGlvbihtLCBrZXksIHZhcmlhZGljKSB7XG5cdFx0ZGVsZXRlIHF1ZXJ5W2tleV1cblx0XHQvLyBJZiBubyBzdWNoIHBhcmFtZXRlciBleGlzdHMsIGRvbid0IGludGVycG9sYXRlIGl0LlxuXHRcdGlmIChwYXJhbXNba2V5XSA9PSBudWxsKSByZXR1cm4gbVxuXHRcdC8vIEVzY2FwZSBub3JtYWwgcGFyYW1ldGVycywgYnV0IG5vdCB2YXJpYWRpYyBvbmVzLlxuXHRcdHJldHVybiB2YXJpYWRpYyA/IHBhcmFtc1trZXldIDogZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhwYXJhbXNba2V5XSkpXG5cdH0pXG5cblx0Ly8gSW4gY2FzZSB0aGUgdGVtcGxhdGUgc3Vic3RpdHV0aW9uIGFkZHMgbmV3IHF1ZXJ5L2hhc2ggcGFyYW1ldGVycy5cblx0dmFyIG5ld1F1ZXJ5SW5kZXggPSByZXNvbHZlZC5pbmRleE9mKFwiP1wiKVxuXHR2YXIgbmV3SGFzaEluZGV4ID0gcmVzb2x2ZWQuaW5kZXhPZihcIiNcIilcblx0dmFyIG5ld1F1ZXJ5RW5kID0gbmV3SGFzaEluZGV4IDwgMCA/IHJlc29sdmVkLmxlbmd0aCA6IG5ld0hhc2hJbmRleFxuXHR2YXIgbmV3UGF0aEVuZCA9IG5ld1F1ZXJ5SW5kZXggPCAwID8gbmV3UXVlcnlFbmQgOiBuZXdRdWVyeUluZGV4XG5cdHZhciByZXN1bHQgPSByZXNvbHZlZC5zbGljZSgwLCBuZXdQYXRoRW5kKVxuXG5cdGlmIChxdWVyeUluZGV4ID49IDApIHJlc3VsdCArPSB0ZW1wbGF0ZS5zbGljZShxdWVyeUluZGV4LCBxdWVyeUVuZClcblx0aWYgKG5ld1F1ZXJ5SW5kZXggPj0gMCkgcmVzdWx0ICs9IChxdWVyeUluZGV4IDwgMCA/IFwiP1wiIDogXCImXCIpICsgcmVzb2x2ZWQuc2xpY2UobmV3UXVlcnlJbmRleCwgbmV3UXVlcnlFbmQpXG5cdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcocXVlcnkpXG5cdGlmIChxdWVyeXN0cmluZykgcmVzdWx0ICs9IChxdWVyeUluZGV4IDwgMCAmJiBuZXdRdWVyeUluZGV4IDwgMCA/IFwiP1wiIDogXCImXCIpICsgcXVlcnlzdHJpbmdcblx0aWYgKGhhc2hJbmRleCA+PSAwKSByZXN1bHQgKz0gdGVtcGxhdGUuc2xpY2UoaGFzaEluZGV4KVxuXHRpZiAobmV3SGFzaEluZGV4ID49IDApIHJlc3VsdCArPSAoaGFzaEluZGV4IDwgMCA/IFwiXCIgOiBcIiZcIikgKyByZXNvbHZlZC5zbGljZShuZXdIYXNoSW5kZXgpXG5cdHJldHVybiByZXN1bHRcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBwYXJzZVBhdGhuYW1lID0gcmVxdWlyZShcIi4vcGFyc2VcIilcblxuLy8gQ29tcGlsZXMgYSB0ZW1wbGF0ZSBpbnRvIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHJlc29sdmVkIHBhdGggKHdpdGhvdXQgcXVlcnlcbi8vIHN0cmluZ3MpIGFuZCByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0ZW1wbGF0ZSBwYXJhbWV0ZXJzIHdpdGggdGhlaXJcbi8vIHBhcnNlZCB2YWx1ZXMuIFRoaXMgZXhwZWN0cyB0aGUgaW5wdXQgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIHRvIGJlIHRoZVxuLy8gb3V0cHV0IG9mIGBwYXJzZVBhdGhuYW1lYC4gTm90ZSB0aGF0IGl0IGRvZXMgKm5vdCogcmVtb3ZlIHF1ZXJ5IHBhcmFtZXRlcnNcbi8vIHNwZWNpZmllZCBpbiB0aGUgdGVtcGxhdGUuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRlbXBsYXRlKSB7XG5cdHZhciB0ZW1wbGF0ZURhdGEgPSBwYXJzZVBhdGhuYW1lKHRlbXBsYXRlKVxuXHR2YXIgdGVtcGxhdGVLZXlzID0gT2JqZWN0LmtleXModGVtcGxhdGVEYXRhLnBhcmFtcylcblx0dmFyIGtleXMgPSBbXVxuXHR2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cChcIl5cIiArIHRlbXBsYXRlRGF0YS5wYXRoLnJlcGxhY2UoXG5cdFx0Ly8gSSBlc2NhcGUgbGl0ZXJhbCB0ZXh0IHNvIHBlb3BsZSBjYW4gdXNlIHRoaW5ncyBsaWtlIGA6ZmlsZS46ZXh0YCBvclxuXHRcdC8vIGA6bGFuZy06bG9jYWxlYCBpbiByb3V0ZXMuIFRoaXMgaXMgYWxsIG1lcmdlZCBpbnRvIG9uZSBwYXNzIHNvIElcblx0XHQvLyBkb24ndCBhbHNvIGFjY2lkZW50YWxseSBlc2NhcGUgYC1gIGFuZCBtYWtlIGl0IGhhcmRlciB0byBkZXRlY3QgaXQgdG9cblx0XHQvLyBiYW4gaXQgZnJvbSB0ZW1wbGF0ZSBwYXJhbWV0ZXJzLlxuXHRcdC86KFteXFwvLi1dKykoXFwuezN9fFxcLig/IVxcLil8LSk/fFtcXFxcXiQqKy4oKXxcXFtcXF17fV0vZyxcblx0XHRmdW5jdGlvbihtLCBrZXksIGV4dHJhKSB7XG5cdFx0XHRpZiAoa2V5ID09IG51bGwpIHJldHVybiBcIlxcXFxcIiArIG1cblx0XHRcdGtleXMucHVzaCh7azoga2V5LCByOiBleHRyYSA9PT0gXCIuLi5cIn0pXG5cdFx0XHRpZiAoZXh0cmEgPT09IFwiLi4uXCIpIHJldHVybiBcIiguKilcIlxuXHRcdFx0aWYgKGV4dHJhID09PSBcIi5cIikgcmV0dXJuIFwiKFteL10rKVxcXFwuXCJcblx0XHRcdHJldHVybiBcIihbXi9dKylcIiArIChleHRyYSB8fCBcIlwiKVxuXHRcdH1cblx0KSArIFwiJFwiKVxuXHRyZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuXHRcdC8vIEZpcnN0LCBjaGVjayB0aGUgcGFyYW1zLiBVc3VhbGx5LCB0aGVyZSBpc24ndCBhbnksIGFuZCBpdCdzIGp1c3Rcblx0XHQvLyBjaGVja2luZyBhIHN0YXRpYyBzZXQuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wbGF0ZUtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0ZW1wbGF0ZURhdGEucGFyYW1zW3RlbXBsYXRlS2V5c1tpXV0gIT09IGRhdGEucGFyYW1zW3RlbXBsYXRlS2V5c1tpXV0pIHJldHVybiBmYWxzZVxuXHRcdH1cblx0XHQvLyBJZiBubyBpbnRlcnBvbGF0aW9ucyBleGlzdCwgbGV0J3Mgc2tpcCBhbGwgdGhlIGNlcmVtb255XG5cdFx0aWYgKCFrZXlzLmxlbmd0aCkgcmV0dXJuIHJlZ2V4cC50ZXN0KGRhdGEucGF0aClcblx0XHR2YXIgdmFsdWVzID0gcmVnZXhwLmV4ZWMoZGF0YS5wYXRoKVxuXHRcdGlmICh2YWx1ZXMgPT0gbnVsbCkgcmV0dXJuIGZhbHNlXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRkYXRhLnBhcmFtc1trZXlzW2ldLmtdID0ga2V5c1tpXS5yID8gdmFsdWVzW2kgKyAxXSA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZXNbaSArIDFdKVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZVxuXHR9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgcGFyc2VRdWVyeVN0cmluZyA9IHJlcXVpcmUoXCIuLi9xdWVyeXN0cmluZy9wYXJzZVwiKVxuXG4vLyBSZXR1cm5zIGB7cGF0aCwgcGFyYW1zfWAgZnJvbSBgdXJsYFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwpIHtcblx0dmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZihcIj9cIilcblx0dmFyIGhhc2hJbmRleCA9IHVybC5pbmRleE9mKFwiI1wiKVxuXHR2YXIgcXVlcnlFbmQgPSBoYXNoSW5kZXggPCAwID8gdXJsLmxlbmd0aCA6IGhhc2hJbmRleFxuXHR2YXIgcGF0aEVuZCA9IHF1ZXJ5SW5kZXggPCAwID8gcXVlcnlFbmQgOiBxdWVyeUluZGV4XG5cdHZhciBwYXRoID0gdXJsLnNsaWNlKDAsIHBhdGhFbmQpLnJlcGxhY2UoL1xcL3syLH0vZywgXCIvXCIpXG5cblx0aWYgKCFwYXRoKSBwYXRoID0gXCIvXCJcblx0ZWxzZSB7XG5cdFx0aWYgKHBhdGhbMF0gIT09IFwiL1wiKSBwYXRoID0gXCIvXCIgKyBwYXRoXG5cdFx0aWYgKHBhdGgubGVuZ3RoID4gMSAmJiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09IFwiL1wiKSBwYXRoID0gcGF0aC5zbGljZSgwLCAtMSlcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHBhdGg6IHBhdGgsXG5cdFx0cGFyYW1zOiBxdWVyeUluZGV4IDwgMFxuXHRcdFx0PyB7fVxuXHRcdFx0OiBwYXJzZVF1ZXJ5U3RyaW5nKHVybC5zbGljZShxdWVyeUluZGV4ICsgMSwgcXVlcnlFbmQpKSxcblx0fVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcbi8qKiBAY29uc3RydWN0b3IgKi9cbnZhciBQcm9taXNlUG9seWZpbGwgPSBmdW5jdGlvbihleGVjdXRvcikge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZVBvbHlmaWxsKSkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZSBtdXN0IGJlIGNhbGxlZCB3aXRoIGBuZXdgXCIpXG5cdGlmICh0eXBlb2YgZXhlY3V0b3IgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvblwiKVxuXG5cdHZhciBzZWxmID0gdGhpcywgcmVzb2x2ZXJzID0gW10sIHJlamVjdG9ycyA9IFtdLCByZXNvbHZlQ3VycmVudCA9IGhhbmRsZXIocmVzb2x2ZXJzLCB0cnVlKSwgcmVqZWN0Q3VycmVudCA9IGhhbmRsZXIocmVqZWN0b3JzLCBmYWxzZSlcblx0dmFyIGluc3RhbmNlID0gc2VsZi5faW5zdGFuY2UgPSB7cmVzb2x2ZXJzOiByZXNvbHZlcnMsIHJlamVjdG9yczogcmVqZWN0b3JzfVxuXHR2YXIgY2FsbEFzeW5jID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dFxuXHRmdW5jdGlvbiBoYW5kbGVyKGxpc3QsIHNob3VsZEFic29yYikge1xuXHRcdHJldHVybiBmdW5jdGlvbiBleGVjdXRlKHZhbHVlKSB7XG5cdFx0XHR2YXIgdGhlblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHNob3VsZEFic29yYiAmJiB2YWx1ZSAhPSBudWxsICYmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiAodGhlbiA9IHZhbHVlLnRoZW4pID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IHNlbGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIHcvIGl0c2VsZlwiKVxuXHRcdFx0XHRcdGV4ZWN1dGVPbmNlKHRoZW4uYmluZCh2YWx1ZSkpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y2FsbEFzeW5jKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCFzaG91bGRBYnNvcmIgJiYgbGlzdC5sZW5ndGggPT09IDApIGNvbnNvbGUuZXJyb3IoXCJQb3NzaWJsZSB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb246XCIsIHZhbHVlKVxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSBsaXN0W2ldKHZhbHVlKVxuXHRcdFx0XHRcdFx0cmVzb2x2ZXJzLmxlbmd0aCA9IDAsIHJlamVjdG9ycy5sZW5ndGggPSAwXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5zdGF0ZSA9IHNob3VsZEFic29yYlxuXHRcdFx0XHRcdFx0aW5zdGFuY2UucmV0cnkgPSBmdW5jdGlvbigpIHtleGVjdXRlKHZhbHVlKX1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRyZWplY3RDdXJyZW50KGUpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGV4ZWN1dGVPbmNlKHRoZW4pIHtcblx0XHR2YXIgcnVucyA9IDBcblx0XHRmdW5jdGlvbiBydW4oZm4pIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRpZiAocnVucysrID4gMCkgcmV0dXJuXG5cdFx0XHRcdGZuKHZhbHVlKVxuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgb25lcnJvciA9IHJ1bihyZWplY3RDdXJyZW50KVxuXHRcdHRyeSB7dGhlbihydW4ocmVzb2x2ZUN1cnJlbnQpLCBvbmVycm9yKX0gY2F0Y2ggKGUpIHtvbmVycm9yKGUpfVxuXHR9XG5cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRyZXR1cm4gdGhpcy50aGVuKFxuXHRcdGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHR9KVxuXHRcdH0sXG5cdFx0ZnVuY3Rpb24ocmVhc29uKSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZWplY3QocmVhc29uKTtcblx0XHRcdH0pXG5cdFx0fVxuXHQpXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2VQb2x5ZmlsbFxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIFByb21pc2VQb2x5ZmlsbCA9IHJlcXVpcmUoXCIuL3BvbHlmaWxsXCIpXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdGlmICh0eXBlb2Ygd2luZG93LlByb21pc2UgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHR3aW5kb3cuUHJvbWlzZSA9IFByb21pc2VQb2x5ZmlsbFxuXHR9IGVsc2UgaWYgKCF3aW5kb3cuUHJvbWlzZS5wcm90b3R5cGUuZmluYWxseSkge1xuXHRcdHdpbmRvdy5Qcm9taXNlLnByb3RvdHlwZS5maW5hbGx5ID0gUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5maW5hbGx5XG5cdH1cblx0bW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuUHJvbWlzZVxufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsLlByb21pc2UgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRnbG9iYWwuUHJvbWlzZSA9IFByb21pc2VQb2x5ZmlsbFxuXHR9IGVsc2UgaWYgKCFnbG9iYWwuUHJvbWlzZS5wcm90b3R5cGUuZmluYWxseSkge1xuXHRcdGdsb2JhbC5Qcm9taXNlLnByb3RvdHlwZS5maW5hbGx5ID0gUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5maW5hbGx5XG5cdH1cblx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuUHJvbWlzZVxufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlUG9seWZpbGxcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIikgcmV0dXJuIFwiXCJcblxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcblx0XHRkZXN0cnVjdHVyZShrZXksIG9iamVjdFtrZXldKVxuXHR9XG5cblx0cmV0dXJuIGFyZ3Muam9pbihcIiZcIilcblxuXHRmdW5jdGlvbiBkZXN0cnVjdHVyZShrZXksIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleSArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuXHRcdFx0Zm9yICh2YXIgaSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRkZXN0cnVjdHVyZShrZXkgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgYXJncy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuLy8gVGhlIGV4dHJhIGBkYXRhYCBwYXJhbWV0ZXIgaXMgZm9yIGlmIHlvdSB3YW50IHRvIGFwcGVuZCB0byBhbiBleGlzdGluZ1xuLy8gcGFyYW1ldGVycyBvYmplY3QuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHRpZiAoc3RyaW5nID09PSBcIlwiIHx8IHN0cmluZyA9PSBudWxsKSByZXR1cm4ge31cblx0aWYgKHN0cmluZy5jaGFyQXQoMCkgPT09IFwiP1wiKSBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMSlcblxuXHR2YXIgZW50cmllcyA9IHN0cmluZy5zcGxpdChcIiZcIiksIGNvdW50ZXJzID0ge30sIGRhdGEgPSB7fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZW50cnkgPSBlbnRyaWVzW2ldLnNwbGl0KFwiPVwiKVxuXHRcdHZhciBrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMF0pXG5cdFx0dmFyIHZhbHVlID0gZW50cnkubGVuZ3RoID09PSAyID8gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5WzFdKSA6IFwiXCJcblxuXHRcdGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHZhbHVlID0gdHJ1ZVxuXHRcdGVsc2UgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHZhbHVlID0gZmFsc2VcblxuXHRcdHZhciBsZXZlbHMgPSBrZXkuc3BsaXQoL1xcXVxcWz98XFxbLylcblx0XHR2YXIgY3Vyc29yID0gZGF0YVxuXHRcdGlmIChrZXkuaW5kZXhPZihcIltcIikgPiAtMSkgbGV2ZWxzLnBvcCgpXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdHZhciBsZXZlbCA9IGxldmVsc1tqXSwgbmV4dExldmVsID0gbGV2ZWxzW2ogKyAxXVxuXHRcdFx0dmFyIGlzTnVtYmVyID0gbmV4dExldmVsID09IFwiXCIgfHwgIWlzTmFOKHBhcnNlSW50KG5leHRMZXZlbCwgMTApKVxuXHRcdFx0dmFyIGlzVmFsdWUgPSBqID09PSBsZXZlbHMubGVuZ3RoIC0gMVxuXHRcdFx0aWYgKGxldmVsID09PSBcIlwiKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBsZXZlbHMuc2xpY2UoMCwgaikuam9pbigpXG5cdFx0XHRcdGlmIChjb3VudGVyc1trZXldID09IG51bGwpIHtcblx0XHRcdFx0XHRjb3VudGVyc1trZXldID0gQXJyYXkuaXNBcnJheShjdXJzb3IpID8gY3Vyc29yLmxlbmd0aCA6IDBcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXZlbCA9IGNvdW50ZXJzW2tleV0rK1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzVmFsdWUpIGN1cnNvcltsZXZlbF0gPSB2YWx1ZVxuXHRcdFx0ZWxzZSBpZiAoY3Vyc29yW2xldmVsXSA9PSBudWxsKSBjdXJzb3JbbGV2ZWxdID0gaXNOdW1iZXIgPyBbXSA6IHt9XG5cdFx0XHRjdXJzb3IgPSBjdXJzb3JbbGV2ZWxdXG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhXG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2FwaS9yZWRyYXdcIikod2luZG93KVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9yZW5kZXIvcmVuZGVyXCIpKHdpbmRvdylcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBWbm9kZSA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvdm5vZGVcIilcbnZhciBoeXBlcnNjcmlwdFZub2RlID0gcmVxdWlyZShcIi4vaHlwZXJzY3JpcHRWbm9kZVwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdm5vZGUgPSBoeXBlcnNjcmlwdFZub2RlLmFwcGx5KDAsIGFyZ3VtZW50cylcblxuXHR2bm9kZS50YWcgPSBcIltcIlxuXHR2bm9kZS5jaGlsZHJlbiA9IFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLmNoaWxkcmVuKVxuXHRyZXR1cm4gdm5vZGVcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBWbm9kZSA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvdm5vZGVcIilcbnZhciBoeXBlcnNjcmlwdFZub2RlID0gcmVxdWlyZShcIi4vaHlwZXJzY3JpcHRWbm9kZVwiKVxuXG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5cbmZ1bmN0aW9uIGlzRW1wdHkob2JqZWN0KSB7XG5cdGZvciAodmFyIGtleSBpbiBvYmplY3QpIGlmIChoYXNPd24uY2FsbChvYmplY3QsIGtleSkpIHJldHVybiBmYWxzZVxuXHRyZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgPT09IFwiXCIgPyBhdHRyVmFsdWUgOiBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuXG5mdW5jdGlvbiBleGVjU2VsZWN0b3Ioc3RhdGUsIHZub2RlKSB7XG5cdHZhciBhdHRycyA9IHZub2RlLmF0dHJzXG5cdHZhciBjaGlsZHJlbiA9IFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLmNoaWxkcmVuKVxuXHR2YXIgaGFzQ2xhc3MgPSBoYXNPd24uY2FsbChhdHRycywgXCJjbGFzc1wiKVxuXHR2YXIgY2xhc3NOYW1lID0gaGFzQ2xhc3MgPyBhdHRycy5jbGFzcyA6IGF0dHJzLmNsYXNzTmFtZVxuXG5cdHZub2RlLnRhZyA9IHN0YXRlLnRhZ1xuXHR2bm9kZS5hdHRycyA9IG51bGxcblx0dm5vZGUuY2hpbGRyZW4gPSB1bmRlZmluZWRcblxuXHRpZiAoIWlzRW1wdHkoc3RhdGUuYXR0cnMpICYmICFpc0VtcHR5KGF0dHJzKSkge1xuXHRcdHZhciBuZXdBdHRycyA9IHt9XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRcdGlmIChoYXNPd24uY2FsbChhdHRycywga2V5KSkgbmV3QXR0cnNba2V5XSA9IGF0dHJzW2tleV1cblx0XHR9XG5cblx0XHRhdHRycyA9IG5ld0F0dHJzXG5cdH1cblxuXHRmb3IgKHZhciBrZXkgaW4gc3RhdGUuYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoc3RhdGUuYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImNsYXNzTmFtZVwiICYmICFoYXNPd24uY2FsbChhdHRycywga2V5KSl7XG5cdFx0XHRhdHRyc1trZXldID0gc3RhdGUuYXR0cnNba2V5XVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3NOYW1lICE9IG51bGwgfHwgc3RhdGUuYXR0cnMuY2xhc3NOYW1lICE9IG51bGwpIGF0dHJzLmNsYXNzTmFtZSA9XG5cdFx0Y2xhc3NOYW1lICE9IG51bGxcblx0XHRcdD8gc3RhdGUuYXR0cnMuY2xhc3NOYW1lICE9IG51bGxcblx0XHRcdFx0PyBTdHJpbmcoc3RhdGUuYXR0cnMuY2xhc3NOYW1lKSArIFwiIFwiICsgU3RyaW5nKGNsYXNzTmFtZSlcblx0XHRcdFx0OiBjbGFzc05hbWVcblx0XHRcdDogc3RhdGUuYXR0cnMuY2xhc3NOYW1lICE9IG51bGxcblx0XHRcdFx0PyBzdGF0ZS5hdHRycy5jbGFzc05hbWVcblx0XHRcdFx0OiBudWxsXG5cblx0aWYgKGhhc0NsYXNzKSBhdHRycy5jbGFzcyA9IG51bGxcblxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHR2bm9kZS5hdHRycyA9IGF0dHJzXG5cdFx0XHRicmVha1xuXHRcdH1cblx0fVxuXG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dm5vZGUudGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0dm5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlblxuXHR9XG5cblx0cmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cblx0dmFyIHZub2RlID0gaHlwZXJzY3JpcHRWbm9kZS5hcHBseSgxLCBhcmd1bWVudHMpXG5cblx0aWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHZub2RlLmNoaWxkcmVuID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGUuY2hpbGRyZW4pXG5cdFx0aWYgKHNlbGVjdG9yICE9PSBcIltcIikgcmV0dXJuIGV4ZWNTZWxlY3RvcihzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSB8fCBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpLCB2bm9kZSlcblx0fVxuXG5cdHZub2RlLnRhZyA9IHNlbGVjdG9yXG5cdHJldHVybiB2bm9kZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGVyc2NyaXB0XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgVm5vZGUgPSByZXF1aXJlKFwiLi4vcmVuZGVyL3Zub2RlXCIpXG5cbi8vIENhbGwgdmlhIGBoeXBlcnNjcmlwdFZub2RlLmFwcGx5KHN0YXJ0T2Zmc2V0LCBhcmd1bWVudHMpYFxuLy9cbi8vIFRoZSByZWFzb24gSSBkbyBpdCB0aGlzIHdheSwgZm9yd2FyZGluZyB0aGUgYXJndW1lbnRzIGFuZCBwYXNzaW5nIHRoZSBzdGFydFxuLy8gb2Zmc2V0IGluIGB0aGlzYCwgaXMgc28gSSBkb24ndCBoYXZlIHRvIGNyZWF0ZSBhIHRlbXBvcmFyeSBhcnJheSBpbiBhXG4vLyBwZXJmb3JtYW5jZS1jcml0aWNhbCBwYXRoLlxuLy9cbi8vIEluIG5hdGl2ZSBFUzYsIEknZCBpbnN0ZWFkIGFkZCBhIGZpbmFsIGAuLi5hcmdzYCBwYXJhbWV0ZXIgdG8gdGhlXG4vLyBgaHlwZXJzY3JpcHRgIGFuZCBgZnJhZ21lbnRgIGZhY3RvcmllcyBhbmQgZGVmaW5lIHRoaXMgYXNcbi8vIGBoeXBlcnNjcmlwdFZub2RlKC4uLmFyZ3MpYCwgc2luY2UgbW9kZXJuIGVuZ2luZXMgZG8gb3B0aW1pemUgdGhhdCBhd2F5LiBCdXRcbi8vIEVTNSAod2hhdCBNaXRocmlsIHJlcXVpcmVzIHRoYW5rcyB0byBJRSBzdXBwb3J0KSBkb2Vzbid0IGdpdmUgbWUgdGhhdCBsdXh1cnksXG4vLyBhbmQgZW5naW5lcyBhcmVuJ3QgbmVhcmx5IGludGVsbGlnZW50IGVub3VnaCB0byBkbyBlaXRoZXIgb2YgdGhlc2U6XG4vL1xuLy8gMS4gRWxpZGUgdGhlIGFsbG9jYXRpb24gZm9yIGBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlgIHdoZW4gaXQncyBwYXNzZWQgdG9cbi8vICAgIGFub3RoZXIgZnVuY3Rpb24gb25seSB0byBiZSBpbmRleGVkLlxuLy8gMi4gRWxpZGUgYW4gYGFyZ3VtZW50c2AgYWxsb2NhdGlvbiB3aGVuIGl0J3MgcGFzc2VkIHRvIGFueSBmdW5jdGlvbiBvdGhlclxuLy8gICAgdGhhbiBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YCBvciBgUmVmbGVjdC5hcHBseWAuXG4vL1xuLy8gSW4gRVM2LCBpdCdkIHByb2JhYmx5IGxvb2sgY2xvc2VyIHRvIHRoaXMgKEknZCBuZWVkIHRvIHByb2ZpbGUgaXQsIHRob3VnaCk6XG4vLyBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF0dHJzLCAuLi5jaGlsZHJlbikge1xuLy8gICAgIGlmIChhdHRycyA9PSBudWxsIHx8IHR5cGVvZiBhdHRycyA9PT0gXCJvYmplY3RcIiAmJiBhdHRycy50YWcgPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShhdHRycykpIHtcbi8vICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGNoaWxkcmVuWzBdKSkgY2hpbGRyZW4gPSBjaGlsZHJlblswXVxuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmIEFycmF5LmlzQXJyYXkoYXR0cnMpID8gYXR0cnMgOiBbYXR0cnMsIC4uLmNoaWxkcmVuXVxuLy8gICAgICAgICBhdHRycyA9IHVuZGVmaW5lZFxuLy8gICAgIH1cbi8vXG4vLyAgICAgaWYgKGF0dHJzID09IG51bGwpIGF0dHJzID0ge31cbi8vICAgICByZXR1cm4gVm5vZGUoXCJcIiwgYXR0cnMua2V5LCBhdHRycywgY2hpbGRyZW4pXG4vLyB9XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgYXR0cnMgPSBhcmd1bWVudHNbdGhpc10sIHN0YXJ0ID0gdGhpcyArIDEsIGNoaWxkcmVuXG5cblx0aWYgKGF0dHJzID09IG51bGwpIHtcblx0XHRhdHRycyA9IHt9XG5cdH0gZWxzZSBpZiAodHlwZW9mIGF0dHJzICE9PSBcIm9iamVjdFwiIHx8IGF0dHJzLnRhZyAhPSBudWxsIHx8IEFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHRcdHN0YXJ0ID0gdGhpc1xuXHR9XG5cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IHN0YXJ0ICsgMSkge1xuXHRcdGNoaWxkcmVuID0gYXJndW1lbnRzW3N0YXJ0XVxuXHRcdGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIGNoaWxkcmVuID0gW2NoaWxkcmVuXVxuXHR9IGVsc2Uge1xuXHRcdGNoaWxkcmVuID0gW11cblx0XHR3aGlsZSAoc3RhcnQgPCBhcmd1bWVudHMubGVuZ3RoKSBjaGlsZHJlbi5wdXNoKGFyZ3VtZW50c1tzdGFydCsrXSlcblx0fVxuXG5cdHJldHVybiBWbm9kZShcIlwiLCBhdHRycy5rZXksIGF0dHJzLCBjaGlsZHJlbilcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBWbm9kZSA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvdm5vZGVcIilcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciAkZG9jID0gJHdpbmRvdy5kb2N1bWVudFxuXG5cdHZhciBuYW1lU3BhY2UgPSB7XG5cdFx0c3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG5cdFx0bWF0aDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCJcblx0fVxuXG5cdHZhciByZWRyYXdcblx0ZnVuY3Rpb24gc2V0UmVkcmF3KGNhbGxiYWNrKSB7cmV0dXJuIHJlZHJhdyA9IGNhbGxiYWNrfVxuXG5cdGZ1bmN0aW9uIGdldE5hbWVTcGFjZSh2bm9kZSkge1xuXHRcdHJldHVybiB2bm9kZS5hdHRycyAmJiB2bm9kZS5hdHRycy54bWxucyB8fCBuYW1lU3BhY2Vbdm5vZGUudGFnXVxuXHR9XG5cblx0Ly9zYW5pdHkgY2hlY2sgdG8gZGlzY291cmFnZSBwZW9wbGUgZnJvbSBkb2luZyBgdm5vZGUuc3RhdGUgPSAuLi5gXG5cdGZ1bmN0aW9uIGNoZWNrU3RhdGUodm5vZGUsIG9yaWdpbmFsKSB7XG5cdFx0aWYgKHZub2RlLnN0YXRlICE9PSBvcmlnaW5hbCkgdGhyb3cgbmV3IEVycm9yKFwiYHZub2RlLnN0YXRlYCBtdXN0IG5vdCBiZSBtb2RpZmllZFwiKVxuXHR9XG5cblx0Ly9Ob3RlOiB0aGUgaG9vayBpcyBwYXNzZWQgYXMgdGhlIGB0aGlzYCBhcmd1bWVudCB0byBhbGxvdyBwcm94eWluZyB0aGVcblx0Ly9hcmd1bWVudHMgd2l0aG91dCByZXF1aXJpbmcgYSBmdWxsIGFycmF5IGFsbG9jYXRpb24gdG8gZG8gc28uIEl0IGFsc29cblx0Ly90YWtlcyBhZHZhbnRhZ2Ugb2YgdGhlIGZhY3QgdGhlIGN1cnJlbnQgYHZub2RlYCBpcyB0aGUgZmlyc3QgYXJndW1lbnQgaW5cblx0Ly9hbGwgbGlmZWN5Y2xlIG1ldGhvZHMuXG5cdGZ1bmN0aW9uIGNhbGxIb29rKHZub2RlKSB7XG5cdFx0dmFyIG9yaWdpbmFsID0gdm5vZGUuc3RhdGVcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHkob3JpZ2luYWwsIGFyZ3VtZW50cylcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0Y2hlY2tTdGF0ZSh2bm9kZSwgb3JpZ2luYWwpXG5cdFx0fVxuXHR9XG5cblx0Ly8gSUUxMSAoYXQgbGVhc3QpIHRocm93cyBhbiBVbnNwZWNpZmllZEVycm9yIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgd2hlblxuXHQvLyBpbnNpZGUgYW4gaWZyYW1lLiBDYXRjaCBhbmQgc3dhbGxvdyB0aGlzIGVycm9yLCBhbmQgaGVhdnktaGFuZGlkbHkgcmV0dXJuIG51bGwuXG5cdGZ1bmN0aW9uIGFjdGl2ZUVsZW1lbnQoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gbnVsbFxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB2YWxpZGF0ZUtleXModm5vZGVzLCBpc0tleWVkKSB7XG5cdFx0Ly8gTm90ZTogdGhpcyBpcyBhICp2ZXJ5KiBwZXJmLXNlbnNpdGl2ZSBjaGVjay5cblx0XHQvLyBGdW4gZmFjdDogbWVyZ2luZyB0aGUgbG9vcCBsaWtlIHRoaXMgaXMgc29tZWhvdyBmYXN0ZXIgdGhhbiBzcGxpdHRpbmdcblx0XHQvLyBpdCwgbm90aWNlYWJseSBzby5cblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKCh2bm9kZXNbaV0gIT0gbnVsbCAmJiB2bm9kZXNbaV0ua2V5ICE9IG51bGwpICE9PSBpc0tleWVkKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJWbm9kZXMgbXVzdCBlaXRoZXIgYWx3YXlzIGhhdmUga2V5cyBvciBuZXZlciBoYXZlIGtleXMhXCIpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vY3JlYXRlXG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGVzQ2hlY2tlZChwYXJlbnQsIHZub2RlcywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGlmICh2bm9kZXMubGVuZ3RoKSB7XG5cdFx0XHR2YWxpZGF0ZUtleXModm5vZGVzLCB2bm9kZXNbMF0gIT0gbnVsbCAmJiB2bm9kZXNbMF0ua2V5ICE9IG51bGwpXG5cdFx0XHRjcmVhdGVOb2Rlc1VuY2hlY2tlZChwYXJlbnQsIHZub2RlcywgMCwgdm5vZGVzLmxlbmd0aCwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlTm9kZXNVbmNoZWNrZWQocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHRpZiAodHlwZW9mIHRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSB7fVxuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdHN3aXRjaCAodGFnKSB7XG5cdFx0XHRcdGNhc2UgXCIjXCI6IGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpOyBicmVha1xuXHRcdFx0XHRjYXNlIFwiPFwiOiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5zLCBuZXh0U2libGluZyk7IGJyZWFrXG5cdFx0XHRcdGNhc2UgXCJbXCI6IGNyZWF0ZUZyYWdtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpOyBicmVha1xuXHRcdFx0XHRkZWZhdWx0OiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZub2RlLmRvbSA9ICRkb2MuY3JlYXRlVGV4dE5vZGUodm5vZGUuY2hpbGRyZW4pXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHZub2RlLmRvbSwgbmV4dFNpYmxpbmcpXG5cdH1cblx0dmFyIHBvc3NpYmxlUGFyZW50cyA9IHtjYXB0aW9uOiBcInRhYmxlXCIsIHRoZWFkOiBcInRhYmxlXCIsIHRib2R5OiBcInRhYmxlXCIsIHRmb290OiBcInRhYmxlXCIsIHRyOiBcInRib2R5XCIsIHRoOiBcInRyXCIsIHRkOiBcInRyXCIsIGNvbGdyb3VwOiBcInRhYmxlXCIsIGNvbDogXCJjb2xncm91cFwifVxuXHRmdW5jdGlvbiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciBtYXRjaCA9IHZub2RlLmNoaWxkcmVuLm1hdGNoKC9eXFxzKj88KFxcdyspL2ltKSB8fCBbXVxuXHRcdC8vIG5vdCB1c2luZyB0aGUgcHJvcGVyIHBhcmVudCBtYWtlcyB0aGUgY2hpbGQgZWxlbWVudChzKSB2YW5pc2guXG5cdFx0Ly8gICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG5cdFx0Ly8gICAgIGRpdi5pbm5lckhUTUwgPSBcIjx0ZD5pPC90ZD48dGQ+ajwvdGQ+XCJcblx0XHQvLyAgICAgY29uc29sZS5sb2coZGl2LmlubmVySFRNTClcblx0XHQvLyAtLT4gXCJpalwiLCBubyA8dGQ+IGluIHNpZ2h0LlxuXHRcdHZhciB0ZW1wID0gJGRvYy5jcmVhdGVFbGVtZW50KHBvc3NpYmxlUGFyZW50c1ttYXRjaFsxXV0gfHwgXCJkaXZcIilcblx0XHRpZiAobnMgPT09IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIikge1xuXHRcdFx0dGVtcC5pbm5lckhUTUwgPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj5cIiArIHZub2RlLmNoaWxkcmVuICsgXCI8L3N2Zz5cIlxuXHRcdFx0dGVtcCA9IHRlbXAuZmlyc3RDaGlsZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0ZW1wLmlubmVySFRNTCA9IHZub2RlLmNoaWxkcmVuXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IHRlbXAuZmlyc3RDaGlsZFxuXHRcdHZub2RlLmRvbVNpemUgPSB0ZW1wLmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHR2YXIgY2hpbGRcblx0XHR3aGlsZSAoY2hpbGQgPSB0ZW1wLmZpcnN0Q2hpbGQpIHtcblx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdGlmICh2bm9kZS5jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0Y3JlYXRlTm9kZXNDaGVja2VkKGZyYWdtZW50LCBjaGlsZHJlbiwgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBmcmFnbWVudC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0dmFyIGF0dHJzID0gdm5vZGUuYXR0cnNcblx0XHR2YXIgaXMgPSBhdHRycyAmJiBhdHRycy5pc1xuXG5cdFx0bnMgPSBnZXROYW1lU3BhY2Uodm5vZGUpIHx8IG5zXG5cblx0XHR2YXIgZWxlbWVudCA9IG5zID9cblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZykgOlxuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnKVxuXHRcdHZub2RlLmRvbSA9IGVsZW1lbnRcblxuXHRcdGlmIChhdHRycyAhPSBudWxsKSB7XG5cdFx0XHRzZXRBdHRycyh2bm9kZSwgYXR0cnMsIG5zKVxuXHRcdH1cblxuXHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblxuXHRcdGlmICghbWF5YmVTZXRDb250ZW50RWRpdGFibGUodm5vZGUpKSB7XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS50ZXh0ICE9PSBcIlwiKSBlbGVtZW50LnRleHRDb250ZW50ID0gdm5vZGUudGV4dFxuXHRcdFx0XHRlbHNlIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0fVxuXHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdFx0Y3JlYXRlTm9kZXNDaGVja2VkKGVsZW1lbnQsIGNoaWxkcmVuLCBob29rcywgbnVsbCwgbnMpXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYgYXR0cnMgIT0gbnVsbCkgc2V0TGF0ZVNlbGVjdEF0dHJzKHZub2RlLCBhdHRycylcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpIHtcblx0XHR2YXIgc2VudGluZWxcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZy52aWV3ID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gT2JqZWN0LmNyZWF0ZSh2bm9kZS50YWcpXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnN0YXRlLnZpZXdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm5cblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHZvaWQgMFxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS50YWdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm5cblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdFx0dm5vZGUuc3RhdGUgPSAodm5vZGUudGFnLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS50YWcucHJvdG90eXBlLnZpZXcgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgdm5vZGUudGFnKHZub2RlKSA6IHZub2RlLnRhZyh2bm9kZSlcblx0XHR9XG5cdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5zdGF0ZSwgdm5vZGUsIGhvb2tzKVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUoY2FsbEhvb2suY2FsbCh2bm9kZS5zdGF0ZS52aWV3LCB2bm9kZSkpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IG51bGxcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5kb20gIT0gbnVsbCA/IHZub2RlLmluc3RhbmNlLmRvbVNpemUgOiAwXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHR9XG5cdH1cblxuXHQvL3VwZGF0ZVxuXHQvKipcblx0ICogQHBhcmFtIHtFbGVtZW50fEZyYWdtZW50fSBwYXJlbnQgLSB0aGUgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtWbm9kZVtdIHwgbnVsbH0gb2xkIC0gdGhlIGxpc3Qgb2Ygdm5vZGVzIG9mIHRoZSBsYXN0IGByZW5kZXIoKWAgY2FsbCBmb3Jcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBwYXJ0IG9mIHRoZSB0cmVlXG5cdCAqIEBwYXJhbSB7Vm5vZGVbXSB8IG51bGx9IHZub2RlcyAtIGFzIGFib3ZlLCBidXQgZm9yIHRoZSBjdXJyZW50IGByZW5kZXIoKWAgY2FsbC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbltdfSBob29rcyAtIGFuIGFjY3VtdWxhdG9yIG9mIHBvc3QtcmVuZGVyIGhvb2tzIChvbmNyZWF0ZS9vbnVwZGF0ZSlcblx0ICogQHBhcmFtIHtFbGVtZW50IHwgbnVsbH0gbmV4dFNpYmxpbmcgLSB0aGUgbmV4dCBET00gbm9kZSBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50IHRoYXQgaXMgbm90IHRoZSBsYXN0IGl0ZW0gaW4gaXRzXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50XG5cdCAqIEBwYXJhbSB7J3N2ZycgfCAnbWF0aCcgfCBTdHJpbmcgfCBudWxsfSBucykgLSB0aGUgY3VycmVudCBYTUwgbmFtZXNwYWNlLCBpZiBhbnlcblx0ICogQHJldHVybnMgdm9pZFxuXHQgKi9cblx0Ly8gVGhpcyBmdW5jdGlvbiBkaWZmcyBhbmQgcGF0Y2hlcyBsaXN0cyBvZiB2bm9kZXMsIGJvdGgga2V5ZWQgYW5kIHVua2V5ZWQuXG5cdC8vXG5cdC8vIFdlIHdpbGw6XG5cdC8vXG5cdC8vIDEuIGRlc2NyaWJlIGl0cyBnZW5lcmFsIHN0cnVjdHVyZVxuXHQvLyAyLiBmb2N1cyBvbiB0aGUgZGlmZiBhbGdvcml0aG0gb3B0aW1pemF0aW9uc1xuXHQvLyAzLiBkaXNjdXNzIERPTSBub2RlIG9wZXJhdGlvbnMuXG5cblx0Ly8gIyMgT3ZlcnZpZXc6XG5cdC8vXG5cdC8vIFRoZSB1cGRhdGVOb2RlcygpIGZ1bmN0aW9uOlxuXHQvLyAtIGRlYWxzIHdpdGggdHJpdmlhbCBjYXNlc1xuXHQvLyAtIGRldGVybWluZXMgd2hldGhlciB0aGUgbGlzdHMgYXJlIGtleWVkIG9yIHVua2V5ZWQgYmFzZWQgb24gdGhlIGZpcnN0IG5vbi1udWxsIG5vZGVcblx0Ly8gICBvZiBlYWNoIGxpc3QuXG5cdC8vIC0gZGlmZnMgdGhlbSBhbmQgcGF0Y2hlcyB0aGUgRE9NIGlmIG5lZWRlZCAodGhhdCdzIHRoZSBicnVudCBvZiB0aGUgY29kZSlcblx0Ly8gLSBtYW5hZ2VzIHRoZSBsZWZ0b3ZlcnM6IGFmdGVyIGRpZmZpbmcsIGFyZSB0aGVyZTpcblx0Ly8gICAtIG9sZCBub2RlcyBsZWZ0IHRvIHJlbW92ZT9cblx0Ly8gXHQgLSBuZXcgbm9kZXMgdG8gaW5zZXJ0P1xuXHQvLyBcdCBkZWFsIHdpdGggdGhlbSFcblx0Ly9cblx0Ly8gVGhlIGxpc3RzIGFyZSBvbmx5IGl0ZXJhdGVkIG92ZXIgb25jZSwgd2l0aCBhbiBleGNlcHRpb24gZm9yIHRoZSBub2RlcyBpbiBgb2xkYCB0aGF0XG5cdC8vIGFyZSB2aXNpdGVkIGluIHRoZSBmb3VydGggcGFydCBvZiB0aGUgZGlmZiBhbmQgaW4gdGhlIGByZW1vdmVOb2Rlc2AgbG9vcC5cblxuXHQvLyAjIyBEaWZmaW5nXG5cdC8vXG5cdC8vIFJlYWRpbmcgaHR0cHM6Ly9naXRodWIuY29tL2xvY2Fsdm9pZC9pdmkvYmxvYi9kZGMwOWQwNmFiYWVmNDUyNDhlNjEzM2Y3MDQwZDAwZDNjNmJlODUzL3BhY2thZ2VzL2l2aS9zcmMvdmRvbS9pbXBsZW1lbnRhdGlvbi50cyNMNjE3LUw4Mzdcblx0Ly8gbWF5IGJlIGdvb2QgZm9yIGNvbnRleHQgb24gbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLWJhc2VkIGxvZ2ljIGZvciBtb3Zpbmcgbm9kZXMuXG5cdC8vXG5cdC8vIEluIG9yZGVyIHRvIGRpZmYga2V5ZWQgbGlzdHMsIG9uZSBoYXMgdG9cblx0Ly9cblx0Ly8gMSkgbWF0Y2ggbm9kZXMgaW4gYm90aCBsaXN0cywgcGVyIGtleSwgYW5kIHVwZGF0ZSB0aGVtIGFjY29yZGluZ2x5XG5cdC8vIDIpIGNyZWF0ZSB0aGUgbm9kZXMgcHJlc2VudCBpbiB0aGUgbmV3IGxpc3QsIGJ1dCBhYnNlbnQgaW4gdGhlIG9sZCBvbmVcblx0Ly8gMykgcmVtb3ZlIHRoZSBub2RlcyBwcmVzZW50IGluIHRoZSBvbGQgbGlzdCwgYnV0IGFic2VudCBpbiB0aGUgbmV3IG9uZVxuXHQvLyA0KSBmaWd1cmUgb3V0IHdoYXQgbm9kZXMgaW4gMSkgdG8gbW92ZSBpbiBvcmRlciB0byBtaW5pbWl6ZSB0aGUgRE9NIG9wZXJhdGlvbnMuXG5cdC8vXG5cdC8vIFRvIGFjaGlldmUgMSkgb25lIGNhbiBjcmVhdGUgYSBkaWN0aW9uYXJ5IG9mIGtleXMgPT4gaW5kZXggKGZvciB0aGUgb2xkIGxpc3QpLCB0aGVuIGl0ZXJhdGVcblx0Ly8gb3ZlciB0aGUgbmV3IGxpc3QgYW5kIGZvciBlYWNoIG5ldyB2bm9kZSwgZmluZCB0aGUgY29ycmVzcG9uZGluZyB2bm9kZSBpbiB0aGUgb2xkIGxpc3QgdXNpbmdcblx0Ly8gdGhlIG1hcC5cblx0Ly8gMikgaXMgYWNoaWV2ZWQgaW4gdGhlIHNhbWUgc3RlcDogaWYgYSBuZXcgbm9kZSBoYXMgbm8gY29ycmVzcG9uZGluZyBlbnRyeSBpbiB0aGUgbWFwLCBpdCBpcyBuZXdcblx0Ly8gYW5kIG11c3QgYmUgY3JlYXRlZC5cblx0Ly8gRm9yIHRoZSByZW1vdmFscywgd2UgYWN0dWFsbHkgcmVtb3ZlIHRoZSBub2RlcyB0aGF0IGhhdmUgYmVlbiB1cGRhdGVkIGZyb20gdGhlIG9sZCBsaXN0LlxuXHQvLyBUaGUgbm9kZXMgdGhhdCByZW1haW4gaW4gdGhhdCBsaXN0IGFmdGVyIDEpIGFuZCAyKSBoYXZlIGJlZW4gcGVyZm9ybWVkIGNhbiBiZSBzYWZlbHkgcmVtb3ZlZC5cblx0Ly8gVGhlIGZvdXJ0aCBzdGVwIGlzIGEgYml0IG1vcmUgY29tcGxleCBhbmQgcmVsaWVzIG9uIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UgKExJUylcblx0Ly8gYWxnb3JpdGhtLlxuXHQvL1xuXHQvLyB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIGlzIHRoZSBsaXN0IG9mIG5vZGVzIHRoYXQgY2FuIHJlbWFpbiBpbiBwbGFjZS4gSW1hZ2luZSBnb2luZ1xuXHQvLyBmcm9tIGAxLDIsMyw0LDVgIHRvIGA0LDUsMSwyLDNgIHdoZXJlIHRoZSBudW1iZXJzIGFyZSBub3QgbmVjZXNzYXJpbHkgdGhlIGtleXMsIGJ1dCB0aGUgaW5kaWNlc1xuXHQvLyBjb3JyZXNwb25kaW5nIHRvIHRoZSBrZXllZCBub2RlcyBpbiB0aGUgb2xkIGxpc3QgKGtleWVkIG5vZGVzIGBlLGQsYyxiLGFgID0+IGBiLGEsZSxkLGNgIHdvdWxkXG5cdC8vICBtYXRjaCB0aGUgYWJvdmUgbGlzdHMsIGZvciBleGFtcGxlKS5cblx0Ly9cblx0Ly8gSW4gdGhlcmUgYXJlIHR3byBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlczogYDQsNWAgYW5kIGAxLDIsM2AsIHRoZSBsYXR0ZXIgYmVpbmcgdGhlIGxvbmdlc3QuIFdlXG5cdC8vIGNhbiB1cGRhdGUgdGhvc2Ugbm9kZXMgd2l0aG91dCBtb3ZpbmcgdGhlbSwgYW5kIG9ubHkgY2FsbCBgaW5zZXJ0Tm9kZWAgb24gYDRgIGFuZCBgNWAuXG5cdC8vXG5cdC8vIEBsb2NhbHZvaWQgYWRhcHRlZCB0aGUgYWxnbyB0byBhbHNvIHN1cHBvcnQgbm9kZSBkZWxldGlvbnMgYW5kIGluc2VydGlvbnMgKHRoZSBgbGlzYCBpcyBhY3R1YWxseVxuXHQvLyB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlICpvZiBvbGQgbm9kZXMgc3RpbGwgcHJlc2VudCBpbiB0aGUgbmV3IGxpc3QqKS5cblx0Ly9cblx0Ly8gSXQgaXMgYSBnZW5lcmFsIGFsZ29yaXRobSB0aGF0IGlzIGZpcmVwcm9vZiBpbiBhbGwgY2lyY3Vtc3RhbmNlcywgYnV0IGl0IHJlcXVpcmVzIHRoZSBhbGxvY2F0aW9uXG5cdC8vIGFuZCB0aGUgY29uc3RydWN0aW9uIG9mIGEgYGtleSA9PiBvbGRJbmRleGAgbWFwLCBhbmQgdGhyZWUgYXJyYXlzIChvbmUgd2l0aCBgbmV3SW5kZXggPT4gb2xkSW5kZXhgLFxuXHQvLyB0aGUgYExJU2AgYW5kIGEgdGVtcG9yYXJ5IG9uZSB0byBjcmVhdGUgdGhlIExJUykuXG5cdC8vXG5cdC8vIFNvIHdlIGNoZWF0IHdoZXJlIHdlIGNhbjogaWYgdGhlIHRhaWxzIG9mIHRoZSBsaXN0cyBhcmUgaWRlbnRpY2FsLCB0aGV5IGFyZSBndWFyYW50ZWVkIHRvIGJlIHBhcnQgb2Zcblx0Ly8gdGhlIExJUyBhbmQgY2FuIGJlIHVwZGF0ZWQgd2l0aG91dCBtb3ZpbmcgdGhlbS5cblx0Ly9cblx0Ly8gSWYgdHdvIG5vZGVzIGFyZSBzd2FwcGVkLCB0aGV5IGFyZSBndWFyYW50ZWVkIG5vdCB0byBiZSBwYXJ0IG9mIHRoZSBMSVMsIGFuZCBtdXN0IGJlIG1vdmVkICh3aXRoXG5cdC8vIHRoZSBleGNlcHRpb24gb2YgdGhlIGxhc3Qgbm9kZSBpZiB0aGUgbGlzdCBpcyBmdWxseSByZXZlcnNlZCkuXG5cdC8vXG5cdC8vICMjIEZpbmRpbmcgdGhlIG5leHQgc2libGluZy5cblx0Ly9cblx0Ly8gYHVwZGF0ZU5vZGUoKWAgYW5kIGBjcmVhdGVOb2RlKClgIGV4cGVjdCBhIG5leHRTaWJsaW5nIHBhcmFtZXRlciB0byBwZXJmb3JtIERPTSBvcGVyYXRpb25zLlxuXHQvLyBXaGVuIHRoZSBsaXN0IGlzIGJlaW5nIHRyYXZlcnNlZCB0b3AtZG93biwgYXQgYW55IGluZGV4LCB0aGUgRE9NIG5vZGVzIHVwIHRvIHRoZSBwcmV2aW91c1xuXHQvLyB2bm9kZSByZWZsZWN0IHRoZSBjb250ZW50IG9mIHRoZSBuZXcgbGlzdCwgd2hlcmVhcyB0aGUgcmVzdCBvZiB0aGUgRE9NIG5vZGVzIHJlZmxlY3QgdGhlIG9sZFxuXHQvLyBsaXN0LiBUaGUgbmV4dCBzaWJsaW5nIG11c3QgYmUgbG9va2VkIGZvciBpbiB0aGUgb2xkIGxpc3QgdXNpbmcgYGdldE5leHRTaWJsaW5nKC4uLiBvbGRTdGFydCArIDEgLi4uKWAuXG5cdC8vXG5cdC8vIEluIHRoZSBvdGhlciBzY2VuYXJpb3MgKHN3YXBzLCB1cHdhcmRzIHRyYXZlcnNhbCwgbWFwLWJhc2VkIGRpZmYpLFxuXHQvLyB0aGUgbmV3IHZub2RlcyBsaXN0IGlzIHRyYXZlcnNlZCB1cHdhcmRzLiBUaGUgRE9NIG5vZGVzIGF0IHRoZSBib3R0b20gb2YgdGhlIGxpc3QgcmVmbGVjdCB0aGVcblx0Ly8gYm90dG9tIHBhcnQgb2YgdGhlIG5ldyB2bm9kZXMgbGlzdCwgYW5kIHdlIGNhbiB1c2UgdGhlIGB2LmRvbWAgIHZhbHVlIG9mIHRoZSBwcmV2aW91cyBub2RlXG5cdC8vIGFzIHRoZSBuZXh0IHNpYmxpbmcgKGNhY2hlZCBpbiB0aGUgYG5leHRTaWJsaW5nYCB2YXJpYWJsZSkuXG5cblxuXHQvLyAjIyBET00gbm9kZSBtb3Zlc1xuXHQvL1xuXHQvLyBJbiBtb3N0IHNjZW5hcmlvcyBgdXBkYXRlTm9kZSgpYCBhbmQgYGNyZWF0ZU5vZGUoKWAgcGVyZm9ybSB0aGUgRE9NIG9wZXJhdGlvbnMuIEhvd2V2ZXIsXG5cdC8vIHRoaXMgaXMgbm90IHRoZSBjYXNlIGlmIHRoZSBub2RlIG1vdmVkIChzZWNvbmQgYW5kIGZvdXJ0aCBwYXJ0IG9mIHRoZSBkaWZmIGFsZ28pLiBXZSBtb3ZlXG5cdC8vIHRoZSBvbGQgRE9NIG5vZGVzIGJlZm9yZSB1cGRhdGVOb2RlIHJ1bnMgYmVjYXVzZSBpdCBlbmFibGVzIHVzIHRvIHVzZSB0aGUgY2FjaGVkIGBuZXh0U2libGluZ2Bcblx0Ly8gdmFyaWFibGUgcmF0aGVyIHRoYW4gZmV0Y2hpbmcgaXQgdXNpbmcgYGdldE5leHRTaWJsaW5nKClgLlxuXHQvL1xuXHQvLyBUaGUgZm91cnRoIHBhcnQgb2YgdGhlIGRpZmYgY3VycmVudGx5IGluc2VydHMgbm9kZXMgdW5jb25kaXRpb25hbGx5LCBsZWFkaW5nIHRvIGlzc3Vlc1xuXHQvLyBsaWtlICMxNzkxIGFuZCAjMTk5OS4gV2UgbmVlZCB0byBiZSBzbWFydGVyIGFib3V0IHRob3NlIHNpdHVhdGlvbnMgd2hlcmUgYWRqYXNjZW50IG9sZFxuXHQvLyBub2RlcyByZW1haW4gdG9nZXRoZXIgaW4gdGhlIG5ldyBsaXN0IGluIGEgd2F5IHRoYXQgaXNuJ3QgY292ZXJlZCBieSBwYXJ0cyBvbmUgYW5kXG5cdC8vIHRocmVlIG9mIHRoZSBkaWZmIGFsZ28uXG5cblx0ZnVuY3Rpb24gdXBkYXRlTm9kZXMocGFyZW50LCBvbGQsIHZub2RlcywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGlmIChvbGQgPT09IHZub2RlcyB8fCBvbGQgPT0gbnVsbCAmJiB2bm9kZXMgPT0gbnVsbCkgcmV0dXJuXG5cdFx0ZWxzZSBpZiAob2xkID09IG51bGwgfHwgb2xkLmxlbmd0aCA9PT0gMCkgY3JlYXRlTm9kZXNDaGVja2VkKHBhcmVudCwgdm5vZGVzLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdGVsc2UgaWYgKHZub2RlcyA9PSBudWxsIHx8IHZub2Rlcy5sZW5ndGggPT09IDApIHJlbW92ZU5vZGVzKG9sZCwgMCwgb2xkLmxlbmd0aClcblx0XHRlbHNlIHtcblx0XHRcdHZhciBpc09sZEtleWVkID0gb2xkWzBdICE9IG51bGwgJiYgb2xkWzBdLmtleSAhPSBudWxsXG5cdFx0XHR2YXIgaXNLZXllZCA9IHZub2Rlc1swXSAhPSBudWxsICYmIHZub2Rlc1swXS5rZXkgIT0gbnVsbFxuXHRcdFx0dmFyIHN0YXJ0ID0gMCwgb2xkU3RhcnQgPSAwXG5cdFx0XHR2YWxpZGF0ZUtleXModm5vZGVzLCBpc0tleWVkKVxuXHRcdFx0aWYgKCFpc09sZEtleWVkKSB3aGlsZSAob2xkU3RhcnQgPCBvbGQubGVuZ3RoICYmIG9sZFtvbGRTdGFydF0gPT0gbnVsbCkgb2xkU3RhcnQrK1xuXHRcdFx0aWYgKCFpc0tleWVkKSB3aGlsZSAoc3RhcnQgPCB2bm9kZXMubGVuZ3RoICYmIHZub2Rlc1tzdGFydF0gPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0aWYgKGlzS2V5ZWQgPT09IG51bGwgJiYgaXNPbGRLZXllZCA9PSBudWxsKSByZXR1cm4gLy8gYm90aCBsaXN0cyBhcmUgZnVsbCBvZiBudWxsc1xuXHRcdFx0aWYgKGlzT2xkS2V5ZWQgIT09IGlzS2V5ZWQpIHtcblx0XHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkLmxlbmd0aClcblx0XHRcdFx0Y3JlYXRlTm9kZXNVbmNoZWNrZWQocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCB2bm9kZXMubGVuZ3RoLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0fSBlbHNlIGlmICghaXNLZXllZCkge1xuXHRcdFx0XHQvLyBEb24ndCBpbmRleCBwYXN0IHRoZSBlbmQgb2YgZWl0aGVyIGxpc3QgKGNhdXNlcyBkZW9wdHMpLlxuXHRcdFx0XHR2YXIgY29tbW9uTGVuZ3RoID0gb2xkLmxlbmd0aCA8IHZub2Rlcy5sZW5ndGggPyBvbGQubGVuZ3RoIDogdm5vZGVzLmxlbmd0aFxuXHRcdFx0XHQvLyBSZXdpbmQgaWYgbmVjZXNzYXJ5IHRvIHRoZSBmaXJzdCBub24tbnVsbCBpbmRleCBvbiBlaXRoZXIgc2lkZS5cblx0XHRcdFx0Ly8gV2UgY291bGQgYWx0ZXJuYXRpdmVseSBlaXRoZXIgZXhwbGljaXRseSBjcmVhdGUgb3IgcmVtb3ZlIG5vZGVzIHdoZW4gYHN0YXJ0ICE9PSBvbGRTdGFydGBcblx0XHRcdFx0Ly8gYnV0IHRoYXQgd291bGQgYmUgb3B0aW1pemluZyBmb3Igc3BhcnNlIGxpc3RzIHdoaWNoIGFyZSBtb3JlIHJhcmUgdGhhbiBkZW5zZSBvbmVzLlxuXHRcdFx0XHRzdGFydCA9IHN0YXJ0IDwgb2xkU3RhcnQgPyBzdGFydCA6IG9sZFN0YXJ0XG5cdFx0XHRcdGZvciAoOyBzdGFydCA8IGNvbW1vbkxlbmd0aDsgc3RhcnQrKykge1xuXHRcdFx0XHRcdG8gPSBvbGRbc3RhcnRdXG5cdFx0XHRcdFx0diA9IHZub2Rlc1tzdGFydF1cblx0XHRcdFx0XHRpZiAobyA9PT0gdiB8fCBvID09IG51bGwgJiYgdiA9PSBudWxsKSBjb250aW51ZVxuXHRcdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHYsIGhvb2tzLCBucywgZ2V0TmV4dFNpYmxpbmcob2xkLCBzdGFydCArIDEsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHJlbW92ZU5vZGUobylcblx0XHRcdFx0XHRlbHNlIHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBzdGFydCArIDEsIG5leHRTaWJsaW5nKSwgbnMpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9sZC5sZW5ndGggPiBjb21tb25MZW5ndGgpIHJlbW92ZU5vZGVzKG9sZCwgc3RhcnQsIG9sZC5sZW5ndGgpXG5cdFx0XHRcdGlmICh2bm9kZXMubGVuZ3RoID4gY29tbW9uTGVuZ3RoKSBjcmVhdGVOb2Rlc1VuY2hlY2tlZChwYXJlbnQsIHZub2Rlcywgc3RhcnQsIHZub2Rlcy5sZW5ndGgsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBrZXllZCBkaWZmXG5cdFx0XHRcdHZhciBvbGRFbmQgPSBvbGQubGVuZ3RoIC0gMSwgZW5kID0gdm5vZGVzLmxlbmd0aCAtIDEsIG1hcCwgbywgdiwgb2UsIHZlLCB0b3BTaWJsaW5nXG5cblx0XHRcdFx0Ly8gYm90dG9tLXVwXG5cdFx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdFx0b2UgPSBvbGRbb2xkRW5kXVxuXHRcdFx0XHRcdHZlID0gdm5vZGVzW2VuZF1cblx0XHRcdFx0XHRpZiAob2Uua2V5ICE9PSB2ZS5rZXkpIGJyZWFrXG5cdFx0XHRcdFx0aWYgKG9lICE9PSB2ZSkgdXBkYXRlTm9kZShwYXJlbnQsIG9lLCB2ZSwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRcdFx0XHRpZiAodmUuZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gdmUuZG9tXG5cdFx0XHRcdFx0b2xkRW5kLS0sIGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdG9wLWRvd25cblx0XHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0XHRvID0gb2xkW29sZFN0YXJ0XVxuXHRcdFx0XHRcdHYgPSB2bm9kZXNbc3RhcnRdXG5cdFx0XHRcdFx0aWYgKG8ua2V5ICE9PSB2LmtleSkgYnJlYWtcblx0XHRcdFx0XHRvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdFx0aWYgKG8gIT09IHYpIHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRTdGFydCwgbmV4dFNpYmxpbmcpLCBucylcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBzd2FwcyBhbmQgbGlzdCByZXZlcnNhbHNcblx0XHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0XHRpZiAoc3RhcnQgPT09IGVuZCkgYnJlYWtcblx0XHRcdFx0XHRpZiAoby5rZXkgIT09IHZlLmtleSB8fCBvZS5rZXkgIT09IHYua2V5KSBicmVha1xuXHRcdFx0XHRcdHRvcFNpYmxpbmcgPSBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZylcblx0XHRcdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvZSksIHRvcFNpYmxpbmcpXG5cdFx0XHRcdFx0aWYgKG9lICE9PSB2KSB1cGRhdGVOb2RlKHBhcmVudCwgb2UsIHYsIGhvb2tzLCB0b3BTaWJsaW5nLCBucylcblx0XHRcdFx0XHRpZiAoKytzdGFydCA8PSAtLWVuZCkgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdGlmIChvICE9PSB2ZSkgdXBkYXRlTm9kZShwYXJlbnQsIG8sIHZlLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0XHRcdGlmICh2ZS5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSB2ZS5kb21cblx0XHRcdFx0XHRvbGRTdGFydCsrOyBvbGRFbmQtLVxuXHRcdFx0XHRcdG9lID0gb2xkW29sZEVuZF1cblx0XHRcdFx0XHR2ZSA9IHZub2Rlc1tlbmRdXG5cdFx0XHRcdFx0byA9IG9sZFtvbGRTdGFydF1cblx0XHRcdFx0XHR2ID0gdm5vZGVzW3N0YXJ0XVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGJvdHRvbSB1cCBvbmNlIGFnYWluXG5cdFx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdFx0aWYgKG9lLmtleSAhPT0gdmUua2V5KSBicmVha1xuXHRcdFx0XHRcdGlmIChvZSAhPT0gdmUpIHVwZGF0ZU5vZGUocGFyZW50LCBvZSwgdmUsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0XHRcdFx0aWYgKHZlLmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IHZlLmRvbVxuXHRcdFx0XHRcdG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHRcdG9lID0gb2xkW29sZEVuZF1cblx0XHRcdFx0XHR2ZSA9IHZub2Rlc1tlbmRdXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN0YXJ0ID4gZW5kKSByZW1vdmVOb2RlcyhvbGQsIG9sZFN0YXJ0LCBvbGRFbmQgKyAxKVxuXHRcdFx0XHRlbHNlIGlmIChvbGRTdGFydCA+IG9sZEVuZCkgY3JlYXRlTm9kZXNVbmNoZWNrZWQocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBpbnNwaXJlZCBieSBpdmkgaHR0cHM6Ly9naXRodWIuY29tL2l2aWpzL2l2aS8gYnkgQm9yaXMgS2F1bFxuXHRcdFx0XHRcdHZhciBvcmlnaW5hbE5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcsIHZub2Rlc0xlbmd0aCA9IGVuZCAtIHN0YXJ0ICsgMSwgb2xkSW5kaWNlcyA9IG5ldyBBcnJheSh2bm9kZXNMZW5ndGgpLCBsaT0wLCBpPTAsIHBvcyA9IDIxNDc0ODM2NDcsIG1hdGNoZWQgPSAwLCBtYXAsIGxpc0luZGljZXNcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdm5vZGVzTGVuZ3RoOyBpKyspIG9sZEluZGljZXNbaV0gPSAtMVxuXHRcdFx0XHRcdGZvciAoaSA9IGVuZDsgaSA+PSBzdGFydDsgaS0tKSB7XG5cdFx0XHRcdFx0XHRpZiAobWFwID09IG51bGwpIG1hcCA9IGdldEtleU1hcChvbGQsIG9sZFN0YXJ0LCBvbGRFbmQgKyAxKVxuXHRcdFx0XHRcdFx0dmUgPSB2bm9kZXNbaV1cblx0XHRcdFx0XHRcdHZhciBvbGRJbmRleCA9IG1hcFt2ZS5rZXldXG5cdFx0XHRcdFx0XHRpZiAob2xkSW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRwb3MgPSAob2xkSW5kZXggPCBwb3MpID8gb2xkSW5kZXggOiAtMSAvLyBiZWNvbWVzIC0xIGlmIG5vZGVzIHdlcmUgcmUtb3JkZXJlZFxuXHRcdFx0XHRcdFx0XHRvbGRJbmRpY2VzW2ktc3RhcnRdID0gb2xkSW5kZXhcblx0XHRcdFx0XHRcdFx0b2UgPSBvbGRbb2xkSW5kZXhdXG5cdFx0XHRcdFx0XHRcdG9sZFtvbGRJbmRleF0gPSBudWxsXG5cdFx0XHRcdFx0XHRcdGlmIChvZSAhPT0gdmUpIHVwZGF0ZU5vZGUocGFyZW50LCBvZSwgdmUsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0XHRcdFx0XHRcdGlmICh2ZS5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSB2ZS5kb21cblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCsrXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5leHRTaWJsaW5nID0gb3JpZ2luYWxOZXh0U2libGluZ1xuXHRcdFx0XHRcdGlmIChtYXRjaGVkICE9PSBvbGRFbmQgLSBvbGRTdGFydCArIDEpIHJlbW92ZU5vZGVzKG9sZCwgb2xkU3RhcnQsIG9sZEVuZCArIDEpXG5cdFx0XHRcdFx0aWYgKG1hdGNoZWQgPT09IDApIGNyZWF0ZU5vZGVzVW5jaGVja2VkKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kICsgMSwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChwb3MgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHRoZSBpbmRpY2VzIG9mIHRoZSBpbmRpY2VzIG9mIHRoZSBpdGVtcyB0aGF0IGFyZSBwYXJ0IG9mIHRoZVxuXHRcdFx0XHRcdFx0XHQvLyBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UgaW4gdGhlIG9sZEluZGljZXMgbGlzdFxuXHRcdFx0XHRcdFx0XHRsaXNJbmRpY2VzID0gbWFrZUxpc0luZGljZXMob2xkSW5kaWNlcylcblx0XHRcdFx0XHRcdFx0bGkgPSBsaXNJbmRpY2VzLmxlbmd0aCAtIDFcblx0XHRcdFx0XHRcdFx0Zm9yIChpID0gZW5kOyBpID49IHN0YXJ0OyBpLS0pIHtcblx0XHRcdFx0XHRcdFx0XHR2ID0gdm5vZGVzW2ldXG5cdFx0XHRcdFx0XHRcdFx0aWYgKG9sZEluZGljZXNbaS1zdGFydF0gPT09IC0xKSBjcmVhdGVOb2RlKHBhcmVudCwgdiwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChsaXNJbmRpY2VzW2xpXSA9PT0gaSAtIHN0YXJ0KSBsaS0tXG5cdFx0XHRcdFx0XHRcdFx0XHRlbHNlIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KHYpLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHYuZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gdm5vZGVzW2ldLmRvbVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSBlbmQ7IGkgPj0gc3RhcnQ7IGktLSkge1xuXHRcdFx0XHRcdFx0XHRcdHYgPSB2bm9kZXNbaV1cblx0XHRcdFx0XHRcdFx0XHRpZiAob2xkSW5kaWNlc1tpLXN0YXJ0XSA9PT0gLTEpIGNyZWF0ZU5vZGUocGFyZW50LCB2LCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0XHRcdGlmICh2LmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IHZub2Rlc1tpXS5kb21cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHZhciBvbGRUYWcgPSBvbGQudGFnLCB0YWcgPSB2bm9kZS50YWdcblx0XHRpZiAob2xkVGFnID09PSB0YWcpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gb2xkLnN0YXRlXG5cdFx0XHR2bm9kZS5ldmVudHMgPSBvbGQuZXZlbnRzXG5cdFx0XHRpZiAoc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpKSByZXR1cm5cblx0XHRcdGlmICh0eXBlb2Ygb2xkVGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRcdH1cblx0XHRcdFx0c3dpdGNoIChvbGRUYWcpIHtcblx0XHRcdFx0XHRjYXNlIFwiI1wiOiB1cGRhdGVUZXh0KG9sZCwgdm5vZGUpOyBicmVha1xuXHRcdFx0XHRcdGNhc2UgXCI8XCI6IHVwZGF0ZUhUTUwocGFyZW50LCBvbGQsIHZub2RlLCBucywgbmV4dFNpYmxpbmcpOyBicmVha1xuXHRcdFx0XHRcdGNhc2UgXCJbXCI6IHVwZGF0ZUZyYWdtZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCBob29rcywgbnMpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZW1vdmVOb2RlKG9sZClcblx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlVGV4dChvbGQsIHZub2RlKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbi50b1N0cmluZygpICE9PSB2bm9kZS5jaGlsZHJlbi50b1N0cmluZygpKSB7XG5cdFx0XHRvbGQuZG9tLm5vZGVWYWx1ZSA9IHZub2RlLmNoaWxkcmVuXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVIVE1MKHBhcmVudCwgb2xkLCB2bm9kZSwgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHRcdGVsc2Ugdm5vZGUuZG9tID0gb2xkLmRvbSwgdm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0dXBkYXRlTm9kZXMocGFyZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgaG9va3MsIG5zKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0bnMgPSBnZXROYW1lU3BhY2Uodm5vZGUpIHx8IG5zXG5cblx0XHRpZiAodm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpIHtcblx0XHRcdGlmICh2bm9kZS5hdHRycyA9PSBudWxsKSB2bm9kZS5hdHRycyA9IHt9XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLmF0dHJzLnZhbHVlID0gdm5vZGUudGV4dCAvL0ZJWE1FIGhhbmRsZSBtdWx0aXBsZSBjaGlsZHJlblxuXHRcdFx0XHR2bm9kZS50ZXh0ID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQuYXR0cnMsIHZub2RlLmF0dHJzLCBucylcblx0XHRpZiAoIW1heWJlU2V0Q29udGVudEVkaXRhYmxlKHZub2RlKSkge1xuXHRcdFx0aWYgKG9sZC50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT09IFwiXCIpIHtcblx0XHRcdFx0aWYgKG9sZC50ZXh0LnRvU3RyaW5nKCkgIT09IHZub2RlLnRleHQudG9TdHJpbmcoKSkgb2xkLmRvbS5maXJzdENoaWxkLm5vZGVWYWx1ZSA9IHZub2RlLnRleHRcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAob2xkLnRleHQgIT0gbnVsbCkgb2xkLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb2xkLnRleHQsIHVuZGVmaW5lZCwgb2xkLmRvbS5maXJzdENoaWxkKV1cblx0XHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkgdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHRcdHVwZGF0ZU5vZGVzKGVsZW1lbnQsIG9sZC5jaGlsZHJlbiwgdm5vZGUuY2hpbGRyZW4sIGhvb2tzLCBudWxsLCBucylcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKGNhbGxIb29rLmNhbGwodm5vZGUuc3RhdGUudmlldywgdm5vZGUpKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0dXBkYXRlTGlmZWN5Y2xlKHZub2RlLnN0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAob2xkLmluc3RhbmNlID09IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZC5pbnN0YW5jZSwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5pbnN0YW5jZS5kb21TaXplXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9sZC5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRyZW1vdmVOb2RlKG9sZC5pbnN0YW5jZSlcblx0XHRcdHZub2RlLmRvbSA9IHVuZGVmaW5lZFxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZ2V0S2V5TWFwKHZub2Rlcywgc3RhcnQsIGVuZCkge1xuXHRcdHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cdFx0Zm9yICg7IHN0YXJ0IDwgZW5kOyBzdGFydCsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbc3RhcnRdXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIga2V5ID0gdm5vZGUua2V5XG5cdFx0XHRcdGlmIChrZXkgIT0gbnVsbCkgbWFwW2tleV0gPSBzdGFydFxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWFwXG5cdH1cblx0Ly8gTGlmdGVkIGZyb20gaXZpIGh0dHBzOi8vZ2l0aHViLmNvbS9pdmlqcy9pdmkvXG5cdC8vIHRha2VzIGEgbGlzdCBvZiB1bmlxdWUgbnVtYmVycyAoLTEgaXMgc3BlY2lhbCBhbmQgY2FuXG5cdC8vIG9jY3VyIG11bHRpcGxlIHRpbWVzKSBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBpbmRpY2VzXG5cdC8vIG9mIHRoZSBpdGVtcyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBsb25nZXN0IGluY3JlYXNpbmdcblx0Ly8gc3Vic2VxdWVjZVxuXHR2YXIgbGlzVGVtcCA9IFtdXG5cdGZ1bmN0aW9uIG1ha2VMaXNJbmRpY2VzKGEpIHtcblx0XHR2YXIgcmVzdWx0ID0gWzBdXG5cdFx0dmFyIHUgPSAwLCB2ID0gMCwgaSA9IDBcblx0XHR2YXIgaWwgPSBsaXNUZW1wLmxlbmd0aCA9IGEubGVuZ3RoXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbDsgaSsrKSBsaXNUZW1wW2ldID0gYVtpXVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaWw7ICsraSkge1xuXHRcdFx0aWYgKGFbaV0gPT09IC0xKSBjb250aW51ZVxuXHRcdFx0dmFyIGogPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdXG5cdFx0XHRpZiAoYVtqXSA8IGFbaV0pIHtcblx0XHRcdFx0bGlzVGVtcFtpXSA9IGpcblx0XHRcdFx0cmVzdWx0LnB1c2goaSlcblx0XHRcdFx0Y29udGludWVcblx0XHRcdH1cblx0XHRcdHUgPSAwXG5cdFx0XHR2ID0gcmVzdWx0Lmxlbmd0aCAtIDFcblx0XHRcdHdoaWxlICh1IDwgdikge1xuXHRcdFx0XHQvLyBGYXN0IGludGVnZXIgYXZlcmFnZSB3aXRob3V0IG92ZXJmbG93LlxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuXHRcdFx0XHR2YXIgYyA9ICh1ID4+PiAxKSArICh2ID4+PiAxKSArICh1ICYgdiAmIDEpXG5cdFx0XHRcdGlmIChhW3Jlc3VsdFtjXV0gPCBhW2ldKSB7XG5cdFx0XHRcdFx0dSA9IGMgKyAxXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0diA9IGNcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFbaV0gPCBhW3Jlc3VsdFt1XV0pIHtcblx0XHRcdFx0aWYgKHUgPiAwKSBsaXNUZW1wW2ldID0gcmVzdWx0W3UgLSAxXVxuXHRcdFx0XHRyZXN1bHRbdV0gPSBpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHUgPSByZXN1bHQubGVuZ3RoXG5cdFx0diA9IHJlc3VsdFt1IC0gMV1cblx0XHR3aGlsZSAodS0tID4gMCkge1xuXHRcdFx0cmVzdWx0W3VdID0gdlxuXHRcdFx0diA9IGxpc1RlbXBbdl1cblx0XHR9XG5cdFx0bGlzVGVtcC5sZW5ndGggPSAwXG5cdFx0cmV0dXJuIHJlc3VsdFxuXHR9XG5cblx0ZnVuY3Rpb24gdG9GcmFnbWVudCh2bm9kZSkge1xuXHRcdHZhciBjb3VudCA9IHZub2RlLmRvbVNpemVcblx0XHRpZiAoY291bnQgIT0gbnVsbCB8fCB2bm9kZS5kb20gPT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRcdGlmIChjb3VudCA+IDApIHtcblx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHR3aGlsZSAoLS1jb3VudCkgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRmcmFnbWVudC5pbnNlcnRCZWZvcmUoZG9tLCBmcmFnbWVudC5maXJzdENoaWxkKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyYWdtZW50XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKHZub2RlcywgaSwgbmV4dFNpYmxpbmcpIHtcblx0XHRmb3IgKDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIHZub2Rlc1tpXS5kb20gIT0gbnVsbCkgcmV0dXJuIHZub2Rlc1tpXS5kb21cblx0XHR9XG5cdFx0cmV0dXJuIG5leHRTaWJsaW5nXG5cdH1cblxuXHRmdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudCwgZG9tLCBuZXh0U2libGluZykge1xuXHRcdGlmIChuZXh0U2libGluZyAhPSBudWxsKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9tKVxuXHR9XG5cblx0ZnVuY3Rpb24gbWF5YmVTZXRDb250ZW50RWRpdGFibGUodm5vZGUpIHtcblx0XHRpZiAodm5vZGUuYXR0cnMgPT0gbnVsbCB8fCAoXG5cdFx0XHR2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgPT0gbnVsbCAmJiAvLyBhdHRyaWJ1dGVcblx0XHRcdHZub2RlLmF0dHJzLmNvbnRlbnRFZGl0YWJsZSA9PSBudWxsIC8vIHByb3BlcnR5XG5cdFx0KSkgcmV0dXJuXG5cdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0udGFnID09PSBcIjxcIikge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjaGlsZHJlblswXS5jaGlsZHJlblxuXHRcdFx0aWYgKHZub2RlLmRvbS5pbm5lckhUTUwgIT09IGNvbnRlbnQpIHZub2RlLmRvbS5pbm5lckhUTUwgPSBjb250ZW50XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHZub2RlLnRleHQgIT0gbnVsbCB8fCBjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgbm9kZSBvZiBhIGNvbnRlbnRlZGl0YWJsZSBtdXN0IGJlIHRydXN0ZWRcIilcblx0fVxuXG5cdC8vcmVtb3ZlXG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVzKHZub2Rlcywgc3RhcnQsIGVuZCkge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSByZW1vdmVOb2RlKHZub2RlKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlKHZub2RlKSB7XG5cdFx0dmFyIGV4cGVjdGVkID0gMSwgY2FsbGVkID0gMFxuXHRcdHZhciBvcmlnaW5hbCA9IHZub2RlLnN0YXRlXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLnN0YXRlLm9uYmVmb3JlcmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhciByZXN1bHQgPSBjYWxsSG9vay5jYWxsKHZub2RlLnN0YXRlLm9uYmVmb3JlcmVtb3ZlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodm5vZGUuYXR0cnMgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhciByZXN1bHQgPSBjYWxsSG9vay5jYWxsKHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb250aW51YXRpb24oKVxuXHRcdGZ1bmN0aW9uIGNvbnRpbnVhdGlvbigpIHtcblx0XHRcdGlmICgrK2NhbGxlZCA9PT0gZXhwZWN0ZWQpIHtcblx0XHRcdFx0Y2hlY2tTdGF0ZSh2bm9kZSwgb3JpZ2luYWwpXG5cdFx0XHRcdG9ucmVtb3ZlKHZub2RlKVxuXHRcdFx0XHRpZiAodm5vZGUuZG9tKSB7XG5cdFx0XHRcdFx0dmFyIHBhcmVudCA9IHZub2RlLmRvbS5wYXJlbnROb2RlXG5cdFx0XHRcdFx0dmFyIGNvdW50ID0gdm5vZGUuZG9tU2l6ZSB8fCAxXG5cdFx0XHRcdFx0d2hpbGUgKC0tY291bnQpIHBhcmVudC5yZW1vdmVDaGlsZCh2bm9kZS5kb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKHZub2RlLmRvbSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBvbnJlbW92ZSh2bm9kZSkge1xuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5zdGF0ZS5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSBjYWxsSG9vay5jYWxsKHZub2RlLnN0YXRlLm9ucmVtb3ZlLCB2bm9kZSlcblx0XHRpZiAodm5vZGUuYXR0cnMgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIGNhbGxIb29rLmNhbGwodm5vZGUuYXR0cnMub25yZW1vdmUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkgb25yZW1vdmUodm5vZGUuaW5zdGFuY2UpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cdFx0XHRcdFx0aWYgKGNoaWxkICE9IG51bGwpIG9ucmVtb3ZlKGNoaWxkKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly9hdHRyc1xuXHRmdW5jdGlvbiBzZXRBdHRycyh2bm9kZSwgYXR0cnMsIG5zKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG5cdFx0XHRzZXRBdHRyKHZub2RlLCBrZXksIG51bGwsIGF0dHJzW2tleV0sIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRBdHRyKHZub2RlLCBrZXksIG9sZCwgdmFsdWUsIG5zKSB7XG5cdFx0aWYgKGtleSA9PT0gXCJrZXlcIiB8fCBrZXkgPT09IFwiaXNcIiB8fCB2YWx1ZSA9PSBudWxsIHx8IGlzTGlmZWN5Y2xlTWV0aG9kKGtleSkgfHwgKG9sZCA9PT0gdmFsdWUgJiYgIWlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwga2V5KSkgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSByZXR1cm5cblx0XHRpZiAoa2V5WzBdID09PSBcIm9cIiAmJiBrZXlbMV0gPT09IFwiblwiKSByZXR1cm4gdXBkYXRlRXZlbnQodm5vZGUsIGtleSwgdmFsdWUpXG5cdFx0aWYgKGtleS5zbGljZSgwLCA2KSA9PT0gXCJ4bGluazpcIikgdm5vZGUuZG9tLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBrZXkuc2xpY2UoNiksIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB1cGRhdGVTdHlsZSh2bm9kZS5kb20sIG9sZCwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoaGFzUHJvcGVydHlLZXkodm5vZGUsIGtleSwgbnMpKSB7XG5cdFx0XHRpZiAoa2V5ID09PSBcInZhbHVlXCIpIHtcblx0XHRcdFx0Ly8gT25seSBkbyB0aGUgY29lcmNpb24gaWYgd2UncmUgYWN0dWFsbHkgZ29pbmcgdG8gY2hlY2sgdGhlIHZhbHVlLlxuXHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1pbXBsaWNpdC1jb2VyY2lvbiAqL1xuXHRcdFx0XHQvL3NldHRpbmcgaW5wdXRbdmFsdWVdIHRvIHNhbWUgdmFsdWUgYnkgdHlwaW5nIG9uIGZvY3VzZWQgZWxlbWVudCBtb3ZlcyBjdXJzb3IgdG8gZW5kIGluIENocm9tZVxuXHRcdFx0XHRpZiAoKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiIHx8IHZub2RlLnRhZyA9PT0gXCJ0ZXh0YXJlYVwiKSAmJiB2bm9kZS5kb20udmFsdWUgPT09IFwiXCIgKyB2YWx1ZSAmJiB2bm9kZS5kb20gPT09IGFjdGl2ZUVsZW1lbnQoKSkgcmV0dXJuXG5cdFx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYgb2xkICE9PSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gXCJcIiArIHZhbHVlKSByZXR1cm5cblx0XHRcdFx0Ly9zZXR0aW5nIG9wdGlvblt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJvcHRpb25cIiAmJiBvbGQgIT09IG51bGwgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBcIlwiICsgdmFsdWUpIHJldHVyblxuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWltcGxpY2l0LWNvZXJjaW9uICovXG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB5b3UgYXNzaWduIGFuIGlucHV0IHR5cGUgdGhhdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFIDExIHdpdGggYW4gYXNzaWdubWVudCBleHByZXNzaW9uLCBhbiBlcnJvciB3aWxsIG9jY3VyLlxuXHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiICYmIGtleSA9PT0gXCJ0eXBlXCIpIHZub2RlLmRvbS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSlcblx0XHRcdGVsc2Ugdm5vZGUuZG9tW2tleV0gPSB2YWx1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuXHRcdFx0XHRpZiAodmFsdWUpIHZub2RlLmRvbS5zZXRBdHRyaWJ1dGUoa2V5LCBcIlwiKVxuXHRcdFx0XHRlbHNlIHZub2RlLmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB2bm9kZS5kb20uc2V0QXR0cmlidXRlKGtleSA9PT0gXCJjbGFzc05hbWVcIiA/IFwiY2xhc3NcIiA6IGtleSwgdmFsdWUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZUF0dHIodm5vZGUsIGtleSwgb2xkLCBucykge1xuXHRcdGlmIChrZXkgPT09IFwia2V5XCIgfHwga2V5ID09PSBcImlzXCIgfHwgb2xkID09IG51bGwgfHwgaXNMaWZlY3ljbGVNZXRob2Qoa2V5KSkgcmV0dXJuXG5cdFx0aWYgKGtleVswXSA9PT0gXCJvXCIgJiYga2V5WzFdID09PSBcIm5cIiAmJiAhaXNMaWZlY3ljbGVNZXRob2Qoa2V5KSkgdXBkYXRlRXZlbnQodm5vZGUsIGtleSwgdW5kZWZpbmVkKVxuXHRcdGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB1cGRhdGVTdHlsZSh2bm9kZS5kb20sIG9sZCwgbnVsbClcblx0XHRlbHNlIGlmIChcblx0XHRcdGhhc1Byb3BlcnR5S2V5KHZub2RlLCBrZXksIG5zKVxuXHRcdFx0JiYga2V5ICE9PSBcImNsYXNzTmFtZVwiXG5cdFx0XHQmJiAhKGtleSA9PT0gXCJ2YWx1ZVwiICYmIChcblx0XHRcdFx0dm5vZGUudGFnID09PSBcIm9wdGlvblwiXG5cdFx0XHRcdHx8IHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIiAmJiB2bm9kZS5kb20uc2VsZWN0ZWRJbmRleCA9PT0gLTEgJiYgdm5vZGUuZG9tID09PSBhY3RpdmVFbGVtZW50KClcblx0XHRcdCkpXG5cdFx0XHQmJiAhKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiICYmIGtleSA9PT0gXCJ0eXBlXCIpXG5cdFx0KSB7XG5cdFx0XHR2bm9kZS5kb21ba2V5XSA9IG51bGxcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG5zTGFzdEluZGV4ID0ga2V5LmluZGV4T2YoXCI6XCIpXG5cdFx0XHRpZiAobnNMYXN0SW5kZXggIT09IC0xKSBrZXkgPSBrZXkuc2xpY2UobnNMYXN0SW5kZXggKyAxKVxuXHRcdFx0aWYgKG9sZCAhPT0gZmFsc2UpIHZub2RlLmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5ID09PSBcImNsYXNzTmFtZVwiID8gXCJjbGFzc1wiIDoga2V5KVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRMYXRlU2VsZWN0QXR0cnModm5vZGUsIGF0dHJzKSB7XG5cdFx0aWYgKFwidmFsdWVcIiBpbiBhdHRycykge1xuXHRcdFx0aWYoYXR0cnMudmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLmRvbS5zZWxlY3RlZEluZGV4ICE9PSAtMSkgdm5vZGUuZG9tLnZhbHVlID0gbnVsbFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIG5vcm1hbGl6ZWQgPSBcIlwiICsgYXR0cnMudmFsdWUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbXBsaWNpdC1jb2VyY2lvblxuXHRcdFx0XHRpZiAodm5vZGUuZG9tLnZhbHVlICE9PSBub3JtYWxpemVkIHx8IHZub2RlLmRvbS5zZWxlY3RlZEluZGV4ID09PSAtMSkge1xuXHRcdFx0XHRcdHZub2RlLmRvbS52YWx1ZSA9IG5vcm1hbGl6ZWRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoXCJzZWxlY3RlZEluZGV4XCIgaW4gYXR0cnMpIHNldEF0dHIodm5vZGUsIFwic2VsZWN0ZWRJbmRleFwiLCBudWxsLCBhdHRycy5zZWxlY3RlZEluZGV4LCB1bmRlZmluZWQpXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQXR0cnModm5vZGUsIG9sZCwgYXR0cnMsIG5zKSB7XG5cdFx0aWYgKGF0dHJzICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBhdHRycykge1xuXHRcdFx0XHRzZXRBdHRyKHZub2RlLCBrZXksIG9sZCAmJiBvbGRba2V5XSwgYXR0cnNba2V5XSwgbnMpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciB2YWxcblx0XHRpZiAob2xkICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBvbGQpIHtcblx0XHRcdFx0aWYgKCgodmFsID0gb2xkW2tleV0pICE9IG51bGwpICYmIChhdHRycyA9PSBudWxsIHx8IGF0dHJzW2tleV0gPT0gbnVsbCkpIHtcblx0XHRcdFx0XHRyZW1vdmVBdHRyKHZub2RlLCBrZXksIHZhbCwgbnMpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaXNGb3JtQXR0cmlidXRlKHZub2RlLCBhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwidmFsdWVcIiB8fCBhdHRyID09PSBcImNoZWNrZWRcIiB8fCBhdHRyID09PSBcInNlbGVjdGVkSW5kZXhcIiB8fCBhdHRyID09PSBcInNlbGVjdGVkXCIgJiYgdm5vZGUuZG9tID09PSBhY3RpdmVFbGVtZW50KCkgfHwgdm5vZGUudGFnID09PSBcIm9wdGlvblwiICYmIHZub2RlLmRvbS5wYXJlbnROb2RlID09PSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpc0xpZmVjeWNsZU1ldGhvZChhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwib25pbml0XCIgfHwgYXR0ciA9PT0gXCJvbmNyZWF0ZVwiIHx8IGF0dHIgPT09IFwib251cGRhdGVcIiB8fCBhdHRyID09PSBcIm9ucmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmV1cGRhdGVcIlxuXHR9XG5cdGZ1bmN0aW9uIGhhc1Byb3BlcnR5S2V5KHZub2RlLCBrZXksIG5zKSB7XG5cdFx0Ly8gRmlsdGVyIG91dCBuYW1lc3BhY2VkIGtleXNcblx0XHRyZXR1cm4gbnMgPT09IHVuZGVmaW5lZCAmJiAoXG5cdFx0XHQvLyBJZiBpdCdzIGEgY3VzdG9tIGVsZW1lbnQsIGp1c3Qga2VlcCBpdC5cblx0XHRcdHZub2RlLnRhZy5pbmRleE9mKFwiLVwiKSA+IC0xIHx8IHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuaXMgfHxcblx0XHRcdC8vIElmIGl0J3MgYSBub3JtYWwgZWxlbWVudCwgbGV0J3MgdHJ5IHRvIGF2b2lkIGEgZmV3IGJyb3dzZXIgYnVncy5cblx0XHRcdGtleSAhPT0gXCJocmVmXCIgJiYga2V5ICE9PSBcImxpc3RcIiAmJiBrZXkgIT09IFwiZm9ybVwiICYmIGtleSAhPT0gXCJ3aWR0aFwiICYmIGtleSAhPT0gXCJoZWlnaHRcIi8vICYmIGtleSAhPT0gXCJ0eXBlXCJcblx0XHRcdC8vIERlZmVyIHRoZSBwcm9wZXJ0eSBjaGVjayB1bnRpbCAqYWZ0ZXIqIHdlIGNoZWNrIGV2ZXJ5dGhpbmcuXG5cdFx0KSAmJiBrZXkgaW4gdm5vZGUuZG9tXG5cdH1cblxuXHQvL3N0eWxlXG5cdHZhciB1cHBlcmNhc2VSZWdleCA9IC9bQS1aXS9nXG5cdGZ1bmN0aW9uIHRvTG93ZXJDYXNlKGNhcGl0YWwpIHsgcmV0dXJuIFwiLVwiICsgY2FwaXRhbC50b0xvd2VyQ2FzZSgpIH1cblx0ZnVuY3Rpb24gbm9ybWFsaXplS2V5KGtleSkge1xuXHRcdHJldHVybiBrZXlbMF0gPT09IFwiLVwiICYmIGtleVsxXSA9PT0gXCItXCIgPyBrZXkgOlxuXHRcdFx0a2V5ID09PSBcImNzc0Zsb2F0XCIgPyBcImZsb2F0XCIgOlxuXHRcdFx0XHRrZXkucmVwbGFjZSh1cHBlcmNhc2VSZWdleCwgdG9Mb3dlckNhc2UpXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkLCBzdHlsZSkge1xuXHRcdGlmIChvbGQgPT09IHN0eWxlKSB7XG5cdFx0XHQvLyBTdHlsZXMgYXJlIGVxdWl2YWxlbnQsIGRvIG5vdGhpbmcuXG5cdFx0fSBlbHNlIGlmIChzdHlsZSA9PSBudWxsKSB7XG5cdFx0XHQvLyBOZXcgc3R5bGUgaXMgbWlzc2luZywganVzdCBjbGVhciBpdC5cblx0XHRcdGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBzdHlsZSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0Ly8gTmV3IHN0eWxlIGlzIGEgc3RyaW5nLCBsZXQgZW5naW5lIGRlYWwgd2l0aCBwYXRjaGluZy5cblx0XHRcdGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlXG5cdFx0fSBlbHNlIGlmIChvbGQgPT0gbnVsbCB8fCB0eXBlb2Ygb2xkICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHQvLyBgb2xkYCBpcyBtaXNzaW5nIG9yIGEgc3RyaW5nLCBgc3R5bGVgIGlzIGFuIG9iamVjdC5cblx0XHRcdGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHRcdC8vIEFkZCBuZXcgc3R5bGUgcHJvcGVydGllc1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHN0eWxlKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHN0eWxlW2tleV1cblx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkobm9ybWFsaXplS2V5KGtleSksIFN0cmluZyh2YWx1ZSkpXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEJvdGggb2xkICYgbmV3IGFyZSAoZGlmZmVyZW50KSBvYmplY3RzLlxuXHRcdFx0Ly8gVXBkYXRlIHN0eWxlIHByb3BlcnRpZXMgdGhhdCBoYXZlIGNoYW5nZWRcblx0XHRcdGZvciAodmFyIGtleSBpbiBzdHlsZSkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBzdHlsZVtrZXldXG5cdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSA9IFN0cmluZyh2YWx1ZSkpICE9PSBTdHJpbmcob2xkW2tleV0pKSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShub3JtYWxpemVLZXkoa2V5KSwgdmFsdWUpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIFJlbW92ZSBzdHlsZSBwcm9wZXJ0aWVzIHRoYXQgbm8gbG9uZ2VyIGV4aXN0XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gb2xkKSB7XG5cdFx0XHRcdGlmIChvbGRba2V5XSAhPSBudWxsICYmIHN0eWxlW2tleV0gPT0gbnVsbCkge1xuXHRcdFx0XHRcdGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkobm9ybWFsaXplS2V5KGtleSkpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBIZXJlJ3MgYW4gZXhwbGFuYXRpb24gb2YgaG93IHRoaXMgd29ya3M6XG5cdC8vIDEuIFRoZSBldmVudCBuYW1lcyBhcmUgYWx3YXlzIChieSBkZXNpZ24pIHByZWZpeGVkIGJ5IGBvbmAuXG5cdC8vIDIuIFRoZSBFdmVudExpc3RlbmVyIGludGVyZmFjZSBhY2NlcHRzIGVpdGhlciBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdFxuXHQvLyAgICB3aXRoIGEgYGhhbmRsZUV2ZW50YCBtZXRob2QuXG5cdC8vIDMuIFRoZSBvYmplY3QgZG9lcyBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYCwgdG8gYXZvaWRcblx0Ly8gICAgYW55IHBvdGVudGlhbCBpbnRlcmZlcmVuY2Ugd2l0aCB0aGF0IChlLmcuIHNldHRlcnMpLlxuXHQvLyA0LiBUaGUgZXZlbnQgbmFtZSBpcyByZW1hcHBlZCB0byB0aGUgaGFuZGxlciBiZWZvcmUgY2FsbGluZyBpdC5cblx0Ly8gNS4gSW4gZnVuY3Rpb24tYmFzZWQgZXZlbnQgaGFuZGxlcnMsIGBldi50YXJnZXQgPT09IHRoaXNgLiBXZSByZXBsaWNhdGVcblx0Ly8gICAgdGhhdCBiZWxvdy5cblx0Ly8gNi4gSW4gZnVuY3Rpb24tYmFzZWQgZXZlbnQgaGFuZGxlcnMsIGByZXR1cm4gZmFsc2VgIHByZXZlbnRzIHRoZSBkZWZhdWx0XG5cdC8vICAgIGFjdGlvbiBhbmQgc3RvcHMgZXZlbnQgcHJvcGFnYXRpb24uIFdlIHJlcGxpY2F0ZSB0aGF0IGJlbG93LlxuXHRmdW5jdGlvbiBFdmVudERpY3QoKSB7fVxuXHRFdmVudERpY3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXHRFdmVudERpY3QucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2KSB7XG5cdFx0dmFyIGhhbmRsZXIgPSB0aGlzW1wib25cIiArIGV2LnR5cGVdXG5cdFx0dmFyIHJlc3VsdFxuXHRcdGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSByZXN1bHQgPSBoYW5kbGVyLmNhbGwoZXYuY3VycmVudFRhcmdldCwgZXYpXG5cdFx0ZWxzZSBpZiAodHlwZW9mIGhhbmRsZXIuaGFuZGxlRXZlbnQgPT09IFwiZnVuY3Rpb25cIikgaGFuZGxlci5oYW5kbGVFdmVudChldilcblx0XHRpZiAoZXYucmVkcmF3ID09PSBmYWxzZSkgZXYucmVkcmF3ID0gdW5kZWZpbmVkXG5cdFx0ZWxzZSBpZiAodHlwZW9mIHJlZHJhdyA9PT0gXCJmdW5jdGlvblwiKSByZWRyYXcoKVxuXHRcdGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG5cdFx0XHRldi5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRldi5zdG9wUHJvcGFnYXRpb24oKVxuXHRcdH1cblx0fVxuXG5cdC8vZXZlbnRcblx0ZnVuY3Rpb24gdXBkYXRlRXZlbnQodm5vZGUsIGtleSwgdmFsdWUpIHtcblx0XHRpZiAodm5vZGUuZXZlbnRzICE9IG51bGwpIHtcblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5XSA9PT0gdmFsdWUpIHJldHVyblxuXHRcdFx0aWYgKHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikpIHtcblx0XHRcdFx0aWYgKHZub2RlLmV2ZW50c1trZXldID09IG51bGwpIHZub2RlLmRvbS5hZGRFdmVudExpc3RlbmVyKGtleS5zbGljZSgyKSwgdm5vZGUuZXZlbnRzLCBmYWxzZSlcblx0XHRcdFx0dm5vZGUuZXZlbnRzW2tleV0gPSB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHZub2RlLmV2ZW50c1trZXldICE9IG51bGwpIHZub2RlLmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKGtleS5zbGljZSgyKSwgdm5vZGUuZXZlbnRzLCBmYWxzZSlcblx0XHRcdFx0dm5vZGUuZXZlbnRzW2tleV0gPSB1bmRlZmluZWRcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikpIHtcblx0XHRcdHZub2RlLmV2ZW50cyA9IG5ldyBFdmVudERpY3QoKVxuXHRcdFx0dm5vZGUuZG9tLmFkZEV2ZW50TGlzdGVuZXIoa2V5LnNsaWNlKDIpLCB2bm9kZS5ldmVudHMsIGZhbHNlKVxuXHRcdFx0dm5vZGUuZXZlbnRzW2tleV0gPSB2YWx1ZVxuXHRcdH1cblx0fVxuXG5cdC8vbGlmZWN5Y2xlXG5cdGZ1bmN0aW9uIGluaXRMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbmluaXQgPT09IFwiZnVuY3Rpb25cIikgY2FsbEhvb2suY2FsbChzb3VyY2Uub25pbml0LCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKGNhbGxIb29rLmJpbmQoc291cmNlLm9uY3JlYXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlTGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub251cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChjYWxsSG9vay5iaW5kKHNvdXJjZS5vbnVwZGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSB7XG5cdFx0ZG8ge1xuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dmFyIGZvcmNlID0gY2FsbEhvb2suY2FsbCh2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZSwgdm5vZGUsIG9sZClcblx0XHRcdFx0aWYgKGZvcmNlICE9PSB1bmRlZmluZWQgJiYgIWZvcmNlKSBicmVha1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLnN0YXRlLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dmFyIGZvcmNlID0gY2FsbEhvb2suY2FsbCh2bm9kZS5zdGF0ZS5vbmJlZm9yZXVwZGF0ZSwgdm5vZGUsIG9sZClcblx0XHRcdFx0aWYgKGZvcmNlICE9PSB1bmRlZmluZWQgJiYgIWZvcmNlKSBicmVha1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0fSB3aGlsZSAoZmFsc2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuXHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHR2bm9kZS5pbnN0YW5jZSA9IG9sZC5pbnN0YW5jZVxuXHRcdC8vIE9uZSB3b3VsZCB0aGluayBoYXZpbmcgdGhlIGFjdHVhbCBsYXRlc3QgYXR0cmlidXRlcyB3b3VsZCBiZSBpZGVhbCxcblx0XHQvLyBidXQgaXQgZG9lc24ndCBsZXQgdXMgcHJvcGVybHkgZGlmZiBiYXNlZCBvbiBvdXIgY3VycmVudCBpbnRlcm5hbFxuXHRcdC8vIHJlcHJlc2VudGF0aW9uLiBXZSBoYXZlIHRvIHNhdmUgbm90IG9ubHkgdGhlIG9sZCBET00gaW5mbywgYnV0IGFsc29cblx0XHQvLyB0aGUgYXR0cmlidXRlcyB1c2VkIHRvIGNyZWF0ZSBpdCwgYXMgd2UgZGlmZiAqdGhhdCosIG5vdCBhZ2FpbnN0IHRoZVxuXHRcdC8vIERPTSBkaXJlY3RseSAod2l0aCBhIGZldyBleGNlcHRpb25zIGluIGBzZXRBdHRyYCkuIEFuZCwgb2YgY291cnNlLCB3ZVxuXHRcdC8vIG5lZWQgdG8gc2F2ZSB0aGUgY2hpbGRyZW4gYW5kIHRleHQgYXMgdGhleSBhcmUgY29uY2VwdHVhbGx5IG5vdFxuXHRcdC8vIHVubGlrZSBzcGVjaWFsIFwiYXR0cmlidXRlc1wiIGludGVybmFsbHkuXG5cdFx0dm5vZGUuYXR0cnMgPSBvbGQuYXR0cnNcblx0XHR2bm9kZS5jaGlsZHJlbiA9IG9sZC5jaGlsZHJlblxuXHRcdHZub2RlLnRleHQgPSBvbGQudGV4dFxuXHRcdHJldHVybiB0cnVlXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXIoZG9tLCB2bm9kZXMpIHtcblx0XHRpZiAoIWRvbSkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCBiZWluZyBwYXNzZWQgdG8gbS5yb3V0ZS9tLm1vdW50L20ucmVuZGVyIGlzIG5vdCB1bmRlZmluZWQuXCIpXG5cdFx0dmFyIGhvb2tzID0gW11cblx0XHR2YXIgYWN0aXZlID0gYWN0aXZlRWxlbWVudCgpXG5cdFx0dmFyIG5hbWVzcGFjZSA9IGRvbS5uYW1lc3BhY2VVUklcblxuXHRcdC8vIEZpcnN0IHRpbWUgcmVuZGVyaW5nIGludG8gYSBub2RlIGNsZWFycyBpdCBvdXRcblx0XHRpZiAoZG9tLnZub2RlcyA9PSBudWxsKSBkb20udGV4dENvbnRlbnQgPSBcIlwiXG5cblx0XHR2bm9kZXMgPSBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihBcnJheS5pc0FycmF5KHZub2RlcykgPyB2bm9kZXMgOiBbdm5vZGVzXSlcblx0XHR1cGRhdGVOb2Rlcyhkb20sIGRvbS52bm9kZXMsIHZub2RlcywgaG9va3MsIG51bGwsIG5hbWVzcGFjZSA9PT0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIgPyB1bmRlZmluZWQgOiBuYW1lc3BhY2UpXG5cdFx0ZG9tLnZub2RlcyA9IHZub2Rlc1xuXHRcdC8vIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBjYW4gcmV0dXJuIG51bGw6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjZG9tLWRvY3VtZW50LWFjdGl2ZWVsZW1lbnRcblx0XHRpZiAoYWN0aXZlICE9IG51bGwgJiYgYWN0aXZlRWxlbWVudCgpICE9PSBhY3RpdmUgJiYgdHlwZW9mIGFjdGl2ZS5mb2N1cyA9PT0gXCJmdW5jdGlvblwiKSBhY3RpdmUuZm9jdXMoKVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIGhvb2tzW2ldKClcblx0fVxuXG5cdHJldHVybiB7cmVuZGVyOiByZW5kZXIsIHNldFJlZHJhdzogc2V0UmVkcmF3fVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIFZub2RlID0gcmVxdWlyZShcIi4uL3JlbmRlci92bm9kZVwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMsIGNoaWxkcmVuLCB0ZXh0LCBkb20pIHtcblx0cmV0dXJuIHt0YWc6IHRhZywga2V5OiBrZXksIGF0dHJzOiBhdHRycywgY2hpbGRyZW46IGNoaWxkcmVuLCB0ZXh0OiB0ZXh0LCBkb206IGRvbSwgZG9tU2l6ZTogdW5kZWZpbmVkLCBzdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZH1cbn1cblZub2RlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHJldHVybiBWbm9kZShcIltcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKG5vZGUpLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0aWYgKG5vZGUgPT0gbnVsbCB8fCB0eXBlb2Ygbm9kZSA9PT0gXCJib29sZWFuXCIpIHJldHVybiBudWxsXG5cdGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIG5vZGVcblx0cmV0dXJuIFZub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKG5vZGUpLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcbn1cblZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0dmFyIGNoaWxkcmVuID0gW11cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuXHRcdGNoaWxkcmVuW2ldID0gVm5vZGUubm9ybWFsaXplKGlucHV0W2ldKVxuXHR9XG5cdHJldHVybiBjaGlsZHJlblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZub2RlXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gcmVxdWlyZShcIi4vcHJvbWlzZS9wcm9taXNlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3JlcXVlc3QvcmVxdWVzdFwiKSh3aW5kb3csIFByb21pc2VQb2x5ZmlsbClcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBidWlsZFBhdGhuYW1lID0gcmVxdWlyZShcIi4uL3BhdGhuYW1lL2J1aWxkXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJHdpbmRvdywgUHJvbWlzZSkge1xuXHR2YXIgY2FsbGJhY2tDb3VudCA9IDBcblx0dmFyIG9uY29tcGxldGlvblxuXG5cdGZ1bmN0aW9uIFByb21pc2VQcm94eShleGVjdXRvcikge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZShleGVjdXRvcilcblx0fVxuXG5cdC8vIEluIGNhc2UgdGhlIGdsb2JhbCBQcm9taXNlIGlzIHNvbWUgdXNlcmxhbmQgbGlicmFyeSdzIHdoZXJlIHRoZXkgcmVseSBvblxuXHQvLyBgZm9vIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvcmAsIGB0aGlzLmNvbnN0cnVjdG9yLnJlc29sdmUodmFsdWUpYCwgb3Jcblx0Ly8gc2ltaWxhci4gTGV0J3MgKm5vdCogYnJlYWsgdGhlbS5cblx0UHJvbWlzZVByb3h5LnByb3RvdHlwZSA9IFByb21pc2UucHJvdG90eXBlXG5cdFByb21pc2VQcm94eS5fX3Byb3RvX18gPSBQcm9taXNlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cblxuXHRmdW5jdGlvbiBtYWtlUmVxdWVzdChmYWN0b3J5KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHVybCwgYXJncykge1xuXHRcdFx0aWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpIHsgYXJncyA9IHVybDsgdXJsID0gdXJsLnVybCB9XG5cdFx0XHRlbHNlIGlmIChhcmdzID09IG51bGwpIGFyZ3MgPSB7fVxuXHRcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdFx0ZmFjdG9yeShidWlsZFBhdGhuYW1lKHVybCwgYXJncy5wYXJhbXMpLCBhcmdzLCBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgYXJncy50eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgYXJncy50eXBlKGRhdGFbaV0pXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgZGF0YSA9IG5ldyBhcmdzLnR5cGUoZGF0YSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzb2x2ZShkYXRhKVxuXHRcdFx0XHR9LCByZWplY3QpXG5cdFx0XHR9KVxuXHRcdFx0aWYgKGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSkgcmV0dXJuIHByb21pc2Vcblx0XHRcdHZhciBjb3VudCA9IDBcblx0XHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuXHRcdFx0XHRpZiAoLS1jb3VudCA9PT0gMCAmJiB0eXBlb2Ygb25jb21wbGV0aW9uID09PSBcImZ1bmN0aW9uXCIpIG9uY29tcGxldGlvbigpXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB3cmFwKHByb21pc2UpXG5cblx0XHRcdGZ1bmN0aW9uIHdyYXAocHJvbWlzZSkge1xuXHRcdFx0XHR2YXIgdGhlbiA9IHByb21pc2UudGhlblxuXHRcdFx0XHQvLyBTZXQgdGhlIGNvbnN0cnVjdG9yLCBzbyBlbmdpbmVzIGtub3cgdG8gbm90IGF3YWl0IG9yIHJlc29sdmVcblx0XHRcdFx0Ly8gdGhpcyBhcyBhIG5hdGl2ZSBwcm9taXNlLiBBdCB0aGUgdGltZSBvZiB3cml0aW5nLCB0aGlzIGlzXG5cdFx0XHRcdC8vIG9ubHkgbmVjZXNzYXJ5IGZvciBWOCwgYnV0IHRoZWlyIGJlaGF2aW9yIGlzIHRoZSBjb3JyZWN0XG5cdFx0XHRcdC8vIGJlaGF2aW9yIHBlciBzcGVjLiBTZWUgdGhpcyBzcGVjIGlzc3VlIGZvciBtb3JlIGRldGFpbHM6XG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L2VjbWEyNjIvaXNzdWVzLzE1NzcuIEFsc28sIHNlZSB0aGVcblx0XHRcdFx0Ly8gY29ycmVzcG9uZGluZyBjb21tZW50IGluIGByZXF1ZXN0L3Rlc3RzL3Rlc3QtcmVxdWVzdC5qc2AgZm9yXG5cdFx0XHRcdC8vIGEgYml0IG1vcmUgYmFja2dyb3VuZCBvbiB0aGUgaXNzdWUgYXQgaGFuZC5cblx0XHRcdFx0cHJvbWlzZS5jb25zdHJ1Y3RvciA9IFByb21pc2VQcm94eVxuXHRcdFx0XHRwcm9taXNlLnRoZW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRjb3VudCsrXG5cdFx0XHRcdFx0dmFyIG5leHQgPSB0aGVuLmFwcGx5KHByb21pc2UsIGFyZ3VtZW50cylcblx0XHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRcdGNvbXBsZXRlKClcblx0XHRcdFx0XHRcdGlmIChjb3VudCA9PT0gMCkgdGhyb3cgZVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0cmV0dXJuIHdyYXAobmV4dClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGhhc0hlYWRlcihhcmdzLCBuYW1lKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIGFyZ3MuaGVhZGVycykge1xuXHRcdFx0aWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXJncy5oZWFkZXJzLCBrZXkpICYmIG5hbWUudGVzdChrZXkpKSByZXR1cm4gdHJ1ZVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0cmVxdWVzdDogbWFrZVJlcXVlc3QoZnVuY3Rpb24odXJsLCBhcmdzLCByZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdHZhciBtZXRob2QgPSBhcmdzLm1ldGhvZCAhPSBudWxsID8gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKSA6IFwiR0VUXCJcblx0XHRcdHZhciBib2R5ID0gYXJncy5ib2R5XG5cdFx0XHR2YXIgYXNzdW1lSlNPTiA9IChhcmdzLnNlcmlhbGl6ZSA9PSBudWxsIHx8IGFyZ3Muc2VyaWFsaXplID09PSBKU09OLnNlcmlhbGl6ZSkgJiYgIShib2R5IGluc3RhbmNlb2YgJHdpbmRvdy5Gb3JtRGF0YSlcblx0XHRcdHZhciByZXNwb25zZVR5cGUgPSBhcmdzLnJlc3BvbnNlVHlwZSB8fCAodHlwZW9mIGFyZ3MuZXh0cmFjdCA9PT0gXCJmdW5jdGlvblwiID8gXCJcIiA6IFwianNvblwiKVxuXG5cdFx0XHR2YXIgeGhyID0gbmV3ICR3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKSwgYWJvcnRlZCA9IGZhbHNlXG5cdFx0XHR2YXIgb3JpZ2luYWwgPSB4aHIsIHJlcGxhY2VkQWJvcnRcblx0XHRcdHZhciBhYm9ydCA9IHhoci5hYm9ydFxuXG5cdFx0XHR4aHIuYWJvcnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0YWJvcnRlZCA9IHRydWVcblx0XHRcdFx0YWJvcnQuY2FsbCh0aGlzKVxuXHRcdFx0fVxuXG5cdFx0XHR4aHIub3BlbihtZXRob2QsIHVybCwgYXJncy5hc3luYyAhPT0gZmFsc2UsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblxuXHRcdFx0aWYgKGFzc3VtZUpTT04gJiYgYm9keSAhPSBudWxsICYmICFoYXNIZWFkZXIoYXJncywgL15jb250ZW50LXR5cGUkL2kpKSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmRlc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIgJiYgIWhhc0hlYWRlcihhcmdzLCAvXmFjY2VwdCQvaSkpIHtcblx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0LypcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLndpdGhDcmVkZW50aWFscykgeGhyLndpdGhDcmVkZW50aWFscyA9IGFyZ3Mud2l0aENyZWRlbnRpYWxzXG5cdFx0XHRpZiAoYXJncy50aW1lb3V0KSB4aHIudGltZW91dCA9IGFyZ3MudGltZW91dFxuXHRcdFx0eGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZVxuXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJncy5oZWFkZXJzKSB7XG5cdFx0XHRcdGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgYXJncy5oZWFkZXJzW2tleV0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdC8vIERvbid0IHRocm93IGVycm9ycyBvbiB4aHIuYWJvcnQoKS5cblx0XHRcdFx0aWYgKGFib3J0ZWQpIHJldHVyblxuXG5cdFx0XHRcdGlmIChldi50YXJnZXQucmVhZHlTdGF0ZSA9PT0gNCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR2YXIgc3VjY2VzcyA9IChldi50YXJnZXQuc3RhdHVzID49IDIwMCAmJiBldi50YXJnZXQuc3RhdHVzIDwgMzAwKSB8fCBldi50YXJnZXQuc3RhdHVzID09PSAzMDQgfHwgKC9eZmlsZTpcXC9cXC8vaSkudGVzdCh1cmwpXG5cdFx0XHRcdFx0XHQvLyBXaGVuIHRoZSByZXNwb25zZSB0eXBlIGlzbid0IFwiXCIgb3IgXCJ0ZXh0XCIsXG5cdFx0XHRcdFx0XHQvLyBgeGhyLnJlc3BvbnNlVGV4dGAgaXMgdGhlIHdyb25nIHRoaW5nIHRvIHVzZS5cblx0XHRcdFx0XHRcdC8vIEJyb3dzZXJzIGRvIHRoZSByaWdodCB0aGluZyBhbmQgdGhyb3cgaGVyZSwgYW5kIHdlXG5cdFx0XHRcdFx0XHQvLyBzaG91bGQgaG9ub3IgdGhhdCBhbmQgZG8gdGhlIHJpZ2h0IHRoaW5nIGJ5XG5cdFx0XHRcdFx0XHQvLyBwcmVmZXJyaW5nIGB4aHIucmVzcG9uc2VgIHdoZXJlIHBvc3NpYmxlL3ByYWN0aWNhbC5cblx0XHRcdFx0XHRcdHZhciByZXNwb25zZSA9IGV2LnRhcmdldC5yZXNwb25zZSwgbWVzc2FnZVxuXG5cdFx0XHRcdFx0XHRpZiAocmVzcG9uc2VUeXBlID09PSBcImpzb25cIikge1xuXHRcdFx0XHRcdFx0XHQvLyBGb3IgSUUgYW5kIEVkZ2UsIHdoaWNoIGRvbid0IGltcGxlbWVudFxuXHRcdFx0XHRcdFx0XHQvLyBgcmVzcG9uc2VUeXBlOiBcImpzb25cImAuXG5cdFx0XHRcdFx0XHRcdGlmICghZXYudGFyZ2V0LnJlc3BvbnNlVHlwZSAmJiB0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIHJlc3BvbnNlID0gSlNPTi5wYXJzZShldi50YXJnZXQucmVzcG9uc2VUZXh0KVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICghcmVzcG9uc2VUeXBlIHx8IHJlc3BvbnNlVHlwZSA9PT0gXCJ0ZXh0XCIpIHtcblx0XHRcdFx0XHRcdFx0Ly8gT25seSB1c2UgdGhpcyBkZWZhdWx0IGlmIGl0J3MgdGV4dC4gSWYgYSBwYXJzZWRcblx0XHRcdFx0XHRcdFx0Ly8gZG9jdW1lbnQgaXMgbmVlZGVkIG9uIG9sZCBJRSBhbmQgZnJpZW5kcyAoYWxsXG5cdFx0XHRcdFx0XHRcdC8vIHVuc3VwcG9ydGVkKSwgdGhlIHVzZXIgc2hvdWxkIHVzZSBhIGN1c3RvbVxuXHRcdFx0XHRcdFx0XHQvLyBgY29uZmlnYCBpbnN0ZWFkLiBUaGV5J3JlIGFscmVhZHkgdXNpbmcgdGhpcyBhdFxuXHRcdFx0XHRcdFx0XHQvLyB0aGVpciBvd24gcmlzay5cblx0XHRcdFx0XHRcdFx0aWYgKHJlc3BvbnNlID09IG51bGwpIHJlc3BvbnNlID0gZXYudGFyZ2V0LnJlc3BvbnNlVGV4dFxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIGFyZ3MuZXh0cmFjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gYXJncy5leHRyYWN0KGV2LnRhcmdldCwgYXJncylcblx0XHRcdFx0XHRcdFx0c3VjY2VzcyA9IHRydWVcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGFyZ3MuZGVzZXJpYWxpemUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGFyZ3MuZGVzZXJpYWxpemUocmVzcG9uc2UpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoc3VjY2VzcykgcmVzb2x2ZShyZXNwb25zZSlcblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0cnkgeyBtZXNzYWdlID0gZXYudGFyZ2V0LnJlc3BvbnNlVGV4dCB9XG5cdFx0XHRcdFx0XHRcdGNhdGNoIChlKSB7IG1lc3NhZ2UgPSByZXNwb25zZSB9XG5cdFx0XHRcdFx0XHRcdHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuXHRcdFx0XHRcdFx0XHRlcnJvci5jb2RlID0gZXYudGFyZ2V0LnN0YXR1c1xuXHRcdFx0XHRcdFx0XHRlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlXG5cdFx0XHRcdFx0XHRcdHJlamVjdChlcnJvcilcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3MuY29uZmlnID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0eGhyID0gYXJncy5jb25maWcoeGhyLCBhcmdzLCB1cmwpIHx8IHhoclxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSB0aGUgYGFib3J0YCB0byBhbnkgcmVwbGFjZW1lbnQgWEhSIGFzIHdlbGwuXG5cdFx0XHRcdGlmICh4aHIgIT09IG9yaWdpbmFsKSB7XG5cdFx0XHRcdFx0cmVwbGFjZWRBYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0XHRcdHhoci5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0YWJvcnRlZCA9IHRydWVcblx0XHRcdFx0XHRcdHJlcGxhY2VkQWJvcnQuY2FsbCh0aGlzKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYm9keSA9PSBudWxsKSB4aHIuc2VuZCgpXG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgYXJncy5zZXJpYWxpemUgPT09IFwiZnVuY3Rpb25cIikgeGhyLnNlbmQoYXJncy5zZXJpYWxpemUoYm9keSkpXG5cdFx0XHRlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgJHdpbmRvdy5Gb3JtRGF0YSkgeGhyLnNlbmQoYm9keSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoSlNPTi5zdHJpbmdpZnkoYm9keSkpXG5cdFx0fSksXG5cdFx0anNvbnA6IG1ha2VSZXF1ZXN0KGZ1bmN0aW9uKHVybCwgYXJncywgcmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpXG5cdFx0XHRcdHJlc29sdmUoZGF0YSlcblx0XHRcdH1cblx0XHRcdHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHR9XG5cdFx0XHRzY3JpcHQuc3JjID0gdXJsICsgKHVybC5pbmRleE9mKFwiP1wiKSA8IDAgPyBcIj9cIiA6IFwiJlwiKSArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudChhcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIikgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudChjYWxsYmFja05hbWUpXG5cdFx0XHQkd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpXG5cdFx0fSksXG5cdFx0c2V0Q29tcGxldGlvbkNhbGxiYWNrOiBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0b25jb21wbGV0aW9uID0gY2FsbGJhY2tcblx0XHR9LFxuXHR9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgcmVkcmF3U2VydmljZSA9IHJlcXVpcmUoXCIuL3JlZHJhd1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2FwaS9yb3V0ZXJcIikod2luZG93LCByZWRyYXdTZXJ2aWNlKVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGJ1aWxkUGF0aG5hbWUgPSByZXF1aXJlKFwiLi4vcGF0aG5hbWUvYnVpbGRcIilcbnZhciBwYXJzZVBhdGhuYW1lID0gcmVxdWlyZShcIi4uL3BhdGhuYW1lL3BhcnNlXCIpXG52YXIgY29tcGlsZVRlbXBsYXRlID0gcmVxdWlyZShcIi4uL3BhdGhuYW1lL2NvbXBpbGVUZW1wbGF0ZVwiKVxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuLi9wYXRobmFtZS9hc3NpZ25cIilcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdHZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9IHR5cGVvZiAkd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID09PSBcImZ1bmN0aW9uXCJcblx0dmFyIGZpcmVBc3luY1xuXG5cdHJldHVybiB7XG5cdFx0cHJlZml4OiBcIiMhXCIsXG5cblx0XHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIENvbnNpZGVyIHRoZSBwYXRobmFtZSBob2xpc3RpY2FsbHkuIFRoZSBwcmVmaXggbWlnaHQgZXZlbiBiZSBpbnZhbGlkLFxuXHRcdFx0Ly8gYnV0IHRoYXQncyBub3Qgb3VyIHByb2JsZW0uXG5cdFx0XHR2YXIgcHJlZml4ID0gJHdpbmRvdy5sb2NhdGlvbi5oYXNoXG5cdFx0XHRpZiAodGhpcy5wcmVmaXhbMF0gIT09IFwiI1wiKSB7XG5cdFx0XHRcdHByZWZpeCA9ICR3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgcHJlZml4XG5cdFx0XHRcdGlmICh0aGlzLnByZWZpeFswXSAhPT0gXCI/XCIpIHtcblx0XHRcdFx0XHRwcmVmaXggPSAkd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgcHJlZml4XG5cdFx0XHRcdFx0aWYgKHByZWZpeFswXSAhPT0gXCIvXCIpIHByZWZpeCA9IFwiL1wiICsgcHJlZml4XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIFRoaXMgc2VlbWluZ2x5IHVzZWxlc3MgYC5jb25jYXQoKWAgc3BlZWRzIHVwIHRoZSB0ZXN0cyBxdWl0ZSBhIGJpdCxcblx0XHRcdC8vIHNpbmNlIHRoZSByZXByZXNlbnRhdGlvbiBpcyBjb25zaXN0ZW50bHkgYSByZWxhdGl2ZWx5IHBvb3JseVxuXHRcdFx0Ly8gb3B0aW1pemVkIGNvbnMgc3RyaW5nLlxuXHRcdFx0cmV0dXJuIHByZWZpeC5jb25jYXQoKVxuXHRcdFx0XHQucmVwbGFjZSgvKD86JVthLWY4OV1bYS1mMC05XSkrL2dpbSwgZGVjb2RlVVJJQ29tcG9uZW50KVxuXHRcdFx0XHQuc2xpY2UodGhpcy5wcmVmaXgubGVuZ3RoKVxuXHRcdH0sXG5cblx0XHRzZXRQYXRoOiBmdW5jdGlvbihwYXRoLCBkYXRhLCBvcHRpb25zKSB7XG5cdFx0XHRwYXRoID0gYnVpbGRQYXRobmFtZShwYXRoLCBkYXRhKVxuXHRcdFx0aWYgKGZpcmVBc3luYyAhPSBudWxsKSB7XG5cdFx0XHRcdGZpcmVBc3luYygpXG5cdFx0XHRcdHZhciBzdGF0ZSA9IG9wdGlvbnMgPyBvcHRpb25zLnN0YXRlIDogbnVsbFxuXHRcdFx0XHR2YXIgdGl0bGUgPSBvcHRpb25zID8gb3B0aW9ucy50aXRsZSA6IG51bGxcblx0XHRcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXBsYWNlKSAkd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgdGhpcy5wcmVmaXggKyBwYXRoKVxuXHRcdFx0XHRlbHNlICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCB0aGlzLnByZWZpeCArIHBhdGgpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0JHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdGhpcy5wcmVmaXggKyBwYXRoXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGRlZmluZVJvdXRlczogZnVuY3Rpb24ocm91dGVzLCByZXNvbHZlLCByZWplY3QsIGRlZmF1bHRSb3V0ZSwgc3Vic2NyaWJlKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXNcblx0XHRcdHZhciBjb21waWxlZCA9IE9iamVjdC5rZXlzKHJvdXRlcykubWFwKGZ1bmN0aW9uKHJvdXRlKSB7XG5cdFx0XHRcdGlmIChyb3V0ZVswXSAhPT0gXCIvXCIpIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlJvdXRlcyBtdXN0IHN0YXJ0IHdpdGggYSBgL2BcIilcblx0XHRcdFx0aWYgKCgvOihbXlxcL1xcLi1dKykoXFwuezN9KT86LykudGVzdChyb3V0ZSkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJSb3V0ZSBwYXJhbWV0ZXIgbmFtZXMgbXVzdCBiZSBzZXBhcmF0ZWQgd2l0aCBlaXRoZXIgYC9gLCBgLmAsIG9yIGAtYFwiKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0cm91dGU6IHJvdXRlLFxuXHRcdFx0XHRcdGNvbXBvbmVudDogcm91dGVzW3JvdXRlXSxcblx0XHRcdFx0XHRjaGVjazogY29tcGlsZVRlbXBsYXRlKHJvdXRlKSxcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdHZhciB1bnN1YnNjcmliZSwgYXN5bmNJZFxuXG5cdFx0XHRmaXJlQXN5bmMgPSBudWxsXG5cblx0XHRcdGlmIChkZWZhdWx0Um91dGUgIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgZGVmYXVsdERhdGEgPSBwYXJzZVBhdGhuYW1lKGRlZmF1bHRSb3V0ZSlcblxuXHRcdFx0XHRpZiAoIWNvbXBpbGVkLnNvbWUoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkuY2hlY2soZGVmYXVsdERhdGEpIH0pKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiRGVmYXVsdCByb3V0ZSBkb2Vzbid0IG1hdGNoIGFueSBrbm93biByb3V0ZXNcIilcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiByZXNvbHZlUm91dGUoKSB7XG5cdFx0XHRcdHZhciBwYXRoID0gc2VsZi5nZXRQYXRoKClcblx0XHRcdFx0dmFyIGRhdGEgPSBwYXJzZVBhdGhuYW1lKHBhdGgpXG5cblx0XHRcdFx0YXNzaWduKGRhdGEucGFyYW1zLCAkd2luZG93Lmhpc3Rvcnkuc3RhdGUpXG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb21waWxlZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChjb21waWxlZFtpXS5jaGVjayhkYXRhKSkge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShjb21waWxlZFtpXS5jb21wb25lbnQsIGRhdGEucGFyYW1zLCBwYXRoLCBjb21waWxlZFtpXS5yb3V0ZSlcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlamVjdChwYXRoLCBkYXRhLnBhcmFtcylcblx0XHRcdH1cblxuXHRcdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSB7XG5cdFx0XHRcdHVuc3Vic2NyaWJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgZmlyZUFzeW5jLCBmYWxzZSlcblx0XHRcdFx0fVxuXHRcdFx0XHQkd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBmaXJlQXN5bmMgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoYXN5bmNJZCkgcmV0dXJuXG5cdFx0XHRcdFx0YXN5bmNJZCA9IGNhbGxBc3luYyhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGFzeW5jSWQgPSBudWxsXG5cdFx0XHRcdFx0XHRyZXNvbHZlUm91dGUoKVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH0sIGZhbHNlKVxuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnByZWZpeFswXSA9PT0gXCIjXCIpIHtcblx0XHRcdFx0dW5zdWJzY3JpYmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsIHJlc29sdmVSb3V0ZSwgZmFsc2UpXG5cdFx0XHRcdH1cblx0XHRcdFx0JHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiaGFzaGNoYW5nZVwiLCByZXNvbHZlUm91dGUsIGZhbHNlKVxuXHRcdFx0fVxuXG5cdFx0XHRzdWJzY3JpYmUodW5zdWJzY3JpYmUpXG5cdFx0XHRyZXNvbHZlUm91dGUoKVxuXHRcdH0sXG5cdH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJpbXBvcnQgYWx3YXlzIGZyb20gJy4vYWx3YXlzJztcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybnMgYGZhbHNlYC4gQW55IHBhc3NlZCBpbiBwYXJhbWV0ZXJzIGFyZSBpZ25vcmVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICogLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5hbHdheXMsIFIuVFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuRigpOyAvLz0+IGZhbHNlXG4gKi9cbnZhciBGID0gLyojX19QVVJFX18qL2Fsd2F5cyhmYWxzZSk7XG5leHBvcnQgZGVmYXVsdCBGOyIsImltcG9ydCBhbHdheXMgZnJvbSAnLi9hbHdheXMnO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAuIEFueSBwYXNzZWQgaW4gcGFyYW1ldGVycyBhcmUgaWdub3JlZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAqIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIuYWx3YXlzLCBSLkZcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLlQoKTsgLy89PiB0cnVlXG4gKi9cbnZhciBUID0gLyojX19QVVJFX18qL2Fsd2F5cyh0cnVlKTtcbmV4cG9ydCBkZWZhdWx0IFQ7IiwiLyoqXG4gKiBBIHNwZWNpYWwgcGxhY2Vob2xkZXIgdmFsdWUgdXNlZCB0byBzcGVjaWZ5IFwiZ2Fwc1wiIHdpdGhpbiBjdXJyaWVkIGZ1bmN0aW9ucyxcbiAqIGFsbG93aW5nIHBhcnRpYWwgYXBwbGljYXRpb24gb2YgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cywgcmVnYXJkbGVzcyBvZlxuICogdGhlaXIgcG9zaXRpb25zLlxuICpcbiAqIElmIGBnYCBpcyBhIGN1cnJpZWQgdGVybmFyeSBmdW5jdGlvbiBhbmQgYF9gIGlzIGBSLl9fYCwgdGhlIGZvbGxvd2luZyBhcmVcbiAqIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEsIDIsIDMpYFxuICogICAtIGBnKF8sIDIsIDMpKDEpYFxuICogICAtIGBnKF8sIF8sIDMpKDEpKDIpYFxuICogICAtIGBnKF8sIF8sIDMpKDEsIDIpYFxuICogICAtIGBnKF8sIDIsIF8pKDEsIDMpYFxuICogICAtIGBnKF8sIDIpKDEpKDMpYFxuICogICAtIGBnKF8sIDIpKDEsIDMpYFxuICogICAtIGBnKF8sIDIpKF8sIDMpKDEpYFxuICpcbiAqIEBjb25zdGFudFxuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC42LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBncmVldCA9IFIucmVwbGFjZSgne25hbWV9JywgUi5fXywgJ0hlbGxvLCB7bmFtZX0hJyk7XG4gKiAgICAgIGdyZWV0KCdBbGljZScpOyAvLz0+ICdIZWxsbywgQWxpY2UhJ1xuICovXG5leHBvcnQgZGVmYXVsdCB7ICdAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInOiB0cnVlIH07IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBBZGRzIHR3byB2YWx1ZXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAc2VlIFIuc3VidHJhY3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmFkZCgyLCAzKTsgICAgICAgLy89PiAgNVxuICogICAgICBSLmFkZCg3KSgxMCk7ICAgICAgLy89PiAxN1xuICovXG52YXIgYWRkID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgcmV0dXJuIE51bWJlcihhKSArIE51bWJlcihiKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgYWRkOyIsImltcG9ydCBfY29uY2F0IGZyb20gJy4vaW50ZXJuYWwvX2NvbmNhdCc7XG5pbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IGN1cnJ5TiBmcm9tICcuL2N1cnJ5Tic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBsaXN0IGl0ZXJhdGlvbiBmdW5jdGlvbiBmcm9tIGFuIGV4aXN0aW5nIG9uZSBieSBhZGRpbmcgdHdvIG5ld1xuICogcGFyYW1ldGVycyB0byBpdHMgY2FsbGJhY2sgZnVuY3Rpb246IHRoZSBjdXJyZW50IGluZGV4LCBhbmQgdGhlIGVudGlyZSBsaXN0LlxuICpcbiAqIFRoaXMgd291bGQgdHVybiwgZm9yIGluc3RhbmNlLCBbYFIubWFwYF0oI21hcCkgZnVuY3Rpb24gaW50byBvbmUgdGhhdFxuICogbW9yZSBjbG9zZWx5IHJlc2VtYmxlcyBgQXJyYXkucHJvdG90eXBlLm1hcGAuIE5vdGUgdGhhdCB0aGlzIHdpbGwgb25seSB3b3JrXG4gKiBmb3IgZnVuY3Rpb25zIGluIHdoaWNoIHRoZSBpdGVyYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24gaXMgdGhlIGZpcnN0XG4gKiBwYXJhbWV0ZXIsIGFuZCB3aGVyZSB0aGUgbGlzdCBpcyB0aGUgbGFzdCBwYXJhbWV0ZXIuIChUaGlzIGxhdHRlciBtaWdodCBiZVxuICogdW5pbXBvcnRhbnQgaWYgdGhlIGxpc3QgcGFyYW1ldGVyIGlzIG5vdCB1c2VkLilcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSAuLi4gLT4gYikgLi4uIC0+IFthXSAtPiAqKSAtPiAoYSAuLi4sIEludCwgW2FdIC0+IGIpIC4uLiAtPiBbYV0gLT4gKilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgbGlzdCBpdGVyYXRpb24gZnVuY3Rpb24gdGhhdCBkb2VzIG5vdCBwYXNzIGluZGV4IG9yIGxpc3QgdG8gaXRzIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQW4gYWx0ZXJlZCBsaXN0IGl0ZXJhdGlvbiBmdW5jdGlvbiB0aGF0IHBhc3NlcyAoaXRlbSwgaW5kZXgsIGxpc3QpIHRvIGl0cyBjYWxsYmFja1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBtYXBJbmRleGVkID0gUi5hZGRJbmRleChSLm1hcCk7XG4gKiAgICAgIG1hcEluZGV4ZWQoKHZhbCwgaWR4KSA9PiBpZHggKyAnLScgKyB2YWwsIFsnZicsICdvJywgJ28nLCAnYicsICdhJywgJ3InXSk7XG4gKiAgICAgIC8vPT4gWycwLWYnLCAnMS1vJywgJzItbycsICczLWInLCAnNC1hJywgJzUtciddXG4gKi9cbnZhciBhZGRJbmRleCA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGFkZEluZGV4KGZuKSB7XG4gIHJldHVybiBjdXJyeU4oZm4ubGVuZ3RoLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIG9yaWdGbiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbGlzdCA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIGFyZ3NbMF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gb3JpZ0ZuLmFwcGx5KHRoaXMsIF9jb25jYXQoYXJndW1lbnRzLCBbaWR4LCBsaXN0XSkpO1xuICAgICAgaWR4ICs9IDE7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgYWRkSW5kZXg7IiwiaW1wb3J0IF9jb25jYXQgZnJvbSAnLi9pbnRlcm5hbC9fY29uY2F0JztcbmltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8qKlxuICogQXBwbGllcyBhIGZ1bmN0aW9uIHRvIHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggb2YgYW4gYXJyYXksIHJldHVybmluZyBhXG4gKiBuZXcgY29weSBvZiB0aGUgYXJyYXkgd2l0aCB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXggcmVwbGFjZWQgd2l0aCB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gYXBwbGljYXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gYSkgLT4gTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBhcHBseS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpZHggVGhlIGluZGV4LlxuICogQHBhcmFtIHtBcnJheXxBcmd1bWVudHN9IGxpc3QgQW4gYXJyYXktbGlrZSBvYmplY3Qgd2hvc2UgdmFsdWVcbiAqICAgICAgICBhdCB0aGUgc3VwcGxpZWQgaW5kZXggd2lsbCBiZSByZXBsYWNlZC5cbiAqIEByZXR1cm4ge0FycmF5fSBBIGNvcHkgb2YgdGhlIHN1cHBsaWVkIGFycmF5LWxpa2Ugb2JqZWN0IHdpdGhcbiAqICAgICAgICAgdGhlIGVsZW1lbnQgYXQgaW5kZXggYGlkeGAgcmVwbGFjZWQgd2l0aCB0aGUgdmFsdWVcbiAqICAgICAgICAgcmV0dXJuZWQgYnkgYXBwbHlpbmcgYGZuYCB0byB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAqIEBzZWUgUi51cGRhdGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmFkanVzdChSLmFkZCgxMCksIDEsIFsxLCAyLCAzXSk7ICAgICAvLz0+IFsxLCAxMiwgM11cbiAqICAgICAgUi5hZGp1c3QoUi5hZGQoMTApKSgxKShbMSwgMiwgM10pOyAgICAgLy89PiBbMSwgMTIsIDNdXG4gKiBAc3ltYiBSLmFkanVzdChmLCAtMSwgW2EsIGJdKSA9IFthLCBmKGIpXVxuICogQHN5bWIgUi5hZGp1c3QoZiwgMCwgW2EsIGJdKSA9IFtmKGEpLCBiXVxuICovXG52YXIgYWRqdXN0ID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gYWRqdXN0KGZuLCBpZHgsIGxpc3QpIHtcbiAgaWYgKGlkeCA+PSBsaXN0Lmxlbmd0aCB8fCBpZHggPCAtbGlzdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuICB2YXIgc3RhcnQgPSBpZHggPCAwID8gbGlzdC5sZW5ndGggOiAwO1xuICB2YXIgX2lkeCA9IHN0YXJ0ICsgaWR4O1xuICB2YXIgX2xpc3QgPSBfY29uY2F0KGxpc3QpO1xuICBfbGlzdFtfaWR4XSA9IGZuKGxpc3RbX2lkeF0pO1xuICByZXR1cm4gX2xpc3Q7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGFkanVzdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfeGFsbCBmcm9tICcuL2ludGVybmFsL194YWxsJztcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgb2YgdGhlIGxpc3QgbWF0Y2ggdGhlIHByZWRpY2F0ZSwgYGZhbHNlYCBpZlxuICogdGhlcmUgYXJlIGFueSB0aGF0IGRvbid0LlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBhbGxgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByZWRpY2F0ZSBpcyBzYXRpc2ZpZWQgYnkgZXZlcnkgZWxlbWVudCwgYGZhbHNlYFxuICogICAgICAgICBvdGhlcndpc2UuXG4gKiBAc2VlIFIuYW55LCBSLm5vbmUsIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGVxdWFsczMgPSBSLmVxdWFscygzKTtcbiAqICAgICAgUi5hbGwoZXF1YWxzMykoWzMsIDMsIDMsIDNdKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuYWxsKGVxdWFsczMpKFszLCAzLCAxLCAzXSk7IC8vPT4gZmFsc2VcbiAqL1xudmFyIGFsbCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovX2Rpc3BhdGNoYWJsZShbJ2FsbCddLCBfeGFsbCwgZnVuY3Rpb24gYWxsKGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICBpZiAoIWZuKGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KSk7XG5leHBvcnQgZGVmYXVsdCBhbGw7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBjdXJyeU4gZnJvbSAnLi9jdXJyeU4nO1xuaW1wb3J0IG1heCBmcm9tICcuL21heCc7XG5pbXBvcnQgcGx1Y2sgZnJvbSAnLi9wbHVjayc7XG5pbXBvcnQgcmVkdWNlIGZyb20gJy4vcmVkdWNlJztcblxuLyoqXG4gKiBUYWtlcyBhIGxpc3Qgb2YgcHJlZGljYXRlcyBhbmQgcmV0dXJucyBhIHByZWRpY2F0ZSB0aGF0IHJldHVybnMgdHJ1ZSBmb3IgYVxuICogZ2l2ZW4gbGlzdCBvZiBhcmd1bWVudHMgaWYgZXZlcnkgb25lIG9mIHRoZSBwcm92aWRlZCBwcmVkaWNhdGVzIGlzIHNhdGlzZmllZFxuICogYnkgdGhvc2UgYXJndW1lbnRzLlxuICpcbiAqIFRoZSBmdW5jdGlvbiByZXR1cm5lZCBpcyBhIGN1cnJpZWQgZnVuY3Rpb24gd2hvc2UgYXJpdHkgbWF0Y2hlcyB0aGF0IG9mIHRoZVxuICogaGlnaGVzdC1hcml0eSBwcmVkaWNhdGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgWygqLi4uIC0+IEJvb2xlYW4pXSAtPiAoKi4uLiAtPiBCb29sZWFuKVxuICogQHBhcmFtIHtBcnJheX0gcHJlZGljYXRlcyBBbiBhcnJheSBvZiBwcmVkaWNhdGVzIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGNvbWJpbmVkIHByZWRpY2F0ZVxuICogQHNlZSBSLmFueVBhc3NcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaXNRdWVlbiA9IFIucHJvcEVxKCdyYW5rJywgJ1EnKTtcbiAqICAgICAgdmFyIGlzU3BhZGUgPSBSLnByb3BFcSgnc3VpdCcsICfimaDvuI4nKTtcbiAqICAgICAgdmFyIGlzUXVlZW5PZlNwYWRlcyA9IFIuYWxsUGFzcyhbaXNRdWVlbiwgaXNTcGFkZV0pO1xuICpcbiAqICAgICAgaXNRdWVlbk9mU3BhZGVzKHtyYW5rOiAnUScsIHN1aXQ6ICfimaPvuI4nfSk7IC8vPT4gZmFsc2VcbiAqICAgICAgaXNRdWVlbk9mU3BhZGVzKHtyYW5rOiAnUScsIHN1aXQ6ICfimaDvuI4nfSk7IC8vPT4gdHJ1ZVxuICovXG52YXIgYWxsUGFzcyA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGFsbFBhc3MocHJlZHMpIHtcbiAgcmV0dXJuIGN1cnJ5TihyZWR1Y2UobWF4LCAwLCBwbHVjaygnbGVuZ3RoJywgcHJlZHMpKSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciBsZW4gPSBwcmVkcy5sZW5ndGg7XG4gICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgaWYgKCFwcmVkc1tpZHhdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgYWxsUGFzczsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIHRoZSBnaXZlbiB2YWx1ZS4gTm90ZSB0aGF0IGZvclxuICogbm9uLXByaW1pdGl2ZXMgdGhlIHZhbHVlIHJldHVybmVkIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGtub3duIGFzIGBjb25zdGAsIGBjb25zdGFudGAsIG9yIGBLYCAoZm9yIEsgY29tYmluYXRvcikgaW5cbiAqIG90aGVyIGxhbmd1YWdlcyBhbmQgbGlicmFyaWVzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIGEgLT4gKCogLT4gYSlcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgZnVuY3Rpb25cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIEZ1bmN0aW9uIDo6ICogLT4gdmFsLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB0ID0gUi5hbHdheXMoJ1RlZScpO1xuICogICAgICB0KCk7IC8vPT4gJ1RlZSdcbiAqL1xudmFyIGFsd2F5cyA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGFsd2F5cyh2YWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9O1xufSk7XG5leHBvcnQgZGVmYXVsdCBhbHdheXM7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGFyZ3VtZW50cyBhcmUgYHRydWVgOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyBhIC0+IGIgLT4gYSB8IGJcbiAqIEBwYXJhbSB7QW55fSBhXG4gKiBAcGFyYW0ge0FueX0gYlxuICogQHJldHVybiB7QW55fSB0aGUgZmlyc3QgYXJndW1lbnQgaWYgaXQgaXMgZmFsc3ksIG90aGVyd2lzZSB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICogQHNlZSBSLmJvdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmFuZCh0cnVlLCB0cnVlKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuYW5kKHRydWUsIGZhbHNlKTsgLy89PiBmYWxzZVxuICogICAgICBSLmFuZChmYWxzZSwgdHJ1ZSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5hbmQoZmFsc2UsIGZhbHNlKTsgLy89PiBmYWxzZVxuICovXG52YXIgYW5kID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gYW5kKGEsIGIpIHtcbiAgcmV0dXJuIGEgJiYgYjtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgYW5kOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tICcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnO1xuaW1wb3J0IF94YW55IGZyb20gJy4vaW50ZXJuYWwvX3hhbnknO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGF0IGxlYXN0IG9uZSBvZiBlbGVtZW50cyBvZiB0aGUgbGlzdCBtYXRjaCB0aGUgcHJlZGljYXRlLFxuICogYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGFueWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJlZGljYXRlIGlzIHNhdGlzZmllZCBieSBhdCBsZWFzdCBvbmUgZWxlbWVudCwgYGZhbHNlYFxuICogICAgICAgICBvdGhlcndpc2UuXG4gKiBAc2VlIFIuYWxsLCBSLm5vbmUsIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGxlc3NUaGFuMCA9IFIuZmxpcChSLmx0KSgwKTtcbiAqICAgICAgdmFyIGxlc3NUaGFuMiA9IFIuZmxpcChSLmx0KSgyKTtcbiAqICAgICAgUi5hbnkobGVzc1RoYW4wKShbMSwgMl0pOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuYW55KGxlc3NUaGFuMikoWzEsIDJdKTsgLy89PiB0cnVlXG4gKi9cbnZhciBhbnkgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoWydhbnknXSwgX3hhbnksIGZ1bmN0aW9uIGFueShmbiwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59KSk7XG5leHBvcnQgZGVmYXVsdCBhbnk7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBjdXJyeU4gZnJvbSAnLi9jdXJyeU4nO1xuaW1wb3J0IG1heCBmcm9tICcuL21heCc7XG5pbXBvcnQgcGx1Y2sgZnJvbSAnLi9wbHVjayc7XG5pbXBvcnQgcmVkdWNlIGZyb20gJy4vcmVkdWNlJztcblxuLyoqXG4gKiBUYWtlcyBhIGxpc3Qgb2YgcHJlZGljYXRlcyBhbmQgcmV0dXJucyBhIHByZWRpY2F0ZSB0aGF0IHJldHVybnMgdHJ1ZSBmb3IgYVxuICogZ2l2ZW4gbGlzdCBvZiBhcmd1bWVudHMgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSBwcm92aWRlZCBwcmVkaWNhdGVzIGlzXG4gKiBzYXRpc2ZpZWQgYnkgdGhvc2UgYXJndW1lbnRzLlxuICpcbiAqIFRoZSBmdW5jdGlvbiByZXR1cm5lZCBpcyBhIGN1cnJpZWQgZnVuY3Rpb24gd2hvc2UgYXJpdHkgbWF0Y2hlcyB0aGF0IG9mIHRoZVxuICogaGlnaGVzdC1hcml0eSBwcmVkaWNhdGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgWygqLi4uIC0+IEJvb2xlYW4pXSAtPiAoKi4uLiAtPiBCb29sZWFuKVxuICogQHBhcmFtIHtBcnJheX0gcHJlZGljYXRlcyBBbiBhcnJheSBvZiBwcmVkaWNhdGVzIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGNvbWJpbmVkIHByZWRpY2F0ZVxuICogQHNlZSBSLmFsbFBhc3NcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaXNDbHViID0gUi5wcm9wRXEoJ3N1aXQnLCAn4pmjJyk7XG4gKiAgICAgIHZhciBpc1NwYWRlID0gUi5wcm9wRXEoJ3N1aXQnLCAn4pmgJyk7XG4gKiAgICAgIHZhciBpc0JsYWNrQ2FyZCA9IFIuYW55UGFzcyhbaXNDbHViLCBpc1NwYWRlXSk7XG4gKlxuICogICAgICBpc0JsYWNrQ2FyZCh7cmFuazogJzEwJywgc3VpdDogJ+KZoyd9KTsgLy89PiB0cnVlXG4gKiAgICAgIGlzQmxhY2tDYXJkKHtyYW5rOiAnUScsIHN1aXQ6ICfimaAnfSk7IC8vPT4gdHJ1ZVxuICogICAgICBpc0JsYWNrQ2FyZCh7cmFuazogJ1EnLCBzdWl0OiAn4pmmJ30pOyAvLz0+IGZhbHNlXG4gKi9cbnZhciBhbnlQYXNzID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gYW55UGFzcyhwcmVkcykge1xuICByZXR1cm4gY3VycnlOKHJlZHVjZShtYXgsIDAsIHBsdWNrKCdsZW5ndGgnLCBwcmVkcykpLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIGxlbiA9IHByZWRzLmxlbmd0aDtcbiAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICBpZiAocHJlZHNbaWR4XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGFueVBhc3M7IiwiaW1wb3J0IF9jb25jYXQgZnJvbSAnLi9pbnRlcm5hbC9fY29uY2F0JztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX3JlZHVjZSBmcm9tICcuL2ludGVybmFsL19yZWR1Y2UnO1xuaW1wb3J0IG1hcCBmcm9tICcuL21hcCc7XG5cbi8qKlxuICogYXAgYXBwbGllcyBhIGxpc3Qgb2YgZnVuY3Rpb25zIHRvIGEgbGlzdCBvZiB2YWx1ZXMuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGFwYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC4gQWxzb1xuICogdHJlYXRzIGN1cnJpZWQgZnVuY3Rpb25zIGFzIGFwcGxpY2F0aXZlcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBbYSAtPiBiXSAtPiBbYV0gLT4gW2JdXG4gKiBAc2lnIEFwcGx5IGYgPT4gZiAoYSAtPiBiKSAtPiBmIGEgLT4gZiBiXG4gKiBAc2lnIChhIC0+IGIgLT4gYykgLT4gKGEgLT4gYikgLT4gKGEgLT4gYylcbiAqIEBwYXJhbSB7Kn0gYXBwbHlGXG4gKiBAcGFyYW0geyp9IGFwcGx5WFxuICogQHJldHVybiB7Kn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmFwKFtSLm11bHRpcGx5KDIpLCBSLmFkZCgzKV0sIFsxLDIsM10pOyAvLz0+IFsyLCA0LCA2LCA0LCA1LCA2XVxuICogICAgICBSLmFwKFtSLmNvbmNhdCgndGFzdHkgJyksIFIudG9VcHBlcl0sIFsncGl6emEnLCAnc2FsYWQnXSk7IC8vPT4gW1widGFzdHkgcGl6emFcIiwgXCJ0YXN0eSBzYWxhZFwiLCBcIlBJWlpBXCIsIFwiU0FMQURcIl1cbiAqXG4gKiAgICAgIC8vIFIuYXAgY2FuIGFsc28gYmUgdXNlZCBhcyBTIGNvbWJpbmF0b3JcbiAqICAgICAgLy8gd2hlbiBvbmx5IHR3byBmdW5jdGlvbnMgYXJlIHBhc3NlZFxuICogICAgICBSLmFwKFIuY29uY2F0LCBSLnRvVXBwZXIpKCdSYW1kYScpIC8vPT4gJ1JhbWRhUkFNREEnXG4gKiBAc3ltYiBSLmFwKFtmLCBnXSwgW2EsIGJdKSA9IFtmKGEpLCBmKGIpLCBnKGEpLCBnKGIpXVxuICovXG52YXIgYXAgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBhcChhcHBseUYsIGFwcGx5WCkge1xuICByZXR1cm4gdHlwZW9mIGFwcGx5WFsnZmFudGFzeS1sYW5kL2FwJ10gPT09ICdmdW5jdGlvbicgPyBhcHBseVhbJ2ZhbnRhc3ktbGFuZC9hcCddKGFwcGx5RikgOiB0eXBlb2YgYXBwbHlGLmFwID09PSAnZnVuY3Rpb24nID8gYXBwbHlGLmFwKGFwcGx5WCkgOiB0eXBlb2YgYXBwbHlGID09PSAnZnVuY3Rpb24nID8gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gYXBwbHlGKHgpKGFwcGx5WCh4KSk7XG4gIH0gOlxuICAvLyBlbHNlXG4gIF9yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZikge1xuICAgIHJldHVybiBfY29uY2F0KGFjYywgbWFwKGYsIGFwcGx5WCkpO1xuICB9LCBbXSwgYXBwbHlGKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgYXA7IiwiaW1wb3J0IF9hcGVydHVyZSBmcm9tICcuL2ludGVybmFsL19hcGVydHVyZSc7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfeGFwZXJ0dXJlIGZyb20gJy4vaW50ZXJuYWwvX3hhcGVydHVyZSc7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0LCBjb21wb3NlZCBvZiBuLXR1cGxlcyBvZiBjb25zZWN1dGl2ZSBlbGVtZW50cy4gSWYgYG5gIGlzXG4gKiBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgbGlzdCwgYW4gZW1wdHkgbGlzdCBpcyByZXR1cm5lZC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTIuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbW2FdXVxuICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIHR1cGxlcyB0byBjcmVhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gc3BsaXQgaW50byBgbmAtbGVuZ3RoIHR1cGxlc1xuICogQHJldHVybiB7QXJyYXl9IFRoZSByZXN1bHRpbmcgbGlzdCBvZiBgbmAtbGVuZ3RoIHR1cGxlc1xuICogQHNlZSBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYXBlcnR1cmUoMiwgWzEsIDIsIDMsIDQsIDVdKTsgLy89PiBbWzEsIDJdLCBbMiwgM10sIFszLCA0XSwgWzQsIDVdXVxuICogICAgICBSLmFwZXJ0dXJlKDMsIFsxLCAyLCAzLCA0LCA1XSk7IC8vPT4gW1sxLCAyLCAzXSwgWzIsIDMsIDRdLCBbMywgNCwgNV1dXG4gKiAgICAgIFIuYXBlcnR1cmUoNywgWzEsIDIsIDMsIDQsIDVdKTsgLy89PiBbXVxuICovXG52YXIgYXBlcnR1cmUgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoW10sIF94YXBlcnR1cmUsIF9hcGVydHVyZSkpO1xuZXhwb3J0IGRlZmF1bHQgYXBlcnR1cmU7IiwiaW1wb3J0IF9jb25jYXQgZnJvbSAnLi9pbnRlcm5hbC9fY29uY2F0JztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIGNvbnRlbnRzIG9mIHRoZSBnaXZlbiBsaXN0LCBmb2xsb3dlZCBieVxuICogdGhlIGdpdmVuIGVsZW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7Kn0gZWwgVGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBlbmQgb2YgdGhlIG5ldyBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCBvZiBlbGVtZW50cyB0byBhZGQgYSBuZXcgaXRlbSB0by5cbiAqICAgICAgICBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgZWxlbWVudHMgb2YgdGhlIG9sZCBsaXN0IGZvbGxvd2VkIGJ5IGBlbGAuXG4gKiBAc2VlIFIucHJlcGVuZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYXBwZW5kKCd0ZXN0cycsIFsnd3JpdGUnLCAnbW9yZSddKTsgLy89PiBbJ3dyaXRlJywgJ21vcmUnLCAndGVzdHMnXVxuICogICAgICBSLmFwcGVuZCgndGVzdHMnLCBbXSk7IC8vPT4gWyd0ZXN0cyddXG4gKiAgICAgIFIuYXBwZW5kKFsndGVzdHMnXSwgWyd3cml0ZScsICdtb3JlJ10pOyAvLz0+IFsnd3JpdGUnLCAnbW9yZScsIFsndGVzdHMnXV1cbiAqL1xudmFyIGFwcGVuZCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGFwcGVuZChlbCwgbGlzdCkge1xuICByZXR1cm4gX2NvbmNhdChsaXN0LCBbZWxdKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgYXBwZW5kOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogQXBwbGllcyBmdW5jdGlvbiBgZm5gIHRvIHRoZSBhcmd1bWVudCBsaXN0IGBhcmdzYC4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gKiBjcmVhdGluZyBhIGZpeGVkLWFyaXR5IGZ1bmN0aW9uIGZyb20gYSB2YXJpYWRpYyBmdW5jdGlvbi4gYGZuYCBzaG91bGQgYmUgYVxuICogYm91bmQgZnVuY3Rpb24gaWYgY29udGV4dCBpcyBzaWduaWZpY2FudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC43LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKi4uLiAtPiBhKSAtPiBbKl0gLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYGFyZ3NgXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gY2FsbCBgZm5gIHdpdGhcbiAqIEByZXR1cm4geyp9IHJlc3VsdCBUaGUgcmVzdWx0LCBlcXVpdmFsZW50IHRvIGBmbiguLi5hcmdzKWBcbiAqIEBzZWUgUi5jYWxsLCBSLnVuYXBwbHlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbnVtcyA9IFsxLCAyLCAzLCAtOTksIDQyLCA2LCA3XTtcbiAqICAgICAgUi5hcHBseShNYXRoLm1heCwgbnVtcyk7IC8vPT4gNDJcbiAqIEBzeW1iIFIuYXBwbHkoZiwgW2EsIGIsIGNdKSA9IGYoYSwgYiwgYylcbiAqL1xudmFyIGFwcGx5ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gYXBwbHkoZm4sIGFyZ3MpIHtcbiAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBhcHBseTsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IGFwcGx5IGZyb20gJy4vYXBwbHknO1xuaW1wb3J0IGN1cnJ5TiBmcm9tICcuL2N1cnJ5Tic7XG5pbXBvcnQgbWFwIGZyb20gJy4vbWFwJztcbmltcG9ydCBtYXggZnJvbSAnLi9tYXgnO1xuaW1wb3J0IHBsdWNrIGZyb20gJy4vcGx1Y2snO1xuaW1wb3J0IHJlZHVjZSBmcm9tICcuL3JlZHVjZSc7XG5pbXBvcnQgdmFsdWVzIGZyb20gJy4vdmFsdWVzJztcblxuLyoqXG4gKiBHaXZlbiBhIHNwZWMgb2JqZWN0IHJlY3Vyc2l2ZWx5IG1hcHBpbmcgcHJvcGVydGllcyB0byBmdW5jdGlvbnMsIGNyZWF0ZXMgYVxuICogZnVuY3Rpb24gcHJvZHVjaW5nIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBzdHJ1Y3R1cmUsIGJ5IG1hcHBpbmcgZWFjaCBwcm9wZXJ0eVxuICogdG8gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGl0cyBhc3NvY2lhdGVkIGZ1bmN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcge2s6ICgoYSwgYiwgLi4uLCBtKSAtPiB2KX0gLT4gKChhLCBiLCAuLi4sIG0pIC0+IHtrOiB2fSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIGFuIG9iamVjdCByZWN1cnNpdmVseSBtYXBwaW5nIHByb3BlcnRpZXMgdG8gZnVuY3Rpb25zIGZvclxuICogICAgICAgIHByb2R1Y2luZyB0aGUgdmFsdWVzIGZvciB0aGVzZSBwcm9wZXJ0aWVzLlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBzdHJ1Y3R1cmVcbiAqIGFzIGBzcGVjJywgd2l0aCBlYWNoIHByb3BlcnR5IHNldCB0byB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgY2FsbGluZyBpdHNcbiAqIGFzc29jaWF0ZWQgZnVuY3Rpb24gd2l0aCB0aGUgc3VwcGxpZWQgYXJndW1lbnRzLlxuICogQHNlZSBSLmNvbnZlcmdlLCBSLmp1eHRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZ2V0TWV0cmljcyA9IFIuYXBwbHlTcGVjKHtcbiAqICAgICAgICBzdW06IFIuYWRkLFxuICogICAgICAgIG5lc3RlZDogeyBtdWw6IFIubXVsdGlwbHkgfVxuICogICAgICB9KTtcbiAqICAgICAgZ2V0TWV0cmljcygyLCA0KTsgLy8gPT4geyBzdW06IDYsIG5lc3RlZDogeyBtdWw6IDggfSB9XG4gKiBAc3ltYiBSLmFwcGx5U3BlYyh7IHg6IGYsIHk6IHsgejogZyB9IH0pKGEsIGIpID0geyB4OiBmKGEsIGIpLCB5OiB7IHo6IGcoYSwgYikgfSB9XG4gKi9cbnZhciBhcHBseVNwZWMgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBhcHBseVNwZWMoc3BlYykge1xuICBzcGVjID0gbWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09ICdmdW5jdGlvbicgPyB2IDogYXBwbHlTcGVjKHYpO1xuICB9LCBzcGVjKTtcbiAgcmV0dXJuIGN1cnJ5TihyZWR1Y2UobWF4LCAwLCBwbHVjaygnbGVuZ3RoJywgdmFsdWVzKHNwZWMpKSksIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4gYXBwbHkoZiwgYXJncyk7XG4gICAgfSwgc3BlYyk7XG4gIH0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBhcHBseVNwZWM7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4qIFRha2VzIGEgdmFsdWUgYW5kIGFwcGxpZXMgYSBmdW5jdGlvbiB0byBpdC5cbipcbiogVGhpcyBmdW5jdGlvbiBpcyBhbHNvIGtub3duIGFzIHRoZSBgdGhydXNoYCBjb21iaW5hdG9yLlxuKlxuKiBAZnVuY1xuKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI1LjBcbiogQGNhdGVnb3J5IEZ1bmN0aW9uXG4qIEBzaWcgYSAtPiAoYSAtPiBiKSAtPiBiXG4qIEBwYXJhbSB7Kn0geCBUaGUgdmFsdWVcbiogQHBhcmFtIHtGdW5jdGlvbn0gZiBUaGUgZnVuY3Rpb24gdG8gYXBwbHlcbiogQHJldHVybiB7Kn0gVGhlIHJlc3VsdCBvZiBhcHBseWluZyBgZmAgdG8gYHhgXG4qIEBleGFtcGxlXG4qXG4qICAgICAgdmFyIHQ0MiA9IFIuYXBwbHlUbyg0Mik7XG4qICAgICAgdDQyKFIuaWRlbnRpdHkpOyAvLz0+IDQyXG4qICAgICAgdDQyKFIuYWRkKDEpKTsgLy89PiA0M1xuKi9cbnZhciBhcHBseVRvID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gYXBwbHlUbyh4LCBmKSB7XG4gIHJldHVybiBmKHgpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBhcHBseVRvOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8qKlxuICogTWFrZXMgYW4gYXNjZW5kaW5nIGNvbXBhcmF0b3IgZnVuY3Rpb24gb3V0IG9mIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdmFsdWVcbiAqIHRoYXQgY2FuIGJlIGNvbXBhcmVkIHdpdGggYDxgIGFuZCBgPmAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjMuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE9yZCBiID0+IChhIC0+IGIpIC0+IGEgLT4gYSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gb2YgYXJpdHkgb25lIHRoYXQgcmV0dXJucyBhIHZhbHVlIHRoYXQgY2FuIGJlIGNvbXBhcmVkXG4gKiBAcGFyYW0geyp9IGEgVGhlIGZpcnN0IGl0ZW0gdG8gYmUgY29tcGFyZWQuXG4gKiBAcGFyYW0geyp9IGIgVGhlIHNlY29uZCBpdGVtIHRvIGJlIGNvbXBhcmVkLlxuICogQHJldHVybiB7TnVtYmVyfSBgLTFgIGlmIGZuKGEpIDwgZm4oYiksIGAxYCBpZiBmbihiKSA8IGZuKGEpLCBvdGhlcndpc2UgYDBgXG4gKiBAc2VlIFIuZGVzY2VuZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBieUFnZSA9IFIuYXNjZW5kKFIucHJvcCgnYWdlJykpO1xuICogICAgICB2YXIgcGVvcGxlID0gW1xuICogICAgICAgIC8vIC4uLlxuICogICAgICBdO1xuICogICAgICB2YXIgcGVvcGxlQnlZb3VuZ2VzdEZpcnN0ID0gUi5zb3J0KGJ5QWdlLCBwZW9wbGUpO1xuICovXG52YXIgYXNjZW5kID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gYXNjZW5kKGZuLCBhLCBiKSB7XG4gIHZhciBhYSA9IGZuKGEpO1xuICB2YXIgYmIgPSBmbihiKTtcbiAgcmV0dXJuIGFhIDwgYmIgPyAtMSA6IGFhID4gYmIgPyAxIDogMDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgYXNjZW5kOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8qKlxuICogTWFrZXMgYSBzaGFsbG93IGNsb25lIG9mIGFuIG9iamVjdCwgc2V0dGluZyBvciBvdmVycmlkaW5nIHRoZSBzcGVjaWZpZWRcbiAqIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIHZhbHVlLiBOb3RlIHRoYXQgdGhpcyBjb3BpZXMgYW5kIGZsYXR0ZW5zIHByb3RvdHlwZVxuICogcHJvcGVydGllcyBvbnRvIHRoZSBuZXcgb2JqZWN0IGFzIHdlbGwuIEFsbCBub24tcHJpbWl0aXZlIHByb3BlcnRpZXMgYXJlXG4gKiBjb3BpZWQgYnkgcmVmZXJlbmNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjguMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBTdHJpbmcgLT4gYSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBUaGUgcHJvcGVydHkgbmFtZSB0byBzZXRcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSBuZXcgdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjbG9uZVxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBvYmplY3QgZXF1aXZhbGVudCB0byB0aGUgb3JpZ2luYWwgZXhjZXB0IGZvciB0aGUgY2hhbmdlZCBwcm9wZXJ0eS5cbiAqIEBzZWUgUi5kaXNzb2NcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmFzc29jKCdjJywgMywge2E6IDEsIGI6IDJ9KTsgLy89PiB7YTogMSwgYjogMiwgYzogM31cbiAqL1xudmFyIGFzc29jID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gYXNzb2MocHJvcCwgdmFsLCBvYmopIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIG9iaikge1xuICAgIHJlc3VsdFtwXSA9IG9ialtwXTtcbiAgfVxuICByZXN1bHRbcHJvcF0gPSB2YWw7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGFzc29jOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgX2hhcyBmcm9tICcuL2ludGVybmFsL19oYXMnO1xuaW1wb3J0IF9pc0FycmF5IGZyb20gJy4vaW50ZXJuYWwvX2lzQXJyYXknO1xuaW1wb3J0IF9pc0ludGVnZXIgZnJvbSAnLi9pbnRlcm5hbC9faXNJbnRlZ2VyJztcbmltcG9ydCBhc3NvYyBmcm9tICcuL2Fzc29jJztcbmltcG9ydCBpc05pbCBmcm9tICcuL2lzTmlsJztcblxuLyoqXG4gKiBNYWtlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYW4gb2JqZWN0LCBzZXR0aW5nIG9yIG92ZXJyaWRpbmcgdGhlIG5vZGVzIHJlcXVpcmVkXG4gKiB0byBjcmVhdGUgdGhlIGdpdmVuIHBhdGgsIGFuZCBwbGFjaW5nIHRoZSBzcGVjaWZpYyB2YWx1ZSBhdCB0aGUgdGFpbCBlbmQgb2ZcbiAqIHRoYXQgcGF0aC4gTm90ZSB0aGF0IHRoaXMgY29waWVzIGFuZCBmbGF0dGVucyBwcm90b3R5cGUgcHJvcGVydGllcyBvbnRvIHRoZVxuICogbmV3IG9iamVjdCBhcyB3ZWxsLiBBbGwgbm9uLXByaW1pdGl2ZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgYnkgcmVmZXJlbmNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjguMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIElkeCA9IFN0cmluZyB8IEludFxuICogQHNpZyBbSWR4XSAtPiBhIC0+IHthfSAtPiB7YX1cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggdGhlIHBhdGggdG8gc2V0XG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgbmV3IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IGVxdWl2YWxlbnQgdG8gdGhlIG9yaWdpbmFsIGV4Y2VwdCBhbG9uZyB0aGUgc3BlY2lmaWVkIHBhdGguXG4gKiBAc2VlIFIuZGlzc29jUGF0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYXNzb2NQYXRoKFsnYScsICdiJywgJ2MnXSwgNDIsIHthOiB7Yjoge2M6IDB9fX0pOyAvLz0+IHthOiB7Yjoge2M6IDQyfX19XG4gKlxuICogICAgICAvLyBBbnkgbWlzc2luZyBvciBub24tb2JqZWN0IGtleXMgaW4gcGF0aCB3aWxsIGJlIG92ZXJyaWRkZW5cbiAqICAgICAgUi5hc3NvY1BhdGgoWydhJywgJ2InLCAnYyddLCA0Miwge2E6IDV9KTsgLy89PiB7YToge2I6IHtjOiA0Mn19fVxuICovXG52YXIgYXNzb2NQYXRoID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gYXNzb2NQYXRoKHBhdGgsIHZhbCwgb2JqKSB7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdmFyIGlkeCA9IHBhdGhbMF07XG4gIGlmIChwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgbmV4dE9iaiA9ICFpc05pbChvYmopICYmIF9oYXMoaWR4LCBvYmopID8gb2JqW2lkeF0gOiBfaXNJbnRlZ2VyKHBhdGhbMV0pID8gW10gOiB7fTtcbiAgICB2YWwgPSBhc3NvY1BhdGgoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwocGF0aCwgMSksIHZhbCwgbmV4dE9iaik7XG4gIH1cbiAgaWYgKF9pc0ludGVnZXIoaWR4KSAmJiBfaXNBcnJheShvYmopKSB7XG4gICAgdmFyIGFyciA9IFtdLmNvbmNhdChvYmopO1xuICAgIGFycltpZHhdID0gdmFsO1xuICAgIHJldHVybiBhcnI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFzc29jKGlkeCwgdmFsLCBvYmopO1xuICB9XG59KTtcbmV4cG9ydCBkZWZhdWx0IGFzc29jUGF0aDsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IG5BcnkgZnJvbSAnLi9uQXJ5JztcblxuLyoqXG4gKiBXcmFwcyBhIGZ1bmN0aW9uIG9mIGFueSBhcml0eSAoaW5jbHVkaW5nIG51bGxhcnkpIGluIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzXG4gKiBleGFjdGx5IDIgcGFyYW1ldGVycy4gQW55IGV4dHJhbmVvdXMgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlXG4gKiBzdXBwbGllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKiAtPiBjKSAtPiAoYSwgYiAtPiBjKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgYGZuYC4gVGhlIG5ldyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIG9mXG4gKiAgICAgICAgIGFyaXR5IDIuXG4gKiBAc2VlIFIubkFyeSwgUi51bmFyeVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB0YWtlc1RocmVlQXJncyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAqICAgICAgICByZXR1cm4gW2EsIGIsIGNdO1xuICogICAgICB9O1xuICogICAgICB0YWtlc1RocmVlQXJncy5sZW5ndGg7IC8vPT4gM1xuICogICAgICB0YWtlc1RocmVlQXJncygxLCAyLCAzKTsgLy89PiBbMSwgMiwgM11cbiAqXG4gKiAgICAgIHZhciB0YWtlc1R3b0FyZ3MgPSBSLmJpbmFyeSh0YWtlc1RocmVlQXJncyk7XG4gKiAgICAgIHRha2VzVHdvQXJncy5sZW5ndGg7IC8vPT4gMlxuICogICAgICAvLyBPbmx5IDIgYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAqICAgICAgdGFrZXNUd29BcmdzKDEsIDIsIDMpOyAvLz0+IFsxLCAyLCB1bmRlZmluZWRdXG4gKiBAc3ltYiBSLmJpbmFyeShmKShhLCBiLCBjKSA9IGYoYSwgYilcbiAqL1xudmFyIGJpbmFyeSA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGJpbmFyeShmbikge1xuICByZXR1cm4gbkFyeSgyLCBmbik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGJpbmFyeTsiLCJpbXBvcnQgX2FyaXR5IGZyb20gJy4vaW50ZXJuYWwvX2FyaXR5JztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgYm91bmQgdG8gYSBjb250ZXh0LlxuICogTm90ZTogYFIuYmluZGAgZG9lcyBub3QgcHJvdmlkZSB0aGUgYWRkaXRpb25hbCBhcmd1bWVudC1iaW5kaW5nIGNhcGFiaWxpdGllcyBvZlxuICogW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC42LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyAoKiAtPiAqKSAtPiB7Kn0gLT4gKCogLT4gKilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBiaW5kIHRvIGNvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzT2JqIFRoZSBjb250ZXh0IHRvIGJpbmQgYGZuYCB0b1xuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgaW4gdGhlIGNvbnRleHQgb2YgYHRoaXNPYmpgLlxuICogQHNlZSBSLnBhcnRpYWxcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbG9nID0gUi5iaW5kKGNvbnNvbGUubG9nLCBjb25zb2xlKTtcbiAqICAgICAgUi5waXBlKFIuYXNzb2MoJ2EnLCAyKSwgUi50YXAobG9nKSwgUi5hc3NvYygnYScsIDMpKSh7YTogMX0pOyAvLz0+IHthOiAzfVxuICogICAgICAvLyBsb2dzIHthOiAyfVxuICogQHN5bWIgUi5iaW5kKGYsIG8pKGEsIGIpID0gZi5jYWxsKG8sIGEsIGIpXG4gKi9cbnZhciBiaW5kID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gYmluZChmbiwgdGhpc09iaikge1xuICByZXR1cm4gX2FyaXR5KGZuLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzT2JqLCBhcmd1bWVudHMpO1xuICB9KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgYmluZDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9pc0Z1bmN0aW9uIGZyb20gJy4vaW50ZXJuYWwvX2lzRnVuY3Rpb24nO1xuaW1wb3J0IGFuZCBmcm9tICcuL2FuZCc7XG5pbXBvcnQgbGlmdCBmcm9tICcuL2xpZnQnO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gd2hpY2ggY2FsbHMgdGhlIHR3byBwcm92aWRlZCBmdW5jdGlvbnMgYW5kIHJldHVybnMgdGhlIGAmJmBcbiAqIG9mIHRoZSByZXN1bHRzLlxuICogSXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBmaXJzdCBmdW5jdGlvbiBpZiBpdCBpcyBmYWxzZS15IGFuZCB0aGUgcmVzdWx0XG4gKiBvZiB0aGUgc2Vjb25kIGZ1bmN0aW9uIG90aGVyd2lzZS4gTm90ZSB0aGF0IHRoaXMgaXMgc2hvcnQtY2lyY3VpdGVkLFxuICogbWVhbmluZyB0aGF0IHRoZSBzZWNvbmQgZnVuY3Rpb24gd2lsbCBub3QgYmUgaW52b2tlZCBpZiB0aGUgZmlyc3QgcmV0dXJucyBhXG4gKiBmYWxzZS15IHZhbHVlLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIGZ1bmN0aW9ucywgYFIuYm90aGAgYWxzbyBhY2NlcHRzIGFueSBmYW50YXN5LWxhbmQgY29tcGF0aWJsZVxuICogYXBwbGljYXRpdmUgZnVuY3Rvci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMi4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKCouLi4gLT4gQm9vbGVhbikgLT4gKCouLi4gLT4gQm9vbGVhbikgLT4gKCouLi4gLT4gQm9vbGVhbilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGYgQSBwcmVkaWNhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGcgQW5vdGhlciBwcmVkaWNhdGVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBpdHMgYXJndW1lbnRzIHRvIGBmYCBhbmQgYGdgIGFuZCBgJiZgcyB0aGVpciBvdXRwdXRzIHRvZ2V0aGVyLlxuICogQHNlZSBSLmFuZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBndDEwID0gUi5ndChSLl9fLCAxMClcbiAqICAgICAgdmFyIGx0MjAgPSBSLmx0KFIuX18sIDIwKVxuICogICAgICB2YXIgZiA9IFIuYm90aChndDEwLCBsdDIwKTtcbiAqICAgICAgZigxNSk7IC8vPT4gdHJ1ZVxuICogICAgICBmKDMwKTsgLy89PiBmYWxzZVxuICovXG52YXIgYm90aCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGJvdGgoZiwgZykge1xuICByZXR1cm4gX2lzRnVuY3Rpb24oZikgPyBmdW5jdGlvbiBfYm90aCgpIHtcbiAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpICYmIGcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSA6IGxpZnQoYW5kKShmLCBnKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgYm90aDsiLCJpbXBvcnQgY3VycnkgZnJvbSAnLi9jdXJyeSc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgaXRzIGZpcnN0IGFyZ3VtZW50IHdpdGggdGhlIHJlbWFpbmluZ1xuICogYXJndW1lbnRzLiBUaGlzIGlzIG9jY2FzaW9uYWxseSB1c2VmdWwgYXMgYSBjb252ZXJnaW5nIGZ1bmN0aW9uIGZvclxuICogW2BSLmNvbnZlcmdlYF0oI2NvbnZlcmdlKTogdGhlIGZpcnN0IGJyYW5jaCBjYW4gcHJvZHVjZSBhIGZ1bmN0aW9uIHdoaWxlIHRoZVxuICogcmVtYWluaW5nIGJyYW5jaGVzIHByb2R1Y2UgdmFsdWVzIHRvIGJlIHBhc3NlZCB0byB0aGF0IGZ1bmN0aW9uIGFzIGl0c1xuICogYXJndW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgqLi4uIC0+IGEpLCouLi4gLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSByZW1haW5pbmcgYXJndW1lbnRzLlxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFueSBudW1iZXIgb2YgcG9zaXRpb25hbCBhcmd1bWVudHMuXG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLmFwcGx5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5jYWxsKFIuYWRkLCAxLCAyKTsgLy89PiAzXG4gKlxuICogICAgICB2YXIgaW5kZW50TiA9IFIucGlwZShSLnJlcGVhdCgnICcpLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBSLmpvaW4oJycpLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBSLnJlcGxhY2UoL14oPyEkKS9nbSkpO1xuICpcbiAqICAgICAgdmFyIGZvcm1hdCA9IFIuY29udmVyZ2UoUi5jYWxsLCBbXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSLnBpcGUoUi5wcm9wKCdpbmRlbnQnKSwgaW5kZW50TiksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSLnByb3AoJ3ZhbHVlJylcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gKlxuICogICAgICBmb3JtYXQoe2luZGVudDogMiwgdmFsdWU6ICdmb29cXG5iYXJcXG5iYXpcXG4nfSk7IC8vPT4gJyAgZm9vXFxuICBiYXJcXG4gIGJhelxcbidcbiAqIEBzeW1iIFIuY2FsbChmLCBhLCBiKSA9IGYoYSwgYilcbiAqL1xudmFyIGNhbGwgPSAvKiNfX1BVUkVfXyovY3VycnkoZnVuY3Rpb24gY2FsbChmbikge1xuICByZXR1cm4gZm4uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGNhbGw7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZSc7XG5pbXBvcnQgX21ha2VGbGF0IGZyb20gJy4vaW50ZXJuYWwvX21ha2VGbGF0JztcbmltcG9ydCBfeGNoYWluIGZyb20gJy4vaW50ZXJuYWwvX3hjaGFpbic7XG5pbXBvcnQgbWFwIGZyb20gJy4vbWFwJztcblxuLyoqXG4gKiBgY2hhaW5gIG1hcHMgYSBmdW5jdGlvbiBvdmVyIGEgbGlzdCBhbmQgY29uY2F0ZW5hdGVzIHRoZSByZXN1bHRzLiBgY2hhaW5gXG4gKiBpcyBhbHNvIGtub3duIGFzIGBmbGF0TWFwYCBpbiBzb21lIGxpYnJhcmllc1xuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBjaGFpbmAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQsXG4gKiBhY2NvcmRpbmcgdG8gdGhlIFtGYW50YXN5TGFuZCBDaGFpbiBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NoYWluKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIENoYWluIG0gPT4gKGEgLT4gbSBiKSAtPiBtIGEgLT4gbSBiXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFwIHdpdGhcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gbWFwIG92ZXJcbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgcmVzdWx0IG9mIGZsYXQtbWFwcGluZyBgbGlzdGAgd2l0aCBgZm5gXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGR1cGxpY2F0ZSA9IG4gPT4gW24sIG5dO1xuICogICAgICBSLmNoYWluKGR1cGxpY2F0ZSwgWzEsIDIsIDNdKTsgLy89PiBbMSwgMSwgMiwgMiwgMywgM11cbiAqXG4gKiAgICAgIFIuY2hhaW4oUi5hcHBlbmQsIFIuaGVhZCkoWzEsIDIsIDNdKTsgLy89PiBbMSwgMiwgMywgMV1cbiAqL1xudmFyIGNoYWluID0gLyojX19QVVJFX18qL19jdXJyeTIoIC8qI19fUFVSRV9fKi9fZGlzcGF0Y2hhYmxlKFsnZmFudGFzeS1sYW5kL2NoYWluJywgJ2NoYWluJ10sIF94Y2hhaW4sIGZ1bmN0aW9uIGNoYWluKGZuLCBtb25hZCkge1xuICBpZiAodHlwZW9mIG1vbmFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZm4obW9uYWQoeCkpKHgpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIF9tYWtlRmxhdChmYWxzZSkobWFwKGZuLCBtb25hZCkpO1xufSkpO1xuZXhwb3J0IGRlZmF1bHQgY2hhaW47IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLyoqXG4gKiBSZXN0cmljdHMgYSBudW1iZXIgdG8gYmUgd2l0aGluIGEgcmFuZ2UuXG4gKlxuICogQWxzbyB3b3JrcyBmb3Igb3RoZXIgb3JkZXJlZCB0eXBlcyBzdWNoIGFzIFN0cmluZ3MgYW5kIERhdGVzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIwLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gYSAtPiBhXG4gKiBAcGFyYW0ge051bWJlcn0gbWluaW11bSBUaGUgbG93ZXIgbGltaXQgb2YgdGhlIGNsYW1wIChpbmNsdXNpdmUpXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4aW11bSBUaGUgdXBwZXIgbGltaXQgb2YgdGhlIGNsYW1wIChpbmNsdXNpdmUpXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVmFsdWUgdG8gYmUgY2xhbXBlZFxuICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIGBtaW5pbXVtYCB3aGVuIGB2YWwgPCBtaW5pbXVtYCwgYG1heGltdW1gIHdoZW4gYHZhbCA+IG1heGltdW1gLCByZXR1cm5zIGB2YWxgIG90aGVyd2lzZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuY2xhbXAoMSwgMTAsIC01KSAvLyA9PiAxXG4gKiAgICAgIFIuY2xhbXAoMSwgMTAsIDE1KSAvLyA9PiAxMFxuICogICAgICBSLmNsYW1wKDEsIDEwLCA0KSAgLy8gPT4gNFxuICovXG52YXIgY2xhbXAgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBjbGFtcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgaWYgKG1pbiA+IG1heCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWluIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiBtYXggaW4gY2xhbXAobWluLCBtYXgsIHZhbHVlKScpO1xuICB9XG4gIHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWU7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGNsYW1wOyIsImltcG9ydCBfY2xvbmUgZnJvbSAnLi9pbnRlcm5hbC9fY2xvbmUnO1xuaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIHRoZSB2YWx1ZSB3aGljaCBtYXkgY29udGFpbiAobmVzdGVkKSBgQXJyYXlgcyBhbmRcbiAqIGBPYmplY3RgcywgYE51bWJlcmBzLCBgU3RyaW5nYHMsIGBCb29sZWFuYHMgYW5kIGBEYXRlYHMuIGBGdW5jdGlvbmBzIGFyZVxuICogYXNzaWduZWQgYnkgcmVmZXJlbmNlIHJhdGhlciB0aGFuIGNvcGllZFxuICpcbiAqIERpc3BhdGNoZXMgdG8gYSBgY2xvbmVgIG1ldGhvZCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7Kn0gLT4geyp9XG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gY2xvbmVcbiAqIEByZXR1cm4geyp9IEEgZGVlcGx5IGNsb25lZCBjb3B5IG9mIGB2YWxgXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG9iamVjdHMgPSBbe30sIHt9LCB7fV07XG4gKiAgICAgIHZhciBvYmplY3RzQ2xvbmUgPSBSLmNsb25lKG9iamVjdHMpO1xuICogICAgICBvYmplY3RzID09PSBvYmplY3RzQ2xvbmU7IC8vPT4gZmFsc2VcbiAqICAgICAgb2JqZWN0c1swXSA9PT0gb2JqZWN0c0Nsb25lWzBdOyAvLz0+IGZhbHNlXG4gKi9cbnZhciBjbG9uZSA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS5jbG9uZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLmNsb25lKCkgOiBfY2xvbmUodmFsdWUsIFtdLCBbXSwgdHJ1ZSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGNsb25lOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5cbi8qKlxuICogTWFrZXMgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIG91dCBvZiBhIGZ1bmN0aW9uIHRoYXQgcmVwb3J0cyB3aGV0aGVyIHRoZSBmaXJzdFxuICogZWxlbWVudCBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKGEsIGIpIC0+IEJvb2xlYW4pIC0+ICgoYSwgYikgLT4gTnVtYmVyKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSBmdW5jdGlvbiBvZiBhcml0eSB0d28gd2hpY2ggd2lsbCByZXR1cm4gYHRydWVgIGlmIHRoZSBmaXJzdCBhcmd1bWVudFxuICogaXMgbGVzcyB0aGFuIHRoZSBzZWNvbmQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBGdW5jdGlvbiA6OiBhIC0+IGIgLT4gSW50IHRoYXQgcmV0dXJucyBgLTFgIGlmIGEgPCBiLCBgMWAgaWYgYiA8IGEsIG90aGVyd2lzZSBgMGBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYnlBZ2UgPSBSLmNvbXBhcmF0b3IoKGEsIGIpID0+IGEuYWdlIDwgYi5hZ2UpO1xuICogICAgICB2YXIgcGVvcGxlID0gW1xuICogICAgICAgIC8vIC4uLlxuICogICAgICBdO1xuICogICAgICB2YXIgcGVvcGxlQnlJbmNyZWFzaW5nQWdlID0gUi5zb3J0KGJ5QWdlLCBwZW9wbGUpO1xuICovXG52YXIgY29tcGFyYXRvciA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGNvbXBhcmF0b3IocHJlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gcHJlZChhLCBiKSA/IC0xIDogcHJlZChiLCBhKSA/IDEgOiAwO1xuICB9O1xufSk7XG5leHBvcnQgZGVmYXVsdCBjb21wYXJhdG9yOyIsImltcG9ydCBsaWZ0IGZyb20gJy4vbGlmdCc7XG5pbXBvcnQgbm90IGZyb20gJy4vbm90JztcblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGBmYCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIGBnYCBzdWNoIHRoYXQgaWYgY2FsbGVkIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzXG4gKiB3aGVuIGBmYCByZXR1cm5zIGEgXCJ0cnV0aHlcIiB2YWx1ZSwgYGdgIHJldHVybnMgYGZhbHNlYCBhbmQgd2hlbiBgZmAgcmV0dXJucyBhIFwiZmFsc3lcIiB2YWx1ZSBgZ2AgcmV0dXJucyBgdHJ1ZWAuXG4gKlxuICogYFIuY29tcGxlbWVudGAgbWF5IGJlIGFwcGxpZWQgdG8gYW55IGZ1bmN0b3JcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMi4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKCouLi4gLT4gKikgLT4gKCouLi4gLT4gQm9vbGVhbilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSBSLm5vdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc05vdE5pbCA9IFIuY29tcGxlbWVudChSLmlzTmlsKTtcbiAqICAgICAgaXNOaWwobnVsbCk7IC8vPT4gdHJ1ZVxuICogICAgICBpc05vdE5pbChudWxsKTsgLy89PiBmYWxzZVxuICogICAgICBpc05pbCg3KTsgLy89PiBmYWxzZVxuICogICAgICBpc05vdE5pbCg3KTsgLy89PiB0cnVlXG4gKi9cbnZhciBjb21wbGVtZW50ID0gLyojX19QVVJFX18qL2xpZnQobm90KTtcbmV4cG9ydCBkZWZhdWx0IGNvbXBsZW1lbnQ7IiwiaW1wb3J0IHBpcGUgZnJvbSAnLi9waXBlJztcbmltcG9ydCByZXZlcnNlIGZyb20gJy4vcmV2ZXJzZSc7XG5cbi8qKlxuICogUGVyZm9ybXMgcmlnaHQtdG8tbGVmdCBmdW5jdGlvbiBjb21wb3NpdGlvbi4gVGhlIHJpZ2h0bW9zdCBmdW5jdGlvbiBtYXkgaGF2ZVxuICogYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nIGZ1bmN0aW9ucyBtdXN0IGJlIHVuYXJ5LlxuICpcbiAqICoqTm90ZToqKiBUaGUgcmVzdWx0IG9mIGNvbXBvc2UgaXMgbm90IGF1dG9tYXRpY2FsbHkgY3VycmllZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKHkgLT4geiksICh4IC0+IHkpLCAuLi4sIChvIC0+IHApLCAoKGEsIGIsIC4uLiwgbikgLT4gbykpIC0+ICgoYSwgYiwgLi4uLCBuKSAtPiB6KVxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gLi4uZnVuY3Rpb25zIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIucGlwZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBjbGFzc3lHcmVldGluZyA9IChmaXJzdE5hbWUsIGxhc3ROYW1lKSA9PiBcIlRoZSBuYW1lJ3MgXCIgKyBsYXN0TmFtZSArIFwiLCBcIiArIGZpcnN0TmFtZSArIFwiIFwiICsgbGFzdE5hbWVcbiAqICAgICAgdmFyIHllbGxHcmVldGluZyA9IFIuY29tcG9zZShSLnRvVXBwZXIsIGNsYXNzeUdyZWV0aW5nKTtcbiAqICAgICAgeWVsbEdyZWV0aW5nKCdKYW1lcycsICdCb25kJyk7IC8vPT4gXCJUSEUgTkFNRSdTIEJPTkQsIEpBTUVTIEJPTkRcIlxuICpcbiAqICAgICAgUi5jb21wb3NlKE1hdGguYWJzLCBSLmFkZCgxKSwgUi5tdWx0aXBseSgyKSkoLTQpIC8vPT4gN1xuICpcbiAqIEBzeW1iIFIuY29tcG9zZShmLCBnLCBoKShhLCBiKSA9IGYoZyhoKGEsIGIpKSlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvc2UgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gIH1cbiAgcmV0dXJuIHBpcGUuYXBwbHkodGhpcywgcmV2ZXJzZShhcmd1bWVudHMpKTtcbn0iLCJpbXBvcnQgY2hhaW4gZnJvbSAnLi9jaGFpbic7XG5pbXBvcnQgY29tcG9zZSBmcm9tICcuL2NvbXBvc2UnO1xuaW1wb3J0IG1hcCBmcm9tICcuL21hcCc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmlnaHQtdG8tbGVmdCBLbGVpc2xpIGNvbXBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMsXG4gKiBlYWNoIG9mIHdoaWNoIG11c3QgcmV0dXJuIGEgdmFsdWUgb2YgYSB0eXBlIHN1cHBvcnRlZCBieSBbYGNoYWluYF0oI2NoYWluKS5cbiAqXG4gKiBgUi5jb21wb3NlSyhoLCBnLCBmKWAgaXMgZXF1aXZhbGVudCB0byBgUi5jb21wb3NlKFIuY2hhaW4oaCksIFIuY2hhaW4oZyksIGYpYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgQ2hhaW4gbSA9PiAoKHkgLT4gbSB6KSwgKHggLT4gbSB5KSwgLi4uLCAoYSAtPiBtIGIpKSAtPiAoYSAtPiBtIHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSAuLi5mdW5jdGlvbnMgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5waXBlS1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgICAvLyAgZ2V0IDo6IFN0cmluZyAtPiBPYmplY3QgLT4gTWF5YmUgKlxuICogICAgICAgdmFyIGdldCA9IFIuY3VycnkoKHByb3BOYW1lLCBvYmopID0+IE1heWJlKG9ialtwcm9wTmFtZV0pKVxuICpcbiAqICAgICAgIC8vICBnZXRTdGF0ZUNvZGUgOjogTWF5YmUgU3RyaW5nIC0+IE1heWJlIFN0cmluZ1xuICogICAgICAgdmFyIGdldFN0YXRlQ29kZSA9IFIuY29tcG9zZUsoXG4gKiAgICAgICAgIFIuY29tcG9zZShNYXliZS5vZiwgUi50b1VwcGVyKSxcbiAqICAgICAgICAgZ2V0KCdzdGF0ZScpLFxuICogICAgICAgICBnZXQoJ2FkZHJlc3MnKSxcbiAqICAgICAgICAgZ2V0KCd1c2VyJyksXG4gKiAgICAgICApO1xuICogICAgICAgZ2V0U3RhdGVDb2RlKHtcInVzZXJcIjp7XCJhZGRyZXNzXCI6e1wic3RhdGVcIjpcIm55XCJ9fX0pOyAvLz0+IE1heWJlLkp1c3QoXCJOWVwiKVxuICogICAgICAgZ2V0U3RhdGVDb2RlKHt9KTsgLy89PiBNYXliZS5Ob3RoaW5nKClcbiAqIEBzeW1iIFIuY29tcG9zZUsoZiwgZywgaCkoYSkgPSBSLmNoYWluKGYsIFIuY2hhaW4oZywgaChhKSkpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBvc2VLKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29tcG9zZUsgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gIH1cbiAgdmFyIGluaXQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICB2YXIgbGFzdCA9IGluaXQucG9wKCk7XG4gIHJldHVybiBjb21wb3NlKGNvbXBvc2UuYXBwbHkodGhpcywgbWFwKGNoYWluLCBpbml0KSksIGxhc3QpO1xufSIsImltcG9ydCBwaXBlUCBmcm9tICcuL3BpcGVQJztcbmltcG9ydCByZXZlcnNlIGZyb20gJy4vcmV2ZXJzZSc7XG5cbi8qKlxuICogUGVyZm9ybXMgcmlnaHQtdG8tbGVmdCBjb21wb3NpdGlvbiBvZiBvbmUgb3IgbW9yZSBQcm9taXNlLXJldHVybmluZ1xuICogZnVuY3Rpb25zLiBUaGUgcmlnaHRtb3N0IGZ1bmN0aW9uIG1heSBoYXZlIGFueSBhcml0eTsgdGhlIHJlbWFpbmluZ1xuICogZnVuY3Rpb25zIG11c3QgYmUgdW5hcnkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTAuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgoeSAtPiBQcm9taXNlIHopLCAoeCAtPiBQcm9taXNlIHkpLCAuLi4sIChhIC0+IFByb21pc2UgYikpIC0+IChhIC0+IFByb21pc2UgeilcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmN0aW9ucyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSBSLnBpcGVQXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGRiID0ge1xuICogICAgICAgIHVzZXJzOiB7XG4gKiAgICAgICAgICBKT0U6IHtcbiAqICAgICAgICAgICAgbmFtZTogJ0pvZScsXG4gKiAgICAgICAgICAgIGZvbGxvd2VyczogWydTVEVWRScsICdTVVpZJ11cbiAqICAgICAgICAgIH1cbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqXG4gKiAgICAgIC8vIFdlJ2xsIHByZXRlbmQgdG8gZG8gYSBkYiBsb29rdXAgd2hpY2ggcmV0dXJucyBhIHByb21pc2VcbiAqICAgICAgdmFyIGxvb2t1cFVzZXIgPSAodXNlcklkKSA9PiBQcm9taXNlLnJlc29sdmUoZGIudXNlcnNbdXNlcklkXSlcbiAqICAgICAgdmFyIGxvb2t1cEZvbGxvd2VycyA9ICh1c2VyKSA9PiBQcm9taXNlLnJlc29sdmUodXNlci5mb2xsb3dlcnMpXG4gKiAgICAgIGxvb2t1cFVzZXIoJ0pPRScpLnRoZW4obG9va3VwRm9sbG93ZXJzKVxuICpcbiAqICAgICAgLy8gIGZvbGxvd2Vyc0ZvclVzZXIgOjogU3RyaW5nIC0+IFByb21pc2UgW1VzZXJJZF1cbiAqICAgICAgdmFyIGZvbGxvd2Vyc0ZvclVzZXIgPSBSLmNvbXBvc2VQKGxvb2t1cEZvbGxvd2VycywgbG9va3VwVXNlcik7XG4gKiAgICAgIGZvbGxvd2Vyc0ZvclVzZXIoJ0pPRScpLnRoZW4oZm9sbG93ZXJzID0+IGNvbnNvbGUubG9nKCdGb2xsb3dlcnM6JywgZm9sbG93ZXJzKSlcbiAqICAgICAgLy8gRm9sbG93ZXJzOiBbXCJTVEVWRVwiLFwiU1VaWVwiXVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlUCgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvc2VQIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuICB9XG4gIHJldHVybiBwaXBlUC5hcHBseSh0aGlzLCByZXZlcnNlKGFyZ3VtZW50cykpO1xufSIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2lzQXJyYXkgZnJvbSAnLi9pbnRlcm5hbC9faXNBcnJheSc7XG5pbXBvcnQgX2lzRnVuY3Rpb24gZnJvbSAnLi9pbnRlcm5hbC9faXNGdW5jdGlvbic7XG5pbXBvcnQgX2lzU3RyaW5nIGZyb20gJy4vaW50ZXJuYWwvX2lzU3RyaW5nJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbGlzdHMgb3Igc3RyaW5ncy5cbiAqXG4gKiBOb3RlOiBgUi5jb25jYXRgIGV4cGVjdHMgYm90aCBhcmd1bWVudHMgdG8gYmUgb2YgdGhlIHNhbWUgdHlwZSxcbiAqIHVubGlrZSB0aGUgbmF0aXZlIGBBcnJheS5wcm90b3R5cGUuY29uY2F0YCBtZXRob2QuIEl0IHdpbGwgdGhyb3dcbiAqIGFuIGVycm9yIGlmIHlvdSBgY29uY2F0YCBhbiBBcnJheSB3aXRoIGEgbm9uLUFycmF5IHZhbHVlLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBjb25jYXRgIG1ldGhvZCBvZiB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKiBDYW4gYWxzbyBjb25jYXRlbmF0ZSB0d28gbWVtYmVycyBvZiBhIFtmYW50YXN5LWxhbmRcbiAqIGNvbXBhdGlibGUgc2VtaWdyb3VwXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3NlbWlncm91cCkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2FdIC0+IFthXVxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGZpcnN0TGlzdCBUaGUgZmlyc3QgbGlzdFxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHNlY29uZExpc3QgVGhlIHNlY29uZCBsaXN0XG4gKiBAcmV0dXJuIHtBcnJheXxTdHJpbmd9IEEgbGlzdCBjb25zaXN0aW5nIG9mIHRoZSBlbGVtZW50cyBvZiBgZmlyc3RMaXN0YCBmb2xsb3dlZCBieSB0aGUgZWxlbWVudHMgb2ZcbiAqIGBzZWNvbmRMaXN0YC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5jb25jYXQoJ0FCQycsICdERUYnKTsgLy8gJ0FCQ0RFRidcbiAqICAgICAgUi5jb25jYXQoWzQsIDUsIDZdLCBbMSwgMiwgM10pOyAvLz0+IFs0LCA1LCA2LCAxLCAyLCAzXVxuICogICAgICBSLmNvbmNhdChbXSwgW10pOyAvLz0+IFtdXG4gKi9cbnZhciBjb25jYXQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBjb25jYXQoYSwgYikge1xuICBpZiAoX2lzQXJyYXkoYSkpIHtcbiAgICBpZiAoX2lzQXJyYXkoYikpIHtcbiAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0b1N0cmluZyhiKSArICcgaXMgbm90IGFuIGFycmF5Jyk7XG4gIH1cbiAgaWYgKF9pc1N0cmluZyhhKSkge1xuICAgIGlmIChfaXNTdHJpbmcoYikpIHtcbiAgICAgIHJldHVybiBhICsgYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0b1N0cmluZyhiKSArICcgaXMgbm90IGEgc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGEgIT0gbnVsbCAmJiBfaXNGdW5jdGlvbihhWydmYW50YXN5LWxhbmQvY29uY2F0J10pKSB7XG4gICAgcmV0dXJuIGFbJ2ZhbnRhc3ktbGFuZC9jb25jYXQnXShiKTtcbiAgfVxuICBpZiAoYSAhPSBudWxsICYmIF9pc0Z1bmN0aW9uKGEuY29uY2F0KSkge1xuICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKHRvU3RyaW5nKGEpICsgJyBkb2VzIG5vdCBoYXZlIGEgbWV0aG9kIG5hbWVkIFwiY29uY2F0XCIgb3IgXCJmYW50YXN5LWxhbmQvY29uY2F0XCInKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgY29uY2F0OyIsImltcG9ydCBfYXJpdHkgZnJvbSAnLi9pbnRlcm5hbC9fYXJpdHknO1xuaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBtYXAgZnJvbSAnLi9tYXAnO1xuaW1wb3J0IG1heCBmcm9tICcuL21heCc7XG5pbXBvcnQgcmVkdWNlIGZyb20gJy4vcmVkdWNlJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24sIGBmbmAsIHdoaWNoIGVuY2Fwc3VsYXRlcyBgaWYvZWxzZSwgaWYvZWxzZSwgLi4uYCBsb2dpYy5cbiAqIGBSLmNvbmRgIHRha2VzIGEgbGlzdCBvZiBbcHJlZGljYXRlLCB0cmFuc2Zvcm1lcl0gcGFpcnMuIEFsbCBvZiB0aGUgYXJndW1lbnRzXG4gKiB0byBgZm5gIGFyZSBhcHBsaWVkIHRvIGVhY2ggb2YgdGhlIHByZWRpY2F0ZXMgaW4gdHVybiB1bnRpbCBvbmUgcmV0dXJucyBhXG4gKiBcInRydXRoeVwiIHZhbHVlLCBhdCB3aGljaCBwb2ludCBgZm5gIHJldHVybnMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBpdHNcbiAqIGFyZ3VtZW50cyB0byB0aGUgY29ycmVzcG9uZGluZyB0cmFuc2Zvcm1lci4gSWYgbm9uZSBvZiB0aGUgcHJlZGljYXRlc1xuICogbWF0Y2hlcywgYGZuYCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC42LjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyBbWygqLi4uIC0+IEJvb2xlYW4pLCgqLi4uIC0+ICopXV0gLT4gKCouLi4gLT4gKilcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIEEgbGlzdCBvZiBbcHJlZGljYXRlLCB0cmFuc2Zvcm1lcl1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBmbiA9IFIuY29uZChbXG4gKiAgICAgICAgW1IuZXF1YWxzKDApLCAgIFIuYWx3YXlzKCd3YXRlciBmcmVlemVzIGF0IDDCsEMnKV0sXG4gKiAgICAgICAgW1IuZXF1YWxzKDEwMCksIFIuYWx3YXlzKCd3YXRlciBib2lscyBhdCAxMDDCsEMnKV0sXG4gKiAgICAgICAgW1IuVCwgICAgICAgICAgIHRlbXAgPT4gJ25vdGhpbmcgc3BlY2lhbCBoYXBwZW5zIGF0ICcgKyB0ZW1wICsgJ8KwQyddXG4gKiAgICAgIF0pO1xuICogICAgICBmbigwKTsgLy89PiAnd2F0ZXIgZnJlZXplcyBhdCAwwrBDJ1xuICogICAgICBmbig1MCk7IC8vPT4gJ25vdGhpbmcgc3BlY2lhbCBoYXBwZW5zIGF0IDUwwrBDJ1xuICogICAgICBmbigxMDApOyAvLz0+ICd3YXRlciBib2lscyBhdCAxMDDCsEMnXG4gKi9cbnZhciBjb25kID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gY29uZChwYWlycykge1xuICB2YXIgYXJpdHkgPSByZWR1Y2UobWF4LCAwLCBtYXAoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICByZXR1cm4gcGFpclswXS5sZW5ndGg7XG4gIH0sIHBhaXJzKSk7XG4gIHJldHVybiBfYXJpdHkoYXJpdHksIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB3aGlsZSAoaWR4IDwgcGFpcnMubGVuZ3RoKSB7XG4gICAgICBpZiAocGFpcnNbaWR4XVswXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgIHJldHVybiBwYWlyc1tpZHhdWzFdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG4gIH0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBjb25kOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgY29uc3RydWN0TiBmcm9tICcuL2NvbnN0cnVjdE4nO1xuXG4vKipcbiAqIFdyYXBzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gaW5zaWRlIGEgY3VycmllZCBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWRcbiAqIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGFuZCByZXR1cm5zIHRoZSBzYW1lIHR5cGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCogLT4geyp9KSAtPiAoKiAtPiB7Kn0pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIHdyYXBwZWQsIGN1cnJpZWQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKiBAc2VlIFIuaW52b2tlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIC8vIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gKiAgICAgIGZ1bmN0aW9uIEFuaW1hbChraW5kKSB7XG4gKiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAqICAgICAgfTtcbiAqICAgICAgQW5pbWFsLnByb3RvdHlwZS5zaWdodGluZyA9IGZ1bmN0aW9uKCkge1xuICogICAgICAgIHJldHVybiBcIkl0J3MgYSBcIiArIHRoaXMua2luZCArIFwiIVwiO1xuICogICAgICB9XG4gKlxuICogICAgICB2YXIgQW5pbWFsQ29uc3RydWN0b3IgPSBSLmNvbnN0cnVjdChBbmltYWwpXG4gKlxuICogICAgICAvLyBOb3RpY2Ugd2Ugbm8gbG9uZ2VyIG5lZWQgdGhlICduZXcnIGtleXdvcmQ6XG4gKiAgICAgIEFuaW1hbENvbnN0cnVjdG9yKCdQaWcnKTsgLy89PiB7XCJraW5kXCI6IFwiUGlnXCIsIFwic2lnaHRpbmdcIjogZnVuY3Rpb24gKCl7Li4ufX07XG4gKlxuICogICAgICB2YXIgYW5pbWFsVHlwZXMgPSBbXCJMaW9uXCIsIFwiVGlnZXJcIiwgXCJCZWFyXCJdO1xuICogICAgICB2YXIgYW5pbWFsU2lnaHRpbmcgPSBSLmludm9rZXIoMCwgJ3NpZ2h0aW5nJyk7XG4gKiAgICAgIHZhciBzaWdodE5ld0FuaW1hbCA9IFIuY29tcG9zZShhbmltYWxTaWdodGluZywgQW5pbWFsQ29uc3RydWN0b3IpO1xuICogICAgICBSLm1hcChzaWdodE5ld0FuaW1hbCwgYW5pbWFsVHlwZXMpOyAvLz0+IFtcIkl0J3MgYSBMaW9uIVwiLCBcIkl0J3MgYSBUaWdlciFcIiwgXCJJdCdzIGEgQmVhciFcIl1cbiAqL1xudmFyIGNvbnN0cnVjdCA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGNvbnN0cnVjdChGbikge1xuICByZXR1cm4gY29uc3RydWN0TihGbi5sZW5ndGgsIEZuKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgY29uc3RydWN0OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgY3VycnkgZnJvbSAnLi9jdXJyeSc7XG5pbXBvcnQgbkFyeSBmcm9tICcuL25BcnknO1xuXG4vKipcbiAqIFdyYXBzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gaW5zaWRlIGEgY3VycmllZCBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWRcbiAqIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGFuZCByZXR1cm5zIHRoZSBzYW1lIHR5cGUuIFRoZSBhcml0eSBvZiB0aGUgZnVuY3Rpb25cbiAqIHJldHVybmVkIGlzIHNwZWNpZmllZCB0byBhbGxvdyB1c2luZyB2YXJpYWRpYyBjb25zdHJ1Y3RvciBmdW5jdGlvbnMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgTnVtYmVyIC0+ICgqIC0+IHsqfSkgLT4gKCogLT4geyp9KVxuICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIGFyaXR5IG9mIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IEZuIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0byB3cmFwLlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgd3JhcHBlZCwgY3VycmllZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyBWYXJpYWRpYyBDb25zdHJ1Y3RvciBmdW5jdGlvblxuICogICAgICBmdW5jdGlvbiBTYWxhZCgpIHtcbiAqICAgICAgICB0aGlzLmluZ3JlZGllbnRzID0gYXJndW1lbnRzO1xuICogICAgICB9XG4gKlxuICogICAgICBTYWxhZC5wcm90b3R5cGUucmVjaXBlID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgdmFyIGluc3RydWN0aW9ucyA9IFIubWFwKGluZ3JlZGllbnQgPT4gJ0FkZCBhIGRvbGxvcCBvZiAnICsgaW5ncmVkaWVudCwgdGhpcy5pbmdyZWRpZW50cyk7XG4gKiAgICAgICAgcmV0dXJuIFIuam9pbignXFxuJywgaW5zdHJ1Y3Rpb25zKTtcbiAqICAgICAgfTtcbiAqXG4gKiAgICAgIHZhciBUaHJlZUxheWVyU2FsYWQgPSBSLmNvbnN0cnVjdE4oMywgU2FsYWQpO1xuICpcbiAqICAgICAgLy8gTm90aWNlIHdlIG5vIGxvbmdlciBuZWVkIHRoZSAnbmV3JyBrZXl3b3JkLCBhbmQgdGhlIGNvbnN0cnVjdG9yIGlzIGN1cnJpZWQgZm9yIDMgYXJndW1lbnRzLlxuICogICAgICB2YXIgc2FsYWQgPSBUaHJlZUxheWVyU2FsYWQoJ01heW9ubmFpc2UnKSgnUG90YXRvIENoaXBzJykoJ0tldGNodXAnKTtcbiAqXG4gKiAgICAgIGNvbnNvbGUubG9nKHNhbGFkLnJlY2lwZSgpKTtcbiAqICAgICAgLy8gQWRkIGEgZG9sbG9wIG9mIE1heW9ubmFpc2VcbiAqICAgICAgLy8gQWRkIGEgZG9sbG9wIG9mIFBvdGF0byBDaGlwc1xuICogICAgICAvLyBBZGQgYSBkb2xsb3Agb2YgS2V0Y2h1cFxuICovXG52YXIgY29uc3RydWN0TiA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGNvbnN0cnVjdE4obiwgRm4pIHtcbiAgaWYgKG4gPiAxMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29uc3RydWN0b3Igd2l0aCBncmVhdGVyIHRoYW4gdGVuIGFyZ3VtZW50cycpO1xuICB9XG4gIGlmIChuID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgRm4oKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBjdXJyeShuQXJ5KG4sIGZ1bmN0aW9uICgkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcsICQ4LCAkOSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIG5ldyBGbigkMCwgJDEpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIpO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzKTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIG5ldyBGbigkMCwgJDEsICQyLCAkMywgJDQpO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUpO1xuICAgICAgY2FzZSA3OlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2KTtcbiAgICAgIGNhc2UgODpcbiAgICAgICAgcmV0dXJuIG5ldyBGbigkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcpO1xuICAgICAgY2FzZSA5OlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDgpO1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgcmV0dXJuIG5ldyBGbigkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcsICQ4LCAkOSk7XG4gICAgfVxuICB9KSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGNvbnN0cnVjdE47IiwiaW1wb3J0IF9jb250YWlucyBmcm9tICcuL2ludGVybmFsL19jb250YWlucyc7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgZXF1YWwsIGluIFtgUi5lcXVhbHNgXSgjZXF1YWxzKVxuICogdGVybXMsIHRvIGF0IGxlYXN0IG9uZSBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0OyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gW2FdIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBpdGVtIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGFuIGVxdWl2YWxlbnQgaXRlbSBpcyBpbiB0aGUgbGlzdCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAc2VlIFIuYW55XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5jb250YWlucygzLCBbMSwgMiwgM10pOyAvLz0+IHRydWVcbiAqICAgICAgUi5jb250YWlucyg0LCBbMSwgMiwgM10pOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuY29udGFpbnMoeyBuYW1lOiAnRnJlZCcgfSwgW3sgbmFtZTogJ0ZyZWQnIH1dKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuY29udGFpbnMoWzQyXSwgW1s0Ml1dKTsgLy89PiB0cnVlXG4gKi9cbnZhciBjb250YWlucyA9IC8qI19fUFVSRV9fKi9fY3VycnkyKF9jb250YWlucyk7XG5leHBvcnQgZGVmYXVsdCBjb250YWluczsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9tYXAgZnJvbSAnLi9pbnRlcm5hbC9fbWFwJztcbmltcG9ydCBjdXJyeU4gZnJvbSAnLi9jdXJyeU4nO1xuaW1wb3J0IG1heCBmcm9tICcuL21heCc7XG5pbXBvcnQgcGx1Y2sgZnJvbSAnLi9wbHVjayc7XG5pbXBvcnQgcmVkdWNlIGZyb20gJy4vcmVkdWNlJztcblxuLyoqXG4gKiBBY2NlcHRzIGEgY29udmVyZ2luZyBmdW5jdGlvbiBhbmQgYSBsaXN0IG9mIGJyYW5jaGluZyBmdW5jdGlvbnMgYW5kIHJldHVybnNcbiAqIGEgbmV3IGZ1bmN0aW9uLiBXaGVuIGludm9rZWQsIHRoaXMgbmV3IGZ1bmN0aW9uIGlzIGFwcGxpZWQgdG8gc29tZVxuICogYXJndW1lbnRzLCBlYWNoIGJyYW5jaGluZyBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRob3NlIHNhbWUgYXJndW1lbnRzLiBUaGVcbiAqIHJlc3VsdHMgb2YgZWFjaCBicmFuY2hpbmcgZnVuY3Rpb24gYXJlIHBhc3NlZCBhcyBhcmd1bWVudHMgdG8gdGhlIGNvbnZlcmdpbmdcbiAqIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHJldHVybiB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC40LjJcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKHgxLCB4MiwgLi4uKSAtPiB6KSAtPiBbKChhLCBiLCAuLi4pIC0+IHgxKSwgKChhLCBiLCAuLi4pIC0+IHgyKSwgLi4uXSAtPiAoYSAtPiBiIC0+IC4uLiAtPiB6KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYWZ0ZXIgQSBmdW5jdGlvbi4gYGFmdGVyYCB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlcyBvZlxuICogICAgICAgIGBmbjFgIGFuZCBgZm4yYCBhcyBpdHMgYXJndW1lbnRzLlxuICogQHBhcmFtIHtBcnJheX0gZnVuY3Rpb25zIEEgbGlzdCBvZiBmdW5jdGlvbnMuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24uXG4gKiBAc2VlIFIudXNlV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBhdmVyYWdlID0gUi5jb252ZXJnZShSLmRpdmlkZSwgW1Iuc3VtLCBSLmxlbmd0aF0pXG4gKiAgICAgIGF2ZXJhZ2UoWzEsIDIsIDMsIDQsIDUsIDYsIDddKSAvLz0+IDRcbiAqXG4gKiAgICAgIHZhciBzdHJhbmdlQ29uY2F0ID0gUi5jb252ZXJnZShSLmNvbmNhdCwgW1IudG9VcHBlciwgUi50b0xvd2VyXSlcbiAqICAgICAgc3RyYW5nZUNvbmNhdChcIllvZGVsXCIpIC8vPT4gXCJZT0RFTHlvZGVsXCJcbiAqXG4gKiBAc3ltYiBSLmNvbnZlcmdlKGYsIFtnLCBoXSkoYSwgYikgPSBmKGcoYSwgYiksIGgoYSwgYikpXG4gKi9cbnZhciBjb252ZXJnZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGNvbnZlcmdlKGFmdGVyLCBmbnMpIHtcbiAgcmV0dXJuIGN1cnJ5TihyZWR1Y2UobWF4LCAwLCBwbHVjaygnbGVuZ3RoJywgZm5zKSksIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgcmV0dXJuIGFmdGVyLmFwcGx5KGNvbnRleHQsIF9tYXAoZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfSwgZm5zKSk7XG4gIH0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBjb252ZXJnZTsiLCJpbXBvcnQgcmVkdWNlQnkgZnJvbSAnLi9yZWR1Y2VCeSc7XG5cbi8qKlxuICogQ291bnRzIHRoZSBlbGVtZW50cyBvZiBhIGxpc3QgYWNjb3JkaW5nIHRvIGhvdyBtYW55IG1hdGNoIGVhY2ggdmFsdWUgb2YgYVxuICoga2V5IGdlbmVyYXRlZCBieSB0aGUgc3VwcGxpZWQgZnVuY3Rpb24uIFJldHVybnMgYW4gb2JqZWN0IG1hcHBpbmcgdGhlIGtleXNcbiAqIHByb2R1Y2VkIGJ5IGBmbmAgdG8gdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBpbiB0aGUgbGlzdC4gTm90ZSB0aGF0IGFsbFxuICoga2V5cyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGJlY2F1c2Ugb2YgaG93IEphdmFTY3JpcHQgb2JqZWN0cyB3b3JrLlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyAoYSAtPiBTdHJpbmcpIC0+IFthXSAtPiB7Kn1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB1c2VkIHRvIG1hcCB2YWx1ZXMgdG8ga2V5cy5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gY291bnQgZWxlbWVudHMgZnJvbS5cbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IG1hcHBpbmcga2V5cyB0byBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgaW4gdGhlIGxpc3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG51bWJlcnMgPSBbMS4wLCAxLjEsIDEuMiwgMi4wLCAzLjAsIDIuMl07XG4gKiAgICAgIFIuY291bnRCeShNYXRoLmZsb29yKShudW1iZXJzKTsgICAgLy89PiB7JzEnOiAzLCAnMic6IDIsICczJzogMX1cbiAqXG4gKiAgICAgIHZhciBsZXR0ZXJzID0gWydhJywgJ2InLCAnQScsICdhJywgJ0InLCAnYyddO1xuICogICAgICBSLmNvdW50QnkoUi50b0xvd2VyKShsZXR0ZXJzKTsgICAvLz0+IHsnYSc6IDMsICdiJzogMiwgJ2MnOiAxfVxuICovXG52YXIgY291bnRCeSA9IC8qI19fUFVSRV9fKi9yZWR1Y2VCeShmdW5jdGlvbiAoYWNjLCBlbGVtKSB7XG4gIHJldHVybiBhY2MgKyAxO1xufSwgMCk7XG5leHBvcnQgZGVmYXVsdCBjb3VudEJ5OyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgY3VycnlOIGZyb20gJy4vY3VycnlOJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgY3VycmllZCBlcXVpdmFsZW50IG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbi4gVGhlIGN1cnJpZWQgZnVuY3Rpb25cbiAqIGhhcyB0d28gdW51c3VhbCBjYXBhYmlsaXRpZXMuIEZpcnN0LCBpdHMgYXJndW1lbnRzIG5lZWRuJ3QgYmUgcHJvdmlkZWQgb25lXG4gKiBhdCBhIHRpbWUuIElmIGBmYCBpcyBhIHRlcm5hcnkgZnVuY3Rpb24gYW5kIGBnYCBpcyBgUi5jdXJyeShmKWAsIHRoZVxuICogZm9sbG93aW5nIGFyZSBlcXVpdmFsZW50OlxuICpcbiAqICAgLSBgZygxKSgyKSgzKWBcbiAqICAgLSBgZygxKSgyLCAzKWBcbiAqICAgLSBgZygxLCAyKSgzKWBcbiAqICAgLSBgZygxLCAyLCAzKWBcbiAqXG4gKiBTZWNvbmRseSwgdGhlIHNwZWNpYWwgcGxhY2Vob2xkZXIgdmFsdWUgW2BSLl9fYF0oI19fKSBtYXkgYmUgdXNlZCB0byBzcGVjaWZ5XG4gKiBcImdhcHNcIiwgYWxsb3dpbmcgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzLFxuICogcmVnYXJkbGVzcyBvZiB0aGVpciBwb3NpdGlvbnMuIElmIGBnYCBpcyBhcyBhYm92ZSBhbmQgYF9gIGlzIFtgUi5fX2BdKCNfXyksXG4gKiB0aGUgZm9sbG93aW5nIGFyZSBlcXVpdmFsZW50OlxuICpcbiAqICAgLSBgZygxLCAyLCAzKWBcbiAqICAgLSBgZyhfLCAyLCAzKSgxKWBcbiAqICAgLSBgZyhfLCBfLCAzKSgxKSgyKWBcbiAqICAgLSBgZyhfLCBfLCAzKSgxLCAyKWBcbiAqICAgLSBgZyhfLCAyKSgxKSgzKWBcbiAqICAgLSBgZyhfLCAyKSgxLCAzKWBcbiAqICAgLSBgZyhfLCAyKShfLCAzKSgxKWBcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKiAtPiBhKSAtPiAoKiAtPiBhKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3LCBjdXJyaWVkIGZ1bmN0aW9uLlxuICogQHNlZSBSLmN1cnJ5TlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBhZGRGb3VyTnVtYmVycyA9IChhLCBiLCBjLCBkKSA9PiBhICsgYiArIGMgKyBkO1xuICpcbiAqICAgICAgdmFyIGN1cnJpZWRBZGRGb3VyTnVtYmVycyA9IFIuY3VycnkoYWRkRm91ck51bWJlcnMpO1xuICogICAgICB2YXIgZiA9IGN1cnJpZWRBZGRGb3VyTnVtYmVycygxLCAyKTtcbiAqICAgICAgdmFyIGcgPSBmKDMpO1xuICogICAgICBnKDQpOyAvLz0+IDEwXG4gKi9cbnZhciBjdXJyeSA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGN1cnJ5KGZuKSB7XG4gIHJldHVybiBjdXJyeU4oZm4ubGVuZ3RoLCBmbik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGN1cnJ5OyIsImltcG9ydCBfYXJpdHkgZnJvbSAnLi9pbnRlcm5hbC9fYXJpdHknO1xuaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2N1cnJ5TiBmcm9tICcuL2ludGVybmFsL19jdXJyeU4nO1xuXG4vKipcbiAqIFJldHVybnMgYSBjdXJyaWVkIGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLCB3aXRoIHRoZSBzcGVjaWZpZWRcbiAqIGFyaXR5LiBUaGUgY3VycmllZCBmdW5jdGlvbiBoYXMgdHdvIHVudXN1YWwgY2FwYWJpbGl0aWVzLiBGaXJzdCwgaXRzXG4gKiBhcmd1bWVudHMgbmVlZG4ndCBiZSBwcm92aWRlZCBvbmUgYXQgYSB0aW1lLiBJZiBgZ2AgaXMgYFIuY3VycnlOKDMsIGYpYCwgdGhlXG4gKiBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEpKDIpKDMpYFxuICogICAtIGBnKDEpKDIsIDMpYFxuICogICAtIGBnKDEsIDIpKDMpYFxuICogICAtIGBnKDEsIDIsIDMpYFxuICpcbiAqIFNlY29uZGx5LCB0aGUgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSBbYFIuX19gXSgjX18pIG1heSBiZSB1c2VkIHRvIHNwZWNpZnlcbiAqIFwiZ2Fwc1wiLCBhbGxvd2luZyBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMsXG4gKiByZWdhcmRsZXNzIG9mIHRoZWlyIHBvc2l0aW9ucy4gSWYgYGdgIGlzIGFzIGFib3ZlIGFuZCBgX2AgaXMgW2BSLl9fYF0oI19fKSxcbiAqIHRoZSBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEsIDIsIDMpYFxuICogICAtIGBnKF8sIDIsIDMpKDEpYFxuICogICAtIGBnKF8sIF8sIDMpKDEpKDIpYFxuICogICAtIGBnKF8sIF8sIDMpKDEsIDIpYFxuICogICAtIGBnKF8sIDIpKDEpKDMpYFxuICogICAtIGBnKF8sIDIpKDEsIDMpYFxuICogICAtIGBnKF8sIDIpKF8sIDMpKDEpYFxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjUuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE51bWJlciAtPiAoKiAtPiBhKSAtPiAoKiAtPiBhKVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgYXJpdHkgZm9yIHRoZSByZXR1cm5lZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldywgY3VycmllZCBmdW5jdGlvbi5cbiAqIEBzZWUgUi5jdXJyeVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBzdW1BcmdzID0gKC4uLmFyZ3MpID0+IFIuc3VtKGFyZ3MpO1xuICpcbiAqICAgICAgdmFyIGN1cnJpZWRBZGRGb3VyTnVtYmVycyA9IFIuY3VycnlOKDQsIHN1bUFyZ3MpO1xuICogICAgICB2YXIgZiA9IGN1cnJpZWRBZGRGb3VyTnVtYmVycygxLCAyKTtcbiAqICAgICAgdmFyIGcgPSBmKDMpO1xuICogICAgICBnKDQpOyAvLz0+IDEwXG4gKi9cbnZhciBjdXJyeU4gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBjdXJyeU4obGVuZ3RoLCBmbikge1xuICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIF9jdXJyeTEoZm4pO1xuICB9XG4gIHJldHVybiBfYXJpdHkobGVuZ3RoLCBfY3VycnlOKGxlbmd0aCwgW10sIGZuKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGN1cnJ5TjsiLCJpbXBvcnQgYWRkIGZyb20gJy4vYWRkJztcblxuLyoqXG4gKiBEZWNyZW1lbnRzIGl0cyBhcmd1bWVudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IG4gLSAxXG4gKiBAc2VlIFIuaW5jXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5kZWMoNDIpOyAvLz0+IDQxXG4gKi9cbnZhciBkZWMgPSAvKiNfX1BVUkVfXyovYWRkKC0xKTtcbmV4cG9ydCBkZWZhdWx0IGRlYzsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHNlY29uZCBhcmd1bWVudCBpZiBpdCBpcyBub3QgYG51bGxgLCBgdW5kZWZpbmVkYCBvciBgTmFOYDtcbiAqIG90aGVyd2lzZSB0aGUgZmlyc3QgYXJndW1lbnQgaXMgcmV0dXJuZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTAuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIGEgLT4gYiAtPiBhIHwgYlxuICogQHBhcmFtIHthfSBkZWZhdWx0IFRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtIHtifSB2YWwgYHZhbGAgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGBkZWZhdWx0YCB1bmxlc3MgYHZhbGAgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCBvciBgTmFOYC5cbiAqIEByZXR1cm4geyp9IFRoZSBzZWNvbmQgdmFsdWUgaWYgaXQgaXMgbm90IGBudWxsYCwgYHVuZGVmaW5lZGAgb3IgYE5hTmAsIG90aGVyd2lzZSB0aGUgZGVmYXVsdCB2YWx1ZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBkZWZhdWx0VG80MiA9IFIuZGVmYXVsdFRvKDQyKTtcbiAqXG4gKiAgICAgIGRlZmF1bHRUbzQyKG51bGwpOyAgLy89PiA0MlxuICogICAgICBkZWZhdWx0VG80Mih1bmRlZmluZWQpOyAgLy89PiA0MlxuICogICAgICBkZWZhdWx0VG80MignUmFtZGEnKTsgIC8vPT4gJ1JhbWRhJ1xuICogICAgICAvLyBwYXJzZUludCgnc3RyaW5nJykgcmVzdWx0cyBpbiBOYU5cbiAqICAgICAgZGVmYXVsdFRvNDIocGFyc2VJbnQoJ3N0cmluZycpKTsgLy89PiA0MlxuICovXG52YXIgZGVmYXVsdFRvID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gZGVmYXVsdFRvKGQsIHYpIHtcbiAgcmV0dXJuIHYgPT0gbnVsbCB8fCB2ICE9PSB2ID8gZCA6IHY7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRUbzsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIE1ha2VzIGEgZGVzY2VuZGluZyBjb21wYXJhdG9yIGZ1bmN0aW9uIG91dCBvZiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHZhbHVlXG4gKiB0aGF0IGNhbiBiZSBjb21wYXJlZCB3aXRoIGA8YCBhbmQgYD5gLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIzLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBPcmQgYiA9PiAoYSAtPiBiKSAtPiBhIC0+IGEgLT4gTnVtYmVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBBIGZ1bmN0aW9uIG9mIGFyaXR5IG9uZSB0aGF0IHJldHVybnMgYSB2YWx1ZSB0aGF0IGNhbiBiZSBjb21wYXJlZFxuICogQHBhcmFtIHsqfSBhIFRoZSBmaXJzdCBpdGVtIHRvIGJlIGNvbXBhcmVkLlxuICogQHBhcmFtIHsqfSBiIFRoZSBzZWNvbmQgaXRlbSB0byBiZSBjb21wYXJlZC5cbiAqIEByZXR1cm4ge051bWJlcn0gYC0xYCBpZiBmbihhKSA+IGZuKGIpLCBgMWAgaWYgZm4oYikgPiBmbihhKSwgb3RoZXJ3aXNlIGAwYFxuICogQHNlZSBSLmFzY2VuZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBieUFnZSA9IFIuZGVzY2VuZChSLnByb3AoJ2FnZScpKTtcbiAqICAgICAgdmFyIHBlb3BsZSA9IFtcbiAqICAgICAgICAvLyAuLi5cbiAqICAgICAgXTtcbiAqICAgICAgdmFyIHBlb3BsZUJ5T2xkZXN0Rmlyc3QgPSBSLnNvcnQoYnlBZ2UsIHBlb3BsZSk7XG4gKi9cbnZhciBkZXNjZW5kID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gZGVzY2VuZChmbiwgYSwgYikge1xuICB2YXIgYWEgPSBmbihhKTtcbiAgdmFyIGJiID0gZm4oYik7XG4gIHJldHVybiBhYSA+IGJiID8gLTEgOiBhYSA8IGJiID8gMSA6IDA7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGRlc2NlbmQ7IiwiaW1wb3J0IF9jb250YWlucyBmcm9tICcuL2ludGVybmFsL19jb250YWlucyc7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgb2YgYWxsIGVsZW1lbnRzIGluIHRoZSBmaXJzdCBsaXN0IG5vdFxuICogY29udGFpbmVkIGluIHRoZSBzZWNvbmQgbGlzdC4gT2JqZWN0cyBhbmQgQXJyYXlzIGFyZSBjb21wYXJlZCBpbiB0ZXJtcyBvZlxuICogdmFsdWUgZXF1YWxpdHksIG5vdCByZWZlcmVuY2UgZXF1YWxpdHkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgWypdIC0+IFsqXSAtPiBbKl1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBlbGVtZW50cyBpbiBgbGlzdDFgIHRoYXQgYXJlIG5vdCBpbiBgbGlzdDJgLlxuICogQHNlZSBSLmRpZmZlcmVuY2VXaXRoLCBSLnN5bW1ldHJpY0RpZmZlcmVuY2UsIFIuc3ltbWV0cmljRGlmZmVyZW5jZVdpdGgsIFIud2l0aG91dFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZGlmZmVyZW5jZShbMSwyLDMsNF0sIFs3LDYsNSw0LDNdKTsgLy89PiBbMSwyXVxuICogICAgICBSLmRpZmZlcmVuY2UoWzcsNiw1LDQsM10sIFsxLDIsMyw0XSk7IC8vPT4gWzcsNiw1XVxuICogICAgICBSLmRpZmZlcmVuY2UoW3thOiAxfSwge2I6IDJ9XSwgW3thOiAxfSwge2M6IDN9XSkgLy89PiBbe2I6IDJ9XVxuICovXG52YXIgZGlmZmVyZW5jZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGRpZmZlcmVuY2UoZmlyc3QsIHNlY29uZCkge1xuICB2YXIgb3V0ID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgZmlyc3RMZW4gPSBmaXJzdC5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBmaXJzdExlbikge1xuICAgIGlmICghX2NvbnRhaW5zKGZpcnN0W2lkeF0sIHNlY29uZCkgJiYgIV9jb250YWlucyhmaXJzdFtpZHhdLCBvdXQpKSB7XG4gICAgICBvdXRbb3V0Lmxlbmd0aF0gPSBmaXJzdFtpZHhdO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gb3V0O1xufSk7XG5leHBvcnQgZGVmYXVsdCBkaWZmZXJlbmNlOyIsImltcG9ydCBfY29udGFpbnNXaXRoIGZyb20gJy4vaW50ZXJuYWwvX2NvbnRhaW5zV2l0aCc7XG5pbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgb2YgYWxsIGVsZW1lbnRzIGluIHRoZSBmaXJzdCBsaXN0IG5vdFxuICogY29udGFpbmVkIGluIHRoZSBzZWNvbmQgbGlzdC4gRHVwbGljYXRpb24gaXMgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG8gdGhlXG4gKiB2YWx1ZSByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIHR3byBsaXN0IGVsZW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnICgoYSwgYSkgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdXNlZCB0byB0ZXN0IHdoZXRoZXIgdHdvIGl0ZW1zIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBlbGVtZW50cyBpbiBgbGlzdDFgIHRoYXQgYXJlIG5vdCBpbiBgbGlzdDJgLlxuICogQHNlZSBSLmRpZmZlcmVuY2UsIFIuc3ltbWV0cmljRGlmZmVyZW5jZSwgUi5zeW1tZXRyaWNEaWZmZXJlbmNlV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBjbXAgPSAoeCwgeSkgPT4geC5hID09PSB5LmE7XG4gKiAgICAgIHZhciBsMSA9IFt7YTogMX0sIHthOiAyfSwge2E6IDN9XTtcbiAqICAgICAgdmFyIGwyID0gW3thOiAzfSwge2E6IDR9XTtcbiAqICAgICAgUi5kaWZmZXJlbmNlV2l0aChjbXAsIGwxLCBsMik7IC8vPT4gW3thOiAxfSwge2E6IDJ9XVxuICovXG52YXIgZGlmZmVyZW5jZVdpdGggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBkaWZmZXJlbmNlV2l0aChwcmVkLCBmaXJzdCwgc2Vjb25kKSB7XG4gIHZhciBvdXQgPSBbXTtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBmaXJzdExlbiA9IGZpcnN0Lmxlbmd0aDtcbiAgd2hpbGUgKGlkeCA8IGZpcnN0TGVuKSB7XG4gICAgaWYgKCFfY29udGFpbnNXaXRoKHByZWQsIGZpcnN0W2lkeF0sIHNlY29uZCkgJiYgIV9jb250YWluc1dpdGgocHJlZCwgZmlyc3RbaWR4XSwgb3V0KSkge1xuICAgICAgb3V0LnB1c2goZmlyc3RbaWR4XSk7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBvdXQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGRpZmZlcmVuY2VXaXRoOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBvYmplY3QgdGhhdCBkb2VzIG5vdCBjb250YWluIGEgYHByb3BgIHByb3BlcnR5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgU3RyaW5nIC0+IHtrOiB2fSAtPiB7azogdn1cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBkaXNzb2NpYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IGVxdWl2YWxlbnQgdG8gdGhlIG9yaWdpbmFsIGJ1dCB3aXRob3V0IHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcbiAqIEBzZWUgUi5hc3NvY1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZGlzc29jKCdiJywge2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiB7YTogMSwgYzogM31cbiAqL1xudmFyIGRpc3NvYyA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGRpc3NvYyhwcm9wLCBvYmopIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIG9iaikge1xuICAgIHJlc3VsdFtwXSA9IG9ialtwXTtcbiAgfVxuICBkZWxldGUgcmVzdWx0W3Byb3BdO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5leHBvcnQgZGVmYXVsdCBkaXNzb2M7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfaXNJbnRlZ2VyIGZyb20gJy4vaW50ZXJuYWwvX2lzSW50ZWdlcic7XG5pbXBvcnQgYXNzb2MgZnJvbSAnLi9hc3NvYyc7XG5pbXBvcnQgZGlzc29jIGZyb20gJy4vZGlzc29jJztcbmltcG9ydCByZW1vdmUgZnJvbSAnLi9yZW1vdmUnO1xuaW1wb3J0IHVwZGF0ZSBmcm9tICcuL3VwZGF0ZSc7XG5cbi8qKlxuICogTWFrZXMgYSBzaGFsbG93IGNsb25lIG9mIGFuIG9iamVjdCwgb21pdHRpbmcgdGhlIHByb3BlcnR5IGF0IHRoZSBnaXZlbiBwYXRoLlxuICogTm90ZSB0aGF0IHRoaXMgY29waWVzIGFuZCBmbGF0dGVucyBwcm90b3R5cGUgcHJvcGVydGllcyBvbnRvIHRoZSBuZXcgb2JqZWN0XG4gKiBhcyB3ZWxsLiBBbGwgbm9uLXByaW1pdGl2ZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgYnkgcmVmZXJlbmNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjExLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBJZHggPSBTdHJpbmcgfCBJbnRcbiAqIEBzaWcgW0lkeF0gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byB0aGUgdmFsdWUgdG8gb21pdFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNsb25lXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRob3V0IHRoZSBwcm9wZXJ0eSBhdCBwYXRoXG4gKiBAc2VlIFIuYXNzb2NQYXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5kaXNzb2NQYXRoKFsnYScsICdiJywgJ2MnXSwge2E6IHtiOiB7YzogNDJ9fX0pOyAvLz0+IHthOiB7Yjoge319fVxuICovXG52YXIgZGlzc29jUGF0aCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGRpc3NvY1BhdGgocGF0aCwgb2JqKSB7XG4gIHN3aXRjaCAocGF0aC5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gb2JqO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBfaXNJbnRlZ2VyKHBhdGhbMF0pID8gcmVtb3ZlKHBhdGhbMF0sIDEsIG9iaikgOiBkaXNzb2MocGF0aFswXSwgb2JqKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGhlYWQgPSBwYXRoWzBdO1xuICAgICAgdmFyIHRhaWwgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChwYXRoLCAxKTtcbiAgICAgIGlmIChvYmpbaGVhZF0gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSBlbHNlIGlmIChfaXNJbnRlZ2VyKHBhdGhbMF0pKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGUoaGVhZCwgZGlzc29jUGF0aCh0YWlsLCBvYmpbaGVhZF0pLCBvYmopO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFzc29jKGhlYWQsIGRpc3NvY1BhdGgodGFpbCwgb2JqW2hlYWRdKSwgb2JqKTtcbiAgICAgIH1cbiAgfVxufSk7XG5leHBvcnQgZGVmYXVsdCBkaXNzb2NQYXRoOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gbnVtYmVycy4gRXF1aXZhbGVudCB0byBgYSAvIGJgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgdmFsdWUuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGEgLyBiYC5cbiAqIEBzZWUgUi5tdWx0aXBseVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZGl2aWRlKDcxLCAxMDApOyAvLz0+IDAuNzFcbiAqXG4gKiAgICAgIHZhciBoYWxmID0gUi5kaXZpZGUoUi5fXywgMik7XG4gKiAgICAgIGhhbGYoNDIpOyAvLz0+IDIxXG4gKlxuICogICAgICB2YXIgcmVjaXByb2NhbCA9IFIuZGl2aWRlKDEpO1xuICogICAgICByZWNpcHJvY2FsKDQpOyAgIC8vPT4gMC4yNVxuICovXG52YXIgZGl2aWRlID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gZGl2aWRlKGEsIGIpIHtcbiAgcmV0dXJuIGEgLyBiO1xufSk7XG5leHBvcnQgZGVmYXVsdCBkaXZpZGU7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZSc7XG5pbXBvcnQgX3hkcm9wIGZyb20gJy4vaW50ZXJuYWwvX3hkcm9wJztcbmltcG9ydCBzbGljZSBmcm9tICcuL3NsaWNlJztcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBidXQgdGhlIGZpcnN0IGBuYCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gbGlzdCwgc3RyaW5nLCBvclxuICogdHJhbnNkdWNlci90cmFuc2Zvcm1lciAob3Igb2JqZWN0IHdpdGggYSBgZHJvcGAgbWV0aG9kKS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgZHJvcGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEBwYXJhbSB7Kn0gbGlzdFxuICogQHJldHVybiB7Kn0gQSBjb3B5IG9mIGxpc3Qgd2l0aG91dCB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzXG4gKiBAc2VlIFIudGFrZSwgUi50cmFuc2R1Y2UsIFIuZHJvcExhc3QsIFIuZHJvcFdoaWxlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5kcm9wKDEsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydiYXInLCAnYmF6J11cbiAqICAgICAgUi5kcm9wKDIsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydiYXonXVxuICogICAgICBSLmRyb3AoMywgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbXVxuICogICAgICBSLmRyb3AoNCwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbXVxuICogICAgICBSLmRyb3AoMywgJ3JhbWRhJyk7ICAgICAgICAgICAgICAgLy89PiAnZGEnXG4gKi9cbnZhciBkcm9wID0gLyojX19QVVJFX18qL19jdXJyeTIoIC8qI19fUFVSRV9fKi9fZGlzcGF0Y2hhYmxlKFsnZHJvcCddLCBfeGRyb3AsIGZ1bmN0aW9uIGRyb3AobiwgeHMpIHtcbiAgcmV0dXJuIHNsaWNlKE1hdGgubWF4KDAsIG4pLCBJbmZpbml0eSwgeHMpO1xufSkpO1xuZXhwb3J0IGRlZmF1bHQgZHJvcDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfZHJvcExhc3QgZnJvbSAnLi9pbnRlcm5hbC9fZHJvcExhc3QnO1xuaW1wb3J0IF94ZHJvcExhc3QgZnJvbSAnLi9pbnRlcm5hbC9feGRyb3BMYXN0JztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBjb250YWluaW5nIGFsbCBidXQgdGhlIGxhc3QgYG5gIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBgbGlzdGAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgYGxpc3RgIHRvIHNraXAuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IG9mIGVsZW1lbnRzIHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXl9IEEgY29weSBvZiB0aGUgbGlzdCB3aXRoIG9ubHkgdGhlIGZpcnN0IGBsaXN0Lmxlbmd0aCAtIG5gIGVsZW1lbnRzXG4gKiBAc2VlIFIudGFrZUxhc3QsIFIuZHJvcCwgUi5kcm9wV2hpbGUsIFIuZHJvcExhc3RXaGlsZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZHJvcExhc3QoMSwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbycsICdiYXInXVxuICogICAgICBSLmRyb3BMYXN0KDIsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nXVxuICogICAgICBSLmRyb3BMYXN0KDMsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gW11cbiAqICAgICAgUi5kcm9wTGFzdCg0LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFtdXG4gKiAgICAgIFIuZHJvcExhc3QoMywgJ3JhbWRhJyk7ICAgICAgICAgICAgICAgLy89PiAncmEnXG4gKi9cbnZhciBkcm9wTGFzdCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovX2Rpc3BhdGNoYWJsZShbXSwgX3hkcm9wTGFzdCwgX2Ryb3BMYXN0KSk7XG5leHBvcnQgZGVmYXVsdCBkcm9wTGFzdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfZHJvcExhc3RXaGlsZSBmcm9tICcuL2ludGVybmFsL19kcm9wTGFzdFdoaWxlJztcbmltcG9ydCBfeGRyb3BMYXN0V2hpbGUgZnJvbSAnLi9pbnRlcm5hbC9feGRyb3BMYXN0V2hpbGUnO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBleGNsdWRpbmcgYWxsIHRoZSB0YWlsaW5nIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gbGlzdCB3aGljaFxuICogc2F0aXNmeSB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIGZ1bmN0aW9uLiBJdCBwYXNzZXMgZWFjaCB2YWx1ZSBmcm9tIHRoZSByaWdodFxuICogdG8gdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbiwgc2tpcHBpbmcgZWxlbWVudHMgdW50aWwgdGhlIHByZWRpY2F0ZVxuICogZnVuY3Rpb24gcmV0dXJucyBhIGBmYWxzeWAgdmFsdWUuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gaXMgYXBwbGllZCB0byBvbmUgYXJndW1lbnQ6XG4gKiAqKHZhbHVlKSouXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBlYWNoIGVsZW1lbnRcbiAqIEBwYXJhbSB7QXJyYXl9IHhzIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBhcnJheSB3aXRob3V0IGFueSB0cmFpbGluZyBlbGVtZW50cyB0aGF0IHJldHVybiBgZmFsc3lgIHZhbHVlcyBmcm9tIHRoZSBgcHJlZGljYXRlYC5cbiAqIEBzZWUgUi50YWtlTGFzdFdoaWxlLCBSLmFkZEluZGV4LCBSLmRyb3AsIFIuZHJvcFdoaWxlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGx0ZVRocmVlID0geCA9PiB4IDw9IDM7XG4gKlxuICogICAgICBSLmRyb3BMYXN0V2hpbGUobHRlVGhyZWUsIFsxLCAyLCAzLCA0LCAzLCAyLCAxXSk7IC8vPT4gWzEsIDIsIDMsIDRdXG4gKlxuICogICAgICBSLmRyb3BMYXN0V2hpbGUoeCA9PiB4ICE9PSAnZCcgLCAnUmFtZGEnKTsgLy89PiAnUmFtZCdcbiAqL1xudmFyIGRyb3BMYXN0V2hpbGUgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoW10sIF94ZHJvcExhc3RXaGlsZSwgX2Ryb3BMYXN0V2hpbGUpKTtcbmV4cG9ydCBkZWZhdWx0IGRyb3BMYXN0V2hpbGU7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZSc7XG5pbXBvcnQgX3hkcm9wUmVwZWF0c1dpdGggZnJvbSAnLi9pbnRlcm5hbC9feGRyb3BSZXBlYXRzV2l0aCc7XG5pbXBvcnQgZHJvcFJlcGVhdHNXaXRoIGZyb20gJy4vZHJvcFJlcGVhdHNXaXRoJztcbmltcG9ydCBlcXVhbHMgZnJvbSAnLi9lcXVhbHMnO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCB3aXRob3V0IGFueSBjb25zZWN1dGl2ZWx5IHJlcGVhdGluZyBlbGVtZW50cy5cbiAqIFtgUi5lcXVhbHNgXSgjZXF1YWxzKSBpcyB1c2VkIHRvIGRldGVybWluZSBlcXVhbGl0eS5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFthXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gYGxpc3RgIHdpdGhvdXQgcmVwZWF0aW5nIGVsZW1lbnRzLlxuICogQHNlZSBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgUi5kcm9wUmVwZWF0cyhbMSwgMSwgMSwgMiwgMywgNCwgNCwgMiwgMl0pOyAvLz0+IFsxLCAyLCAzLCA0LCAyXVxuICovXG52YXIgZHJvcFJlcGVhdHMgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MSggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoW10sIC8qI19fUFVSRV9fKi9feGRyb3BSZXBlYXRzV2l0aChlcXVhbHMpLCAvKiNfX1BVUkVfXyovZHJvcFJlcGVhdHNXaXRoKGVxdWFscykpKTtcbmV4cG9ydCBkZWZhdWx0IGRyb3BSZXBlYXRzOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tICcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnO1xuaW1wb3J0IF94ZHJvcFJlcGVhdHNXaXRoIGZyb20gJy4vaW50ZXJuYWwvX3hkcm9wUmVwZWF0c1dpdGgnO1xuaW1wb3J0IGxhc3QgZnJvbSAnLi9sYXN0JztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3Qgd2l0aG91dCBhbnkgY29uc2VjdXRpdmVseSByZXBlYXRpbmcgZWxlbWVudHMuIEVxdWFsaXR5IGlzXG4gKiBkZXRlcm1pbmVkIGJ5IGFwcGx5aW5nIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgdG8gZWFjaCBwYWlyIG9mIGNvbnNlY3V0aXZlIGVsZW1lbnRzLiBUaGVcbiAqIGZpcnN0IGVsZW1lbnQgaW4gYSBzZXJpZXMgb2YgZXF1YWwgZWxlbWVudHMgd2lsbCBiZSBwcmVzZXJ2ZWQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSwgYSkgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB1c2VkIHRvIHRlc3Qgd2hldGhlciB0d28gaXRlbXMgYXJlIGVxdWFsLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gYGxpc3RgIHdpdGhvdXQgcmVwZWF0aW5nIGVsZW1lbnRzLlxuICogQHNlZSBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBsID0gWzEsIC0xLCAxLCAzLCA0LCAtNCwgLTQsIC01LCA1LCAzLCAzXTtcbiAqICAgICAgUi5kcm9wUmVwZWF0c1dpdGgoUi5lcUJ5KE1hdGguYWJzKSwgbCk7IC8vPT4gWzEsIDMsIDQsIC01LCAzXVxuICovXG52YXIgZHJvcFJlcGVhdHNXaXRoID0gLyojX19QVVJFX18qL19jdXJyeTIoIC8qI19fUFVSRV9fKi9fZGlzcGF0Y2hhYmxlKFtdLCBfeGRyb3BSZXBlYXRzV2l0aCwgZnVuY3Rpb24gZHJvcFJlcGVhdHNXaXRoKHByZWQsIGxpc3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaWR4ID0gMTtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICBpZiAobGVuICE9PSAwKSB7XG4gICAgcmVzdWx0WzBdID0gbGlzdFswXTtcbiAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICBpZiAoIXByZWQobGFzdChyZXN1bHQpLCBsaXN0W2lkeF0pKSB7XG4gICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGxpc3RbaWR4XTtcbiAgICAgIH1cbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSkpO1xuZXhwb3J0IGRlZmF1bHQgZHJvcFJlcGVhdHNXaXRoOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tICcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnO1xuaW1wb3J0IF94ZHJvcFdoaWxlIGZyb20gJy4vaW50ZXJuYWwvX3hkcm9wV2hpbGUnO1xuaW1wb3J0IHNsaWNlIGZyb20gJy4vc2xpY2UnO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBleGNsdWRpbmcgdGhlIGxlYWRpbmcgZWxlbWVudHMgb2YgYSBnaXZlbiBsaXN0IHdoaWNoXG4gKiBzYXRpc2Z5IHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgZnVuY3Rpb24uIEl0IHBhc3NlcyBlYWNoIHZhbHVlIHRvIHRoZSBzdXBwbGllZFxuICogcHJlZGljYXRlIGZ1bmN0aW9uLCBza2lwcGluZyBlbGVtZW50cyB3aGlsZSB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnNcbiAqIGB0cnVlYC4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIG9uZSBhcmd1bWVudDogKih2YWx1ZSkqLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBkcm9wV2hpbGVgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtBcnJheX0geHMgVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICogQHNlZSBSLnRha2VXaGlsZSwgUi50cmFuc2R1Y2UsIFIuYWRkSW5kZXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbHRlVHdvID0geCA9PiB4IDw9IDI7XG4gKlxuICogICAgICBSLmRyb3BXaGlsZShsdGVUd28sIFsxLCAyLCAzLCA0LCAzLCAyLCAxXSk7IC8vPT4gWzMsIDQsIDMsIDIsIDFdXG4gKlxuICogICAgICBSLmRyb3BXaGlsZSh4ID0+IHggIT09ICdkJyAsICdSYW1kYScpOyAvLz0+ICdkYSdcbiAqL1xudmFyIGRyb3BXaGlsZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovX2Rpc3BhdGNoYWJsZShbJ2Ryb3BXaGlsZSddLCBfeGRyb3BXaGlsZSwgZnVuY3Rpb24gZHJvcFdoaWxlKHByZWQsIHhzKSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0geHMubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgbGVuICYmIHByZWQoeHNbaWR4XSkpIHtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gc2xpY2UoaWR4LCBJbmZpbml0eSwgeHMpO1xufSkpO1xuZXhwb3J0IGRlZmF1bHQgZHJvcFdoaWxlOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2lzRnVuY3Rpb24gZnJvbSAnLi9pbnRlcm5hbC9faXNGdW5jdGlvbic7XG5pbXBvcnQgbGlmdCBmcm9tICcuL2xpZnQnO1xuaW1wb3J0IG9yIGZyb20gJy4vb3InO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gd3JhcHBpbmcgY2FsbHMgdG8gdGhlIHR3byBmdW5jdGlvbnMgaW4gYW4gYHx8YCBvcGVyYXRpb24sXG4gKiByZXR1cm5pbmcgdGhlIHJlc3VsdCBvZiB0aGUgZmlyc3QgZnVuY3Rpb24gaWYgaXQgaXMgdHJ1dGgteSBhbmQgdGhlIHJlc3VsdFxuICogb2YgdGhlIHNlY29uZCBmdW5jdGlvbiBvdGhlcndpc2UuIE5vdGUgdGhhdCB0aGlzIGlzIHNob3J0LWNpcmN1aXRlZCxcbiAqIG1lYW5pbmcgdGhhdCB0aGUgc2Vjb25kIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGludm9rZWQgaWYgdGhlIGZpcnN0IHJldHVybnMgYVxuICogdHJ1dGgteSB2YWx1ZS5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBmdW5jdGlvbnMsIGBSLmVpdGhlcmAgYWxzbyBhY2NlcHRzIGFueSBmYW50YXN5LWxhbmQgY29tcGF0aWJsZVxuICogYXBwbGljYXRpdmUgZnVuY3Rvci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMi4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKCouLi4gLT4gQm9vbGVhbikgLT4gKCouLi4gLT4gQm9vbGVhbikgLT4gKCouLi4gLT4gQm9vbGVhbilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGYgYSBwcmVkaWNhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGcgYW5vdGhlciBwcmVkaWNhdGVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBpdHMgYXJndW1lbnRzIHRvIGBmYCBhbmQgYGdgIGFuZCBgfHxgcyB0aGVpciBvdXRwdXRzIHRvZ2V0aGVyLlxuICogQHNlZSBSLm9yXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGd0MTAgPSB4ID0+IHggPiAxMDtcbiAqICAgICAgdmFyIGV2ZW4gPSB4ID0+IHggJSAyID09PSAwO1xuICogICAgICB2YXIgZiA9IFIuZWl0aGVyKGd0MTAsIGV2ZW4pO1xuICogICAgICBmKDEwMSk7IC8vPT4gdHJ1ZVxuICogICAgICBmKDgpOyAvLz0+IHRydWVcbiAqL1xudmFyIGVpdGhlciA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGVpdGhlcihmLCBnKSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbihmKSA/IGZ1bmN0aW9uIF9laXRoZXIoKSB7XG4gICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCBnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0gOiBsaWZ0KG9yKShmLCBnKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgZWl0aGVyOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgX2lzQXJndW1lbnRzIGZyb20gJy4vaW50ZXJuYWwvX2lzQXJndW1lbnRzJztcbmltcG9ydCBfaXNBcnJheSBmcm9tICcuL2ludGVybmFsL19pc0FycmF5JztcbmltcG9ydCBfaXNPYmplY3QgZnJvbSAnLi9pbnRlcm5hbC9faXNPYmplY3QnO1xuaW1wb3J0IF9pc1N0cmluZyBmcm9tICcuL2ludGVybmFsL19pc1N0cmluZyc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZW1wdHkgdmFsdWUgb2YgaXRzIGFyZ3VtZW50J3MgdHlwZS4gUmFtZGEgZGVmaW5lcyB0aGUgZW1wdHlcbiAqIHZhbHVlIG9mIEFycmF5IChgW11gKSwgT2JqZWN0IChge31gKSwgU3RyaW5nIChgJydgKSwgYW5kIEFyZ3VtZW50cy4gT3RoZXJcbiAqIHR5cGVzIGFyZSBzdXBwb3J0ZWQgaWYgdGhleSBkZWZpbmUgYDxUeXBlPi5lbXB0eWAsXG4gKiBgPFR5cGU+LnByb3RvdHlwZS5lbXB0eWAgb3IgaW1wbGVtZW50IHRoZVxuICogW0ZhbnRhc3lMYW5kIE1vbm9pZCBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI21vbm9pZCkuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGVtcHR5YCBtZXRob2Qgb2YgdGhlIGZpcnN0IGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIGEgLT4gYVxuICogQHBhcmFtIHsqfSB4XG4gKiBAcmV0dXJuIHsqfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZW1wdHkoSnVzdCg0MikpOyAgICAgIC8vPT4gTm90aGluZygpXG4gKiAgICAgIFIuZW1wdHkoWzEsIDIsIDNdKTsgICAgIC8vPT4gW11cbiAqICAgICAgUi5lbXB0eSgndW5pY29ybnMnKTsgICAgLy89PiAnJ1xuICogICAgICBSLmVtcHR5KHt4OiAxLCB5OiAyfSk7ICAvLz0+IHt9XG4gKi9cbnZhciBlbXB0eSA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGVtcHR5KHgpIHtcbiAgcmV0dXJuIHggIT0gbnVsbCAmJiB0eXBlb2YgeFsnZmFudGFzeS1sYW5kL2VtcHR5J10gPT09ICdmdW5jdGlvbicgPyB4WydmYW50YXN5LWxhbmQvZW1wdHknXSgpIDogeCAhPSBudWxsICYmIHguY29uc3RydWN0b3IgIT0gbnVsbCAmJiB0eXBlb2YgeC5jb25zdHJ1Y3RvclsnZmFudGFzeS1sYW5kL2VtcHR5J10gPT09ICdmdW5jdGlvbicgPyB4LmNvbnN0cnVjdG9yWydmYW50YXN5LWxhbmQvZW1wdHknXSgpIDogeCAhPSBudWxsICYmIHR5cGVvZiB4LmVtcHR5ID09PSAnZnVuY3Rpb24nID8geC5lbXB0eSgpIDogeCAhPSBudWxsICYmIHguY29uc3RydWN0b3IgIT0gbnVsbCAmJiB0eXBlb2YgeC5jb25zdHJ1Y3Rvci5lbXB0eSA9PT0gJ2Z1bmN0aW9uJyA/IHguY29uc3RydWN0b3IuZW1wdHkoKSA6IF9pc0FycmF5KHgpID8gW10gOiBfaXNTdHJpbmcoeCkgPyAnJyA6IF9pc09iamVjdCh4KSA/IHt9IDogX2lzQXJndW1lbnRzKHgpID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmd1bWVudHM7XG4gIH0oKSA6XG4gIC8vIGVsc2VcbiAgdm9pZCAwO1xufSk7XG5leHBvcnQgZGVmYXVsdCBlbXB0eTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IGVxdWFscyBmcm9tICcuL2VxdWFscyc7XG5pbXBvcnQgdGFrZUxhc3QgZnJvbSAnLi90YWtlTGFzdCc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBlbmRzIHdpdGggdGhlIHByb3ZpZGVkIHZhbHVlc1xuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI0LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBCb29sZWFuXG4gKiBAc2lnIFN0cmluZyAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IHN1ZmZpeFxuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZW5kc1dpdGgoJ2MnLCAnYWJjJykgICAgICAgICAgICAgICAgLy89PiB0cnVlXG4gKiAgICAgIFIuZW5kc1dpdGgoJ2InLCAnYWJjJykgICAgICAgICAgICAgICAgLy89PiBmYWxzZVxuICogICAgICBSLmVuZHNXaXRoKFsnYyddLCBbJ2EnLCAnYicsICdjJ10pICAgIC8vPT4gdHJ1ZVxuICogICAgICBSLmVuZHNXaXRoKFsnYiddLCBbJ2EnLCAnYicsICdjJ10pICAgIC8vPT4gZmFsc2VcbiAqL1xudmFyIGVuZHNXaXRoID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gKHN1ZmZpeCwgbGlzdCkge1xuICByZXR1cm4gZXF1YWxzKHRha2VMYXN0KHN1ZmZpeC5sZW5ndGgsIGxpc3QpLCBzdWZmaXgpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBlbmRzV2l0aDsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuaW1wb3J0IGVxdWFscyBmcm9tICcuL2VxdWFscyc7XG5cbi8qKlxuICogVGFrZXMgYSBmdW5jdGlvbiBhbmQgdHdvIHZhbHVlcyBpbiBpdHMgZG9tYWluIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGVcbiAqIHZhbHVlcyBtYXAgdG8gdGhlIHNhbWUgdmFsdWUgaW4gdGhlIGNvZG9tYWluOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOC4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgKGEgLT4gYikgLT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEBwYXJhbSB7Kn0geFxuICogQHBhcmFtIHsqfSB5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZXFCeShNYXRoLmFicywgNSwgLTUpOyAvLz0+IHRydWVcbiAqL1xudmFyIGVxQnkgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBlcUJ5KGYsIHgsIHkpIHtcbiAgcmV0dXJuIGVxdWFscyhmKHgpLCBmKHkpKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgZXFCeTsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuaW1wb3J0IGVxdWFscyBmcm9tICcuL2VxdWFscyc7XG5cbi8qKlxuICogUmVwb3J0cyB3aGV0aGVyIHR3byBvYmplY3RzIGhhdmUgdGhlIHNhbWUgdmFsdWUsIGluIFtgUi5lcXVhbHNgXSgjZXF1YWxzKVxuICogdGVybXMsIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LiBVc2VmdWwgYXMgYSBjdXJyaWVkIHByZWRpY2F0ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgayAtPiB7azogdn0gLT4ge2s6IHZ9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMVxuICogQHBhcmFtIHtPYmplY3R9IG9iajJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBvMSA9IHsgYTogMSwgYjogMiwgYzogMywgZDogNCB9O1xuICogICAgICB2YXIgbzIgPSB7IGE6IDEwLCBiOiAyMCwgYzogMywgZDogNDAgfTtcbiAqICAgICAgUi5lcVByb3BzKCdhJywgbzEsIG8yKTsgLy89PiBmYWxzZVxuICogICAgICBSLmVxUHJvcHMoJ2MnLCBvMSwgbzIpOyAvLz0+IHRydWVcbiAqL1xudmFyIGVxUHJvcHMgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBlcVByb3BzKHByb3AsIG9iajEsIG9iajIpIHtcbiAgcmV0dXJuIGVxdWFscyhvYmoxW3Byb3BdLCBvYmoyW3Byb3BdKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgZXFQcm9wczsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9lcXVhbHMgZnJvbSAnLi9pbnRlcm5hbC9fZXF1YWxzJztcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBpdHMgYXJndW1lbnRzIGFyZSBlcXVpdmFsZW50LCBgZmFsc2VgIG90aGVyd2lzZS4gSGFuZGxlc1xuICogY3ljbGljYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICpcbiAqIERpc3BhdGNoZXMgc3ltbWV0cmljYWxseSB0byB0aGUgYGVxdWFsc2AgbWV0aG9kcyBvZiBib3RoIGFyZ3VtZW50cywgaWZcbiAqIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTUuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIGEgLT4gYiAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmVxdWFscygxLCAxKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuZXF1YWxzKDEsICcxJyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5lcXVhbHMoWzEsIDIsIDNdLCBbMSwgMiwgM10pOyAvLz0+IHRydWVcbiAqXG4gKiAgICAgIHZhciBhID0ge307IGEudiA9IGE7XG4gKiAgICAgIHZhciBiID0ge307IGIudiA9IGI7XG4gKiAgICAgIFIuZXF1YWxzKGEsIGIpOyAvLz0+IHRydWVcbiAqL1xudmFyIGVxdWFscyA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBfZXF1YWxzKGEsIGIsIFtdLCBbXSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGVxdWFsczsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IGJ5IHJlY3Vyc2l2ZWx5IGV2b2x2aW5nIGEgc2hhbGxvdyBjb3B5IG9mIGBvYmplY3RgLFxuICogYWNjb3JkaW5nIHRvIHRoZSBgdHJhbnNmb3JtYXRpb25gIGZ1bmN0aW9ucy4gQWxsIG5vbi1wcmltaXRpdmUgcHJvcGVydGllc1xuICogYXJlIGNvcGllZCBieSByZWZlcmVuY2UuXG4gKlxuICogQSBgdHJhbnNmb3JtYXRpb25gIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGludm9rZWQgaWYgaXRzIGNvcnJlc3BvbmRpbmcga2V5XG4gKiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZXZvbHZlZCBvYmplY3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtrOiAodiAtPiB2KX0gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybWF0aW9ucyBUaGUgb2JqZWN0IHNwZWNpZnlpbmcgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zIHRvIGFwcGx5XG4gKiAgICAgICAgdG8gdGhlIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSB0cmFuc2Zvcm1lZC5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHRyYW5zZm9ybWVkIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgdG9tYXRvICA9IHtmaXJzdE5hbWU6ICcgIFRvbWF0byAnLCBkYXRhOiB7ZWxhcHNlZDogMTAwLCByZW1haW5pbmc6IDE0MDB9LCBpZDoxMjN9O1xuICogICAgICB2YXIgdHJhbnNmb3JtYXRpb25zID0ge1xuICogICAgICAgIGZpcnN0TmFtZTogUi50cmltLFxuICogICAgICAgIGxhc3ROYW1lOiBSLnRyaW0sIC8vIFdpbGwgbm90IGdldCBpbnZva2VkLlxuICogICAgICAgIGRhdGE6IHtlbGFwc2VkOiBSLmFkZCgxKSwgcmVtYWluaW5nOiBSLmFkZCgtMSl9XG4gKiAgICAgIH07XG4gKiAgICAgIFIuZXZvbHZlKHRyYW5zZm9ybWF0aW9ucywgdG9tYXRvKTsgLy89PiB7Zmlyc3ROYW1lOiAnVG9tYXRvJywgZGF0YToge2VsYXBzZWQ6IDEwMSwgcmVtYWluaW5nOiAxMzk5fSwgaWQ6MTIzfVxuICovXG52YXIgZXZvbHZlID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gZXZvbHZlKHRyYW5zZm9ybWF0aW9ucywgb2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIHRyYW5zZm9ybWF0aW9uLCBrZXksIHR5cGU7XG4gIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgIHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb25zW2tleV07XG4gICAgdHlwZSA9IHR5cGVvZiB0cmFuc2Zvcm1hdGlvbjtcbiAgICByZXN1bHRba2V5XSA9IHR5cGUgPT09ICdmdW5jdGlvbicgPyB0cmFuc2Zvcm1hdGlvbihvYmplY3Rba2V5XSkgOiB0cmFuc2Zvcm1hdGlvbiAmJiB0eXBlID09PSAnb2JqZWN0JyA/IGV2b2x2ZSh0cmFuc2Zvcm1hdGlvbiwgb2JqZWN0W2tleV0pIDogb2JqZWN0W2tleV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgZXZvbHZlOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tICcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnO1xuaW1wb3J0IF9maWx0ZXIgZnJvbSAnLi9pbnRlcm5hbC9fZmlsdGVyJztcbmltcG9ydCBfaXNPYmplY3QgZnJvbSAnLi9pbnRlcm5hbC9faXNPYmplY3QnO1xuaW1wb3J0IF9yZWR1Y2UgZnJvbSAnLi9pbnRlcm5hbC9fcmVkdWNlJztcbmltcG9ydCBfeGZpbHRlciBmcm9tICcuL2ludGVybmFsL194ZmlsdGVyJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cyc7XG5cbi8qKlxuICogVGFrZXMgYSBwcmVkaWNhdGUgYW5kIGEgYEZpbHRlcmFibGVgLCBhbmQgcmV0dXJucyBhIG5ldyBmaWx0ZXJhYmxlIG9mIHRoZVxuICogc2FtZSB0eXBlIGNvbnRhaW5pbmcgdGhlIG1lbWJlcnMgb2YgdGhlIGdpdmVuIGZpbHRlcmFibGUgd2hpY2ggc2F0aXNmeSB0aGVcbiAqIGdpdmVuIHByZWRpY2F0ZS4gRmlsdGVyYWJsZSBvYmplY3RzIGluY2x1ZGUgcGxhaW4gb2JqZWN0cyBvciBhbnkgb2JqZWN0XG4gKiB0aGF0IGhhcyBhIGZpbHRlciBtZXRob2Qgc3VjaCBhcyBgQXJyYXlgLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBmaWx0ZXJgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIEZpbHRlcmFibGUgZiA9PiAoYSAtPiBCb29sZWFuKSAtPiBmIGEgLT4gZiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJhYmxlXG4gKiBAcmV0dXJuIHtBcnJheX0gRmlsdGVyYWJsZVxuICogQHNlZSBSLnJlamVjdCwgUi50cmFuc2R1Y2UsIFIuYWRkSW5kZXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaXNFdmVuID0gbiA9PiBuICUgMiA9PT0gMDtcbiAqXG4gKiAgICAgIFIuZmlsdGVyKGlzRXZlbiwgWzEsIDIsIDMsIDRdKTsgLy89PiBbMiwgNF1cbiAqXG4gKiAgICAgIFIuZmlsdGVyKGlzRXZlbiwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YjogMiwgZDogNH1cbiAqL1xudmFyIGZpbHRlciA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovX2Rpc3BhdGNoYWJsZShbJ2ZpbHRlciddLCBfeGZpbHRlciwgZnVuY3Rpb24gKHByZWQsIGZpbHRlcmFibGUpIHtcbiAgcmV0dXJuIF9pc09iamVjdChmaWx0ZXJhYmxlKSA/IF9yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgaWYgKHByZWQoZmlsdGVyYWJsZVtrZXldKSkge1xuICAgICAgYWNjW2tleV0gPSBmaWx0ZXJhYmxlW2tleV07XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9LCBrZXlzKGZpbHRlcmFibGUpKSA6XG4gIC8vIGVsc2VcbiAgX2ZpbHRlcihwcmVkLCBmaWx0ZXJhYmxlKTtcbn0pKTtcbmV4cG9ydCBkZWZhdWx0IGZpbHRlcjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfeGZpbmQgZnJvbSAnLi9pbnRlcm5hbC9feGZpbmQnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGUgcHJlZGljYXRlLCBvclxuICogYHVuZGVmaW5lZGAgaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBmaW5kYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gYSB8IHVuZGVmaW5lZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyB0aGVcbiAqICAgICAgICBkZXNpcmVkIG9uZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZWxlbWVudCBmb3VuZCwgb3IgYHVuZGVmaW5lZGAuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHhzID0gW3thOiAxfSwge2E6IDJ9LCB7YTogM31dO1xuICogICAgICBSLmZpbmQoUi5wcm9wRXEoJ2EnLCAyKSkoeHMpOyAvLz0+IHthOiAyfVxuICogICAgICBSLmZpbmQoUi5wcm9wRXEoJ2EnLCA0KSkoeHMpOyAvLz0+IHVuZGVmaW5lZFxuICovXG52YXIgZmluZCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovX2Rpc3BhdGNoYWJsZShbJ2ZpbmQnXSwgX3hmaW5kLCBmdW5jdGlvbiBmaW5kKGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgcmV0dXJuIGxpc3RbaWR4XTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbn0pKTtcbmV4cG9ydCBkZWZhdWx0IGZpbmQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZSc7XG5pbXBvcnQgX3hmaW5kSW5kZXggZnJvbSAnLi9pbnRlcm5hbC9feGZpbmRJbmRleCc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGVcbiAqIHByZWRpY2F0ZSwgb3IgYC0xYCBpZiBubyBlbGVtZW50IG1hdGNoZXMuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMVxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IE51bWJlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyB0aGVcbiAqIGRlc2lyZWQgb25lLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBmb3VuZCwgb3IgYC0xYC5cbiAqIEBzZWUgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgeHMgPSBbe2E6IDF9LCB7YTogMn0sIHthOiAzfV07XG4gKiAgICAgIFIuZmluZEluZGV4KFIucHJvcEVxKCdhJywgMikpKHhzKTsgLy89PiAxXG4gKiAgICAgIFIuZmluZEluZGV4KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiAtMVxuICovXG52YXIgZmluZEluZGV4ID0gLyojX19QVVJFX18qL19jdXJyeTIoIC8qI19fUFVSRV9fKi9fZGlzcGF0Y2hhYmxlKFtdLCBfeGZpbmRJbmRleCwgZnVuY3Rpb24gZmluZEluZGV4KGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSkpO1xuZXhwb3J0IGRlZmF1bHQgZmluZEluZGV4OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tICcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnO1xuaW1wb3J0IF94ZmluZExhc3QgZnJvbSAnLi9pbnRlcm5hbC9feGZpbmRMYXN0JztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGUgcHJlZGljYXRlLCBvclxuICogYHVuZGVmaW5lZGAgaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjFcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBhIHwgdW5kZWZpbmVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBlbGVtZW50IGlzIHRoZVxuICogZGVzaXJlZCBvbmUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGVsZW1lbnQgZm91bmQsIG9yIGB1bmRlZmluZWRgLlxuICogQHNlZSBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB4cyA9IFt7YTogMSwgYjogMH0sIHthOjEsIGI6IDF9XTtcbiAqICAgICAgUi5maW5kTGFzdChSLnByb3BFcSgnYScsIDEpKSh4cyk7IC8vPT4ge2E6IDEsIGI6IDF9XG4gKiAgICAgIFIuZmluZExhc3QoUi5wcm9wRXEoJ2EnLCA0KSkoeHMpOyAvLz0+IHVuZGVmaW5lZFxuICovXG52YXIgZmluZExhc3QgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoW10sIF94ZmluZExhc3QsIGZ1bmN0aW9uIGZpbmRMYXN0KGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gIHdoaWxlIChpZHggPj0gMCkge1xuICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICByZXR1cm4gbGlzdFtpZHhdO1xuICAgIH1cbiAgICBpZHggLT0gMTtcbiAgfVxufSkpO1xuZXhwb3J0IGRlZmF1bHQgZmluZExhc3Q7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZSc7XG5pbXBvcnQgX3hmaW5kTGFzdEluZGV4IGZyb20gJy4vaW50ZXJuYWwvX3hmaW5kTGFzdEluZGV4JztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBsaXN0IHdoaWNoIG1hdGNoZXMgdGhlXG4gKiBwcmVkaWNhdGUsIG9yIGAtMWAgaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjFcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGVsZW1lbnQgaXMgdGhlXG4gKiBkZXNpcmVkIG9uZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgZm91bmQsIG9yIGAtMWAuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHhzID0gW3thOiAxLCBiOiAwfSwge2E6MSwgYjogMX1dO1xuICogICAgICBSLmZpbmRMYXN0SW5kZXgoUi5wcm9wRXEoJ2EnLCAxKSkoeHMpOyAvLz0+IDFcbiAqICAgICAgUi5maW5kTGFzdEluZGV4KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiAtMVxuICovXG52YXIgZmluZExhc3RJbmRleCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovX2Rpc3BhdGNoYWJsZShbXSwgX3hmaW5kTGFzdEluZGV4LCBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gIHdoaWxlIChpZHggPj0gMCkge1xuICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICByZXR1cm4gaWR4O1xuICAgIH1cbiAgICBpZHggLT0gMTtcbiAgfVxuICByZXR1cm4gLTE7XG59KSk7XG5leHBvcnQgZGVmYXVsdCBmaW5kTGFzdEluZGV4OyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgX21ha2VGbGF0IGZyb20gJy4vaW50ZXJuYWwvX21ha2VGbGF0JztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QgYnkgcHVsbGluZyBldmVyeSBpdGVtIG91dCBvZiBpdCAoYW5kIGFsbCBpdHMgc3ViLWFycmF5cylcbiAqIGFuZCBwdXR0aW5nIHRoZW0gaW4gYSBuZXcgYXJyYXksIGRlcHRoLWZpcnN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFtiXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGZsYXR0ZW5lZCBsaXN0LlxuICogQHNlZSBSLnVubmVzdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZmxhdHRlbihbMSwgMiwgWzMsIDRdLCA1LCBbNiwgWzcsIDgsIFs5LCBbMTAsIDExXSwgMTJdXV1dKTtcbiAqICAgICAgLy89PiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMl1cbiAqL1xudmFyIGZsYXR0ZW4gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MSggLyojX19QVVJFX18qL19tYWtlRmxhdCh0cnVlKSk7XG5leHBvcnQgZGVmYXVsdCBmbGF0dGVuOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgY3VycnlOIGZyb20gJy4vY3VycnlOJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIG11Y2ggbGlrZSB0aGUgc3VwcGxpZWQgb25lLCBleGNlcHQgdGhhdCB0aGUgZmlyc3QgdHdvXG4gKiBhcmd1bWVudHMnIG9yZGVyIGlzIHJldmVyc2VkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgoYSwgYiwgYywgLi4uKSAtPiB6KSAtPiAoYiAtPiBhIC0+IGMgLT4gLi4uIC0+IHopXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIHdpdGggaXRzIGZpcnN0IHR3byBwYXJhbWV0ZXJzIHJldmVyc2VkLlxuICogQHJldHVybiB7Kn0gVGhlIHJlc3VsdCBvZiBpbnZva2luZyBgZm5gIHdpdGggaXRzIGZpcnN0IHR3byBwYXJhbWV0ZXJzJyBvcmRlciByZXZlcnNlZC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbWVyZ2VUaHJlZSA9IChhLCBiLCBjKSA9PiBbXS5jb25jYXQoYSwgYiwgYyk7XG4gKlxuICogICAgICBtZXJnZVRocmVlKDEsIDIsIDMpOyAvLz0+IFsxLCAyLCAzXVxuICpcbiAqICAgICAgUi5mbGlwKG1lcmdlVGhyZWUpKDEsIDIsIDMpOyAvLz0+IFsyLCAxLCAzXVxuICogQHN5bWIgUi5mbGlwKGYpKGEsIGIsIGMpID0gZihiLCBhLCBjKVxuICovXG52YXIgZmxpcCA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGZsaXAoZm4pIHtcbiAgcmV0dXJuIGN1cnJ5Tihmbi5sZW5ndGgsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIGFyZ3NbMF0gPSBiO1xuICAgIGFyZ3NbMV0gPSBhO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGZsaXA7IiwiaW1wb3J0IF9jaGVja0Zvck1ldGhvZCBmcm9tICcuL2ludGVybmFsL19jaGVja0Zvck1ldGhvZCc7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBpbnB1dCBgbGlzdGAsIGNhbGxpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiBgZm5gIGZvciBlYWNoXG4gKiBlbGVtZW50IGluIHRoZSBsaXN0LlxuICpcbiAqIGBmbmAgcmVjZWl2ZXMgb25lIGFyZ3VtZW50OiAqKHZhbHVlKSouXG4gKlxuICogTm90ZTogYFIuZm9yRWFjaGAgZG9lcyBub3Qgc2tpcCBkZWxldGVkIG9yIHVuYXNzaWduZWQgaW5kaWNlcyAoc3BhcnNlXG4gKiBhcnJheXMpLCB1bmxpa2UgdGhlIG5hdGl2ZSBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZC4gRm9yIG1vcmVcbiAqIGRldGFpbHMgb24gdGhpcyBiZWhhdmlvciwgc2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZm9yRWFjaCNEZXNjcmlwdGlvblxuICpcbiAqIEFsc28gbm90ZSB0aGF0LCB1bmxpa2UgYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCwgUmFtZGEncyBgZm9yRWFjaGAgcmV0dXJuc1xuICogdGhlIG9yaWdpbmFsIGFycmF5LiBJbiBzb21lIGxpYnJhcmllcyB0aGlzIGZ1bmN0aW9uIGlzIG5hbWVkIGBlYWNoYC5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgZm9yRWFjaGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4xXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiAqKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLiBSZWNlaXZlcyBvbmUgYXJndW1lbnQsIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgb3JpZ2luYWwgbGlzdC5cbiAqIEBzZWUgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBwcmludFhQbHVzRml2ZSA9IHggPT4gY29uc29sZS5sb2coeCArIDUpO1xuICogICAgICBSLmZvckVhY2gocHJpbnRYUGx1c0ZpdmUsIFsxLCAyLCAzXSk7IC8vPT4gWzEsIDIsIDNdXG4gKiAgICAgIC8vIGxvZ3MgNlxuICogICAgICAvLyBsb2dzIDdcbiAqICAgICAgLy8gbG9ncyA4XG4gKiBAc3ltYiBSLmZvckVhY2goZiwgW2EsIGIsIGNdKSA9IFthLCBiLCBjXVxuICovXG52YXIgZm9yRWFjaCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovX2NoZWNrRm9yTWV0aG9kKCdmb3JFYWNoJywgZnVuY3Rpb24gZm9yRWFjaChmbiwgbGlzdCkge1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgZm4obGlzdFtpZHhdKTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gbGlzdDtcbn0pKTtcbmV4cG9ydCBkZWZhdWx0IGZvckVhY2g7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cyc7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIGlucHV0IGBvYmplY3RgLCBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gYGZuYCBmb3IgZWFjaFxuICoga2V5IGFuZCB2YWx1ZSBpbiB0aGUgb2JqZWN0LlxuICpcbiAqIGBmbmAgcmVjZWl2ZXMgdGhyZWUgYXJndW1lbnQ6ICoodmFsdWUsIGtleSwgb2JqKSouXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjMuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyAoKGEsIFN0cmluZywgU3RyTWFwIGEpIC0+IEFueSkgLT4gU3RyTWFwIGEgLT4gU3RyTWFwIGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuIFJlY2VpdmVzIHRocmVlIGFyZ3VtZW50LCBgdmFsdWVgLCBga2V5YCwgYG9iamAuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgb3JpZ2luYWwgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBwcmludEtleUNvbmNhdFZhbHVlID0gKHZhbHVlLCBrZXkpID0+IGNvbnNvbGUubG9nKGtleSArICc6JyArIHZhbHVlKTtcbiAqICAgICAgUi5mb3JFYWNoT2JqSW5kZXhlZChwcmludEtleUNvbmNhdFZhbHVlLCB7eDogMSwgeTogMn0pOyAvLz0+IHt4OiAxLCB5OiAyfVxuICogICAgICAvLyBsb2dzIHg6MVxuICogICAgICAvLyBsb2dzIHk6MlxuICogQHN5bWIgUi5mb3JFYWNoT2JqSW5kZXhlZChmLCB7eDogYSwgeTogYn0pID0ge3g6IGEsIHk6IGJ9XG4gKi9cbnZhciBmb3JFYWNoT2JqSW5kZXhlZCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGZvckVhY2hPYmpJbmRleGVkKGZuLCBvYmopIHtcbiAgdmFyIGtleUxpc3QgPSBrZXlzKG9iaik7XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwga2V5TGlzdC5sZW5ndGgpIHtcbiAgICB2YXIga2V5ID0ga2V5TGlzdFtpZHhdO1xuICAgIGZuKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgZm9yRWFjaE9iakluZGV4ZWQ7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCBmcm9tIGEgbGlzdCBrZXktdmFsdWUgcGFpcnMuIElmIGEga2V5IGFwcGVhcnMgaW5cbiAqIG11bHRpcGxlIHBhaXJzLCB0aGUgcmlnaHRtb3N0IHBhaXIgaXMgaW5jbHVkZWQgaW4gdGhlIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFtbayx2XV0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge0FycmF5fSBwYWlycyBBbiBhcnJheSBvZiB0d28tZWxlbWVudCBhcnJheXMgdGhhdCB3aWxsIGJlIHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIG91dHB1dCBvYmplY3QuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvYmplY3QgbWFkZSBieSBwYWlyaW5nIHVwIGBrZXlzYCBhbmQgYHZhbHVlc2AuXG4gKiBAc2VlIFIudG9QYWlycywgUi5wYWlyXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dKTsgLy89PiB7YTogMSwgYjogMiwgYzogM31cbiAqL1xudmFyIGZyb21QYWlycyA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgcGFpcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0W3BhaXJzW2lkeF1bMF1dID0gcGFpcnNbaWR4XVsxXTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5leHBvcnQgZGVmYXVsdCBmcm9tUGFpcnM7IiwiaW1wb3J0IF9jaGVja0Zvck1ldGhvZCBmcm9tICcuL2ludGVybmFsL19jaGVja0Zvck1ldGhvZCc7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IHJlZHVjZUJ5IGZyb20gJy4vcmVkdWNlQnknO1xuXG4vKipcbiAqIFNwbGl0cyBhIGxpc3QgaW50byBzdWItbGlzdHMgc3RvcmVkIGluIGFuIG9iamVjdCwgYmFzZWQgb24gdGhlIHJlc3VsdCBvZlxuICogY2FsbGluZyBhIFN0cmluZy1yZXR1cm5pbmcgZnVuY3Rpb24gb24gZWFjaCBlbGVtZW50LCBhbmQgZ3JvdXBpbmcgdGhlXG4gKiByZXN1bHRzIGFjY29yZGluZyB0byB2YWx1ZXMgcmV0dXJuZWQuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGdyb3VwQnlgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IFN0cmluZykgLT4gW2FdIC0+IHtTdHJpbmc6IFthXX1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIDo6IGEgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBncm91cFxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgb3V0cHV0IG9mIGBmbmAgZm9yIGtleXMsIG1hcHBlZCB0byBhcnJheXMgb2YgZWxlbWVudHNcbiAqICAgICAgICAgdGhhdCBwcm9kdWNlZCB0aGF0IGtleSB3aGVuIHBhc3NlZCB0byBgZm5gLlxuICogQHNlZSBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBieUdyYWRlID0gUi5ncm91cEJ5KGZ1bmN0aW9uKHN0dWRlbnQpIHtcbiAqICAgICAgICB2YXIgc2NvcmUgPSBzdHVkZW50LnNjb3JlO1xuICogICAgICAgIHJldHVybiBzY29yZSA8IDY1ID8gJ0YnIDpcbiAqICAgICAgICAgICAgICAgc2NvcmUgPCA3MCA/ICdEJyA6XG4gKiAgICAgICAgICAgICAgIHNjb3JlIDwgODAgPyAnQycgOlxuICogICAgICAgICAgICAgICBzY29yZSA8IDkwID8gJ0InIDogJ0EnO1xuICogICAgICB9KTtcbiAqICAgICAgdmFyIHN0dWRlbnRzID0gW3tuYW1lOiAnQWJieScsIHNjb3JlOiA4NH0sXG4gKiAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0VkZHknLCBzY29yZTogNTh9LFxuICogICAgICAgICAgICAgICAgICAgICAgLy8gLi4uXG4gKiAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0phY2snLCBzY29yZTogNjl9XTtcbiAqICAgICAgYnlHcmFkZShzdHVkZW50cyk7XG4gKiAgICAgIC8vIHtcbiAqICAgICAgLy8gICAnQSc6IFt7bmFtZTogJ0RpYW5uZScsIHNjb3JlOiA5OX1dLFxuICogICAgICAvLyAgICdCJzogW3tuYW1lOiAnQWJieScsIHNjb3JlOiA4NH1dXG4gKiAgICAgIC8vICAgLy8gLi4uLFxuICogICAgICAvLyAgICdGJzogW3tuYW1lOiAnRWRkeScsIHNjb3JlOiA1OH1dXG4gKiAgICAgIC8vIH1cbiAqL1xudmFyIGdyb3VwQnkgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19jaGVja0Zvck1ldGhvZCgnZ3JvdXBCeScsIC8qI19fUFVSRV9fKi9yZWR1Y2VCeShmdW5jdGlvbiAoYWNjLCBpdGVtKSB7XG4gIGlmIChhY2MgPT0gbnVsbCkge1xuICAgIGFjYyA9IFtdO1xuICB9XG4gIGFjYy5wdXNoKGl0ZW0pO1xuICByZXR1cm4gYWNjO1xufSwgbnVsbCkpKTtcbmV4cG9ydCBkZWZhdWx0IGdyb3VwQnk7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBUYWtlcyBhIGxpc3QgYW5kIHJldHVybnMgYSBsaXN0IG9mIGxpc3RzIHdoZXJlIGVhY2ggc3VibGlzdCdzIGVsZW1lbnRzIGFyZVxuICogYWxsIHNhdGlzZmllZCBwYWlyd2lzZSBjb21wYXJpc29uIGFjY29yZGluZyB0byB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBPbmx5IGFkamFjZW50IGVsZW1lbnRzIGFyZSBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhLCBhKSDihpIgQm9vbGVhbikg4oaSIFthXSDihpIgW1thXV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHR3byBnaXZlbiAoYWRqYWNlbnQpXG4gKiAgICAgICAgZWxlbWVudHMgc2hvdWxkIGJlIGluIHRoZSBzYW1lIGdyb3VwXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBncm91cC4gQWxzbyBhY2NlcHRzIGEgc3RyaW5nLCB3aGljaCB3aWxsIGJlXG4gKiAgICAgICAgdHJlYXRlZCBhcyBhIGxpc3Qgb2YgY2hhcmFjdGVycy5cbiAqIEByZXR1cm4ge0xpc3R9IEEgbGlzdCB0aGF0IGNvbnRhaW5zIHN1Ymxpc3RzIG9mIGVsZW1lbnRzLFxuICogICAgICAgICB3aG9zZSBjb25jYXRlbmF0aW9ucyBhcmUgZXF1YWwgdG8gdGhlIG9yaWdpbmFsIGxpc3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIFIuZ3JvdXBXaXRoKFIuZXF1YWxzLCBbMCwgMSwgMSwgMiwgMywgNSwgOCwgMTMsIDIxXSlcbiAqIC8vPT4gW1swXSwgWzEsIDFdLCBbMl0sIFszXSwgWzVdLCBbOF0sIFsxM10sIFsyMV1dXG4gKlxuICogUi5ncm91cFdpdGgoKGEsIGIpID0+IGEgKyAxID09PSBiLCBbMCwgMSwgMSwgMiwgMywgNSwgOCwgMTMsIDIxXSlcbiAqIC8vPT4gW1swLCAxXSwgWzEsIDIsIDNdLCBbNV0sIFs4XSwgWzEzXSwgWzIxXV1cbiAqXG4gKiBSLmdyb3VwV2l0aCgoYSwgYikgPT4gYSAlIDIgPT09IGIgJSAyLCBbMCwgMSwgMSwgMiwgMywgNSwgOCwgMTMsIDIxXSlcbiAqIC8vPT4gW1swXSwgWzEsIDFdLCBbMl0sIFszLCA1XSwgWzhdLCBbMTMsIDIxXV1cbiAqXG4gKiBSLmdyb3VwV2l0aChSLmVxQnkoaXNWb3dlbCksICdhZXN0aW91JylcbiAqIC8vPT4gWydhZScsICdzdCcsICdpb3UnXVxuICovXG52YXIgZ3JvdXBXaXRoID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gKGZuLCBsaXN0KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHZhciBuZXh0aWR4ID0gaWR4ICsgMTtcbiAgICB3aGlsZSAobmV4dGlkeCA8IGxlbiAmJiBmbihsaXN0W25leHRpZHggLSAxXSwgbGlzdFtuZXh0aWR4XSkpIHtcbiAgICAgIG5leHRpZHggKz0gMTtcbiAgICB9XG4gICAgcmVzLnB1c2gobGlzdC5zbGljZShpZHgsIG5leHRpZHgpKTtcbiAgICBpZHggPSBuZXh0aWR4O1xuICB9XG4gIHJldHVybiByZXM7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGdyb3VwV2l0aDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBncmVhdGVyIHRoYW4gdGhlIHNlY29uZDsgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5sdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZ3QoMiwgMSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmd0KDIsIDIpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuZ3QoMiwgMyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5ndCgnYScsICd6Jyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5ndCgneicsICdhJyk7IC8vPT4gdHJ1ZVxuICovXG52YXIgZ3QgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBndChhLCBiKSB7XG4gIHJldHVybiBhID4gYjtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgZ3Q7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQ7XG4gKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmx0ZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZ3RlKDIsIDEpOyAvLz0+IHRydWVcbiAqICAgICAgUi5ndGUoMiwgMik7IC8vPT4gdHJ1ZVxuICogICAgICBSLmd0ZSgyLCAzKTsgLy89PiBmYWxzZVxuICogICAgICBSLmd0ZSgnYScsICd6Jyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5ndGUoJ3onLCAnYScpOyAvLz0+IHRydWVcbiAqL1xudmFyIGd0ZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGd0ZShhLCBiKSB7XG4gIHJldHVybiBhID49IGI7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGd0ZTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9oYXMgZnJvbSAnLi9pbnRlcm5hbC9faGFzJztcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHMgLT4ge3M6IHh9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVjayBmb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBleGlzdHMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGhhc05hbWUgPSBSLmhhcygnbmFtZScpO1xuICogICAgICBoYXNOYW1lKHtuYW1lOiAnYWxpY2UnfSk7ICAgLy89PiB0cnVlXG4gKiAgICAgIGhhc05hbWUoe25hbWU6ICdib2InfSk7ICAgICAvLz0+IHRydWVcbiAqICAgICAgaGFzTmFtZSh7fSk7ICAgICAgICAgICAgICAgIC8vPT4gZmFsc2VcbiAqXG4gKiAgICAgIHZhciBwb2ludCA9IHt4OiAwLCB5OiAwfTtcbiAqICAgICAgdmFyIHBvaW50SGFzID0gUi5oYXMoUi5fXywgcG9pbnQpO1xuICogICAgICBwb2ludEhhcygneCcpOyAgLy89PiB0cnVlXG4gKiAgICAgIHBvaW50SGFzKCd5Jyk7ICAvLz0+IHRydWVcbiAqICAgICAgcG9pbnRIYXMoJ3onKTsgIC8vPT4gZmFsc2VcbiAqL1xudmFyIGhhcyA9IC8qI19fUFVSRV9fKi9fY3VycnkyKF9oYXMpO1xuZXhwb3J0IGRlZmF1bHQgaGFzOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbiBoYXMgYSBwcm9wZXJ0eSB3aXRoXG4gKiB0aGUgc3BlY2lmaWVkIG5hbWVcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgcyAtPiB7czogeH0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNoZWNrIGZvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IGV4aXN0cy5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBmdW5jdGlvbiBSZWN0YW5nbGUod2lkdGgsIGhlaWdodCkge1xuICogICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAqICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAqICAgICAgfVxuICogICAgICBSZWN0YW5nbGUucHJvdG90eXBlLmFyZWEgPSBmdW5jdGlvbigpIHtcbiAqICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuICogICAgICB9O1xuICpcbiAqICAgICAgdmFyIHNxdWFyZSA9IG5ldyBSZWN0YW5nbGUoMiwgMik7XG4gKiAgICAgIFIuaGFzSW4oJ3dpZHRoJywgc3F1YXJlKTsgIC8vPT4gdHJ1ZVxuICogICAgICBSLmhhc0luKCdhcmVhJywgc3F1YXJlKTsgIC8vPT4gdHJ1ZVxuICovXG52YXIgaGFzSW4gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBoYXNJbihwcm9wLCBvYmopIHtcbiAgcmV0dXJuIHByb3AgaW4gb2JqO1xufSk7XG5leHBvcnQgZGVmYXVsdCBoYXNJbjsiLCJpbXBvcnQgbnRoIGZyb20gJy4vbnRoJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZy4gSW4gc29tZSBsaWJyYXJpZXNcbiAqIHRoaXMgZnVuY3Rpb24gaXMgbmFtZWQgYGZpcnN0YC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBhIHwgVW5kZWZpbmVkXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLnRhaWwsIFIuaW5pdCwgUi5sYXN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5oZWFkKFsnZmknLCAnZm8nLCAnZnVtJ10pOyAvLz0+ICdmaSdcbiAqICAgICAgUi5oZWFkKFtdKTsgLy89PiB1bmRlZmluZWRcbiAqXG4gKiAgICAgIFIuaGVhZCgnYWJjJyk7IC8vPT4gJ2EnXG4gKiAgICAgIFIuaGVhZCgnJyk7IC8vPT4gJydcbiAqL1xudmFyIGhlYWQgPSAvKiNfX1BVUkVfXyovbnRoKDApO1xuZXhwb3J0IGRlZmF1bHQgaGVhZDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBpdHMgYXJndW1lbnRzIGFyZSBpZGVudGljYWwsIGZhbHNlIG90aGVyd2lzZS4gVmFsdWVzIGFyZVxuICogaWRlbnRpY2FsIGlmIHRoZXkgcmVmZXJlbmNlIHRoZSBzYW1lIG1lbW9yeS4gYE5hTmAgaXMgaWRlbnRpY2FsIHRvIGBOYU5gO1xuICogYDBgIGFuZCBgLTBgIGFyZSBub3QgaWRlbnRpY2FsLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE1LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBhIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG8gPSB7fTtcbiAqICAgICAgUi5pZGVudGljYWwobywgbyk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlkZW50aWNhbCgxLCAxKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaWRlbnRpY2FsKDEsICcxJyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5pZGVudGljYWwoW10sIFtdKTsgLy89PiBmYWxzZVxuICogICAgICBSLmlkZW50aWNhbCgwLCAtMCk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5pZGVudGljYWwoTmFOLCBOYU4pOyAvLz0+IHRydWVcbiAqL1xudmFyIGlkZW50aWNhbCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGlkZW50aWNhbChhLCBiKSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKGEgPT09IGIpIHtcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG4gIH1cbn0pO1xuZXhwb3J0IGRlZmF1bHQgaWRlbnRpY2FsOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgX2lkZW50aXR5IGZyb20gJy4vaW50ZXJuYWwvX2lkZW50aXR5JztcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgZG9lcyBub3RoaW5nIGJ1dCByZXR1cm4gdGhlIHBhcmFtZXRlciBzdXBwbGllZCB0byBpdC4gR29vZFxuICogYXMgYSBkZWZhdWx0IG9yIHBsYWNlaG9sZGVyIGZ1bmN0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIGEgLT4gYVxuICogQHBhcmFtIHsqfSB4IFRoZSB2YWx1ZSB0byByZXR1cm4uXG4gKiBAcmV0dXJuIHsqfSBUaGUgaW5wdXQgdmFsdWUsIGB4YC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmlkZW50aXR5KDEpOyAvLz0+IDFcbiAqXG4gKiAgICAgIHZhciBvYmogPSB7fTtcbiAqICAgICAgUi5pZGVudGl0eShvYmopID09PSBvYmo7IC8vPT4gdHJ1ZVxuICogQHN5bWIgUi5pZGVudGl0eShhKSA9IGFcbiAqL1xudmFyIGlkZW50aXR5ID0gLyojX19QVVJFX18qL19jdXJyeTEoX2lkZW50aXR5KTtcbmV4cG9ydCBkZWZhdWx0IGlkZW50aXR5OyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgY3VycnlOIGZyb20gJy4vY3VycnlOJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHByb2Nlc3MgZWl0aGVyIHRoZSBgb25UcnVlYCBvciB0aGUgYG9uRmFsc2VgXG4gKiBmdW5jdGlvbiBkZXBlbmRpbmcgdXBvbiB0aGUgcmVzdWx0IG9mIHRoZSBgY29uZGl0aW9uYCBwcmVkaWNhdGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKCouLi4gLT4gQm9vbGVhbikgLT4gKCouLi4gLT4gKikgLT4gKCouLi4gLT4gKikgLT4gKCouLi4gLT4gKilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvbiBBIHByZWRpY2F0ZSBmdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gb25UcnVlIEEgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIGBjb25kaXRpb25gIGV2YWx1YXRlcyB0byBhIHRydXRoeSB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRmFsc2UgQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYGNvbmRpdGlvbmAgZXZhbHVhdGVzIHRvIGEgZmFsc3kgdmFsdWUuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgdW5hcnkgZnVuY3Rpb24gdGhhdCB3aWxsIHByb2Nlc3MgZWl0aGVyIHRoZSBgb25UcnVlYCBvciB0aGUgYG9uRmFsc2VgXG4gKiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVwZW5kaW5nIHVwb24gdGhlIHJlc3VsdCBvZiB0aGUgYGNvbmRpdGlvbmAgcHJlZGljYXRlLlxuICogQHNlZSBSLnVubGVzcywgUi53aGVuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGluY0NvdW50ID0gUi5pZkVsc2UoXG4gKiAgICAgICAgUi5oYXMoJ2NvdW50JyksXG4gKiAgICAgICAgUi5vdmVyKFIubGVuc1Byb3AoJ2NvdW50JyksIFIuaW5jKSxcbiAqICAgICAgICBSLmFzc29jKCdjb3VudCcsIDEpXG4gKiAgICAgICk7XG4gKiAgICAgIGluY0NvdW50KHt9KTsgICAgICAgICAgIC8vPT4geyBjb3VudDogMSB9XG4gKiAgICAgIGluY0NvdW50KHsgY291bnQ6IDEgfSk7IC8vPT4geyBjb3VudDogMiB9XG4gKi9cbnZhciBpZkVsc2UgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBpZkVsc2UoY29uZGl0aW9uLCBvblRydWUsIG9uRmFsc2UpIHtcbiAgcmV0dXJuIGN1cnJ5TihNYXRoLm1heChjb25kaXRpb24ubGVuZ3RoLCBvblRydWUubGVuZ3RoLCBvbkZhbHNlLmxlbmd0aCksIGZ1bmN0aW9uIF9pZkVsc2UoKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gb25UcnVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBvbkZhbHNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBpZkVsc2U7IiwiaW1wb3J0IGFkZCBmcm9tICcuL2FkZCc7XG5cbi8qKlxuICogSW5jcmVtZW50cyBpdHMgYXJndW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TnVtYmVyfSBuICsgMVxuICogQHNlZSBSLmRlY1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaW5jKDQyKTsgLy89PiA0M1xuICovXG52YXIgaW5jID0gLyojX19QVVJFX18qL2FkZCgxKTtcbmV4cG9ydCBkZWZhdWx0IGluYzsiLCJleHBvcnQgeyBkZWZhdWx0IGFzIEYgfSBmcm9tICcuL0YnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUIH0gZnJvbSAnLi9UJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgX18gfSBmcm9tICcuL19fJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYWRkIH0gZnJvbSAnLi9hZGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhZGRJbmRleCB9IGZyb20gJy4vYWRkSW5kZXgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhZGp1c3QgfSBmcm9tICcuL2FkanVzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFsbCB9IGZyb20gJy4vYWxsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYWxsUGFzcyB9IGZyb20gJy4vYWxsUGFzcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFsd2F5cyB9IGZyb20gJy4vYWx3YXlzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYW5kIH0gZnJvbSAnLi9hbmQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhbnkgfSBmcm9tICcuL2FueSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFueVBhc3MgfSBmcm9tICcuL2FueVBhc3MnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhcCB9IGZyb20gJy4vYXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhcGVydHVyZSB9IGZyb20gJy4vYXBlcnR1cmUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhcHBlbmQgfSBmcm9tICcuL2FwcGVuZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFwcGx5IH0gZnJvbSAnLi9hcHBseSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFwcGx5U3BlYyB9IGZyb20gJy4vYXBwbHlTcGVjJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXBwbHlUbyB9IGZyb20gJy4vYXBwbHlUbyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFzY2VuZCB9IGZyb20gJy4vYXNjZW5kJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXNzb2MgfSBmcm9tICcuL2Fzc29jJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXNzb2NQYXRoIH0gZnJvbSAnLi9hc3NvY1BhdGgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBiaW5hcnkgfSBmcm9tICcuL2JpbmFyeSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGJpbmQgfSBmcm9tICcuL2JpbmQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBib3RoIH0gZnJvbSAnLi9ib3RoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY2FsbCB9IGZyb20gJy4vY2FsbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNoYWluIH0gZnJvbSAnLi9jaGFpbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNsYW1wIH0gZnJvbSAnLi9jbGFtcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNsb25lIH0gZnJvbSAnLi9jbG9uZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbXBhcmF0b3IgfSBmcm9tICcuL2NvbXBhcmF0b3InO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb21wbGVtZW50IH0gZnJvbSAnLi9jb21wbGVtZW50JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29tcG9zZSB9IGZyb20gJy4vY29tcG9zZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbXBvc2VLIH0gZnJvbSAnLi9jb21wb3NlSyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbXBvc2VQIH0gZnJvbSAnLi9jb21wb3NlUCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbmNhdCB9IGZyb20gJy4vY29uY2F0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29uZCB9IGZyb20gJy4vY29uZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbnN0cnVjdCB9IGZyb20gJy4vY29uc3RydWN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29uc3RydWN0TiB9IGZyb20gJy4vY29uc3RydWN0Tic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbnRhaW5zIH0gZnJvbSAnLi9jb250YWlucyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbnZlcmdlIH0gZnJvbSAnLi9jb252ZXJnZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvdW50QnkgfSBmcm9tICcuL2NvdW50QnknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjdXJyeSB9IGZyb20gJy4vY3VycnknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjdXJyeU4gfSBmcm9tICcuL2N1cnJ5Tic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRlYyB9IGZyb20gJy4vZGVjJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZGVmYXVsdFRvIH0gZnJvbSAnLi9kZWZhdWx0VG8nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBkZXNjZW5kIH0gZnJvbSAnLi9kZXNjZW5kJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZGlmZmVyZW5jZSB9IGZyb20gJy4vZGlmZmVyZW5jZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRpZmZlcmVuY2VXaXRoIH0gZnJvbSAnLi9kaWZmZXJlbmNlV2l0aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRpc3NvYyB9IGZyb20gJy4vZGlzc29jJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZGlzc29jUGF0aCB9IGZyb20gJy4vZGlzc29jUGF0aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRpdmlkZSB9IGZyb20gJy4vZGl2aWRlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZHJvcCB9IGZyb20gJy4vZHJvcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRyb3BMYXN0IH0gZnJvbSAnLi9kcm9wTGFzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRyb3BMYXN0V2hpbGUgfSBmcm9tICcuL2Ryb3BMYXN0V2hpbGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBkcm9wUmVwZWF0cyB9IGZyb20gJy4vZHJvcFJlcGVhdHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBkcm9wUmVwZWF0c1dpdGggfSBmcm9tICcuL2Ryb3BSZXBlYXRzV2l0aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRyb3BXaGlsZSB9IGZyb20gJy4vZHJvcFdoaWxlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZWl0aGVyIH0gZnJvbSAnLi9laXRoZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBlbXB0eSB9IGZyb20gJy4vZW1wdHknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBlbmRzV2l0aCB9IGZyb20gJy4vZW5kc1dpdGgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBlcUJ5IH0gZnJvbSAnLi9lcUJ5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZXFQcm9wcyB9IGZyb20gJy4vZXFQcm9wcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGVxdWFscyB9IGZyb20gJy4vZXF1YWxzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZXZvbHZlIH0gZnJvbSAnLi9ldm9sdmUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmaWx0ZXIgfSBmcm9tICcuL2ZpbHRlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpbmQgfSBmcm9tICcuL2ZpbmQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmaW5kSW5kZXggfSBmcm9tICcuL2ZpbmRJbmRleCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpbmRMYXN0IH0gZnJvbSAnLi9maW5kTGFzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpbmRMYXN0SW5kZXggfSBmcm9tICcuL2ZpbmRMYXN0SW5kZXgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmbGF0dGVuIH0gZnJvbSAnLi9mbGF0dGVuJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZmxpcCB9IGZyb20gJy4vZmxpcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZvckVhY2ggfSBmcm9tICcuL2ZvckVhY2gnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmb3JFYWNoT2JqSW5kZXhlZCB9IGZyb20gJy4vZm9yRWFjaE9iakluZGV4ZWQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmcm9tUGFpcnMgfSBmcm9tICcuL2Zyb21QYWlycyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGdyb3VwQnkgfSBmcm9tICcuL2dyb3VwQnknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBncm91cFdpdGggfSBmcm9tICcuL2dyb3VwV2l0aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGd0IH0gZnJvbSAnLi9ndCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGd0ZSB9IGZyb20gJy4vZ3RlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaGFzIH0gZnJvbSAnLi9oYXMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBoYXNJbiB9IGZyb20gJy4vaGFzSW4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBoZWFkIH0gZnJvbSAnLi9oZWFkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaWRlbnRpY2FsIH0gZnJvbSAnLi9pZGVudGljYWwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpZGVudGl0eSB9IGZyb20gJy4vaWRlbnRpdHknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpZkVsc2UgfSBmcm9tICcuL2lmRWxzZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGluYyB9IGZyb20gJy4vaW5jJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaW5kZXhCeSB9IGZyb20gJy4vaW5kZXhCeSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGluZGV4T2YgfSBmcm9tICcuL2luZGV4T2YnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpbml0IH0gZnJvbSAnLi9pbml0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaW5uZXJKb2luIH0gZnJvbSAnLi9pbm5lckpvaW4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpbnNlcnQgfSBmcm9tICcuL2luc2VydCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGluc2VydEFsbCB9IGZyb20gJy4vaW5zZXJ0QWxsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaW50ZXJzZWN0aW9uIH0gZnJvbSAnLi9pbnRlcnNlY3Rpb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpbnRlcnNwZXJzZSB9IGZyb20gJy4vaW50ZXJzcGVyc2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpbnRvIH0gZnJvbSAnLi9pbnRvJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaW52ZXJ0IH0gZnJvbSAnLi9pbnZlcnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpbnZlcnRPYmogfSBmcm9tICcuL2ludmVydE9iaic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGludm9rZXIgfSBmcm9tICcuL2ludm9rZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpcyB9IGZyb20gJy4vaXMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpc0VtcHR5IH0gZnJvbSAnLi9pc0VtcHR5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaXNOaWwgfSBmcm9tICcuL2lzTmlsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgam9pbiB9IGZyb20gJy4vam9pbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGp1eHQgfSBmcm9tICcuL2p1eHQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBrZXlzIH0gZnJvbSAnLi9rZXlzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMga2V5c0luIH0gZnJvbSAnLi9rZXlzSW4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsYXN0IH0gZnJvbSAnLi9sYXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbGFzdEluZGV4T2YgfSBmcm9tICcuL2xhc3RJbmRleE9mJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbGVuZ3RoIH0gZnJvbSAnLi9sZW5ndGgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsZW5zIH0gZnJvbSAnLi9sZW5zJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbGVuc0luZGV4IH0gZnJvbSAnLi9sZW5zSW5kZXgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsZW5zUGF0aCB9IGZyb20gJy4vbGVuc1BhdGgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsZW5zUHJvcCB9IGZyb20gJy4vbGVuc1Byb3AnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsaWZ0IH0gZnJvbSAnLi9saWZ0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbGlmdE4gfSBmcm9tICcuL2xpZnROJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbHQgfSBmcm9tICcuL2x0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbHRlIH0gZnJvbSAnLi9sdGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtYXAgfSBmcm9tICcuL21hcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1hcEFjY3VtIH0gZnJvbSAnLi9tYXBBY2N1bSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1hcEFjY3VtUmlnaHQgfSBmcm9tICcuL21hcEFjY3VtUmlnaHQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtYXBPYmpJbmRleGVkIH0gZnJvbSAnLi9tYXBPYmpJbmRleGVkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWF0Y2ggfSBmcm9tICcuL21hdGNoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWF0aE1vZCB9IGZyb20gJy4vbWF0aE1vZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1heCB9IGZyb20gJy4vbWF4JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWF4QnkgfSBmcm9tICcuL21heEJ5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWVhbiB9IGZyb20gJy4vbWVhbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1lZGlhbiB9IGZyb20gJy4vbWVkaWFuJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWVtb2l6ZSB9IGZyb20gJy4vbWVtb2l6ZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1lbW9pemVXaXRoIH0gZnJvbSAnLi9tZW1vaXplV2l0aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1lcmdlIH0gZnJvbSAnLi9tZXJnZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1lcmdlQWxsIH0gZnJvbSAnLi9tZXJnZUFsbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1lcmdlRGVlcExlZnQgfSBmcm9tICcuL21lcmdlRGVlcExlZnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtZXJnZURlZXBSaWdodCB9IGZyb20gJy4vbWVyZ2VEZWVwUmlnaHQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtZXJnZURlZXBXaXRoIH0gZnJvbSAnLi9tZXJnZURlZXBXaXRoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWVyZ2VEZWVwV2l0aEtleSB9IGZyb20gJy4vbWVyZ2VEZWVwV2l0aEtleSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1lcmdlV2l0aCB9IGZyb20gJy4vbWVyZ2VXaXRoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWVyZ2VXaXRoS2V5IH0gZnJvbSAnLi9tZXJnZVdpdGhLZXknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtaW4gfSBmcm9tICcuL21pbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1pbkJ5IH0gZnJvbSAnLi9taW5CeSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1vZHVsbyB9IGZyb20gJy4vbW9kdWxvJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbXVsdGlwbHkgfSBmcm9tICcuL211bHRpcGx5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbkFyeSB9IGZyb20gJy4vbkFyeSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG5lZ2F0ZSB9IGZyb20gJy4vbmVnYXRlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbm9uZSB9IGZyb20gJy4vbm9uZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG5vdCB9IGZyb20gJy4vbm90JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbnRoIH0gZnJvbSAnLi9udGgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBudGhBcmcgfSBmcm9tICcuL250aEFyZyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG8gfSBmcm9tICcuL28nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBvYmpPZiB9IGZyb20gJy4vb2JqT2YnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBvZiB9IGZyb20gJy4vb2YnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBvbWl0IH0gZnJvbSAnLi9vbWl0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgb25jZSB9IGZyb20gJy4vb25jZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG9yIH0gZnJvbSAnLi9vcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG92ZXIgfSBmcm9tICcuL292ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYWlyIH0gZnJvbSAnLi9wYWlyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFydGlhbCB9IGZyb20gJy4vcGFydGlhbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhcnRpYWxSaWdodCB9IGZyb20gJy4vcGFydGlhbFJpZ2h0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFydGl0aW9uIH0gZnJvbSAnLi9wYXJ0aXRpb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXRoIH0gZnJvbSAnLi9wYXRoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGF0aEVxIH0gZnJvbSAnLi9wYXRoRXEnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXRoT3IgfSBmcm9tICcuL3BhdGhPcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhdGhTYXRpc2ZpZXMgfSBmcm9tICcuL3BhdGhTYXRpc2ZpZXMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwaWNrIH0gZnJvbSAnLi9waWNrJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGlja0FsbCB9IGZyb20gJy4vcGlja0FsbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBpY2tCeSB9IGZyb20gJy4vcGlja0J5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGlwZSB9IGZyb20gJy4vcGlwZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBpcGVLIH0gZnJvbSAnLi9waXBlSyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBpcGVQIH0gZnJvbSAnLi9waXBlUCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBsdWNrIH0gZnJvbSAnLi9wbHVjayc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHByZXBlbmQgfSBmcm9tICcuL3ByZXBlbmQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwcm9kdWN0IH0gZnJvbSAnLi9wcm9kdWN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcHJvamVjdCB9IGZyb20gJy4vcHJvamVjdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHByb3AgfSBmcm9tICcuL3Byb3AnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwcm9wRXEgfSBmcm9tICcuL3Byb3BFcSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHByb3BJcyB9IGZyb20gJy4vcHJvcElzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcHJvcE9yIH0gZnJvbSAnLi9wcm9wT3InO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwcm9wU2F0aXNmaWVzIH0gZnJvbSAnLi9wcm9wU2F0aXNmaWVzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcHJvcHMgfSBmcm9tICcuL3Byb3BzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcmFuZ2UgfSBmcm9tICcuL3JhbmdlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcmVkdWNlIH0gZnJvbSAnLi9yZWR1Y2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByZWR1Y2VCeSB9IGZyb20gJy4vcmVkdWNlQnknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByZWR1Y2VSaWdodCB9IGZyb20gJy4vcmVkdWNlUmlnaHQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByZWR1Y2VXaGlsZSB9IGZyb20gJy4vcmVkdWNlV2hpbGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByZWR1Y2VkIH0gZnJvbSAnLi9yZWR1Y2VkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcmVqZWN0IH0gZnJvbSAnLi9yZWplY3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByZW1vdmUgfSBmcm9tICcuL3JlbW92ZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHJlcGVhdCB9IGZyb20gJy4vcmVwZWF0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcmVwbGFjZSB9IGZyb20gJy4vcmVwbGFjZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHJldmVyc2UgfSBmcm9tICcuL3JldmVyc2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzY2FuIH0gZnJvbSAnLi9zY2FuJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc2VxdWVuY2UgfSBmcm9tICcuL3NlcXVlbmNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc2V0IH0gZnJvbSAnLi9zZXQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzbGljZSB9IGZyb20gJy4vc2xpY2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzb3J0IH0gZnJvbSAnLi9zb3J0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc29ydEJ5IH0gZnJvbSAnLi9zb3J0QnknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzb3J0V2l0aCB9IGZyb20gJy4vc29ydFdpdGgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzcGxpdCB9IGZyb20gJy4vc3BsaXQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzcGxpdEF0IH0gZnJvbSAnLi9zcGxpdEF0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3BsaXRFdmVyeSB9IGZyb20gJy4vc3BsaXRFdmVyeSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNwbGl0V2hlbiB9IGZyb20gJy4vc3BsaXRXaGVuJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RhcnRzV2l0aCB9IGZyb20gJy4vc3RhcnRzV2l0aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHN1YnRyYWN0IH0gZnJvbSAnLi9zdWJ0cmFjdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHN1bSB9IGZyb20gJy4vc3VtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3ltbWV0cmljRGlmZmVyZW5jZSB9IGZyb20gJy4vc3ltbWV0cmljRGlmZmVyZW5jZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoIH0gZnJvbSAnLi9zeW1tZXRyaWNEaWZmZXJlbmNlV2l0aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRhaWwgfSBmcm9tICcuL3RhaWwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0YWtlIH0gZnJvbSAnLi90YWtlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdGFrZUxhc3QgfSBmcm9tICcuL3Rha2VMYXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdGFrZUxhc3RXaGlsZSB9IGZyb20gJy4vdGFrZUxhc3RXaGlsZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRha2VXaGlsZSB9IGZyb20gJy4vdGFrZVdoaWxlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdGFwIH0gZnJvbSAnLi90YXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0ZXN0IH0gZnJvbSAnLi90ZXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdGltZXMgfSBmcm9tICcuL3RpbWVzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdG9Mb3dlciB9IGZyb20gJy4vdG9Mb3dlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRvUGFpcnMgfSBmcm9tICcuL3RvUGFpcnMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0b1BhaXJzSW4gfSBmcm9tICcuL3RvUGFpcnNJbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRvU3RyaW5nIH0gZnJvbSAnLi90b1N0cmluZyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRvVXBwZXIgfSBmcm9tICcuL3RvVXBwZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0cmFuc2R1Y2UgfSBmcm9tICcuL3RyYW5zZHVjZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRyYW5zcG9zZSB9IGZyb20gJy4vdHJhbnNwb3NlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdHJhdmVyc2UgfSBmcm9tICcuL3RyYXZlcnNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdHJpbSB9IGZyb20gJy4vdHJpbSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRyeUNhdGNoIH0gZnJvbSAnLi90cnlDYXRjaCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHR5cGUgfSBmcm9tICcuL3R5cGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bmFwcGx5IH0gZnJvbSAnLi91bmFwcGx5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdW5hcnkgfSBmcm9tICcuL3VuYXJ5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdW5jdXJyeU4gfSBmcm9tICcuL3VuY3VycnlOJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdW5mb2xkIH0gZnJvbSAnLi91bmZvbGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bmlvbiB9IGZyb20gJy4vdW5pb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bmlvbldpdGggfSBmcm9tICcuL3VuaW9uV2l0aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuaXEgfSBmcm9tICcuL3VuaXEnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bmlxQnkgfSBmcm9tICcuL3VuaXFCeSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuaXFXaXRoIH0gZnJvbSAnLi91bmlxV2l0aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVubGVzcyB9IGZyb20gJy4vdW5sZXNzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdW5uZXN0IH0gZnJvbSAnLi91bm5lc3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bnRpbCB9IGZyb20gJy4vdW50aWwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1cGRhdGUgfSBmcm9tICcuL3VwZGF0ZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZVdpdGggfSBmcm9tICcuL3VzZVdpdGgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2YWx1ZXMgfSBmcm9tICcuL3ZhbHVlcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZhbHVlc0luIH0gZnJvbSAnLi92YWx1ZXNJbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZpZXcgfSBmcm9tICcuL3ZpZXcnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB3aGVuIH0gZnJvbSAnLi93aGVuJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgd2hlcmUgfSBmcm9tICcuL3doZXJlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgd2hlcmVFcSB9IGZyb20gJy4vd2hlcmVFcSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHdpdGhvdXQgfSBmcm9tICcuL3dpdGhvdXQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB4cHJvZCB9IGZyb20gJy4veHByb2QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB6aXAgfSBmcm9tICcuL3ppcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHppcE9iaiB9IGZyb20gJy4vemlwT2JqJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgemlwV2l0aCB9IGZyb20gJy4vemlwV2l0aCc7IiwiaW1wb3J0IHJlZHVjZUJ5IGZyb20gJy4vcmVkdWNlQnknO1xuXG4vKipcbiAqIEdpdmVuIGEgZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgYSBrZXksIHR1cm5zIGEgbGlzdCBvZiBvYmplY3RzIGludG8gYW5cbiAqIG9iamVjdCBpbmRleGluZyB0aGUgb2JqZWN0cyBieSB0aGUgZ2l2ZW4ga2V5LiBOb3RlIHRoYXQgaWYgbXVsdGlwbGVcbiAqIG9iamVjdHMgZ2VuZXJhdGUgdGhlIHNhbWUgdmFsdWUgZm9yIHRoZSBpbmRleGluZyBrZXkgb25seSB0aGUgbGFzdCB2YWx1ZVxuICogd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgZ2VuZXJhdGVkIG9iamVjdC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gU3RyaW5nKSAtPiBbe2s6IHZ9XSAtPiB7azoge2s6IHZ9fVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gOjogYSAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBvYmplY3RzIHRvIGluZGV4XG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBpbmRleGluZyBlYWNoIGFycmF5IGVsZW1lbnQgYnkgdGhlIGdpdmVuIHByb3BlcnR5LlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBsaXN0ID0gW3tpZDogJ3h5eicsIHRpdGxlOiAnQSd9LCB7aWQ6ICdhYmMnLCB0aXRsZTogJ0InfV07XG4gKiAgICAgIFIuaW5kZXhCeShSLnByb3AoJ2lkJyksIGxpc3QpO1xuICogICAgICAvLz0+IHthYmM6IHtpZDogJ2FiYycsIHRpdGxlOiAnQid9LCB4eXo6IHtpZDogJ3h5eicsIHRpdGxlOiAnQSd9fVxuICovXG52YXIgaW5kZXhCeSA9IC8qI19fUFVSRV9fKi9yZWR1Y2VCeShmdW5jdGlvbiAoYWNjLCBlbGVtKSB7XG4gIHJldHVybiBlbGVtO1xufSwgbnVsbCk7XG5leHBvcnQgZGVmYXVsdCBpbmRleEJ5OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2luZGV4T2YgZnJvbSAnLi9pbnRlcm5hbC9faW5kZXhPZic7XG5pbXBvcnQgX2lzQXJyYXkgZnJvbSAnLi9pbnRlcm5hbC9faXNBcnJheSc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSwgb3IgLTFcbiAqIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuIFtgUi5lcXVhbHNgXSgjZXF1YWxzKSBpcyB1c2VkIHRvXG4gKiBkZXRlcm1pbmUgZXF1YWxpdHkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IFthXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSBpdGVtIHRvIGZpbmQuXG4gKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgYXJyYXkgdG8gc2VhcmNoIGluLlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIHRhcmdldCwgb3IgLTEgaWYgdGhlIHRhcmdldCBpcyBub3QgZm91bmQuXG4gKiBAc2VlIFIubGFzdEluZGV4T2ZcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmluZGV4T2YoMywgWzEsMiwzLDRdKTsgLy89PiAyXG4gKiAgICAgIFIuaW5kZXhPZigxMCwgWzEsMiwzLDRdKTsgLy89PiAtMVxuICovXG52YXIgaW5kZXhPZiA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGluZGV4T2YodGFyZ2V0LCB4cykge1xuICByZXR1cm4gdHlwZW9mIHhzLmluZGV4T2YgPT09ICdmdW5jdGlvbicgJiYgIV9pc0FycmF5KHhzKSA/IHhzLmluZGV4T2YodGFyZ2V0KSA6IF9pbmRleE9mKHhzLCB0YXJnZXQsIDApO1xufSk7XG5leHBvcnQgZGVmYXVsdCBpbmRleE9mOyIsImltcG9ydCBzbGljZSBmcm9tICcuL3NsaWNlJztcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2FdXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7Kn0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5sYXN0LCBSLmhlYWQsIFIudGFpbFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaW5pdChbMSwgMiwgM10pOyAgLy89PiBbMSwgMl1cbiAqICAgICAgUi5pbml0KFsxLCAyXSk7ICAgICAvLz0+IFsxXVxuICogICAgICBSLmluaXQoWzFdKTsgICAgICAgIC8vPT4gW11cbiAqICAgICAgUi5pbml0KFtdKTsgICAgICAgICAvLz0+IFtdXG4gKlxuICogICAgICBSLmluaXQoJ2FiYycpOyAgLy89PiAnYWInXG4gKiAgICAgIFIuaW5pdCgnYWInKTsgICAvLz0+ICdhJ1xuICogICAgICBSLmluaXQoJ2EnKTsgICAgLy89PiAnJ1xuICogICAgICBSLmluaXQoJycpOyAgICAgLy89PiAnJ1xuICovXG52YXIgaW5pdCA9IC8qI19fUFVSRV9fKi9zbGljZSgwLCAtMSk7XG5leHBvcnQgZGVmYXVsdCBpbml0OyIsImltcG9ydCBfY29udGFpbnNXaXRoIGZyb20gJy4vaW50ZXJuYWwvX2NvbnRhaW5zV2l0aCc7XG5pbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuaW1wb3J0IF9maWx0ZXIgZnJvbSAnLi9pbnRlcm5hbC9fZmlsdGVyJztcblxuLyoqXG4gKiBUYWtlcyBhIHByZWRpY2F0ZSBgcHJlZGAsIGEgbGlzdCBgeHNgLCBhbmQgYSBsaXN0IGB5c2AsIGFuZCByZXR1cm5zIGEgbGlzdFxuICogYHhzJ2AgY29tcHJpc2luZyBlYWNoIG9mIHRoZSBlbGVtZW50cyBvZiBgeHNgIHdoaWNoIGlzIGVxdWFsIHRvIG9uZSBvciBtb3JlXG4gKiBlbGVtZW50cyBvZiBgeXNgIGFjY29yZGluZyB0byBgcHJlZGAuXG4gKlxuICogYHByZWRgIG11c3QgYmUgYSBiaW5hcnkgZnVuY3Rpb24gZXhwZWN0aW5nIGFuIGVsZW1lbnQgZnJvbSBlYWNoIGxpc3QuXG4gKlxuICogYHhzYCwgYHlzYCwgYW5kIGB4cydgIGFyZSB0cmVhdGVkIGFzIHNldHMsIHNlbWFudGljYWxseSwgc28gb3JkZXJpbmcgc2hvdWxkXG4gKiBub3QgYmUgc2lnbmlmaWNhbnQsIGJ1dCBzaW5jZSBgeHMnYCBpcyBvcmRlcmVkIHRoZSBpbXBsZW1lbnRhdGlvbiBndWFyYW50ZWVzXG4gKiB0aGF0IGl0cyB2YWx1ZXMgYXJlIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZXkgYXBwZWFyIGluIGB4c2AuIER1cGxpY2F0ZXMgYXJlXG4gKiBub3QgcmVtb3ZlZCwgc28gYHhzJ2AgbWF5IGNvbnRhaW4gZHVwbGljYXRlcyBpZiBgeHNgIGNvbnRhaW5zIGR1cGxpY2F0ZXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjQuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnICgoYSwgYikgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFtiXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRcbiAqIEBwYXJhbSB7QXJyYXl9IHhzXG4gKiBAcGFyYW0ge0FycmF5fSB5c1xuICogQHJldHVybiB7QXJyYXl9XG4gKiBAc2VlIFIuaW50ZXJzZWN0aW9uXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pbm5lckpvaW4oXG4gKiAgICAgICAgKHJlY29yZCwgaWQpID0+IHJlY29yZC5pZCA9PT0gaWQsXG4gKiAgICAgICAgW3tpZDogODI0LCBuYW1lOiAnUmljaGllIEZ1cmF5J30sXG4gKiAgICAgICAgIHtpZDogOTU2LCBuYW1lOiAnRGV3ZXkgTWFydGluJ30sXG4gKiAgICAgICAgIHtpZDogMzEzLCBuYW1lOiAnQnJ1Y2UgUGFsbWVyJ30sXG4gKiAgICAgICAgIHtpZDogNDU2LCBuYW1lOiAnU3RlcGhlbiBTdGlsbHMnfSxcbiAqICAgICAgICAge2lkOiAxNzcsIG5hbWU6ICdOZWlsIFlvdW5nJ31dLFxuICogICAgICAgIFsxNzcsIDQ1NiwgOTk5XVxuICogICAgICApO1xuICogICAgICAvLz0+IFt7aWQ6IDQ1NiwgbmFtZTogJ1N0ZXBoZW4gU3RpbGxzJ30sIHtpZDogMTc3LCBuYW1lOiAnTmVpbCBZb3VuZyd9XVxuICovXG52YXIgaW5uZXJKb2luID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gaW5uZXJKb2luKHByZWQsIHhzLCB5cykge1xuICByZXR1cm4gX2ZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBfY29udGFpbnNXaXRoKHByZWQsIHgsIHlzKTtcbiAgfSwgeHMpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBpbm5lckpvaW47IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLyoqXG4gKiBJbnNlcnRzIHRoZSBzdXBwbGllZCBlbGVtZW50IGludG8gdGhlIGxpc3QsIGF0IHRoZSBzcGVjaWZpZWQgYGluZGV4YC4gX05vdGUgdGhhdFxuXG4gKiB0aGlzIGlzIG5vdCBkZXN0cnVjdGl2ZV86IGl0IHJldHVybnMgYSBjb3B5IG9mIHRoZSBsaXN0IHdpdGggdGhlIGNoYW5nZXMuXG4gKiA8c21hbGw+Tm8gbGlzdHMgaGF2ZSBiZWVuIGhhcm1lZCBpbiB0aGUgYXBwbGljYXRpb24gb2YgdGhpcyBmdW5jdGlvbi48L3NtYWxsPlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuMlxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IGEgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7Kn0gZWx0IFRoZSBlbGVtZW50IHRvIGluc2VydCBpbnRvIHRoZSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpbnNlcnQgaW50b1xuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IEFycmF5IHdpdGggYGVsdGAgaW5zZXJ0ZWQgYXQgYGluZGV4YC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmluc2VydCgyLCAneCcsIFsxLDIsMyw0XSk7IC8vPT4gWzEsMiwneCcsMyw0XVxuICovXG52YXIgaW5zZXJ0ID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gaW5zZXJ0KGlkeCwgZWx0LCBsaXN0KSB7XG4gIGlkeCA9IGlkeCA8IGxpc3QubGVuZ3RoICYmIGlkeCA+PSAwID8gaWR4IDogbGlzdC5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCAwKTtcbiAgcmVzdWx0LnNwbGljZShpZHgsIDAsIGVsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGluc2VydDsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIEluc2VydHMgdGhlIHN1Yi1saXN0IGludG8gdGhlIGxpc3QsIGF0IHRoZSBzcGVjaWZpZWQgYGluZGV4YC4gX05vdGUgdGhhdCB0aGlzIGlzIG5vdFxuICogZGVzdHJ1Y3RpdmVfOiBpdCByZXR1cm5zIGEgY29weSBvZiB0aGUgbGlzdCB3aXRoIHRoZSBjaGFuZ2VzLlxuICogPHNtYWxsPk5vIGxpc3RzIGhhdmUgYmVlbiBoYXJtZWQgaW4gdGhlIGFwcGxpY2F0aW9uIG9mIHRoaXMgZnVuY3Rpb24uPC9zbWFsbD5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHN1Yi1saXN0XG4gKiBAcGFyYW0ge0FycmF5fSBlbHRzIFRoZSBzdWItbGlzdCB0byBpbnNlcnQgaW50byB0aGUgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaW5zZXJ0IHRoZSBzdWItbGlzdCBpbnRvXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgQXJyYXkgd2l0aCBgZWx0c2AgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgYGluZGV4YC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmluc2VydEFsbCgyLCBbJ3gnLCd5JywneiddLCBbMSwyLDMsNF0pOyAvLz0+IFsxLDIsJ3gnLCd5JywneicsMyw0XVxuICovXG52YXIgaW5zZXJ0QWxsID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gaW5zZXJ0QWxsKGlkeCwgZWx0cywgbGlzdCkge1xuICBpZHggPSBpZHggPCBsaXN0Lmxlbmd0aCAmJiBpZHggPj0gMCA/IGlkeCA6IGxpc3QubGVuZ3RoO1xuICByZXR1cm4gW10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIDAsIGlkeCksIGVsdHMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIGlkeCkpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBpbnNlcnRBbGw7IiwiaW1wb3J0IF9jb250YWlucyBmcm9tICcuL19jb250YWlucyc7XG5cbnZhciBfU2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gX1NldCgpIHtcbiAgICAvKiBnbG9iYWxzIFNldCAqL1xuICAgIHRoaXMuX25hdGl2ZVNldCA9IHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgPyBuZXcgU2V0KCkgOiBudWxsO1xuICAgIHRoaXMuX2l0ZW1zID0ge307XG4gIH1cblxuICAvLyB1bnRpbCB3ZSBmaWd1cmUgb3V0IHdoeSBqc2RvYyBjaG9rZXMgb24gdGhpc1xuICAvLyBAcGFyYW0gaXRlbSBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIFNldFxuICAvLyBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgaXRlbSBkaWQgbm90IGV4aXN0IHByaW9yLCBvdGhlcndpc2UgZmFsc2VcbiAgLy9cbiAgX1NldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gIWhhc09yQWRkKGl0ZW0sIHRydWUsIHRoaXMpO1xuICB9O1xuXG4gIC8vXG4gIC8vIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIGNoZWNrIGZvciBleGlzdGVuY2UgaW4gdGhlIFNldFxuICAvLyBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgaXRlbSBleGlzdHMgaW4gdGhlIFNldCwgb3RoZXJ3aXNlIGZhbHNlXG4gIC8vXG4gIF9TZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGhhc09yQWRkKGl0ZW0sIGZhbHNlLCB0aGlzKTtcbiAgfTtcblxuICAvL1xuICAvLyBDb21iaW5lcyB0aGUgbG9naWMgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gaXRlbSBpcyBhIG1lbWJlciBvZiB0aGUgc2V0IGFuZFxuICAvLyBmb3IgYWRkaW5nIGEgbmV3IGl0ZW0gdG8gdGhlIHNldC5cbiAgLy9cbiAgLy8gQHBhcmFtIGl0ZW0gICAgICAgVGhlIGl0ZW0gdG8gY2hlY2sgb3IgYWRkIHRvIHRoZSBTZXQgaW5zdGFuY2UuXG4gIC8vIEBwYXJhbSBzaG91bGRBZGQgIElmIHRydWUsIHRoZSBpdGVtIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNldCBpZiBpdCBkb2Vzbid0XG4gIC8vICAgICAgICAgICAgICAgICAgIGFscmVhZHkgZXhpc3QuXG4gIC8vIEBwYXJhbSBzZXQgICAgICAgIFRoZSBzZXQgaW5zdGFuY2UgdG8gY2hlY2sgb3IgYWRkIHRvLlxuICAvLyBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBpdGVtIGFscmVhZHkgZXhpc3RlZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAvL1xuICByZXR1cm4gX1NldDtcbn0oKTtcblxuZnVuY3Rpb24gaGFzT3JBZGQoaXRlbSwgc2hvdWxkQWRkLCBzZXQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgaXRlbTtcbiAgdmFyIHByZXZTaXplLCBuZXdTaXplO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAvLyBkaXN0aW5ndWlzaCBiZXR3ZWVuICswIGFuZCAtMFxuICAgICAgaWYgKGl0ZW0gPT09IDAgJiYgMSAvIGl0ZW0gPT09IC1JbmZpbml0eSkge1xuICAgICAgICBpZiAoc2V0Ll9pdGVtc1snLTAnXSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHNldC5faXRlbXNbJy0wJ10gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHRoZXNlIHR5cGVzIGNhbiBhbGwgdXRpbGlzZSB0aGUgbmF0aXZlIFNldFxuICAgICAgaWYgKHNldC5fbmF0aXZlU2V0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICBwcmV2U2l6ZSA9IHNldC5fbmF0aXZlU2V0LnNpemU7XG4gICAgICAgICAgc2V0Ll9uYXRpdmVTZXQuYWRkKGl0ZW0pO1xuICAgICAgICAgIG5ld1NpemUgPSBzZXQuX25hdGl2ZVNldC5zaXplO1xuICAgICAgICAgIHJldHVybiBuZXdTaXplID09PSBwcmV2U2l6ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2V0Ll9uYXRpdmVTZXQuaGFzKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoISh0eXBlIGluIHNldC5faXRlbXMpKSB7XG4gICAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXSA9IHt9O1xuICAgICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXVtpdGVtXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluIHNldC5faXRlbXNbdHlwZV0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdW2l0ZW1dID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIC8vIHNldC5faXRlbXNbJ2Jvb2xlYW4nXSBob2xkcyBhIHR3byBlbGVtZW50IGFycmF5XG4gICAgICAvLyByZXByZXNlbnRpbmcgWyBmYWxzZUV4aXN0cywgdHJ1ZUV4aXN0cyBdXG4gICAgICBpZiAodHlwZSBpbiBzZXQuX2l0ZW1zKSB7XG4gICAgICAgIHZhciBiSWR4ID0gaXRlbSA/IDEgOiAwO1xuICAgICAgICBpZiAoc2V0Ll9pdGVtc1t0eXBlXVtiSWR4XSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV1bYklkeF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdID0gaXRlbSA/IFtmYWxzZSwgdHJ1ZV0gOiBbdHJ1ZSwgZmFsc2VdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIC8vIGNvbXBhcmUgZnVuY3Rpb25zIGZvciByZWZlcmVuY2UgZXF1YWxpdHlcbiAgICAgIGlmIChzZXQuX25hdGl2ZVNldCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgcHJldlNpemUgPSBzZXQuX25hdGl2ZVNldC5zaXplO1xuICAgICAgICAgIHNldC5fbmF0aXZlU2V0LmFkZChpdGVtKTtcbiAgICAgICAgICBuZXdTaXplID0gc2V0Ll9uYXRpdmVTZXQuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gbmV3U2l6ZSA9PT0gcHJldlNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNldC5fbmF0aXZlU2V0LmhhcyhpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEodHlwZSBpbiBzZXQuX2l0ZW1zKSkge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0gPSBbaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9jb250YWlucyhpdGVtLCBzZXQuX2l0ZW1zW3R5cGVdKSkge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0ucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIGlmIChzZXQuX2l0ZW1zW3R5cGVdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoaXRlbSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoIXNldC5faXRlbXNbJ251bGwnXSkge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHNldC5faXRlbXNbJ251bGwnXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIHJlZHVjZSB0aGUgc2VhcmNoIHNpemUgb2YgaGV0ZXJvZ2VuZW91cyBzZXRzIGJ5IGNyZWF0aW5nIGJ1Y2tldHNcbiAgICAgIC8vIGZvciBlYWNoIHR5cGUuXG4gICAgICB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuICAgICAgaWYgKCEodHlwZSBpbiBzZXQuX2l0ZW1zKSkge1xuICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXSA9IFtpdGVtXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBzY2FuIHRocm91Z2ggYWxsIHByZXZpb3VzbHkgYXBwbGllZCBpdGVtc1xuICAgICAgaWYgKCFfY29udGFpbnMoaXRlbSwgc2V0Ll9pdGVtc1t0eXBlXSkpIHtcbiAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0ucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vLyBBIHNpbXBsZSBTZXQgdHlwZSB0aGF0IGhvbm91cnMgUi5lcXVhbHMgc2VtYW50aWNzXG5leHBvcnQgZGVmYXVsdCBfU2V0OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcGVydHVyZShuLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGltaXQgPSBsaXN0Lmxlbmd0aCAtIChuIC0gMSk7XG4gIHZhciBhY2MgPSBuZXcgQXJyYXkobGltaXQgPj0gMCA/IGxpbWl0IDogMCk7XG4gIHdoaWxlIChpZHggPCBsaW1pdCkge1xuICAgIGFjY1tpZHhdID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgaWR4LCBpZHggKyBuKTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gYWNjO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcml0eShuLCBmbikge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMikge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMykge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNikge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgY2FzZSAxMDpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIF9hcml0eSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgbm8gZ3JlYXRlciB0aGFuIHRlbicpO1xuICB9XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5RnJvbUl0ZXJhdG9yKGl0ZXIpIHtcbiAgdmFyIGxpc3QgPSBbXTtcbiAgdmFyIG5leHQ7XG4gIHdoaWxlICghKG5leHQgPSBpdGVyLm5leHQoKSkuZG9uZSkge1xuICAgIGxpc3QucHVzaChuZXh0LnZhbHVlKTtcbiAgfVxuICByZXR1cm4gbGlzdDtcbn0iLCJpbXBvcnQgX29iamVjdEFzc2lnbiBmcm9tICcuL19vYmplY3RBc3NpZ24nO1xuXG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgT2JqZWN0LmFzc2lnbiA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5hc3NpZ24gOiBfb2JqZWN0QXNzaWduOyIsImltcG9ydCBfaXNBcnJheSBmcm9tICcuL19pc0FycmF5JztcblxuLyoqXG4gKiBUaGlzIGNoZWNrcyB3aGV0aGVyIGEgZnVuY3Rpb24gaGFzIGEgW21ldGhvZG5hbWVdIGZ1bmN0aW9uLiBJZiBpdCBpc24ndCBhblxuICogYXJyYXkgaXQgd2lsbCBleGVjdXRlIHRoYXQgZnVuY3Rpb24gb3RoZXJ3aXNlIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgcmFtZGFcbiAqIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiByYW1kYSBpbXBsZW10YXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RuYW1lIHByb3BlcnR5IHRvIGNoZWNrIGZvciBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybiB7T2JqZWN0fSBXaGF0ZXZlciB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBtZXRob2QgaXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jaGVja0Zvck1ldGhvZChtZXRob2RuYW1lLCBmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbiAgICB2YXIgb2JqID0gYXJndW1lbnRzW2xlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfaXNBcnJheShvYmopIHx8IHR5cGVvZiBvYmpbbWV0aG9kbmFtZV0gIT09ICdmdW5jdGlvbicgPyBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogb2JqW21ldGhvZG5hbWVdLmFwcGx5KG9iaiwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCBsZW5ndGggLSAxKSk7XG4gIH07XG59IiwiaW1wb3J0IF9jbG9uZVJlZ0V4cCBmcm9tICcuL19jbG9uZVJlZ0V4cCc7XG5pbXBvcnQgdHlwZSBmcm9tICcuLi90eXBlJztcblxuLyoqXG4gKiBDb3BpZXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjb3BpZWRcbiAqIEBwYXJhbSB7QXJyYXl9IHJlZkZyb20gQXJyYXkgY29udGFpbmluZyB0aGUgc291cmNlIHJlZmVyZW5jZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHJlZlRvIEFycmF5IGNvbnRhaW5pbmcgdGhlIGNvcGllZCBzb3VyY2UgcmVmZXJlbmNlc1xuICogQHBhcmFtIHtCb29sZWFufSBkZWVwIFdoZXRoZXIgb3Igbm90IHRvIHBlcmZvcm0gZGVlcCBjbG9uaW5nLlxuICogQHJldHVybiB7Kn0gVGhlIGNvcGllZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Nsb25lKHZhbHVlLCByZWZGcm9tLCByZWZUbywgZGVlcCkge1xuICB2YXIgY29weSA9IGZ1bmN0aW9uIGNvcHkoY29waWVkVmFsdWUpIHtcbiAgICB2YXIgbGVuID0gcmVmRnJvbS5sZW5ndGg7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgaWYgKHZhbHVlID09PSByZWZGcm9tW2lkeF0pIHtcbiAgICAgICAgcmV0dXJuIHJlZlRvW2lkeF07XG4gICAgICB9XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG4gICAgcmVmRnJvbVtpZHggKyAxXSA9IHZhbHVlO1xuICAgIHJlZlRvW2lkeCArIDFdID0gY29waWVkVmFsdWU7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBjb3BpZWRWYWx1ZVtrZXldID0gZGVlcCA/IF9jbG9uZSh2YWx1ZVtrZXldLCByZWZGcm9tLCByZWZUbywgdHJ1ZSkgOiB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gY29waWVkVmFsdWU7XG4gIH07XG4gIHN3aXRjaCAodHlwZSh2YWx1ZSkpIHtcbiAgICBjYXNlICdPYmplY3QnOlxuICAgICAgcmV0dXJuIGNvcHkoe30pO1xuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHJldHVybiBjb3B5KFtdKTtcbiAgICBjYXNlICdEYXRlJzpcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZS52YWx1ZU9mKCkpO1xuICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICByZXR1cm4gX2Nsb25lUmVnRXhwKHZhbHVlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Nsb25lUmVnRXhwKHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgKHBhdHRlcm4uZ2xvYmFsID8gJ2cnIDogJycpICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArIChwYXR0ZXJuLm11bHRpbGluZSA/ICdtJyA6ICcnKSArIChwYXR0ZXJuLnN0aWNreSA/ICd5JyA6ICcnKSArIChwYXR0ZXJuLnVuaWNvZGUgPyAndScgOiAnJykpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jb21wbGVtZW50KGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0iLCIvKipcbiAqIFByaXZhdGUgYGNvbmNhdGAgZnVuY3Rpb24gdG8gbWVyZ2UgdHdvIGFycmF5LWxpa2Ugb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxBcmd1bWVudHN9IFtzZXQxPVtdXSBBbiBhcnJheS1saWtlIG9iamVjdC5cbiAqIEBwYXJhbSB7QXJyYXl8QXJndW1lbnRzfSBbc2V0Mj1bXV0gQW4gYXJyYXktbGlrZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcsIG1lcmdlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBfY29uY2F0KFs0LCA1LCA2XSwgWzEsIDIsIDNdKTsgLy89PiBbNCwgNSwgNiwgMSwgMiwgM11cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NvbmNhdChzZXQxLCBzZXQyKSB7XG4gIHNldDEgPSBzZXQxIHx8IFtdO1xuICBzZXQyID0gc2V0MiB8fCBbXTtcbiAgdmFyIGlkeDtcbiAgdmFyIGxlbjEgPSBzZXQxLmxlbmd0aDtcbiAgdmFyIGxlbjIgPSBzZXQyLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBsZW4xKSB7XG4gICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gc2V0MVtpZHhdO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBsZW4yKSB7XG4gICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gc2V0MltpZHhdO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59IiwiaW1wb3J0IF9pbmRleE9mIGZyb20gJy4vX2luZGV4T2YnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY29udGFpbnMoYSwgbGlzdCkge1xuICByZXR1cm4gX2luZGV4T2YobGlzdCwgYSwgMCkgPj0gMDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY29udGFpbnNXaXRoKHByZWQsIHgsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgaWYgKHByZWQoeCwgbGlzdFtpZHhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn0iLCJpbXBvcnQgX2FyaXR5IGZyb20gJy4vX2FyaXR5JztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vX2N1cnJ5Mic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jcmVhdGVQYXJ0aWFsQXBwbGljYXRvcihjb25jYXQpIHtcbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gKGZuLCBhcmdzKSB7XG4gICAgcmV0dXJuIF9hcml0eShNYXRoLm1heCgwLCBmbi5sZW5ndGggLSBhcmdzLmxlbmd0aCksIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBjb25jYXQoYXJncywgYXJndW1lbnRzKSk7XG4gICAgfSk7XG4gIH0pO1xufSIsImltcG9ydCBfaXNQbGFjZWhvbGRlciBmcm9tICcuL19pc1BsYWNlaG9sZGVyJztcblxuLyoqXG4gKiBPcHRpbWl6ZWQgaW50ZXJuYWwgb25lLWFyaXR5IGN1cnJ5IGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2N1cnJ5MShmbikge1xuICByZXR1cm4gZnVuY3Rpb24gZjEoYSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IF9pc1BsYWNlaG9sZGVyKGEpKSB7XG4gICAgICByZXR1cm4gZjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbn0iLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL19jdXJyeTEnO1xuaW1wb3J0IF9pc1BsYWNlaG9sZGVyIGZyb20gJy4vX2lzUGxhY2Vob2xkZXInO1xuXG4vKipcbiAqIE9wdGltaXplZCBpbnRlcm5hbCB0d28tYXJpdHkgY3VycnkgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY3VycnkyKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmMihhLCBiKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBmMjtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpID8gZjIgOiBfY3VycnkxKGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgIHJldHVybiBmbihhLCBfYik7XG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGIpID8gZjIgOiBfaXNQbGFjZWhvbGRlcihhKSA/IF9jdXJyeTEoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKF9hLCBiKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTEoZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKGEsIF9iKTtcbiAgICAgICAgfSkgOiBmbihhLCBiKTtcbiAgICB9XG4gIH07XG59IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9fY3VycnkxJztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vX2N1cnJ5Mic7XG5pbXBvcnQgX2lzUGxhY2Vob2xkZXIgZnJvbSAnLi9faXNQbGFjZWhvbGRlcic7XG5cbi8qKlxuICogT3B0aW1pemVkIGludGVybmFsIHRocmVlLWFyaXR5IGN1cnJ5IGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2N1cnJ5Myhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gZjMoYSwgYiwgYykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gZjM7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSA/IGYzIDogX2N1cnJ5MihmdW5jdGlvbiAoX2IsIF9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKGEsIF9iLCBfYyk7XG4gICAgICAgIH0pO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgPyBmMyA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MihmdW5jdGlvbiAoX2EsIF9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKF9hLCBiLCBfYyk7XG4gICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYikgPyBfY3VycnkyKGZ1bmN0aW9uIChfYiwgX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgX2IsIF9jKTtcbiAgICAgICAgfSkgOiBfY3VycnkxKGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgIHJldHVybiBmbihhLCBiLCBfYyk7XG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGIpICYmIF9pc1BsYWNlaG9sZGVyKGMpID8gZjMgOiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTIoZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICAgIHJldHVybiBmbihfYSwgX2IsIGMpO1xuICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGMpID8gX2N1cnJ5MihmdW5jdGlvbiAoX2EsIF9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKF9hLCBiLCBfYyk7XG4gICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYikgJiYgX2lzUGxhY2Vob2xkZXIoYykgPyBfY3VycnkyKGZ1bmN0aW9uIChfYiwgX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgX2IsIF9jKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihhKSA/IF9jdXJyeTEoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKF9hLCBiLCBjKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTEoZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKGEsIF9iLCBjKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihjKSA/IF9jdXJyeTEoZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKGEsIGIsIF9jKTtcbiAgICAgICAgfSkgOiBmbihhLCBiLCBjKTtcbiAgICB9XG4gIH07XG59IiwiaW1wb3J0IF9hcml0eSBmcm9tICcuL19hcml0eSc7XG5pbXBvcnQgX2lzUGxhY2Vob2xkZXIgZnJvbSAnLi9faXNQbGFjZWhvbGRlcic7XG5cbi8qKlxuICogSW50ZXJuYWwgY3VycnlOIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGFyaXR5IG9mIHRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gcmVjZWl2ZWQgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHJlY2VpdmVkIHRodXMgZmFyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY3VycnlOKGxlbmd0aCwgcmVjZWl2ZWQsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbWJpbmVkID0gW107XG4gICAgdmFyIGFyZ3NJZHggPSAwO1xuICAgIHZhciBsZWZ0ID0gbGVuZ3RoO1xuICAgIHZhciBjb21iaW5lZElkeCA9IDA7XG4gICAgd2hpbGUgKGNvbWJpbmVkSWR4IDwgcmVjZWl2ZWQubGVuZ3RoIHx8IGFyZ3NJZHggPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKGNvbWJpbmVkSWR4IDwgcmVjZWl2ZWQubGVuZ3RoICYmICghX2lzUGxhY2Vob2xkZXIocmVjZWl2ZWRbY29tYmluZWRJZHhdKSB8fCBhcmdzSWR4ID49IGFyZ3VtZW50cy5sZW5ndGgpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlY2VpdmVkW2NvbWJpbmVkSWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGFyZ3VtZW50c1thcmdzSWR4XTtcbiAgICAgICAgYXJnc0lkeCArPSAxO1xuICAgICAgfVxuICAgICAgY29tYmluZWRbY29tYmluZWRJZHhdID0gcmVzdWx0O1xuICAgICAgaWYgKCFfaXNQbGFjZWhvbGRlcihyZXN1bHQpKSB7XG4gICAgICAgIGxlZnQgLT0gMTtcbiAgICAgIH1cbiAgICAgIGNvbWJpbmVkSWR4ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0IDw9IDAgPyBmbi5hcHBseSh0aGlzLCBjb21iaW5lZCkgOiBfYXJpdHkobGVmdCwgX2N1cnJ5TihsZW5ndGgsIGNvbWJpbmVkLCBmbikpO1xuICB9O1xufSIsImltcG9ydCBfaXNBcnJheSBmcm9tICcuL19pc0FycmF5JztcbmltcG9ydCBfaXNUcmFuc2Zvcm1lciBmcm9tICcuL19pc1RyYW5zZm9ybWVyJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBkaXNwYXRjaGVzIHdpdGggZGlmZmVyZW50IHN0cmF0ZWdpZXMgYmFzZWQgb24gdGhlXG4gKiBvYmplY3QgaW4gbGlzdCBwb3NpdGlvbiAobGFzdCBhcmd1bWVudCkuIElmIGl0IGlzIGFuIGFycmF5LCBleGVjdXRlcyBbZm5dLlxuICogT3RoZXJ3aXNlLCBpZiBpdCBoYXMgYSBmdW5jdGlvbiB3aXRoIG9uZSBvZiB0aGUgZ2l2ZW4gbWV0aG9kIG5hbWVzLCBpdCB3aWxsXG4gKiBleGVjdXRlIHRoYXQgZnVuY3Rpb24gKGZ1bmN0b3IgY2FzZSkuIE90aGVyd2lzZSwgaWYgaXQgaXMgYSB0cmFuc2Zvcm1lcixcbiAqIHVzZXMgdHJhbnNkdWNlciBbeGZdIHRvIHJldHVybiBhIG5ldyB0cmFuc2Zvcm1lciAodHJhbnNkdWNlciBjYXNlKS5cbiAqIE90aGVyd2lzZSwgaXQgd2lsbCBkZWZhdWx0IHRvIGV4ZWN1dGluZyBbZm5dLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBtZXRob2ROYW1lcyBwcm9wZXJ0aWVzIHRvIGNoZWNrIGZvciBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0geGYgdHJhbnNkdWNlciB0byBpbml0aWFsaXplIGlmIG9iamVjdCBpcyB0cmFuc2Zvcm1lclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gZGVmYXVsdCByYW1kYSBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCBkaXNwYXRjaGVzIG9uIG9iamVjdCBpbiBsaXN0IHBvc2l0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9kaXNwYXRjaGFibGUobWV0aG9kTmFtZXMsIHhmLCBmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIHZhciBvYmogPSBhcmdzLnBvcCgpO1xuICAgIGlmICghX2lzQXJyYXkob2JqKSkge1xuICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICB3aGlsZSAoaWR4IDwgbWV0aG9kTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqW21ldGhvZE5hbWVzW2lkeF1dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIG9ialttZXRob2ROYW1lc1tpZHhdXS5hcHBseShvYmosIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlkeCArPSAxO1xuICAgICAgfVxuICAgICAgaWYgKF9pc1RyYW5zZm9ybWVyKG9iaikpIHtcbiAgICAgICAgdmFyIHRyYW5zZHVjZXIgPSB4Zi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZHVjZXIob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59IiwiaW1wb3J0IHRha2UgZnJvbSAnLi4vdGFrZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRyb3BMYXN0KG4sIHhzKSB7XG4gIHJldHVybiB0YWtlKG4gPCB4cy5sZW5ndGggPyB4cy5sZW5ndGggLSBuIDogMCwgeHMpO1xufSIsImltcG9ydCBzbGljZSBmcm9tICcuLi9zbGljZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRyb3BMYXN0V2hpbGUocHJlZCwgeHMpIHtcbiAgdmFyIGlkeCA9IHhzLmxlbmd0aCAtIDE7XG4gIHdoaWxlIChpZHggPj0gMCAmJiBwcmVkKHhzW2lkeF0pKSB7XG4gICAgaWR4IC09IDE7XG4gIH1cbiAgcmV0dXJuIHNsaWNlKDAsIGlkeCArIDEsIHhzKTtcbn0iLCJpbXBvcnQgX2FycmF5RnJvbUl0ZXJhdG9yIGZyb20gJy4vX2FycmF5RnJvbUl0ZXJhdG9yJztcbmltcG9ydCBfY29udGFpbnNXaXRoIGZyb20gJy4vX2NvbnRhaW5zV2l0aCc7XG5pbXBvcnQgX2Z1bmN0aW9uTmFtZSBmcm9tICcuL19mdW5jdGlvbk5hbWUnO1xuaW1wb3J0IF9oYXMgZnJvbSAnLi9faGFzJztcbmltcG9ydCBpZGVudGljYWwgZnJvbSAnLi4vaWRlbnRpY2FsJztcbmltcG9ydCBrZXlzIGZyb20gJy4uL2tleXMnO1xuaW1wb3J0IHR5cGUgZnJvbSAnLi4vdHlwZSc7XG5cbi8qKlxuICogcHJpdmF0ZSBfdW5pcUNvbnRlbnRFcXVhbHMgZnVuY3Rpb24uXG4gKiBUaGF0IGZ1bmN0aW9uIGlzIGNoZWNraW5nIGVxdWFsaXR5IG9mIDIgaXRlcmF0b3IgY29udGVudHMgd2l0aCAyIGFzc3VtcHRpb25zXG4gKiAtIGl0ZXJhdG9ycyBsZW5ndGhzIGFyZSB0aGUgc2FtZVxuICogLSBpdGVyYXRvcnMgdmFsdWVzIGFyZSB1bmlxdWVcbiAqXG4gKiBmYWxzZS1wb3NpdGl2ZSByZXN1bHQgd2lsbCBiZSByZXR1cm5lZCBmb3IgY29tcGFyaXNpb24gb2YsIGUuZy5cbiAqIC0gWzEsMiwzXSBhbmQgWzEsMiwzLDRdXG4gKiAtIFsxLDEsMV0gYW5kIFsxLDIsM11cbiAqICovXG5cbmZ1bmN0aW9uIF91bmlxQ29udGVudEVxdWFscyhhSXRlcmF0b3IsIGJJdGVyYXRvciwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIGEgPSBfYXJyYXlGcm9tSXRlcmF0b3IoYUl0ZXJhdG9yKTtcbiAgdmFyIGIgPSBfYXJyYXlGcm9tSXRlcmF0b3IoYkl0ZXJhdG9yKTtcblxuICBmdW5jdGlvbiBlcShfYSwgX2IpIHtcbiAgICByZXR1cm4gX2VxdWFscyhfYSwgX2IsIHN0YWNrQS5zbGljZSgpLCBzdGFja0Iuc2xpY2UoKSk7XG4gIH1cblxuICAvLyBpZiAqYSogYXJyYXkgY29udGFpbnMgYW55IGVsZW1lbnQgdGhhdCBpcyBub3QgaW5jbHVkZWQgaW4gKmIqXG4gIHJldHVybiAhX2NvbnRhaW5zV2l0aChmdW5jdGlvbiAoYiwgYUl0ZW0pIHtcbiAgICByZXR1cm4gIV9jb250YWluc1dpdGgoZXEsIGFJdGVtLCBiKTtcbiAgfSwgYiwgYSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9lcXVhbHMoYSwgYiwgc3RhY2tBLCBzdGFja0IpIHtcbiAgaWYgKGlkZW50aWNhbChhLCBiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHR5cGVBID0gdHlwZShhKTtcblxuICBpZiAodHlwZUEgIT09IHR5cGUoYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYVsnZmFudGFzeS1sYW5kL2VxdWFscyddID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBiWydmYW50YXN5LWxhbmQvZXF1YWxzJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXSA9PT0gJ2Z1bmN0aW9uJyAmJiBhWydmYW50YXN5LWxhbmQvZXF1YWxzJ10oYikgJiYgdHlwZW9mIGJbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXSA9PT0gJ2Z1bmN0aW9uJyAmJiBiWydmYW50YXN5LWxhbmQvZXF1YWxzJ10oYSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGEuZXF1YWxzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBiLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlb2YgYS5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiYgYS5lcXVhbHMoYikgJiYgdHlwZW9mIGIuZXF1YWxzID09PSAnZnVuY3Rpb24nICYmIGIuZXF1YWxzKGEpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlQSkge1xuICAgIGNhc2UgJ0FyZ3VtZW50cyc6XG4gICAgY2FzZSAnQXJyYXknOlxuICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICBpZiAodHlwZW9mIGEuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiYgX2Z1bmN0aW9uTmFtZShhLmNvbnN0cnVjdG9yKSA9PT0gJ1Byb21pc2UnKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgY2FzZSAnTnVtYmVyJzpcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgaWYgKCEodHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGlkZW50aWNhbChhLnZhbHVlT2YoKSwgYi52YWx1ZU9mKCkpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdEYXRlJzpcbiAgICAgIGlmICghaWRlbnRpY2FsKGEudmFsdWVPZigpLCBiLnZhbHVlT2YoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnRXJyb3InOlxuICAgICAgcmV0dXJuIGEubmFtZSA9PT0gYi5uYW1lICYmIGEubWVzc2FnZSA9PT0gYi5tZXNzYWdlO1xuICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICBpZiAoIShhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5nbG9iYWwgPT09IGIuZ2xvYmFsICYmIGEuaWdub3JlQ2FzZSA9PT0gYi5pZ25vcmVDYXNlICYmIGEubXVsdGlsaW5lID09PSBiLm11bHRpbGluZSAmJiBhLnN0aWNreSA9PT0gYi5zdGlja3kgJiYgYS51bmljb2RlID09PSBiLnVuaWNvZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIGlkeCA9IHN0YWNrQS5sZW5ndGggLSAxO1xuICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICBpZiAoc3RhY2tBW2lkeF0gPT09IGEpIHtcbiAgICAgIHJldHVybiBzdGFja0JbaWR4XSA9PT0gYjtcbiAgICB9XG4gICAgaWR4IC09IDE7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVBKSB7XG4gICAgY2FzZSAnTWFwJzpcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdW5pcUNvbnRlbnRFcXVhbHMoYS5lbnRyaWVzKCksIGIuZW50cmllcygpLCBzdGFja0EuY29uY2F0KFthXSksIHN0YWNrQi5jb25jYXQoW2JdKSk7XG4gICAgY2FzZSAnU2V0JzpcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdW5pcUNvbnRlbnRFcXVhbHMoYS52YWx1ZXMoKSwgYi52YWx1ZXMoKSwgc3RhY2tBLmNvbmNhdChbYV0pLCBzdGFja0IuY29uY2F0KFtiXSkpO1xuICAgIGNhc2UgJ0FyZ3VtZW50cyc6XG4gICAgY2FzZSAnQXJyYXknOlxuICAgIGNhc2UgJ09iamVjdCc6XG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgY2FzZSAnTnVtYmVyJzpcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgIGNhc2UgJ0RhdGUnOlxuICAgIGNhc2UgJ0Vycm9yJzpcbiAgICBjYXNlICdSZWdFeHAnOlxuICAgIGNhc2UgJ0ludDhBcnJheSc6XG4gICAgY2FzZSAnVWludDhBcnJheSc6XG4gICAgY2FzZSAnVWludDhDbGFtcGVkQXJyYXknOlxuICAgIGNhc2UgJ0ludDE2QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQxNkFycmF5JzpcbiAgICBjYXNlICdJbnQzMkFycmF5JzpcbiAgICBjYXNlICdVaW50MzJBcnJheSc6XG4gICAgY2FzZSAnRmxvYXQzMkFycmF5JzpcbiAgICBjYXNlICdGbG9hdDY0QXJyYXknOlxuICAgIGNhc2UgJ0FycmF5QnVmZmVyJzpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBWYWx1ZXMgb2Ygb3RoZXIgdHlwZXMgYXJlIG9ubHkgZXF1YWwgaWYgaWRlbnRpY2FsLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0ga2V5cyhhKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5cyhiKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXh0ZW5kZWRTdGFja0EgPSBzdGFja0EuY29uY2F0KFthXSk7XG4gIHZhciBleHRlbmRlZFN0YWNrQiA9IHN0YWNrQi5jb25jYXQoW2JdKTtcblxuICBpZHggPSBrZXlzQS5sZW5ndGggLSAxO1xuICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcbiAgICBpZiAoIShfaGFzKGtleSwgYikgJiYgX2VxdWFscyhiW2tleV0sIGFba2V5XSwgZXh0ZW5kZWRTdGFja0EsIGV4dGVuZGVkU3RhY2tCKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWR4IC09IDE7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2ZpbHRlcihmbiwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBsaXN0W2lkeF07XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59IiwiaW1wb3J0IF9mb3JjZVJlZHVjZWQgZnJvbSAnLi9fZm9yY2VSZWR1Y2VkJztcbmltcG9ydCBfaXNBcnJheUxpa2UgZnJvbSAnLi9faXNBcnJheUxpa2UnO1xuaW1wb3J0IF9yZWR1Y2UgZnJvbSAnLi9fcmVkdWNlJztcbmltcG9ydCBfeGZCYXNlIGZyb20gJy4vX3hmQmFzZSc7XG5cbnZhciBwcmVzZXJ2aW5nUmVkdWNlZCA9IGZ1bmN0aW9uICh4Zikge1xuICByZXR1cm4ge1xuICAgICdAQHRyYW5zZHVjZXIvaW5pdCc6IF94ZkJhc2UuaW5pdCxcbiAgICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgfSxcbiAgICAnQEB0cmFuc2R1Y2VyL3N0ZXAnOiBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgdmFyIHJldCA9IHhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpO1xuICAgICAgcmV0dXJuIHJldFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSA/IF9mb3JjZVJlZHVjZWQocmV0KSA6IHJldDtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgX2ZsYXRDYXQgPSBmdW5jdGlvbiBfeGNhdCh4Zikge1xuICB2YXIgcnhmID0gcHJlc2VydmluZ1JlZHVjZWQoeGYpO1xuICByZXR1cm4ge1xuICAgICdAQHRyYW5zZHVjZXIvaW5pdCc6IF94ZkJhc2UuaW5pdCxcbiAgICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByeGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICAgIH0sXG4gICAgJ0BAdHJhbnNkdWNlci9zdGVwJzogZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgIHJldHVybiAhX2lzQXJyYXlMaWtlKGlucHV0KSA/IF9yZWR1Y2UocnhmLCByZXN1bHQsIFtpbnB1dF0pIDogX3JlZHVjZShyeGYsIHJlc3VsdCwgaW5wdXQpO1xuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IF9mbGF0Q2F0OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9mb3JjZVJlZHVjZWQoeCkge1xuICByZXR1cm4ge1xuICAgICdAQHRyYW5zZHVjZXIvdmFsdWUnOiB4LFxuICAgICdAQHRyYW5zZHVjZXIvcmVkdWNlZCc6IHRydWVcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZnVuY3Rpb25OYW1lKGYpIHtcbiAgLy8gU3RyaW5nKHggPT4geCkgZXZhbHVhdGVzIHRvIFwieCA9PiB4XCIsIHNvIHRoZSBwYXR0ZXJuIG1heSBub3QgbWF0Y2guXG4gIHZhciBtYXRjaCA9IFN0cmluZyhmKS5tYXRjaCgvXmZ1bmN0aW9uIChcXHcqKS8pO1xuICByZXR1cm4gbWF0Y2ggPT0gbnVsbCA/ICcnIDogbWF0Y2hbMV07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2hhcyhwcm9wLCBvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufSIsImltcG9ydCBlcXVhbHMgZnJvbSAnLi4vZXF1YWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2luZGV4T2YobGlzdCwgYSwgaWR4KSB7XG4gIHZhciBpbmYsIGl0ZW07XG4gIC8vIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIGRvZXNuJ3QgZXhpc3QgYmVsb3cgSUU5XG4gIGlmICh0eXBlb2YgbGlzdC5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgYSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAvLyBtYW51YWxseSBjcmF3bCB0aGUgbGlzdCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuICswIGFuZCAtMFxuICAgICAgICAgIGluZiA9IDEgLyBhO1xuICAgICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaWR4XTtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSAwICYmIDEgLyBpdGVtID09PSBpbmYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYSAhPT0gYSkge1xuICAgICAgICAgIC8vIE5hTlxuICAgICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaWR4XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicgJiYgaXRlbSAhPT0gaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub24temVybyBudW1iZXJzIGNhbiB1dGlsaXNlIFNldFxuICAgICAgICByZXR1cm4gbGlzdC5pbmRleE9mKGEsIGlkeCk7XG5cbiAgICAgIC8vIGFsbCB0aGVzZSB0eXBlcyBjYW4gdXRpbGlzZSBTZXRcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiBsaXN0LmluZGV4T2YoYSwgaWR4KTtcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKGEgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBudWxsIGNhbiB1dGlsaXNlIFNldFxuICAgICAgICAgIHJldHVybiBsaXN0LmluZGV4T2YoYSwgaWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBhbnl0aGluZyBlbHNlIG5vdCBjb3ZlcmVkIGFib3ZlLCBkZWZlciB0byBSLmVxdWFsc1xuICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICBpZiAoZXF1YWxzKGxpc3RbaWR4XSwgYSkpIHtcbiAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCJpbXBvcnQgX2hhcyBmcm9tICcuL19oYXMnO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIF9pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXScgPyBmdW5jdGlvbiBfaXNBcmd1bWVudHMoeCkge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbiAgfSA6IGZ1bmN0aW9uIF9pc0FyZ3VtZW50cyh4KSB7XG4gICAgcmV0dXJuIF9oYXMoJ2NhbGxlZScsIHgpO1xuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgX2lzQXJndW1lbnRzOyIsIi8qKlxuICogVGVzdHMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGlzIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHZhbGAgaXMgYW4gYXJyYXksIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIF9pc0FycmF5KFtdKTsgLy89PiB0cnVlXG4gKiAgICAgIF9pc0FycmF5KG51bGwpOyAvLz0+IGZhbHNlXG4gKiAgICAgIF9pc0FycmF5KHt9KTsgLy89PiBmYWxzZVxuICovXG5leHBvcnQgZGVmYXVsdCBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIF9pc0FycmF5KHZhbCkge1xuICByZXR1cm4gdmFsICE9IG51bGwgJiYgdmFsLmxlbmd0aCA+PSAwICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufTsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL19jdXJyeTEnO1xuaW1wb3J0IF9pc0FycmF5IGZyb20gJy4vX2lzQXJyYXknO1xuaW1wb3J0IF9pc1N0cmluZyBmcm9tICcuL19pc1N0cmluZyc7XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGlzIHNpbWlsYXIgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAqIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0geCBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHhgIGhhcyBhIG51bWVyaWMgbGVuZ3RoIHByb3BlcnR5IGFuZCBleHRyZW1lIGluZGljZXMgZGVmaW5lZDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgX2lzQXJyYXlMaWtlKFtdKTsgLy89PiB0cnVlXG4gKiAgICAgIF9pc0FycmF5TGlrZSh0cnVlKTsgLy89PiBmYWxzZVxuICogICAgICBfaXNBcnJheUxpa2Uoe30pOyAvLz0+IGZhbHNlXG4gKiAgICAgIF9pc0FycmF5TGlrZSh7bGVuZ3RoOiAxMH0pOyAvLz0+IGZhbHNlXG4gKiAgICAgIF9pc0FycmF5TGlrZSh7MDogJ3plcm8nLCA5OiAnbmluZScsIGxlbmd0aDogMTB9KTsgLy89PiB0cnVlXG4gKi9cbnZhciBfaXNBcnJheUxpa2UgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBpc0FycmF5TGlrZSh4KSB7XG4gIGlmIChfaXNBcnJheSh4KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgheCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChfaXNTdHJpbmcoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHgubm9kZVR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gISF4Lmxlbmd0aDtcbiAgfVxuICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoeC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHguaGFzT3duUHJvcGVydHkoMCkgJiYgeC5oYXNPd25Qcm9wZXJ0eSh4Lmxlbmd0aCAtIDEpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgX2lzQXJyYXlMaWtlOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn0iLCIvKipcbiAqIERldGVybWluZSBpZiB0aGUgcGFzc2VkIGFyZ3VtZW50IGlzIGFuIGludGVnZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gblxuICogQGNhdGVnb3J5IFR5cGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBkZWZhdWx0IE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24gX2lzSW50ZWdlcihuKSB7XG4gIHJldHVybiBuIDw8IDAgPT09IG47XG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pc051bWJlcih4KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pc09iamVjdCh4KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pc1BsYWNlaG9sZGVyKGEpIHtcbiAgICAgICByZXR1cm4gYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSA9PT0gdHJ1ZTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXNSZWdFeHAoeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXNTdHJpbmcoeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBTdHJpbmddJztcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXNUcmFuc2Zvcm1lcihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmpbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPT09ICdmdW5jdGlvbic7XG59IiwiaW1wb3J0IF9pc0FycmF5TGlrZSBmcm9tICcuL19pc0FycmF5TGlrZSc7XG5cbi8qKlxuICogYF9tYWtlRmxhdGAgaXMgYSBoZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgb25lLWxldmVsIG9yIGZ1bGx5IHJlY3Vyc2l2ZVxuICogZnVuY3Rpb24gYmFzZWQgb24gdGhlIGZsYWcgcGFzc2VkIGluLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9tYWtlRmxhdChyZWN1cnNpdmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZsYXR0KGxpc3QpIHtcbiAgICB2YXIgdmFsdWUsIGpsZW4sIGo7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciBpbGVuID0gbGlzdC5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaWR4IDwgaWxlbikge1xuICAgICAgaWYgKF9pc0FycmF5TGlrZShsaXN0W2lkeF0pKSB7XG4gICAgICAgIHZhbHVlID0gcmVjdXJzaXZlID8gZmxhdHQobGlzdFtpZHhdKSA6IGxpc3RbaWR4XTtcbiAgICAgICAgaiA9IDA7XG4gICAgICAgIGpsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChqIDwgamxlbikge1xuICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlW2pdO1xuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gbGlzdFtpZHhdO1xuICAgICAgfVxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX21hcChmbiwgZnVuY3Rvcikge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGZ1bmN0b3IubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuKTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHJlc3VsdFtpZHhdID0gZm4oZnVuY3RvcltpZHhdKTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSIsImltcG9ydCBfaGFzIGZyb20gJy4vX2hhcyc7XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RBc3NpZ24odGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICB9XG5cbiAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICB2YXIgaWR4ID0gMTtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2lkeF07XG4gICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoX2hhcyhuZXh0S2V5LCBzb3VyY2UpKSB7XG4gICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29mKHgpIHtcbiAgcmV0dXJuIFt4XTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfcGlwZShmLCBnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGcuY2FsbCh0aGlzLCBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9waXBlUChmLCBnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN0eCA9IHRoaXM7XG4gICAgcmV0dXJuIGYuYXBwbHkoY3R4LCBhcmd1bWVudHMpLnRoZW4oZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBnLmNhbGwoY3R4LCB4KTtcbiAgICB9KTtcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfcXVvdGUocykge1xuICB2YXIgZXNjYXBlZCA9IHMucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9bXFxiXS9nLCAnXFxcXGInKSAvLyBcXGIgbWF0Y2hlcyB3b3JkIGJvdW5kYXJ5OyBbXFxiXSBtYXRjaGVzIGJhY2tzcGFjZVxuICAucmVwbGFjZSgvXFxmL2csICdcXFxcZicpLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKS5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpLnJlcGxhY2UoL1xcdi9nLCAnXFxcXHYnKS5yZXBsYWNlKC9cXDAvZywgJ1xcXFwwJyk7XG5cbiAgcmV0dXJuICdcIicgKyBlc2NhcGVkLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSArICdcIic7XG59IiwiaW1wb3J0IF9pc0FycmF5TGlrZSBmcm9tICcuL19pc0FycmF5TGlrZSc7XG5pbXBvcnQgX3h3cmFwIGZyb20gJy4vX3h3cmFwJztcbmltcG9ydCBiaW5kIGZyb20gJy4uL2JpbmQnO1xuXG5mdW5jdGlvbiBfYXJyYXlSZWR1Y2UoeGYsIGFjYywgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgYWNjID0geGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10oYWNjLCBsaXN0W2lkeF0pO1xuICAgIGlmIChhY2MgJiYgYWNjWydAQHRyYW5zZHVjZXIvcmVkdWNlZCddKSB7XG4gICAgICBhY2MgPSBhY2NbJ0BAdHJhbnNkdWNlci92YWx1ZSddO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKGFjYyk7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVJlZHVjZSh4ZiwgYWNjLCBpdGVyKSB7XG4gIHZhciBzdGVwID0gaXRlci5uZXh0KCk7XG4gIHdoaWxlICghc3RlcC5kb25lKSB7XG4gICAgYWNjID0geGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10oYWNjLCBzdGVwLnZhbHVlKTtcbiAgICBpZiAoYWNjICYmIGFjY1snQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSkge1xuICAgICAgYWNjID0gYWNjWydAQHRyYW5zZHVjZXIvdmFsdWUnXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzdGVwID0gaXRlci5uZXh0KCk7XG4gIH1cbiAgcmV0dXJuIHhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10oYWNjKTtcbn1cblxuZnVuY3Rpb24gX21ldGhvZFJlZHVjZSh4ZiwgYWNjLCBvYmosIG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIHhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ob2JqW21ldGhvZE5hbWVdKGJpbmQoeGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10sIHhmKSwgYWNjKSk7XG59XG5cbnZhciBzeW1JdGVyYXRvciA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sLml0ZXJhdG9yIDogJ0BAaXRlcmF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfcmVkdWNlKGZuLCBhY2MsIGxpc3QpIHtcbiAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gX3h3cmFwKGZuKTtcbiAgfVxuICBpZiAoX2lzQXJyYXlMaWtlKGxpc3QpKSB7XG4gICAgcmV0dXJuIF9hcnJheVJlZHVjZShmbiwgYWNjLCBsaXN0KTtcbiAgfVxuICBpZiAodHlwZW9mIGxpc3RbJ2ZhbnRhc3ktbGFuZC9yZWR1Y2UnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBfbWV0aG9kUmVkdWNlKGZuLCBhY2MsIGxpc3QsICdmYW50YXN5LWxhbmQvcmVkdWNlJyk7XG4gIH1cbiAgaWYgKGxpc3Rbc3ltSXRlcmF0b3JdICE9IG51bGwpIHtcbiAgICByZXR1cm4gX2l0ZXJhYmxlUmVkdWNlKGZuLCBhY2MsIGxpc3Rbc3ltSXRlcmF0b3JdKCkpO1xuICB9XG4gIGlmICh0eXBlb2YgbGlzdC5uZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIF9pdGVyYWJsZVJlZHVjZShmbiwgYWNjLCBsaXN0KTtcbiAgfVxuICBpZiAodHlwZW9mIGxpc3QucmVkdWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIF9tZXRob2RSZWR1Y2UoZm4sIGFjYywgbGlzdCwgJ3JlZHVjZScpO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlOiBsaXN0IG11c3QgYmUgYXJyYXkgb3IgaXRlcmFibGUnKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfcmVkdWNlZCh4KSB7XG4gIHJldHVybiB4ICYmIHhbJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJ10gPyB4IDoge1xuICAgICdAQHRyYW5zZHVjZXIvdmFsdWUnOiB4LFxuICAgICdAQHRyYW5zZHVjZXIvcmVkdWNlZCc6IHRydWVcbiAgfTtcbn0iLCJpbXBvcnQgX2Fzc2lnbiBmcm9tICcuL19hc3NpZ24nO1xuaW1wb3J0IF9pZGVudGl0eSBmcm9tICcuL19pZGVudGl0eSc7XG5pbXBvcnQgX2lzQXJyYXlMaWtlIGZyb20gJy4vX2lzQXJyYXlMaWtlJztcbmltcG9ydCBfaXNUcmFuc2Zvcm1lciBmcm9tICcuL19pc1RyYW5zZm9ybWVyJztcbmltcG9ydCBvYmpPZiBmcm9tICcuLi9vYmpPZic7XG5cbnZhciBfc3RlcENhdEFycmF5ID0ge1xuICAnQEB0cmFuc2R1Y2VyL2luaXQnOiBBcnJheSxcbiAgJ0BAdHJhbnNkdWNlci9zdGVwJzogZnVuY3Rpb24gKHhzLCB4KSB7XG4gICAgeHMucHVzaCh4KTtcbiAgICByZXR1cm4geHM7XG4gIH0sXG4gICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogX2lkZW50aXR5XG59O1xudmFyIF9zdGVwQ2F0U3RyaW5nID0ge1xuICAnQEB0cmFuc2R1Y2VyL2luaXQnOiBTdHJpbmcsXG4gICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgKyBiO1xuICB9LFxuICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IF9pZGVudGl0eVxufTtcbnZhciBfc3RlcENhdE9iamVjdCA9IHtcbiAgJ0BAdHJhbnNkdWNlci9pbml0JzogT2JqZWN0LFxuICAnQEB0cmFuc2R1Y2VyL3N0ZXAnOiBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHJldHVybiBfYXNzaWduKHJlc3VsdCwgX2lzQXJyYXlMaWtlKGlucHV0KSA/IG9iak9mKGlucHV0WzBdLCBpbnB1dFsxXSkgOiBpbnB1dCk7XG4gIH0sXG4gICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogX2lkZW50aXR5XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfc3RlcENhdChvYmopIHtcbiAgaWYgKF9pc1RyYW5zZm9ybWVyKG9iaikpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChfaXNBcnJheUxpa2Uob2JqKSkge1xuICAgIHJldHVybiBfc3RlcENhdEFycmF5O1xuICB9XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBfc3RlcENhdFN0cmluZztcbiAgfVxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gX3N0ZXBDYXRPYmplY3Q7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIHRyYW5zZm9ybWVyIGZvciAnICsgb2JqKTtcbn0iLCIvKipcbiAqIFBvbHlmaWxsIGZyb20gPGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9JU09TdHJpbmc+LlxuICovXG52YXIgcGFkID0gZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIChuIDwgMTAgPyAnMCcgOiAnJykgKyBuO1xufTtcblxudmFyIF90b0lTT1N0cmluZyA9IHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uIF90b0lTT1N0cmluZyhkKSB7XG4gIHJldHVybiBkLnRvSVNPU3RyaW5nKCk7XG59IDogZnVuY3Rpb24gX3RvSVNPU3RyaW5nKGQpIHtcbiAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKSArICctJyArIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArIHBhZChkLmdldFVUQ0RhdGUoKSkgKyAnVCcgKyBwYWQoZC5nZXRVVENIb3VycygpKSArICc6JyArIHBhZChkLmdldFVUQ01pbnV0ZXMoKSkgKyAnOicgKyBwYWQoZC5nZXRVVENTZWNvbmRzKCkpICsgJy4nICsgKGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgLyAxMDAwKS50b0ZpeGVkKDMpLnNsaWNlKDIsIDUpICsgJ1onO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgX3RvSVNPU3RyaW5nOyIsImltcG9ydCBfY29udGFpbnMgZnJvbSAnLi9fY29udGFpbnMnO1xuaW1wb3J0IF9tYXAgZnJvbSAnLi9fbWFwJztcbmltcG9ydCBfcXVvdGUgZnJvbSAnLi9fcXVvdGUnO1xuaW1wb3J0IF90b0lTT1N0cmluZyBmcm9tICcuL190b0lTT1N0cmluZyc7XG5pbXBvcnQga2V5cyBmcm9tICcuLi9rZXlzJztcbmltcG9ydCByZWplY3QgZnJvbSAnLi4vcmVqZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3RvU3RyaW5nKHgsIHNlZW4pIHtcbiAgdmFyIHJlY3VyID0gZnVuY3Rpb24gcmVjdXIoeSkge1xuICAgIHZhciB4cyA9IHNlZW4uY29uY2F0KFt4XSk7XG4gICAgcmV0dXJuIF9jb250YWlucyh5LCB4cykgPyAnPENpcmN1bGFyPicgOiBfdG9TdHJpbmcoeSwgeHMpO1xuICB9O1xuXG4gIC8vICBtYXBQYWlycyA6OiAoT2JqZWN0LCBbU3RyaW5nXSkgLT4gW1N0cmluZ11cbiAgdmFyIG1hcFBhaXJzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICAgIHJldHVybiBfbWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICByZXR1cm4gX3F1b3RlKGspICsgJzogJyArIHJlY3VyKG9ialtrXSk7XG4gICAgfSwga2V5cy5zbGljZSgpLnNvcnQoKSk7XG4gIH07XG5cbiAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkpIHtcbiAgICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOlxuICAgICAgcmV0dXJuICcoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oJyArIF9tYXAocmVjdXIsIHgpLmpvaW4oJywgJykgKyAnKSknO1xuICAgIGNhc2UgJ1tvYmplY3QgQXJyYXldJzpcbiAgICAgIHJldHVybiAnWycgKyBfbWFwKHJlY3VyLCB4KS5jb25jYXQobWFwUGFpcnMoeCwgcmVqZWN0KGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiAoL15cXGQrJC8udGVzdChrKVxuICAgICAgICApO1xuICAgICAgfSwga2V5cyh4KSkpKS5qb2luKCcsICcpICsgJ10nO1xuICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/ICduZXcgQm9vbGVhbignICsgcmVjdXIoeC52YWx1ZU9mKCkpICsgJyknIDogeC50b1N0cmluZygpO1xuICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgcmV0dXJuICduZXcgRGF0ZSgnICsgKGlzTmFOKHgudmFsdWVPZigpKSA/IHJlY3VyKE5hTikgOiBfcXVvdGUoX3RvSVNPU3RyaW5nKHgpKSkgKyAnKSc7XG4gICAgY2FzZSAnW29iamVjdCBOdWxsXSc6XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnID8gJ25ldyBOdW1iZXIoJyArIHJlY3VyKHgudmFsdWVPZigpKSArICcpJyA6IDEgLyB4ID09PSAtSW5maW5pdHkgPyAnLTAnIDogeC50b1N0cmluZygxMCk7XG4gICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgPyAnbmV3IFN0cmluZygnICsgcmVjdXIoeC52YWx1ZU9mKCkpICsgJyknIDogX3F1b3RlKHgpO1xuICAgIGNhc2UgJ1tvYmplY3QgVW5kZWZpbmVkXSc6XG4gICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgeC50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcmVwciA9IHgudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHJlcHIgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgcmV0dXJuIHJlcHI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAneycgKyBtYXBQYWlycyh4LCBrZXlzKHgpKS5qb2luKCcsICcpICsgJ30nO1xuICB9XG59IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9fY3VycnkyJztcbmltcG9ydCBfcmVkdWNlZCBmcm9tICcuL19yZWR1Y2VkJztcbmltcG9ydCBfeGZCYXNlIGZyb20gJy4vX3hmQmFzZSc7XG5cbnZhciBYQWxsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWEFsbChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMuYWxsID0gdHJ1ZTtcbiAgfVxuICBYQWxsLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWEFsbC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBpZiAodGhpcy5hbGwpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuICBYQWxsLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmYoaW5wdXQpKSB7XG4gICAgICB0aGlzLmFsbCA9IGZhbHNlO1xuICAgICAgcmVzdWx0ID0gX3JlZHVjZWQodGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGZhbHNlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFhBbGw7XG59KCk7XG5cbnZhciBfeGFsbCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF94YWxsKGYsIHhmKSB7XG4gIHJldHVybiBuZXcgWEFsbChmLCB4Zik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IF94YWxsOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vX2N1cnJ5Mic7XG5pbXBvcnQgX3JlZHVjZWQgZnJvbSAnLi9fcmVkdWNlZCc7XG5pbXBvcnQgX3hmQmFzZSBmcm9tICcuL194ZkJhc2UnO1xuXG52YXIgWEFueSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhBbnkoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgICB0aGlzLmFueSA9IGZhbHNlO1xuICB9XG4gIFhBbnkucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYQW55LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGlmICghdGhpcy5hbnkpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfTtcbiAgWEFueS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICB0aGlzLmFueSA9IHRydWU7XG4gICAgICByZXN1bHQgPSBfcmVkdWNlZCh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBYQW55O1xufSgpO1xuXG52YXIgX3hhbnkgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBfeGFueShmLCB4Zikge1xuICByZXR1cm4gbmV3IFhBbnkoZiwgeGYpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBfeGFueTsiLCJpbXBvcnQgX2NvbmNhdCBmcm9tICcuL19jb25jYXQnO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9fY3VycnkyJztcbmltcG9ydCBfeGZCYXNlIGZyb20gJy4vX3hmQmFzZSc7XG5cbnZhciBYQXBlcnR1cmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYQXBlcnR1cmUobiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuZnVsbCA9IGZhbHNlO1xuICAgIHRoaXMuYWNjID0gbmV3IEFycmF5KG4pO1xuICB9XG4gIFhBcGVydHVyZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhBcGVydHVyZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICB0aGlzLmFjYyA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuICBYQXBlcnR1cmUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB0aGlzLnN0b3JlKGlucHV0KTtcbiAgICByZXR1cm4gdGhpcy5mdWxsID8gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMuZ2V0Q29weSgpKSA6IHJlc3VsdDtcbiAgfTtcbiAgWEFwZXJ0dXJlLnByb3RvdHlwZS5zdG9yZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHRoaXMuYWNjW3RoaXMucG9zXSA9IGlucHV0O1xuICAgIHRoaXMucG9zICs9IDE7XG4gICAgaWYgKHRoaXMucG9zID09PSB0aGlzLmFjYy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgIHRoaXMuZnVsbCA9IHRydWU7XG4gICAgfVxuICB9O1xuICBYQXBlcnR1cmUucHJvdG90eXBlLmdldENvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5hY2MsIHRoaXMucG9zKSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5hY2MsIDAsIHRoaXMucG9zKSk7XG4gIH07XG5cbiAgcmV0dXJuIFhBcGVydHVyZTtcbn0oKTtcblxudmFyIF94YXBlcnR1cmUgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBfeGFwZXJ0dXJlKG4sIHhmKSB7XG4gIHJldHVybiBuZXcgWEFwZXJ0dXJlKG4sIHhmKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgX3hhcGVydHVyZTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL19jdXJyeTInO1xuaW1wb3J0IF9mbGF0Q2F0IGZyb20gJy4vX2ZsYXRDYXQnO1xuaW1wb3J0IG1hcCBmcm9tICcuLi9tYXAnO1xuXG52YXIgX3hjaGFpbiA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF94Y2hhaW4oZiwgeGYpIHtcbiAgcmV0dXJuIG1hcChmLCBfZmxhdENhdCh4ZikpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBfeGNoYWluOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vX2N1cnJ5Mic7XG5pbXBvcnQgX3hmQmFzZSBmcm9tICcuL194ZkJhc2UnO1xuXG52YXIgWERyb3AgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYRHJvcChuLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLm4gPSBuO1xuICB9XG4gIFhEcm9wLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWERyb3AucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWERyb3AucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICBpZiAodGhpcy5uID4gMCkge1xuICAgICAgdGhpcy5uIC09IDE7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gWERyb3A7XG59KCk7XG5cbnZhciBfeGRyb3AgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBfeGRyb3AobiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYRHJvcChuLCB4Zik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IF94ZHJvcDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL19jdXJyeTInO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSAnLi9feGZCYXNlJztcblxudmFyIFhEcm9wTGFzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhEcm9wTGFzdChuLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5mdWxsID0gZmFsc2U7XG4gICAgdGhpcy5hY2MgPSBuZXcgQXJyYXkobik7XG4gIH1cbiAgWERyb3BMYXN0LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWERyb3BMYXN0LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHRoaXMuYWNjID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gIH07XG4gIFhEcm9wTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIGlmICh0aGlzLmZ1bGwpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmFjY1t0aGlzLnBvc10pO1xuICAgIH1cbiAgICB0aGlzLnN0b3JlKGlucHV0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBYRHJvcExhc3QucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdGhpcy5hY2NbdGhpcy5wb3NdID0gaW5wdXQ7XG4gICAgdGhpcy5wb3MgKz0gMTtcbiAgICBpZiAodGhpcy5wb3MgPT09IHRoaXMuYWNjLmxlbmd0aCkge1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgdGhpcy5mdWxsID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFhEcm9wTGFzdDtcbn0oKTtcblxudmFyIF94ZHJvcExhc3QgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBfeGRyb3BMYXN0KG4sIHhmKSB7XG4gIHJldHVybiBuZXcgWERyb3BMYXN0KG4sIHhmKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgX3hkcm9wTGFzdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL19jdXJyeTInO1xuaW1wb3J0IF9yZWR1Y2UgZnJvbSAnLi9fcmVkdWNlJztcbmltcG9ydCBfeGZCYXNlIGZyb20gJy4vX3hmQmFzZSc7XG5cbnZhciBYRHJvcExhc3RXaGlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhEcm9wTGFzdFdoaWxlKGZuLCB4Zikge1xuICAgIHRoaXMuZiA9IGZuO1xuICAgIHRoaXMucmV0YWluZWQgPSBbXTtcbiAgICB0aGlzLnhmID0geGY7XG4gIH1cbiAgWERyb3BMYXN0V2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRHJvcExhc3RXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICB0aGlzLnJldGFpbmVkID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gIH07XG4gIFhEcm9wTGFzdFdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZihpbnB1dCkgPyB0aGlzLnJldGFpbihyZXN1bHQsIGlucHV0KSA6IHRoaXMuZmx1c2gocmVzdWx0LCBpbnB1dCk7XG4gIH07XG4gIFhEcm9wTGFzdFdoaWxlLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgcmVzdWx0ID0gX3JlZHVjZSh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddLCByZXN1bHQsIHRoaXMucmV0YWluZWQpO1xuICAgIHRoaXMucmV0YWluZWQgPSBbXTtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgfTtcbiAgWERyb3BMYXN0V2hpbGUucHJvdG90eXBlLnJldGFpbiA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgdGhpcy5yZXRhaW5lZC5wdXNoKGlucHV0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBYRHJvcExhc3RXaGlsZTtcbn0oKTtcblxudmFyIF94ZHJvcExhc3RXaGlsZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF94ZHJvcExhc3RXaGlsZShmbiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYRHJvcExhc3RXaGlsZShmbiwgeGYpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBfeGRyb3BMYXN0V2hpbGU7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9fY3VycnkyJztcbmltcG9ydCBfeGZCYXNlIGZyb20gJy4vX3hmQmFzZSc7XG5cbnZhciBYRHJvcFJlcGVhdHNXaXRoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWERyb3BSZXBlYXRzV2l0aChwcmVkLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLnByZWQgPSBwcmVkO1xuICAgIHRoaXMubGFzdFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2VlbkZpcnN0VmFsdWUgPSBmYWxzZTtcbiAgfVxuXG4gIFhEcm9wUmVwZWF0c1dpdGgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRHJvcFJlcGVhdHNXaXRoLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG4gIFhEcm9wUmVwZWF0c1dpdGgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB2YXIgc2FtZUFzTGFzdCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5zZWVuRmlyc3RWYWx1ZSkge1xuICAgICAgdGhpcy5zZWVuRmlyc3RWYWx1ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByZWQodGhpcy5sYXN0VmFsdWUsIGlucHV0KSkge1xuICAgICAgc2FtZUFzTGFzdCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMubGFzdFZhbHVlID0gaW5wdXQ7XG4gICAgcmV0dXJuIHNhbWVBc0xhc3QgPyByZXN1bHQgOiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpO1xuICB9O1xuXG4gIHJldHVybiBYRHJvcFJlcGVhdHNXaXRoO1xufSgpO1xuXG52YXIgX3hkcm9wUmVwZWF0c1dpdGggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBfeGRyb3BSZXBlYXRzV2l0aChwcmVkLCB4Zikge1xuICByZXR1cm4gbmV3IFhEcm9wUmVwZWF0c1dpdGgocHJlZCwgeGYpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBfeGRyb3BSZXBlYXRzV2l0aDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL19jdXJyeTInO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSAnLi9feGZCYXNlJztcblxudmFyIFhEcm9wV2hpbGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYRHJvcFdoaWxlKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cbiAgWERyb3BXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhEcm9wV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWERyb3BXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIGlmICh0aGlzLmYpIHtcbiAgICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB0aGlzLmYgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gWERyb3BXaGlsZTtcbn0oKTtcblxudmFyIF94ZHJvcFdoaWxlID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gX3hkcm9wV2hpbGUoZiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYRHJvcFdoaWxlKGYsIHhmKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgX3hkcm9wV2hpbGU7IiwiZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9pbml0J10oKTtcbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9XG59OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vX2N1cnJ5Mic7XG5pbXBvcnQgX3hmQmFzZSBmcm9tICcuL194ZkJhc2UnO1xuXG52YXIgWEZpbHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhGaWx0ZXIoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgfVxuICBYRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWEZpbHRlci5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICBYRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZihpbnB1dCkgPyB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpIDogcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBYRmlsdGVyO1xufSgpO1xuXG52YXIgX3hmaWx0ZXIgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBfeGZpbHRlcihmLCB4Zikge1xuICByZXR1cm4gbmV3IFhGaWx0ZXIoZiwgeGYpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBfeGZpbHRlcjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL19jdXJyeTInO1xuaW1wb3J0IF9yZWR1Y2VkIGZyb20gJy4vX3JlZHVjZWQnO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSAnLi9feGZCYXNlJztcblxudmFyIFhGaW5kID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWEZpbmQoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgICB0aGlzLmZvdW5kID0gZmFsc2U7XG4gIH1cbiAgWEZpbmQucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRmluZC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBpZiAoIXRoaXMuZm91bmQpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB2b2lkIDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gIH07XG4gIFhGaW5kLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgcmVzdWx0ID0gX3JlZHVjZWQodGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFhGaW5kO1xufSgpO1xuXG52YXIgX3hmaW5kID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gX3hmaW5kKGYsIHhmKSB7XG4gIHJldHVybiBuZXcgWEZpbmQoZiwgeGYpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBfeGZpbmQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9fY3VycnkyJztcbmltcG9ydCBfcmVkdWNlZCBmcm9tICcuL19yZWR1Y2VkJztcbmltcG9ydCBfeGZCYXNlIGZyb20gJy4vX3hmQmFzZSc7XG5cbnZhciBYRmluZEluZGV4ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWEZpbmRJbmRleChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMuaWR4ID0gLTE7XG4gICAgdGhpcy5mb3VuZCA9IGZhbHNlO1xuICB9XG4gIFhGaW5kSW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRmluZEluZGV4LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGlmICghdGhpcy5mb3VuZCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuICBYRmluZEluZGV4LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgdGhpcy5pZHggKz0gMTtcbiAgICBpZiAodGhpcy5mKGlucHV0KSkge1xuICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICByZXN1bHQgPSBfcmVkdWNlZCh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5pZHgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gWEZpbmRJbmRleDtcbn0oKTtcblxudmFyIF94ZmluZEluZGV4ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gX3hmaW5kSW5kZXgoZiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYRmluZEluZGV4KGYsIHhmKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgX3hmaW5kSW5kZXg7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9fY3VycnkyJztcbmltcG9ydCBfeGZCYXNlIGZyb20gJy4vX3hmQmFzZSc7XG5cbnZhciBYRmluZExhc3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYRmluZExhc3QoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgfVxuICBYRmluZExhc3QucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRmluZExhc3QucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5sYXN0KSk7XG4gIH07XG4gIFhGaW5kTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICB0aGlzLmxhc3QgPSBpbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gWEZpbmRMYXN0O1xufSgpO1xuXG52YXIgX3hmaW5kTGFzdCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF94ZmluZExhc3QoZiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYRmluZExhc3QoZiwgeGYpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBfeGZpbmRMYXN0OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vX2N1cnJ5Mic7XG5pbXBvcnQgX3hmQmFzZSBmcm9tICcuL194ZkJhc2UnO1xuXG52YXIgWEZpbmRMYXN0SW5kZXggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYRmluZExhc3RJbmRleChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMuaWR4ID0gLTE7XG4gICAgdGhpcy5sYXN0SWR4ID0gLTE7XG4gIH1cbiAgWEZpbmRMYXN0SW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRmluZExhc3RJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmxhc3RJZHgpKTtcbiAgfTtcbiAgWEZpbmRMYXN0SW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB0aGlzLmlkeCArPSAxO1xuICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICB0aGlzLmxhc3RJZHggPSB0aGlzLmlkeDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gWEZpbmRMYXN0SW5kZXg7XG59KCk7XG5cbnZhciBfeGZpbmRMYXN0SW5kZXggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBfeGZpbmRMYXN0SW5kZXgoZiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYRmluZExhc3RJbmRleChmLCB4Zik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IF94ZmluZExhc3RJbmRleDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL19jdXJyeTInO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSAnLi9feGZCYXNlJztcblxudmFyIFhNYXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYTWFwKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cbiAgWE1hcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhNYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWE1hcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5mKGlucHV0KSk7XG4gIH07XG5cbiAgcmV0dXJuIFhNYXA7XG59KCk7XG5cbnZhciBfeG1hcCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF94bWFwKGYsIHhmKSB7XG4gIHJldHVybiBuZXcgWE1hcChmLCB4Zik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IF94bWFwOyIsImltcG9ydCBfY3VycnlOIGZyb20gJy4vX2N1cnJ5Tic7XG5pbXBvcnQgX2hhcyBmcm9tICcuL19oYXMnO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSAnLi9feGZCYXNlJztcblxudmFyIFhSZWR1Y2VCeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhSZWR1Y2VCeSh2YWx1ZUZuLCB2YWx1ZUFjYywga2V5Rm4sIHhmKSB7XG4gICAgdGhpcy52YWx1ZUZuID0gdmFsdWVGbjtcbiAgICB0aGlzLnZhbHVlQWNjID0gdmFsdWVBY2M7XG4gICAgdGhpcy5rZXlGbiA9IGtleUZuO1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmlucHV0cyA9IHt9O1xuICB9XG4gIFhSZWR1Y2VCeS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhSZWR1Y2VCeS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICB2YXIga2V5O1xuICAgIGZvciAoa2V5IGluIHRoaXMuaW5wdXRzKSB7XG4gICAgICBpZiAoX2hhcyhrZXksIHRoaXMuaW5wdXRzKSkge1xuICAgICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5pbnB1dHNba2V5XSk7XG4gICAgICAgIGlmIChyZXN1bHRbJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJ10pIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHRbJ0BAdHJhbnNkdWNlci92YWx1ZSddO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaW5wdXRzID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gIH07XG4gIFhSZWR1Y2VCeS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHZhciBrZXkgPSB0aGlzLmtleUZuKGlucHV0KTtcbiAgICB0aGlzLmlucHV0c1trZXldID0gdGhpcy5pbnB1dHNba2V5XSB8fCBba2V5LCB0aGlzLnZhbHVlQWNjXTtcbiAgICB0aGlzLmlucHV0c1trZXldWzFdID0gdGhpcy52YWx1ZUZuKHRoaXMuaW5wdXRzW2tleV1bMV0sIGlucHV0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBYUmVkdWNlQnk7XG59KCk7XG5cbnZhciBfeHJlZHVjZUJ5ID0gLyojX19QVVJFX18qL19jdXJyeU4oNCwgW10sIGZ1bmN0aW9uIF94cmVkdWNlQnkodmFsdWVGbiwgdmFsdWVBY2MsIGtleUZuLCB4Zikge1xuICByZXR1cm4gbmV3IFhSZWR1Y2VCeSh2YWx1ZUZuLCB2YWx1ZUFjYywga2V5Rm4sIHhmKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgX3hyZWR1Y2VCeTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL19jdXJyeTInO1xuaW1wb3J0IF9yZWR1Y2VkIGZyb20gJy4vX3JlZHVjZWQnO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSAnLi9feGZCYXNlJztcblxudmFyIFhUYWtlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWFRha2UobiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5uID0gbjtcbiAgICB0aGlzLmkgPSAwO1xuICB9XG4gIFhUYWtlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWFRha2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWFRha2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB0aGlzLmkgKz0gMTtcbiAgICB2YXIgcmV0ID0gdGhpcy5uID09PSAwID8gcmVzdWx0IDogdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgICByZXR1cm4gdGhpcy5uID49IDAgJiYgdGhpcy5pID49IHRoaXMubiA/IF9yZWR1Y2VkKHJldCkgOiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIFhUYWtlO1xufSgpO1xuXG52YXIgX3h0YWtlID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gX3h0YWtlKG4sIHhmKSB7XG4gIHJldHVybiBuZXcgWFRha2UobiwgeGYpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBfeHRha2U7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9fY3VycnkyJztcbmltcG9ydCBfcmVkdWNlZCBmcm9tICcuL19yZWR1Y2VkJztcbmltcG9ydCBfeGZCYXNlIGZyb20gJy4vX3hmQmFzZSc7XG5cbnZhciBYVGFrZVdoaWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWFRha2VXaGlsZShmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICB9XG4gIFhUYWtlV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYVGFrZVdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG4gIFhUYWtlV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICByZXR1cm4gdGhpcy5mKGlucHV0KSA/IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCkgOiBfcmVkdWNlZChyZXN1bHQpO1xuICB9O1xuXG4gIHJldHVybiBYVGFrZVdoaWxlO1xufSgpO1xuXG52YXIgX3h0YWtlV2hpbGUgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBfeHRha2VXaGlsZShmLCB4Zikge1xuICByZXR1cm4gbmV3IFhUYWtlV2hpbGUoZiwgeGYpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBfeHRha2VXaGlsZTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL19jdXJyeTInO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSAnLi9feGZCYXNlJztcblxudmFyIFhUYXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYVGFwKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cbiAgWFRhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhUYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWFRhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHRoaXMuZihpbnB1dCk7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gIH07XG5cbiAgcmV0dXJuIFhUYXA7XG59KCk7XG5cbnZhciBfeHRhcCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF94dGFwKGYsIHhmKSB7XG4gIHJldHVybiBuZXcgWFRhcChmLCB4Zik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IF94dGFwOyIsInZhciBYV3JhcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhXcmFwKGZuKSB7XG4gICAgdGhpcy5mID0gZm47XG4gIH1cbiAgWFdyYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5pdCBub3QgaW1wbGVtZW50ZWQgb24gWFdyYXAnKTtcbiAgfTtcbiAgWFdyYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAoYWNjKSB7XG4gICAgcmV0dXJuIGFjYztcbiAgfTtcbiAgWFdyYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKGFjYywgeCkge1xuICAgIHJldHVybiB0aGlzLmYoYWNjLCB4KTtcbiAgfTtcblxuICByZXR1cm4gWFdyYXA7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF94d3JhcChmbikge1xuICByZXR1cm4gbmV3IFhXcmFwKGZuKTtcbn0iLCJpbXBvcnQgX2NvbnRhaW5zIGZyb20gJy4vaW50ZXJuYWwvX2NvbnRhaW5zJztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2ZpbHRlciBmcm9tICcuL2ludGVybmFsL19maWx0ZXInO1xuaW1wb3J0IGZsaXAgZnJvbSAnLi9mbGlwJztcbmltcG9ydCB1bmlxIGZyb20gJy4vdW5pcSc7XG5cbi8qKlxuICogQ29tYmluZXMgdHdvIGxpc3RzIGludG8gYSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgY29tcG9zZWQgb2YgdGhvc2VcbiAqIGVsZW1lbnRzIGNvbW1vbiB0byBib3RoIGxpc3RzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIFsqXSAtPiBbKl0gLT4gWypdXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgbGlzdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgbGlzdC5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBlbGVtZW50cyBmb3VuZCBpbiBib3RoIGBsaXN0MWAgYW5kIGBsaXN0MmAuXG4gKiBAc2VlIFIuaW5uZXJKb2luXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pbnRlcnNlY3Rpb24oWzEsMiwzLDRdLCBbNyw2LDUsNCwzXSk7IC8vPT4gWzQsIDNdXG4gKi9cbnZhciBpbnRlcnNlY3Rpb24gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBpbnRlcnNlY3Rpb24obGlzdDEsIGxpc3QyKSB7XG4gIHZhciBsb29rdXBMaXN0LCBmaWx0ZXJlZExpc3Q7XG4gIGlmIChsaXN0MS5sZW5ndGggPiBsaXN0Mi5sZW5ndGgpIHtcbiAgICBsb29rdXBMaXN0ID0gbGlzdDE7XG4gICAgZmlsdGVyZWRMaXN0ID0gbGlzdDI7XG4gIH0gZWxzZSB7XG4gICAgbG9va3VwTGlzdCA9IGxpc3QyO1xuICAgIGZpbHRlcmVkTGlzdCA9IGxpc3QxO1xuICB9XG4gIHJldHVybiB1bmlxKF9maWx0ZXIoZmxpcChfY29udGFpbnMpKGxvb2t1cExpc3QpLCBmaWx0ZXJlZExpc3QpKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgaW50ZXJzZWN0aW9uOyIsImltcG9ydCBfY2hlY2tGb3JNZXRob2QgZnJvbSAnLi9pbnRlcm5hbC9fY2hlY2tGb3JNZXRob2QnO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGxpc3Qgd2l0aCB0aGUgc2VwYXJhdG9yIGludGVycG9zZWQgYmV0d2VlbiBlbGVtZW50cy5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgaW50ZXJzcGVyc2VgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHsqfSBzZXBhcmF0b3IgVGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBiZSBpbnRlcnBvc2VkLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBuZXcgbGlzdC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmludGVyc3BlcnNlKCduJywgWydiYScsICdhJywgJ2EnXSk7IC8vPT4gWydiYScsICduJywgJ2EnLCAnbicsICdhJ11cbiAqL1xudmFyIGludGVyc3BlcnNlID0gLyojX19QVVJFX18qL19jdXJyeTIoIC8qI19fUFVSRV9fKi9fY2hlY2tGb3JNZXRob2QoJ2ludGVyc3BlcnNlJywgZnVuY3Rpb24gaW50ZXJzcGVyc2Uoc2VwYXJhdG9yLCBsaXN0KSB7XG4gIHZhciBvdXQgPSBbXTtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgd2hpbGUgKGlkeCA8IGxlbmd0aCkge1xuICAgIGlmIChpZHggPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgIG91dC5wdXNoKGxpc3RbaWR4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5wdXNoKGxpc3RbaWR4XSwgc2VwYXJhdG9yKTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pKTtcbmV4cG9ydCBkZWZhdWx0IGludGVyc3BlcnNlOyIsImltcG9ydCBfY2xvbmUgZnJvbSAnLi9pbnRlcm5hbC9fY2xvbmUnO1xuaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcbmltcG9ydCBfaXNUcmFuc2Zvcm1lciBmcm9tICcuL2ludGVybmFsL19pc1RyYW5zZm9ybWVyJztcbmltcG9ydCBfcmVkdWNlIGZyb20gJy4vaW50ZXJuYWwvX3JlZHVjZSc7XG5pbXBvcnQgX3N0ZXBDYXQgZnJvbSAnLi9pbnRlcm5hbC9fc3RlcENhdCc7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgaXRlbXMgb2YgdGhlIGxpc3Qgd2l0aCB0aGUgdHJhbnNkdWNlciBhbmQgYXBwZW5kcyB0aGVcbiAqIHRyYW5zZm9ybWVkIGl0ZW1zIHRvIHRoZSBhY2N1bXVsYXRvciB1c2luZyBhbiBhcHByb3ByaWF0ZSBpdGVyYXRvciBmdW5jdGlvblxuICogYmFzZWQgb24gdGhlIGFjY3VtdWxhdG9yIHR5cGUuXG4gKlxuICogVGhlIGFjY3VtdWxhdG9yIGNhbiBiZSBhbiBhcnJheSwgc3RyaW5nLCBvYmplY3Qgb3IgYSB0cmFuc2Zvcm1lci4gSXRlcmF0ZWRcbiAqIGl0ZW1zIHdpbGwgYmUgYXBwZW5kZWQgdG8gYXJyYXlzIGFuZCBjb25jYXRlbmF0ZWQgdG8gc3RyaW5ncy4gT2JqZWN0cyB3aWxsXG4gKiBiZSBtZXJnZWQgZGlyZWN0bHkgb3IgMi1pdGVtIGFycmF5cyB3aWxsIGJlIG1lcmdlZCBhcyBrZXksIHZhbHVlIHBhaXJzLlxuICpcbiAqIFRoZSBhY2N1bXVsYXRvciBjYW4gYWxzbyBiZSBhIHRyYW5zZm9ybWVyIG9iamVjdCB0aGF0IHByb3ZpZGVzIGEgMi1hcml0eVxuICogcmVkdWNpbmcgaXRlcmF0b3IgZnVuY3Rpb24sIHN0ZXAsIDAtYXJpdHkgaW5pdGlhbCB2YWx1ZSBmdW5jdGlvbiwgaW5pdCwgYW5kXG4gKiAxLWFyaXR5IHJlc3VsdCBleHRyYWN0aW9uIGZ1bmN0aW9uIHJlc3VsdC4gVGhlIHN0ZXAgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGVcbiAqIGl0ZXJhdG9yIGZ1bmN0aW9uIGluIHJlZHVjZS4gVGhlIHJlc3VsdCBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbnZlcnQgdGhlXG4gKiBmaW5hbCBhY2N1bXVsYXRvciBpbnRvIHRoZSByZXR1cm4gdHlwZSBhbmQgaW4gbW9zdCBjYXNlcyBpcyBSLmlkZW50aXR5LiBUaGVcbiAqIGluaXQgZnVuY3Rpb24gaXMgdXNlZCB0byBwcm92aWRlIHRoZSBpbml0aWFsIGFjY3VtdWxhdG9yLlxuICpcbiAqIFRoZSBpdGVyYXRpb24gaXMgcGVyZm9ybWVkIHdpdGggW2BSLnJlZHVjZWBdKCNyZWR1Y2UpIGFmdGVyIGluaXRpYWxpemluZyB0aGVcbiAqIHRyYW5zZHVjZXIuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTIuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiAoYiAtPiBiKSAtPiBbY10gLT4gYVxuICogQHBhcmFtIHsqfSBhY2MgVGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB4ZiBUaGUgdHJhbnNkdWNlciBmdW5jdGlvbi4gUmVjZWl2ZXMgYSB0cmFuc2Zvcm1lciBhbmQgcmV0dXJucyBhIHRyYW5zZm9ybWVyLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBudW1iZXJzID0gWzEsIDIsIDMsIDRdO1xuICogICAgICB2YXIgdHJhbnNkdWNlciA9IFIuY29tcG9zZShSLm1hcChSLmFkZCgxKSksIFIudGFrZSgyKSk7XG4gKlxuICogICAgICBSLmludG8oW10sIHRyYW5zZHVjZXIsIG51bWJlcnMpOyAvLz0+IFsyLCAzXVxuICpcbiAqICAgICAgdmFyIGludG9BcnJheSA9IFIuaW50byhbXSk7XG4gKiAgICAgIGludG9BcnJheSh0cmFuc2R1Y2VyLCBudW1iZXJzKTsgLy89PiBbMiwgM11cbiAqL1xudmFyIGludG8gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBpbnRvKGFjYywgeGYsIGxpc3QpIHtcbiAgcmV0dXJuIF9pc1RyYW5zZm9ybWVyKGFjYykgPyBfcmVkdWNlKHhmKGFjYyksIGFjY1snQEB0cmFuc2R1Y2VyL2luaXQnXSgpLCBsaXN0KSA6IF9yZWR1Y2UoeGYoX3N0ZXBDYXQoYWNjKSksIF9jbG9uZShhY2MsIFtdLCBbXSwgZmFsc2UpLCBsaXN0KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgaW50bzsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IF9oYXMgZnJvbSAnLi9pbnRlcm5hbC9faGFzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cyc7XG5cbi8qKlxuICogU2FtZSBhcyBbYFIuaW52ZXJ0T2JqYF0oI2ludmVydE9iaiksIGhvd2V2ZXIgdGhpcyBhY2NvdW50cyBmb3Igb2JqZWN0cyB3aXRoXG4gKiBkdXBsaWNhdGUgdmFsdWVzIGJ5IHB1dHRpbmcgdGhlIHZhbHVlcyBpbnRvIGFuIGFycmF5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7czogeH0gLT4ge3g6IFsgcywgLi4uIF19XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gaW52ZXJ0XG4gKiBAcmV0dXJuIHtPYmplY3R9IG91dCBBIG5ldyBvYmplY3Qgd2l0aCBrZXlzIGluIGFuIGFycmF5LlxuICogQHNlZSBSLmludmVydE9ialxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciByYWNlUmVzdWx0c0J5Rmlyc3ROYW1lID0ge1xuICogICAgICAgIGZpcnN0OiAnYWxpY2UnLFxuICogICAgICAgIHNlY29uZDogJ2pha2UnLFxuICogICAgICAgIHRoaXJkOiAnYWxpY2UnLFxuICogICAgICB9O1xuICogICAgICBSLmludmVydChyYWNlUmVzdWx0c0J5Rmlyc3ROYW1lKTtcbiAqICAgICAgLy89PiB7ICdhbGljZSc6IFsnZmlyc3QnLCAndGhpcmQnXSwgJ2pha2UnOlsnc2Vjb25kJ10gfVxuICovXG52YXIgaW52ZXJ0ID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gaW52ZXJ0KG9iaikge1xuICB2YXIgcHJvcHMgPSBrZXlzKG9iaik7XG4gIHZhciBsZW4gPSBwcm9wcy5sZW5ndGg7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgb3V0ID0ge307XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpZHhdO1xuICAgIHZhciB2YWwgPSBvYmpba2V5XTtcbiAgICB2YXIgbGlzdCA9IF9oYXModmFsLCBvdXQpID8gb3V0W3ZhbF0gOiBvdXRbdmFsXSA9IFtdO1xuICAgIGxpc3RbbGlzdC5sZW5ndGhdID0ga2V5O1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBvdXQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGludmVydDsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBrZXlzIG9mIHRoZSBnaXZlbiBvYmplY3QgYXMgdmFsdWVzLCBhbmQgdGhlXG4gKiB2YWx1ZXMgb2YgdGhlIGdpdmVuIG9iamVjdCwgd2hpY2ggYXJlIGNvZXJjZWQgdG8gc3RyaW5ncywgYXMga2V5cy4gTm90ZVxuICogdGhhdCB0aGUgbGFzdCBrZXkgZm91bmQgaXMgcHJlZmVycmVkIHdoZW4gaGFuZGxpbmcgdGhlIHNhbWUgdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtzOiB4fSAtPiB7eDogc31cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCBvciBhcnJheSB0byBpbnZlcnRcbiAqIEByZXR1cm4ge09iamVjdH0gb3V0IEEgbmV3IG9iamVjdFxuICogQHNlZSBSLmludmVydFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciByYWNlUmVzdWx0cyA9IHtcbiAqICAgICAgICBmaXJzdDogJ2FsaWNlJyxcbiAqICAgICAgICBzZWNvbmQ6ICdqYWtlJ1xuICogICAgICB9O1xuICogICAgICBSLmludmVydE9iaihyYWNlUmVzdWx0cyk7XG4gKiAgICAgIC8vPT4geyAnYWxpY2UnOiAnZmlyc3QnLCAnamFrZSc6J3NlY29uZCcgfVxuICpcbiAqICAgICAgLy8gQWx0ZXJuYXRpdmVseTpcbiAqICAgICAgdmFyIHJhY2VSZXN1bHRzID0gWydhbGljZScsICdqYWtlJ107XG4gKiAgICAgIFIuaW52ZXJ0T2JqKHJhY2VSZXN1bHRzKTtcbiAqICAgICAgLy89PiB7ICdhbGljZSc6ICcwJywgJ2pha2UnOicxJyB9XG4gKi9cbnZhciBpbnZlcnRPYmogPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBpbnZlcnRPYmoob2JqKSB7XG4gIHZhciBwcm9wcyA9IGtleXMob2JqKTtcbiAgdmFyIGxlbiA9IHByb3BzLmxlbmd0aDtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBvdXQgPSB7fTtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2lkeF07XG4gICAgb3V0W29ialtrZXldXSA9IGtleTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gb3V0O1xufSk7XG5leHBvcnQgZGVmYXVsdCBpbnZlcnRPYmo7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfaXNGdW5jdGlvbiBmcm9tICcuL2ludGVybmFsL19pc0Z1bmN0aW9uJztcbmltcG9ydCBjdXJyeU4gZnJvbSAnLi9jdXJyeU4nO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcnO1xuXG4vKipcbiAqIFR1cm5zIGEgbmFtZWQgbWV0aG9kIHdpdGggYSBzcGVjaWZpZWQgYXJpdHkgaW50byBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlXG4gKiBjYWxsZWQgZGlyZWN0bHkgc3VwcGxpZWQgd2l0aCBhcmd1bWVudHMgYW5kIGEgdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gaXMgY3VycmllZCBhbmQgYWNjZXB0cyBgYXJpdHkgKyAxYCBwYXJhbWV0ZXJzIHdoZXJlXG4gKiB0aGUgZmluYWwgcGFyYW1ldGVyIGlzIHRoZSB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gKGEgLT4gYiAtPiAuLi4gLT4gbiAtPiBPYmplY3QgLT4gKilcbiAqIEBwYXJhbSB7TnVtYmVyfSBhcml0eSBOdW1iZXIgb2YgYXJndW1lbnRzIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBzaG91bGQgdGFrZVxuICogICAgICAgIGJlZm9yZSB0aGUgdGFyZ2V0IG9iamVjdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTmFtZSBvZiB0aGUgbWV0aG9kIHRvIGNhbGwuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAqIEBzZWUgUi5jb25zdHJ1Y3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgc2xpY2VGcm9tID0gUi5pbnZva2VyKDEsICdzbGljZScpO1xuICogICAgICBzbGljZUZyb20oNiwgJ2FiY2RlZmdoaWprbG0nKTsgLy89PiAnZ2hpamtsbSdcbiAqICAgICAgdmFyIHNsaWNlRnJvbTYgPSBSLmludm9rZXIoMiwgJ3NsaWNlJykoNik7XG4gKiAgICAgIHNsaWNlRnJvbTYoOCwgJ2FiY2RlZmdoaWprbG0nKTsgLy89PiAnZ2gnXG4gKiBAc3ltYiBSLmludm9rZXIoMCwgJ21ldGhvZCcpKG8pID0gb1snbWV0aG9kJ10oKVxuICogQHN5bWIgUi5pbnZva2VyKDEsICdtZXRob2QnKShhLCBvKSA9IG9bJ21ldGhvZCddKGEpXG4gKiBAc3ltYiBSLmludm9rZXIoMiwgJ21ldGhvZCcpKGEsIGIsIG8pID0gb1snbWV0aG9kJ10oYSwgYilcbiAqL1xudmFyIGludm9rZXIgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBpbnZva2VyKGFyaXR5LCBtZXRob2QpIHtcbiAgcmV0dXJuIGN1cnJ5Tihhcml0eSArIDEsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGFyZ2V0ID0gYXJndW1lbnRzW2FyaXR5XTtcbiAgICBpZiAodGFyZ2V0ICE9IG51bGwgJiYgX2lzRnVuY3Rpb24odGFyZ2V0W21ldGhvZF0pKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0W21ldGhvZF0uYXBwbHkodGFyZ2V0LCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIGFyaXR5KSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IodG9TdHJpbmcodGFyZ2V0KSArICcgZG9lcyBub3QgaGF2ZSBhIG1ldGhvZCBuYW1lZCBcIicgKyBtZXRob2QgKyAnXCInKTtcbiAgfSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGludm9rZXI7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBTZWUgaWYgYW4gb2JqZWN0IChgdmFsYCkgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHN1cHBsaWVkIGNvbnN0cnVjdG9yLiBUaGlzXG4gKiBmdW5jdGlvbiB3aWxsIGNoZWNrIHVwIHRoZSBpbmhlcml0YW5jZSBjaGFpbiwgaWYgYW55LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IFR5cGVcbiAqIEBzaWcgKCogLT4geyp9KSAtPiBhIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdG9yIEEgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaXMoT2JqZWN0LCB7fSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzKE51bWJlciwgMSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzKE9iamVjdCwgMSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5pcyhTdHJpbmcsICdzJyk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzKFN0cmluZywgbmV3IFN0cmluZygnJykpOyAvLz0+IHRydWVcbiAqICAgICAgUi5pcyhPYmplY3QsIG5ldyBTdHJpbmcoJycpKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaXMoT2JqZWN0LCAncycpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXMoTnVtYmVyLCB7fSk7IC8vPT4gZmFsc2VcbiAqL1xudmFyIGlzID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gaXMoQ3RvciwgdmFsKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbCAmJiB2YWwuY29uc3RydWN0b3IgPT09IEN0b3IgfHwgdmFsIGluc3RhbmNlb2YgQ3Rvcjtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgaXM7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBlbXB0eSBmcm9tICcuL2VtcHR5JztcbmltcG9ydCBlcXVhbHMgZnJvbSAnLi9lcXVhbHMnO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBpdHMgdHlwZSdzIGVtcHR5IHZhbHVlOyBgZmFsc2VgXG4gKiBvdGhlcndpc2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgYSAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IHhcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIuZW1wdHlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmlzRW1wdHkoWzEsIDIsIDNdKTsgICAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXNFbXB0eShbXSk7ICAgICAgICAgIC8vPT4gdHJ1ZVxuICogICAgICBSLmlzRW1wdHkoJycpOyAgICAgICAgICAvLz0+IHRydWVcbiAqICAgICAgUi5pc0VtcHR5KG51bGwpOyAgICAgICAgLy89PiBmYWxzZVxuICogICAgICBSLmlzRW1wdHkoe30pOyAgICAgICAgICAvLz0+IHRydWVcbiAqICAgICAgUi5pc0VtcHR5KHtsZW5ndGg6IDB9KTsgLy89PiBmYWxzZVxuICovXG52YXIgaXNFbXB0eSA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGlzRW1wdHkoeCkge1xuICByZXR1cm4geCAhPSBudWxsICYmIGVxdWFscyh4LCBlbXB0eSh4KSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGlzRW1wdHk7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAc2lnICogLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSB4IFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB4YCBpcyBgdW5kZWZpbmVkYCBvciBgbnVsbGAsIG90aGVyd2lzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaXNOaWwobnVsbCk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzTmlsKHVuZGVmaW5lZCk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzTmlsKDApOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXNOaWwoW10pOyAvLz0+IGZhbHNlXG4gKi9cbnZhciBpc05pbCA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGlzTmlsKHgpIHtcbiAgcmV0dXJuIHggPT0gbnVsbDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgaXNOaWw7IiwiaW1wb3J0IGludm9rZXIgZnJvbSAnLi9pbnZva2VyJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIG1hZGUgYnkgaW5zZXJ0aW5nIHRoZSBgc2VwYXJhdG9yYCBiZXR3ZWVuIGVhY2ggZWxlbWVudCBhbmRcbiAqIGNvbmNhdGVuYXRpbmcgYWxsIHRoZSBlbGVtZW50cyBpbnRvIGEgc2luZ2xlIHN0cmluZy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFN0cmluZyAtPiBbYV0gLT4gU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHNlcGFyYXRvciBUaGUgc3RyaW5nIHVzZWQgdG8gc2VwYXJhdGUgdGhlIGVsZW1lbnRzLlxuICogQHBhcmFtIHtBcnJheX0geHMgVGhlIGVsZW1lbnRzIHRvIGpvaW4gaW50byBhIHN0cmluZy5cbiAqIEByZXR1cm4ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgbWFkZSBieSBjb25jYXRlbmF0aW5nIGB4c2Agd2l0aCBgc2VwYXJhdG9yYC5cbiAqIEBzZWUgUi5zcGxpdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBzcGFjZXIgPSBSLmpvaW4oJyAnKTtcbiAqICAgICAgc3BhY2VyKFsnYScsIDIsIDMuNF0pOyAgIC8vPT4gJ2EgMiAzLjQnXG4gKiAgICAgIFIuam9pbignfCcsIFsxLCAyLCAzXSk7ICAgIC8vPT4gJzF8MnwzJ1xuICovXG52YXIgam9pbiA9IC8qI19fUFVSRV9fKi9pbnZva2VyKDEsICdqb2luJyk7XG5leHBvcnQgZGVmYXVsdCBqb2luOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgY29udmVyZ2UgZnJvbSAnLi9jb252ZXJnZSc7XG5cbi8qKlxuICoganV4dCBhcHBsaWVzIGEgbGlzdCBvZiBmdW5jdGlvbnMgdG8gYSBsaXN0IG9mIHZhbHVlcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgWyhhLCBiLCAuLi4sIG0pIC0+IG5dIC0+ICgoYSwgYiwgLi4uLCBtKSAtPiBbbl0pXG4gKiBAcGFyYW0ge0FycmF5fSBmbnMgQW4gYXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBsaXN0IG9mIHZhbHVlcyBhZnRlciBhcHBseWluZyBlYWNoIG9mIHRoZSBvcmlnaW5hbCBgZm5zYCB0byBpdHMgcGFyYW1ldGVycy5cbiAqIEBzZWUgUi5hcHBseVNwZWNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZ2V0UmFuZ2UgPSBSLmp1eHQoW01hdGgubWluLCBNYXRoLm1heF0pO1xuICogICAgICBnZXRSYW5nZSgzLCA0LCA5LCAtMyk7IC8vPT4gWy0zLCA5XVxuICogQHN5bWIgUi5qdXh0KFtmLCBnLCBoXSkoYSwgYikgPSBbZihhLCBiKSwgZyhhLCBiKSwgaChhLCBiKV1cbiAqL1xudmFyIGp1eHQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBqdXh0KGZucykge1xuICByZXR1cm4gY29udmVyZ2UoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICB9LCBmbnMpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBqdXh0OyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgX2hhcyBmcm9tICcuL2ludGVybmFsL19oYXMnO1xuaW1wb3J0IF9pc0FyZ3VtZW50cyBmcm9tICcuL2ludGVybmFsL19pc0FyZ3VtZW50cyc7XG5cbi8vIGNvdmVyIElFIDwgOSBrZXlzIGlzc3Vlc1xudmFyIGhhc0VudW1CdWcgPSAhIC8qI19fUFVSRV9fKi97IHRvU3RyaW5nOiBudWxsIH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG52YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWydjb25zdHJ1Y3RvcicsICd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAnaGFzT3duUHJvcGVydHknLCAndG9Mb2NhbGVTdHJpbmcnXTtcbi8vIFNhZmFyaSBidWdcbnZhciBoYXNBcmdzRW51bUJ1ZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICByZXR1cm4gYXJndW1lbnRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKCdsZW5ndGgnKTtcbn0oKTtcblxudmFyIGNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMobGlzdCwgaXRlbSkge1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgaWYgKGxpc3RbaWR4XSA9PT0gaXRlbSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIHRoZSBlbnVtZXJhYmxlIG93biBwcm9wZXJ0aWVzIG9mXG4gKiB0aGUgc3VwcGxpZWQgb2JqZWN0LlxuICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnRcbiAqIGFjcm9zcyBkaWZmZXJlbnQgSlMgcGxhdGZvcm1zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7azogdn0gLT4gW2tdXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gKiBAc2VlIFIua2V5c0luLCBSLnZhbHVlc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIua2V5cyh7YTogMSwgYjogMiwgYzogM30pOyAvLz0+IFsnYScsICdiJywgJ2MnXVxuICovXG52YXIgX2tleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgIWhhc0FyZ3NFbnVtQnVnID8gZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdChvYmopICE9PSBvYmogPyBbXSA6IE9iamVjdC5rZXlzKG9iaik7XG59IDogZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgaWYgKE9iamVjdChvYmopICE9PSBvYmopIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIHByb3AsIG5JZHg7XG4gIHZhciBrcyA9IFtdO1xuICB2YXIgY2hlY2tBcmdzTGVuZ3RoID0gaGFzQXJnc0VudW1CdWcgJiYgX2lzQXJndW1lbnRzKG9iaik7XG4gIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICBpZiAoX2hhcyhwcm9wLCBvYmopICYmICghY2hlY2tBcmdzTGVuZ3RoIHx8IHByb3AgIT09ICdsZW5ndGgnKSkge1xuICAgICAga3Nba3MubGVuZ3RoXSA9IHByb3A7XG4gICAgfVxuICB9XG4gIGlmIChoYXNFbnVtQnVnKSB7XG4gICAgbklkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChuSWR4ID49IDApIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbklkeF07XG4gICAgICBpZiAoX2hhcyhwcm9wLCBvYmopICYmICFjb250YWlucyhrcywgcHJvcCkpIHtcbiAgICAgICAga3Nba3MubGVuZ3RoXSA9IHByb3A7XG4gICAgICB9XG4gICAgICBuSWR4IC09IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBrcztcbn07XG52YXIga2V5cyA9IC8qI19fUFVSRV9fKi9fY3VycnkxKF9rZXlzKTtcbmV4cG9ydCBkZWZhdWx0IGtleXM7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHN1cHBsaWVkXG4gKiBvYmplY3QsIGluY2x1ZGluZyBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBjb25zaXN0ZW50XG4gKiBhY3Jvc3MgZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge2s6IHZ9IC0+IFtrXVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIG9iamVjdCdzIG93biBhbmQgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKiBAc2VlIFIua2V5cywgUi52YWx1ZXNJblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9ICdYJzsgfTtcbiAqICAgICAgRi5wcm90b3R5cGUueSA9ICdZJztcbiAqICAgICAgdmFyIGYgPSBuZXcgRigpO1xuICogICAgICBSLmtleXNJbihmKTsgLy89PiBbJ3gnLCAneSddXG4gKi9cbnZhciBrZXlzSW4gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBrZXlzSW4ob2JqKSB7XG4gIHZhciBwcm9wO1xuICB2YXIga3MgPSBbXTtcbiAgZm9yIChwcm9wIGluIG9iaikge1xuICAgIGtzW2tzLmxlbmd0aF0gPSBwcm9wO1xuICB9XG4gIHJldHVybiBrcztcbn0pO1xuZXhwb3J0IGRlZmF1bHQga2V5c0luOyIsImltcG9ydCBudGggZnJvbSAnLi9udGgnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS40XG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gYSB8IFVuZGVmaW5lZFxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIuaW5pdCwgUi5oZWFkLCBSLnRhaWxcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmxhc3QoWydmaScsICdmbycsICdmdW0nXSk7IC8vPT4gJ2Z1bSdcbiAqICAgICAgUi5sYXN0KFtdKTsgLy89PiB1bmRlZmluZWRcbiAqXG4gKiAgICAgIFIubGFzdCgnYWJjJyk7IC8vPT4gJ2MnXG4gKiAgICAgIFIubGFzdCgnJyk7IC8vPT4gJydcbiAqL1xudmFyIGxhc3QgPSAvKiNfX1BVUkVfXyovbnRoKC0xKTtcbmV4cG9ydCBkZWZhdWx0IGxhc3Q7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfaXNBcnJheSBmcm9tICcuL2ludGVybmFsL19pc0FycmF5JztcbmltcG9ydCBlcXVhbHMgZnJvbSAnLi9lcXVhbHMnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSwgb3IgLTEgaWZcbiAqIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuIFtgUi5lcXVhbHNgXSgjZXF1YWxzKSBpcyB1c2VkIHRvXG4gKiBkZXRlcm1pbmUgZXF1YWxpdHkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IFthXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSBpdGVtIHRvIGZpbmQuXG4gKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgYXJyYXkgdG8gc2VhcmNoIGluLlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIHRhcmdldCwgb3IgLTEgaWYgdGhlIHRhcmdldCBpcyBub3QgZm91bmQuXG4gKiBAc2VlIFIuaW5kZXhPZlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubGFzdEluZGV4T2YoMywgWy0xLDMsMywwLDEsMiwzLDRdKTsgLy89PiA2XG4gKiAgICAgIFIubGFzdEluZGV4T2YoMTAsIFsxLDIsMyw0XSk7IC8vPT4gLTFcbiAqL1xudmFyIGxhc3RJbmRleE9mID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gbGFzdEluZGV4T2YodGFyZ2V0LCB4cykge1xuICBpZiAodHlwZW9mIHhzLmxhc3RJbmRleE9mID09PSAnZnVuY3Rpb24nICYmICFfaXNBcnJheSh4cykpIHtcbiAgICByZXR1cm4geHMubGFzdEluZGV4T2YodGFyZ2V0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaWR4ID0geHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICAgIGlmIChlcXVhbHMoeHNbaWR4XSwgdGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgfVxuICAgICAgaWR4IC09IDE7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxufSk7XG5leHBvcnQgZGVmYXVsdCBsYXN0SW5kZXhPZjsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IF9pc051bWJlciBmcm9tICcuL2ludGVybmFsL19pc051bWJlcic7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheSBieSByZXR1cm5pbmcgYGxpc3QubGVuZ3RoYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubGVuZ3RoKFtdKTsgLy89PiAwXG4gKiAgICAgIFIubGVuZ3RoKFsxLCAyLCAzXSk7IC8vPT4gM1xuICovXG52YXIgbGVuZ3RoID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gbGVuZ3RoKGxpc3QpIHtcbiAgcmV0dXJuIGxpc3QgIT0gbnVsbCAmJiBfaXNOdW1iZXIobGlzdC5sZW5ndGgpID8gbGlzdC5sZW5ndGggOiBOYU47XG59KTtcbmV4cG9ydCBkZWZhdWx0IGxlbmd0aDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IG1hcCBmcm9tICcuL21hcCc7XG5cbi8qKlxuICogUmV0dXJucyBhIGxlbnMgZm9yIHRoZSBnaXZlbiBnZXR0ZXIgYW5kIHNldHRlciBmdW5jdGlvbnMuIFRoZSBnZXR0ZXIgXCJnZXRzXCJcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgZm9jdXM7IHRoZSBzZXR0ZXIgXCJzZXRzXCIgdGhlIHZhbHVlIG9mIHRoZSBmb2N1cy4gVGhlIHNldHRlclxuICogc2hvdWxkIG5vdCBtdXRhdGUgdGhlIGRhdGEgc3RydWN0dXJlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjguMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAqIEBzaWcgKHMgLT4gYSkgLT4gKChhLCBzKSAtPiBzKSAtPiBMZW5zIHMgYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXJcbiAqIEByZXR1cm4ge0xlbnN9XG4gKiBAc2VlIFIudmlldywgUi5zZXQsIFIub3ZlciwgUi5sZW5zSW5kZXgsIFIubGVuc1Byb3BcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgeExlbnMgPSBSLmxlbnMoUi5wcm9wKCd4JyksIFIuYXNzb2MoJ3gnKSk7XG4gKlxuICogICAgICBSLnZpZXcoeExlbnMsIHt4OiAxLCB5OiAyfSk7ICAgICAgICAgICAgLy89PiAxXG4gKiAgICAgIFIuc2V0KHhMZW5zLCA0LCB7eDogMSwgeTogMn0pOyAgICAgICAgICAvLz0+IHt4OiA0LCB5OiAyfVxuICogICAgICBSLm92ZXIoeExlbnMsIFIubmVnYXRlLCB7eDogMSwgeTogMn0pOyAgLy89PiB7eDogLTEsIHk6IDJ9XG4gKi9cbnZhciBsZW5zID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gbGVucyhnZXR0ZXIsIHNldHRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHRvRnVuY3RvckZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBtYXAoZnVuY3Rpb24gKGZvY3VzKSB7XG4gICAgICAgIHJldHVybiBzZXR0ZXIoZm9jdXMsIHRhcmdldCk7XG4gICAgICB9LCB0b0Z1bmN0b3JGbihnZXR0ZXIodGFyZ2V0KSkpO1xuICAgIH07XG4gIH07XG59KTtcbmV4cG9ydCBkZWZhdWx0IGxlbnM7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBsZW5zIGZyb20gJy4vbGVucyc7XG5pbXBvcnQgbnRoIGZyb20gJy4vbnRoJztcbmltcG9ydCB1cGRhdGUgZnJvbSAnLi91cGRhdGUnO1xuXG4vKipcbiAqIFJldHVybnMgYSBsZW5zIHdob3NlIGZvY3VzIGlzIHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAqIEBzaWcgTnVtYmVyIC0+IExlbnMgcyBhXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TGVuc31cbiAqIEBzZWUgUi52aWV3LCBSLnNldCwgUi5vdmVyXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGhlYWRMZW5zID0gUi5sZW5zSW5kZXgoMCk7XG4gKlxuICogICAgICBSLnZpZXcoaGVhZExlbnMsIFsnYScsICdiJywgJ2MnXSk7ICAgICAgICAgICAgLy89PiAnYSdcbiAqICAgICAgUi5zZXQoaGVhZExlbnMsICd4JywgWydhJywgJ2InLCAnYyddKTsgICAgICAgIC8vPT4gWyd4JywgJ2InLCAnYyddXG4gKiAgICAgIFIub3ZlcihoZWFkTGVucywgUi50b1VwcGVyLCBbJ2EnLCAnYicsICdjJ10pOyAvLz0+IFsnQScsICdiJywgJ2MnXVxuICovXG52YXIgbGVuc0luZGV4ID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gbGVuc0luZGV4KG4pIHtcbiAgcmV0dXJuIGxlbnMobnRoKG4pLCB1cGRhdGUobikpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBsZW5zSW5kZXg7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBhc3NvY1BhdGggZnJvbSAnLi9hc3NvY1BhdGgnO1xuaW1wb3J0IGxlbnMgZnJvbSAnLi9sZW5zJztcbmltcG9ydCBwYXRoIGZyb20gJy4vcGF0aCc7XG5cbi8qKlxuICogUmV0dXJucyBhIGxlbnMgd2hvc2UgZm9jdXMgaXMgdGhlIHNwZWNpZmllZCBwYXRoLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBJZHggPSBTdHJpbmcgfCBJbnRcbiAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gKiBAc2lnIFtJZHhdIC0+IExlbnMgcyBhXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIHVzZS5cbiAqIEByZXR1cm4ge0xlbnN9XG4gKiBAc2VlIFIudmlldywgUi5zZXQsIFIub3ZlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB4SGVhZFlMZW5zID0gUi5sZW5zUGF0aChbJ3gnLCAwLCAneSddKTtcbiAqXG4gKiAgICAgIFIudmlldyh4SGVhZFlMZW5zLCB7eDogW3t5OiAyLCB6OiAzfSwge3k6IDQsIHo6IDV9XX0pO1xuICogICAgICAvLz0+IDJcbiAqICAgICAgUi5zZXQoeEhlYWRZTGVucywgMSwge3g6IFt7eTogMiwgejogM30sIHt5OiA0LCB6OiA1fV19KTtcbiAqICAgICAgLy89PiB7eDogW3t5OiAxLCB6OiAzfSwge3k6IDQsIHo6IDV9XX1cbiAqICAgICAgUi5vdmVyKHhIZWFkWUxlbnMsIFIubmVnYXRlLCB7eDogW3t5OiAyLCB6OiAzfSwge3k6IDQsIHo6IDV9XX0pO1xuICogICAgICAvLz0+IHt4OiBbe3k6IC0yLCB6OiAzfSwge3k6IDQsIHo6IDV9XX1cbiAqL1xudmFyIGxlbnNQYXRoID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gbGVuc1BhdGgocCkge1xuICByZXR1cm4gbGVucyhwYXRoKHApLCBhc3NvY1BhdGgocCkpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBsZW5zUGF0aDsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IGFzc29jIGZyb20gJy4vYXNzb2MnO1xuaW1wb3J0IGxlbnMgZnJvbSAnLi9sZW5zJztcbmltcG9ydCBwcm9wIGZyb20gJy4vcHJvcCc7XG5cbi8qKlxuICogUmV0dXJucyBhIGxlbnMgd2hvc2UgZm9jdXMgaXMgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICogQHNpZyBTdHJpbmcgLT4gTGVucyBzIGFcbiAqIEBwYXJhbSB7U3RyaW5nfSBrXG4gKiBAcmV0dXJuIHtMZW5zfVxuICogQHNlZSBSLnZpZXcsIFIuc2V0LCBSLm92ZXJcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgeExlbnMgPSBSLmxlbnNQcm9wKCd4Jyk7XG4gKlxuICogICAgICBSLnZpZXcoeExlbnMsIHt4OiAxLCB5OiAyfSk7ICAgICAgICAgICAgLy89PiAxXG4gKiAgICAgIFIuc2V0KHhMZW5zLCA0LCB7eDogMSwgeTogMn0pOyAgICAgICAgICAvLz0+IHt4OiA0LCB5OiAyfVxuICogICAgICBSLm92ZXIoeExlbnMsIFIubmVnYXRlLCB7eDogMSwgeTogMn0pOyAgLy89PiB7eDogLTEsIHk6IDJ9XG4gKi9cbnZhciBsZW5zUHJvcCA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGxlbnNQcm9wKGspIHtcbiAgcmV0dXJuIGxlbnMocHJvcChrKSwgYXNzb2MoaykpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBsZW5zUHJvcDsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IGxpZnROIGZyb20gJy4vbGlmdE4nO1xuXG4vKipcbiAqIFwibGlmdHNcIiBhIGZ1bmN0aW9uIG9mIGFyaXR5ID4gMSBzbyB0aGF0IGl0IG1heSBcIm1hcCBvdmVyXCIgYSBsaXN0LCBGdW5jdGlvbiBvciBvdGhlclxuICogb2JqZWN0IHRoYXQgc2F0aXNmaWVzIHRoZSBbRmFudGFzeUxhbmQgQXBwbHkgc3BlY10oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhcHBseSkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNy4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCouLi4gLT4gKikgLT4gKFsqXS4uLiAtPiBbKl0pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbGlmdCBpbnRvIGhpZ2hlciBjb250ZXh0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGxpZnRlZCBmdW5jdGlvbi5cbiAqIEBzZWUgUi5saWZ0TlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBtYWRkMyA9IFIubGlmdCgoYSwgYiwgYykgPT4gYSArIGIgKyBjKTtcbiAqXG4gKiAgICAgIG1hZGQzKFsxLDIsM10sIFsxLDIsM10sIFsxXSk7IC8vPT4gWzMsIDQsIDUsIDQsIDUsIDYsIDUsIDYsIDddXG4gKlxuICogICAgICB2YXIgbWFkZDUgPSBSLmxpZnQoKGEsIGIsIGMsIGQsIGUpID0+IGEgKyBiICsgYyArIGQgKyBlKTtcbiAqXG4gKiAgICAgIG1hZGQ1KFsxLDJdLCBbM10sIFs0LCA1XSwgWzZdLCBbNywgOF0pOyAvLz0+IFsyMSwgMjIsIDIyLCAyMywgMjIsIDIzLCAyMywgMjRdXG4gKi9cbnZhciBsaWZ0ID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gbGlmdChmbikge1xuICByZXR1cm4gbGlmdE4oZm4ubGVuZ3RoLCBmbik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGxpZnQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfcmVkdWNlIGZyb20gJy4vaW50ZXJuYWwvX3JlZHVjZSc7XG5pbXBvcnQgYXAgZnJvbSAnLi9hcCc7XG5pbXBvcnQgY3VycnlOIGZyb20gJy4vY3VycnlOJztcbmltcG9ydCBtYXAgZnJvbSAnLi9tYXAnO1xuXG4vKipcbiAqIFwibGlmdHNcIiBhIGZ1bmN0aW9uIHRvIGJlIHRoZSBzcGVjaWZpZWQgYXJpdHksIHNvIHRoYXQgaXQgbWF5IFwibWFwIG92ZXJcIiB0aGF0XG4gKiBtYW55IGxpc3RzLCBGdW5jdGlvbnMgb3Igb3RoZXIgb2JqZWN0cyB0aGF0IHNhdGlzZnkgdGhlIFtGYW50YXN5TGFuZCBBcHBseSBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwcGx5KS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC43LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBOdW1iZXIgLT4gKCouLi4gLT4gKikgLT4gKFsqXS4uLiAtPiBbKl0pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbGlmdCBpbnRvIGhpZ2hlciBjb250ZXh0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGxpZnRlZCBmdW5jdGlvbi5cbiAqIEBzZWUgUi5saWZ0LCBSLmFwXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG1hZGQzID0gUi5saWZ0TigzLCAoLi4uYXJncykgPT4gUi5zdW0oYXJncykpO1xuICogICAgICBtYWRkMyhbMSwyLDNdLCBbMSwyLDNdLCBbMV0pOyAvLz0+IFszLCA0LCA1LCA0LCA1LCA2LCA1LCA2LCA3XVxuICovXG52YXIgbGlmdE4gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBsaWZ0Tihhcml0eSwgZm4pIHtcbiAgdmFyIGxpZnRlZCA9IGN1cnJ5Tihhcml0eSwgZm4pO1xuICByZXR1cm4gY3VycnlOKGFyaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9yZWR1Y2UoYXAsIG1hcChsaWZ0ZWQsIGFyZ3VtZW50c1swXSksIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbGlmdE47IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbGVzcyB0aGFuIHRoZSBzZWNvbmQ7IGBmYWxzZWBcbiAqIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIuZ3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmx0KDIsIDEpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIubHQoMiwgMik7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5sdCgyLCAzKTsgLy89PiB0cnVlXG4gKiAgICAgIFIubHQoJ2EnLCAneicpOyAvLz0+IHRydWVcbiAqICAgICAgUi5sdCgneicsICdhJyk7IC8vPT4gZmFsc2VcbiAqL1xudmFyIGx0ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gbHQoYSwgYikge1xuICByZXR1cm4gYSA8IGI7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGx0OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kO1xuICogYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gKiBAcGFyYW0ge051bWJlcn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5ndGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmx0ZSgyLCAxKTsgLy89PiBmYWxzZVxuICogICAgICBSLmx0ZSgyLCAyKTsgLy89PiB0cnVlXG4gKiAgICAgIFIubHRlKDIsIDMpOyAvLz0+IHRydWVcbiAqICAgICAgUi5sdGUoJ2EnLCAneicpOyAvLz0+IHRydWVcbiAqICAgICAgUi5sdGUoJ3onLCAnYScpOyAvLz0+IGZhbHNlXG4gKi9cbnZhciBsdGUgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBsdGUoYSwgYikge1xuICByZXR1cm4gYSA8PSBiO1xufSk7XG5leHBvcnQgZGVmYXVsdCBsdGU7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZSc7XG5pbXBvcnQgX21hcCBmcm9tICcuL2ludGVybmFsL19tYXAnO1xuaW1wb3J0IF9yZWR1Y2UgZnJvbSAnLi9pbnRlcm5hbC9fcmVkdWNlJztcbmltcG9ydCBfeG1hcCBmcm9tICcuL2ludGVybmFsL194bWFwJztcbmltcG9ydCBjdXJyeU4gZnJvbSAnLi9jdXJyeU4nO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzJztcblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGFuZFxuICogYSBbZnVuY3Rvcl0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNmdW5jdG9yKSxcbiAqIGFwcGxpZXMgdGhlIGZ1bmN0aW9uIHRvIGVhY2ggb2YgdGhlIGZ1bmN0b3IncyB2YWx1ZXMsIGFuZCByZXR1cm5zXG4gKiBhIGZ1bmN0b3Igb2YgdGhlIHNhbWUgc2hhcGUuXG4gKlxuICogUmFtZGEgcHJvdmlkZXMgc3VpdGFibGUgYG1hcGAgaW1wbGVtZW50YXRpb25zIGZvciBgQXJyYXlgIGFuZCBgT2JqZWN0YCxcbiAqIHNvIHRoaXMgZnVuY3Rpb24gbWF5IGJlIGFwcGxpZWQgdG8gYFsxLCAyLCAzXWAgb3IgYHt4OiAxLCB5OiAyLCB6OiAzfWAuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYG1hcGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEFsc28gdHJlYXRzIGZ1bmN0aW9ucyBhcyBmdW5jdG9ycyBhbmQgd2lsbCBjb21wb3NlIHRoZW0gdG9nZXRoZXIuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBGdW5jdG9yIGYgPT4gKGEgLT4gYikgLT4gZiBhIC0+IGYgYlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50IG9mIHRoZSBpbnB1dCBgbGlzdGAuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGJlIGl0ZXJhdGVkIG92ZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIG5ldyBsaXN0LlxuICogQHNlZSBSLnRyYW5zZHVjZSwgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBkb3VibGUgPSB4ID0+IHggKiAyO1xuICpcbiAqICAgICAgUi5tYXAoZG91YmxlLCBbMSwgMiwgM10pOyAvLz0+IFsyLCA0LCA2XVxuICpcbiAqICAgICAgUi5tYXAoZG91YmxlLCB7eDogMSwgeTogMiwgejogM30pOyAvLz0+IHt4OiAyLCB5OiA0LCB6OiA2fVxuICogQHN5bWIgUi5tYXAoZiwgW2EsIGJdKSA9IFtmKGEpLCBmKGIpXVxuICogQHN5bWIgUi5tYXAoZiwgeyB4OiBhLCB5OiBiIH0pID0geyB4OiBmKGEpLCB5OiBmKGIpIH1cbiAqIEBzeW1iIFIubWFwKGYsIGZ1bmN0b3JfbykgPSBmdW5jdG9yX28ubWFwKGYpXG4gKi9cbnZhciBtYXAgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoWydmYW50YXN5LWxhbmQvbWFwJywgJ21hcCddLCBfeG1hcCwgZnVuY3Rpb24gbWFwKGZuLCBmdW5jdG9yKSB7XG4gIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0b3IpKSB7XG4gICAgY2FzZSAnW29iamVjdCBGdW5jdGlvbl0nOlxuICAgICAgcmV0dXJuIGN1cnJ5TihmdW5jdG9yLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBmdW5jdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfSk7XG4gICAgY2FzZSAnW29iamVjdCBPYmplY3RdJzpcbiAgICAgIHJldHVybiBfcmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICBhY2Nba2V5XSA9IGZuKGZ1bmN0b3Jba2V5XSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSwga2V5cyhmdW5jdG9yKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBfbWFwKGZuLCBmdW5jdG9yKTtcbiAgfVxufSkpO1xuZXhwb3J0IGRlZmF1bHQgbWFwOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8qKlxuICogVGhlIGBtYXBBY2N1bWAgZnVuY3Rpb24gYmVoYXZlcyBsaWtlIGEgY29tYmluYXRpb24gb2YgbWFwIGFuZCByZWR1Y2U7IGl0XG4gKiBhcHBsaWVzIGEgZnVuY3Rpb24gdG8gZWFjaCBlbGVtZW50IG9mIGEgbGlzdCwgcGFzc2luZyBhbiBhY2N1bXVsYXRpbmdcbiAqIHBhcmFtZXRlciBmcm9tIGxlZnQgdG8gcmlnaHQsIGFuZCByZXR1cm5pbmcgYSBmaW5hbCB2YWx1ZSBvZiB0aGlzXG4gKiBhY2N1bXVsYXRvciB0b2dldGhlciB3aXRoIHRoZSBuZXcgbGlzdC5cbiAqXG4gKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIGFyZ3VtZW50cywgKmFjYyogYW5kICp2YWx1ZSosIGFuZCBzaG91bGRcbiAqIHJldHVybiBhIHR1cGxlICpbYWNjLCB2YWx1ZV0qLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYWNjLCB4KSAtPiAoYWNjLCB5KSkgLT4gYWNjIC0+IFt4XSAtPiAoYWNjLCBbeV0pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGlucHV0IGBsaXN0YC5cbiAqIEBwYXJhbSB7Kn0gYWNjIFRoZSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgUi5hZGRJbmRleCwgUi5tYXBBY2N1bVJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGRpZ2l0cyA9IFsnMScsICcyJywgJzMnLCAnNCddO1xuICogICAgICB2YXIgYXBwZW5kZXIgPSAoYSwgYikgPT4gW2EgKyBiLCBhICsgYl07XG4gKlxuICogICAgICBSLm1hcEFjY3VtKGFwcGVuZGVyLCAwLCBkaWdpdHMpOyAvLz0+IFsnMDEyMzQnLCBbJzAxJywgJzAxMicsICcwMTIzJywgJzAxMjM0J11dXG4gKiBAc3ltYiBSLm1hcEFjY3VtKGYsIGEsIFtiLCBjLCBkXSkgPSBbXG4gKiAgIGYoZihmKGEsIGIpWzBdLCBjKVswXSwgZClbMF0sXG4gKiAgIFtcbiAqICAgICBmKGEsIGIpWzFdLFxuICogICAgIGYoZihhLCBiKVswXSwgYylbMV0sXG4gKiAgICAgZihmKGYoYSwgYilbMF0sIGMpWzBdLCBkKVsxXVxuICogICBdXG4gKiBdXG4gKi9cbnZhciBtYXBBY2N1bSA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIG1hcEFjY3VtKGZuLCBhY2MsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgdHVwbGUgPSBbYWNjXTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHR1cGxlID0gZm4odHVwbGVbMF0sIGxpc3RbaWR4XSk7XG4gICAgcmVzdWx0W2lkeF0gPSB0dXBsZVsxXTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gW3R1cGxlWzBdLCByZXN1bHRdO1xufSk7XG5leHBvcnQgZGVmYXVsdCBtYXBBY2N1bTsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIFRoZSBgbWFwQWNjdW1SaWdodGAgZnVuY3Rpb24gYmVoYXZlcyBsaWtlIGEgY29tYmluYXRpb24gb2YgbWFwIGFuZCByZWR1Y2U7IGl0XG4gKiBhcHBsaWVzIGEgZnVuY3Rpb24gdG8gZWFjaCBlbGVtZW50IG9mIGEgbGlzdCwgcGFzc2luZyBhbiBhY2N1bXVsYXRpbmdcbiAqIHBhcmFtZXRlciBmcm9tIHJpZ2h0IHRvIGxlZnQsIGFuZCByZXR1cm5pbmcgYSBmaW5hbCB2YWx1ZSBvZiB0aGlzXG4gKiBhY2N1bXVsYXRvciB0b2dldGhlciB3aXRoIHRoZSBuZXcgbGlzdC5cbiAqXG4gKiBTaW1pbGFyIHRvIFtgbWFwQWNjdW1gXSgjbWFwQWNjdW0pLCBleGNlcHQgbW92ZXMgdGhyb3VnaCB0aGUgaW5wdXQgbGlzdCBmcm9tXG4gKiB0aGUgcmlnaHQgdG8gdGhlIGxlZnQuXG4gKlxuICogVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byBhcmd1bWVudHMsICp2YWx1ZSogYW5kICphY2MqLCBhbmQgc2hvdWxkXG4gKiByZXR1cm4gYSB0dXBsZSAqW3ZhbHVlLCBhY2NdKi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKHgsIGFjYykgLT4gKHksIGFjYykpIC0+IGFjYyAtPiBbeF0gLT4gKFt5XSwgYWNjKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50IG9mIHRoZSBpbnB1dCBgbGlzdGAuXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIFIuYWRkSW5kZXgsIFIubWFwQWNjdW1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZGlnaXRzID0gWycxJywgJzInLCAnMycsICc0J107XG4gKiAgICAgIHZhciBhcHBlbmQgPSAoYSwgYikgPT4gW2EgKyBiLCBhICsgYl07XG4gKlxuICogICAgICBSLm1hcEFjY3VtUmlnaHQoYXBwZW5kLCA1LCBkaWdpdHMpOyAvLz0+IFtbJzEyMzQ1JywgJzIzNDUnLCAnMzQ1JywgJzQ1J10sICcxMjM0NSddXG4gKiBAc3ltYiBSLm1hcEFjY3VtUmlnaHQoZiwgYSwgW2IsIGMsIGRdKSA9IFtcbiAqICAgW1xuICogICAgIGYoYiwgZihjLCBmKGQsIGEpWzBdKVswXSlbMV0sXG4gKiAgICAgZihjLCBmKGQsIGEpWzBdKVsxXSxcbiAqICAgICBmKGQsIGEpWzFdLFxuICogICBdXG4gKiAgIGYoYiwgZihjLCBmKGQsIGEpWzBdKVswXSlbMF0sXG4gKiBdXG4gKi9cbnZhciBtYXBBY2N1bVJpZ2h0ID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gbWFwQWNjdW1SaWdodChmbiwgYWNjLCBsaXN0KSB7XG4gIHZhciBpZHggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIHR1cGxlID0gW2FjY107XG4gIHdoaWxlIChpZHggPj0gMCkge1xuICAgIHR1cGxlID0gZm4obGlzdFtpZHhdLCB0dXBsZVswXSk7XG4gICAgcmVzdWx0W2lkeF0gPSB0dXBsZVsxXTtcbiAgICBpZHggLT0gMTtcbiAgfVxuICByZXR1cm4gW3Jlc3VsdCwgdHVwbGVbMF1dO1xufSk7XG5leHBvcnQgZGVmYXVsdCBtYXBBY2N1bVJpZ2h0OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX3JlZHVjZSBmcm9tICcuL2ludGVybmFsL19yZWR1Y2UnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzJztcblxuLyoqXG4gKiBBbiBPYmplY3Qtc3BlY2lmaWMgdmVyc2lvbiBvZiBbYG1hcGBdKCNtYXApLiBUaGUgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aHJlZVxuICogYXJndW1lbnRzOiAqKHZhbHVlLCBrZXksIG9iaikqLiBJZiBvbmx5IHRoZSB2YWx1ZSBpcyBzaWduaWZpY2FudCwgdXNlXG4gKiBbYG1hcGBdKCNtYXApIGluc3RlYWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgoKiwgU3RyaW5nLCBPYmplY3QpIC0+ICopIC0+IE9iamVjdCAtPiBPYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc2VlIFIubWFwXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHZhbHVlcyA9IHsgeDogMSwgeTogMiwgejogMyB9O1xuICogICAgICB2YXIgcHJlcGVuZEtleUFuZERvdWJsZSA9IChudW0sIGtleSwgb2JqKSA9PiBrZXkgKyAobnVtICogMik7XG4gKlxuICogICAgICBSLm1hcE9iakluZGV4ZWQocHJlcGVuZEtleUFuZERvdWJsZSwgdmFsdWVzKTsgLy89PiB7IHg6ICd4MicsIHk6ICd5NCcsIHo6ICd6NicgfVxuICovXG52YXIgbWFwT2JqSW5kZXhlZCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIG1hcE9iakluZGV4ZWQoZm4sIG9iaikge1xuICByZXR1cm4gX3JlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICBhY2Nba2V5XSA9IGZuKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30sIGtleXMob2JqKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1hcE9iakluZGV4ZWQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBUZXN0cyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhZ2FpbnN0IGEgU3RyaW5nLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsXG4gKiByZXR1cm4gYW4gZW1wdHkgYXJyYXkgd2hlbiB0aGVyZSBhcmUgbm8gbWF0Y2hlcy4gVGhpcyBkaWZmZXJzIGZyb21cbiAqIFtgU3RyaW5nLnByb3RvdHlwZS5tYXRjaGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9tYXRjaClcbiAqIHdoaWNoIHJldHVybnMgYG51bGxgIHdoZW4gdGhlcmUgYXJlIG5vIG1hdGNoZXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIFJlZ0V4cCAtPiBTdHJpbmcgLT4gW1N0cmluZyB8IFVuZGVmaW5lZF1cbiAqIEBwYXJhbSB7UmVnRXhwfSByeCBBIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBtYXRjaCBhZ2FpbnN0XG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgbWF0Y2hlcyBvciBlbXB0eSBhcnJheS5cbiAqIEBzZWUgUi50ZXN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tYXRjaCgvKFthLXpdYSkvZywgJ2JhbmFuYXMnKTsgLy89PiBbJ2JhJywgJ25hJywgJ25hJ11cbiAqICAgICAgUi5tYXRjaCgvYS8sICdiJyk7IC8vPT4gW11cbiAqICAgICAgUi5tYXRjaCgvYS8sIG51bGwpOyAvLz0+IFR5cGVFcnJvcjogbnVsbCBkb2VzIG5vdCBoYXZlIGEgbWV0aG9kIG5hbWVkIFwibWF0Y2hcIlxuICovXG52YXIgbWF0Y2ggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBtYXRjaChyeCwgc3RyKSB7XG4gIHJldHVybiBzdHIubWF0Y2gocngpIHx8IFtdO1xufSk7XG5leHBvcnQgZGVmYXVsdCBtYXRjaDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9pc0ludGVnZXIgZnJvbSAnLi9pbnRlcm5hbC9faXNJbnRlZ2VyJztcblxuLyoqXG4gKiBgbWF0aE1vZGAgYmVoYXZlcyBsaWtlIHRoZSBtb2R1bG8gb3BlcmF0b3Igc2hvdWxkIG1hdGhlbWF0aWNhbGx5LCB1bmxpa2UgdGhlXG4gKiBgJWAgb3BlcmF0b3IgKGFuZCBieSBleHRlbnNpb24sIFtgUi5tb2R1bG9gXSgjbW9kdWxvKSkuIFNvIHdoaWxlXG4gKiBgLTE3ICUgNWAgaXMgYC0yYCwgYG1hdGhNb2QoLTE3LCA1KWAgaXMgYDNgLiBgbWF0aE1vZGAgcmVxdWlyZXMgSW50ZWdlclxuICogYXJndW1lbnRzLCBhbmQgcmV0dXJucyBOYU4gd2hlbiB0aGUgbW9kdWx1cyBpcyB6ZXJvIG9yIG5lZ2F0aXZlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtIFRoZSBkaXZpZGVuZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwIHRoZSBtb2R1bHVzLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzdWx0IG9mIGBiIG1vZCBhYC5cbiAqIEBzZWUgUi5tb2R1bG9cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1hdGhNb2QoLTE3LCA1KTsgIC8vPT4gM1xuICogICAgICBSLm1hdGhNb2QoMTcsIDUpOyAgIC8vPT4gMlxuICogICAgICBSLm1hdGhNb2QoMTcsIC01KTsgIC8vPT4gTmFOXG4gKiAgICAgIFIubWF0aE1vZCgxNywgMCk7ICAgLy89PiBOYU5cbiAqICAgICAgUi5tYXRoTW9kKDE3LjIsIDUpOyAvLz0+IE5hTlxuICogICAgICBSLm1hdGhNb2QoMTcsIDUuMyk7IC8vPT4gTmFOXG4gKlxuICogICAgICB2YXIgY2xvY2sgPSBSLm1hdGhNb2QoUi5fXywgMTIpO1xuICogICAgICBjbG9jaygxNSk7IC8vPT4gM1xuICogICAgICBjbG9jaygyNCk7IC8vPT4gMFxuICpcbiAqICAgICAgdmFyIHNldmVudGVlbk1vZCA9IFIubWF0aE1vZCgxNyk7XG4gKiAgICAgIHNldmVudGVlbk1vZCgzKTsgIC8vPT4gMlxuICogICAgICBzZXZlbnRlZW5Nb2QoNCk7ICAvLz0+IDFcbiAqICAgICAgc2V2ZW50ZWVuTW9kKDEwKTsgLy89PiA3XG4gKi9cbnZhciBtYXRoTW9kID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gbWF0aE1vZChtLCBwKSB7XG4gIGlmICghX2lzSW50ZWdlcihtKSkge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgaWYgKCFfaXNJbnRlZ2VyKHApIHx8IHAgPCAxKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuICByZXR1cm4gKG0gJSBwICsgcCkgJSBwO1xufSk7XG5leHBvcnQgZGVmYXVsdCBtYXRoTW9kOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGFyZ2VyIG9mIGl0cyB0d28gYXJndW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBhXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5tYXhCeSwgUi5taW5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1heCg3ODksIDEyMyk7IC8vPT4gNzg5XG4gKiAgICAgIFIubWF4KCdhJywgJ2InKTsgLy89PiAnYidcbiAqL1xudmFyIG1heCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIG1heChhLCBiKSB7XG4gIHJldHVybiBiID4gYSA/IGIgOiBhO1xufSk7XG5leHBvcnQgZGVmYXVsdCBtYXg7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCB0d28gdmFsdWVzLCBhbmQgcmV0dXJucyB3aGljaGV2ZXIgdmFsdWUgcHJvZHVjZXMgdGhlXG4gKiBsYXJnZXIgcmVzdWx0IHdoZW4gcGFzc2VkIHRvIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYiA9PiAoYSAtPiBiKSAtPiBhIC0+IGEgLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIubWF4LCBSLm1pbkJ5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gIHNxdWFyZSA6OiBOdW1iZXIgLT4gTnVtYmVyXG4gKiAgICAgIHZhciBzcXVhcmUgPSBuID0+IG4gKiBuO1xuICpcbiAqICAgICAgUi5tYXhCeShzcXVhcmUsIC0zLCAyKTsgLy89PiAtM1xuICpcbiAqICAgICAgUi5yZWR1Y2UoUi5tYXhCeShzcXVhcmUpLCAwLCBbMywgLTUsIDQsIDEsIC0yXSk7IC8vPT4gLTVcbiAqICAgICAgUi5yZWR1Y2UoUi5tYXhCeShzcXVhcmUpLCAwLCBbXSk7IC8vPT4gMFxuICovXG52YXIgbWF4QnkgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBtYXhCeShmLCBhLCBiKSB7XG4gIHJldHVybiBmKGIpID4gZihhKSA/IGIgOiBhO1xufSk7XG5leHBvcnQgZGVmYXVsdCBtYXhCeTsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IHN1bSBmcm9tICcuL3N1bSc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWVhbiBvZiB0aGUgZ2l2ZW4gbGlzdCBvZiBudW1iZXJzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIFtOdW1iZXJdIC0+IE51bWJlclxuICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICogQHJldHVybiB7TnVtYmVyfVxuICogQHNlZSBSLm1lZGlhblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWVhbihbMiwgNywgOV0pOyAvLz0+IDZcbiAqICAgICAgUi5tZWFuKFtdKTsgLy89PiBOYU5cbiAqL1xudmFyIG1lYW4gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBtZWFuKGxpc3QpIHtcbiAgcmV0dXJuIHN1bShsaXN0KSAvIGxpc3QubGVuZ3RoO1xufSk7XG5leHBvcnQgZGVmYXVsdCBtZWFuOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgbWVhbiBmcm9tICcuL21lYW4nO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1lZGlhbiBvZiB0aGUgZ2l2ZW4gbGlzdCBvZiBudW1iZXJzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIFtOdW1iZXJdIC0+IE51bWJlclxuICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICogQHJldHVybiB7TnVtYmVyfVxuICogQHNlZSBSLm1lYW5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1lZGlhbihbMiwgOSwgN10pOyAvLz0+IDdcbiAqICAgICAgUi5tZWRpYW4oWzcsIDIsIDEwLCA5XSk7IC8vPT4gOFxuICogICAgICBSLm1lZGlhbihbXSk7IC8vPT4gTmFOXG4gKi9cbnZhciBtZWRpYW4gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBtZWRpYW4obGlzdCkge1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIHZhciB3aWR0aCA9IDIgLSBsZW4gJSAyO1xuICB2YXIgaWR4ID0gKGxlbiAtIHdpZHRoKSAvIDI7XG4gIHJldHVybiBtZWFuKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIDApLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gIH0pLnNsaWNlKGlkeCwgaWR4ICsgd2lkdGgpKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbWVkaWFuOyIsImltcG9ydCBtZW1vaXplV2l0aCBmcm9tICcuL21lbW9pemVXaXRoJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZ1bmN0aW9uIHRoYXQsIHdoZW4gaW52b2tlZCwgY2FjaGVzIHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZm5gXG4gKiBmb3IgYSBnaXZlbiBhcmd1bWVudCBzZXQgYW5kIHJldHVybnMgdGhlIHJlc3VsdC4gU3Vic2VxdWVudCBjYWxscyB0byB0aGVcbiAqIG1lbW9pemVkIGBmbmAgd2l0aCB0aGUgc2FtZSBhcmd1bWVudCBzZXQgd2lsbCBub3QgcmVzdWx0IGluIGFuIGFkZGl0aW9uYWxcbiAqIGNhbGwgdG8gYGZuYDsgaW5zdGVhZCwgdGhlIGNhY2hlZCByZXN1bHQgZm9yIHRoYXQgc2V0IG9mIGFyZ3VtZW50cyB3aWxsIGJlXG4gKiByZXR1cm5lZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKi4uLiAtPiBhKSAtPiAoKi4uLiAtPiBhKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1lbW9pemUuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gTWVtb2l6ZWQgdmVyc2lvbiBvZiBgZm5gLlxuICogQHNlZSBSLm1lbW9pemVXaXRoXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2MC4yNS4wXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgbGV0IGNvdW50ID0gMDtcbiAqICAgICAgY29uc3QgZmFjdG9yaWFsID0gUi5tZW1vaXplKG4gPT4ge1xuICogICAgICAgIGNvdW50ICs9IDE7XG4gKiAgICAgICAgcmV0dXJuIFIucHJvZHVjdChSLnJhbmdlKDEsIG4gKyAxKSk7XG4gKiAgICAgIH0pO1xuICogICAgICBmYWN0b3JpYWwoNSk7IC8vPT4gMTIwXG4gKiAgICAgIGZhY3RvcmlhbCg1KTsgLy89PiAxMjBcbiAqICAgICAgZmFjdG9yaWFsKDUpOyAvLz0+IDEyMFxuICogICAgICBjb3VudDsgLy89PiAxXG4gKi9cbnZhciBtZW1vaXplID0gLyojX19QVVJFX18qL21lbW9pemVXaXRoKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRvU3RyaW5nKGFyZ3VtZW50cyk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1lbW9pemU7IiwiaW1wb3J0IF9hcml0eSBmcm9tICcuL2ludGVybmFsL19hcml0eSc7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9oYXMgZnJvbSAnLi9pbnRlcm5hbC9faGFzJztcblxuLyoqXG4gKiBBIGN1c3RvbWlzYWJsZSB2ZXJzaW9uIG9mIFtgUi5tZW1vaXplYF0oI21lbW9pemUpLiBgbWVtb2l6ZVdpdGhgIHRha2VzIGFuXG4gKiBhZGRpdGlvbmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZ2l2ZW4gYXJndW1lbnQgc2V0IGFuZCB1c2VkIHRvXG4gKiBjcmVhdGUgdGhlIGNhY2hlIGtleSB1bmRlciB3aGljaCB0aGUgcmVzdWx0cyBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgbWVtb2l6ZWRcbiAqIHdpbGwgYmUgc3RvcmVkLiBDYXJlIG11c3QgYmUgdGFrZW4gd2hlbiBpbXBsZW1lbnRpbmcga2V5IGdlbmVyYXRpb24gdG8gYXZvaWRcbiAqIGNsYXNoZXMgdGhhdCBtYXkgb3ZlcndyaXRlIHByZXZpb3VzIGVudHJpZXMgZXJyb25lb3VzbHkuXG4gKlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI0LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKi4uLiAtPiBTdHJpbmcpIC0+ICgqLi4uIC0+IGEpIC0+ICgqLi4uIC0+IGEpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGNhY2hlIGtleS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtZW1vaXplLlxuICogQHJldHVybiB7RnVuY3Rpb259IE1lbW9pemVkIHZlcnNpb24gb2YgYGZuYC5cbiAqIEBzZWUgUi5tZW1vaXplXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgbGV0IGNvdW50ID0gMDtcbiAqICAgICAgY29uc3QgZmFjdG9yaWFsID0gUi5tZW1vaXplV2l0aChSLmlkZW50aXR5LCBuID0+IHtcbiAqICAgICAgICBjb3VudCArPSAxO1xuICogICAgICAgIHJldHVybiBSLnByb2R1Y3QoUi5yYW5nZSgxLCBuICsgMSkpO1xuICogICAgICB9KTtcbiAqICAgICAgZmFjdG9yaWFsKDUpOyAvLz0+IDEyMFxuICogICAgICBmYWN0b3JpYWwoNSk7IC8vPT4gMTIwXG4gKiAgICAgIGZhY3RvcmlhbCg1KTsgLy89PiAxMjBcbiAqICAgICAgY291bnQ7IC8vPT4gMVxuICovXG52YXIgbWVtb2l6ZVdpdGggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBtZW1vaXplV2l0aChtRm4sIGZuKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gX2FyaXR5KGZuLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBrZXkgPSBtRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoIV9oYXMoa2V5LCBjYWNoZSkpIHtcbiAgICAgIGNhY2hlW2tleV0gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVba2V5XTtcbiAgfSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1lbW9pemVXaXRoOyIsImltcG9ydCBfYXNzaWduIGZyb20gJy4vaW50ZXJuYWwvX2Fzc2lnbic7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIGZpcnN0IG9iamVjdCBtZXJnZWQgd2l0aFxuICogdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBzZWNvbmQgb2JqZWN0LiBJZiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLFxuICogdGhlIHZhbHVlIGZyb20gdGhlIHNlY29uZCBvYmplY3Qgd2lsbCBiZSB1c2VkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7azogdn0gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtPYmplY3R9IGxcbiAqIEBwYXJhbSB7T2JqZWN0fSByXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc2VlIFIubWVyZ2VEZWVwUmlnaHQsIFIubWVyZ2VXaXRoLCBSLm1lcmdlV2l0aEtleVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWVyZ2UoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDEwIH0sIHsgJ2FnZSc6IDQwIH0pO1xuICogICAgICAvLz0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9XG4gKlxuICogICAgICB2YXIgcmVzZXRUb0RlZmF1bHQgPSBSLm1lcmdlKFIuX18sIHt4OiAwfSk7XG4gKiAgICAgIHJlc2V0VG9EZWZhdWx0KHt4OiA1LCB5OiAyfSk7IC8vPT4ge3g6IDAsIHk6IDJ9XG4gKiBAc3ltYiBSLm1lcmdlKHsgeDogMSwgeTogMiB9LCB7IHk6IDUsIHo6IDMgfSkgPSB7IHg6IDEsIHk6IDUsIHo6IDMgfVxuICovXG52YXIgbWVyZ2UgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBtZXJnZShsLCByKSB7XG4gIHJldHVybiBfYXNzaWduKHt9LCBsLCByKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbWVyZ2U7IiwiaW1wb3J0IF9hc3NpZ24gZnJvbSAnLi9pbnRlcm5hbC9fYXNzaWduJztcbmltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5cbi8qKlxuICogTWVyZ2VzIGEgbGlzdCBvZiBvYmplY3RzIHRvZ2V0aGVyIGludG8gb25lIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbe2s6IHZ9XSAtPiB7azogdn1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgQW4gYXJyYXkgb2Ygb2JqZWN0c1xuICogQHJldHVybiB7T2JqZWN0fSBBIG1lcmdlZCBvYmplY3QuXG4gKiBAc2VlIFIucmVkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tZXJnZUFsbChbe2ZvbzoxfSx7YmFyOjJ9LHtiYXo6M31dKTsgLy89PiB7Zm9vOjEsYmFyOjIsYmF6OjN9XG4gKiAgICAgIFIubWVyZ2VBbGwoW3tmb286MX0se2ZvbzoyfSx7YmFyOjJ9XSk7IC8vPT4ge2ZvbzoyLGJhcjoyfVxuICogQHN5bWIgUi5tZXJnZUFsbChbeyB4OiAxIH0sIHsgeTogMiB9LCB7IHo6IDMgfV0pID0geyB4OiAxLCB5OiAyLCB6OiAzIH1cbiAqL1xudmFyIG1lcmdlQWxsID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gbWVyZ2VBbGwobGlzdCkge1xuICByZXR1cm4gX2Fzc2lnbi5hcHBseShudWxsLCBbe31dLmNvbmNhdChsaXN0KSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1lcmdlQWxsOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgbWVyZ2VEZWVwV2l0aEtleSBmcm9tICcuL21lcmdlRGVlcFdpdGhLZXknO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBmaXJzdCBvYmplY3QgbWVyZ2VkIHdpdGhcbiAqIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgc2Vjb25kIG9iamVjdC4gSWYgYSBrZXkgZXhpc3RzIGluIGJvdGggb2JqZWN0czpcbiAqIC0gYW5kIGJvdGggdmFsdWVzIGFyZSBvYmplY3RzLCB0aGUgdHdvIHZhbHVlcyB3aWxsIGJlIHJlY3Vyc2l2ZWx5IG1lcmdlZFxuICogLSBvdGhlcndpc2UgdGhlIHZhbHVlIGZyb20gdGhlIGZpcnN0IG9iamVjdCB3aWxsIGJlIHVzZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7YX0gLT4ge2F9IC0+IHthfVxuICogQHBhcmFtIHtPYmplY3R9IGxPYmpcbiAqIEBwYXJhbSB7T2JqZWN0fSByT2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc2VlIFIubWVyZ2UsIFIubWVyZ2VEZWVwUmlnaHQsIFIubWVyZ2VEZWVwV2l0aCwgUi5tZXJnZURlZXBXaXRoS2V5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tZXJnZURlZXBMZWZ0KHsgbmFtZTogJ2ZyZWQnLCBhZ2U6IDEwLCBjb250YWN0OiB7IGVtYWlsOiAnbW9vQGV4YW1wbGUuY29tJyB9fSxcbiAqICAgICAgICAgICAgICAgICAgICAgIHsgYWdlOiA0MCwgY29udGFjdDogeyBlbWFpbDogJ2JhYUBleGFtcGxlLmNvbScgfX0pO1xuICogICAgICAvLz0+IHsgbmFtZTogJ2ZyZWQnLCBhZ2U6IDEwLCBjb250YWN0OiB7IGVtYWlsOiAnbW9vQGV4YW1wbGUuY29tJyB9fVxuICovXG52YXIgbWVyZ2VEZWVwTGVmdCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIG1lcmdlRGVlcExlZnQobE9iaiwgck9iaikge1xuICByZXR1cm4gbWVyZ2VEZWVwV2l0aEtleShmdW5jdGlvbiAoaywgbFZhbCwgclZhbCkge1xuICAgIHJldHVybiBsVmFsO1xuICB9LCBsT2JqLCByT2JqKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbWVyZ2VEZWVwTGVmdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IG1lcmdlRGVlcFdpdGhLZXkgZnJvbSAnLi9tZXJnZURlZXBXaXRoS2V5JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgZmlyc3Qgb2JqZWN0IG1lcmdlZCB3aXRoXG4gKiB0aGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIHNlY29uZCBvYmplY3QuIElmIGEga2V5IGV4aXN0cyBpbiBib3RoIG9iamVjdHM6XG4gKiAtIGFuZCBib3RoIHZhbHVlcyBhcmUgb2JqZWN0cywgdGhlIHR3byB2YWx1ZXMgd2lsbCBiZSByZWN1cnNpdmVseSBtZXJnZWRcbiAqIC0gb3RoZXJ3aXNlIHRoZSB2YWx1ZSBmcm9tIHRoZSBzZWNvbmQgb2JqZWN0IHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHthfSAtPiB7YX0gLT4ge2F9XG4gKiBAcGFyYW0ge09iamVjdH0gbE9ialxuICogQHBhcmFtIHtPYmplY3R9IHJPYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgUi5tZXJnZSwgUi5tZXJnZURlZXBMZWZ0LCBSLm1lcmdlRGVlcFdpdGgsIFIubWVyZ2VEZWVwV2l0aEtleVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWVyZ2VEZWVwUmlnaHQoeyBuYW1lOiAnZnJlZCcsIGFnZTogMTAsIGNvbnRhY3Q6IHsgZW1haWw6ICdtb29AZXhhbXBsZS5jb20nIH19LFxuICogICAgICAgICAgICAgICAgICAgICAgIHsgYWdlOiA0MCwgY29udGFjdDogeyBlbWFpbDogJ2JhYUBleGFtcGxlLmNvbScgfX0pO1xuICogICAgICAvLz0+IHsgbmFtZTogJ2ZyZWQnLCBhZ2U6IDQwLCBjb250YWN0OiB7IGVtYWlsOiAnYmFhQGV4YW1wbGUuY29tJyB9fVxuICovXG52YXIgbWVyZ2VEZWVwUmlnaHQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBtZXJnZURlZXBSaWdodChsT2JqLCByT2JqKSB7XG4gIHJldHVybiBtZXJnZURlZXBXaXRoS2V5KGZ1bmN0aW9uIChrLCBsVmFsLCByVmFsKSB7XG4gICAgcmV0dXJuIHJWYWw7XG4gIH0sIGxPYmosIHJPYmopO1xufSk7XG5leHBvcnQgZGVmYXVsdCBtZXJnZURlZXBSaWdodDsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuaW1wb3J0IG1lcmdlRGVlcFdpdGhLZXkgZnJvbSAnLi9tZXJnZURlZXBXaXRoS2V5JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgdHdvIHByb3ZpZGVkIG9iamVjdHMuXG4gKiBJZiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzOlxuICogLSBhbmQgYm90aCBhc3NvY2lhdGVkIHZhbHVlcyBhcmUgYWxzbyBvYmplY3RzIHRoZW4gdGhlIHZhbHVlcyB3aWxsIGJlXG4gKiAgIHJlY3Vyc2l2ZWx5IG1lcmdlZC5cbiAqIC0gb3RoZXJ3aXNlIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIGFzc29jaWF0ZWQgdmFsdWVzIHVzaW5nIHRoZVxuICogICByZXN1bHRpbmcgdmFsdWUgYXMgdGhlIG5ldyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleS5cbiAqIElmIGEga2V5IG9ubHkgZXhpc3RzIGluIG9uZSBvYmplY3QsIHRoZSB2YWx1ZSB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5XG4gKiBvZiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgoYSwgYSkgLT4gYSkgLT4ge2F9IC0+IHthfSAtPiB7YX1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gbE9ialxuICogQHBhcmFtIHtPYmplY3R9IHJPYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgUi5tZXJnZVdpdGgsIFIubWVyZ2VEZWVwLCBSLm1lcmdlRGVlcFdpdGhLZXlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1lcmdlRGVlcFdpdGgoUi5jb25jYXQsXG4gKiAgICAgICAgICAgICAgICAgICAgICB7IGE6IHRydWUsIGM6IHsgdmFsdWVzOiBbMTAsIDIwXSB9fSxcbiAqICAgICAgICAgICAgICAgICAgICAgIHsgYjogdHJ1ZSwgYzogeyB2YWx1ZXM6IFsxNSwgMzVdIH19KTtcbiAqICAgICAgLy89PiB7IGE6IHRydWUsIGI6IHRydWUsIGM6IHsgdmFsdWVzOiBbMTAsIDIwLCAxNSwgMzVdIH19XG4gKi9cbnZhciBtZXJnZURlZXBXaXRoID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gbWVyZ2VEZWVwV2l0aChmbiwgbE9iaiwgck9iaikge1xuICByZXR1cm4gbWVyZ2VEZWVwV2l0aEtleShmdW5jdGlvbiAoaywgbFZhbCwgclZhbCkge1xuICAgIHJldHVybiBmbihsVmFsLCByVmFsKTtcbiAgfSwgbE9iaiwgck9iaik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1lcmdlRGVlcFdpdGg7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcbmltcG9ydCBfaXNPYmplY3QgZnJvbSAnLi9pbnRlcm5hbC9faXNPYmplY3QnO1xuaW1wb3J0IG1lcmdlV2l0aEtleSBmcm9tICcuL21lcmdlV2l0aEtleSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIHR3byBwcm92aWRlZCBvYmplY3RzLlxuICogSWYgYSBrZXkgZXhpc3RzIGluIGJvdGggb2JqZWN0czpcbiAqIC0gYW5kIGJvdGggYXNzb2NpYXRlZCB2YWx1ZXMgYXJlIGFsc28gb2JqZWN0cyB0aGVuIHRoZSB2YWx1ZXMgd2lsbCBiZVxuICogICByZWN1cnNpdmVseSBtZXJnZWQuXG4gKiAtIG90aGVyd2lzZSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aGUga2V5IGFuZCBhc3NvY2lhdGVkIHZhbHVlc1xuICogICB1c2luZyB0aGUgcmVzdWx0aW5nIHZhbHVlIGFzIHRoZSBuZXcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkuXG4gKiBJZiBhIGtleSBvbmx5IGV4aXN0cyBpbiBvbmUgb2JqZWN0LCB0aGUgdmFsdWUgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleVxuICogb2YgdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyAoKFN0cmluZywgYSwgYSkgLT4gYSkgLT4ge2F9IC0+IHthfSAtPiB7YX1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gbE9ialxuICogQHBhcmFtIHtPYmplY3R9IHJPYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgUi5tZXJnZVdpdGhLZXksIFIubWVyZ2VEZWVwLCBSLm1lcmdlRGVlcFdpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBsZXQgY29uY2F0VmFsdWVzID0gKGssIGwsIHIpID0+IGsgPT0gJ3ZhbHVlcycgPyBSLmNvbmNhdChsLCByKSA6IHJcbiAqICAgICAgUi5tZXJnZURlZXBXaXRoS2V5KGNvbmNhdFZhbHVlcyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHsgYTogdHJ1ZSwgYzogeyB0aGluZzogJ2ZvbycsIHZhbHVlczogWzEwLCAyMF0gfX0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICB7IGI6IHRydWUsIGM6IHsgdGhpbmc6ICdiYXInLCB2YWx1ZXM6IFsxNSwgMzVdIH19KTtcbiAqICAgICAgLy89PiB7IGE6IHRydWUsIGI6IHRydWUsIGM6IHsgdGhpbmc6ICdiYXInLCB2YWx1ZXM6IFsxMCwgMjAsIDE1LCAzNV0gfX1cbiAqL1xudmFyIG1lcmdlRGVlcFdpdGhLZXkgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBtZXJnZURlZXBXaXRoS2V5KGZuLCBsT2JqLCByT2JqKSB7XG4gIHJldHVybiBtZXJnZVdpdGhLZXkoZnVuY3Rpb24gKGssIGxWYWwsIHJWYWwpIHtcbiAgICBpZiAoX2lzT2JqZWN0KGxWYWwpICYmIF9pc09iamVjdChyVmFsKSkge1xuICAgICAgcmV0dXJuIG1lcmdlRGVlcFdpdGhLZXkoZm4sIGxWYWwsIHJWYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZm4oaywgbFZhbCwgclZhbCk7XG4gICAgfVxuICB9LCBsT2JqLCByT2JqKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbWVyZ2VEZWVwV2l0aEtleTsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuaW1wb3J0IG1lcmdlV2l0aEtleSBmcm9tICcuL21lcmdlV2l0aEtleSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIHR3byBwcm92aWRlZCBvYmplY3RzLiBJZlxuICogYSBrZXkgZXhpc3RzIGluIGJvdGggb2JqZWN0cywgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGlzIGFwcGxpZWQgdG8gdGhlIHZhbHVlc1xuICogYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkgaW4gZWFjaCBvYmplY3QsIHdpdGggdGhlIHJlc3VsdCBiZWluZyB1c2VkIGFzIHRoZVxuICogdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkgaW4gdGhlIHJldHVybmVkIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgoYSwgYSkgLT4gYSkgLT4ge2F9IC0+IHthfSAtPiB7YX1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gbFxuICogQHBhcmFtIHtPYmplY3R9IHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgUi5tZXJnZURlZXBXaXRoLCBSLm1lcmdlLCBSLm1lcmdlV2l0aEtleVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWVyZ2VXaXRoKFIuY29uY2F0LFxuICogICAgICAgICAgICAgICAgICB7IGE6IHRydWUsIHZhbHVlczogWzEwLCAyMF0gfSxcbiAqICAgICAgICAgICAgICAgICAgeyBiOiB0cnVlLCB2YWx1ZXM6IFsxNSwgMzVdIH0pO1xuICogICAgICAvLz0+IHsgYTogdHJ1ZSwgYjogdHJ1ZSwgdmFsdWVzOiBbMTAsIDIwLCAxNSwgMzVdIH1cbiAqL1xudmFyIG1lcmdlV2l0aCA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIG1lcmdlV2l0aChmbiwgbCwgcikge1xuICByZXR1cm4gbWVyZ2VXaXRoS2V5KGZ1bmN0aW9uIChfLCBfbCwgX3IpIHtcbiAgICByZXR1cm4gZm4oX2wsIF9yKTtcbiAgfSwgbCwgcik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1lcmdlV2l0aDsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuaW1wb3J0IF9oYXMgZnJvbSAnLi9pbnRlcm5hbC9faGFzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgdHdvIHByb3ZpZGVkIG9iamVjdHMuIElmXG4gKiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aGUga2V5XG4gKiBhbmQgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSBpbiBlYWNoIG9iamVjdCwgd2l0aCB0aGUgcmVzdWx0IGJlaW5nXG4gKiB1c2VkIGFzIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSBpbiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgKChTdHJpbmcsIGEsIGEpIC0+IGEpIC0+IHthfSAtPiB7YX0gLT4ge2F9XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGxcbiAqIEBwYXJhbSB7T2JqZWN0fSByXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc2VlIFIubWVyZ2VEZWVwV2l0aEtleSwgUi5tZXJnZSwgUi5tZXJnZVdpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBsZXQgY29uY2F0VmFsdWVzID0gKGssIGwsIHIpID0+IGsgPT0gJ3ZhbHVlcycgPyBSLmNvbmNhdChsLCByKSA6IHJcbiAqICAgICAgUi5tZXJnZVdpdGhLZXkoY29uY2F0VmFsdWVzLFxuICogICAgICAgICAgICAgICAgICAgICB7IGE6IHRydWUsIHRoaW5nOiAnZm9vJywgdmFsdWVzOiBbMTAsIDIwXSB9LFxuICogICAgICAgICAgICAgICAgICAgICB7IGI6IHRydWUsIHRoaW5nOiAnYmFyJywgdmFsdWVzOiBbMTUsIDM1XSB9KTtcbiAqICAgICAgLy89PiB7IGE6IHRydWUsIGI6IHRydWUsIHRoaW5nOiAnYmFyJywgdmFsdWVzOiBbMTAsIDIwLCAxNSwgMzVdIH1cbiAqIEBzeW1iIFIubWVyZ2VXaXRoS2V5KGYsIHsgeDogMSwgeTogMiB9LCB7IHk6IDUsIHo6IDMgfSkgPSB7IHg6IDEsIHk6IGYoJ3knLCAyLCA1KSwgejogMyB9XG4gKi9cbnZhciBtZXJnZVdpdGhLZXkgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBtZXJnZVdpdGhLZXkoZm4sIGwsIHIpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgaztcblxuICBmb3IgKGsgaW4gbCkge1xuICAgIGlmIChfaGFzKGssIGwpKSB7XG4gICAgICByZXN1bHRba10gPSBfaGFzKGssIHIpID8gZm4oaywgbFtrXSwgcltrXSkgOiBsW2tdO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoayBpbiByKSB7XG4gICAgaWYgKF9oYXMoaywgcikgJiYgIV9oYXMoaywgcmVzdWx0KSkge1xuICAgICAgcmVzdWx0W2tdID0gcltrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5leHBvcnQgZGVmYXVsdCBtZXJnZVdpdGhLZXk7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzbWFsbGVyIG9mIGl0cyB0d28gYXJndW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBhXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5taW5CeSwgUi5tYXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1pbig3ODksIDEyMyk7IC8vPT4gMTIzXG4gKiAgICAgIFIubWluKCdhJywgJ2InKTsgLy89PiAnYSdcbiAqL1xudmFyIG1pbiA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIG1pbihhLCBiKSB7XG4gIHJldHVybiBiIDwgYSA/IGIgOiBhO1xufSk7XG5leHBvcnQgZGVmYXVsdCBtaW47IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCB0d28gdmFsdWVzLCBhbmQgcmV0dXJucyB3aGljaGV2ZXIgdmFsdWUgcHJvZHVjZXMgdGhlXG4gKiBzbWFsbGVyIHJlc3VsdCB3aGVuIHBhc3NlZCB0byB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGIgPT4gKGEgLT4gYikgLT4gYSAtPiBhIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLm1pbiwgUi5tYXhCeVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIC8vICBzcXVhcmUgOjogTnVtYmVyIC0+IE51bWJlclxuICogICAgICB2YXIgc3F1YXJlID0gbiA9PiBuICogbjtcbiAqXG4gKiAgICAgIFIubWluQnkoc3F1YXJlLCAtMywgMik7IC8vPT4gMlxuICpcbiAqICAgICAgUi5yZWR1Y2UoUi5taW5CeShzcXVhcmUpLCBJbmZpbml0eSwgWzMsIC01LCA0LCAxLCAtMl0pOyAvLz0+IDFcbiAqICAgICAgUi5yZWR1Y2UoUi5taW5CeShzcXVhcmUpLCBJbmZpbml0eSwgW10pOyAvLz0+IEluZmluaXR5XG4gKi9cbnZhciBtaW5CeSA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIG1pbkJ5KGYsIGEsIGIpIHtcbiAgcmV0dXJuIGYoYikgPCBmKGEpID8gYiA6IGE7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1pbkJ5OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogRGl2aWRlcyB0aGUgZmlyc3QgcGFyYW1ldGVyIGJ5IHRoZSBzZWNvbmQgYW5kIHJldHVybnMgdGhlIHJlbWFpbmRlci4gTm90ZVxuICogdGhhdCB0aGlzIGZ1bmN0aW9uIHByZXNlcnZlcyB0aGUgSmF2YVNjcmlwdC1zdHlsZSBiZWhhdmlvciBmb3IgbW9kdWxvLiBGb3JcbiAqIG1hdGhlbWF0aWNhbCBtb2R1bG8gc2VlIFtgbWF0aE1vZGBdKCNtYXRoTW9kKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjFcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgdmFsdWUgdG8gdGhlIGRpdmlkZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBwc2V1ZG8tbW9kdWx1c1xuICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzdWx0IG9mIGBiICUgYWAuXG4gKiBAc2VlIFIubWF0aE1vZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubW9kdWxvKDE3LCAzKTsgLy89PiAyXG4gKiAgICAgIC8vIEpTIGJlaGF2aW9yOlxuICogICAgICBSLm1vZHVsbygtMTcsIDMpOyAvLz0+IC0yXG4gKiAgICAgIFIubW9kdWxvKDE3LCAtMyk7IC8vPT4gMlxuICpcbiAqICAgICAgdmFyIGlzT2RkID0gUi5tb2R1bG8oUi5fXywgMik7XG4gKiAgICAgIGlzT2RkKDQyKTsgLy89PiAwXG4gKiAgICAgIGlzT2RkKDIxKTsgLy89PiAxXG4gKi9cbnZhciBtb2R1bG8gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBtb2R1bG8oYSwgYikge1xuICByZXR1cm4gYSAlIGI7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1vZHVsbzsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG51bWJlcnMuIEVxdWl2YWxlbnQgdG8gYGEgKiBiYCBidXQgY3VycmllZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIHZhbHVlLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzdWx0IG9mIGBhICogYmAuXG4gKiBAc2VlIFIuZGl2aWRlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGRvdWJsZSA9IFIubXVsdGlwbHkoMik7XG4gKiAgICAgIHZhciB0cmlwbGUgPSBSLm11bHRpcGx5KDMpO1xuICogICAgICBkb3VibGUoMyk7ICAgICAgIC8vPT4gIDZcbiAqICAgICAgdHJpcGxlKDQpOyAgICAgICAvLz0+IDEyXG4gKiAgICAgIFIubXVsdGlwbHkoMiwgNSk7ICAvLz0+IDEwXG4gKi9cbnZhciBtdWx0aXBseSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIG11bHRpcGx5KGEsIGIpIHtcbiAgcmV0dXJuIGEgKiBiO1xufSk7XG5leHBvcnQgZGVmYXVsdCBtdWx0aXBseTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFdyYXBzIGEgZnVuY3Rpb24gb2YgYW55IGFyaXR5IChpbmNsdWRpbmcgbnVsbGFyeSkgaW4gYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHNcbiAqIGV4YWN0bHkgYG5gIHBhcmFtZXRlcnMuIEFueSBleHRyYW5lb3VzIHBhcmFtZXRlcnMgd2lsbCBub3QgYmUgcGFzc2VkIHRvIHRoZVxuICogc3VwcGxpZWQgZnVuY3Rpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgTnVtYmVyIC0+ICgqIC0+IGEpIC0+ICgqIC0+IGEpXG4gKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgZGVzaXJlZCBhcml0eSBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgYGZuYC4gVGhlIG5ldyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIG9mXG4gKiAgICAgICAgIGFyaXR5IGBuYC5cbiAqIEBzZWUgUi5iaW5hcnksIFIudW5hcnlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgdGFrZXNUd29BcmdzID0gKGEsIGIpID0+IFthLCBiXTtcbiAqXG4gKiAgICAgIHRha2VzVHdvQXJncy5sZW5ndGg7IC8vPT4gMlxuICogICAgICB0YWtlc1R3b0FyZ3MoMSwgMik7IC8vPT4gWzEsIDJdXG4gKlxuICogICAgICB2YXIgdGFrZXNPbmVBcmcgPSBSLm5BcnkoMSwgdGFrZXNUd29BcmdzKTtcbiAqICAgICAgdGFrZXNPbmVBcmcubGVuZ3RoOyAvLz0+IDFcbiAqICAgICAgLy8gT25seSBgbmAgYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAqICAgICAgdGFrZXNPbmVBcmcoMSwgMik7IC8vPT4gWzEsIHVuZGVmaW5lZF1cbiAqIEBzeW1iIFIubkFyeSgwLCBmKShhLCBiKSA9IGYoKVxuICogQHN5bWIgUi5uQXJ5KDEsIGYpKGEsIGIpID0gZihhKVxuICogQHN5bWIgUi5uQXJ5KDIsIGYpKGEsIGIpID0gZihhLCBiKVxuICovXG52YXIgbkFyeSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIG5BcnkobiwgZm4pIHtcbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcyk7XG4gICAgICB9O1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTApIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYTApO1xuICAgICAgfTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEpO1xuICAgICAgfTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExLCBhMik7XG4gICAgICB9O1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExLCBhMiwgYTMpO1xuICAgICAgfTtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQpO1xuICAgICAgfTtcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gICAgICB9O1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpO1xuICAgICAgfTtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNykge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpO1xuICAgICAgfTtcbiAgICBjYXNlIDk6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCk7XG4gICAgICB9O1xuICAgIGNhc2UgMTA6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KTtcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gbkFyeSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgbm8gZ3JlYXRlciB0aGFuIHRlbicpO1xuICB9XG59KTtcbmV4cG9ydCBkZWZhdWx0IG5Bcnk7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcblxuLyoqXG4gKiBOZWdhdGVzIGl0cyBhcmd1bWVudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5uZWdhdGUoNDIpOyAvLz0+IC00MlxuICovXG52YXIgbmVnYXRlID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gbmVnYXRlKG4pIHtcbiAgcmV0dXJuIC1uO1xufSk7XG5leHBvcnQgZGVmYXVsdCBuZWdhdGU7IiwiaW1wb3J0IF9jb21wbGVtZW50IGZyb20gJy4vaW50ZXJuYWwvX2NvbXBsZW1lbnQnO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZSc7XG5pbXBvcnQgX3hhbnkgZnJvbSAnLi9pbnRlcm5hbC9feGFueSc7XG5pbXBvcnQgYW55IGZyb20gJy4vYW55JztcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBubyBlbGVtZW50cyBvZiB0aGUgbGlzdCBtYXRjaCB0aGUgcHJlZGljYXRlLCBgZmFsc2VgXG4gKiBvdGhlcndpc2UuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGFueWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTIuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJlZGljYXRlIGlzIG5vdCBzYXRpc2ZpZWQgYnkgZXZlcnkgZWxlbWVudCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAc2VlIFIuYWxsLCBSLmFueVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc0V2ZW4gPSBuID0+IG4gJSAyID09PSAwO1xuICogICAgICB2YXIgaXNPZGQgPSBuID0+IG4gJSAyID09PSAxO1xuICpcbiAqICAgICAgUi5ub25lKGlzRXZlbiwgWzEsIDMsIDUsIDcsIDksIDExXSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLm5vbmUoaXNPZGQsIFsxLCAzLCA1LCA3LCA4LCAxMV0pOyAvLz0+IGZhbHNlXG4gKi9cbnZhciBub25lID0gLyojX19QVVJFX18qL19jdXJyeTIoIC8qI19fUFVSRV9fKi9fY29tcGxlbWVudCggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoWydhbnknXSwgX3hhbnksIGFueSkpKTtcbmV4cG9ydCBkZWZhdWx0IG5vbmU7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYCFgIG9mIGl0cyBhcmd1bWVudC4gSXQgd2lsbCByZXR1cm4gYHRydWVgIHdoZW5cbiAqIHBhc3NlZCBmYWxzZS15IHZhbHVlLCBhbmQgYGZhbHNlYCB3aGVuIHBhc3NlZCBhIHRydXRoLXkgb25lLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnICogLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSBhIGFueSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gdGhlIGxvZ2ljYWwgaW52ZXJzZSBvZiBwYXNzZWQgYXJndW1lbnQuXG4gKiBAc2VlIFIuY29tcGxlbWVudFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubm90KHRydWUpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIubm90KGZhbHNlKTsgLy89PiB0cnVlXG4gKiAgICAgIFIubm90KDApOyAvLz0+IHRydWVcbiAqICAgICAgUi5ub3QoMSk7IC8vPT4gZmFsc2VcbiAqL1xudmFyIG5vdCA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIG5vdChhKSB7XG4gIHJldHVybiAhYTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbm90OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2lzU3RyaW5nIGZyb20gJy4vaW50ZXJuYWwvX2lzU3RyaW5nJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcuIElmIG4gaXMgbmVnYXRpdmUgdGhlXG4gKiBlbGVtZW50IGF0IGluZGV4IGxlbmd0aCArIG4gaXMgcmV0dXJuZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IGEgfCBVbmRlZmluZWRcbiAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7Kn0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbGlzdCA9IFsnZm9vJywgJ2JhcicsICdiYXonLCAncXV1eCddO1xuICogICAgICBSLm50aCgxLCBsaXN0KTsgLy89PiAnYmFyJ1xuICogICAgICBSLm50aCgtMSwgbGlzdCk7IC8vPT4gJ3F1dXgnXG4gKiAgICAgIFIubnRoKC05OSwgbGlzdCk7IC8vPT4gdW5kZWZpbmVkXG4gKlxuICogICAgICBSLm50aCgyLCAnYWJjJyk7IC8vPT4gJ2MnXG4gKiAgICAgIFIubnRoKDMsICdhYmMnKTsgLy89PiAnJ1xuICogQHN5bWIgUi5udGgoLTEsIFthLCBiLCBjXSkgPSBjXG4gKiBAc3ltYiBSLm50aCgwLCBbYSwgYiwgY10pID0gYVxuICogQHN5bWIgUi5udGgoMSwgW2EsIGIsIGNdKSA9IGJcbiAqL1xudmFyIG50aCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIG50aChvZmZzZXQsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IG9mZnNldCA8IDAgPyBsaXN0Lmxlbmd0aCArIG9mZnNldCA6IG9mZnNldDtcbiAgcmV0dXJuIF9pc1N0cmluZyhsaXN0KSA/IGxpc3QuY2hhckF0KGlkeCkgOiBsaXN0W2lkeF07XG59KTtcbmV4cG9ydCBkZWZhdWx0IG50aDsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IGN1cnJ5TiBmcm9tICcuL2N1cnJ5Tic7XG5pbXBvcnQgbnRoIGZyb20gJy4vbnRoJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBpdHMgbnRoIGFyZ3VtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE51bWJlciAtPiAqLi4uIC0+ICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm50aEFyZygxKSgnYScsICdiJywgJ2MnKTsgLy89PiAnYidcbiAqICAgICAgUi5udGhBcmcoLTEpKCdhJywgJ2InLCAnYycpOyAvLz0+ICdjJ1xuICogQHN5bWIgUi5udGhBcmcoLTEpKGEsIGIsIGMpID0gY1xuICogQHN5bWIgUi5udGhBcmcoMCkoYSwgYiwgYykgPSBhXG4gKiBAc3ltYiBSLm50aEFyZygxKShhLCBiLCBjKSA9IGJcbiAqL1xudmFyIG50aEFyZyA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIG50aEFyZyhuKSB7XG4gIHZhciBhcml0eSA9IG4gPCAwID8gMSA6IG4gKyAxO1xuICByZXR1cm4gY3VycnlOKGFyaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG50aChuLCBhcmd1bWVudHMpO1xuICB9KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbnRoQXJnOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8qKlxuICogYG9gIGlzIGEgY3VycmllZCBjb21wb3NpdGlvbiBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB1bmFyeSBmdW5jdGlvbi5cbiAqIExpa2UgW2Bjb21wb3NlYF0oI2NvbXBvc2UpLCBgb2AgcGVyZm9ybXMgcmlnaHQtdG8tbGVmdCBmdW5jdGlvbiBjb21wb3NpdGlvbi5cbiAqIFVubGlrZSBbYGNvbXBvc2VgXSgjY29tcG9zZSksIHRoZSByaWdodG1vc3QgZnVuY3Rpb24gcGFzc2VkIHRvIGBvYCB3aWxsIGJlXG4gKiBpbnZva2VkIHdpdGggb25seSBvbmUgYXJndW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjQuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIChiIC0+IGMpIC0+IChhIC0+IGIpIC0+IGEgLT4gY1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIuY29tcG9zZSwgUi5waXBlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGNsYXNzeUdyZWV0aW5nID0gbmFtZSA9PiBcIlRoZSBuYW1lJ3MgXCIgKyBuYW1lLmxhc3QgKyBcIiwgXCIgKyBuYW1lLmZpcnN0ICsgXCIgXCIgKyBuYW1lLmxhc3RcbiAqICAgICAgdmFyIHllbGxHcmVldGluZyA9IFIubyhSLnRvVXBwZXIsIGNsYXNzeUdyZWV0aW5nKTtcbiAqICAgICAgeWVsbEdyZWV0aW5nKHtmaXJzdDogJ0phbWVzJywgbGFzdDogJ0JvbmQnfSk7IC8vPT4gXCJUSEUgTkFNRSdTIEJPTkQsIEpBTUVTIEJPTkRcIlxuICpcbiAqICAgICAgUi5vKFIubXVsdGlwbHkoMTApLCBSLmFkZCgxMCkpKC00KSAvLz0+IDYwXG4gKlxuICogQHN5bWIgUi5vKGYsIGcsIHgpID0gZihnKHgpKVxuICovXG52YXIgbyA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIG8oZiwgZywgeCkge1xuICByZXR1cm4gZihnKHgpKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbzsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBzaW5nbGUga2V5OnZhbHVlIHBhaXIuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTguMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBTdHJpbmcgLT4gYSAtPiB7U3RyaW5nOmF9XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBSLnBhaXJcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbWF0Y2hQaHJhc2VzID0gUi5jb21wb3NlKFxuICogICAgICAgIFIub2JqT2YoJ211c3QnKSxcbiAqICAgICAgICBSLm1hcChSLm9iak9mKCdtYXRjaF9waHJhc2UnKSlcbiAqICAgICAgKTtcbiAqICAgICAgbWF0Y2hQaHJhc2VzKFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4ge211c3Q6IFt7bWF0Y2hfcGhyYXNlOiAnZm9vJ30sIHttYXRjaF9waHJhc2U6ICdiYXInfSwge21hdGNoX3BocmFzZTogJ2Jheid9XX1cbiAqL1xudmFyIG9iak9mID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gb2JqT2Yoa2V5LCB2YWwpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICBvYmpba2V5XSA9IHZhbDtcbiAgcmV0dXJuIG9iajtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgb2JqT2Y7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBfb2YgZnJvbSAnLi9pbnRlcm5hbC9fb2YnO1xuXG4vKipcbiAqIFJldHVybnMgYSBzaW5nbGV0b24gYXJyYXkgY29udGFpbmluZyB0aGUgdmFsdWUgcHJvdmlkZWQuXG4gKlxuICogTm90ZSB0aGlzIGBvZmAgaXMgZGlmZmVyZW50IGZyb20gdGhlIEVTNiBgb2ZgOyBTZWVcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L29mXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMy4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgYSAtPiBbYV1cbiAqIEBwYXJhbSB7Kn0geCBhbnkgdmFsdWVcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSB3cmFwcGluZyBgeGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5vZihudWxsKTsgLy89PiBbbnVsbF1cbiAqICAgICAgUi5vZihbNDJdKTsgLy89PiBbWzQyXV1cbiAqL1xudmFyIG9mID0gLyojX19QVVJFX18qL19jdXJyeTEoX29mKTtcbmV4cG9ydCBkZWZhdWx0IG9mOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogUmV0dXJucyBhIHBhcnRpYWwgY29weSBvZiBhbiBvYmplY3Qgb21pdHRpbmcgdGhlIGtleXMgc3BlY2lmaWVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBbU3RyaW5nXSAtPiB7U3RyaW5nOiAqfSAtPiB7U3RyaW5nOiAqfVxuICogQHBhcmFtIHtBcnJheX0gbmFtZXMgYW4gYXJyYXkgb2YgU3RyaW5nIHByb3BlcnR5IG5hbWVzIHRvIG9taXQgZnJvbSB0aGUgbmV3IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGZyb20gYG5hbWVzYCBub3Qgb24gaXQuXG4gKiBAc2VlIFIucGlja1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIub21pdChbJ2EnLCAnZCddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHtiOiAyLCBjOiAzfVxuICovXG52YXIgb21pdCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIG9taXQobmFtZXMsIG9iaikge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBpbmRleCA9IHt9O1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IG5hbWVzLmxlbmd0aDtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgaW5kZXhbbmFtZXNbaWR4XV0gPSAxO1xuICAgIGlkeCArPSAxO1xuICB9XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICBpZiAoIWluZGV4Lmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG9taXQ7IiwiaW1wb3J0IF9hcml0eSBmcm9tICcuL2ludGVybmFsL19hcml0eSc7XG5pbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuXG4vKipcbiAqIEFjY2VwdHMgYSBmdW5jdGlvbiBgZm5gIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBndWFyZHMgaW52b2NhdGlvbiBvZlxuICogYGZuYCBzdWNoIHRoYXQgYGZuYCBjYW4gb25seSBldmVyIGJlIGNhbGxlZCBvbmNlLCBubyBtYXR0ZXIgaG93IG1hbnkgdGltZXNcbiAqIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBpcyBpbnZva2VkLiBUaGUgZmlyc3QgdmFsdWUgY2FsY3VsYXRlZCBpcyByZXR1cm5lZCBpblxuICogc3Vic2VxdWVudCBpbnZvY2F0aW9ucy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoYS4uLiAtPiBiKSAtPiAoYS4uLiAtPiBiKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXAgaW4gYSBjYWxsLW9ubHktb25jZSB3cmFwcGVyLlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBhZGRPbmVPbmNlID0gUi5vbmNlKHggPT4geCArIDEpO1xuICogICAgICBhZGRPbmVPbmNlKDEwKTsgLy89PiAxMVxuICogICAgICBhZGRPbmVPbmNlKGFkZE9uZU9uY2UoNTApKTsgLy89PiAxMVxuICovXG52YXIgb25jZSA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICB2YXIgcmVzdWx0O1xuICByZXR1cm4gX2FyaXR5KGZuLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgb25jZTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIG9uZSBvciBib3RoIG9mIGl0cyBhcmd1bWVudHMgYXJlIGB0cnVlYC4gUmV0dXJucyBgZmFsc2VgXG4gKiBpZiBib3RoIGFyZ3VtZW50cyBhcmUgYGZhbHNlYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyBhIC0+IGIgLT4gYSB8IGJcbiAqIEBwYXJhbSB7QW55fSBhXG4gKiBAcGFyYW0ge0FueX0gYlxuICogQHJldHVybiB7QW55fSB0aGUgZmlyc3QgYXJndW1lbnQgaWYgdHJ1dGh5LCBvdGhlcndpc2UgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAqIEBzZWUgUi5laXRoZXJcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm9yKHRydWUsIHRydWUpOyAvLz0+IHRydWVcbiAqICAgICAgUi5vcih0cnVlLCBmYWxzZSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLm9yKGZhbHNlLCB0cnVlKTsgLy89PiB0cnVlXG4gKiAgICAgIFIub3IoZmFsc2UsIGZhbHNlKTsgLy89PiBmYWxzZVxuICovXG52YXIgb3IgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBvcihhLCBiKSB7XG4gIHJldHVybiBhIHx8IGI7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG9yOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8vIGBJZGVudGl0eWAgaXMgYSBmdW5jdG9yIHRoYXQgaG9sZHMgYSBzaW5nbGUgdmFsdWUsIHdoZXJlIGBtYXBgIHNpbXBseVxuLy8gdHJhbnNmb3JtcyB0aGUgaGVsZCB2YWx1ZSB3aXRoIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbnZhciBJZGVudGl0eSA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiB7IHZhbHVlOiB4LCBtYXA6IGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4gSWRlbnRpdHkoZih4KSk7XG4gICAgfSB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgXCJzZXR0aW5nXCIgdGhlIHBvcnRpb24gb2YgdGhlIGdpdmVuIGRhdGEgc3RydWN0dXJlXG4gKiBmb2N1c2VkIGJ5IHRoZSBnaXZlbiBsZW5zIHRvIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uIHRvXG4gKiB0aGUgZm9jdXNlZCB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICogQHNpZyBMZW5zIHMgYSAtPiAoYSAtPiBhKSAtPiBzIC0+IHNcbiAqIEBwYXJhbSB7TGVuc30gbGVuc1xuICogQHBhcmFtIHsqfSB2XG4gKiBAcGFyYW0geyp9IHhcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIucHJvcCwgUi5sZW5zSW5kZXgsIFIubGVuc1Byb3BcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaGVhZExlbnMgPSBSLmxlbnNJbmRleCgwKTtcbiAqXG4gKiAgICAgIFIub3ZlcihoZWFkTGVucywgUi50b1VwcGVyLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnRk9PJywgJ2JhcicsICdiYXonXVxuICovXG52YXIgb3ZlciA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIG92ZXIobGVucywgZiwgeCkge1xuICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGdldHRlciBmdW5jdGlvbiBpcyBmaXJzdCB0cmFuc2Zvcm1lZCB3aXRoIGBmYCxcbiAgLy8gdGhlbiBzZXQgYXMgdGhlIHZhbHVlIG9mIGFuIGBJZGVudGl0eWAuIFRoaXMgaXMgdGhlbiBtYXBwZWQgb3ZlciB3aXRoIHRoZVxuICAvLyBzZXR0ZXIgZnVuY3Rpb24gb2YgdGhlIGxlbnMuXG4gIHJldHVybiBsZW5zKGZ1bmN0aW9uICh5KSB7XG4gICAgcmV0dXJuIElkZW50aXR5KGYoeSkpO1xuICB9KSh4KS52YWx1ZTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgb3ZlcjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFRha2VzIHR3byBhcmd1bWVudHMsIGBmc3RgIGFuZCBgc25kYCwgYW5kIHJldHVybnMgYFtmc3QsIHNuZF1gLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE4LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gYiAtPiAoYSxiKVxuICogQHBhcmFtIHsqfSBmc3RcbiAqIEBwYXJhbSB7Kn0gc25kXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBzZWUgUi5vYmpPZiwgUi5vZlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGFpcignZm9vJywgJ2JhcicpOyAvLz0+IFsnZm9vJywgJ2JhciddXG4gKi9cbnZhciBwYWlyID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gcGFpcihmc3QsIHNuZCkge1xuICByZXR1cm4gW2ZzdCwgc25kXTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcGFpcjsiLCJpbXBvcnQgX2NvbmNhdCBmcm9tICcuL2ludGVybmFsL19jb25jYXQnO1xuaW1wb3J0IF9jcmVhdGVQYXJ0aWFsQXBwbGljYXRvciBmcm9tICcuL2ludGVybmFsL19jcmVhdGVQYXJ0aWFsQXBwbGljYXRvcic7XG5cbi8qKlxuICogVGFrZXMgYSBmdW5jdGlvbiBgZmAgYW5kIGEgbGlzdCBvZiBhcmd1bWVudHMsIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gYGdgLlxuICogV2hlbiBhcHBsaWVkLCBgZ2AgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGBmYCB0byB0aGUgYXJndW1lbnRzXG4gKiBwcm92aWRlZCBpbml0aWFsbHkgZm9sbG93ZWQgYnkgdGhlIGFyZ3VtZW50cyBwcm92aWRlZCB0byBgZ2AuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTAuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgoYSwgYiwgYywgLi4uLCBuKSAtPiB4KSAtPiBbYSwgYiwgYywgLi4uXSAtPiAoKGQsIGUsIGYsIC4uLiwgbikgLT4geClcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSBSLnBhcnRpYWxSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBtdWx0aXBseTIgPSAoYSwgYikgPT4gYSAqIGI7XG4gKiAgICAgIHZhciBkb3VibGUgPSBSLnBhcnRpYWwobXVsdGlwbHkyLCBbMl0pO1xuICogICAgICBkb3VibGUoMik7IC8vPT4gNFxuICpcbiAqICAgICAgdmFyIGdyZWV0ID0gKHNhbHV0YXRpb24sIHRpdGxlLCBmaXJzdE5hbWUsIGxhc3ROYW1lKSA9PlxuICogICAgICAgIHNhbHV0YXRpb24gKyAnLCAnICsgdGl0bGUgKyAnICcgKyBmaXJzdE5hbWUgKyAnICcgKyBsYXN0TmFtZSArICchJztcbiAqXG4gKiAgICAgIHZhciBzYXlIZWxsbyA9IFIucGFydGlhbChncmVldCwgWydIZWxsbyddKTtcbiAqICAgICAgdmFyIHNheUhlbGxvVG9NcyA9IFIucGFydGlhbChzYXlIZWxsbywgWydNcy4nXSk7XG4gKiAgICAgIHNheUhlbGxvVG9NcygnSmFuZScsICdKb25lcycpOyAvLz0+ICdIZWxsbywgTXMuIEphbmUgSm9uZXMhJ1xuICogQHN5bWIgUi5wYXJ0aWFsKGYsIFthLCBiXSkoYywgZCkgPSBmKGEsIGIsIGMsIGQpXG4gKi9cbnZhciBwYXJ0aWFsID0gLyojX19QVVJFX18qL19jcmVhdGVQYXJ0aWFsQXBwbGljYXRvcihfY29uY2F0KTtcbmV4cG9ydCBkZWZhdWx0IHBhcnRpYWw7IiwiaW1wb3J0IF9jb25jYXQgZnJvbSAnLi9pbnRlcm5hbC9fY29uY2F0JztcbmltcG9ydCBfY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IgZnJvbSAnLi9pbnRlcm5hbC9fY3JlYXRlUGFydGlhbEFwcGxpY2F0b3InO1xuaW1wb3J0IGZsaXAgZnJvbSAnLi9mbGlwJztcblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGBmYCBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cywgYW5kIHJldHVybnMgYSBmdW5jdGlvbiBgZ2AuXG4gKiBXaGVuIGFwcGxpZWQsIGBnYCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYGZgIHRvIHRoZSBhcmd1bWVudHNcbiAqIHByb3ZpZGVkIHRvIGBnYCBmb2xsb3dlZCBieSB0aGUgYXJndW1lbnRzIHByb3ZpZGVkIGluaXRpYWxseS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKChhLCBiLCBjLCAuLi4sIG4pIC0+IHgpIC0+IFtkLCBlLCBmLCAuLi4sIG5dIC0+ICgoYSwgYiwgYywgLi4uKSAtPiB4KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIucGFydGlhbFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBncmVldCA9IChzYWx1dGF0aW9uLCB0aXRsZSwgZmlyc3ROYW1lLCBsYXN0TmFtZSkgPT5cbiAqICAgICAgICBzYWx1dGF0aW9uICsgJywgJyArIHRpdGxlICsgJyAnICsgZmlyc3ROYW1lICsgJyAnICsgbGFzdE5hbWUgKyAnISc7XG4gKlxuICogICAgICB2YXIgZ3JlZXRNc0phbmVKb25lcyA9IFIucGFydGlhbFJpZ2h0KGdyZWV0LCBbJ01zLicsICdKYW5lJywgJ0pvbmVzJ10pO1xuICpcbiAqICAgICAgZ3JlZXRNc0phbmVKb25lcygnSGVsbG8nKTsgLy89PiAnSGVsbG8sIE1zLiBKYW5lIEpvbmVzISdcbiAqIEBzeW1iIFIucGFydGlhbFJpZ2h0KGYsIFthLCBiXSkoYywgZCkgPSBmKGMsIGQsIGEsIGIpXG4gKi9cbnZhciBwYXJ0aWFsUmlnaHQgPSAvKiNfX1BVUkVfXyovX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yKCAvKiNfX1BVUkVfXyovZmxpcChfY29uY2F0KSk7XG5leHBvcnQgZGVmYXVsdCBwYXJ0aWFsUmlnaHQ7IiwiaW1wb3J0IGZpbHRlciBmcm9tICcuL2ZpbHRlcic7XG5pbXBvcnQganV4dCBmcm9tICcuL2p1eHQnO1xuaW1wb3J0IHJlamVjdCBmcm9tICcuL3JlamVjdCc7XG5cbi8qKlxuICogVGFrZXMgYSBwcmVkaWNhdGUgYW5kIGEgbGlzdCBvciBvdGhlciBgRmlsdGVyYWJsZWAgb2JqZWN0IGFuZCByZXR1cm5zIHRoZVxuICogcGFpciBvZiBmaWx0ZXJhYmxlIG9iamVjdHMgb2YgdGhlIHNhbWUgdHlwZSBvZiBlbGVtZW50cyB3aGljaCBkbyBhbmQgZG8gbm90XG4gKiBzYXRpc2Z5LCB0aGUgcHJlZGljYXRlLCByZXNwZWN0aXZlbHkuIEZpbHRlcmFibGUgb2JqZWN0cyBpbmNsdWRlIHBsYWluIG9iamVjdHMgb3IgYW55IG9iamVjdFxuICogdGhhdCBoYXMgYSBmaWx0ZXIgbWV0aG9kIHN1Y2ggYXMgYEFycmF5YC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjRcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIEZpbHRlcmFibGUgZiA9PiAoYSAtPiBCb29sZWFuKSAtPiBmIGEgLT4gW2YgYSwgZiBhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB0byBkZXRlcm1pbmUgd2hpY2ggc2lkZSB0aGUgZWxlbWVudCBiZWxvbmdzIHRvLlxuICogQHBhcmFtIHtBcnJheX0gZmlsdGVyYWJsZSB0aGUgbGlzdCAob3Igb3RoZXIgZmlsdGVyYWJsZSkgdG8gcGFydGl0aW9uLlxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5LCBjb250YWluaW5nIGZpcnN0IHRoZSBzdWJzZXQgb2YgZWxlbWVudHMgdGhhdCBzYXRpc2Z5IHRoZVxuICogICAgICAgICBwcmVkaWNhdGUsIGFuZCBzZWNvbmQgdGhlIHN1YnNldCBvZiBlbGVtZW50cyB0aGF0IGRvIG5vdCBzYXRpc2Z5LlxuICogQHNlZSBSLmZpbHRlciwgUi5yZWplY3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBhcnRpdGlvbihSLmNvbnRhaW5zKCdzJyksIFsnc3NzJywgJ3R0dCcsICdmb28nLCAnYmFycyddKTtcbiAqICAgICAgLy8gPT4gWyBbICdzc3MnLCAnYmFycycgXSwgIFsgJ3R0dCcsICdmb28nIF0gXVxuICpcbiAqICAgICAgUi5wYXJ0aXRpb24oUi5jb250YWlucygncycpLCB7IGE6ICdzc3MnLCBiOiAndHR0JywgZm9vOiAnYmFycycgfSk7XG4gKiAgICAgIC8vID0+IFsgeyBhOiAnc3NzJywgZm9vOiAnYmFycycgfSwgeyBiOiAndHR0JyB9ICBdXG4gKi9cbnZhciBwYXJ0aXRpb24gPSAvKiNfX1BVUkVfXyovanV4dChbZmlsdGVyLCByZWplY3RdKTtcbmV4cG9ydCBkZWZhdWx0IHBhcnRpdGlvbjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSB2YWx1ZSBhdCBhIGdpdmVuIHBhdGguXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMi4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gSWR4ID0gU3RyaW5nIHwgSW50XG4gKiBAc2lnIFtJZHhdIC0+IHthfSAtPiBhIHwgVW5kZWZpbmVkXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIHVzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byByZXRyaWV2ZSB0aGUgbmVzdGVkIHByb3BlcnR5IGZyb20uXG4gKiBAcmV0dXJuIHsqfSBUaGUgZGF0YSBhdCBgcGF0aGAuXG4gKiBAc2VlIFIucHJvcFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGF0aChbJ2EnLCAnYiddLCB7YToge2I6IDJ9fSk7IC8vPT4gMlxuICogICAgICBSLnBhdGgoWydhJywgJ2InXSwge2M6IHtiOiAyfX0pOyAvLz0+IHVuZGVmaW5lZFxuICovXG52YXIgcGF0aCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHBhdGgocGF0aHMsIG9iaikge1xuICB2YXIgdmFsID0gb2JqO1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IHBhdGhzLmxlbmd0aCkge1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YWwgPSB2YWxbcGF0aHNbaWR4XV07XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcGF0aDsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuaW1wb3J0IGVxdWFscyBmcm9tICcuL2VxdWFscyc7XG5pbXBvcnQgcGF0aCBmcm9tICcuL3BhdGgnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIG5lc3RlZCBwYXRoIG9uIGFuIG9iamVjdCBoYXMgYSBzcGVjaWZpYyB2YWx1ZSwgaW5cbiAqIFtgUi5lcXVhbHNgXSgjZXF1YWxzKSB0ZXJtcy4gTW9zdCBsaWtlbHkgdXNlZCB0byBmaWx0ZXIgYSBsaXN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjcuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAdHlwZWRlZm4gSWR4ID0gU3RyaW5nIHwgSW50XG4gKiBAc2lnIFtJZHhdIC0+IGEgLT4ge2F9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggb2YgdGhlIG5lc3RlZCBwcm9wZXJ0eSB0byB1c2VcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byBjb21wYXJlIHRoZSBuZXN0ZWQgcHJvcGVydHkgd2l0aFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrIHRoZSBuZXN0ZWQgcHJvcGVydHkgaW5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgZXF1YWxzIHRoZSBuZXN0ZWQgb2JqZWN0IHByb3BlcnR5LFxuICogICAgICAgICBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgdXNlcjEgPSB7IGFkZHJlc3M6IHsgemlwQ29kZTogOTAyMTAgfSB9O1xuICogICAgICB2YXIgdXNlcjIgPSB7IGFkZHJlc3M6IHsgemlwQ29kZTogNTU1NTUgfSB9O1xuICogICAgICB2YXIgdXNlcjMgPSB7IG5hbWU6ICdCb2InIH07XG4gKiAgICAgIHZhciB1c2VycyA9IFsgdXNlcjEsIHVzZXIyLCB1c2VyMyBdO1xuICogICAgICB2YXIgaXNGYW1vdXMgPSBSLnBhdGhFcShbJ2FkZHJlc3MnLCAnemlwQ29kZSddLCA5MDIxMCk7XG4gKiAgICAgIFIuZmlsdGVyKGlzRmFtb3VzLCB1c2Vycyk7IC8vPT4gWyB1c2VyMSBdXG4gKi9cbnZhciBwYXRoRXEgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBwYXRoRXEoX3BhdGgsIHZhbCwgb2JqKSB7XG4gIHJldHVybiBlcXVhbHMocGF0aChfcGF0aCwgb2JqKSwgdmFsKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcGF0aEVxOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgZGVmYXVsdFRvIGZyb20gJy4vZGVmYXVsdFRvJztcbmltcG9ydCBwYXRoIGZyb20gJy4vcGF0aCc7XG5cbi8qKlxuICogSWYgdGhlIGdpdmVuLCBub24tbnVsbCBvYmplY3QgaGFzIGEgdmFsdWUgYXQgdGhlIGdpdmVuIHBhdGgsIHJldHVybnMgdGhlXG4gKiB2YWx1ZSBhdCB0aGF0IHBhdGguIE90aGVyd2lzZSByZXR1cm5zIHRoZSBwcm92aWRlZCBkZWZhdWx0IHZhbHVlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE4LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBJZHggPSBTdHJpbmcgfCBJbnRcbiAqIEBzaWcgYSAtPiBbSWR4XSAtPiB7YX0gLT4gYVxuICogQHBhcmFtIHsqfSBkIFRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtIHtBcnJheX0gcCBUaGUgcGF0aCB0byB1c2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcmV0cmlldmUgdGhlIG5lc3RlZCBwcm9wZXJ0eSBmcm9tLlxuICogQHJldHVybiB7Kn0gVGhlIGRhdGEgYXQgYHBhdGhgIG9mIHRoZSBzdXBwbGllZCBvYmplY3Qgb3IgdGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wYXRoT3IoJ04vQScsIFsnYScsICdiJ10sIHthOiB7YjogMn19KTsgLy89PiAyXG4gKiAgICAgIFIucGF0aE9yKCdOL0EnLCBbJ2EnLCAnYiddLCB7Yzoge2I6IDJ9fSk7IC8vPT4gXCJOL0FcIlxuICovXG52YXIgcGF0aE9yID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gcGF0aE9yKGQsIHAsIG9iaikge1xuICByZXR1cm4gZGVmYXVsdFRvKGQsIHBhdGgocCwgb2JqKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHBhdGhPcjsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuaW1wb3J0IHBhdGggZnJvbSAnLi9wYXRoJztcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBwcm9wZXJ0eSBhdCBnaXZlbiBwYXRoIHNhdGlzZmllcyB0aGVcbiAqIGdpdmVuIHByZWRpY2F0ZTsgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAdHlwZWRlZm4gSWR4ID0gU3RyaW5nIHwgSW50XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFtJZHhdIC0+IHthfSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wUGF0aFxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIucHJvcFNhdGlzZmllcywgUi5wYXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wYXRoU2F0aXNmaWVzKHkgPT4geSA+IDAsIFsneCcsICd5J10sIHt4OiB7eTogMn19KTsgLy89PiB0cnVlXG4gKi9cbnZhciBwYXRoU2F0aXNmaWVzID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gcGF0aFNhdGlzZmllcyhwcmVkLCBwcm9wUGF0aCwgb2JqKSB7XG4gIHJldHVybiBwcm9wUGF0aC5sZW5ndGggPiAwICYmIHByZWQocGF0aChwcm9wUGF0aCwgb2JqKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHBhdGhTYXRpc2ZpZXM7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgcGFydGlhbCBjb3B5IG9mIGFuIG9iamVjdCBjb250YWluaW5nIG9ubHkgdGhlIGtleXMgc3BlY2lmaWVkLiBJZlxuICogdGhlIGtleSBkb2VzIG5vdCBleGlzdCwgdGhlIHByb3BlcnR5IGlzIGlnbm9yZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIFtrXSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge0FycmF5fSBuYW1lcyBhbiBhcnJheSBvZiBTdHJpbmcgcHJvcGVydHkgbmFtZXMgdG8gY29weSBvbnRvIGEgbmV3IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBvYmplY3Qgd2l0aCBvbmx5IHByb3BlcnRpZXMgZnJvbSBgbmFtZXNgIG9uIGl0LlxuICogQHNlZSBSLm9taXQsIFIucHJvcHNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBpY2soWydhJywgJ2QnXSwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YTogMSwgZDogNH1cbiAqICAgICAgUi5waWNrKFsnYScsICdlJywgJ2YnXSwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YTogMX1cbiAqL1xudmFyIHBpY2sgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBwaWNrKG5hbWVzLCBvYmopIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IG5hbWVzLmxlbmd0aCkge1xuICAgIGlmIChuYW1lc1tpZHhdIGluIG9iaikge1xuICAgICAgcmVzdWx0W25hbWVzW2lkeF1dID0gb2JqW25hbWVzW2lkeF1dO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5leHBvcnQgZGVmYXVsdCBwaWNrOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogU2ltaWxhciB0byBgcGlja2AgZXhjZXB0IHRoYXQgdGhpcyBvbmUgaW5jbHVkZXMgYSBga2V5OiB1bmRlZmluZWRgIHBhaXIgZm9yXG4gKiBwcm9wZXJ0aWVzIHRoYXQgZG9uJ3QgZXhpc3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIFtrXSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge0FycmF5fSBuYW1lcyBhbiBhcnJheSBvZiBTdHJpbmcgcHJvcGVydHkgbmFtZXMgdG8gY29weSBvbnRvIGEgbmV3IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBvYmplY3Qgd2l0aCBvbmx5IHByb3BlcnRpZXMgZnJvbSBgbmFtZXNgIG9uIGl0LlxuICogQHNlZSBSLnBpY2tcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBpY2tBbGwoWydhJywgJ2QnXSwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YTogMSwgZDogNH1cbiAqICAgICAgUi5waWNrQWxsKFsnYScsICdlJywgJ2YnXSwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YTogMSwgZTogdW5kZWZpbmVkLCBmOiB1bmRlZmluZWR9XG4gKi9cbnZhciBwaWNrQWxsID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gcGlja0FsbChuYW1lcywgb2JqKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICB2YXIgbmFtZSA9IG5hbWVzW2lkeF07XG4gICAgcmVzdWx0W25hbWVdID0gb2JqW25hbWVdO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHBpY2tBbGw7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgcGFydGlhbCBjb3B5IG9mIGFuIG9iamVjdCBjb250YWluaW5nIG9ubHkgdGhlIGtleXMgdGhhdCBzYXRpc2Z5XG4gKiB0aGUgc3VwcGxpZWQgcHJlZGljYXRlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjguMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyAoKHYsIGspIC0+IEJvb2xlYW4pIC0+IHtrOiB2fSAtPiB7azogdn1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGEga2V5XG4gKiAgICAgICAgc2hvdWxkIGJlIGluY2x1ZGVkIG9uIHRoZSBvdXRwdXQgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBvYmplY3Qgd2l0aCBvbmx5IHByb3BlcnRpZXMgdGhhdCBzYXRpc2Z5IGBwcmVkYFxuICogICAgICAgICBvbiBpdC5cbiAqIEBzZWUgUi5waWNrLCBSLmZpbHRlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc1VwcGVyQ2FzZSA9ICh2YWwsIGtleSkgPT4ga2V5LnRvVXBwZXJDYXNlKCkgPT09IGtleTtcbiAqICAgICAgUi5waWNrQnkoaXNVcHBlckNhc2UsIHthOiAxLCBiOiAyLCBBOiAzLCBCOiA0fSk7IC8vPT4ge0E6IDMsIEI6IDR9XG4gKi9cbnZhciBwaWNrQnkgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBwaWNrQnkodGVzdCwgb2JqKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICBpZiAodGVzdChvYmpbcHJvcF0sIHByb3AsIG9iaikpIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcGlja0J5OyIsImltcG9ydCBfYXJpdHkgZnJvbSAnLi9pbnRlcm5hbC9fYXJpdHknO1xuaW1wb3J0IF9waXBlIGZyb20gJy4vaW50ZXJuYWwvX3BpcGUnO1xuaW1wb3J0IHJlZHVjZSBmcm9tICcuL3JlZHVjZSc7XG5pbXBvcnQgdGFpbCBmcm9tICcuL3RhaWwnO1xuXG4vKipcbiAqIFBlcmZvcm1zIGxlZnQtdG8tcmlnaHQgZnVuY3Rpb24gY29tcG9zaXRpb24uIFRoZSBsZWZ0bW9zdCBmdW5jdGlvbiBtYXkgaGF2ZVxuICogYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nIGZ1bmN0aW9ucyBtdXN0IGJlIHVuYXJ5LlxuICpcbiAqIEluIHNvbWUgbGlicmFyaWVzIHRoaXMgZnVuY3Rpb24gaXMgbmFtZWQgYHNlcXVlbmNlYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIHJlc3VsdCBvZiBwaXBlIGlzIG5vdCBhdXRvbWF0aWNhbGx5IGN1cnJpZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCgoYSwgYiwgLi4uLCBuKSAtPiBvKSwgKG8gLT4gcCksIC4uLiwgKHggLT4geSksICh5IC0+IHopKSAtPiAoKGEsIGIsIC4uLiwgbikgLT4geilcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmN0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIuY29tcG9zZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBmID0gUi5waXBlKE1hdGgucG93LCBSLm5lZ2F0ZSwgUi5pbmMpO1xuICpcbiAqICAgICAgZigzLCA0KTsgLy8gLSgzXjQpICsgMVxuICogQHN5bWIgUi5waXBlKGYsIGcsIGgpKGEsIGIpID0gaChnKGYoYSwgYikpKVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwaXBlKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGlwZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgfVxuICByZXR1cm4gX2FyaXR5KGFyZ3VtZW50c1swXS5sZW5ndGgsIHJlZHVjZShfcGlwZSwgYXJndW1lbnRzWzBdLCB0YWlsKGFyZ3VtZW50cykpKTtcbn0iLCJpbXBvcnQgY29tcG9zZUsgZnJvbSAnLi9jb21wb3NlSyc7XG5pbXBvcnQgcmV2ZXJzZSBmcm9tICcuL3JldmVyc2UnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGxlZnQtdG8tcmlnaHQgS2xlaXNsaSBjb21wb3NpdGlvbiBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zLFxuICogZWFjaCBvZiB3aGljaCBtdXN0IHJldHVybiBhIHZhbHVlIG9mIGEgdHlwZSBzdXBwb3J0ZWQgYnkgW2BjaGFpbmBdKCNjaGFpbikuXG4gKlxuICogYFIucGlwZUsoZiwgZywgaClgIGlzIGVxdWl2YWxlbnQgdG8gYFIucGlwZShmLCBSLmNoYWluKGcpLCBSLmNoYWluKGgpKWAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIENoYWluIG0gPT4gKChhIC0+IG0gYiksIChiIC0+IG0gYyksIC4uLiwgKHkgLT4gbSB6KSkgLT4gKGEgLT4gbSB6KVxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSBSLmNvbXBvc2VLXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gIHBhcnNlSnNvbiA6OiBTdHJpbmcgLT4gTWF5YmUgKlxuICogICAgICAvLyAgZ2V0IDo6IFN0cmluZyAtPiBPYmplY3QgLT4gTWF5YmUgKlxuICpcbiAqICAgICAgLy8gIGdldFN0YXRlQ29kZSA6OiBNYXliZSBTdHJpbmcgLT4gTWF5YmUgU3RyaW5nXG4gKiAgICAgIHZhciBnZXRTdGF0ZUNvZGUgPSBSLnBpcGVLKFxuICogICAgICAgIHBhcnNlSnNvbixcbiAqICAgICAgICBnZXQoJ3VzZXInKSxcbiAqICAgICAgICBnZXQoJ2FkZHJlc3MnKSxcbiAqICAgICAgICBnZXQoJ3N0YXRlJyksXG4gKiAgICAgICAgUi5jb21wb3NlKE1heWJlLm9mLCBSLnRvVXBwZXIpXG4gKiAgICAgICk7XG4gKlxuICogICAgICBnZXRTdGF0ZUNvZGUoJ3tcInVzZXJcIjp7XCJhZGRyZXNzXCI6e1wic3RhdGVcIjpcIm55XCJ9fX0nKTtcbiAqICAgICAgLy89PiBKdXN0KCdOWScpXG4gKiAgICAgIGdldFN0YXRlQ29kZSgnW0ludmFsaWQgSlNPTl0nKTtcbiAqICAgICAgLy89PiBOb3RoaW5nKClcbiAqIEBzeW1iIFIucGlwZUsoZiwgZywgaCkoYSkgPSBSLmNoYWluKGgsIFIuY2hhaW4oZywgZihhKSkpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBpcGVLKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGlwZUsgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gIH1cbiAgcmV0dXJuIGNvbXBvc2VLLmFwcGx5KHRoaXMsIHJldmVyc2UoYXJndW1lbnRzKSk7XG59IiwiaW1wb3J0IF9hcml0eSBmcm9tICcuL2ludGVybmFsL19hcml0eSc7XG5pbXBvcnQgX3BpcGVQIGZyb20gJy4vaW50ZXJuYWwvX3BpcGVQJztcbmltcG9ydCByZWR1Y2UgZnJvbSAnLi9yZWR1Y2UnO1xuaW1wb3J0IHRhaWwgZnJvbSAnLi90YWlsJztcblxuLyoqXG4gKiBQZXJmb3JtcyBsZWZ0LXRvLXJpZ2h0IGNvbXBvc2l0aW9uIG9mIG9uZSBvciBtb3JlIFByb21pc2UtcmV0dXJuaW5nXG4gKiBmdW5jdGlvbnMuIFRoZSBsZWZ0bW9zdCBmdW5jdGlvbiBtYXkgaGF2ZSBhbnkgYXJpdHk7IHRoZSByZW1haW5pbmcgZnVuY3Rpb25zXG4gKiBtdXN0IGJlIHVuYXJ5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKGEgLT4gUHJvbWlzZSBiKSwgKGIgLT4gUHJvbWlzZSBjKSwgLi4uLCAoeSAtPiBQcm9taXNlIHopKSAtPiAoYSAtPiBQcm9taXNlIHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSBSLmNvbXBvc2VQXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gIGZvbGxvd2Vyc0ZvclVzZXIgOjogU3RyaW5nIC0+IFByb21pc2UgW1VzZXJdXG4gKiAgICAgIHZhciBmb2xsb3dlcnNGb3JVc2VyID0gUi5waXBlUChkYi5nZXRVc2VyQnlJZCwgZGIuZ2V0Rm9sbG93ZXJzKTtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGlwZVAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwaXBlUCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgfVxuICByZXR1cm4gX2FyaXR5KGFyZ3VtZW50c1swXS5sZW5ndGgsIHJlZHVjZShfcGlwZVAsIGFyZ3VtZW50c1swXSwgdGFpbChhcmd1bWVudHMpKSk7XG59IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBtYXAgZnJvbSAnLi9tYXAnO1xuaW1wb3J0IHByb3AgZnJvbSAnLi9wcm9wJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QgYnkgcGx1Y2tpbmcgdGhlIHNhbWUgbmFtZWQgcHJvcGVydHkgb2ZmIGFsbCBvYmplY3RzIGluXG4gKiB0aGUgbGlzdCBzdXBwbGllZC5cbiAqXG4gKiBgcGx1Y2tgIHdpbGwgd29yayBvblxuICogYW55IFtmdW5jdG9yXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2Z1bmN0b3IpIGluXG4gKiBhZGRpdGlvbiB0byBhcnJheXMsIGFzIGl0IGlzIGVxdWl2YWxlbnQgdG8gYFIubWFwKFIucHJvcChrKSwgZilgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgRnVuY3RvciBmID0+IGsgLT4gZiB7azogdn0gLT4gZiB2XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGtleSBUaGUga2V5IG5hbWUgdG8gcGx1Y2sgb2ZmIG9mIGVhY2ggb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheX0gZiBUaGUgYXJyYXkgb3IgZnVuY3RvciB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBrZXkuXG4gKiBAc2VlIFIucHJvcHNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBsdWNrKCdhJykoW3thOiAxfSwge2E6IDJ9XSk7IC8vPT4gWzEsIDJdXG4gKiAgICAgIFIucGx1Y2soMCkoW1sxLCAyXSwgWzMsIDRdXSk7ICAgLy89PiBbMSwgM11cbiAqICAgICAgUi5wbHVjaygndmFsJywge2E6IHt2YWw6IDN9LCBiOiB7dmFsOiA1fX0pOyAvLz0+IHthOiAzLCBiOiA1fVxuICogQHN5bWIgUi5wbHVjaygneCcsIFt7eDogMSwgeTogMn0sIHt4OiAzLCB5OiA0fSwge3g6IDUsIHk6IDZ9XSkgPSBbMSwgMywgNV1cbiAqIEBzeW1iIFIucGx1Y2soMCwgW1sxLCAyXSwgWzMsIDRdLCBbNSwgNl1dKSA9IFsxLCAzLCA1XVxuICovXG52YXIgcGx1Y2sgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBwbHVjayhwLCBsaXN0KSB7XG4gIHJldHVybiBtYXAocHJvcChwKSwgbGlzdCk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHBsdWNrOyIsImltcG9ydCBfY29uY2F0IGZyb20gJy4vaW50ZXJuYWwvX2NvbmNhdCc7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCB3aXRoIHRoZSBnaXZlbiBlbGVtZW50IGF0IHRoZSBmcm9udCwgZm9sbG93ZWQgYnkgdGhlXG4gKiBjb250ZW50cyBvZiB0aGUgbGlzdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHsqfSBlbCBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGhlYWQgb2YgdGhlIG91dHB1dCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gYWRkIHRvIHRoZSB0YWlsIG9mIHRoZSBvdXRwdXQgbGlzdC5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBhcnJheS5cbiAqIEBzZWUgUi5hcHBlbmRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnByZXBlbmQoJ2ZlZScsIFsnZmknLCAnZm8nLCAnZnVtJ10pOyAvLz0+IFsnZmVlJywgJ2ZpJywgJ2ZvJywgJ2Z1bSddXG4gKi9cbnZhciBwcmVwZW5kID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gcHJlcGVuZChlbCwgbGlzdCkge1xuICByZXR1cm4gX2NvbmNhdChbZWxdLCBsaXN0KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcHJlcGVuZDsiLCJpbXBvcnQgbXVsdGlwbHkgZnJvbSAnLi9tdWx0aXBseSc7XG5pbXBvcnQgcmVkdWNlIGZyb20gJy4vcmVkdWNlJztcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHRvZ2V0aGVyIGFsbCB0aGUgZWxlbWVudHMgb2YgYSBsaXN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgW051bWJlcl0gLT4gTnVtYmVyXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IEFuIGFycmF5IG9mIG51bWJlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIHByb2R1Y3Qgb2YgYWxsIHRoZSBudW1iZXJzIGluIHRoZSBsaXN0LlxuICogQHNlZSBSLnJlZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucHJvZHVjdChbMiw0LDYsOCwxMDAsMV0pOyAvLz0+IDM4NDAwXG4gKi9cbnZhciBwcm9kdWN0ID0gLyojX19QVVJFX18qL3JlZHVjZShtdWx0aXBseSwgMSk7XG5leHBvcnQgZGVmYXVsdCBwcm9kdWN0OyIsImltcG9ydCBfbWFwIGZyb20gJy4vaW50ZXJuYWwvX21hcCc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eSc7XG5pbXBvcnQgcGlja0FsbCBmcm9tICcuL3BpY2tBbGwnO1xuaW1wb3J0IHVzZVdpdGggZnJvbSAnLi91c2VXaXRoJztcblxuLyoqXG4gKiBSZWFzb25hYmxlIGFuYWxvZyB0byBTUUwgYHNlbGVjdGAgc3RhdGVtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIFtrXSAtPiBbe2s6IHZ9XSAtPiBbe2s6IHZ9XVxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIHByb2plY3RcbiAqIEBwYXJhbSB7QXJyYXl9IG9ianMgVGhlIG9iamVjdHMgdG8gcXVlcnlcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBvYmplY3RzIHdpdGgganVzdCB0aGUgYHByb3BzYCBwcm9wZXJ0aWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBhYmJ5ID0ge25hbWU6ICdBYmJ5JywgYWdlOiA3LCBoYWlyOiAnYmxvbmQnLCBncmFkZTogMn07XG4gKiAgICAgIHZhciBmcmVkID0ge25hbWU6ICdGcmVkJywgYWdlOiAxMiwgaGFpcjogJ2Jyb3duJywgZ3JhZGU6IDd9O1xuICogICAgICB2YXIga2lkcyA9IFthYmJ5LCBmcmVkXTtcbiAqICAgICAgUi5wcm9qZWN0KFsnbmFtZScsICdncmFkZSddLCBraWRzKTsgLy89PiBbe25hbWU6ICdBYmJ5JywgZ3JhZGU6IDJ9LCB7bmFtZTogJ0ZyZWQnLCBncmFkZTogN31dXG4gKi9cbnZhciBwcm9qZWN0ID0gLyojX19QVVJFX18qL3VzZVdpdGgoX21hcCwgW3BpY2tBbGwsIGlkZW50aXR5XSk7IC8vIHBhc3NpbmcgYGlkZW50aXR5YCBnaXZlcyBjb3JyZWN0IGFyaXR5XG5leHBvcnQgZGVmYXVsdCBwcm9qZWN0OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgcGF0aCBmcm9tICcuL3BhdGgnO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gc3VwcGxpZWQgYW4gb2JqZWN0IHJldHVybnMgdGhlIGluZGljYXRlZFxuICogcHJvcGVydHkgb2YgdGhhdCBvYmplY3QsIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgcyAtPiB7czogYX0gLT4gYSB8IFVuZGVmaW5lZFxuICogQHBhcmFtIHtTdHJpbmd9IHAgVGhlIHByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBxdWVyeVxuICogQHJldHVybiB7Kn0gVGhlIHZhbHVlIGF0IGBvYmoucGAuXG4gKiBAc2VlIFIucGF0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucHJvcCgneCcsIHt4OiAxMDB9KTsgLy89PiAxMDBcbiAqICAgICAgUi5wcm9wKCd4Jywge30pOyAvLz0+IHVuZGVmaW5lZFxuICovXG5cbnZhciBwcm9wID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gcHJvcChwLCBvYmopIHtcbiAgcmV0dXJuIHBhdGgoW3BdLCBvYmopO1xufSk7XG5leHBvcnQgZGVmYXVsdCBwcm9wOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgZXF1YWxzIGZyb20gJy4vZXF1YWxzJztcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBwcm9wZXJ0eSBpcyBlcXVhbCwgaW5cbiAqIFtgUi5lcXVhbHNgXSgjZXF1YWxzKSB0ZXJtcywgdG8gdGhlIGdpdmVuIHZhbHVlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIFlvdSBjYW4gdGVzdCBtdWx0aXBsZSBwcm9wZXJ0aWVzIHdpdGggW2BSLndoZXJlYF0oI3doZXJlKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBTdHJpbmcgLT4gYSAtPiBPYmplY3QgLT4gQm9vbGVhblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi53aGVyZUVxLCBSLnByb3BTYXRpc2ZpZXMsIFIuZXF1YWxzXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGFiYnkgPSB7bmFtZTogJ0FiYnknLCBhZ2U6IDcsIGhhaXI6ICdibG9uZCd9O1xuICogICAgICB2YXIgZnJlZCA9IHtuYW1lOiAnRnJlZCcsIGFnZTogMTIsIGhhaXI6ICdicm93bid9O1xuICogICAgICB2YXIgcnVzdHkgPSB7bmFtZTogJ1J1c3R5JywgYWdlOiAxMCwgaGFpcjogJ2Jyb3duJ307XG4gKiAgICAgIHZhciBhbG9pcyA9IHtuYW1lOiAnQWxvaXMnLCBhZ2U6IDE1LCBkaXNwb3NpdGlvbjogJ3N1cmx5J307XG4gKiAgICAgIHZhciBraWRzID0gW2FiYnksIGZyZWQsIHJ1c3R5LCBhbG9pc107XG4gKiAgICAgIHZhciBoYXNCcm93bkhhaXIgPSBSLnByb3BFcSgnaGFpcicsICdicm93bicpO1xuICogICAgICBSLmZpbHRlcihoYXNCcm93bkhhaXIsIGtpZHMpOyAvLz0+IFtmcmVkLCBydXN0eV1cbiAqL1xudmFyIHByb3BFcSA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIHByb3BFcShuYW1lLCB2YWwsIG9iaikge1xuICByZXR1cm4gZXF1YWxzKHZhbCwgb2JqW25hbWVdKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcHJvcEVxOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgaXMgZnJvbSAnLi9pcyc7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgcHJvcGVydHkgaXMgb2YgdGhlIGdpdmVuIHR5cGU7XG4gKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgVHlwZVxuICogQHNpZyBUeXBlIC0+IFN0cmluZyAtPiBPYmplY3QgLT4gQm9vbGVhblxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmlzLCBSLnByb3BTYXRpc2ZpZXNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnByb3BJcyhOdW1iZXIsICd4Jywge3g6IDEsIHk6IDJ9KTsgIC8vPT4gdHJ1ZVxuICogICAgICBSLnByb3BJcyhOdW1iZXIsICd4Jywge3g6ICdmb28nfSk7ICAgIC8vPT4gZmFsc2VcbiAqICAgICAgUi5wcm9wSXMoTnVtYmVyLCAneCcsIHt9KTsgICAgICAgICAgICAvLz0+IGZhbHNlXG4gKi9cbnZhciBwcm9wSXMgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBwcm9wSXModHlwZSwgbmFtZSwgb2JqKSB7XG4gIHJldHVybiBpcyh0eXBlLCBvYmpbbmFtZV0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBwcm9wSXM7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcbmltcG9ydCBfaGFzIGZyb20gJy4vaW50ZXJuYWwvX2hhcyc7XG5cbi8qKlxuICogSWYgdGhlIGdpdmVuLCBub24tbnVsbCBvYmplY3QgaGFzIGFuIG93biBwcm9wZXJ0eSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSxcbiAqIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoYXQgcHJvcGVydHkuIE90aGVyd2lzZSByZXR1cm5zIHRoZSBwcm92aWRlZCBkZWZhdWx0XG4gKiB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC42LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgYSAtPiBTdHJpbmcgLT4gT2JqZWN0IC0+IGFcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtIHtTdHJpbmd9IHAgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHVybi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZSBvZiBnaXZlbiBwcm9wZXJ0eSBvZiB0aGUgc3VwcGxpZWQgb2JqZWN0IG9yIHRoZSBkZWZhdWx0IHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBhbGljZSA9IHtcbiAqICAgICAgICBuYW1lOiAnQUxJQ0UnLFxuICogICAgICAgIGFnZTogMTAxXG4gKiAgICAgIH07XG4gKiAgICAgIHZhciBmYXZvcml0ZSA9IFIucHJvcCgnZmF2b3JpdGVMaWJyYXJ5Jyk7XG4gKiAgICAgIHZhciBmYXZvcml0ZVdpdGhEZWZhdWx0ID0gUi5wcm9wT3IoJ1JhbWRhJywgJ2Zhdm9yaXRlTGlicmFyeScpO1xuICpcbiAqICAgICAgZmF2b3JpdGUoYWxpY2UpOyAgLy89PiB1bmRlZmluZWRcbiAqICAgICAgZmF2b3JpdGVXaXRoRGVmYXVsdChhbGljZSk7ICAvLz0+ICdSYW1kYSdcbiAqL1xudmFyIHByb3BPciA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIHByb3BPcih2YWwsIHAsIG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgX2hhcyhwLCBvYmopID8gb2JqW3BdIDogdmFsO1xufSk7XG5leHBvcnQgZGVmYXVsdCBwcm9wT3I7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBwcm9wZXJ0eSBzYXRpc2ZpZXMgdGhlIGdpdmVuXG4gKiBwcmVkaWNhdGU7IGBmYWxzZWAgb3RoZXJ3aXNlLiBZb3UgY2FuIHRlc3QgbXVsdGlwbGUgcHJvcGVydGllcyB3aXRoXG4gKiBbYFIud2hlcmVgXSgjd2hlcmUpLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBTdHJpbmcgLT4ge1N0cmluZzogYX0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLndoZXJlLCBSLnByb3BFcSwgUi5wcm9wSXNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnByb3BTYXRpc2ZpZXMoeCA9PiB4ID4gMCwgJ3gnLCB7eDogMSwgeTogMn0pOyAvLz0+IHRydWVcbiAqL1xudmFyIHByb3BTYXRpc2ZpZXMgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBwcm9wU2F0aXNmaWVzKHByZWQsIG5hbWUsIG9iaikge1xuICByZXR1cm4gcHJlZChvYmpbbmFtZV0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBwcm9wU2F0aXNmaWVzOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogQWN0cyBhcyBtdWx0aXBsZSBgcHJvcGA6IGFycmF5IG9mIGtleXMgaW4sIGFycmF5IG9mIHZhbHVlcyBvdXQuIFByZXNlcnZlc1xuICogb3JkZXIuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIFtrXSAtPiB7azogdn0gLT4gW3ZdXG4gKiBAcGFyYW0ge0FycmF5fSBwcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZmV0Y2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBxdWVyeVxuICogQHJldHVybiB7QXJyYXl9IFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcyBvciBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnByb3BzKFsneCcsICd5J10sIHt4OiAxLCB5OiAyfSk7IC8vPT4gWzEsIDJdXG4gKiAgICAgIFIucHJvcHMoWydjJywgJ2EnLCAnYiddLCB7YjogMiwgYTogMX0pOyAvLz0+IFt1bmRlZmluZWQsIDEsIDJdXG4gKlxuICogICAgICB2YXIgZnVsbE5hbWUgPSBSLmNvbXBvc2UoUi5qb2luKCcgJyksIFIucHJvcHMoWydmaXJzdCcsICdsYXN0J10pKTtcbiAqICAgICAgZnVsbE5hbWUoe2xhc3Q6ICdCdWxsZXQtVG9vdGgnLCBhZ2U6IDMzLCBmaXJzdDogJ1RvbnknfSk7IC8vPT4gJ1RvbnkgQnVsbGV0LVRvb3RoJ1xuICovXG52YXIgcHJvcHMgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBwcm9wcyhwcywgb2JqKSB7XG4gIHZhciBsZW4gPSBwcy5sZW5ndGg7XG4gIHZhciBvdXQgPSBbXTtcbiAgdmFyIGlkeCA9IDA7XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIG91dFtpZHhdID0gb2JqW3BzW2lkeF1dO1xuICAgIGlkeCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcHJvcHM7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfaXNOdW1iZXIgZnJvbSAnLi9pbnRlcm5hbC9faXNOdW1iZXInO1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIG51bWJlcnMgZnJvbSBgZnJvbWAgKGluY2x1c2l2ZSkgdG8gYHRvYCAoZXhjbHVzaXZlKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gW051bWJlcl1cbiAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tIFRoZSBmaXJzdCBudW1iZXIgaW4gdGhlIGxpc3QuXG4gKiBAcGFyYW0ge051bWJlcn0gdG8gT25lIG1vcmUgdGhhbiB0aGUgbGFzdCBudW1iZXIgaW4gdGhlIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgbnVtYmVycyBpbiB0dGhlIHNldCBgW2EsIGIpYC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJhbmdlKDEsIDUpOyAgICAvLz0+IFsxLCAyLCAzLCA0XVxuICogICAgICBSLnJhbmdlKDUwLCA1Myk7ICAvLz0+IFs1MCwgNTEsIDUyXVxuICovXG52YXIgcmFuZ2UgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiByYW5nZShmcm9tLCB0bykge1xuICBpZiAoIShfaXNOdW1iZXIoZnJvbSkgJiYgX2lzTnVtYmVyKHRvKSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb3RoIGFyZ3VtZW50cyB0byByYW5nZSBtdXN0IGJlIG51bWJlcnMnKTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBuID0gZnJvbTtcbiAgd2hpbGUgKG4gPCB0bykge1xuICAgIHJlc3VsdC5wdXNoKG4pO1xuICAgIG4gKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5leHBvcnQgZGVmYXVsdCByYW5nZTsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuaW1wb3J0IF9yZWR1Y2UgZnJvbSAnLi9pbnRlcm5hbC9fcmVkdWNlJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgc2luZ2xlIGl0ZW0gYnkgaXRlcmF0aW5nIHRocm91Z2ggdGhlIGxpc3QsIHN1Y2Nlc3NpdmVseSBjYWxsaW5nXG4gKiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24gYW5kIHBhc3NpbmcgaXQgYW4gYWNjdW11bGF0b3IgdmFsdWUgYW5kIHRoZSBjdXJyZW50XG4gKiB2YWx1ZSBmcm9tIHRoZSBhcnJheSwgYW5kIHRoZW4gcGFzc2luZyB0aGUgcmVzdWx0IHRvIHRoZSBuZXh0IGNhbGwuXG4gKlxuICogVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byB2YWx1ZXM6ICooYWNjLCB2YWx1ZSkqLiBJdCBtYXkgdXNlXG4gKiBbYFIucmVkdWNlZGBdKCNyZWR1Y2VkKSB0byBzaG9ydGN1dCB0aGUgaXRlcmF0aW9uLlxuICpcbiAqIFRoZSBhcmd1bWVudHMnIG9yZGVyIG9mIFtgcmVkdWNlUmlnaHRgXSgjcmVkdWNlUmlnaHQpJ3MgaXRlcmF0b3IgZnVuY3Rpb25cbiAqIGlzICoodmFsdWUsIGFjYykqLlxuICpcbiAqIE5vdGU6IGBSLnJlZHVjZWAgZG9lcyBub3Qgc2tpcCBkZWxldGVkIG9yIHVuYXNzaWduZWQgaW5kaWNlcyAoc3BhcnNlXG4gKiBhcnJheXMpLCB1bmxpa2UgdGhlIG5hdGl2ZSBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kLiBGb3IgbW9yZSBkZXRhaWxzXG4gKiBvbiB0aGlzIGJlaGF2aW9yLCBzZWU6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9yZWR1Y2UjRGVzY3JpcHRpb25cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgcmVkdWNlYCBtZXRob2Qgb2YgdGhlIHRoaXJkIGFyZ3VtZW50LCBpZiBwcmVzZW50LiBXaGVuXG4gKiBkb2luZyBzbywgaXQgaXMgdXAgdG8gdGhlIHVzZXIgdG8gaGFuZGxlIHRoZSBbYFIucmVkdWNlZGBdKCNyZWR1Y2VkKVxuICogc2hvcnRjdXRpbmcsIGFzIHRoaXMgaXMgbm90IGltcGxlbWVudGVkIGJ5IGByZWR1Y2VgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhLCBiKSAtPiBhKSAtPiBhIC0+IFtiXSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIFJlY2VpdmVzIHR3byB2YWx1ZXMsIHRoZSBhY2N1bXVsYXRvciBhbmQgdGhlXG4gKiAgICAgICAgY3VycmVudCBlbGVtZW50IGZyb20gdGhlIGFycmF5LlxuICogQHBhcmFtIHsqfSBhY2MgVGhlIGFjY3VtdWxhdG9yIHZhbHVlLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQHNlZSBSLnJlZHVjZWQsIFIuYWRkSW5kZXgsIFIucmVkdWNlUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJlZHVjZShSLnN1YnRyYWN0LCAwLCBbMSwgMiwgMywgNF0pIC8vID0+ICgoKCgwIC0gMSkgLSAyKSAtIDMpIC0gNCkgPSAtMTBcbiAqICAgICAgLy8gICAgICAgICAgLSAgICAgICAgICAgICAgIC0xMFxuICogICAgICAvLyAgICAgICAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgLy8gICAgICAgIC0gICA0ICAgICAgICAgICAtNiAgIDRcbiAqICAgICAgLy8gICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAvLyAgICAgIC0gICAzICAgPT0+ICAgICAtMyAgIDNcbiAqICAgICAgLy8gICAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgLy8gICAgLSAgIDIgICAgICAgICAgIC0xICAgMlxuICogICAgICAvLyAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgLy8gIDAgICAxICAgICAgICAgICAgMCAgIDFcbiAqXG4gKiBAc3ltYiBSLnJlZHVjZShmLCBhLCBbYiwgYywgZF0pID0gZihmKGYoYSwgYiksIGMpLCBkKVxuICovXG52YXIgcmVkdWNlID0gLyojX19QVVJFX18qL19jdXJyeTMoX3JlZHVjZSk7XG5leHBvcnQgZGVmYXVsdCByZWR1Y2U7IiwiaW1wb3J0IF9jdXJyeU4gZnJvbSAnLi9pbnRlcm5hbC9fY3VycnlOJztcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZSc7XG5pbXBvcnQgX2hhcyBmcm9tICcuL2ludGVybmFsL19oYXMnO1xuaW1wb3J0IF9yZWR1Y2UgZnJvbSAnLi9pbnRlcm5hbC9fcmVkdWNlJztcbmltcG9ydCBfeHJlZHVjZUJ5IGZyb20gJy4vaW50ZXJuYWwvX3hyZWR1Y2VCeSc7XG5cbi8qKlxuICogR3JvdXBzIHRoZSBlbGVtZW50cyBvZiB0aGUgbGlzdCBhY2NvcmRpbmcgdG8gdGhlIHJlc3VsdCBvZiBjYWxsaW5nXG4gKiB0aGUgU3RyaW5nLXJldHVybmluZyBmdW5jdGlvbiBga2V5Rm5gIG9uIGVhY2ggZWxlbWVudCBhbmQgcmVkdWNlcyB0aGUgZWxlbWVudHNcbiAqIG9mIGVhY2ggZ3JvdXAgdG8gYSBzaW5nbGUgdmFsdWUgdmlhIHRoZSByZWR1Y2VyIGZ1bmN0aW9uIGB2YWx1ZUZuYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2ljYWxseSBhIG1vcmUgZ2VuZXJhbCBbYGdyb3VwQnlgXSgjZ3JvdXBCeSkgZnVuY3Rpb24uXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSwgYikgLT4gYSkgLT4gYSAtPiAoYiAtPiBTdHJpbmcpIC0+IFtiXSAtPiB7U3RyaW5nOiBhfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gdmFsdWVGbiBUaGUgZnVuY3Rpb24gdGhhdCByZWR1Y2VzIHRoZSBlbGVtZW50cyBvZiBlYWNoIGdyb3VwIHRvIGEgc2luZ2xlXG4gKiAgICAgICAgdmFsdWUuIFJlY2VpdmVzIHR3byB2YWx1ZXMsIGFjY3VtdWxhdG9yIGZvciBhIHBhcnRpY3VsYXIgZ3JvdXAgYW5kIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgKGluaXRpYWwpIGFjY3VtdWxhdG9yIHZhbHVlIGZvciBlYWNoIGdyb3VwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5Rm4gVGhlIGZ1bmN0aW9uIHRoYXQgbWFwcyB0aGUgbGlzdCdzIGVsZW1lbnQgaW50byBhIGtleS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGdyb3VwLlxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgb3V0cHV0IG9mIGBrZXlGbmAgZm9yIGtleXMsIG1hcHBlZCB0byB0aGUgb3V0cHV0IG9mXG4gKiAgICAgICAgIGB2YWx1ZUZuYCBmb3IgZWxlbWVudHMgd2hpY2ggcHJvZHVjZWQgdGhhdCBrZXkgd2hlbiBwYXNzZWQgdG8gYGtleUZuYC5cbiAqIEBzZWUgUi5ncm91cEJ5LCBSLnJlZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciByZWR1Y2VUb05hbWVzQnkgPSBSLnJlZHVjZUJ5KChhY2MsIHN0dWRlbnQpID0+IGFjYy5jb25jYXQoc3R1ZGVudC5uYW1lKSwgW10pO1xuICogICAgICB2YXIgbmFtZXNCeUdyYWRlID0gcmVkdWNlVG9OYW1lc0J5KGZ1bmN0aW9uKHN0dWRlbnQpIHtcbiAqICAgICAgICB2YXIgc2NvcmUgPSBzdHVkZW50LnNjb3JlO1xuICogICAgICAgIHJldHVybiBzY29yZSA8IDY1ID8gJ0YnIDpcbiAqICAgICAgICAgICAgICAgc2NvcmUgPCA3MCA/ICdEJyA6XG4gKiAgICAgICAgICAgICAgIHNjb3JlIDwgODAgPyAnQycgOlxuICogICAgICAgICAgICAgICBzY29yZSA8IDkwID8gJ0InIDogJ0EnO1xuICogICAgICB9KTtcbiAqICAgICAgdmFyIHN0dWRlbnRzID0gW3tuYW1lOiAnTHVjeScsIHNjb3JlOiA5Mn0sXG4gKiAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0RyZXcnLCBzY29yZTogODV9LFxuICogICAgICAgICAgICAgICAgICAgICAgLy8gLi4uXG4gKiAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0JhcnQnLCBzY29yZTogNjJ9XTtcbiAqICAgICAgbmFtZXNCeUdyYWRlKHN0dWRlbnRzKTtcbiAqICAgICAgLy8ge1xuICogICAgICAvLyAgICdBJzogWydMdWN5J10sXG4gKiAgICAgIC8vICAgJ0InOiBbJ0RyZXcnXVxuICogICAgICAvLyAgIC8vIC4uLixcbiAqICAgICAgLy8gICAnRic6IFsnQmFydCddXG4gKiAgICAgIC8vIH1cbiAqL1xudmFyIHJlZHVjZUJ5ID0gLyojX19QVVJFX18qL19jdXJyeU4oNCwgW10sIC8qI19fUFVSRV9fKi9fZGlzcGF0Y2hhYmxlKFtdLCBfeHJlZHVjZUJ5LCBmdW5jdGlvbiByZWR1Y2VCeSh2YWx1ZUZuLCB2YWx1ZUFjYywga2V5Rm4sIGxpc3QpIHtcbiAgcmV0dXJuIF9yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZWx0KSB7XG4gICAgdmFyIGtleSA9IGtleUZuKGVsdCk7XG4gICAgYWNjW2tleV0gPSB2YWx1ZUZuKF9oYXMoa2V5LCBhY2MpID8gYWNjW2tleV0gOiB2YWx1ZUFjYywgZWx0KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSwgbGlzdCk7XG59KSk7XG5leHBvcnQgZGVmYXVsdCByZWR1Y2VCeTsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIFJldHVybnMgYSBzaW5nbGUgaXRlbSBieSBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgbGlzdCwgc3VjY2Vzc2l2ZWx5IGNhbGxpbmdcbiAqIHRoZSBpdGVyYXRvciBmdW5jdGlvbiBhbmQgcGFzc2luZyBpdCBhbiBhY2N1bXVsYXRvciB2YWx1ZSBhbmQgdGhlIGN1cnJlbnRcbiAqIHZhbHVlIGZyb20gdGhlIGFycmF5LCBhbmQgdGhlbiBwYXNzaW5nIHRoZSByZXN1bHQgdG8gdGhlIG5leHQgY2FsbC5cbiAqXG4gKiBTaW1pbGFyIHRvIFtgcmVkdWNlYF0oI3JlZHVjZSksIGV4Y2VwdCBtb3ZlcyB0aHJvdWdoIHRoZSBpbnB1dCBsaXN0IGZyb20gdGhlXG4gKiByaWdodCB0byB0aGUgbGVmdC5cbiAqXG4gKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHZhbHVlczogKih2YWx1ZSwgYWNjKSosIHdoaWxlIHRoZSBhcmd1bWVudHMnXG4gKiBvcmRlciBvZiBgcmVkdWNlYCdzIGl0ZXJhdG9yIGZ1bmN0aW9uIGlzICooYWNjLCB2YWx1ZSkqLlxuICpcbiAqIE5vdGU6IGBSLnJlZHVjZVJpZ2h0YCBkb2VzIG5vdCBza2lwIGRlbGV0ZWQgb3IgdW5hc3NpZ25lZCBpbmRpY2VzIChzcGFyc2VcbiAqIGFycmF5cyksIHVubGlrZSB0aGUgbmF0aXZlIGBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHRgIG1ldGhvZC4gRm9yIG1vcmUgZGV0YWlsc1xuICogb24gdGhpcyBiZWhhdmlvciwgc2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcmVkdWNlUmlnaHQjRGVzY3JpcHRpb25cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSwgYikgLT4gYikgLT4gYiAtPiBbYV0gLT4gYlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLiBSZWNlaXZlcyB0d28gdmFsdWVzLCB0aGUgY3VycmVudCBlbGVtZW50IGZyb20gdGhlIGFycmF5XG4gKiAgICAgICAgYW5kIHRoZSBhY2N1bXVsYXRvci5cbiAqIEBwYXJhbSB7Kn0gYWNjIFRoZSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgUi5yZWR1Y2UsIFIuYWRkSW5kZXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJlZHVjZVJpZ2h0KFIuc3VidHJhY3QsIDAsIFsxLCAyLCAzLCA0XSkgLy8gPT4gKDEgLSAoMiAtICgzIC0gKDQgLSAwKSkpKSA9IC0yXG4gKiAgICAgIC8vICAgIC0gICAgICAgICAgICAgICAtMlxuICogICAgICAvLyAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgLy8gIDEgICAtICAgICAgICAgICAgMSAgIDNcbiAqICAgICAgLy8gICAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgLy8gICAgMiAgIC0gICAgID09PiAgICAyICAtMVxuICogICAgICAvLyAgICAgICAvIFxcICAgICAgICAgICAgICAvIFxcXG4gKiAgICAgIC8vICAgICAgMyAgIC0gICAgICAgICAgICAzICAgNFxuICogICAgICAvLyAgICAgICAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgLy8gICAgICAgIDQgICAwICAgICAgICAgICAgNCAgIDBcbiAqXG4gKiBAc3ltYiBSLnJlZHVjZVJpZ2h0KGYsIGEsIFtiLCBjLCBkXSkgPSBmKGIsIGYoYywgZihkLCBhKSkpXG4gKi9cbnZhciByZWR1Y2VSaWdodCA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGZuLCBhY2MsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgYWNjID0gZm4obGlzdFtpZHhdLCBhY2MpO1xuICAgIGlkeCAtPSAxO1xuICB9XG4gIHJldHVybiBhY2M7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHJlZHVjZVJpZ2h0OyIsImltcG9ydCBfY3VycnlOIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Tic7XG5pbXBvcnQgX3JlZHVjZSBmcm9tICcuL2ludGVybmFsL19yZWR1Y2UnO1xuaW1wb3J0IF9yZWR1Y2VkIGZyb20gJy4vaW50ZXJuYWwvX3JlZHVjZWQnO1xuXG4vKipcbiAqIExpa2UgW2ByZWR1Y2VgXSgjcmVkdWNlKSwgYHJlZHVjZVdoaWxlYCByZXR1cm5zIGEgc2luZ2xlIGl0ZW0gYnkgaXRlcmF0aW5nXG4gKiB0aHJvdWdoIHRoZSBsaXN0LCBzdWNjZXNzaXZlbHkgY2FsbGluZyB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uIGByZWR1Y2VXaGlsZWBcbiAqIGFsc28gdGFrZXMgYSBwcmVkaWNhdGUgdGhhdCBpcyBldmFsdWF0ZWQgYmVmb3JlIGVhY2ggc3RlcC4gSWYgdGhlIHByZWRpY2F0ZVxuICogcmV0dXJucyBgZmFsc2VgLCBpdCBcInNob3J0LWNpcmN1aXRzXCIgdGhlIGl0ZXJhdGlvbiBhbmQgcmV0dXJucyB0aGUgY3VycmVudFxuICogdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIyLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSwgYikgLT4gQm9vbGVhbikgLT4gKChhLCBiKSAtPiBhKSAtPiBhIC0+IFtiXSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIFRoZSBwcmVkaWNhdGUuIEl0IGlzIHBhc3NlZCB0aGUgYWNjdW11bGF0b3IgYW5kIHRoZVxuICogICAgICAgIGN1cnJlbnQgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlXG4gKiAgICAgICAgYWNjdW11bGF0b3IgYW5kIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IGEgVGhlIGFjY3VtdWxhdG9yIHZhbHVlLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQHNlZSBSLnJlZHVjZSwgUi5yZWR1Y2VkXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGlzT2RkID0gKGFjYywgeCkgPT4geCAlIDIgPT09IDE7XG4gKiAgICAgIHZhciB4cyA9IFsxLCAzLCA1LCA2MCwgNzc3LCA4MDBdO1xuICogICAgICBSLnJlZHVjZVdoaWxlKGlzT2RkLCBSLmFkZCwgMCwgeHMpOyAvLz0+IDlcbiAqXG4gKiAgICAgIHZhciB5cyA9IFsyLCA0LCA2XVxuICogICAgICBSLnJlZHVjZVdoaWxlKGlzT2RkLCBSLmFkZCwgMTExLCB5cyk7IC8vPT4gMTExXG4gKi9cbnZhciByZWR1Y2VXaGlsZSA9IC8qI19fUFVSRV9fKi9fY3VycnlOKDQsIFtdLCBmdW5jdGlvbiBfcmVkdWNlV2hpbGUocHJlZCwgZm4sIGEsIGxpc3QpIHtcbiAgcmV0dXJuIF9yZWR1Y2UoZnVuY3Rpb24gKGFjYywgeCkge1xuICAgIHJldHVybiBwcmVkKGFjYywgeCkgPyBmbihhY2MsIHgpIDogX3JlZHVjZWQoYWNjKTtcbiAgfSwgYSwgbGlzdCk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHJlZHVjZVdoaWxlOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgX3JlZHVjZWQgZnJvbSAnLi9pbnRlcm5hbC9fcmVkdWNlZCc7XG5cbi8qKlxuICogUmV0dXJucyBhIHZhbHVlIHdyYXBwZWQgdG8gaW5kaWNhdGUgdGhhdCBpdCBpcyB0aGUgZmluYWwgdmFsdWUgb2YgdGhlIHJlZHVjZVxuICogYW5kIHRyYW5zZHVjZSBmdW5jdGlvbnMuIFRoZSByZXR1cm5lZCB2YWx1ZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGJsYWNrXG4gKiBib3g6IHRoZSBpbnRlcm5hbCBzdHJ1Y3R1cmUgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgc3RhYmxlLlxuICpcbiAqIE5vdGU6IHRoaXMgb3B0aW1pemF0aW9uIGlzIHVuYXZhaWxhYmxlIHRvIGZ1bmN0aW9ucyBub3QgZXhwbGljaXRseSBsaXN0ZWRcbiAqIGFib3ZlLiBGb3IgaW5zdGFuY2UsIGl0IGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5XG4gKiBbYHJlZHVjZVJpZ2h0YF0oI3JlZHVjZVJpZ2h0KS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+ICpcbiAqIEBwYXJhbSB7Kn0geCBUaGUgZmluYWwgdmFsdWUgb2YgdGhlIHJlZHVjZS5cbiAqIEByZXR1cm4geyp9IFRoZSB3cmFwcGVkIHZhbHVlLlxuICogQHNlZSBSLnJlZHVjZSwgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIFIucmVkdWNlKFxuICogICAgICAgKGFjYywgaXRlbSkgPT4gaXRlbSA+IDMgPyBSLnJlZHVjZWQoYWNjKSA6IGFjYy5jb25jYXQoaXRlbSksXG4gKiAgICAgICBbXSxcbiAqICAgICAgIFsxLCAyLCAzLCA0LCA1XSkgLy8gWzEsIDIsIDNdXG4gKi9cbnZhciByZWR1Y2VkID0gLyojX19QVVJFX18qL19jdXJyeTEoX3JlZHVjZWQpO1xuZXhwb3J0IGRlZmF1bHQgcmVkdWNlZDsiLCJpbXBvcnQgX2NvbXBsZW1lbnQgZnJvbSAnLi9pbnRlcm5hbC9fY29tcGxlbWVudCc7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IGZpbHRlciBmcm9tICcuL2ZpbHRlcic7XG5cbi8qKlxuICogVGhlIGNvbXBsZW1lbnQgb2YgW2BmaWx0ZXJgXSgjZmlsdGVyKS5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uIEZpbHRlcmFibGVcbiAqIG9iamVjdHMgaW5jbHVkZSBwbGFpbiBvYmplY3RzIG9yIGFueSBvYmplY3QgdGhhdCBoYXMgYSBmaWx0ZXIgbWV0aG9kIHN1Y2hcbiAqIGFzIGBBcnJheWAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBGaWx0ZXJhYmxlIGYgPT4gKGEgLT4gQm9vbGVhbikgLT4gZiBhIC0+IGYgYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZFxuICogQHBhcmFtIHtBcnJheX0gZmlsdGVyYWJsZVxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAc2VlIFIuZmlsdGVyLCBSLnRyYW5zZHVjZSwgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc09kZCA9IChuKSA9PiBuICUgMiA9PT0gMTtcbiAqXG4gKiAgICAgIFIucmVqZWN0KGlzT2RkLCBbMSwgMiwgMywgNF0pOyAvLz0+IFsyLCA0XVxuICpcbiAqICAgICAgUi5yZWplY3QoaXNPZGQsIHthOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSk7IC8vPT4ge2I6IDIsIGQ6IDR9XG4gKi9cbnZhciByZWplY3QgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiByZWplY3QocHJlZCwgZmlsdGVyYWJsZSkge1xuICByZXR1cm4gZmlsdGVyKF9jb21wbGVtZW50KHByZWQpLCBmaWx0ZXJhYmxlKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcmVqZWN0OyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgc3ViLWxpc3Qgb2YgYGxpc3RgIHN0YXJ0aW5nIGF0IGluZGV4IGBzdGFydGAgYW5kIGNvbnRhaW5pbmdcbiAqIGBjb3VudGAgZWxlbWVudHMuIF9Ob3RlIHRoYXQgdGhpcyBpcyBub3QgZGVzdHJ1Y3RpdmVfOiBpdCByZXR1cm5zIGEgY29weSBvZlxuICogdGhlIGxpc3Qgd2l0aCB0aGUgY2hhbmdlcy5cbiAqIDxzbWFsbD5ObyBsaXN0cyBoYXZlIGJlZW4gaGFybWVkIGluIHRoZSBhcHBsaWNhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLjwvc21hbGw+XG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMi4yXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBUaGUgcG9zaXRpb24gdG8gc3RhcnQgcmVtb3ZpbmcgZWxlbWVudHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJlbW92ZVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byByZW1vdmUgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IEFycmF5IHdpdGggYGNvdW50YCBlbGVtZW50cyBmcm9tIGBzdGFydGAgcmVtb3ZlZC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJlbW92ZSgyLCAzLCBbMSwyLDMsNCw1LDYsNyw4XSk7IC8vPT4gWzEsMiw2LDcsOF1cbiAqL1xudmFyIHJlbW92ZSA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIHJlbW92ZShzdGFydCwgY291bnQsIGxpc3QpIHtcbiAgdmFyIHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIDApO1xuICByZXN1bHQuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHJlbW92ZTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IGFsd2F5cyBmcm9tICcuL2Fsd2F5cyc7XG5pbXBvcnQgdGltZXMgZnJvbSAnLi90aW1lcyc7XG5cbi8qKlxuICogUmV0dXJucyBhIGZpeGVkIGxpc3Qgb2Ygc2l6ZSBgbmAgY29udGFpbmluZyBhIHNwZWNpZmllZCBpZGVudGljYWwgdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4xXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IG4gLT4gW2FdXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXBlYXQuXG4gKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgZGVzaXJlZCBzaXplIG9mIHRoZSBvdXRwdXQgbGlzdC5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBhcnJheSBjb250YWluaW5nIGBuYCBgdmFsdWVgcy5cbiAqIEBzZWUgUi50aW1lc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucmVwZWF0KCdoaScsIDUpOyAvLz0+IFsnaGknLCAnaGknLCAnaGknLCAnaGknLCAnaGknXVxuICpcbiAqICAgICAgdmFyIG9iaiA9IHt9O1xuICogICAgICB2YXIgcmVwZWF0ZWRPYmpzID0gUi5yZXBlYXQob2JqLCA1KTsgLy89PiBbe30sIHt9LCB7fSwge30sIHt9XVxuICogICAgICByZXBlYXRlZE9ianNbMF0gPT09IHJlcGVhdGVkT2Jqc1sxXTsgLy89PiB0cnVlXG4gKiBAc3ltYiBSLnJlcGVhdChhLCAwKSA9IFtdXG4gKiBAc3ltYiBSLnJlcGVhdChhLCAxKSA9IFthXVxuICogQHN5bWIgUi5yZXBlYXQoYSwgMikgPSBbYSwgYV1cbiAqL1xudmFyIHJlcGVhdCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHJlcGVhdCh2YWx1ZSwgbikge1xuICByZXR1cm4gdGltZXMoYWx3YXlzKHZhbHVlKSwgbik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHJlcGVhdDsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIFJlcGxhY2UgYSBzdWJzdHJpbmcgb3IgcmVnZXggbWF0Y2ggaW4gYSBzdHJpbmcgd2l0aCBhIHJlcGxhY2VtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjcuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHNpZyBSZWdFeHB8U3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHBhdHRlcm4gQSByZWd1bGFyIGV4cHJlc3Npb24gb3IgYSBzdWJzdHJpbmcgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVwbGFjZW1lbnQgVGhlIHN0cmluZyB0byByZXBsYWNlIHRoZSBtYXRjaGVzIHdpdGguXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gZG8gdGhlIHNlYXJjaCBhbmQgcmVwbGFjZW1lbnQgaW4uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZXN1bHQuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5yZXBsYWNlKCdmb28nLCAnYmFyJywgJ2ZvbyBmb28gZm9vJyk7IC8vPT4gJ2JhciBmb28gZm9vJ1xuICogICAgICBSLnJlcGxhY2UoL2Zvby8sICdiYXInLCAnZm9vIGZvbyBmb28nKTsgLy89PiAnYmFyIGZvbyBmb28nXG4gKlxuICogICAgICAvLyBVc2UgdGhlIFwiZ1wiIChnbG9iYWwpIGZsYWcgdG8gcmVwbGFjZSBhbGwgb2NjdXJyZW5jZXM6XG4gKiAgICAgIFIucmVwbGFjZSgvZm9vL2csICdiYXInLCAnZm9vIGZvbyBmb28nKTsgLy89PiAnYmFyIGJhciBiYXInXG4gKi9cbnZhciByZXBsYWNlID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gcmVwbGFjZShyZWdleCwgcmVwbGFjZW1lbnQsIHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXgsIHJlcGxhY2VtZW50KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcmVwbGFjZTsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IF9pc1N0cmluZyBmcm9tICcuL2ludGVybmFsL19pc1N0cmluZyc7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IG9yIHN0cmluZyB3aXRoIHRoZSBlbGVtZW50cyBvciBjaGFyYWN0ZXJzIGluIHJldmVyc2VcbiAqIG9yZGVyLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFthXVxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gbGlzdFxuICogQHJldHVybiB7QXJyYXl8U3RyaW5nfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucmV2ZXJzZShbMSwgMiwgM10pOyAgLy89PiBbMywgMiwgMV1cbiAqICAgICAgUi5yZXZlcnNlKFsxLCAyXSk7ICAgICAvLz0+IFsyLCAxXVxuICogICAgICBSLnJldmVyc2UoWzFdKTsgICAgICAgIC8vPT4gWzFdXG4gKiAgICAgIFIucmV2ZXJzZShbXSk7ICAgICAgICAgLy89PiBbXVxuICpcbiAqICAgICAgUi5yZXZlcnNlKCdhYmMnKTsgICAgICAvLz0+ICdjYmEnXG4gKiAgICAgIFIucmV2ZXJzZSgnYWInKTsgICAgICAgLy89PiAnYmEnXG4gKiAgICAgIFIucmV2ZXJzZSgnYScpOyAgICAgICAgLy89PiAnYSdcbiAqICAgICAgUi5yZXZlcnNlKCcnKTsgICAgICAgICAvLz0+ICcnXG4gKi9cbnZhciByZXZlcnNlID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gcmV2ZXJzZShsaXN0KSB7XG4gIHJldHVybiBfaXNTdHJpbmcobGlzdCkgPyBsaXN0LnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCAwKS5yZXZlcnNlKCk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHJldmVyc2U7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLyoqXG4gKiBTY2FuIGlzIHNpbWlsYXIgdG8gW2ByZWR1Y2VgXSgjcmVkdWNlKSwgYnV0IHJldHVybnMgYSBsaXN0IG9mIHN1Y2Nlc3NpdmVseVxuICogcmVkdWNlZCB2YWx1ZXMgZnJvbSB0aGUgbGVmdFxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSwgYikgLT4gYSkgLT4gYSAtPiBbYl0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIFJlY2VpdmVzIHR3byB2YWx1ZXMsIHRoZSBhY2N1bXVsYXRvciBhbmQgdGhlXG4gKiAgICAgICAgY3VycmVudCBlbGVtZW50IGZyb20gdGhlIGFycmF5XG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4ge0FycmF5fSBBIGxpc3Qgb2YgYWxsIGludGVybWVkaWF0ZWx5IHJlZHVjZWQgdmFsdWVzLlxuICogQHNlZSBSLnJlZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBudW1iZXJzID0gWzEsIDIsIDMsIDRdO1xuICogICAgICB2YXIgZmFjdG9yaWFscyA9IFIuc2NhbihSLm11bHRpcGx5LCAxLCBudW1iZXJzKTsgLy89PiBbMSwgMSwgMiwgNiwgMjRdXG4gKiBAc3ltYiBSLnNjYW4oZiwgYSwgW2IsIGNdKSA9IFthLCBmKGEsIGIpLCBmKGYoYSwgYiksIGMpXVxuICovXG52YXIgc2NhbiA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIHNjYW4oZm4sIGFjYywgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW2FjY107XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBhY2MgPSBmbihhY2MsIGxpc3RbaWR4XSk7XG4gICAgcmVzdWx0W2lkeCArIDFdID0gYWNjO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHNjYW47IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBhcCBmcm9tICcuL2FwJztcbmltcG9ydCBtYXAgZnJvbSAnLi9tYXAnO1xuaW1wb3J0IHByZXBlbmQgZnJvbSAnLi9wcmVwZW5kJztcbmltcG9ydCByZWR1Y2VSaWdodCBmcm9tICcuL3JlZHVjZVJpZ2h0JztcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgW1RyYXZlcnNhYmxlXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3RyYXZlcnNhYmxlKVxuICogb2YgW0FwcGxpY2F0aXZlXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwcGxpY2F0aXZlKSBpbnRvIGFuXG4gKiBBcHBsaWNhdGl2ZSBvZiBUcmF2ZXJzYWJsZS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgc2VxdWVuY2VgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChBcHBsaWNhdGl2ZSBmLCBUcmF2ZXJzYWJsZSB0KSA9PiAoYSAtPiBmIGEpIC0+IHQgKGYgYSkgLT4gZiAodCBhKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb2ZcbiAqIEBwYXJhbSB7Kn0gdHJhdmVyc2FibGVcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIudHJhdmVyc2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnNlcXVlbmNlKE1heWJlLm9mLCBbSnVzdCgxKSwgSnVzdCgyKSwgSnVzdCgzKV0pOyAgIC8vPT4gSnVzdChbMSwgMiwgM10pXG4gKiAgICAgIFIuc2VxdWVuY2UoTWF5YmUub2YsIFtKdXN0KDEpLCBKdXN0KDIpLCBOb3RoaW5nKCldKTsgLy89PiBOb3RoaW5nKClcbiAqXG4gKiAgICAgIFIuc2VxdWVuY2UoUi5vZiwgSnVzdChbMSwgMiwgM10pKTsgLy89PiBbSnVzdCgxKSwgSnVzdCgyKSwgSnVzdCgzKV1cbiAqICAgICAgUi5zZXF1ZW5jZShSLm9mLCBOb3RoaW5nKCkpOyAgICAgICAvLz0+IFtOb3RoaW5nKCldXG4gKi9cbnZhciBzZXF1ZW5jZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHNlcXVlbmNlKG9mLCB0cmF2ZXJzYWJsZSkge1xuICByZXR1cm4gdHlwZW9mIHRyYXZlcnNhYmxlLnNlcXVlbmNlID09PSAnZnVuY3Rpb24nID8gdHJhdmVyc2FibGUuc2VxdWVuY2Uob2YpIDogcmVkdWNlUmlnaHQoZnVuY3Rpb24gKHgsIGFjYykge1xuICAgIHJldHVybiBhcChtYXAocHJlcGVuZCwgeCksIGFjYyk7XG4gIH0sIG9mKFtdKSwgdHJhdmVyc2FibGUpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBzZXF1ZW5jZTsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuaW1wb3J0IGFsd2F5cyBmcm9tICcuL2Fsd2F5cyc7XG5pbXBvcnQgb3ZlciBmcm9tICcuL292ZXInO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBcInNldHRpbmdcIiB0aGUgcG9ydGlvbiBvZiB0aGUgZ2l2ZW4gZGF0YSBzdHJ1Y3R1cmVcbiAqIGZvY3VzZWQgYnkgdGhlIGdpdmVuIGxlbnMgdG8gdGhlIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gKiBAc2lnIExlbnMgcyBhIC0+IGEgLT4gcyAtPiBzXG4gKiBAcGFyYW0ge0xlbnN9IGxlbnNcbiAqIEBwYXJhbSB7Kn0gdlxuICogQHBhcmFtIHsqfSB4XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLnByb3AsIFIubGVuc0luZGV4LCBSLmxlbnNQcm9wXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHhMZW5zID0gUi5sZW5zUHJvcCgneCcpO1xuICpcbiAqICAgICAgUi5zZXQoeExlbnMsIDQsIHt4OiAxLCB5OiAyfSk7ICAvLz0+IHt4OiA0LCB5OiAyfVxuICogICAgICBSLnNldCh4TGVucywgOCwge3g6IDEsIHk6IDJ9KTsgIC8vPT4ge3g6IDgsIHk6IDJ9XG4gKi9cbnZhciBzZXQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBzZXQobGVucywgdiwgeCkge1xuICByZXR1cm4gb3ZlcihsZW5zLCBhbHdheXModiksIHgpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBzZXQ7IiwiaW1wb3J0IF9jaGVja0Zvck1ldGhvZCBmcm9tICcuL2ludGVybmFsL19jaGVja0Zvck1ldGhvZCc7XG5pbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZyAob3Igb2JqZWN0IHdpdGggYSBgc2xpY2VgXG4gKiBtZXRob2QpIGZyb20gYGZyb21JbmRleGAgKGluY2x1c2l2ZSkgdG8gYHRvSW5kZXhgIChleGNsdXNpdmUpLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBzbGljZWAgbWV0aG9kIG9mIHRoZSB0aGlyZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjRcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tSW5kZXggVGhlIHN0YXJ0IGluZGV4IChpbmNsdXNpdmUpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHRvSW5kZXggVGhlIGVuZCBpbmRleCAoZXhjbHVzaXZlKS5cbiAqIEBwYXJhbSB7Kn0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnNsaWNlKDEsIDMsIFsnYScsICdiJywgJ2MnLCAnZCddKTsgICAgICAgIC8vPT4gWydiJywgJ2MnXVxuICogICAgICBSLnNsaWNlKDEsIEluZmluaXR5LCBbJ2EnLCAnYicsICdjJywgJ2QnXSk7IC8vPT4gWydiJywgJ2MnLCAnZCddXG4gKiAgICAgIFIuc2xpY2UoMCwgLTEsIFsnYScsICdiJywgJ2MnLCAnZCddKTsgICAgICAgLy89PiBbJ2EnLCAnYicsICdjJ11cbiAqICAgICAgUi5zbGljZSgtMywgLTEsIFsnYScsICdiJywgJ2MnLCAnZCddKTsgICAgICAvLz0+IFsnYicsICdjJ11cbiAqICAgICAgUi5zbGljZSgwLCAzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAgICAgICAvLz0+ICdyYW0nXG4gKi9cbnZhciBzbGljZSA9IC8qI19fUFVSRV9fKi9fY3VycnkzKCAvKiNfX1BVUkVfXyovX2NoZWNrRm9yTWV0aG9kKCdzbGljZScsIGZ1bmN0aW9uIHNsaWNlKGZyb21JbmRleCwgdG9JbmRleCwgbGlzdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgZnJvbUluZGV4LCB0b0luZGV4KTtcbn0pKTtcbmV4cG9ydCBkZWZhdWx0IHNsaWNlOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGxpc3QsIHNvcnRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24sXG4gKiB3aGljaCBzaG91bGQgYWNjZXB0IHR3byB2YWx1ZXMgYXQgYSB0aW1lIGFuZCByZXR1cm4gYSBuZWdhdGl2ZSBudW1iZXIgaWYgdGhlXG4gKiBmaXJzdCB2YWx1ZSBpcyBzbWFsbGVyLCBhIHBvc2l0aXZlIG51bWJlciBpZiBpdCdzIGxhcmdlciwgYW5kIHplcm8gaWYgdGhleVxuICogYXJlIGVxdWFsLiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgaXMgYSAqKmNvcHkqKiBvZiB0aGUgbGlzdC4gSXQgZG9lcyBub3RcbiAqIG1vZGlmeSB0aGUgb3JpZ2luYWwuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGEpIC0+IE51bWJlcikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBBIHNvcnRpbmcgZnVuY3Rpb24gOjogYSAtPiBiIC0+IEludFxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBzb3J0XG4gKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgYXJyYXkgd2l0aCBpdHMgZWxlbWVudHMgc29ydGVkIGJ5IHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBkaWZmID0gZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH07XG4gKiAgICAgIFIuc29ydChkaWZmLCBbNCwyLDcsNV0pOyAvLz0+IFsyLCA0LCA1LCA3XVxuICovXG52YXIgc29ydCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHNvcnQoY29tcGFyYXRvciwgbGlzdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCkuc29ydChjb21wYXJhdG9yKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgc29ydDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFNvcnRzIHRoZSBsaXN0IGFjY29yZGluZyB0byB0aGUgc3VwcGxpZWQgZnVuY3Rpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGIgPT4gKGEgLT4gYikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gc29ydC5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBsaXN0IHNvcnRlZCBieSB0aGUga2V5cyBnZW5lcmF0ZWQgYnkgYGZuYC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgc29ydEJ5Rmlyc3RJdGVtID0gUi5zb3J0QnkoUi5wcm9wKDApKTtcbiAqICAgICAgdmFyIHNvcnRCeU5hbWVDYXNlSW5zZW5zaXRpdmUgPSBSLnNvcnRCeShSLmNvbXBvc2UoUi50b0xvd2VyLCBSLnByb3AoJ25hbWUnKSkpO1xuICogICAgICB2YXIgcGFpcnMgPSBbWy0xLCAxXSwgWy0yLCAyXSwgWy0zLCAzXV07XG4gKiAgICAgIHNvcnRCeUZpcnN0SXRlbShwYWlycyk7IC8vPT4gW1stMywgM10sIFstMiwgMl0sIFstMSwgMV1dXG4gKiAgICAgIHZhciBhbGljZSA9IHtcbiAqICAgICAgICBuYW1lOiAnQUxJQ0UnLFxuICogICAgICAgIGFnZTogMTAxXG4gKiAgICAgIH07XG4gKiAgICAgIHZhciBib2IgPSB7XG4gKiAgICAgICAgbmFtZTogJ0JvYicsXG4gKiAgICAgICAgYWdlOiAtMTBcbiAqICAgICAgfTtcbiAqICAgICAgdmFyIGNsYXJhID0ge1xuICogICAgICAgIG5hbWU6ICdjbGFyYScsXG4gKiAgICAgICAgYWdlOiAzMTQuMTU5XG4gKiAgICAgIH07XG4gKiAgICAgIHZhciBwZW9wbGUgPSBbY2xhcmEsIGJvYiwgYWxpY2VdO1xuICogICAgICBzb3J0QnlOYW1lQ2FzZUluc2Vuc2l0aXZlKHBlb3BsZSk7IC8vPT4gW2FsaWNlLCBib2IsIGNsYXJhXVxuICovXG52YXIgc29ydEJ5ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gc29ydEJ5KGZuLCBsaXN0KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCAwKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGFhID0gZm4oYSk7XG4gICAgdmFyIGJiID0gZm4oYik7XG4gICAgcmV0dXJuIGFhIDwgYmIgPyAtMSA6IGFhID4gYmIgPyAxIDogMDtcbiAgfSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHNvcnRCeTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFNvcnRzIGEgbGlzdCBhY2NvcmRpbmcgdG8gYSBsaXN0IG9mIGNvbXBhcmF0b3JzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIzLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBbKGEsIGEpIC0+IE51bWJlcl0gLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtBcnJheX0gZnVuY3Rpb25zIEEgbGlzdCBvZiBjb21wYXJhdG9yIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gc29ydC5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBsaXN0IHNvcnRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvbWFyYXRvciBmdW5jdGlvbnMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGFsaWNlID0ge1xuICogICAgICAgIG5hbWU6ICdhbGljZScsXG4gKiAgICAgICAgYWdlOiA0MFxuICogICAgICB9O1xuICogICAgICB2YXIgYm9iID0ge1xuICogICAgICAgIG5hbWU6ICdib2InLFxuICogICAgICAgIGFnZTogMzBcbiAqICAgICAgfTtcbiAqICAgICAgdmFyIGNsYXJhID0ge1xuICogICAgICAgIG5hbWU6ICdjbGFyYScsXG4gKiAgICAgICAgYWdlOiA0MFxuICogICAgICB9O1xuICogICAgICB2YXIgcGVvcGxlID0gW2NsYXJhLCBib2IsIGFsaWNlXTtcbiAqICAgICAgdmFyIGFnZU5hbWVTb3J0ID0gUi5zb3J0V2l0aChbXG4gKiAgICAgICAgUi5kZXNjZW5kKFIucHJvcCgnYWdlJykpLFxuICogICAgICAgIFIuYXNjZW5kKFIucHJvcCgnbmFtZScpKVxuICogICAgICBdKTtcbiAqICAgICAgYWdlTmFtZVNvcnQocGVvcGxlKTsgLy89PiBbYWxpY2UsIGNsYXJhLCBib2JdXG4gKi9cbnZhciBzb3J0V2l0aCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHNvcnRXaXRoKGZucywgbGlzdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocmVzdWx0ID09PSAwICYmIGkgPCBmbnMubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBmbnNbaV0oYSwgYik7XG4gICAgICBpICs9IDE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBzb3J0V2l0aDsiLCJpbXBvcnQgaW52b2tlciBmcm9tICcuL2ludm9rZXInO1xuXG4vKipcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MgYmFzZWQgb24gdGhlIGdpdmVuXG4gKiBzZXBhcmF0b3IuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIChTdHJpbmcgfCBSZWdFeHApIC0+IFN0cmluZyAtPiBbU3RyaW5nXVxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBzZXAgVGhlIHBhdHRlcm4uXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gc2VwYXJhdGUgaW50byBhbiBhcnJheS5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgYXJyYXkgb2Ygc3RyaW5ncyBmcm9tIGBzdHJgIHNlcGFyYXRlZCBieSBgc3RyYC5cbiAqIEBzZWUgUi5qb2luXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHBhdGhDb21wb25lbnRzID0gUi5zcGxpdCgnLycpO1xuICogICAgICBSLnRhaWwocGF0aENvbXBvbmVudHMoJy91c3IvbG9jYWwvYmluL25vZGUnKSk7IC8vPT4gWyd1c3InLCAnbG9jYWwnLCAnYmluJywgJ25vZGUnXVxuICpcbiAqICAgICAgUi5zcGxpdCgnLicsICdhLmIuYy54eXouZCcpOyAvLz0+IFsnYScsICdiJywgJ2MnLCAneHl6JywgJ2QnXVxuICovXG52YXIgc3BsaXQgPSAvKiNfX1BVUkVfXyovaW52b2tlcigxLCAnc3BsaXQnKTtcbmV4cG9ydCBkZWZhdWx0IHNwbGl0OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgbGVuZ3RoIGZyb20gJy4vbGVuZ3RoJztcbmltcG9ydCBzbGljZSBmcm9tICcuL3NsaWNlJztcblxuLyoqXG4gKiBTcGxpdHMgYSBnaXZlbiBsaXN0IG9yIHN0cmluZyBhdCBhIGdpdmVuIGluZGV4LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW1thXSwgW2FdXVxuICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFtTdHJpbmcsIFN0cmluZ11cbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggd2hlcmUgdGhlIGFycmF5L3N0cmluZyBpcyBzcGxpdC5cbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBhcnJheSBUaGUgYXJyYXkvc3RyaW5nIHRvIGJlIHNwbGl0LlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5zcGxpdEF0KDEsIFsxLCAyLCAzXSk7ICAgICAgICAgIC8vPT4gW1sxXSwgWzIsIDNdXVxuICogICAgICBSLnNwbGl0QXQoNSwgJ2hlbGxvIHdvcmxkJyk7ICAgICAgLy89PiBbJ2hlbGxvJywgJyB3b3JsZCddXG4gKiAgICAgIFIuc3BsaXRBdCgtMSwgJ2Zvb2JhcicpOyAgICAgICAgICAvLz0+IFsnZm9vYmEnLCAnciddXG4gKi9cbnZhciBzcGxpdEF0ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gc3BsaXRBdChpbmRleCwgYXJyYXkpIHtcbiAgcmV0dXJuIFtzbGljZSgwLCBpbmRleCwgYXJyYXkpLCBzbGljZShpbmRleCwgbGVuZ3RoKGFycmF5KSwgYXJyYXkpXTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgc3BsaXRBdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IHNsaWNlIGZyb20gJy4vc2xpY2UnO1xuXG4vKipcbiAqIFNwbGl0cyBhIGNvbGxlY3Rpb24gaW50byBzbGljZXMgb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbW2FdXVxuICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFtTdHJpbmddXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5zcGxpdEV2ZXJ5KDMsIFsxLCAyLCAzLCA0LCA1LCA2LCA3XSk7IC8vPT4gW1sxLCAyLCAzXSwgWzQsIDUsIDZdLCBbN11dXG4gKiAgICAgIFIuc3BsaXRFdmVyeSgzLCAnZm9vYmFyYmF6Jyk7IC8vPT4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gKi9cbnZhciBzcGxpdEV2ZXJ5ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gc3BsaXRFdmVyeShuLCBsaXN0KSB7XG4gIGlmIChuIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHNwbGl0RXZlcnkgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICByZXN1bHQucHVzaChzbGljZShpZHgsIGlkeCArPSBuLCBsaXN0KSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgc3BsaXRFdmVyeTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFRha2VzIGEgbGlzdCBhbmQgYSBwcmVkaWNhdGUgYW5kIHJldHVybnMgYSBwYWlyIG9mIGxpc3RzIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAtIHRoZSByZXN1bHQgb2YgY29uY2F0ZW5hdGluZyB0aGUgdHdvIG91dHB1dCBsaXN0cyBpcyBlcXVpdmFsZW50IHRvIHRoZSBpbnB1dCBsaXN0O1xuICogIC0gbm9uZSBvZiB0aGUgZWxlbWVudHMgb2YgdGhlIGZpcnN0IG91dHB1dCBsaXN0IHNhdGlzZmllcyB0aGUgcHJlZGljYXRlOyBhbmRcbiAqICAtIGlmIHRoZSBzZWNvbmQgb3V0cHV0IGxpc3QgaXMgbm9uLWVtcHR5LCBpdHMgZmlyc3QgZWxlbWVudCBzYXRpc2ZpZXMgdGhlIHByZWRpY2F0ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW1thXSwgW2FdXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBUaGUgcHJlZGljYXRlIHRoYXQgZGV0ZXJtaW5lcyB3aGVyZSB0aGUgYXJyYXkgaXMgc3BsaXQuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBiZSBzcGxpdC5cbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc3BsaXRXaGVuKFIuZXF1YWxzKDIpLCBbMSwgMiwgMywgMSwgMiwgM10pOyAgIC8vPT4gW1sxXSwgWzIsIDMsIDEsIDIsIDNdXVxuICovXG52YXIgc3BsaXRXaGVuID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gc3BsaXRXaGVuKHByZWQsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIHByZWZpeCA9IFtdO1xuXG4gIHdoaWxlIChpZHggPCBsZW4gJiYgIXByZWQobGlzdFtpZHhdKSkge1xuICAgIHByZWZpeC5wdXNoKGxpc3RbaWR4XSk7XG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gW3ByZWZpeCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgaWR4KV07XG59KTtcbmV4cG9ydCBkZWZhdWx0IHNwbGl0V2hlbjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IGVxdWFscyBmcm9tICcuL2VxdWFscyc7XG5pbXBvcnQgdGFrZSBmcm9tICcuL3Rha2UnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3Qgc3RhcnRzIHdpdGggdGhlIHByb3ZpZGVkIHZhbHVlc1xuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI0LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBCb29sZWFuXG4gKiBAc2lnIFN0cmluZyAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IHByZWZpeFxuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc3RhcnRzV2l0aCgnYScsICdhYmMnKSAgICAgICAgICAgICAgICAvLz0+IHRydWVcbiAqICAgICAgUi5zdGFydHNXaXRoKCdiJywgJ2FiYycpICAgICAgICAgICAgICAgIC8vPT4gZmFsc2VcbiAqICAgICAgUi5zdGFydHNXaXRoKFsnYSddLCBbJ2EnLCAnYicsICdjJ10pICAgIC8vPT4gdHJ1ZVxuICogICAgICBSLnN0YXJ0c1dpdGgoWydiJ10sIFsnYScsICdiJywgJ2MnXSkgICAgLy89PiBmYWxzZVxuICovXG52YXIgc3RhcnRzV2l0aCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIChwcmVmaXgsIGxpc3QpIHtcbiAgcmV0dXJuIGVxdWFscyh0YWtlKHByZWZpeC5sZW5ndGgsIGxpc3QpLCBwcmVmaXgpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBzdGFydHNXaXRoOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogU3VidHJhY3RzIGl0cyBzZWNvbmQgYXJndW1lbnQgZnJvbSBpdHMgZmlyc3QgYXJndW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCB2YWx1ZS5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc3VsdCBvZiBgYSAtIGJgLlxuICogQHNlZSBSLmFkZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc3VidHJhY3QoMTAsIDgpOyAvLz0+IDJcbiAqXG4gKiAgICAgIHZhciBtaW51czUgPSBSLnN1YnRyYWN0KFIuX18sIDUpO1xuICogICAgICBtaW51czUoMTcpOyAvLz0+IDEyXG4gKlxuICogICAgICB2YXIgY29tcGxlbWVudGFyeUFuZ2xlID0gUi5zdWJ0cmFjdCg5MCk7XG4gKiAgICAgIGNvbXBsZW1lbnRhcnlBbmdsZSgzMCk7IC8vPT4gNjBcbiAqICAgICAgY29tcGxlbWVudGFyeUFuZ2xlKDcyKTsgLy89PiAxOFxuICovXG52YXIgc3VidHJhY3QgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBzdWJ0cmFjdChhLCBiKSB7XG4gIHJldHVybiBOdW1iZXIoYSkgLSBOdW1iZXIoYik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHN1YnRyYWN0OyIsImltcG9ydCBhZGQgZnJvbSAnLi9hZGQnO1xuaW1wb3J0IHJlZHVjZSBmcm9tICcuL3JlZHVjZSc7XG5cbi8qKlxuICogQWRkcyB0b2dldGhlciBhbGwgdGhlIGVsZW1lbnRzIG9mIGEgbGlzdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIFtOdW1iZXJdIC0+IE51bWJlclxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBBbiBhcnJheSBvZiBudW1iZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzdW0gb2YgYWxsIHRoZSBudW1iZXJzIGluIHRoZSBsaXN0LlxuICogQHNlZSBSLnJlZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc3VtKFsyLDQsNiw4LDEwMCwxXSk7IC8vPT4gMTIxXG4gKi9cbnZhciBzdW0gPSAvKiNfX1BVUkVfXyovcmVkdWNlKGFkZCwgMCk7XG5leHBvcnQgZGVmYXVsdCBzdW07IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBjb25jYXQgZnJvbSAnLi9jb25jYXQnO1xuaW1wb3J0IGRpZmZlcmVuY2UgZnJvbSAnLi9kaWZmZXJlbmNlJztcblxuLyoqXG4gKiBGaW5kcyB0aGUgc2V0IChpLmUuIG5vIGR1cGxpY2F0ZXMpIG9mIGFsbCBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIGZpcnN0IG9yXG4gKiBzZWNvbmQgbGlzdCwgYnV0IG5vdCBib3RoLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBbKl0gLT4gWypdIC0+IFsqXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIGZpcnN0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGVsZW1lbnRzIGluIGBsaXN0MWAgb3IgYGxpc3QyYCwgYnV0IG5vdCBib3RoLlxuICogQHNlZSBSLnN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoLCBSLmRpZmZlcmVuY2UsIFIuZGlmZmVyZW5jZVdpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnN5bW1ldHJpY0RpZmZlcmVuY2UoWzEsMiwzLDRdLCBbNyw2LDUsNCwzXSk7IC8vPT4gWzEsMiw3LDYsNV1cbiAqICAgICAgUi5zeW1tZXRyaWNEaWZmZXJlbmNlKFs3LDYsNSw0LDNdLCBbMSwyLDMsNF0pOyAvLz0+IFs3LDYsNSwxLDJdXG4gKi9cbnZhciBzeW1tZXRyaWNEaWZmZXJlbmNlID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gc3ltbWV0cmljRGlmZmVyZW5jZShsaXN0MSwgbGlzdDIpIHtcbiAgcmV0dXJuIGNvbmNhdChkaWZmZXJlbmNlKGxpc3QxLCBsaXN0MiksIGRpZmZlcmVuY2UobGlzdDIsIGxpc3QxKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHN5bW1ldHJpY0RpZmZlcmVuY2U7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcbmltcG9ydCBjb25jYXQgZnJvbSAnLi9jb25jYXQnO1xuaW1wb3J0IGRpZmZlcmVuY2VXaXRoIGZyb20gJy4vZGlmZmVyZW5jZVdpdGgnO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgb2YgYWxsIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgZmlyc3Qgb3JcbiAqIHNlY29uZCBsaXN0LCBidXQgbm90IGJvdGguIER1cGxpY2F0aW9uIGlzIGRldGVybWluZWQgYWNjb3JkaW5nIHRvIHRoZSB2YWx1ZVxuICogcmV0dXJuZWQgYnkgYXBwbHlpbmcgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSB0byB0d28gbGlzdCBlbGVtZW50cy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgKChhLCBhKSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB1c2VkIHRvIHRlc3Qgd2hldGhlciB0d28gaXRlbXMgYXJlIGVxdWFsLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIGZpcnN0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGVsZW1lbnRzIGluIGBsaXN0MWAgb3IgYGxpc3QyYCwgYnV0IG5vdCBib3RoLlxuICogQHNlZSBSLnN5bW1ldHJpY0RpZmZlcmVuY2UsIFIuZGlmZmVyZW5jZSwgUi5kaWZmZXJlbmNlV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBlcUEgPSBSLmVxQnkoUi5wcm9wKCdhJykpO1xuICogICAgICB2YXIgbDEgPSBbe2E6IDF9LCB7YTogMn0sIHthOiAzfSwge2E6IDR9XTtcbiAqICAgICAgdmFyIGwyID0gW3thOiAzfSwge2E6IDR9LCB7YTogNX0sIHthOiA2fV07XG4gKiAgICAgIFIuc3ltbWV0cmljRGlmZmVyZW5jZVdpdGgoZXFBLCBsMSwgbDIpOyAvLz0+IFt7YTogMX0sIHthOiAyfSwge2E6IDV9LCB7YTogNn1dXG4gKi9cbnZhciBzeW1tZXRyaWNEaWZmZXJlbmNlV2l0aCA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIHN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoKHByZWQsIGxpc3QxLCBsaXN0Mikge1xuICByZXR1cm4gY29uY2F0KGRpZmZlcmVuY2VXaXRoKHByZWQsIGxpc3QxLCBsaXN0MiksIGRpZmZlcmVuY2VXaXRoKHByZWQsIGxpc3QyLCBsaXN0MSkpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBzeW1tZXRyaWNEaWZmZXJlbmNlV2l0aDsiLCJpbXBvcnQgX2NoZWNrRm9yTWV0aG9kIGZyb20gJy4vaW50ZXJuYWwvX2NoZWNrRm9yTWV0aG9kJztcbmltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgc2xpY2UgZnJvbSAnLi9zbGljZSc7XG5cbi8qKlxuICogUmV0dXJucyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZyAob3Igb2JqZWN0XG4gKiB3aXRoIGEgYHRhaWxgIG1ldGhvZCkuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHNsaWNlYCBtZXRob2Qgb2YgdGhlIGZpcnN0IGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFthXVxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIuaGVhZCwgUi5pbml0LCBSLmxhc3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRhaWwoWzEsIDIsIDNdKTsgIC8vPT4gWzIsIDNdXG4gKiAgICAgIFIudGFpbChbMSwgMl0pOyAgICAgLy89PiBbMl1cbiAqICAgICAgUi50YWlsKFsxXSk7ICAgICAgICAvLz0+IFtdXG4gKiAgICAgIFIudGFpbChbXSk7ICAgICAgICAgLy89PiBbXVxuICpcbiAqICAgICAgUi50YWlsKCdhYmMnKTsgIC8vPT4gJ2JjJ1xuICogICAgICBSLnRhaWwoJ2FiJyk7ICAgLy89PiAnYidcbiAqICAgICAgUi50YWlsKCdhJyk7ICAgIC8vPT4gJydcbiAqICAgICAgUi50YWlsKCcnKTsgICAgIC8vPT4gJydcbiAqL1xudmFyIHRhaWwgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MSggLyojX19QVVJFX18qL19jaGVja0Zvck1ldGhvZCgndGFpbCcsIC8qI19fUFVSRV9fKi9zbGljZSgxLCBJbmZpbml0eSkpKTtcbmV4cG9ydCBkZWZhdWx0IHRhaWw7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZSc7XG5pbXBvcnQgX3h0YWtlIGZyb20gJy4vaW50ZXJuYWwvX3h0YWtlJztcbmltcG9ydCBzbGljZSBmcm9tICcuL3NsaWNlJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBgbmAgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3QsIHN0cmluZywgb3JcbiAqIHRyYW5zZHVjZXIvdHJhbnNmb3JtZXIgKG9yIG9iamVjdCB3aXRoIGEgYHRha2VgIG1ldGhvZCkuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHRha2VgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIuZHJvcFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudGFrZSgxLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJ11cbiAqICAgICAgUi50YWtlKDIsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nLCAnYmFyJ11cbiAqICAgICAgUi50YWtlKDMsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gKiAgICAgIFIudGFrZSg0LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICogICAgICBSLnRha2UoMywgJ3JhbWRhJyk7ICAgICAgICAgICAgICAgLy89PiAncmFtJ1xuICpcbiAqICAgICAgdmFyIHBlcnNvbm5lbCA9IFtcbiAqICAgICAgICAnRGF2ZSBCcnViZWNrJyxcbiAqICAgICAgICAnUGF1bCBEZXNtb25kJyxcbiAqICAgICAgICAnRXVnZW5lIFdyaWdodCcsXG4gKiAgICAgICAgJ0pvZSBNb3JlbGxvJyxcbiAqICAgICAgICAnR2VycnkgTXVsbGlnYW4nLFxuICogICAgICAgICdCb2IgQmF0ZXMnLFxuICogICAgICAgICdKb2UgRG9kZ2UnLFxuICogICAgICAgICdSb24gQ3JvdHR5J1xuICogICAgICBdO1xuICpcbiAqICAgICAgdmFyIHRha2VGaXZlID0gUi50YWtlKDUpO1xuICogICAgICB0YWtlRml2ZShwZXJzb25uZWwpO1xuICogICAgICAvLz0+IFsnRGF2ZSBCcnViZWNrJywgJ1BhdWwgRGVzbW9uZCcsICdFdWdlbmUgV3JpZ2h0JywgJ0pvZSBNb3JlbGxvJywgJ0dlcnJ5IE11bGxpZ2FuJ11cbiAqIEBzeW1iIFIudGFrZSgtMSwgW2EsIGJdKSA9IFthLCBiXVxuICogQHN5bWIgUi50YWtlKDAsIFthLCBiXSkgPSBbXVxuICogQHN5bWIgUi50YWtlKDEsIFthLCBiXSkgPSBbYV1cbiAqIEBzeW1iIFIudGFrZSgyLCBbYSwgYl0pID0gW2EsIGJdXG4gKi9cbnZhciB0YWtlID0gLyojX19QVVJFX18qL19jdXJyeTIoIC8qI19fUFVSRV9fKi9fZGlzcGF0Y2hhYmxlKFsndGFrZSddLCBfeHRha2UsIGZ1bmN0aW9uIHRha2UobiwgeHMpIHtcbiAgcmV0dXJuIHNsaWNlKDAsIG4gPCAwID8gSW5maW5pdHkgOiBuLCB4cyk7XG59KSk7XG5leHBvcnQgZGVmYXVsdCB0YWtlOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgZHJvcCBmcm9tICcuL2Ryb3AnO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBsYXN0IGBuYCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gbGlzdC5cbiAqIElmIGBuID4gbGlzdC5sZW5ndGhgLCByZXR1cm5zIGEgbGlzdCBvZiBgbGlzdC5sZW5ndGhgIGVsZW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi5cbiAqIEBwYXJhbSB7QXJyYXl9IHhzIFRoZSBjb2xsZWN0aW9uIHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAc2VlIFIuZHJvcExhc3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRha2VMYXN0KDEsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydiYXonXVxuICogICAgICBSLnRha2VMYXN0KDIsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydiYXInLCAnYmF6J11cbiAqICAgICAgUi50YWtlTGFzdCgzLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICogICAgICBSLnRha2VMYXN0KDQsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gKiAgICAgIFIudGFrZUxhc3QoMywgJ3JhbWRhJyk7ICAgICAgICAgICAgICAgLy89PiAnbWRhJ1xuICovXG52YXIgdGFrZUxhc3QgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiB0YWtlTGFzdChuLCB4cykge1xuICByZXR1cm4gZHJvcChuID49IDAgPyB4cy5sZW5ndGggLSBuIDogMCwgeHMpO1xufSk7XG5leHBvcnQgZGVmYXVsdCB0YWtlTGFzdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IHNsaWNlIGZyb20gJy4vc2xpY2UnO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBsYXN0IGBuYCBlbGVtZW50cyBvZiBhIGdpdmVuIGxpc3QsIHBhc3NpbmdcbiAqIGVhY2ggdmFsdWUgdG8gdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbiwgYW5kIHRlcm1pbmF0aW5nIHdoZW4gdGhlXG4gKiBwcmVkaWNhdGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLiBFeGNsdWRlcyB0aGUgZWxlbWVudCB0aGF0IGNhdXNlZCB0aGVcbiAqIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBmYWlsLiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIGlzIHBhc3NlZCBvbmUgYXJndW1lbnQ6XG4gKiAqKHZhbHVlKSouXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkuXG4gKiBAc2VlIFIuZHJvcExhc3RXaGlsZSwgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc05vdE9uZSA9IHggPT4geCAhPT0gMTtcbiAqXG4gKiAgICAgIFIudGFrZUxhc3RXaGlsZShpc05vdE9uZSwgWzEsIDIsIDMsIDRdKTsgLy89PiBbMiwgMywgNF1cbiAqXG4gKiAgICAgIFIudGFrZUxhc3RXaGlsZSh4ID0+IHggIT09ICdSJyAsICdSYW1kYScpOyAvLz0+ICdhbWRhJ1xuICovXG52YXIgdGFrZUxhc3RXaGlsZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHRha2VMYXN0V2hpbGUoZm4sIHhzKSB7XG4gIHZhciBpZHggPSB4cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoaWR4ID49IDAgJiYgZm4oeHNbaWR4XSkpIHtcbiAgICBpZHggLT0gMTtcbiAgfVxuICByZXR1cm4gc2xpY2UoaWR4ICsgMSwgSW5maW5pdHksIHhzKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdGFrZUxhc3RXaGlsZTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfeHRha2VXaGlsZSBmcm9tICcuL2ludGVybmFsL194dGFrZVdoaWxlJztcbmltcG9ydCBzbGljZSBmcm9tICcuL3NsaWNlJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gbGlzdCxcbiAqIHBhc3NpbmcgZWFjaCB2YWx1ZSB0byB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIGZ1bmN0aW9uLCBhbmQgdGVybWluYXRpbmcgd2hlblxuICogdGhlIHByZWRpY2F0ZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAuIEV4Y2x1ZGVzIHRoZSBlbGVtZW50IHRoYXQgY2F1c2VkIHRoZVxuICogcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGZhaWwuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gaXMgcGFzc2VkIG9uZSBhcmd1bWVudDpcbiAqICoodmFsdWUpKi5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgdGFrZVdoaWxlYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IHhzIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBhcnJheS5cbiAqIEBzZWUgUi5kcm9wV2hpbGUsIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGlzTm90Rm91ciA9IHggPT4geCAhPT0gNDtcbiAqXG4gKiAgICAgIFIudGFrZVdoaWxlKGlzTm90Rm91ciwgWzEsIDIsIDMsIDQsIDMsIDIsIDFdKTsgLy89PiBbMSwgMiwgM11cbiAqXG4gKiAgICAgIFIudGFrZVdoaWxlKHggPT4geCAhPT0gJ2QnICwgJ1JhbWRhJyk7IC8vPT4gJ1JhbSdcbiAqL1xudmFyIHRha2VXaGlsZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovX2Rpc3BhdGNoYWJsZShbJ3Rha2VXaGlsZSddLCBfeHRha2VXaGlsZSwgZnVuY3Rpb24gdGFrZVdoaWxlKGZuLCB4cykge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IHhzLmxlbmd0aDtcbiAgd2hpbGUgKGlkeCA8IGxlbiAmJiBmbih4c1tpZHhdKSkge1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBzbGljZSgwLCBpZHgsIHhzKTtcbn0pKTtcbmV4cG9ydCBkZWZhdWx0IHRha2VXaGlsZTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfeHRhcCBmcm9tICcuL2ludGVybmFsL194dGFwJztcblxuLyoqXG4gKiBSdW5zIHRoZSBnaXZlbiBmdW5jdGlvbiB3aXRoIHRoZSBzdXBwbGllZCBvYmplY3QsIHRoZW4gcmV0dXJucyB0aGUgb2JqZWN0LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gYXMgc2Vjb25kIHBhcmFtZXRlci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoYSAtPiAqKSAtPiBhIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdpdGggYHhgLiBUaGUgcmV0dXJuIHZhbHVlIG9mIGBmbmAgd2lsbCBiZSB0aHJvd24gYXdheS5cbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybiB7Kn0gYHhgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBzYXlYID0geCA9PiBjb25zb2xlLmxvZygneCBpcyAnICsgeCk7XG4gKiAgICAgIFIudGFwKHNheVgsIDEwMCk7IC8vPT4gMTAwXG4gKiAgICAgIC8vIGxvZ3MgJ3ggaXMgMTAwJ1xuICogQHN5bWIgUi50YXAoZiwgYSkgPSBhXG4gKi9cbnZhciB0YXAgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoW10sIF94dGFwLCBmdW5jdGlvbiB0YXAoZm4sIHgpIHtcbiAgZm4oeCk7XG4gIHJldHVybiB4O1xufSkpO1xuZXhwb3J0IGRlZmF1bHQgdGFwOyIsImltcG9ydCBfY2xvbmVSZWdFeHAgZnJvbSAnLi9pbnRlcm5hbC9fY2xvbmVSZWdFeHAnO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfaXNSZWdFeHAgZnJvbSAnLi9pbnRlcm5hbC9faXNSZWdFeHAnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIGdpdmVuIHN0cmluZyBtYXRjaGVzIGEgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEyLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgUmVnRXhwIC0+IFN0cmluZyAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcGF0dGVyblxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5tYXRjaFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudGVzdCgvXngvLCAneHl6Jyk7IC8vPT4gdHJ1ZVxuICogICAgICBSLnRlc3QoL155LywgJ3h5eicpOyAvLz0+IGZhbHNlXG4gKi9cbnZhciB0ZXN0ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gdGVzdChwYXR0ZXJuLCBzdHIpIHtcbiAgaWYgKCFfaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCfigJh0ZXN04oCZIHJlcXVpcmVzIGEgdmFsdWUgb2YgdHlwZSBSZWdFeHAgYXMgaXRzIGZpcnN0IGFyZ3VtZW50OyByZWNlaXZlZCAnICsgdG9TdHJpbmcocGF0dGVybikpO1xuICB9XG4gIHJldHVybiBfY2xvbmVSZWdFeHAocGF0dGVybikudGVzdChzdHIpO1xufSk7XG5leHBvcnQgZGVmYXVsdCB0ZXN0OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogQ2FsbHMgYW4gaW5wdXQgZnVuY3Rpb24gYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgcmVzdWx0c1xuICogb2YgdGhvc2UgZnVuY3Rpb24gY2FsbHMuXG4gKlxuICogYGZuYCBpcyBwYXNzZWQgb25lIGFyZ3VtZW50OiBUaGUgY3VycmVudCB2YWx1ZSBvZiBgbmAsIHdoaWNoIGJlZ2lucyBhdCBgMGBcbiAqIGFuZCBpcyBncmFkdWFsbHkgaW5jcmVtZW50ZWQgdG8gYG4gLSAxYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjNcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChOdW1iZXIgLT4gYSkgLT4gTnVtYmVyIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGludm9rZS4gUGFzc2VkIG9uZSBhcmd1bWVudCwgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYG5gLlxuICogQHBhcmFtIHtOdW1iZXJ9IG4gQSB2YWx1ZSBiZXR3ZWVuIGAwYCBhbmQgYG4gLSAxYC4gSW5jcmVtZW50cyBhZnRlciBlYWNoIGZ1bmN0aW9uIGNhbGwuXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgcmV0dXJuIHZhbHVlcyBvZiBhbGwgY2FsbHMgdG8gYGZuYC5cbiAqIEBzZWUgUi5yZXBlYXRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRpbWVzKFIuaWRlbnRpdHksIDUpOyAvLz0+IFswLCAxLCAyLCAzLCA0XVxuICogQHN5bWIgUi50aW1lcyhmLCAwKSA9IFtdXG4gKiBAc3ltYiBSLnRpbWVzKGYsIDEpID0gW2YoMCldXG4gKiBAc3ltYiBSLnRpbWVzKGYsIDIpID0gW2YoMCksIGYoMSldXG4gKi9cbnZhciB0aW1lcyA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHRpbWVzKGZuLCBuKSB7XG4gIHZhciBsZW4gPSBOdW1iZXIobik7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGlzdDtcblxuICBpZiAobGVuIDwgMCB8fCBpc05hTihsZW4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ24gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgfVxuICBsaXN0ID0gbmV3IEFycmF5KGxlbik7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBsaXN0W2lkeF0gPSBmbihpZHgpO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBsaXN0O1xufSk7XG5leHBvcnQgZGVmYXVsdCB0aW1lczsiLCJpbXBvcnQgaW52b2tlciBmcm9tICcuL2ludm9rZXInO1xuXG4vKipcbiAqIFRoZSBsb3dlciBjYXNlIHZlcnNpb24gb2YgYSBzdHJpbmcuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBsb3dlciBjYXNlLlxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgbG93ZXIgY2FzZSB2ZXJzaW9uIG9mIGBzdHJgLlxuICogQHNlZSBSLnRvVXBwZXJcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRvTG93ZXIoJ1hZWicpOyAvLz0+ICd4eXonXG4gKi9cbnZhciB0b0xvd2VyID0gLyojX19QVVJFX18qL2ludm9rZXIoMCwgJ3RvTG93ZXJDYXNlJyk7XG5leHBvcnQgZGVmYXVsdCB0b0xvd2VyOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgX2hhcyBmcm9tICcuL2ludGVybmFsL19oYXMnO1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGFuIGFycmF5IG9mIGtleSwgdmFsdWUgYXJyYXlzLiBPbmx5IHRoZSBvYmplY3Qnc1xuICogb3duIHByb3BlcnRpZXMgYXJlIHVzZWQuXG4gKiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBvdXRwdXQgYXJyYXkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgY29uc2lzdGVudFxuICogYWNyb3NzIGRpZmZlcmVudCBKUyBwbGF0Zm9ybXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtTdHJpbmc6ICp9IC0+IFtbU3RyaW5nLCpdXVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIGtleSwgdmFsdWUgYXJyYXlzIGZyb20gdGhlIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICogQHNlZSBSLmZyb21QYWlyc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudG9QYWlycyh7YTogMSwgYjogMiwgYzogM30pOyAvLz0+IFtbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdXVxuICovXG52YXIgdG9QYWlycyA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIHRvUGFpcnMob2JqKSB7XG4gIHZhciBwYWlycyA9IFtdO1xuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIGlmIChfaGFzKHByb3AsIG9iaikpIHtcbiAgICAgIHBhaXJzW3BhaXJzLmxlbmd0aF0gPSBbcHJvcCwgb2JqW3Byb3BdXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhaXJzO1xufSk7XG5leHBvcnQgZGVmYXVsdCB0b1BhaXJzOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYW4gYXJyYXkgb2Yga2V5LCB2YWx1ZSBhcnJheXMuIFRoZSBvYmplY3QncyBvd25cbiAqIHByb3BlcnRpZXMgYW5kIHByb3RvdHlwZSBwcm9wZXJ0aWVzIGFyZSB1c2VkLiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZVxuICogb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnQgYWNyb3NzIGRpZmZlcmVudCBKU1xuICogcGxhdGZvcm1zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7U3RyaW5nOiAqfSAtPiBbW1N0cmluZywqXV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cyBmcm9tIHRoZSBvYmplY3QncyBvd25cbiAqICAgICAgICAgYW5kIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9ICdYJzsgfTtcbiAqICAgICAgRi5wcm90b3R5cGUueSA9ICdZJztcbiAqICAgICAgdmFyIGYgPSBuZXcgRigpO1xuICogICAgICBSLnRvUGFpcnNJbihmKTsgLy89PiBbWyd4JywnWCddLCBbJ3knLCdZJ11dXG4gKi9cbnZhciB0b1BhaXJzSW4gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiB0b1BhaXJzSW4ob2JqKSB7XG4gIHZhciBwYWlycyA9IFtdO1xuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIHBhaXJzW3BhaXJzLmxlbmd0aF0gPSBbcHJvcCwgb2JqW3Byb3BdXTtcbiAgfVxuICByZXR1cm4gcGFpcnM7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHRvUGFpcnNJbjsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IF90b1N0cmluZyBmcm9tICcuL2ludGVybmFsL190b1N0cmluZyc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB2YWx1ZS4gYGV2YWxgJ2luZyB0aGUgb3V0cHV0XG4gKiBzaG91bGQgcmVzdWx0IGluIGEgdmFsdWUgZXF1aXZhbGVudCB0byB0aGUgaW5wdXQgdmFsdWUuIE1hbnkgb2YgdGhlIGJ1aWx0LWluXG4gKiBgdG9TdHJpbmdgIG1ldGhvZHMgZG8gbm90IHNhdGlzZnkgdGhpcyByZXF1aXJlbWVudC5cbiAqXG4gKiBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gYFtvYmplY3QgT2JqZWN0XWAgd2l0aCBhIGB0b1N0cmluZ2AgbWV0aG9kIG90aGVyXG4gKiB0aGFuIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCwgdGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aXRoIG5vIGFyZ3VtZW50c1xuICogdG8gcHJvZHVjZSB0aGUgcmV0dXJuIHZhbHVlLiBUaGlzIG1lYW5zIHVzZXItZGVmaW5lZCBjb25zdHJ1Y3RvciBmdW5jdGlvbnNcbiAqIGNhbiBwcm92aWRlIGEgc3VpdGFibGUgYHRvU3RyaW5nYCBtZXRob2QuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICBmdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gKiAgICAgICB0aGlzLnggPSB4O1xuICogICAgICAgdGhpcy55ID0geTtcbiAqICAgICB9XG4gKlxuICogICAgIFBvaW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuICduZXcgUG9pbnQoJyArIHRoaXMueCArICcsICcgKyB0aGlzLnkgKyAnKSc7XG4gKiAgICAgfTtcbiAqXG4gKiAgICAgUi50b1N0cmluZyhuZXcgUG9pbnQoMSwgMikpOyAvLz0+ICduZXcgUG9pbnQoMSwgMiknXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHNpZyAqIC0+IFN0cmluZ1xuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRvU3RyaW5nKDQyKTsgLy89PiAnNDInXG4gKiAgICAgIFIudG9TdHJpbmcoJ2FiYycpOyAvLz0+ICdcImFiY1wiJ1xuICogICAgICBSLnRvU3RyaW5nKFsxLCAyLCAzXSk7IC8vPT4gJ1sxLCAyLCAzXSdcbiAqICAgICAgUi50b1N0cmluZyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30pOyAvLz0+ICd7XCJiYXJcIjogMiwgXCJiYXpcIjogMywgXCJmb29cIjogMX0nXG4gKiAgICAgIFIudG9TdHJpbmcobmV3IERhdGUoJzIwMDEtMDItMDNUMDQ6MDU6MDZaJykpOyAvLz0+ICduZXcgRGF0ZShcIjIwMDEtMDItMDNUMDQ6MDU6MDYuMDAwWlwiKSdcbiAqL1xudmFyIHRvU3RyaW5nID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gdG9TdHJpbmcodmFsKSB7XG4gIHJldHVybiBfdG9TdHJpbmcodmFsLCBbXSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHRvU3RyaW5nOyIsImltcG9ydCBpbnZva2VyIGZyb20gJy4vaW52b2tlcic7XG5cbi8qKlxuICogVGhlIHVwcGVyIGNhc2UgdmVyc2lvbiBvZiBhIHN0cmluZy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHVwcGVyIGNhc2UuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB1cHBlciBjYXNlIHZlcnNpb24gb2YgYHN0cmAuXG4gKiBAc2VlIFIudG9Mb3dlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudG9VcHBlcignYWJjJyk7IC8vPT4gJ0FCQydcbiAqL1xudmFyIHRvVXBwZXIgPSAvKiNfX1BVUkVfXyovaW52b2tlcigwLCAndG9VcHBlckNhc2UnKTtcbmV4cG9ydCBkZWZhdWx0IHRvVXBwZXI7IiwiaW1wb3J0IF9yZWR1Y2UgZnJvbSAnLi9pbnRlcm5hbC9fcmVkdWNlJztcbmltcG9ydCBfeHdyYXAgZnJvbSAnLi9pbnRlcm5hbC9feHdyYXAnO1xuaW1wb3J0IGN1cnJ5TiBmcm9tICcuL2N1cnJ5Tic7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSB0cmFuc2R1Y2VyIHVzaW5nIHN1cHBsaWVkIGl0ZXJhdG9yIGZ1bmN0aW9uLiBSZXR1cm5zIGEgc2luZ2xlXG4gKiBpdGVtIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBsaXN0LCBzdWNjZXNzaXZlbHkgY2FsbGluZyB0aGUgdHJhbnNmb3JtZWRcbiAqIGl0ZXJhdG9yIGZ1bmN0aW9uIGFuZCBwYXNzaW5nIGl0IGFuIGFjY3VtdWxhdG9yIHZhbHVlIGFuZCB0aGUgY3VycmVudCB2YWx1ZVxuICogZnJvbSB0aGUgYXJyYXksIGFuZCB0aGVuIHBhc3NpbmcgdGhlIHJlc3VsdCB0byB0aGUgbmV4dCBjYWxsLlxuICpcbiAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyB0d28gdmFsdWVzOiAqKGFjYywgdmFsdWUpKi4gSXQgd2lsbCBiZVxuICogd3JhcHBlZCBhcyBhIHRyYW5zZm9ybWVyIHRvIGluaXRpYWxpemUgdGhlIHRyYW5zZHVjZXIuIEEgdHJhbnNmb3JtZXIgY2FuIGJlXG4gKiBwYXNzZWQgZGlyZWN0bHkgaW4gcGxhY2Ugb2YgYW4gaXRlcmF0b3IgZnVuY3Rpb24uIEluIGJvdGggY2FzZXMsIGl0ZXJhdGlvblxuICogbWF5IGJlIHN0b3BwZWQgZWFybHkgd2l0aCB0aGUgW2BSLnJlZHVjZWRgXSgjcmVkdWNlZCkgZnVuY3Rpb24uXG4gKlxuICogQSB0cmFuc2R1Y2VyIGlzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgdHJhbnNmb3JtZXIgYW5kIHJldHVybnMgYVxuICogdHJhbnNmb3JtZXIgYW5kIGNhbiBiZSBjb21wb3NlZCBkaXJlY3RseS5cbiAqXG4gKiBBIHRyYW5zZm9ybWVyIGlzIGFuIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIGEgMi1hcml0eSByZWR1Y2luZyBpdGVyYXRvclxuICogZnVuY3Rpb24sIHN0ZXAsIDAtYXJpdHkgaW5pdGlhbCB2YWx1ZSBmdW5jdGlvbiwgaW5pdCwgYW5kIDEtYXJpdHkgcmVzdWx0XG4gKiBleHRyYWN0aW9uIGZ1bmN0aW9uLCByZXN1bHQuIFRoZSBzdGVwIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIGl0ZXJhdG9yXG4gKiBmdW5jdGlvbiBpbiByZWR1Y2UuIFRoZSByZXN1bHQgZnVuY3Rpb24gaXMgdXNlZCB0byBjb252ZXJ0IHRoZSBmaW5hbFxuICogYWNjdW11bGF0b3IgaW50byB0aGUgcmV0dXJuIHR5cGUgYW5kIGluIG1vc3QgY2FzZXMgaXNcbiAqIFtgUi5pZGVudGl0eWBdKCNpZGVudGl0eSkuIFRoZSBpbml0IGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgYW5cbiAqIGluaXRpYWwgYWNjdW11bGF0b3IsIGJ1dCBpcyBpZ25vcmVkIGJ5IHRyYW5zZHVjZS5cbiAqXG4gKiBUaGUgaXRlcmF0aW9uIGlzIHBlcmZvcm1lZCB3aXRoIFtgUi5yZWR1Y2VgXSgjcmVkdWNlKSBhZnRlciBpbml0aWFsaXppbmcgdGhlIHRyYW5zZHVjZXIuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTIuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGMgLT4gYykgLT4gKChhLCBiKSAtPiBhKSAtPiBhIC0+IFtiXSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB4ZiBUaGUgdHJhbnNkdWNlciBmdW5jdGlvbi4gUmVjZWl2ZXMgYSB0cmFuc2Zvcm1lciBhbmQgcmV0dXJucyBhIHRyYW5zZm9ybWVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLiBSZWNlaXZlcyB0d28gdmFsdWVzLCB0aGUgYWNjdW11bGF0b3IgYW5kIHRoZVxuICogICAgICAgIGN1cnJlbnQgZWxlbWVudCBmcm9tIHRoZSBhcnJheS4gV3JhcHBlZCBhcyB0cmFuc2Zvcm1lciwgaWYgbmVjZXNzYXJ5LCBhbmQgdXNlZCB0b1xuICogICAgICAgIGluaXRpYWxpemUgdGhlIHRyYW5zZHVjZXJcbiAqIEBwYXJhbSB7Kn0gYWNjIFRoZSBpbml0aWFsIGFjY3VtdWxhdG9yIHZhbHVlLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQHNlZSBSLnJlZHVjZSwgUi5yZWR1Y2VkLCBSLmludG9cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbnVtYmVycyA9IFsxLCAyLCAzLCA0XTtcbiAqICAgICAgdmFyIHRyYW5zZHVjZXIgPSBSLmNvbXBvc2UoUi5tYXAoUi5hZGQoMSkpLCBSLnRha2UoMikpO1xuICogICAgICBSLnRyYW5zZHVjZSh0cmFuc2R1Y2VyLCBSLmZsaXAoUi5hcHBlbmQpLCBbXSwgbnVtYmVycyk7IC8vPT4gWzIsIDNdXG4gKlxuICogICAgICB2YXIgaXNPZGQgPSAoeCkgPT4geCAlIDIgPT09IDE7XG4gKiAgICAgIHZhciBmaXJzdE9kZFRyYW5zZHVjZXIgPSBSLmNvbXBvc2UoUi5maWx0ZXIoaXNPZGQpLCBSLnRha2UoMSkpO1xuICogICAgICBSLnRyYW5zZHVjZShmaXJzdE9kZFRyYW5zZHVjZXIsIFIuZmxpcChSLmFwcGVuZCksIFtdLCBSLnJhbmdlKDAsIDEwMCkpOyAvLz0+IFsxXVxuICovXG52YXIgdHJhbnNkdWNlID0gLyojX19QVVJFX18qL2N1cnJ5Tig0LCBmdW5jdGlvbiB0cmFuc2R1Y2UoeGYsIGZuLCBhY2MsIGxpc3QpIHtcbiAgcmV0dXJuIF9yZWR1Y2UoeGYodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nID8gX3h3cmFwKGZuKSA6IGZuKSwgYWNjLCBsaXN0KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdHJhbnNkdWNlOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5cbi8qKlxuICogVHJhbnNwb3NlcyB0aGUgcm93cyBhbmQgY29sdW1ucyBvZiBhIDJEIGxpc3QuXG4gKiBXaGVuIHBhc3NlZCBhIGxpc3Qgb2YgYG5gIGxpc3RzIG9mIGxlbmd0aCBgeGAsXG4gKiByZXR1cm5zIGEgbGlzdCBvZiBgeGAgbGlzdHMgb2YgbGVuZ3RoIGBuYC5cbiAqXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW1thXV0gLT4gW1thXV1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgQSAyRCBsaXN0XG4gKiBAcmV0dXJuIHtBcnJheX0gQSAyRCBsaXN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50cmFuc3Bvc2UoW1sxLCAnYSddLCBbMiwgJ2InXSwgWzMsICdjJ11dKSAvLz0+IFtbMSwgMiwgM10sIFsnYScsICdiJywgJ2MnXV1cbiAqICAgICAgUi50cmFuc3Bvc2UoW1sxLCAyLCAzXSwgWydhJywgJ2InLCAnYyddXSkgLy89PiBbWzEsICdhJ10sIFsyLCAnYiddLCBbMywgJ2MnXV1cbiAqXG4gKiAgICAgIC8vIElmIHNvbWUgb2YgdGhlIHJvd3MgYXJlIHNob3J0ZXIgdGhhbiB0aGUgZm9sbG93aW5nIHJvd3MsIHRoZWlyIGVsZW1lbnRzIGFyZSBza2lwcGVkOlxuICogICAgICBSLnRyYW5zcG9zZShbWzEwLCAxMV0sIFsyMF0sIFtdLCBbMzAsIDMxLCAzMl1dKSAvLz0+IFtbMTAsIDIwLCAzMF0sIFsxMSwgMzFdLCBbMzJdXVxuICogQHN5bWIgUi50cmFuc3Bvc2UoW1thXSwgW2JdLCBbY11dKSA9IFthLCBiLCBjXVxuICogQHN5bWIgUi50cmFuc3Bvc2UoW1thLCBiXSwgW2MsIGRdXSkgPSBbW2EsIGNdLCBbYiwgZF1dXG4gKiBAc3ltYiBSLnRyYW5zcG9zZShbW2EsIGJdLCBbY11dKSA9IFtbYSwgY10sIFtiXV1cbiAqL1xudmFyIHRyYW5zcG9zZSA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIHRyYW5zcG9zZShvdXRlcmxpc3QpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChpIDwgb3V0ZXJsaXN0Lmxlbmd0aCkge1xuICAgIHZhciBpbm5lcmxpc3QgPSBvdXRlcmxpc3RbaV07XG4gICAgdmFyIGogPSAwO1xuICAgIHdoaWxlIChqIDwgaW5uZXJsaXN0Lmxlbmd0aCkge1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHRbal0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJlc3VsdFtqXSA9IFtdO1xuICAgICAgfVxuICAgICAgcmVzdWx0W2pdLnB1c2goaW5uZXJsaXN0W2pdKTtcbiAgICAgIGogKz0gMTtcbiAgICB9XG4gICAgaSArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHRyYW5zcG9zZTsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuaW1wb3J0IG1hcCBmcm9tICcuL21hcCc7XG5pbXBvcnQgc2VxdWVuY2UgZnJvbSAnLi9zZXF1ZW5jZSc7XG5cbi8qKlxuICogTWFwcyBhbiBbQXBwbGljYXRpdmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXBwbGljYXRpdmUpLXJldHVybmluZ1xuICogZnVuY3Rpb24gb3ZlciBhIFtUcmF2ZXJzYWJsZV0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCN0cmF2ZXJzYWJsZSksXG4gKiB0aGVuIHVzZXMgW2BzZXF1ZW5jZWBdKCNzZXF1ZW5jZSkgdG8gdHJhbnNmb3JtIHRoZSByZXN1bHRpbmcgVHJhdmVyc2FibGUgb2YgQXBwbGljYXRpdmVcbiAqIGludG8gYW4gQXBwbGljYXRpdmUgb2YgVHJhdmVyc2FibGUuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHRyYXZlcnNlYCBtZXRob2Qgb2YgdGhlIHRoaXJkIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChBcHBsaWNhdGl2ZSBmLCBUcmF2ZXJzYWJsZSB0KSA9PiAoYSAtPiBmIGEpIC0+IChhIC0+IGYgYikgLT4gdCBhIC0+IGYgKHQgYilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9mXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gKiBAcGFyYW0geyp9IHRyYXZlcnNhYmxlXG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLnNlcXVlbmNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gUmV0dXJucyBgTm90aGluZ2AgaWYgdGhlIGdpdmVuIGRpdmlzb3IgaXMgYDBgXG4gKiAgICAgIHNhZmVEaXYgPSBuID0+IGQgPT4gZCA9PT0gMCA/IE5vdGhpbmcoKSA6IEp1c3QobiAvIGQpXG4gKlxuICogICAgICBSLnRyYXZlcnNlKE1heWJlLm9mLCBzYWZlRGl2KDEwKSwgWzIsIDQsIDVdKTsgLy89PiBKdXN0KFs1LCAyLjUsIDJdKVxuICogICAgICBSLnRyYXZlcnNlKE1heWJlLm9mLCBzYWZlRGl2KDEwKSwgWzIsIDAsIDVdKTsgLy89PiBOb3RoaW5nXG4gKi9cbnZhciB0cmF2ZXJzZSA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIHRyYXZlcnNlKG9mLCBmLCB0cmF2ZXJzYWJsZSkge1xuICByZXR1cm4gdHlwZW9mIHRyYXZlcnNhYmxlWydmYW50YXN5LWxhbmQvdHJhdmVyc2UnXSA9PT0gJ2Z1bmN0aW9uJyA/IHRyYXZlcnNhYmxlWydmYW50YXN5LWxhbmQvdHJhdmVyc2UnXShmLCBvZikgOiBzZXF1ZW5jZShvZiwgbWFwKGYsIHRyYXZlcnNhYmxlKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHRyYXZlcnNlOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5cbnZhciB3cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgKyAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjgnICsgJ1xcdTIwMjlcXHVGRUZGJztcbnZhciB6ZXJvV2lkdGggPSAnXFx1MjAwYic7XG52YXIgaGFzUHJvdG9UcmltID0gdHlwZW9mIFN0cmluZy5wcm90b3R5cGUudHJpbSA9PT0gJ2Z1bmN0aW9uJztcbi8qKlxuICogUmVtb3ZlcyAoc3RyaXBzKSB3aGl0ZXNwYWNlIGZyb20gYm90aCBlbmRzIG9mIHRoZSBzdHJpbmcuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNi4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB0cmltLlxuICogQHJldHVybiB7U3RyaW5nfSBUcmltbWVkIHZlcnNpb24gb2YgYHN0cmAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50cmltKCcgICB4eXogICcpOyAvLz0+ICd4eXonXG4gKiAgICAgIFIubWFwKFIudHJpbSwgUi5zcGxpdCgnLCcsICd4LCB5LCB6JykpOyAvLz0+IFsneCcsICd5JywgJ3onXVxuICovXG52YXIgX3RyaW0gPSAhaGFzUHJvdG9UcmltIHx8IC8qI19fUFVSRV9fKi93cy50cmltKCkgfHwgISAvKiNfX1BVUkVfXyovemVyb1dpZHRoLnRyaW0oKSA/IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHZhciBiZWdpblJ4ID0gbmV3IFJlZ0V4cCgnXlsnICsgd3MgKyAnXVsnICsgd3MgKyAnXSonKTtcbiAgdmFyIGVuZFJ4ID0gbmV3IFJlZ0V4cCgnWycgKyB3cyArICddWycgKyB3cyArICddKiQnKTtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGJlZ2luUngsICcnKS5yZXBsYWNlKGVuZFJ4LCAnJyk7XG59IDogZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci50cmltKCk7XG59O1xudmFyIHRyaW0gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShfdHJpbSk7XG5leHBvcnQgZGVmYXVsdCB0cmltOyIsImltcG9ydCBfYXJpdHkgZnJvbSAnLi9pbnRlcm5hbC9fYXJpdHknO1xuaW1wb3J0IF9jb25jYXQgZnJvbSAnLi9pbnRlcm5hbC9fY29uY2F0JztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogYHRyeUNhdGNoYCB0YWtlcyB0d28gZnVuY3Rpb25zLCBhIGB0cnllcmAgYW5kIGEgYGNhdGNoZXJgLiBUaGUgcmV0dXJuZWRcbiAqIGZ1bmN0aW9uIGV2YWx1YXRlcyB0aGUgYHRyeWVyYDsgaWYgaXQgZG9lcyBub3QgdGhyb3csIGl0IHNpbXBseSByZXR1cm5zIHRoZVxuICogcmVzdWx0LiBJZiB0aGUgYHRyeWVyYCAqZG9lcyogdGhyb3csIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBldmFsdWF0ZXMgdGhlXG4gKiBgY2F0Y2hlcmAgZnVuY3Rpb24gYW5kIHJldHVybnMgaXRzIHJlc3VsdC4gTm90ZSB0aGF0IGZvciBlZmZlY3RpdmVcbiAqIGNvbXBvc2l0aW9uIHdpdGggdGhpcyBmdW5jdGlvbiwgYm90aCB0aGUgYHRyeWVyYCBhbmQgYGNhdGNoZXJgIGZ1bmN0aW9uc1xuICogbXVzdCByZXR1cm4gdGhlIHNhbWUgdHlwZSBvZiByZXN1bHRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIwLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoLi4ueCAtPiBhKSAtPiAoKGUsIC4uLngpIC0+IGEpIC0+ICguLi54IC0+IGEpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cnllciBUaGUgZnVuY3Rpb24gdGhhdCBtYXkgdGhyb3cuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYXRjaGVyIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXZhbHVhdGVkIGlmIGB0cnllcmAgdGhyb3dzLlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHRoYXQgd2lsbCBjYXRjaCBleGNlcHRpb25zIGFuZCBzZW5kIHRoZW4gdG8gdGhlIGNhdGNoZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50cnlDYXRjaChSLnByb3AoJ3gnKSwgUi5GKSh7eDogdHJ1ZX0pOyAvLz0+IHRydWVcbiAqICAgICAgUi50cnlDYXRjaChSLnByb3AoJ3gnKSwgUi5GKShudWxsKTsgICAgICAvLz0+IGZhbHNlXG4gKi9cbnZhciB0cnlDYXRjaCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF90cnlDYXRjaCh0cnllciwgY2F0Y2hlcikge1xuICByZXR1cm4gX2FyaXR5KHRyeWVyLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdHJ5ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gY2F0Y2hlci5hcHBseSh0aGlzLCBfY29uY2F0KFtlXSwgYXJndW1lbnRzKSk7XG4gICAgfVxuICB9KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdHJ5Q2F0Y2g7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcblxuLyoqXG4gKiBHaXZlcyBhIHNpbmdsZS13b3JkIHN0cmluZyBkZXNjcmlwdGlvbiBvZiB0aGUgKG5hdGl2ZSkgdHlwZSBvZiBhIHZhbHVlLFxuICogcmV0dXJuaW5nIHN1Y2ggYW5zd2VycyBhcyAnT2JqZWN0JywgJ051bWJlcicsICdBcnJheScsIG9yICdOdWxsJy4gRG9lcyBub3RcbiAqIGF0dGVtcHQgdG8gZGlzdGluZ3Vpc2ggdXNlciBPYmplY3QgdHlwZXMgYW55IGZ1cnRoZXIsIHJlcG9ydGluZyB0aGVtIGFsbCBhc1xuICogJ09iamVjdCcuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgVHlwZVxuICogQHNpZyAoKiAtPiB7Kn0pIC0+IFN0cmluZ1xuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnR5cGUoe30pOyAvLz0+IFwiT2JqZWN0XCJcbiAqICAgICAgUi50eXBlKDEpOyAvLz0+IFwiTnVtYmVyXCJcbiAqICAgICAgUi50eXBlKGZhbHNlKTsgLy89PiBcIkJvb2xlYW5cIlxuICogICAgICBSLnR5cGUoJ3MnKTsgLy89PiBcIlN0cmluZ1wiXG4gKiAgICAgIFIudHlwZShudWxsKTsgLy89PiBcIk51bGxcIlxuICogICAgICBSLnR5cGUoW10pOyAvLz0+IFwiQXJyYXlcIlxuICogICAgICBSLnR5cGUoL1tBLXpdLyk7IC8vPT4gXCJSZWdFeHBcIlxuICogICAgICBSLnR5cGUoKCkgPT4ge30pOyAvLz0+IFwiRnVuY3Rpb25cIlxuICogICAgICBSLnR5cGUodW5kZWZpbmVkKTsgLy89PiBcIlVuZGVmaW5lZFwiXG4gKi9cbnZhciB0eXBlID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gdHlwZSh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gbnVsbCA/ICdOdWxsJyA6IHZhbCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHR5cGU7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGBmbmAsIHdoaWNoIHRha2VzIGEgc2luZ2xlIGFycmF5IGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhXG4gKiBmdW5jdGlvbiB3aGljaDpcbiAqXG4gKiAgIC0gdGFrZXMgYW55IG51bWJlciBvZiBwb3NpdGlvbmFsIGFyZ3VtZW50cztcbiAqICAgLSBwYXNzZXMgdGhlc2UgYXJndW1lbnRzIHRvIGBmbmAgYXMgYW4gYXJyYXk7IGFuZFxuICogICAtIHJldHVybnMgdGhlIHJlc3VsdC5cbiAqXG4gKiBJbiBvdGhlciB3b3JkcywgYFIudW5hcHBseWAgZGVyaXZlcyBhIHZhcmlhZGljIGZ1bmN0aW9uIGZyb20gYSBmdW5jdGlvbiB3aGljaFxuICogdGFrZXMgYW4gYXJyYXkuIGBSLnVuYXBwbHlgIGlzIHRoZSBpbnZlcnNlIG9mIFtgUi5hcHBseWBdKCNhcHBseSkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKFsqLi4uXSAtPiBhKSAtPiAoKi4uLiAtPiBhKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSBSLmFwcGx5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51bmFwcGx5KEpTT04uc3RyaW5naWZ5KSgxLCAyLCAzKTsgLy89PiAnWzEsMiwzXSdcbiAqIEBzeW1iIFIudW5hcHBseShmKShhLCBiKSA9IGYoW2EsIGJdKVxuICovXG52YXIgdW5hcHBseSA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIHVuYXBwbHkoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4oQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG4gIH07XG59KTtcbmV4cG9ydCBkZWZhdWx0IHVuYXBwbHk7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBuQXJ5IGZyb20gJy4vbkFyeSc7XG5cbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiBvZiBhbnkgYXJpdHkgKGluY2x1ZGluZyBudWxsYXJ5KSBpbiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0c1xuICogZXhhY3RseSAxIHBhcmFtZXRlci4gQW55IGV4dHJhbmVvdXMgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlXG4gKiBzdXBwbGllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKiAtPiBiKSAtPiAoYSAtPiBiKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgYGZuYC4gVGhlIG5ldyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIG9mXG4gKiAgICAgICAgIGFyaXR5IDEuXG4gKiBAc2VlIFIuYmluYXJ5LCBSLm5BcnlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgdGFrZXNUd29BcmdzID0gZnVuY3Rpb24oYSwgYikge1xuICogICAgICAgIHJldHVybiBbYSwgYl07XG4gKiAgICAgIH07XG4gKiAgICAgIHRha2VzVHdvQXJncy5sZW5ndGg7IC8vPT4gMlxuICogICAgICB0YWtlc1R3b0FyZ3MoMSwgMik7IC8vPT4gWzEsIDJdXG4gKlxuICogICAgICB2YXIgdGFrZXNPbmVBcmcgPSBSLnVuYXJ5KHRha2VzVHdvQXJncyk7XG4gKiAgICAgIHRha2VzT25lQXJnLmxlbmd0aDsgLy89PiAxXG4gKiAgICAgIC8vIE9ubHkgMSBhcmd1bWVudCBpcyBwYXNzZWQgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAqICAgICAgdGFrZXNPbmVBcmcoMSwgMik7IC8vPT4gWzEsIHVuZGVmaW5lZF1cbiAqIEBzeW1iIFIudW5hcnkoZikoYSwgYiwgYykgPSBmKGEpXG4gKi9cbnZhciB1bmFyeSA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIHVuYXJ5KGZuKSB7XG4gIHJldHVybiBuQXJ5KDEsIGZuKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdW5hcnk7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBjdXJyeU4gZnJvbSAnLi9jdXJyeU4nO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiBvZiBhcml0eSBgbmAgZnJvbSBhIChtYW51YWxseSkgY3VycmllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgTnVtYmVyIC0+IChhIC0+IGIpIC0+IChhIC0+IGMpXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBmb3IgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHVuY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24uXG4gKiBAc2VlIFIuY3VycnlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYWRkRm91ciA9IGEgPT4gYiA9PiBjID0+IGQgPT4gYSArIGIgKyBjICsgZDtcbiAqXG4gKiAgICAgIHZhciB1bmN1cnJpZWRBZGRGb3VyID0gUi51bmN1cnJ5Tig0LCBhZGRGb3VyKTtcbiAqICAgICAgdW5jdXJyaWVkQWRkRm91cigxLCAyLCAzLCA0KTsgLy89PiAxMFxuICovXG52YXIgdW5jdXJyeU4gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiB1bmN1cnJ5TihkZXB0aCwgZm4pIHtcbiAgcmV0dXJuIGN1cnJ5TihkZXB0aCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50RGVwdGggPSAxO1xuICAgIHZhciB2YWx1ZSA9IGZuO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciBlbmRJZHg7XG4gICAgd2hpbGUgKGN1cnJlbnREZXB0aCA8PSBkZXB0aCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVuZElkeCA9IGN1cnJlbnREZXB0aCA9PT0gZGVwdGggPyBhcmd1bWVudHMubGVuZ3RoIDogaWR4ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIGlkeCwgZW5kSWR4KSk7XG4gICAgICBjdXJyZW50RGVwdGggKz0gMTtcbiAgICAgIGlkeCA9IGVuZElkeDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdW5jdXJyeU47IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBCdWlsZHMgYSBsaXN0IGZyb20gYSBzZWVkIHZhbHVlLiBBY2NlcHRzIGFuIGl0ZXJhdG9yIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zXG4gKiBlaXRoZXIgZmFsc2UgdG8gc3RvcCBpdGVyYXRpb24gb3IgYW4gYXJyYXkgb2YgbGVuZ3RoIDIgY29udGFpbmluZyB0aGUgdmFsdWVcbiAqIHRvIGFkZCB0byB0aGUgcmVzdWx0aW5nIGxpc3QgYW5kIHRoZSBzZWVkIHRvIGJlIHVzZWQgaW4gdGhlIG5leHQgY2FsbCB0byB0aGVcbiAqIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyBvbmUgYXJndW1lbnQ6ICooc2VlZCkqLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IFtiXSkgLT4gKiAtPiBbYl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gcmVjZWl2ZXMgb25lIGFyZ3VtZW50LCBgc2VlZGAsIGFuZCByZXR1cm5zXG4gKiAgICAgICAgZWl0aGVyIGZhbHNlIHRvIHF1aXQgaXRlcmF0aW9uIG9yIGFuIGFycmF5IG9mIGxlbmd0aCB0d28gdG8gcHJvY2VlZC4gVGhlIGVsZW1lbnRcbiAqICAgICAgICBhdCBpbmRleCAwIG9mIHRoaXMgYXJyYXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgcmVzdWx0aW5nIGFycmF5LCBhbmQgdGhlIGVsZW1lbnRcbiAqICAgICAgICBhdCBpbmRleCAxIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBuZXh0IGNhbGwgdG8gYGZuYC5cbiAqIEBwYXJhbSB7Kn0gc2VlZCBUaGUgc2VlZCB2YWx1ZS5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZmluYWwgbGlzdC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZiA9IG4gPT4gbiA+IDUwID8gZmFsc2UgOiBbLW4sIG4gKyAxMF07XG4gKiAgICAgIFIudW5mb2xkKGYsIDEwKTsgLy89PiBbLTEwLCAtMjAsIC0zMCwgLTQwLCAtNTBdXG4gKiBAc3ltYiBSLnVuZm9sZChmLCB4KSA9IFtmKHgpWzBdLCBmKGYoeClbMV0pWzBdLCBmKGYoZih4KVsxXSlbMV0pWzBdLCAuLi5dXG4gKi9cbnZhciB1bmZvbGQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiB1bmZvbGQoZm4sIHNlZWQpIHtcbiAgdmFyIHBhaXIgPSBmbihzZWVkKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAocGFpciAmJiBwYWlyLmxlbmd0aCkge1xuICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHBhaXJbMF07XG4gICAgcGFpciA9IGZuKHBhaXJbMV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHVuZm9sZDsiLCJpbXBvcnQgX2NvbmNhdCBmcm9tICcuL2ludGVybmFsL19jb25jYXQnO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBjb21wb3NlIGZyb20gJy4vY29tcG9zZSc7XG5pbXBvcnQgdW5pcSBmcm9tICcuL3VuaXEnO1xuXG4vKipcbiAqIENvbWJpbmVzIHR3byBsaXN0cyBpbnRvIGEgc2V0IChpLmUuIG5vIGR1cGxpY2F0ZXMpIGNvbXBvc2VkIG9mIHRoZSBlbGVtZW50c1xuICogb2YgZWFjaCBsaXN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIFsqXSAtPiBbKl0gLT4gWypdXG4gKiBAcGFyYW0ge0FycmF5fSBhcyBUaGUgZmlyc3QgbGlzdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGJzIFRoZSBzZWNvbmQgbGlzdC5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZmlyc3QgYW5kIHNlY29uZCBsaXN0cyBjb25jYXRlbmF0ZWQsIHdpdGhcbiAqICAgICAgICAgZHVwbGljYXRlcyByZW1vdmVkLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudW5pb24oWzEsIDIsIDNdLCBbMiwgMywgNF0pOyAvLz0+IFsxLCAyLCAzLCA0XVxuICovXG52YXIgdW5pb24gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL2NvbXBvc2UodW5pcSwgX2NvbmNhdCkpO1xuZXhwb3J0IGRlZmF1bHQgdW5pb247IiwiaW1wb3J0IF9jb25jYXQgZnJvbSAnLi9pbnRlcm5hbC9fY29uY2F0JztcbmltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgdW5pcVdpdGggZnJvbSAnLi91bmlxV2l0aCc7XG5cbi8qKlxuICogQ29tYmluZXMgdHdvIGxpc3RzIGludG8gYSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgY29tcG9zZWQgb2YgdGhlIGVsZW1lbnRzXG4gKiBvZiBlYWNoIGxpc3QuIER1cGxpY2F0aW9uIGlzIGRldGVybWluZWQgYWNjb3JkaW5nIHRvIHRoZSB2YWx1ZSByZXR1cm5lZCBieVxuICogYXBwbHlpbmcgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSB0byB0d28gbGlzdCBlbGVtZW50cy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyAoKGEsIGEpIC0+IEJvb2xlYW4pIC0+IFsqXSAtPiBbKl0gLT4gWypdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHVzZWQgdG8gdGVzdCB3aGV0aGVyIHR3byBpdGVtcyBhcmUgZXF1YWwuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgbGlzdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgbGlzdC5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZmlyc3QgYW5kIHNlY29uZCBsaXN0cyBjb25jYXRlbmF0ZWQsIHdpdGhcbiAqICAgICAgICAgZHVwbGljYXRlcyByZW1vdmVkLlxuICogQHNlZSBSLnVuaW9uXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGwxID0gW3thOiAxfSwge2E6IDJ9XTtcbiAqICAgICAgdmFyIGwyID0gW3thOiAxfSwge2E6IDR9XTtcbiAqICAgICAgUi51bmlvbldpdGgoUi5lcUJ5KFIucHJvcCgnYScpKSwgbDEsIGwyKTsgLy89PiBbe2E6IDF9LCB7YTogMn0sIHthOiA0fV1cbiAqL1xudmFyIHVuaW9uV2l0aCA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIHVuaW9uV2l0aChwcmVkLCBsaXN0MSwgbGlzdDIpIHtcbiAgcmV0dXJuIHVuaXFXaXRoKHByZWQsIF9jb25jYXQobGlzdDEsIGxpc3QyKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHVuaW9uV2l0aDsiLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eSc7XG5pbXBvcnQgdW5pcUJ5IGZyb20gJy4vdW5pcUJ5JztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyBvbmx5IG9uZSBjb3B5IG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgb3JpZ2luYWxcbiAqIGxpc3QuIFtgUi5lcXVhbHNgXSgjZXF1YWxzKSBpcyB1c2VkIHRvIGRldGVybWluZSBlcXVhbGl0eS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIHVuaXF1ZSBpdGVtcy5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnVuaXEoWzEsIDEsIDIsIDFdKTsgLy89PiBbMSwgMl1cbiAqICAgICAgUi51bmlxKFsxLCAnMSddKTsgICAgIC8vPT4gWzEsICcxJ11cbiAqICAgICAgUi51bmlxKFtbNDJdLCBbNDJdXSk7IC8vPT4gW1s0Ml1dXG4gKi9cbnZhciB1bmlxID0gLyojX19QVVJFX18qL3VuaXFCeShpZGVudGl0eSk7XG5leHBvcnQgZGVmYXVsdCB1bmlxOyIsImltcG9ydCBfU2V0IGZyb20gJy4vaW50ZXJuYWwvX1NldCc7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIG9ubHkgb25lIGNvcHkgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBvcmlnaW5hbFxuICogbGlzdCwgYmFzZWQgdXBvbiB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgYXBwbHlpbmcgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIHRvXG4gKiBlYWNoIGxpc3QgZWxlbWVudC4gUHJlZmVycyB0aGUgZmlyc3QgaXRlbSBpZiB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gcHJvZHVjZXNcbiAqIHRoZSBzYW1lIHZhbHVlIG9uIHR3byBpdGVtcy4gW2BSLmVxdWFsc2BdKCNlcXVhbHMpIGlzIHVzZWQgZm9yIGNvbXBhcmlzb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gYikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiB1c2VkIHRvIHByb2R1Y2UgYSB2YWx1ZSB0byB1c2UgZHVyaW5nIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgdW5pcXVlIGl0ZW1zLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudW5pcUJ5KE1hdGguYWJzLCBbLTEsIC01LCAyLCAxMCwgMSwgMl0pOyAvLz0+IFstMSwgLTUsIDIsIDEwXVxuICovXG52YXIgdW5pcUJ5ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gdW5pcUJ5KGZuLCBsaXN0KSB7XG4gIHZhciBzZXQgPSBuZXcgX1NldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgYXBwbGllZEl0ZW0sIGl0ZW07XG5cbiAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgaXRlbSA9IGxpc3RbaWR4XTtcbiAgICBhcHBsaWVkSXRlbSA9IGZuKGl0ZW0pO1xuICAgIGlmIChzZXQuYWRkKGFwcGxpZWRJdGVtKSkge1xuICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHVuaXFCeTsiLCJpbXBvcnQgX2NvbnRhaW5zV2l0aCBmcm9tICcuL2ludGVybmFsL19jb250YWluc1dpdGgnO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyBvbmx5IG9uZSBjb3B5IG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgb3JpZ2luYWxcbiAqIGxpc3QsIGJhc2VkIHVwb24gdGhlIHZhbHVlIHJldHVybmVkIGJ5IGFwcGx5aW5nIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgdG9cbiAqIHR3byBsaXN0IGVsZW1lbnRzLiBQcmVmZXJzIHRoZSBmaXJzdCBpdGVtIGlmIHR3byBpdGVtcyBjb21wYXJlIGVxdWFsIGJhc2VkXG4gKiBvbiB0aGUgcHJlZGljYXRlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhLCBhKSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHVzZWQgdG8gdGVzdCB3aGV0aGVyIHR3byBpdGVtcyBhcmUgZXF1YWwuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiB1bmlxdWUgaXRlbXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHN0ckVxID0gUi5lcUJ5KFN0cmluZyk7XG4gKiAgICAgIFIudW5pcVdpdGgoc3RyRXEpKFsxLCAnMScsIDIsIDFdKTsgLy89PiBbMSwgMl1cbiAqICAgICAgUi51bmlxV2l0aChzdHJFcSkoW3t9LCB7fV0pOyAgICAgICAvLz0+IFt7fV1cbiAqICAgICAgUi51bmlxV2l0aChzdHJFcSkoWzEsICcxJywgMV0pOyAgICAvLz0+IFsxXVxuICogICAgICBSLnVuaXFXaXRoKHN0ckVxKShbJzEnLCAxLCAxXSk7ICAgIC8vPT4gWycxJ11cbiAqL1xudmFyIHVuaXFXaXRoID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gdW5pcVdpdGgocHJlZCwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpdGVtO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgaXRlbSA9IGxpc3RbaWR4XTtcbiAgICBpZiAoIV9jb250YWluc1dpdGgocHJlZCwgaXRlbSwgcmVzdWx0KSkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gaXRlbTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdW5pcVdpdGg7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLyoqXG4gKiBUZXN0cyB0aGUgZmluYWwgYXJndW1lbnQgYnkgcGFzc2luZyBpdCB0byB0aGUgZ2l2ZW4gcHJlZGljYXRlIGZ1bmN0aW9uLiBJZlxuICogdGhlIHByZWRpY2F0ZSBpcyBub3Qgc2F0aXNmaWVkLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHJlc3VsdCBvZlxuICogY2FsbGluZyB0aGUgYHdoZW5GYWxzZUZuYCBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50LiBJZiB0aGUgcHJlZGljYXRlXG4gKiBpcyBzYXRpc2ZpZWQsIHRoZSBhcmd1bWVudCBpcyByZXR1cm5lZCBhcyBpcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOC4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gKGEgLT4gYSkgLT4gYSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkICAgICAgICBBIHByZWRpY2F0ZSBmdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gd2hlbkZhbHNlRm4gQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYHByZWRgIGV2YWx1YXRlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBmYWxzeSB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gICAgICAgIHggICAgICAgICAgIEFuIG9iamVjdCB0byB0ZXN0IHdpdGggdGhlIGBwcmVkYCBmdW5jdGlvbiBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgdG8gYHdoZW5GYWxzZUZuYCBpZiBuZWNlc3NhcnkuXG4gKiBAcmV0dXJuIHsqfSBFaXRoZXIgYHhgIG9yIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYHhgIHRvIGB3aGVuRmFsc2VGbmAuXG4gKiBAc2VlIFIuaWZFbHNlLCBSLndoZW5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBsZXQgc2FmZUluYyA9IFIudW5sZXNzKFIuaXNOaWwsIFIuaW5jKTtcbiAqICAgICAgc2FmZUluYyhudWxsKTsgLy89PiBudWxsXG4gKiAgICAgIHNhZmVJbmMoMSk7IC8vPT4gMlxuICovXG52YXIgdW5sZXNzID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gdW5sZXNzKHByZWQsIHdoZW5GYWxzZUZuLCB4KSB7XG4gIHJldHVybiBwcmVkKHgpID8geCA6IHdoZW5GYWxzZUZuKHgpO1xufSk7XG5leHBvcnQgZGVmYXVsdCB1bmxlc3M7IiwiaW1wb3J0IF9pZGVudGl0eSBmcm9tICcuL2ludGVybmFsL19pZGVudGl0eSc7XG5pbXBvcnQgY2hhaW4gZnJvbSAnLi9jaGFpbic7XG5cbi8qKlxuICogU2hvcnRoYW5kIGZvciBgUi5jaGFpbihSLmlkZW50aXR5KWAsIHdoaWNoIHJlbW92ZXMgb25lIGxldmVsIG9mIG5lc3RpbmcgZnJvbVxuICogYW55IFtDaGFpbl0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjaGFpbikuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMy4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBDaGFpbiBjID0+IGMgKGMgYSkgLT4gYyBhXG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIuZmxhdHRlbiwgUi5jaGFpblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudW5uZXN0KFsxLCBbMl0sIFtbM11dXSk7IC8vPT4gWzEsIDIsIFszXV1cbiAqICAgICAgUi51bm5lc3QoW1sxLCAyXSwgWzMsIDRdLCBbNSwgNl1dKTsgLy89PiBbMSwgMiwgMywgNCwgNSwgNl1cbiAqL1xudmFyIHVubmVzdCA9IC8qI19fUFVSRV9fKi9jaGFpbihfaWRlbnRpdHkpO1xuZXhwb3J0IGRlZmF1bHQgdW5uZXN0OyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8qKlxuICogVGFrZXMgYSBwcmVkaWNhdGUsIGEgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24sIGFuZCBhbiBpbml0aWFsIHZhbHVlLFxuICogYW5kIHJldHVybnMgYSB2YWx1ZSBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICogSXQgZG9lcyBzbyBieSBhcHBseWluZyB0aGUgdHJhbnNmb3JtYXRpb24gdW50aWwgdGhlIHByZWRpY2F0ZSBpcyBzYXRpc2ZpZWQsXG4gKiBhdCB3aGljaCBwb2ludCBpdCByZXR1cm5zIHRoZSBzYXRpc2ZhY3RvcnkgdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjAuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IChhIC0+IGEpIC0+IGEgLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSBmdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IGluaXQgSW5pdGlhbCB2YWx1ZVxuICogQHJldHVybiB7Kn0gRmluYWwgdmFsdWUgdGhhdCBzYXRpc2ZpZXMgcHJlZGljYXRlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51bnRpbChSLmd0KFIuX18sIDEwMCksIFIubXVsdGlwbHkoMikpKDEpIC8vID0+IDEyOFxuICovXG52YXIgdW50aWwgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiB1bnRpbChwcmVkLCBmbiwgaW5pdCkge1xuICB2YXIgdmFsID0gaW5pdDtcbiAgd2hpbGUgKCFwcmVkKHZhbCkpIHtcbiAgICB2YWwgPSBmbih2YWwpO1xuICB9XG4gIHJldHVybiB2YWw7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHVudGlsOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgYWRqdXN0IGZyb20gJy4vYWRqdXN0JztcbmltcG9ydCBhbHdheXMgZnJvbSAnLi9hbHdheXMnO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgY29weSBvZiB0aGUgYXJyYXkgd2l0aCB0aGUgZWxlbWVudCBhdCB0aGUgcHJvdmlkZWQgaW5kZXhcbiAqIHJlcGxhY2VkIHdpdGggdGhlIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBhIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBpZHggVGhlIGluZGV4IHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7Kn0geCBUaGUgdmFsdWUgdG8gZXhpc3QgYXQgdGhlIGdpdmVuIGluZGV4IG9mIHRoZSByZXR1cm5lZCBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJndW1lbnRzfSBsaXN0IFRoZSBzb3VyY2UgYXJyYXktbGlrZSBvYmplY3QgdG8gYmUgdXBkYXRlZC5cbiAqIEByZXR1cm4ge0FycmF5fSBBIGNvcHkgb2YgYGxpc3RgIHdpdGggdGhlIHZhbHVlIGF0IGluZGV4IGBpZHhgIHJlcGxhY2VkIHdpdGggYHhgLlxuICogQHNlZSBSLmFkanVzdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudXBkYXRlKDEsIDExLCBbMCwgMSwgMl0pOyAgICAgLy89PiBbMCwgMTEsIDJdXG4gKiAgICAgIFIudXBkYXRlKDEpKDExKShbMCwgMSwgMl0pOyAgICAgLy89PiBbMCwgMTEsIDJdXG4gKiBAc3ltYiBSLnVwZGF0ZSgtMSwgYSwgW2IsIGNdKSA9IFtiLCBhXVxuICogQHN5bWIgUi51cGRhdGUoMCwgYSwgW2IsIGNdKSA9IFthLCBjXVxuICogQHN5bWIgUi51cGRhdGUoMSwgYSwgW2IsIGNdKSA9IFtiLCBhXVxuICovXG52YXIgdXBkYXRlID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gdXBkYXRlKGlkeCwgeCwgbGlzdCkge1xuICByZXR1cm4gYWRqdXN0KGFsd2F5cyh4KSwgaWR4LCBsaXN0KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdXBkYXRlOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgY3VycnlOIGZyb20gJy4vY3VycnlOJztcblxuLyoqXG4gKiBBY2NlcHRzIGEgZnVuY3Rpb24gYGZuYCBhbmQgYSBsaXN0IG9mIHRyYW5zZm9ybWVyIGZ1bmN0aW9ucyBhbmQgcmV0dXJucyBhXG4gKiBuZXcgY3VycmllZCBmdW5jdGlvbi4gV2hlbiB0aGUgbmV3IGZ1bmN0aW9uIGlzIGludm9rZWQsIGl0IGNhbGxzIHRoZVxuICogZnVuY3Rpb24gYGZuYCB3aXRoIHBhcmFtZXRlcnMgY29uc2lzdGluZyBvZiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgZWFjaFxuICogc3VwcGxpZWQgaGFuZGxlciBvbiBzdWNjZXNzaXZlIGFyZ3VtZW50cyB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICpcbiAqIElmIG1vcmUgYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gdGhlIHJldHVybmVkIGZ1bmN0aW9uIHRoYW4gdHJhbnNmb3JtZXJcbiAqIGZ1bmN0aW9ucywgdGhvc2UgYXJndW1lbnRzIGFyZSBwYXNzZWQgZGlyZWN0bHkgdG8gYGZuYCBhcyBhZGRpdGlvbmFsXG4gKiBwYXJhbWV0ZXJzLiBJZiB5b3UgZXhwZWN0IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgZG9uJ3QgbmVlZCB0byBiZVxuICogdHJhbnNmb3JtZWQsIGFsdGhvdWdoIHlvdSBjYW4gaWdub3JlIHRoZW0sIGl0J3MgYmVzdCB0byBwYXNzIGFuIGlkZW50aXR5XG4gKiBmdW5jdGlvbiBzbyB0aGF0IHRoZSBuZXcgZnVuY3Rpb24gcmVwb3J0cyB0aGUgY29ycmVjdCBhcml0eS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKHgxLCB4MiwgLi4uKSAtPiB6KSAtPiBbKGEgLT4geDEpLCAoYiAtPiB4MiksIC4uLl0gLT4gKGEgLT4gYiAtPiAuLi4gLT4geilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtZXJzIEEgbGlzdCBvZiB0cmFuc2Zvcm1lciBmdW5jdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvbi5cbiAqIEBzZWUgUi5jb252ZXJnZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudXNlV2l0aChNYXRoLnBvdywgW1IuaWRlbnRpdHksIFIuaWRlbnRpdHldKSgzLCA0KTsgLy89PiA4MVxuICogICAgICBSLnVzZVdpdGgoTWF0aC5wb3csIFtSLmlkZW50aXR5LCBSLmlkZW50aXR5XSkoMykoNCk7IC8vPT4gODFcbiAqICAgICAgUi51c2VXaXRoKE1hdGgucG93LCBbUi5kZWMsIFIuaW5jXSkoMywgNCk7IC8vPT4gMzJcbiAqICAgICAgUi51c2VXaXRoKE1hdGgucG93LCBbUi5kZWMsIFIuaW5jXSkoMykoNCk7IC8vPT4gMzJcbiAqIEBzeW1iIFIudXNlV2l0aChmLCBbZywgaF0pKGEsIGIpID0gZihnKGEpLCBoKGIpKVxuICovXG52YXIgdXNlV2l0aCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHVzZVdpdGgoZm4sIHRyYW5zZm9ybWVycykge1xuICByZXR1cm4gY3VycnlOKHRyYW5zZm9ybWVycy5sZW5ndGgsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHdoaWxlIChpZHggPCB0cmFuc2Zvcm1lcnMubGVuZ3RoKSB7XG4gICAgICBhcmdzLnB1c2godHJhbnNmb3JtZXJzW2lkeF0uY2FsbCh0aGlzLCBhcmd1bWVudHNbaWR4XSkpO1xuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIHRyYW5zZm9ybWVycy5sZW5ndGgpKSk7XG4gIH0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCB1c2VXaXRoOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMnO1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBvZiB0aGUgc3VwcGxpZWQgb2JqZWN0LlxuICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBkaWZmZXJlbnRcbiAqIEpTIHBsYXRmb3Jtcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge2s6IHZ9IC0+IFt2XVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgdmFsdWVzIGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgdmFsdWVzIG9mIHRoZSBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAqIEBzZWUgUi52YWx1ZXNJbiwgUi5rZXlzXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi52YWx1ZXMoe2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiBbMSwgMiwgM11cbiAqL1xudmFyIHZhbHVlcyA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIHZhbHVlcyhvYmopIHtcbiAgdmFyIHByb3BzID0ga2V5cyhvYmopO1xuICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuICB2YXIgdmFscyA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHZhbHNbaWR4XSA9IG9ialtwcm9wc1tpZHhdXTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gdmFscztcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdmFsdWVzOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRoZSBwcm9wZXJ0aWVzLCBpbmNsdWRpbmcgcHJvdG90eXBlIHByb3BlcnRpZXMsIG9mIHRoZVxuICogc3VwcGxpZWQgb2JqZWN0LlxuICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnRcbiAqIGFjcm9zcyBkaWZmZXJlbnQgSlMgcGxhdGZvcm1zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7azogdn0gLT4gW3ZdXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZXh0cmFjdCB2YWx1ZXMgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgb2YgdGhlIG9iamVjdCdzIG93biBhbmQgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKiBAc2VlIFIudmFsdWVzLCBSLmtleXNJblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9ICdYJzsgfTtcbiAqICAgICAgRi5wcm90b3R5cGUueSA9ICdZJztcbiAqICAgICAgdmFyIGYgPSBuZXcgRigpO1xuICogICAgICBSLnZhbHVlc0luKGYpOyAvLz0+IFsnWCcsICdZJ11cbiAqL1xudmFyIHZhbHVlc0luID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gdmFsdWVzSW4ob2JqKSB7XG4gIHZhciBwcm9wO1xuICB2YXIgdnMgPSBbXTtcbiAgZm9yIChwcm9wIGluIG9iaikge1xuICAgIHZzW3ZzLmxlbmd0aF0gPSBvYmpbcHJvcF07XG4gIH1cbiAgcmV0dXJuIHZzO1xufSk7XG5leHBvcnQgZGVmYXVsdCB2YWx1ZXNJbjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vLyBgQ29uc3RgIGlzIGEgZnVuY3RvciB0aGF0IGVmZmVjdGl2ZWx5IGlnbm9yZXMgdGhlIGZ1bmN0aW9uIGdpdmVuIHRvIGBtYXBgLlxudmFyIENvbnN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHgsICdmYW50YXN5LWxhbmQvbWFwJzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgXCJ2aWV3XCIgb2YgdGhlIGdpdmVuIGRhdGEgc3RydWN0dXJlLCBkZXRlcm1pbmVkIGJ5IHRoZSBnaXZlbiBsZW5zLlxuICogVGhlIGxlbnMncyBmb2N1cyBkZXRlcm1pbmVzIHdoaWNoIHBvcnRpb24gb2YgdGhlIGRhdGEgc3RydWN0dXJlIGlzIHZpc2libGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAqIEBzaWcgTGVucyBzIGEgLT4gcyAtPiBhXG4gKiBAcGFyYW0ge0xlbnN9IGxlbnNcbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5wcm9wLCBSLmxlbnNJbmRleCwgUi5sZW5zUHJvcFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB4TGVucyA9IFIubGVuc1Byb3AoJ3gnKTtcbiAqXG4gKiAgICAgIFIudmlldyh4TGVucywge3g6IDEsIHk6IDJ9KTsgIC8vPT4gMVxuICogICAgICBSLnZpZXcoeExlbnMsIHt4OiA0LCB5OiAyfSk7ICAvLz0+IDRcbiAqL1xudmFyIHZpZXcgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiB2aWV3KGxlbnMsIHgpIHtcbiAgLy8gVXNpbmcgYENvbnN0YCBlZmZlY3RpdmVseSBpZ25vcmVzIHRoZSBzZXR0ZXIgZnVuY3Rpb24gb2YgdGhlIGBsZW5zYCxcbiAgLy8gbGVhdmluZyB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGdldHRlciBmdW5jdGlvbiB1bm1vZGlmaWVkLlxuICByZXR1cm4gbGVucyhDb25zdCkoeCkudmFsdWU7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHZpZXc7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLyoqXG4gKiBUZXN0cyB0aGUgZmluYWwgYXJndW1lbnQgYnkgcGFzc2luZyBpdCB0byB0aGUgZ2l2ZW4gcHJlZGljYXRlIGZ1bmN0aW9uLiBJZlxuICogdGhlIHByZWRpY2F0ZSBpcyBzYXRpc2ZpZWQsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmdcbiAqIHRoZSBgd2hlblRydWVGbmAgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBhcmd1bWVudC4gSWYgdGhlIHByZWRpY2F0ZSBpcyBub3RcbiAqIHNhdGlzZmllZCwgdGhlIGFyZ3VtZW50IGlzIHJldHVybmVkIGFzIGlzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE4LjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiAoYSAtPiBhKSAtPiBhIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgICAgICAgQSBwcmVkaWNhdGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHdoZW5UcnVlRm4gQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYGNvbmRpdGlvbmBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGVzIHRvIGEgdHJ1dGh5IHZhbHVlLlxuICogQHBhcmFtIHsqfSAgICAgICAgeCAgICAgICAgICBBbiBvYmplY3QgdG8gdGVzdCB3aXRoIHRoZSBgcHJlZGAgZnVuY3Rpb24gYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgdG8gYHdoZW5UcnVlRm5gIGlmIG5lY2Vzc2FyeS5cbiAqIEByZXR1cm4geyp9IEVpdGhlciBgeGAgb3IgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgeGAgdG8gYHdoZW5UcnVlRm5gLlxuICogQHNlZSBSLmlmRWxzZSwgUi51bmxlc3NcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyB0cnVuY2F0ZSA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gKiAgICAgIHZhciB0cnVuY2F0ZSA9IFIud2hlbihcbiAqICAgICAgICBSLnByb3BTYXRpc2ZpZXMoUi5ndChSLl9fLCAxMCksICdsZW5ndGgnKSxcbiAqICAgICAgICBSLnBpcGUoUi50YWtlKDEwKSwgUi5hcHBlbmQoJ+KApicpLCBSLmpvaW4oJycpKVxuICogICAgICApO1xuICogICAgICB0cnVuY2F0ZSgnMTIzNDUnKTsgICAgICAgICAvLz0+ICcxMjM0NSdcbiAqICAgICAgdHJ1bmNhdGUoJzAxMjM0NTY3ODlBQkMnKTsgLy89PiAnMDEyMzQ1Njc4OeKApidcbiAqL1xudmFyIHdoZW4gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiB3aGVuKHByZWQsIHdoZW5UcnVlRm4sIHgpIHtcbiAgcmV0dXJuIHByZWQoeCkgPyB3aGVuVHJ1ZUZuKHgpIDogeDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgd2hlbjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9oYXMgZnJvbSAnLi9pbnRlcm5hbC9faGFzJztcblxuLyoqXG4gKiBUYWtlcyBhIHNwZWMgb2JqZWN0IGFuZCBhIHRlc3Qgb2JqZWN0OyByZXR1cm5zIHRydWUgaWYgdGhlIHRlc3Qgc2F0aXNmaWVzXG4gKiB0aGUgc3BlYy4gRWFjaCBvZiB0aGUgc3BlYydzIG93biBwcm9wZXJ0aWVzIG11c3QgYmUgYSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gKiBFYWNoIHByZWRpY2F0ZSBpcyBhcHBsaWVkIHRvIHRoZSB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBvZiB0aGVcbiAqIHRlc3Qgb2JqZWN0LiBgd2hlcmVgIHJldHVybnMgdHJ1ZSBpZiBhbGwgdGhlIHByZWRpY2F0ZXMgcmV0dXJuIHRydWUsIGZhbHNlXG4gKiBvdGhlcndpc2UuXG4gKlxuICogYHdoZXJlYCBpcyB3ZWxsIHN1aXRlZCB0byBkZWNsYXJhdGl2ZWx5IGV4cHJlc3NpbmcgY29uc3RyYWludHMgZm9yIG90aGVyXG4gKiBmdW5jdGlvbnMgc3VjaCBhcyBbYGZpbHRlcmBdKCNmaWx0ZXIpIGFuZCBbYGZpbmRgXSgjZmluZCkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4xXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtTdHJpbmc6ICgqIC0+IEJvb2xlYW4pfSAtPiB7U3RyaW5nOiAqfSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge09iamVjdH0gc3BlY1xuICogQHBhcmFtIHtPYmplY3R9IHRlc3RPYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIucHJvcFNhdGlzZmllcywgUi53aGVyZUVxXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gcHJlZCA6OiBPYmplY3QgLT4gQm9vbGVhblxuICogICAgICB2YXIgcHJlZCA9IFIud2hlcmUoe1xuICogICAgICAgIGE6IFIuZXF1YWxzKCdmb28nKSxcbiAqICAgICAgICBiOiBSLmNvbXBsZW1lbnQoUi5lcXVhbHMoJ2JhcicpKSxcbiAqICAgICAgICB4OiBSLmd0KFIuX18sIDEwKSxcbiAqICAgICAgICB5OiBSLmx0KFIuX18sIDIwKVxuICogICAgICB9KTtcbiAqXG4gKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAneHh4JywgeDogMTEsIHk6IDE5fSk7IC8vPT4gdHJ1ZVxuICogICAgICBwcmVkKHthOiAneHh4JywgYjogJ3h4eCcsIHg6IDExLCB5OiAxOX0pOyAvLz0+IGZhbHNlXG4gKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAnYmFyJywgeDogMTEsIHk6IDE5fSk7IC8vPT4gZmFsc2VcbiAqICAgICAgcHJlZCh7YTogJ2ZvbycsIGI6ICd4eHgnLCB4OiAxMCwgeTogMTl9KTsgLy89PiBmYWxzZVxuICogICAgICBwcmVkKHthOiAnZm9vJywgYjogJ3h4eCcsIHg6IDExLCB5OiAyMH0pOyAvLz0+IGZhbHNlXG4gKi9cbnZhciB3aGVyZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHdoZXJlKHNwZWMsIHRlc3RPYmopIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBzcGVjKSB7XG4gICAgaWYgKF9oYXMocHJvcCwgc3BlYykgJiYgIXNwZWNbcHJvcF0odGVzdE9ialtwcm9wXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHdoZXJlOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgZXF1YWxzIGZyb20gJy4vZXF1YWxzJztcbmltcG9ydCBtYXAgZnJvbSAnLi9tYXAnO1xuaW1wb3J0IHdoZXJlIGZyb20gJy4vd2hlcmUnO1xuXG4vKipcbiAqIFRha2VzIGEgc3BlYyBvYmplY3QgYW5kIGEgdGVzdCBvYmplY3Q7IHJldHVybnMgdHJ1ZSBpZiB0aGUgdGVzdCBzYXRpc2ZpZXNcbiAqIHRoZSBzcGVjLCBmYWxzZSBvdGhlcndpc2UuIEFuIG9iamVjdCBzYXRpc2ZpZXMgdGhlIHNwZWMgaWYsIGZvciBlYWNoIG9mIHRoZVxuICogc3BlYydzIG93biBwcm9wZXJ0aWVzLCBhY2Nlc3NpbmcgdGhhdCBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0IGdpdmVzIHRoZSBzYW1lXG4gKiB2YWx1ZSAoaW4gW2BSLmVxdWFsc2BdKCNlcXVhbHMpIHRlcm1zKSBhcyBhY2Nlc3NpbmcgdGhhdCBwcm9wZXJ0eSBvZiB0aGVcbiAqIHNwZWMuXG4gKlxuICogYHdoZXJlRXFgIGlzIGEgc3BlY2lhbGl6YXRpb24gb2YgW2B3aGVyZWBdKCN3aGVyZSkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7U3RyaW5nOiAqfSAtPiB7U3RyaW5nOiAqfSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge09iamVjdH0gc3BlY1xuICogQHBhcmFtIHtPYmplY3R9IHRlc3RPYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIucHJvcEVxLCBSLndoZXJlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gcHJlZCA6OiBPYmplY3QgLT4gQm9vbGVhblxuICogICAgICB2YXIgcHJlZCA9IFIud2hlcmVFcSh7YTogMSwgYjogMn0pO1xuICpcbiAqICAgICAgcHJlZCh7YTogMX0pOyAgICAgICAgICAgICAgLy89PiBmYWxzZVxuICogICAgICBwcmVkKHthOiAxLCBiOiAyfSk7ICAgICAgICAvLz0+IHRydWVcbiAqICAgICAgcHJlZCh7YTogMSwgYjogMiwgYzogM30pOyAgLy89PiB0cnVlXG4gKiAgICAgIHByZWQoe2E6IDEsIGI6IDF9KTsgICAgICAgIC8vPT4gZmFsc2VcbiAqL1xudmFyIHdoZXJlRXEgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiB3aGVyZUVxKHNwZWMsIHRlc3RPYmopIHtcbiAgcmV0dXJuIHdoZXJlKG1hcChlcXVhbHMsIHNwZWMpLCB0ZXN0T2JqKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgd2hlcmVFcTsiLCJpbXBvcnQgX2NvbnRhaW5zIGZyb20gJy4vaW50ZXJuYWwvX2NvbnRhaW5zJztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgZmxpcCBmcm9tICcuL2ZsaXAnO1xuaW1wb3J0IHJlamVjdCBmcm9tICcuL3JlamVjdCc7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IHdpdGhvdXQgdmFsdWVzIGluIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAqIFtgUi5lcXVhbHNgXSgjZXF1YWxzKSBpcyB1c2VkIHRvIGRldGVybWluZSBlcXVhbGl0eS5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSB2YWx1ZXMgdG8gYmUgcmVtb3ZlZCBmcm9tIGBsaXN0MmAuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgYXJyYXkgdG8gcmVtb3ZlIHZhbHVlcyBmcm9tLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgd2l0aG91dCB2YWx1ZXMgaW4gYGxpc3QxYC5cbiAqIEBzZWUgUi50cmFuc2R1Y2UsIFIuZGlmZmVyZW5jZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIud2l0aG91dChbMSwgMl0sIFsxLCAyLCAxLCAzLCA0XSk7IC8vPT4gWzMsIDRdXG4gKi9cbnZhciB3aXRob3V0ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gKHhzLCBsaXN0KSB7XG4gIHJldHVybiByZWplY3QoZmxpcChfY29udGFpbnMpKHhzKSwgbGlzdCk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHdpdGhvdXQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGxpc3Qgb3V0IG9mIHRoZSB0d28gc3VwcGxpZWQgYnkgY3JlYXRpbmcgZWFjaCBwb3NzaWJsZSBwYWlyXG4gKiBmcm9tIHRoZSBsaXN0cy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYl0gLT4gW1thLGJdXVxuICogQHBhcmFtIHtBcnJheX0gYXMgVGhlIGZpcnN0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBicyBUaGUgc2Vjb25kIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3QgbWFkZSBieSBjb21iaW5pbmcgZWFjaCBwb3NzaWJsZSBwYWlyIGZyb21cbiAqICAgICAgICAgYGFzYCBhbmQgYGJzYCBpbnRvIHBhaXJzIChgW2EsIGJdYCkuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi54cHJvZChbMSwgMl0sIFsnYScsICdiJ10pOyAvLz0+IFtbMSwgJ2EnXSwgWzEsICdiJ10sIFsyLCAnYSddLCBbMiwgJ2InXV1cbiAqIEBzeW1iIFIueHByb2QoW2EsIGJdLCBbYywgZF0pID0gW1thLCBjXSwgW2EsIGRdLCBbYiwgY10sIFtiLCBkXV1cbiAqL1xudmFyIHhwcm9kID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24geHByb2QoYSwgYikge1xuICAvLyA9IHhwcm9kV2l0aChwcmVwZW5kKTsgKHRha2VzIGFib3V0IDMgdGltZXMgYXMgbG9uZy4uLilcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBpbGVuID0gYS5sZW5ndGg7XG4gIHZhciBqO1xuICB2YXIgamxlbiA9IGIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChpZHggPCBpbGVuKSB7XG4gICAgaiA9IDA7XG4gICAgd2hpbGUgKGogPCBqbGVuKSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBbYVtpZHhdLCBiW2pdXTtcbiAgICAgIGogKz0gMTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgeHByb2Q7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGxpc3Qgb3V0IG9mIHRoZSB0d28gc3VwcGxpZWQgYnkgcGFpcmluZyB1cCBlcXVhbGx5LXBvc2l0aW9uZWRcbiAqIGl0ZW1zIGZyb20gYm90aCBsaXN0cy4gVGhlIHJldHVybmVkIGxpc3QgaXMgdHJ1bmNhdGVkIHRvIHRoZSBsZW5ndGggb2YgdGhlXG4gKiBzaG9ydGVyIG9mIHRoZSB0d28gaW5wdXQgbGlzdHMuXG4gKiBOb3RlOiBgemlwYCBpcyBlcXVpdmFsZW50IHRvIGB6aXBXaXRoKGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIFthLCBiXSB9KWAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2JdIC0+IFtbYSxiXV1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBhcnJheSB0byBjb25zaWRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3QgbWFkZSBieSBwYWlyaW5nIHVwIHNhbWUtaW5kZXhlZCBlbGVtZW50cyBvZiBgbGlzdDFgIGFuZCBgbGlzdDJgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuemlwKFsxLCAyLCAzXSwgWydhJywgJ2InLCAnYyddKTsgLy89PiBbWzEsICdhJ10sIFsyLCAnYiddLCBbMywgJ2MnXV1cbiAqIEBzeW1iIFIuemlwKFthLCBiLCBjXSwgW2QsIGUsIGZdKSA9IFtbYSwgZF0sIFtiLCBlXSwgW2MsIGZdXVxuICovXG52YXIgemlwID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gemlwKGEsIGIpIHtcbiAgdmFyIHJ2ID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHJ2W2lkeF0gPSBbYVtpZHhdLCBiW2lkeF1dO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBydjtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgemlwOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3Qgb3V0IG9mIGEgbGlzdCBvZiBrZXlzIGFuZCBhIGxpc3Qgb2YgdmFsdWVzLlxuICogS2V5L3ZhbHVlIHBhaXJpbmcgaXMgdHJ1bmNhdGVkIHRvIHRoZSBsZW5ndGggb2YgdGhlIHNob3J0ZXIgb2YgdGhlIHR3byBsaXN0cy5cbiAqIE5vdGU6IGB6aXBPYmpgIGlzIGVxdWl2YWxlbnQgdG8gYHBpcGUoemlwLCBmcm9tUGFpcnMpYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFtTdHJpbmddIC0+IFsqXSAtPiB7U3RyaW5nOiAqfVxuICogQHBhcmFtIHtBcnJheX0ga2V5cyBUaGUgYXJyYXkgdGhhdCB3aWxsIGJlIHByb3BlcnRpZXMgb24gdGhlIG91dHB1dCBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIGxpc3Qgb2YgdmFsdWVzIG9uIHRoZSBvdXRwdXQgb2JqZWN0LlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgb2JqZWN0IG1hZGUgYnkgcGFpcmluZyB1cCBzYW1lLWluZGV4ZWQgZWxlbWVudHMgb2YgYGtleXNgIGFuZCBgdmFsdWVzYC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnppcE9iaihbJ2EnLCAnYicsICdjJ10sIFsxLCAyLCAzXSk7IC8vPT4ge2E6IDEsIGI6IDIsIGM6IDN9XG4gKi9cbnZhciB6aXBPYmogPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiB6aXBPYmooa2V5cywgdmFsdWVzKSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gTWF0aC5taW4oa2V5cy5sZW5ndGgsIHZhbHVlcy5sZW5ndGgpO1xuICB2YXIgb3V0ID0ge307XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBvdXRba2V5c1tpZHhdXSA9IHZhbHVlc1tpZHhdO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBvdXQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHppcE9iajsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbGlzdCBvdXQgb2YgdGhlIHR3byBzdXBwbGllZCBieSBhcHBseWluZyB0aGUgZnVuY3Rpb24gdG8gZWFjaFxuICogZXF1YWxseS1wb3NpdGlvbmVkIHBhaXIgaW4gdGhlIGxpc3RzLiBUaGUgcmV0dXJuZWQgbGlzdCBpcyB0cnVuY2F0ZWQgdG8gdGhlXG4gKiBsZW5ndGggb2YgdGhlIHNob3J0ZXIgb2YgdGhlIHR3byBpbnB1dCBsaXN0cy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGIpIC0+IGMpIC0+IFthXSAtPiBbYl0gLT4gW2NdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdXNlZCB0byBjb21iaW5lIHRoZSB0d28gZWxlbWVudHMgaW50byBvbmUgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG1hZGUgYnkgY29tYmluaW5nIHNhbWUtaW5kZXhlZCBlbGVtZW50cyBvZiBgbGlzdDFgIGFuZCBgbGlzdDJgXG4gKiAgICAgICAgIHVzaW5nIGBmbmAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGYgPSAoeCwgeSkgPT4ge1xuICogICAgICAgIC8vIC4uLlxuICogICAgICB9O1xuICogICAgICBSLnppcFdpdGgoZiwgWzEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ10pO1xuICogICAgICAvLz0+IFtmKDEsICdhJyksIGYoMiwgJ2InKSwgZigzLCAnYycpXVxuICogQHN5bWIgUi56aXBXaXRoKGZuLCBbYSwgYiwgY10sIFtkLCBlLCBmXSkgPSBbZm4oYSwgZCksIGZuKGIsIGUpLCBmbihjLCBmKV1cbiAqL1xudmFyIHppcFdpdGggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiB6aXBXaXRoKGZuLCBhLCBiKSB7XG4gIHZhciBydiA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBydltpZHhdID0gZm4oYVtpZHhdLCBiW2lkeF0pO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBydjtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgemlwV2l0aDsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvJyk7XG4iLCIvLyBMaXN0IG9mIHZhbGlkIGVudGl0aWVzXG4vL1xuLy8gR2VuZXJhdGUgd2l0aCAuL3N1cHBvcnQvZW50aXRpZXMuanMgc2NyaXB0XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludCBxdW90ZXM6MCovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCJBYWN1dGVcIjpcIlxcdTAwQzFcIixcbiAgXCJhYWN1dGVcIjpcIlxcdTAwRTFcIixcbiAgXCJBYnJldmVcIjpcIlxcdTAxMDJcIixcbiAgXCJhYnJldmVcIjpcIlxcdTAxMDNcIixcbiAgXCJhY1wiOlwiXFx1MjIzRVwiLFxuICBcImFjZFwiOlwiXFx1MjIzRlwiLFxuICBcImFjRVwiOlwiXFx1MjIzRVxcdTAzMzNcIixcbiAgXCJBY2lyY1wiOlwiXFx1MDBDMlwiLFxuICBcImFjaXJjXCI6XCJcXHUwMEUyXCIsXG4gIFwiYWN1dGVcIjpcIlxcdTAwQjRcIixcbiAgXCJBY3lcIjpcIlxcdTA0MTBcIixcbiAgXCJhY3lcIjpcIlxcdTA0MzBcIixcbiAgXCJBRWxpZ1wiOlwiXFx1MDBDNlwiLFxuICBcImFlbGlnXCI6XCJcXHUwMEU2XCIsXG4gIFwiYWZcIjpcIlxcdTIwNjFcIixcbiAgXCJBZnJcIjpcIlxcdUQ4MzVcXHVERDA0XCIsXG4gIFwiYWZyXCI6XCJcXHVEODM1XFx1REQxRVwiLFxuICBcIkFncmF2ZVwiOlwiXFx1MDBDMFwiLFxuICBcImFncmF2ZVwiOlwiXFx1MDBFMFwiLFxuICBcImFsZWZzeW1cIjpcIlxcdTIxMzVcIixcbiAgXCJhbGVwaFwiOlwiXFx1MjEzNVwiLFxuICBcIkFscGhhXCI6XCJcXHUwMzkxXCIsXG4gIFwiYWxwaGFcIjpcIlxcdTAzQjFcIixcbiAgXCJBbWFjclwiOlwiXFx1MDEwMFwiLFxuICBcImFtYWNyXCI6XCJcXHUwMTAxXCIsXG4gIFwiYW1hbGdcIjpcIlxcdTJBM0ZcIixcbiAgXCJBTVBcIjpcIlxcdTAwMjZcIixcbiAgXCJhbXBcIjpcIlxcdTAwMjZcIixcbiAgXCJBbmRcIjpcIlxcdTJBNTNcIixcbiAgXCJhbmRcIjpcIlxcdTIyMjdcIixcbiAgXCJhbmRhbmRcIjpcIlxcdTJBNTVcIixcbiAgXCJhbmRkXCI6XCJcXHUyQTVDXCIsXG4gIFwiYW5kc2xvcGVcIjpcIlxcdTJBNThcIixcbiAgXCJhbmR2XCI6XCJcXHUyQTVBXCIsXG4gIFwiYW5nXCI6XCJcXHUyMjIwXCIsXG4gIFwiYW5nZVwiOlwiXFx1MjlBNFwiLFxuICBcImFuZ2xlXCI6XCJcXHUyMjIwXCIsXG4gIFwiYW5nbXNkXCI6XCJcXHUyMjIxXCIsXG4gIFwiYW5nbXNkYWFcIjpcIlxcdTI5QThcIixcbiAgXCJhbmdtc2RhYlwiOlwiXFx1MjlBOVwiLFxuICBcImFuZ21zZGFjXCI6XCJcXHUyOUFBXCIsXG4gIFwiYW5nbXNkYWRcIjpcIlxcdTI5QUJcIixcbiAgXCJhbmdtc2RhZVwiOlwiXFx1MjlBQ1wiLFxuICBcImFuZ21zZGFmXCI6XCJcXHUyOUFEXCIsXG4gIFwiYW5nbXNkYWdcIjpcIlxcdTI5QUVcIixcbiAgXCJhbmdtc2RhaFwiOlwiXFx1MjlBRlwiLFxuICBcImFuZ3J0XCI6XCJcXHUyMjFGXCIsXG4gIFwiYW5ncnR2YlwiOlwiXFx1MjJCRVwiLFxuICBcImFuZ3J0dmJkXCI6XCJcXHUyOTlEXCIsXG4gIFwiYW5nc3BoXCI6XCJcXHUyMjIyXCIsXG4gIFwiYW5nc3RcIjpcIlxcdTAwQzVcIixcbiAgXCJhbmd6YXJyXCI6XCJcXHUyMzdDXCIsXG4gIFwiQW9nb25cIjpcIlxcdTAxMDRcIixcbiAgXCJhb2dvblwiOlwiXFx1MDEwNVwiLFxuICBcIkFvcGZcIjpcIlxcdUQ4MzVcXHVERDM4XCIsXG4gIFwiYW9wZlwiOlwiXFx1RDgzNVxcdURENTJcIixcbiAgXCJhcFwiOlwiXFx1MjI0OFwiLFxuICBcImFwYWNpclwiOlwiXFx1MkE2RlwiLFxuICBcImFwRVwiOlwiXFx1MkE3MFwiLFxuICBcImFwZVwiOlwiXFx1MjI0QVwiLFxuICBcImFwaWRcIjpcIlxcdTIyNEJcIixcbiAgXCJhcG9zXCI6XCJcXHUwMDI3XCIsXG4gIFwiQXBwbHlGdW5jdGlvblwiOlwiXFx1MjA2MVwiLFxuICBcImFwcHJveFwiOlwiXFx1MjI0OFwiLFxuICBcImFwcHJveGVxXCI6XCJcXHUyMjRBXCIsXG4gIFwiQXJpbmdcIjpcIlxcdTAwQzVcIixcbiAgXCJhcmluZ1wiOlwiXFx1MDBFNVwiLFxuICBcIkFzY3JcIjpcIlxcdUQ4MzVcXHVEQzlDXCIsXG4gIFwiYXNjclwiOlwiXFx1RDgzNVxcdURDQjZcIixcbiAgXCJBc3NpZ25cIjpcIlxcdTIyNTRcIixcbiAgXCJhc3RcIjpcIlxcdTAwMkFcIixcbiAgXCJhc3ltcFwiOlwiXFx1MjI0OFwiLFxuICBcImFzeW1wZXFcIjpcIlxcdTIyNERcIixcbiAgXCJBdGlsZGVcIjpcIlxcdTAwQzNcIixcbiAgXCJhdGlsZGVcIjpcIlxcdTAwRTNcIixcbiAgXCJBdW1sXCI6XCJcXHUwMEM0XCIsXG4gIFwiYXVtbFwiOlwiXFx1MDBFNFwiLFxuICBcImF3Y29uaW50XCI6XCJcXHUyMjMzXCIsXG4gIFwiYXdpbnRcIjpcIlxcdTJBMTFcIixcbiAgXCJiYWNrY29uZ1wiOlwiXFx1MjI0Q1wiLFxuICBcImJhY2tlcHNpbG9uXCI6XCJcXHUwM0Y2XCIsXG4gIFwiYmFja3ByaW1lXCI6XCJcXHUyMDM1XCIsXG4gIFwiYmFja3NpbVwiOlwiXFx1MjIzRFwiLFxuICBcImJhY2tzaW1lcVwiOlwiXFx1MjJDRFwiLFxuICBcIkJhY2tzbGFzaFwiOlwiXFx1MjIxNlwiLFxuICBcIkJhcnZcIjpcIlxcdTJBRTdcIixcbiAgXCJiYXJ2ZWVcIjpcIlxcdTIyQkRcIixcbiAgXCJCYXJ3ZWRcIjpcIlxcdTIzMDZcIixcbiAgXCJiYXJ3ZWRcIjpcIlxcdTIzMDVcIixcbiAgXCJiYXJ3ZWRnZVwiOlwiXFx1MjMwNVwiLFxuICBcImJicmtcIjpcIlxcdTIzQjVcIixcbiAgXCJiYnJrdGJya1wiOlwiXFx1MjNCNlwiLFxuICBcImJjb25nXCI6XCJcXHUyMjRDXCIsXG4gIFwiQmN5XCI6XCJcXHUwNDExXCIsXG4gIFwiYmN5XCI6XCJcXHUwNDMxXCIsXG4gIFwiYmRxdW9cIjpcIlxcdTIwMUVcIixcbiAgXCJiZWNhdXNcIjpcIlxcdTIyMzVcIixcbiAgXCJCZWNhdXNlXCI6XCJcXHUyMjM1XCIsXG4gIFwiYmVjYXVzZVwiOlwiXFx1MjIzNVwiLFxuICBcImJlbXB0eXZcIjpcIlxcdTI5QjBcIixcbiAgXCJiZXBzaVwiOlwiXFx1MDNGNlwiLFxuICBcImJlcm5vdVwiOlwiXFx1MjEyQ1wiLFxuICBcIkJlcm5vdWxsaXNcIjpcIlxcdTIxMkNcIixcbiAgXCJCZXRhXCI6XCJcXHUwMzkyXCIsXG4gIFwiYmV0YVwiOlwiXFx1MDNCMlwiLFxuICBcImJldGhcIjpcIlxcdTIxMzZcIixcbiAgXCJiZXR3ZWVuXCI6XCJcXHUyMjZDXCIsXG4gIFwiQmZyXCI6XCJcXHVEODM1XFx1REQwNVwiLFxuICBcImJmclwiOlwiXFx1RDgzNVxcdUREMUZcIixcbiAgXCJiaWdjYXBcIjpcIlxcdTIyQzJcIixcbiAgXCJiaWdjaXJjXCI6XCJcXHUyNUVGXCIsXG4gIFwiYmlnY3VwXCI6XCJcXHUyMkMzXCIsXG4gIFwiYmlnb2RvdFwiOlwiXFx1MkEwMFwiLFxuICBcImJpZ29wbHVzXCI6XCJcXHUyQTAxXCIsXG4gIFwiYmlnb3RpbWVzXCI6XCJcXHUyQTAyXCIsXG4gIFwiYmlnc3FjdXBcIjpcIlxcdTJBMDZcIixcbiAgXCJiaWdzdGFyXCI6XCJcXHUyNjA1XCIsXG4gIFwiYmlndHJpYW5nbGVkb3duXCI6XCJcXHUyNUJEXCIsXG4gIFwiYmlndHJpYW5nbGV1cFwiOlwiXFx1MjVCM1wiLFxuICBcImJpZ3VwbHVzXCI6XCJcXHUyQTA0XCIsXG4gIFwiYmlndmVlXCI6XCJcXHUyMkMxXCIsXG4gIFwiYmlnd2VkZ2VcIjpcIlxcdTIyQzBcIixcbiAgXCJia2Fyb3dcIjpcIlxcdTI5MERcIixcbiAgXCJibGFja2xvemVuZ2VcIjpcIlxcdTI5RUJcIixcbiAgXCJibGFja3NxdWFyZVwiOlwiXFx1MjVBQVwiLFxuICBcImJsYWNrdHJpYW5nbGVcIjpcIlxcdTI1QjRcIixcbiAgXCJibGFja3RyaWFuZ2xlZG93blwiOlwiXFx1MjVCRVwiLFxuICBcImJsYWNrdHJpYW5nbGVsZWZ0XCI6XCJcXHUyNUMyXCIsXG4gIFwiYmxhY2t0cmlhbmdsZXJpZ2h0XCI6XCJcXHUyNUI4XCIsXG4gIFwiYmxhbmtcIjpcIlxcdTI0MjNcIixcbiAgXCJibGsxMlwiOlwiXFx1MjU5MlwiLFxuICBcImJsazE0XCI6XCJcXHUyNTkxXCIsXG4gIFwiYmxrMzRcIjpcIlxcdTI1OTNcIixcbiAgXCJibG9ja1wiOlwiXFx1MjU4OFwiLFxuICBcImJuZVwiOlwiXFx1MDAzRFxcdTIwRTVcIixcbiAgXCJibmVxdWl2XCI6XCJcXHUyMjYxXFx1MjBFNVwiLFxuICBcImJOb3RcIjpcIlxcdTJBRURcIixcbiAgXCJibm90XCI6XCJcXHUyMzEwXCIsXG4gIFwiQm9wZlwiOlwiXFx1RDgzNVxcdUREMzlcIixcbiAgXCJib3BmXCI6XCJcXHVEODM1XFx1REQ1M1wiLFxuICBcImJvdFwiOlwiXFx1MjJBNVwiLFxuICBcImJvdHRvbVwiOlwiXFx1MjJBNVwiLFxuICBcImJvd3RpZVwiOlwiXFx1MjJDOFwiLFxuICBcImJveGJveFwiOlwiXFx1MjlDOVwiLFxuICBcImJveERMXCI6XCJcXHUyNTU3XCIsXG4gIFwiYm94RGxcIjpcIlxcdTI1NTZcIixcbiAgXCJib3hkTFwiOlwiXFx1MjU1NVwiLFxuICBcImJveGRsXCI6XCJcXHUyNTEwXCIsXG4gIFwiYm94RFJcIjpcIlxcdTI1NTRcIixcbiAgXCJib3hEclwiOlwiXFx1MjU1M1wiLFxuICBcImJveGRSXCI6XCJcXHUyNTUyXCIsXG4gIFwiYm94ZHJcIjpcIlxcdTI1MENcIixcbiAgXCJib3hIXCI6XCJcXHUyNTUwXCIsXG4gIFwiYm94aFwiOlwiXFx1MjUwMFwiLFxuICBcImJveEhEXCI6XCJcXHUyNTY2XCIsXG4gIFwiYm94SGRcIjpcIlxcdTI1NjRcIixcbiAgXCJib3hoRFwiOlwiXFx1MjU2NVwiLFxuICBcImJveGhkXCI6XCJcXHUyNTJDXCIsXG4gIFwiYm94SFVcIjpcIlxcdTI1NjlcIixcbiAgXCJib3hIdVwiOlwiXFx1MjU2N1wiLFxuICBcImJveGhVXCI6XCJcXHUyNTY4XCIsXG4gIFwiYm94aHVcIjpcIlxcdTI1MzRcIixcbiAgXCJib3htaW51c1wiOlwiXFx1MjI5RlwiLFxuICBcImJveHBsdXNcIjpcIlxcdTIyOUVcIixcbiAgXCJib3h0aW1lc1wiOlwiXFx1MjJBMFwiLFxuICBcImJveFVMXCI6XCJcXHUyNTVEXCIsXG4gIFwiYm94VWxcIjpcIlxcdTI1NUNcIixcbiAgXCJib3h1TFwiOlwiXFx1MjU1QlwiLFxuICBcImJveHVsXCI6XCJcXHUyNTE4XCIsXG4gIFwiYm94VVJcIjpcIlxcdTI1NUFcIixcbiAgXCJib3hVclwiOlwiXFx1MjU1OVwiLFxuICBcImJveHVSXCI6XCJcXHUyNTU4XCIsXG4gIFwiYm94dXJcIjpcIlxcdTI1MTRcIixcbiAgXCJib3hWXCI6XCJcXHUyNTUxXCIsXG4gIFwiYm94dlwiOlwiXFx1MjUwMlwiLFxuICBcImJveFZIXCI6XCJcXHUyNTZDXCIsXG4gIFwiYm94VmhcIjpcIlxcdTI1NkJcIixcbiAgXCJib3h2SFwiOlwiXFx1MjU2QVwiLFxuICBcImJveHZoXCI6XCJcXHUyNTNDXCIsXG4gIFwiYm94VkxcIjpcIlxcdTI1NjNcIixcbiAgXCJib3hWbFwiOlwiXFx1MjU2MlwiLFxuICBcImJveHZMXCI6XCJcXHUyNTYxXCIsXG4gIFwiYm94dmxcIjpcIlxcdTI1MjRcIixcbiAgXCJib3hWUlwiOlwiXFx1MjU2MFwiLFxuICBcImJveFZyXCI6XCJcXHUyNTVGXCIsXG4gIFwiYm94dlJcIjpcIlxcdTI1NUVcIixcbiAgXCJib3h2clwiOlwiXFx1MjUxQ1wiLFxuICBcImJwcmltZVwiOlwiXFx1MjAzNVwiLFxuICBcIkJyZXZlXCI6XCJcXHUwMkQ4XCIsXG4gIFwiYnJldmVcIjpcIlxcdTAyRDhcIixcbiAgXCJicnZiYXJcIjpcIlxcdTAwQTZcIixcbiAgXCJCc2NyXCI6XCJcXHUyMTJDXCIsXG4gIFwiYnNjclwiOlwiXFx1RDgzNVxcdURDQjdcIixcbiAgXCJic2VtaVwiOlwiXFx1MjA0RlwiLFxuICBcImJzaW1cIjpcIlxcdTIyM0RcIixcbiAgXCJic2ltZVwiOlwiXFx1MjJDRFwiLFxuICBcImJzb2xcIjpcIlxcdTAwNUNcIixcbiAgXCJic29sYlwiOlwiXFx1MjlDNVwiLFxuICBcImJzb2xoc3ViXCI6XCJcXHUyN0M4XCIsXG4gIFwiYnVsbFwiOlwiXFx1MjAyMlwiLFxuICBcImJ1bGxldFwiOlwiXFx1MjAyMlwiLFxuICBcImJ1bXBcIjpcIlxcdTIyNEVcIixcbiAgXCJidW1wRVwiOlwiXFx1MkFBRVwiLFxuICBcImJ1bXBlXCI6XCJcXHUyMjRGXCIsXG4gIFwiQnVtcGVxXCI6XCJcXHUyMjRFXCIsXG4gIFwiYnVtcGVxXCI6XCJcXHUyMjRGXCIsXG4gIFwiQ2FjdXRlXCI6XCJcXHUwMTA2XCIsXG4gIFwiY2FjdXRlXCI6XCJcXHUwMTA3XCIsXG4gIFwiQ2FwXCI6XCJcXHUyMkQyXCIsXG4gIFwiY2FwXCI6XCJcXHUyMjI5XCIsXG4gIFwiY2FwYW5kXCI6XCJcXHUyQTQ0XCIsXG4gIFwiY2FwYnJjdXBcIjpcIlxcdTJBNDlcIixcbiAgXCJjYXBjYXBcIjpcIlxcdTJBNEJcIixcbiAgXCJjYXBjdXBcIjpcIlxcdTJBNDdcIixcbiAgXCJjYXBkb3RcIjpcIlxcdTJBNDBcIixcbiAgXCJDYXBpdGFsRGlmZmVyZW50aWFsRFwiOlwiXFx1MjE0NVwiLFxuICBcImNhcHNcIjpcIlxcdTIyMjlcXHVGRTAwXCIsXG4gIFwiY2FyZXRcIjpcIlxcdTIwNDFcIixcbiAgXCJjYXJvblwiOlwiXFx1MDJDN1wiLFxuICBcIkNheWxleXNcIjpcIlxcdTIxMkRcIixcbiAgXCJjY2Fwc1wiOlwiXFx1MkE0RFwiLFxuICBcIkNjYXJvblwiOlwiXFx1MDEwQ1wiLFxuICBcImNjYXJvblwiOlwiXFx1MDEwRFwiLFxuICBcIkNjZWRpbFwiOlwiXFx1MDBDN1wiLFxuICBcImNjZWRpbFwiOlwiXFx1MDBFN1wiLFxuICBcIkNjaXJjXCI6XCJcXHUwMTA4XCIsXG4gIFwiY2NpcmNcIjpcIlxcdTAxMDlcIixcbiAgXCJDY29uaW50XCI6XCJcXHUyMjMwXCIsXG4gIFwiY2N1cHNcIjpcIlxcdTJBNENcIixcbiAgXCJjY3Vwc3NtXCI6XCJcXHUyQTUwXCIsXG4gIFwiQ2RvdFwiOlwiXFx1MDEwQVwiLFxuICBcImNkb3RcIjpcIlxcdTAxMEJcIixcbiAgXCJjZWRpbFwiOlwiXFx1MDBCOFwiLFxuICBcIkNlZGlsbGFcIjpcIlxcdTAwQjhcIixcbiAgXCJjZW1wdHl2XCI6XCJcXHUyOUIyXCIsXG4gIFwiY2VudFwiOlwiXFx1MDBBMlwiLFxuICBcIkNlbnRlckRvdFwiOlwiXFx1MDBCN1wiLFxuICBcImNlbnRlcmRvdFwiOlwiXFx1MDBCN1wiLFxuICBcIkNmclwiOlwiXFx1MjEyRFwiLFxuICBcImNmclwiOlwiXFx1RDgzNVxcdUREMjBcIixcbiAgXCJDSGN5XCI6XCJcXHUwNDI3XCIsXG4gIFwiY2hjeVwiOlwiXFx1MDQ0N1wiLFxuICBcImNoZWNrXCI6XCJcXHUyNzEzXCIsXG4gIFwiY2hlY2ttYXJrXCI6XCJcXHUyNzEzXCIsXG4gIFwiQ2hpXCI6XCJcXHUwM0E3XCIsXG4gIFwiY2hpXCI6XCJcXHUwM0M3XCIsXG4gIFwiY2lyXCI6XCJcXHUyNUNCXCIsXG4gIFwiY2lyY1wiOlwiXFx1MDJDNlwiLFxuICBcImNpcmNlcVwiOlwiXFx1MjI1N1wiLFxuICBcImNpcmNsZWFycm93bGVmdFwiOlwiXFx1MjFCQVwiLFxuICBcImNpcmNsZWFycm93cmlnaHRcIjpcIlxcdTIxQkJcIixcbiAgXCJjaXJjbGVkYXN0XCI6XCJcXHUyMjlCXCIsXG4gIFwiY2lyY2xlZGNpcmNcIjpcIlxcdTIyOUFcIixcbiAgXCJjaXJjbGVkZGFzaFwiOlwiXFx1MjI5RFwiLFxuICBcIkNpcmNsZURvdFwiOlwiXFx1MjI5OVwiLFxuICBcImNpcmNsZWRSXCI6XCJcXHUwMEFFXCIsXG4gIFwiY2lyY2xlZFNcIjpcIlxcdTI0QzhcIixcbiAgXCJDaXJjbGVNaW51c1wiOlwiXFx1MjI5NlwiLFxuICBcIkNpcmNsZVBsdXNcIjpcIlxcdTIyOTVcIixcbiAgXCJDaXJjbGVUaW1lc1wiOlwiXFx1MjI5N1wiLFxuICBcImNpckVcIjpcIlxcdTI5QzNcIixcbiAgXCJjaXJlXCI6XCJcXHUyMjU3XCIsXG4gIFwiY2lyZm5pbnRcIjpcIlxcdTJBMTBcIixcbiAgXCJjaXJtaWRcIjpcIlxcdTJBRUZcIixcbiAgXCJjaXJzY2lyXCI6XCJcXHUyOUMyXCIsXG4gIFwiQ2xvY2t3aXNlQ29udG91ckludGVncmFsXCI6XCJcXHUyMjMyXCIsXG4gIFwiQ2xvc2VDdXJseURvdWJsZVF1b3RlXCI6XCJcXHUyMDFEXCIsXG4gIFwiQ2xvc2VDdXJseVF1b3RlXCI6XCJcXHUyMDE5XCIsXG4gIFwiY2x1YnNcIjpcIlxcdTI2NjNcIixcbiAgXCJjbHVic3VpdFwiOlwiXFx1MjY2M1wiLFxuICBcIkNvbG9uXCI6XCJcXHUyMjM3XCIsXG4gIFwiY29sb25cIjpcIlxcdTAwM0FcIixcbiAgXCJDb2xvbmVcIjpcIlxcdTJBNzRcIixcbiAgXCJjb2xvbmVcIjpcIlxcdTIyNTRcIixcbiAgXCJjb2xvbmVxXCI6XCJcXHUyMjU0XCIsXG4gIFwiY29tbWFcIjpcIlxcdTAwMkNcIixcbiAgXCJjb21tYXRcIjpcIlxcdTAwNDBcIixcbiAgXCJjb21wXCI6XCJcXHUyMjAxXCIsXG4gIFwiY29tcGZuXCI6XCJcXHUyMjE4XCIsXG4gIFwiY29tcGxlbWVudFwiOlwiXFx1MjIwMVwiLFxuICBcImNvbXBsZXhlc1wiOlwiXFx1MjEwMlwiLFxuICBcImNvbmdcIjpcIlxcdTIyNDVcIixcbiAgXCJjb25nZG90XCI6XCJcXHUyQTZEXCIsXG4gIFwiQ29uZ3J1ZW50XCI6XCJcXHUyMjYxXCIsXG4gIFwiQ29uaW50XCI6XCJcXHUyMjJGXCIsXG4gIFwiY29uaW50XCI6XCJcXHUyMjJFXCIsXG4gIFwiQ29udG91ckludGVncmFsXCI6XCJcXHUyMjJFXCIsXG4gIFwiQ29wZlwiOlwiXFx1MjEwMlwiLFxuICBcImNvcGZcIjpcIlxcdUQ4MzVcXHVERDU0XCIsXG4gIFwiY29wcm9kXCI6XCJcXHUyMjEwXCIsXG4gIFwiQ29wcm9kdWN0XCI6XCJcXHUyMjEwXCIsXG4gIFwiQ09QWVwiOlwiXFx1MDBBOVwiLFxuICBcImNvcHlcIjpcIlxcdTAwQTlcIixcbiAgXCJjb3B5c3JcIjpcIlxcdTIxMTdcIixcbiAgXCJDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsXCI6XCJcXHUyMjMzXCIsXG4gIFwiY3JhcnJcIjpcIlxcdTIxQjVcIixcbiAgXCJDcm9zc1wiOlwiXFx1MkEyRlwiLFxuICBcImNyb3NzXCI6XCJcXHUyNzE3XCIsXG4gIFwiQ3NjclwiOlwiXFx1RDgzNVxcdURDOUVcIixcbiAgXCJjc2NyXCI6XCJcXHVEODM1XFx1RENCOFwiLFxuICBcImNzdWJcIjpcIlxcdTJBQ0ZcIixcbiAgXCJjc3ViZVwiOlwiXFx1MkFEMVwiLFxuICBcImNzdXBcIjpcIlxcdTJBRDBcIixcbiAgXCJjc3VwZVwiOlwiXFx1MkFEMlwiLFxuICBcImN0ZG90XCI6XCJcXHUyMkVGXCIsXG4gIFwiY3VkYXJybFwiOlwiXFx1MjkzOFwiLFxuICBcImN1ZGFycnJcIjpcIlxcdTI5MzVcIixcbiAgXCJjdWVwclwiOlwiXFx1MjJERVwiLFxuICBcImN1ZXNjXCI6XCJcXHUyMkRGXCIsXG4gIFwiY3VsYXJyXCI6XCJcXHUyMUI2XCIsXG4gIFwiY3VsYXJycFwiOlwiXFx1MjkzRFwiLFxuICBcIkN1cFwiOlwiXFx1MjJEM1wiLFxuICBcImN1cFwiOlwiXFx1MjIyQVwiLFxuICBcImN1cGJyY2FwXCI6XCJcXHUyQTQ4XCIsXG4gIFwiQ3VwQ2FwXCI6XCJcXHUyMjREXCIsXG4gIFwiY3VwY2FwXCI6XCJcXHUyQTQ2XCIsXG4gIFwiY3VwY3VwXCI6XCJcXHUyQTRBXCIsXG4gIFwiY3VwZG90XCI6XCJcXHUyMjhEXCIsXG4gIFwiY3Vwb3JcIjpcIlxcdTJBNDVcIixcbiAgXCJjdXBzXCI6XCJcXHUyMjJBXFx1RkUwMFwiLFxuICBcImN1cmFyclwiOlwiXFx1MjFCN1wiLFxuICBcImN1cmFycm1cIjpcIlxcdTI5M0NcIixcbiAgXCJjdXJseWVxcHJlY1wiOlwiXFx1MjJERVwiLFxuICBcImN1cmx5ZXFzdWNjXCI6XCJcXHUyMkRGXCIsXG4gIFwiY3VybHl2ZWVcIjpcIlxcdTIyQ0VcIixcbiAgXCJjdXJseXdlZGdlXCI6XCJcXHUyMkNGXCIsXG4gIFwiY3VycmVuXCI6XCJcXHUwMEE0XCIsXG4gIFwiY3VydmVhcnJvd2xlZnRcIjpcIlxcdTIxQjZcIixcbiAgXCJjdXJ2ZWFycm93cmlnaHRcIjpcIlxcdTIxQjdcIixcbiAgXCJjdXZlZVwiOlwiXFx1MjJDRVwiLFxuICBcImN1d2VkXCI6XCJcXHUyMkNGXCIsXG4gIFwiY3djb25pbnRcIjpcIlxcdTIyMzJcIixcbiAgXCJjd2ludFwiOlwiXFx1MjIzMVwiLFxuICBcImN5bGN0eVwiOlwiXFx1MjMyRFwiLFxuICBcIkRhZ2dlclwiOlwiXFx1MjAyMVwiLFxuICBcImRhZ2dlclwiOlwiXFx1MjAyMFwiLFxuICBcImRhbGV0aFwiOlwiXFx1MjEzOFwiLFxuICBcIkRhcnJcIjpcIlxcdTIxQTFcIixcbiAgXCJkQXJyXCI6XCJcXHUyMUQzXCIsXG4gIFwiZGFyclwiOlwiXFx1MjE5M1wiLFxuICBcImRhc2hcIjpcIlxcdTIwMTBcIixcbiAgXCJEYXNodlwiOlwiXFx1MkFFNFwiLFxuICBcImRhc2h2XCI6XCJcXHUyMkEzXCIsXG4gIFwiZGJrYXJvd1wiOlwiXFx1MjkwRlwiLFxuICBcImRibGFjXCI6XCJcXHUwMkREXCIsXG4gIFwiRGNhcm9uXCI6XCJcXHUwMTBFXCIsXG4gIFwiZGNhcm9uXCI6XCJcXHUwMTBGXCIsXG4gIFwiRGN5XCI6XCJcXHUwNDE0XCIsXG4gIFwiZGN5XCI6XCJcXHUwNDM0XCIsXG4gIFwiRERcIjpcIlxcdTIxNDVcIixcbiAgXCJkZFwiOlwiXFx1MjE0NlwiLFxuICBcImRkYWdnZXJcIjpcIlxcdTIwMjFcIixcbiAgXCJkZGFyclwiOlwiXFx1MjFDQVwiLFxuICBcIkREb3RyYWhkXCI6XCJcXHUyOTExXCIsXG4gIFwiZGRvdHNlcVwiOlwiXFx1MkE3N1wiLFxuICBcImRlZ1wiOlwiXFx1MDBCMFwiLFxuICBcIkRlbFwiOlwiXFx1MjIwN1wiLFxuICBcIkRlbHRhXCI6XCJcXHUwMzk0XCIsXG4gIFwiZGVsdGFcIjpcIlxcdTAzQjRcIixcbiAgXCJkZW1wdHl2XCI6XCJcXHUyOUIxXCIsXG4gIFwiZGZpc2h0XCI6XCJcXHUyOTdGXCIsXG4gIFwiRGZyXCI6XCJcXHVEODM1XFx1REQwN1wiLFxuICBcImRmclwiOlwiXFx1RDgzNVxcdUREMjFcIixcbiAgXCJkSGFyXCI6XCJcXHUyOTY1XCIsXG4gIFwiZGhhcmxcIjpcIlxcdTIxQzNcIixcbiAgXCJkaGFyclwiOlwiXFx1MjFDMlwiLFxuICBcIkRpYWNyaXRpY2FsQWN1dGVcIjpcIlxcdTAwQjRcIixcbiAgXCJEaWFjcml0aWNhbERvdFwiOlwiXFx1MDJEOVwiLFxuICBcIkRpYWNyaXRpY2FsRG91YmxlQWN1dGVcIjpcIlxcdTAyRERcIixcbiAgXCJEaWFjcml0aWNhbEdyYXZlXCI6XCJcXHUwMDYwXCIsXG4gIFwiRGlhY3JpdGljYWxUaWxkZVwiOlwiXFx1MDJEQ1wiLFxuICBcImRpYW1cIjpcIlxcdTIyQzRcIixcbiAgXCJEaWFtb25kXCI6XCJcXHUyMkM0XCIsXG4gIFwiZGlhbW9uZFwiOlwiXFx1MjJDNFwiLFxuICBcImRpYW1vbmRzdWl0XCI6XCJcXHUyNjY2XCIsXG4gIFwiZGlhbXNcIjpcIlxcdTI2NjZcIixcbiAgXCJkaWVcIjpcIlxcdTAwQThcIixcbiAgXCJEaWZmZXJlbnRpYWxEXCI6XCJcXHUyMTQ2XCIsXG4gIFwiZGlnYW1tYVwiOlwiXFx1MDNERFwiLFxuICBcImRpc2luXCI6XCJcXHUyMkYyXCIsXG4gIFwiZGl2XCI6XCJcXHUwMEY3XCIsXG4gIFwiZGl2aWRlXCI6XCJcXHUwMEY3XCIsXG4gIFwiZGl2aWRlb250aW1lc1wiOlwiXFx1MjJDN1wiLFxuICBcImRpdm9ueFwiOlwiXFx1MjJDN1wiLFxuICBcIkRKY3lcIjpcIlxcdTA0MDJcIixcbiAgXCJkamN5XCI6XCJcXHUwNDUyXCIsXG4gIFwiZGxjb3JuXCI6XCJcXHUyMzFFXCIsXG4gIFwiZGxjcm9wXCI6XCJcXHUyMzBEXCIsXG4gIFwiZG9sbGFyXCI6XCJcXHUwMDI0XCIsXG4gIFwiRG9wZlwiOlwiXFx1RDgzNVxcdUREM0JcIixcbiAgXCJkb3BmXCI6XCJcXHVEODM1XFx1REQ1NVwiLFxuICBcIkRvdFwiOlwiXFx1MDBBOFwiLFxuICBcImRvdFwiOlwiXFx1MDJEOVwiLFxuICBcIkRvdERvdFwiOlwiXFx1MjBEQ1wiLFxuICBcImRvdGVxXCI6XCJcXHUyMjUwXCIsXG4gIFwiZG90ZXFkb3RcIjpcIlxcdTIyNTFcIixcbiAgXCJEb3RFcXVhbFwiOlwiXFx1MjI1MFwiLFxuICBcImRvdG1pbnVzXCI6XCJcXHUyMjM4XCIsXG4gIFwiZG90cGx1c1wiOlwiXFx1MjIxNFwiLFxuICBcImRvdHNxdWFyZVwiOlwiXFx1MjJBMVwiLFxuICBcImRvdWJsZWJhcndlZGdlXCI6XCJcXHUyMzA2XCIsXG4gIFwiRG91YmxlQ29udG91ckludGVncmFsXCI6XCJcXHUyMjJGXCIsXG4gIFwiRG91YmxlRG90XCI6XCJcXHUwMEE4XCIsXG4gIFwiRG91YmxlRG93bkFycm93XCI6XCJcXHUyMUQzXCIsXG4gIFwiRG91YmxlTGVmdEFycm93XCI6XCJcXHUyMUQwXCIsXG4gIFwiRG91YmxlTGVmdFJpZ2h0QXJyb3dcIjpcIlxcdTIxRDRcIixcbiAgXCJEb3VibGVMZWZ0VGVlXCI6XCJcXHUyQUU0XCIsXG4gIFwiRG91YmxlTG9uZ0xlZnRBcnJvd1wiOlwiXFx1MjdGOFwiLFxuICBcIkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvd1wiOlwiXFx1MjdGQVwiLFxuICBcIkRvdWJsZUxvbmdSaWdodEFycm93XCI6XCJcXHUyN0Y5XCIsXG4gIFwiRG91YmxlUmlnaHRBcnJvd1wiOlwiXFx1MjFEMlwiLFxuICBcIkRvdWJsZVJpZ2h0VGVlXCI6XCJcXHUyMkE4XCIsXG4gIFwiRG91YmxlVXBBcnJvd1wiOlwiXFx1MjFEMVwiLFxuICBcIkRvdWJsZVVwRG93bkFycm93XCI6XCJcXHUyMUQ1XCIsXG4gIFwiRG91YmxlVmVydGljYWxCYXJcIjpcIlxcdTIyMjVcIixcbiAgXCJEb3duQXJyb3dcIjpcIlxcdTIxOTNcIixcbiAgXCJEb3duYXJyb3dcIjpcIlxcdTIxRDNcIixcbiAgXCJkb3duYXJyb3dcIjpcIlxcdTIxOTNcIixcbiAgXCJEb3duQXJyb3dCYXJcIjpcIlxcdTI5MTNcIixcbiAgXCJEb3duQXJyb3dVcEFycm93XCI6XCJcXHUyMUY1XCIsXG4gIFwiRG93bkJyZXZlXCI6XCJcXHUwMzExXCIsXG4gIFwiZG93bmRvd25hcnJvd3NcIjpcIlxcdTIxQ0FcIixcbiAgXCJkb3duaGFycG9vbmxlZnRcIjpcIlxcdTIxQzNcIixcbiAgXCJkb3duaGFycG9vbnJpZ2h0XCI6XCJcXHUyMUMyXCIsXG4gIFwiRG93bkxlZnRSaWdodFZlY3RvclwiOlwiXFx1Mjk1MFwiLFxuICBcIkRvd25MZWZ0VGVlVmVjdG9yXCI6XCJcXHUyOTVFXCIsXG4gIFwiRG93bkxlZnRWZWN0b3JcIjpcIlxcdTIxQkRcIixcbiAgXCJEb3duTGVmdFZlY3RvckJhclwiOlwiXFx1Mjk1NlwiLFxuICBcIkRvd25SaWdodFRlZVZlY3RvclwiOlwiXFx1Mjk1RlwiLFxuICBcIkRvd25SaWdodFZlY3RvclwiOlwiXFx1MjFDMVwiLFxuICBcIkRvd25SaWdodFZlY3RvckJhclwiOlwiXFx1Mjk1N1wiLFxuICBcIkRvd25UZWVcIjpcIlxcdTIyQTRcIixcbiAgXCJEb3duVGVlQXJyb3dcIjpcIlxcdTIxQTdcIixcbiAgXCJkcmJrYXJvd1wiOlwiXFx1MjkxMFwiLFxuICBcImRyY29yblwiOlwiXFx1MjMxRlwiLFxuICBcImRyY3JvcFwiOlwiXFx1MjMwQ1wiLFxuICBcIkRzY3JcIjpcIlxcdUQ4MzVcXHVEQzlGXCIsXG4gIFwiZHNjclwiOlwiXFx1RDgzNVxcdURDQjlcIixcbiAgXCJEU2N5XCI6XCJcXHUwNDA1XCIsXG4gIFwiZHNjeVwiOlwiXFx1MDQ1NVwiLFxuICBcImRzb2xcIjpcIlxcdTI5RjZcIixcbiAgXCJEc3Ryb2tcIjpcIlxcdTAxMTBcIixcbiAgXCJkc3Ryb2tcIjpcIlxcdTAxMTFcIixcbiAgXCJkdGRvdFwiOlwiXFx1MjJGMVwiLFxuICBcImR0cmlcIjpcIlxcdTI1QkZcIixcbiAgXCJkdHJpZlwiOlwiXFx1MjVCRVwiLFxuICBcImR1YXJyXCI6XCJcXHUyMUY1XCIsXG4gIFwiZHVoYXJcIjpcIlxcdTI5NkZcIixcbiAgXCJkd2FuZ2xlXCI6XCJcXHUyOUE2XCIsXG4gIFwiRFpjeVwiOlwiXFx1MDQwRlwiLFxuICBcImR6Y3lcIjpcIlxcdTA0NUZcIixcbiAgXCJkemlncmFyclwiOlwiXFx1MjdGRlwiLFxuICBcIkVhY3V0ZVwiOlwiXFx1MDBDOVwiLFxuICBcImVhY3V0ZVwiOlwiXFx1MDBFOVwiLFxuICBcImVhc3RlclwiOlwiXFx1MkE2RVwiLFxuICBcIkVjYXJvblwiOlwiXFx1MDExQVwiLFxuICBcImVjYXJvblwiOlwiXFx1MDExQlwiLFxuICBcImVjaXJcIjpcIlxcdTIyNTZcIixcbiAgXCJFY2lyY1wiOlwiXFx1MDBDQVwiLFxuICBcImVjaXJjXCI6XCJcXHUwMEVBXCIsXG4gIFwiZWNvbG9uXCI6XCJcXHUyMjU1XCIsXG4gIFwiRWN5XCI6XCJcXHUwNDJEXCIsXG4gIFwiZWN5XCI6XCJcXHUwNDREXCIsXG4gIFwiZUREb3RcIjpcIlxcdTJBNzdcIixcbiAgXCJFZG90XCI6XCJcXHUwMTE2XCIsXG4gIFwiZURvdFwiOlwiXFx1MjI1MVwiLFxuICBcImVkb3RcIjpcIlxcdTAxMTdcIixcbiAgXCJlZVwiOlwiXFx1MjE0N1wiLFxuICBcImVmRG90XCI6XCJcXHUyMjUyXCIsXG4gIFwiRWZyXCI6XCJcXHVEODM1XFx1REQwOFwiLFxuICBcImVmclwiOlwiXFx1RDgzNVxcdUREMjJcIixcbiAgXCJlZ1wiOlwiXFx1MkE5QVwiLFxuICBcIkVncmF2ZVwiOlwiXFx1MDBDOFwiLFxuICBcImVncmF2ZVwiOlwiXFx1MDBFOFwiLFxuICBcImVnc1wiOlwiXFx1MkE5NlwiLFxuICBcImVnc2RvdFwiOlwiXFx1MkE5OFwiLFxuICBcImVsXCI6XCJcXHUyQTk5XCIsXG4gIFwiRWxlbWVudFwiOlwiXFx1MjIwOFwiLFxuICBcImVsaW50ZXJzXCI6XCJcXHUyM0U3XCIsXG4gIFwiZWxsXCI6XCJcXHUyMTEzXCIsXG4gIFwiZWxzXCI6XCJcXHUyQTk1XCIsXG4gIFwiZWxzZG90XCI6XCJcXHUyQTk3XCIsXG4gIFwiRW1hY3JcIjpcIlxcdTAxMTJcIixcbiAgXCJlbWFjclwiOlwiXFx1MDExM1wiLFxuICBcImVtcHR5XCI6XCJcXHUyMjA1XCIsXG4gIFwiZW1wdHlzZXRcIjpcIlxcdTIyMDVcIixcbiAgXCJFbXB0eVNtYWxsU3F1YXJlXCI6XCJcXHUyNUZCXCIsXG4gIFwiZW1wdHl2XCI6XCJcXHUyMjA1XCIsXG4gIFwiRW1wdHlWZXJ5U21hbGxTcXVhcmVcIjpcIlxcdTI1QUJcIixcbiAgXCJlbXNwXCI6XCJcXHUyMDAzXCIsXG4gIFwiZW1zcDEzXCI6XCJcXHUyMDA0XCIsXG4gIFwiZW1zcDE0XCI6XCJcXHUyMDA1XCIsXG4gIFwiRU5HXCI6XCJcXHUwMTRBXCIsXG4gIFwiZW5nXCI6XCJcXHUwMTRCXCIsXG4gIFwiZW5zcFwiOlwiXFx1MjAwMlwiLFxuICBcIkVvZ29uXCI6XCJcXHUwMTE4XCIsXG4gIFwiZW9nb25cIjpcIlxcdTAxMTlcIixcbiAgXCJFb3BmXCI6XCJcXHVEODM1XFx1REQzQ1wiLFxuICBcImVvcGZcIjpcIlxcdUQ4MzVcXHVERDU2XCIsXG4gIFwiZXBhclwiOlwiXFx1MjJENVwiLFxuICBcImVwYXJzbFwiOlwiXFx1MjlFM1wiLFxuICBcImVwbHVzXCI6XCJcXHUyQTcxXCIsXG4gIFwiZXBzaVwiOlwiXFx1MDNCNVwiLFxuICBcIkVwc2lsb25cIjpcIlxcdTAzOTVcIixcbiAgXCJlcHNpbG9uXCI6XCJcXHUwM0I1XCIsXG4gIFwiZXBzaXZcIjpcIlxcdTAzRjVcIixcbiAgXCJlcWNpcmNcIjpcIlxcdTIyNTZcIixcbiAgXCJlcWNvbG9uXCI6XCJcXHUyMjU1XCIsXG4gIFwiZXFzaW1cIjpcIlxcdTIyNDJcIixcbiAgXCJlcXNsYW50Z3RyXCI6XCJcXHUyQTk2XCIsXG4gIFwiZXFzbGFudGxlc3NcIjpcIlxcdTJBOTVcIixcbiAgXCJFcXVhbFwiOlwiXFx1MkE3NVwiLFxuICBcImVxdWFsc1wiOlwiXFx1MDAzRFwiLFxuICBcIkVxdWFsVGlsZGVcIjpcIlxcdTIyNDJcIixcbiAgXCJlcXVlc3RcIjpcIlxcdTIyNUZcIixcbiAgXCJFcXVpbGlicml1bVwiOlwiXFx1MjFDQ1wiLFxuICBcImVxdWl2XCI6XCJcXHUyMjYxXCIsXG4gIFwiZXF1aXZERFwiOlwiXFx1MkE3OFwiLFxuICBcImVxdnBhcnNsXCI6XCJcXHUyOUU1XCIsXG4gIFwiZXJhcnJcIjpcIlxcdTI5NzFcIixcbiAgXCJlckRvdFwiOlwiXFx1MjI1M1wiLFxuICBcIkVzY3JcIjpcIlxcdTIxMzBcIixcbiAgXCJlc2NyXCI6XCJcXHUyMTJGXCIsXG4gIFwiZXNkb3RcIjpcIlxcdTIyNTBcIixcbiAgXCJFc2ltXCI6XCJcXHUyQTczXCIsXG4gIFwiZXNpbVwiOlwiXFx1MjI0MlwiLFxuICBcIkV0YVwiOlwiXFx1MDM5N1wiLFxuICBcImV0YVwiOlwiXFx1MDNCN1wiLFxuICBcIkVUSFwiOlwiXFx1MDBEMFwiLFxuICBcImV0aFwiOlwiXFx1MDBGMFwiLFxuICBcIkV1bWxcIjpcIlxcdTAwQ0JcIixcbiAgXCJldW1sXCI6XCJcXHUwMEVCXCIsXG4gIFwiZXVyb1wiOlwiXFx1MjBBQ1wiLFxuICBcImV4Y2xcIjpcIlxcdTAwMjFcIixcbiAgXCJleGlzdFwiOlwiXFx1MjIwM1wiLFxuICBcIkV4aXN0c1wiOlwiXFx1MjIwM1wiLFxuICBcImV4cGVjdGF0aW9uXCI6XCJcXHUyMTMwXCIsXG4gIFwiRXhwb25lbnRpYWxFXCI6XCJcXHUyMTQ3XCIsXG4gIFwiZXhwb25lbnRpYWxlXCI6XCJcXHUyMTQ3XCIsXG4gIFwiZmFsbGluZ2RvdHNlcVwiOlwiXFx1MjI1MlwiLFxuICBcIkZjeVwiOlwiXFx1MDQyNFwiLFxuICBcImZjeVwiOlwiXFx1MDQ0NFwiLFxuICBcImZlbWFsZVwiOlwiXFx1MjY0MFwiLFxuICBcImZmaWxpZ1wiOlwiXFx1RkIwM1wiLFxuICBcImZmbGlnXCI6XCJcXHVGQjAwXCIsXG4gIFwiZmZsbGlnXCI6XCJcXHVGQjA0XCIsXG4gIFwiRmZyXCI6XCJcXHVEODM1XFx1REQwOVwiLFxuICBcImZmclwiOlwiXFx1RDgzNVxcdUREMjNcIixcbiAgXCJmaWxpZ1wiOlwiXFx1RkIwMVwiLFxuICBcIkZpbGxlZFNtYWxsU3F1YXJlXCI6XCJcXHUyNUZDXCIsXG4gIFwiRmlsbGVkVmVyeVNtYWxsU3F1YXJlXCI6XCJcXHUyNUFBXCIsXG4gIFwiZmpsaWdcIjpcIlxcdTAwNjZcXHUwMDZBXCIsXG4gIFwiZmxhdFwiOlwiXFx1MjY2RFwiLFxuICBcImZsbGlnXCI6XCJcXHVGQjAyXCIsXG4gIFwiZmx0bnNcIjpcIlxcdTI1QjFcIixcbiAgXCJmbm9mXCI6XCJcXHUwMTkyXCIsXG4gIFwiRm9wZlwiOlwiXFx1RDgzNVxcdUREM0RcIixcbiAgXCJmb3BmXCI6XCJcXHVEODM1XFx1REQ1N1wiLFxuICBcIkZvckFsbFwiOlwiXFx1MjIwMFwiLFxuICBcImZvcmFsbFwiOlwiXFx1MjIwMFwiLFxuICBcImZvcmtcIjpcIlxcdTIyRDRcIixcbiAgXCJmb3JrdlwiOlwiXFx1MkFEOVwiLFxuICBcIkZvdXJpZXJ0cmZcIjpcIlxcdTIxMzFcIixcbiAgXCJmcGFydGludFwiOlwiXFx1MkEwRFwiLFxuICBcImZyYWMxMlwiOlwiXFx1MDBCRFwiLFxuICBcImZyYWMxM1wiOlwiXFx1MjE1M1wiLFxuICBcImZyYWMxNFwiOlwiXFx1MDBCQ1wiLFxuICBcImZyYWMxNVwiOlwiXFx1MjE1NVwiLFxuICBcImZyYWMxNlwiOlwiXFx1MjE1OVwiLFxuICBcImZyYWMxOFwiOlwiXFx1MjE1QlwiLFxuICBcImZyYWMyM1wiOlwiXFx1MjE1NFwiLFxuICBcImZyYWMyNVwiOlwiXFx1MjE1NlwiLFxuICBcImZyYWMzNFwiOlwiXFx1MDBCRVwiLFxuICBcImZyYWMzNVwiOlwiXFx1MjE1N1wiLFxuICBcImZyYWMzOFwiOlwiXFx1MjE1Q1wiLFxuICBcImZyYWM0NVwiOlwiXFx1MjE1OFwiLFxuICBcImZyYWM1NlwiOlwiXFx1MjE1QVwiLFxuICBcImZyYWM1OFwiOlwiXFx1MjE1RFwiLFxuICBcImZyYWM3OFwiOlwiXFx1MjE1RVwiLFxuICBcImZyYXNsXCI6XCJcXHUyMDQ0XCIsXG4gIFwiZnJvd25cIjpcIlxcdTIzMjJcIixcbiAgXCJGc2NyXCI6XCJcXHUyMTMxXCIsXG4gIFwiZnNjclwiOlwiXFx1RDgzNVxcdURDQkJcIixcbiAgXCJnYWN1dGVcIjpcIlxcdTAxRjVcIixcbiAgXCJHYW1tYVwiOlwiXFx1MDM5M1wiLFxuICBcImdhbW1hXCI6XCJcXHUwM0IzXCIsXG4gIFwiR2FtbWFkXCI6XCJcXHUwM0RDXCIsXG4gIFwiZ2FtbWFkXCI6XCJcXHUwM0REXCIsXG4gIFwiZ2FwXCI6XCJcXHUyQTg2XCIsXG4gIFwiR2JyZXZlXCI6XCJcXHUwMTFFXCIsXG4gIFwiZ2JyZXZlXCI6XCJcXHUwMTFGXCIsXG4gIFwiR2NlZGlsXCI6XCJcXHUwMTIyXCIsXG4gIFwiR2NpcmNcIjpcIlxcdTAxMUNcIixcbiAgXCJnY2lyY1wiOlwiXFx1MDExRFwiLFxuICBcIkdjeVwiOlwiXFx1MDQxM1wiLFxuICBcImdjeVwiOlwiXFx1MDQzM1wiLFxuICBcIkdkb3RcIjpcIlxcdTAxMjBcIixcbiAgXCJnZG90XCI6XCJcXHUwMTIxXCIsXG4gIFwiZ0VcIjpcIlxcdTIyNjdcIixcbiAgXCJnZVwiOlwiXFx1MjI2NVwiLFxuICBcImdFbFwiOlwiXFx1MkE4Q1wiLFxuICBcImdlbFwiOlwiXFx1MjJEQlwiLFxuICBcImdlcVwiOlwiXFx1MjI2NVwiLFxuICBcImdlcXFcIjpcIlxcdTIyNjdcIixcbiAgXCJnZXFzbGFudFwiOlwiXFx1MkE3RVwiLFxuICBcImdlc1wiOlwiXFx1MkE3RVwiLFxuICBcImdlc2NjXCI6XCJcXHUyQUE5XCIsXG4gIFwiZ2VzZG90XCI6XCJcXHUyQTgwXCIsXG4gIFwiZ2VzZG90b1wiOlwiXFx1MkE4MlwiLFxuICBcImdlc2RvdG9sXCI6XCJcXHUyQTg0XCIsXG4gIFwiZ2VzbFwiOlwiXFx1MjJEQlxcdUZFMDBcIixcbiAgXCJnZXNsZXNcIjpcIlxcdTJBOTRcIixcbiAgXCJHZnJcIjpcIlxcdUQ4MzVcXHVERDBBXCIsXG4gIFwiZ2ZyXCI6XCJcXHVEODM1XFx1REQyNFwiLFxuICBcIkdnXCI6XCJcXHUyMkQ5XCIsXG4gIFwiZ2dcIjpcIlxcdTIyNkJcIixcbiAgXCJnZ2dcIjpcIlxcdTIyRDlcIixcbiAgXCJnaW1lbFwiOlwiXFx1MjEzN1wiLFxuICBcIkdKY3lcIjpcIlxcdTA0MDNcIixcbiAgXCJnamN5XCI6XCJcXHUwNDUzXCIsXG4gIFwiZ2xcIjpcIlxcdTIyNzdcIixcbiAgXCJnbGFcIjpcIlxcdTJBQTVcIixcbiAgXCJnbEVcIjpcIlxcdTJBOTJcIixcbiAgXCJnbGpcIjpcIlxcdTJBQTRcIixcbiAgXCJnbmFwXCI6XCJcXHUyQThBXCIsXG4gIFwiZ25hcHByb3hcIjpcIlxcdTJBOEFcIixcbiAgXCJnbkVcIjpcIlxcdTIyNjlcIixcbiAgXCJnbmVcIjpcIlxcdTJBODhcIixcbiAgXCJnbmVxXCI6XCJcXHUyQTg4XCIsXG4gIFwiZ25lcXFcIjpcIlxcdTIyNjlcIixcbiAgXCJnbnNpbVwiOlwiXFx1MjJFN1wiLFxuICBcIkdvcGZcIjpcIlxcdUQ4MzVcXHVERDNFXCIsXG4gIFwiZ29wZlwiOlwiXFx1RDgzNVxcdURENThcIixcbiAgXCJncmF2ZVwiOlwiXFx1MDA2MFwiLFxuICBcIkdyZWF0ZXJFcXVhbFwiOlwiXFx1MjI2NVwiLFxuICBcIkdyZWF0ZXJFcXVhbExlc3NcIjpcIlxcdTIyREJcIixcbiAgXCJHcmVhdGVyRnVsbEVxdWFsXCI6XCJcXHUyMjY3XCIsXG4gIFwiR3JlYXRlckdyZWF0ZXJcIjpcIlxcdTJBQTJcIixcbiAgXCJHcmVhdGVyTGVzc1wiOlwiXFx1MjI3N1wiLFxuICBcIkdyZWF0ZXJTbGFudEVxdWFsXCI6XCJcXHUyQTdFXCIsXG4gIFwiR3JlYXRlclRpbGRlXCI6XCJcXHUyMjczXCIsXG4gIFwiR3NjclwiOlwiXFx1RDgzNVxcdURDQTJcIixcbiAgXCJnc2NyXCI6XCJcXHUyMTBBXCIsXG4gIFwiZ3NpbVwiOlwiXFx1MjI3M1wiLFxuICBcImdzaW1lXCI6XCJcXHUyQThFXCIsXG4gIFwiZ3NpbWxcIjpcIlxcdTJBOTBcIixcbiAgXCJHVFwiOlwiXFx1MDAzRVwiLFxuICBcIkd0XCI6XCJcXHUyMjZCXCIsXG4gIFwiZ3RcIjpcIlxcdTAwM0VcIixcbiAgXCJndGNjXCI6XCJcXHUyQUE3XCIsXG4gIFwiZ3RjaXJcIjpcIlxcdTJBN0FcIixcbiAgXCJndGRvdFwiOlwiXFx1MjJEN1wiLFxuICBcImd0bFBhclwiOlwiXFx1Mjk5NVwiLFxuICBcImd0cXVlc3RcIjpcIlxcdTJBN0NcIixcbiAgXCJndHJhcHByb3hcIjpcIlxcdTJBODZcIixcbiAgXCJndHJhcnJcIjpcIlxcdTI5NzhcIixcbiAgXCJndHJkb3RcIjpcIlxcdTIyRDdcIixcbiAgXCJndHJlcWxlc3NcIjpcIlxcdTIyREJcIixcbiAgXCJndHJlcXFsZXNzXCI6XCJcXHUyQThDXCIsXG4gIFwiZ3RybGVzc1wiOlwiXFx1MjI3N1wiLFxuICBcImd0cnNpbVwiOlwiXFx1MjI3M1wiLFxuICBcImd2ZXJ0bmVxcVwiOlwiXFx1MjI2OVxcdUZFMDBcIixcbiAgXCJndm5FXCI6XCJcXHUyMjY5XFx1RkUwMFwiLFxuICBcIkhhY2VrXCI6XCJcXHUwMkM3XCIsXG4gIFwiaGFpcnNwXCI6XCJcXHUyMDBBXCIsXG4gIFwiaGFsZlwiOlwiXFx1MDBCRFwiLFxuICBcImhhbWlsdFwiOlwiXFx1MjEwQlwiLFxuICBcIkhBUkRjeVwiOlwiXFx1MDQyQVwiLFxuICBcImhhcmRjeVwiOlwiXFx1MDQ0QVwiLFxuICBcImhBcnJcIjpcIlxcdTIxRDRcIixcbiAgXCJoYXJyXCI6XCJcXHUyMTk0XCIsXG4gIFwiaGFycmNpclwiOlwiXFx1Mjk0OFwiLFxuICBcImhhcnJ3XCI6XCJcXHUyMUFEXCIsXG4gIFwiSGF0XCI6XCJcXHUwMDVFXCIsXG4gIFwiaGJhclwiOlwiXFx1MjEwRlwiLFxuICBcIkhjaXJjXCI6XCJcXHUwMTI0XCIsXG4gIFwiaGNpcmNcIjpcIlxcdTAxMjVcIixcbiAgXCJoZWFydHNcIjpcIlxcdTI2NjVcIixcbiAgXCJoZWFydHN1aXRcIjpcIlxcdTI2NjVcIixcbiAgXCJoZWxsaXBcIjpcIlxcdTIwMjZcIixcbiAgXCJoZXJjb25cIjpcIlxcdTIyQjlcIixcbiAgXCJIZnJcIjpcIlxcdTIxMENcIixcbiAgXCJoZnJcIjpcIlxcdUQ4MzVcXHVERDI1XCIsXG4gIFwiSGlsYmVydFNwYWNlXCI6XCJcXHUyMTBCXCIsXG4gIFwiaGtzZWFyb3dcIjpcIlxcdTI5MjVcIixcbiAgXCJoa3N3YXJvd1wiOlwiXFx1MjkyNlwiLFxuICBcImhvYXJyXCI6XCJcXHUyMUZGXCIsXG4gIFwiaG9tdGh0XCI6XCJcXHUyMjNCXCIsXG4gIFwiaG9va2xlZnRhcnJvd1wiOlwiXFx1MjFBOVwiLFxuICBcImhvb2tyaWdodGFycm93XCI6XCJcXHUyMUFBXCIsXG4gIFwiSG9wZlwiOlwiXFx1MjEwRFwiLFxuICBcImhvcGZcIjpcIlxcdUQ4MzVcXHVERDU5XCIsXG4gIFwiaG9yYmFyXCI6XCJcXHUyMDE1XCIsXG4gIFwiSG9yaXpvbnRhbExpbmVcIjpcIlxcdTI1MDBcIixcbiAgXCJIc2NyXCI6XCJcXHUyMTBCXCIsXG4gIFwiaHNjclwiOlwiXFx1RDgzNVxcdURDQkRcIixcbiAgXCJoc2xhc2hcIjpcIlxcdTIxMEZcIixcbiAgXCJIc3Ryb2tcIjpcIlxcdTAxMjZcIixcbiAgXCJoc3Ryb2tcIjpcIlxcdTAxMjdcIixcbiAgXCJIdW1wRG93bkh1bXBcIjpcIlxcdTIyNEVcIixcbiAgXCJIdW1wRXF1YWxcIjpcIlxcdTIyNEZcIixcbiAgXCJoeWJ1bGxcIjpcIlxcdTIwNDNcIixcbiAgXCJoeXBoZW5cIjpcIlxcdTIwMTBcIixcbiAgXCJJYWN1dGVcIjpcIlxcdTAwQ0RcIixcbiAgXCJpYWN1dGVcIjpcIlxcdTAwRURcIixcbiAgXCJpY1wiOlwiXFx1MjA2M1wiLFxuICBcIkljaXJjXCI6XCJcXHUwMENFXCIsXG4gIFwiaWNpcmNcIjpcIlxcdTAwRUVcIixcbiAgXCJJY3lcIjpcIlxcdTA0MThcIixcbiAgXCJpY3lcIjpcIlxcdTA0MzhcIixcbiAgXCJJZG90XCI6XCJcXHUwMTMwXCIsXG4gIFwiSUVjeVwiOlwiXFx1MDQxNVwiLFxuICBcImllY3lcIjpcIlxcdTA0MzVcIixcbiAgXCJpZXhjbFwiOlwiXFx1MDBBMVwiLFxuICBcImlmZlwiOlwiXFx1MjFENFwiLFxuICBcIklmclwiOlwiXFx1MjExMVwiLFxuICBcImlmclwiOlwiXFx1RDgzNVxcdUREMjZcIixcbiAgXCJJZ3JhdmVcIjpcIlxcdTAwQ0NcIixcbiAgXCJpZ3JhdmVcIjpcIlxcdTAwRUNcIixcbiAgXCJpaVwiOlwiXFx1MjE0OFwiLFxuICBcImlpaWludFwiOlwiXFx1MkEwQ1wiLFxuICBcImlpaW50XCI6XCJcXHUyMjJEXCIsXG4gIFwiaWluZmluXCI6XCJcXHUyOURDXCIsXG4gIFwiaWlvdGFcIjpcIlxcdTIxMjlcIixcbiAgXCJJSmxpZ1wiOlwiXFx1MDEzMlwiLFxuICBcImlqbGlnXCI6XCJcXHUwMTMzXCIsXG4gIFwiSW1cIjpcIlxcdTIxMTFcIixcbiAgXCJJbWFjclwiOlwiXFx1MDEyQVwiLFxuICBcImltYWNyXCI6XCJcXHUwMTJCXCIsXG4gIFwiaW1hZ2VcIjpcIlxcdTIxMTFcIixcbiAgXCJJbWFnaW5hcnlJXCI6XCJcXHUyMTQ4XCIsXG4gIFwiaW1hZ2xpbmVcIjpcIlxcdTIxMTBcIixcbiAgXCJpbWFncGFydFwiOlwiXFx1MjExMVwiLFxuICBcImltYXRoXCI6XCJcXHUwMTMxXCIsXG4gIFwiaW1vZlwiOlwiXFx1MjJCN1wiLFxuICBcImltcGVkXCI6XCJcXHUwMUI1XCIsXG4gIFwiSW1wbGllc1wiOlwiXFx1MjFEMlwiLFxuICBcImluXCI6XCJcXHUyMjA4XCIsXG4gIFwiaW5jYXJlXCI6XCJcXHUyMTA1XCIsXG4gIFwiaW5maW5cIjpcIlxcdTIyMUVcIixcbiAgXCJpbmZpbnRpZVwiOlwiXFx1MjlERFwiLFxuICBcImlub2RvdFwiOlwiXFx1MDEzMVwiLFxuICBcIkludFwiOlwiXFx1MjIyQ1wiLFxuICBcImludFwiOlwiXFx1MjIyQlwiLFxuICBcImludGNhbFwiOlwiXFx1MjJCQVwiLFxuICBcImludGVnZXJzXCI6XCJcXHUyMTI0XCIsXG4gIFwiSW50ZWdyYWxcIjpcIlxcdTIyMkJcIixcbiAgXCJpbnRlcmNhbFwiOlwiXFx1MjJCQVwiLFxuICBcIkludGVyc2VjdGlvblwiOlwiXFx1MjJDMlwiLFxuICBcImludGxhcmhrXCI6XCJcXHUyQTE3XCIsXG4gIFwiaW50cHJvZFwiOlwiXFx1MkEzQ1wiLFxuICBcIkludmlzaWJsZUNvbW1hXCI6XCJcXHUyMDYzXCIsXG4gIFwiSW52aXNpYmxlVGltZXNcIjpcIlxcdTIwNjJcIixcbiAgXCJJT2N5XCI6XCJcXHUwNDAxXCIsXG4gIFwiaW9jeVwiOlwiXFx1MDQ1MVwiLFxuICBcIklvZ29uXCI6XCJcXHUwMTJFXCIsXG4gIFwiaW9nb25cIjpcIlxcdTAxMkZcIixcbiAgXCJJb3BmXCI6XCJcXHVEODM1XFx1REQ0MFwiLFxuICBcImlvcGZcIjpcIlxcdUQ4MzVcXHVERDVBXCIsXG4gIFwiSW90YVwiOlwiXFx1MDM5OVwiLFxuICBcImlvdGFcIjpcIlxcdTAzQjlcIixcbiAgXCJpcHJvZFwiOlwiXFx1MkEzQ1wiLFxuICBcImlxdWVzdFwiOlwiXFx1MDBCRlwiLFxuICBcIklzY3JcIjpcIlxcdTIxMTBcIixcbiAgXCJpc2NyXCI6XCJcXHVEODM1XFx1RENCRVwiLFxuICBcImlzaW5cIjpcIlxcdTIyMDhcIixcbiAgXCJpc2luZG90XCI6XCJcXHUyMkY1XCIsXG4gIFwiaXNpbkVcIjpcIlxcdTIyRjlcIixcbiAgXCJpc2luc1wiOlwiXFx1MjJGNFwiLFxuICBcImlzaW5zdlwiOlwiXFx1MjJGM1wiLFxuICBcImlzaW52XCI6XCJcXHUyMjA4XCIsXG4gIFwiaXRcIjpcIlxcdTIwNjJcIixcbiAgXCJJdGlsZGVcIjpcIlxcdTAxMjhcIixcbiAgXCJpdGlsZGVcIjpcIlxcdTAxMjlcIixcbiAgXCJJdWtjeVwiOlwiXFx1MDQwNlwiLFxuICBcIml1a2N5XCI6XCJcXHUwNDU2XCIsXG4gIFwiSXVtbFwiOlwiXFx1MDBDRlwiLFxuICBcIml1bWxcIjpcIlxcdTAwRUZcIixcbiAgXCJKY2lyY1wiOlwiXFx1MDEzNFwiLFxuICBcImpjaXJjXCI6XCJcXHUwMTM1XCIsXG4gIFwiSmN5XCI6XCJcXHUwNDE5XCIsXG4gIFwiamN5XCI6XCJcXHUwNDM5XCIsXG4gIFwiSmZyXCI6XCJcXHVEODM1XFx1REQwRFwiLFxuICBcImpmclwiOlwiXFx1RDgzNVxcdUREMjdcIixcbiAgXCJqbWF0aFwiOlwiXFx1MDIzN1wiLFxuICBcIkpvcGZcIjpcIlxcdUQ4MzVcXHVERDQxXCIsXG4gIFwiam9wZlwiOlwiXFx1RDgzNVxcdURENUJcIixcbiAgXCJKc2NyXCI6XCJcXHVEODM1XFx1RENBNVwiLFxuICBcImpzY3JcIjpcIlxcdUQ4MzVcXHVEQ0JGXCIsXG4gIFwiSnNlcmN5XCI6XCJcXHUwNDA4XCIsXG4gIFwianNlcmN5XCI6XCJcXHUwNDU4XCIsXG4gIFwiSnVrY3lcIjpcIlxcdTA0MDRcIixcbiAgXCJqdWtjeVwiOlwiXFx1MDQ1NFwiLFxuICBcIkthcHBhXCI6XCJcXHUwMzlBXCIsXG4gIFwia2FwcGFcIjpcIlxcdTAzQkFcIixcbiAgXCJrYXBwYXZcIjpcIlxcdTAzRjBcIixcbiAgXCJLY2VkaWxcIjpcIlxcdTAxMzZcIixcbiAgXCJrY2VkaWxcIjpcIlxcdTAxMzdcIixcbiAgXCJLY3lcIjpcIlxcdTA0MUFcIixcbiAgXCJrY3lcIjpcIlxcdTA0M0FcIixcbiAgXCJLZnJcIjpcIlxcdUQ4MzVcXHVERDBFXCIsXG4gIFwia2ZyXCI6XCJcXHVEODM1XFx1REQyOFwiLFxuICBcImtncmVlblwiOlwiXFx1MDEzOFwiLFxuICBcIktIY3lcIjpcIlxcdTA0MjVcIixcbiAgXCJraGN5XCI6XCJcXHUwNDQ1XCIsXG4gIFwiS0pjeVwiOlwiXFx1MDQwQ1wiLFxuICBcImtqY3lcIjpcIlxcdTA0NUNcIixcbiAgXCJLb3BmXCI6XCJcXHVEODM1XFx1REQ0MlwiLFxuICBcImtvcGZcIjpcIlxcdUQ4MzVcXHVERDVDXCIsXG4gIFwiS3NjclwiOlwiXFx1RDgzNVxcdURDQTZcIixcbiAgXCJrc2NyXCI6XCJcXHVEODM1XFx1RENDMFwiLFxuICBcImxBYXJyXCI6XCJcXHUyMURBXCIsXG4gIFwiTGFjdXRlXCI6XCJcXHUwMTM5XCIsXG4gIFwibGFjdXRlXCI6XCJcXHUwMTNBXCIsXG4gIFwibGFlbXB0eXZcIjpcIlxcdTI5QjRcIixcbiAgXCJsYWdyYW5cIjpcIlxcdTIxMTJcIixcbiAgXCJMYW1iZGFcIjpcIlxcdTAzOUJcIixcbiAgXCJsYW1iZGFcIjpcIlxcdTAzQkJcIixcbiAgXCJMYW5nXCI6XCJcXHUyN0VBXCIsXG4gIFwibGFuZ1wiOlwiXFx1MjdFOFwiLFxuICBcImxhbmdkXCI6XCJcXHUyOTkxXCIsXG4gIFwibGFuZ2xlXCI6XCJcXHUyN0U4XCIsXG4gIFwibGFwXCI6XCJcXHUyQTg1XCIsXG4gIFwiTGFwbGFjZXRyZlwiOlwiXFx1MjExMlwiLFxuICBcImxhcXVvXCI6XCJcXHUwMEFCXCIsXG4gIFwiTGFyclwiOlwiXFx1MjE5RVwiLFxuICBcImxBcnJcIjpcIlxcdTIxRDBcIixcbiAgXCJsYXJyXCI6XCJcXHUyMTkwXCIsXG4gIFwibGFycmJcIjpcIlxcdTIxRTRcIixcbiAgXCJsYXJyYmZzXCI6XCJcXHUyOTFGXCIsXG4gIFwibGFycmZzXCI6XCJcXHUyOTFEXCIsXG4gIFwibGFycmhrXCI6XCJcXHUyMUE5XCIsXG4gIFwibGFycmxwXCI6XCJcXHUyMUFCXCIsXG4gIFwibGFycnBsXCI6XCJcXHUyOTM5XCIsXG4gIFwibGFycnNpbVwiOlwiXFx1Mjk3M1wiLFxuICBcImxhcnJ0bFwiOlwiXFx1MjFBMlwiLFxuICBcImxhdFwiOlwiXFx1MkFBQlwiLFxuICBcImxBdGFpbFwiOlwiXFx1MjkxQlwiLFxuICBcImxhdGFpbFwiOlwiXFx1MjkxOVwiLFxuICBcImxhdGVcIjpcIlxcdTJBQURcIixcbiAgXCJsYXRlc1wiOlwiXFx1MkFBRFxcdUZFMDBcIixcbiAgXCJsQmFyclwiOlwiXFx1MjkwRVwiLFxuICBcImxiYXJyXCI6XCJcXHUyOTBDXCIsXG4gIFwibGJicmtcIjpcIlxcdTI3NzJcIixcbiAgXCJsYnJhY2VcIjpcIlxcdTAwN0JcIixcbiAgXCJsYnJhY2tcIjpcIlxcdTAwNUJcIixcbiAgXCJsYnJrZVwiOlwiXFx1Mjk4QlwiLFxuICBcImxicmtzbGRcIjpcIlxcdTI5OEZcIixcbiAgXCJsYnJrc2x1XCI6XCJcXHUyOThEXCIsXG4gIFwiTGNhcm9uXCI6XCJcXHUwMTNEXCIsXG4gIFwibGNhcm9uXCI6XCJcXHUwMTNFXCIsXG4gIFwiTGNlZGlsXCI6XCJcXHUwMTNCXCIsXG4gIFwibGNlZGlsXCI6XCJcXHUwMTNDXCIsXG4gIFwibGNlaWxcIjpcIlxcdTIzMDhcIixcbiAgXCJsY3ViXCI6XCJcXHUwMDdCXCIsXG4gIFwiTGN5XCI6XCJcXHUwNDFCXCIsXG4gIFwibGN5XCI6XCJcXHUwNDNCXCIsXG4gIFwibGRjYVwiOlwiXFx1MjkzNlwiLFxuICBcImxkcXVvXCI6XCJcXHUyMDFDXCIsXG4gIFwibGRxdW9yXCI6XCJcXHUyMDFFXCIsXG4gIFwibGRyZGhhclwiOlwiXFx1Mjk2N1wiLFxuICBcImxkcnVzaGFyXCI6XCJcXHUyOTRCXCIsXG4gIFwibGRzaFwiOlwiXFx1MjFCMlwiLFxuICBcImxFXCI6XCJcXHUyMjY2XCIsXG4gIFwibGVcIjpcIlxcdTIyNjRcIixcbiAgXCJMZWZ0QW5nbGVCcmFja2V0XCI6XCJcXHUyN0U4XCIsXG4gIFwiTGVmdEFycm93XCI6XCJcXHUyMTkwXCIsXG4gIFwiTGVmdGFycm93XCI6XCJcXHUyMUQwXCIsXG4gIFwibGVmdGFycm93XCI6XCJcXHUyMTkwXCIsXG4gIFwiTGVmdEFycm93QmFyXCI6XCJcXHUyMUU0XCIsXG4gIFwiTGVmdEFycm93UmlnaHRBcnJvd1wiOlwiXFx1MjFDNlwiLFxuICBcImxlZnRhcnJvd3RhaWxcIjpcIlxcdTIxQTJcIixcbiAgXCJMZWZ0Q2VpbGluZ1wiOlwiXFx1MjMwOFwiLFxuICBcIkxlZnREb3VibGVCcmFja2V0XCI6XCJcXHUyN0U2XCIsXG4gIFwiTGVmdERvd25UZWVWZWN0b3JcIjpcIlxcdTI5NjFcIixcbiAgXCJMZWZ0RG93blZlY3RvclwiOlwiXFx1MjFDM1wiLFxuICBcIkxlZnREb3duVmVjdG9yQmFyXCI6XCJcXHUyOTU5XCIsXG4gIFwiTGVmdEZsb29yXCI6XCJcXHUyMzBBXCIsXG4gIFwibGVmdGhhcnBvb25kb3duXCI6XCJcXHUyMUJEXCIsXG4gIFwibGVmdGhhcnBvb251cFwiOlwiXFx1MjFCQ1wiLFxuICBcImxlZnRsZWZ0YXJyb3dzXCI6XCJcXHUyMUM3XCIsXG4gIFwiTGVmdFJpZ2h0QXJyb3dcIjpcIlxcdTIxOTRcIixcbiAgXCJMZWZ0cmlnaHRhcnJvd1wiOlwiXFx1MjFENFwiLFxuICBcImxlZnRyaWdodGFycm93XCI6XCJcXHUyMTk0XCIsXG4gIFwibGVmdHJpZ2h0YXJyb3dzXCI6XCJcXHUyMUM2XCIsXG4gIFwibGVmdHJpZ2h0aGFycG9vbnNcIjpcIlxcdTIxQ0JcIixcbiAgXCJsZWZ0cmlnaHRzcXVpZ2Fycm93XCI6XCJcXHUyMUFEXCIsXG4gIFwiTGVmdFJpZ2h0VmVjdG9yXCI6XCJcXHUyOTRFXCIsXG4gIFwiTGVmdFRlZVwiOlwiXFx1MjJBM1wiLFxuICBcIkxlZnRUZWVBcnJvd1wiOlwiXFx1MjFBNFwiLFxuICBcIkxlZnRUZWVWZWN0b3JcIjpcIlxcdTI5NUFcIixcbiAgXCJsZWZ0dGhyZWV0aW1lc1wiOlwiXFx1MjJDQlwiLFxuICBcIkxlZnRUcmlhbmdsZVwiOlwiXFx1MjJCMlwiLFxuICBcIkxlZnRUcmlhbmdsZUJhclwiOlwiXFx1MjlDRlwiLFxuICBcIkxlZnRUcmlhbmdsZUVxdWFsXCI6XCJcXHUyMkI0XCIsXG4gIFwiTGVmdFVwRG93blZlY3RvclwiOlwiXFx1Mjk1MVwiLFxuICBcIkxlZnRVcFRlZVZlY3RvclwiOlwiXFx1Mjk2MFwiLFxuICBcIkxlZnRVcFZlY3RvclwiOlwiXFx1MjFCRlwiLFxuICBcIkxlZnRVcFZlY3RvckJhclwiOlwiXFx1Mjk1OFwiLFxuICBcIkxlZnRWZWN0b3JcIjpcIlxcdTIxQkNcIixcbiAgXCJMZWZ0VmVjdG9yQmFyXCI6XCJcXHUyOTUyXCIsXG4gIFwibEVnXCI6XCJcXHUyQThCXCIsXG4gIFwibGVnXCI6XCJcXHUyMkRBXCIsXG4gIFwibGVxXCI6XCJcXHUyMjY0XCIsXG4gIFwibGVxcVwiOlwiXFx1MjI2NlwiLFxuICBcImxlcXNsYW50XCI6XCJcXHUyQTdEXCIsXG4gIFwibGVzXCI6XCJcXHUyQTdEXCIsXG4gIFwibGVzY2NcIjpcIlxcdTJBQThcIixcbiAgXCJsZXNkb3RcIjpcIlxcdTJBN0ZcIixcbiAgXCJsZXNkb3RvXCI6XCJcXHUyQTgxXCIsXG4gIFwibGVzZG90b3JcIjpcIlxcdTJBODNcIixcbiAgXCJsZXNnXCI6XCJcXHUyMkRBXFx1RkUwMFwiLFxuICBcImxlc2dlc1wiOlwiXFx1MkE5M1wiLFxuICBcImxlc3NhcHByb3hcIjpcIlxcdTJBODVcIixcbiAgXCJsZXNzZG90XCI6XCJcXHUyMkQ2XCIsXG4gIFwibGVzc2VxZ3RyXCI6XCJcXHUyMkRBXCIsXG4gIFwibGVzc2VxcWd0clwiOlwiXFx1MkE4QlwiLFxuICBcIkxlc3NFcXVhbEdyZWF0ZXJcIjpcIlxcdTIyREFcIixcbiAgXCJMZXNzRnVsbEVxdWFsXCI6XCJcXHUyMjY2XCIsXG4gIFwiTGVzc0dyZWF0ZXJcIjpcIlxcdTIyNzZcIixcbiAgXCJsZXNzZ3RyXCI6XCJcXHUyMjc2XCIsXG4gIFwiTGVzc0xlc3NcIjpcIlxcdTJBQTFcIixcbiAgXCJsZXNzc2ltXCI6XCJcXHUyMjcyXCIsXG4gIFwiTGVzc1NsYW50RXF1YWxcIjpcIlxcdTJBN0RcIixcbiAgXCJMZXNzVGlsZGVcIjpcIlxcdTIyNzJcIixcbiAgXCJsZmlzaHRcIjpcIlxcdTI5N0NcIixcbiAgXCJsZmxvb3JcIjpcIlxcdTIzMEFcIixcbiAgXCJMZnJcIjpcIlxcdUQ4MzVcXHVERDBGXCIsXG4gIFwibGZyXCI6XCJcXHVEODM1XFx1REQyOVwiLFxuICBcImxnXCI6XCJcXHUyMjc2XCIsXG4gIFwibGdFXCI6XCJcXHUyQTkxXCIsXG4gIFwibEhhclwiOlwiXFx1Mjk2MlwiLFxuICBcImxoYXJkXCI6XCJcXHUyMUJEXCIsXG4gIFwibGhhcnVcIjpcIlxcdTIxQkNcIixcbiAgXCJsaGFydWxcIjpcIlxcdTI5NkFcIixcbiAgXCJsaGJsa1wiOlwiXFx1MjU4NFwiLFxuICBcIkxKY3lcIjpcIlxcdTA0MDlcIixcbiAgXCJsamN5XCI6XCJcXHUwNDU5XCIsXG4gIFwiTGxcIjpcIlxcdTIyRDhcIixcbiAgXCJsbFwiOlwiXFx1MjI2QVwiLFxuICBcImxsYXJyXCI6XCJcXHUyMUM3XCIsXG4gIFwibGxjb3JuZXJcIjpcIlxcdTIzMUVcIixcbiAgXCJMbGVmdGFycm93XCI6XCJcXHUyMURBXCIsXG4gIFwibGxoYXJkXCI6XCJcXHUyOTZCXCIsXG4gIFwibGx0cmlcIjpcIlxcdTI1RkFcIixcbiAgXCJMbWlkb3RcIjpcIlxcdTAxM0ZcIixcbiAgXCJsbWlkb3RcIjpcIlxcdTAxNDBcIixcbiAgXCJsbW91c3RcIjpcIlxcdTIzQjBcIixcbiAgXCJsbW91c3RhY2hlXCI6XCJcXHUyM0IwXCIsXG4gIFwibG5hcFwiOlwiXFx1MkE4OVwiLFxuICBcImxuYXBwcm94XCI6XCJcXHUyQTg5XCIsXG4gIFwibG5FXCI6XCJcXHUyMjY4XCIsXG4gIFwibG5lXCI6XCJcXHUyQTg3XCIsXG4gIFwibG5lcVwiOlwiXFx1MkE4N1wiLFxuICBcImxuZXFxXCI6XCJcXHUyMjY4XCIsXG4gIFwibG5zaW1cIjpcIlxcdTIyRTZcIixcbiAgXCJsb2FuZ1wiOlwiXFx1MjdFQ1wiLFxuICBcImxvYXJyXCI6XCJcXHUyMUZEXCIsXG4gIFwibG9icmtcIjpcIlxcdTI3RTZcIixcbiAgXCJMb25nTGVmdEFycm93XCI6XCJcXHUyN0Y1XCIsXG4gIFwiTG9uZ2xlZnRhcnJvd1wiOlwiXFx1MjdGOFwiLFxuICBcImxvbmdsZWZ0YXJyb3dcIjpcIlxcdTI3RjVcIixcbiAgXCJMb25nTGVmdFJpZ2h0QXJyb3dcIjpcIlxcdTI3RjdcIixcbiAgXCJMb25nbGVmdHJpZ2h0YXJyb3dcIjpcIlxcdTI3RkFcIixcbiAgXCJsb25nbGVmdHJpZ2h0YXJyb3dcIjpcIlxcdTI3RjdcIixcbiAgXCJsb25nbWFwc3RvXCI6XCJcXHUyN0ZDXCIsXG4gIFwiTG9uZ1JpZ2h0QXJyb3dcIjpcIlxcdTI3RjZcIixcbiAgXCJMb25ncmlnaHRhcnJvd1wiOlwiXFx1MjdGOVwiLFxuICBcImxvbmdyaWdodGFycm93XCI6XCJcXHUyN0Y2XCIsXG4gIFwibG9vcGFycm93bGVmdFwiOlwiXFx1MjFBQlwiLFxuICBcImxvb3BhcnJvd3JpZ2h0XCI6XCJcXHUyMUFDXCIsXG4gIFwibG9wYXJcIjpcIlxcdTI5ODVcIixcbiAgXCJMb3BmXCI6XCJcXHVEODM1XFx1REQ0M1wiLFxuICBcImxvcGZcIjpcIlxcdUQ4MzVcXHVERDVEXCIsXG4gIFwibG9wbHVzXCI6XCJcXHUyQTJEXCIsXG4gIFwibG90aW1lc1wiOlwiXFx1MkEzNFwiLFxuICBcImxvd2FzdFwiOlwiXFx1MjIxN1wiLFxuICBcImxvd2JhclwiOlwiXFx1MDA1RlwiLFxuICBcIkxvd2VyTGVmdEFycm93XCI6XCJcXHUyMTk5XCIsXG4gIFwiTG93ZXJSaWdodEFycm93XCI6XCJcXHUyMTk4XCIsXG4gIFwibG96XCI6XCJcXHUyNUNBXCIsXG4gIFwibG96ZW5nZVwiOlwiXFx1MjVDQVwiLFxuICBcImxvemZcIjpcIlxcdTI5RUJcIixcbiAgXCJscGFyXCI6XCJcXHUwMDI4XCIsXG4gIFwibHBhcmx0XCI6XCJcXHUyOTkzXCIsXG4gIFwibHJhcnJcIjpcIlxcdTIxQzZcIixcbiAgXCJscmNvcm5lclwiOlwiXFx1MjMxRlwiLFxuICBcImxyaGFyXCI6XCJcXHUyMUNCXCIsXG4gIFwibHJoYXJkXCI6XCJcXHUyOTZEXCIsXG4gIFwibHJtXCI6XCJcXHUyMDBFXCIsXG4gIFwibHJ0cmlcIjpcIlxcdTIyQkZcIixcbiAgXCJsc2FxdW9cIjpcIlxcdTIwMzlcIixcbiAgXCJMc2NyXCI6XCJcXHUyMTEyXCIsXG4gIFwibHNjclwiOlwiXFx1RDgzNVxcdURDQzFcIixcbiAgXCJMc2hcIjpcIlxcdTIxQjBcIixcbiAgXCJsc2hcIjpcIlxcdTIxQjBcIixcbiAgXCJsc2ltXCI6XCJcXHUyMjcyXCIsXG4gIFwibHNpbWVcIjpcIlxcdTJBOERcIixcbiAgXCJsc2ltZ1wiOlwiXFx1MkE4RlwiLFxuICBcImxzcWJcIjpcIlxcdTAwNUJcIixcbiAgXCJsc3F1b1wiOlwiXFx1MjAxOFwiLFxuICBcImxzcXVvclwiOlwiXFx1MjAxQVwiLFxuICBcIkxzdHJva1wiOlwiXFx1MDE0MVwiLFxuICBcImxzdHJva1wiOlwiXFx1MDE0MlwiLFxuICBcIkxUXCI6XCJcXHUwMDNDXCIsXG4gIFwiTHRcIjpcIlxcdTIyNkFcIixcbiAgXCJsdFwiOlwiXFx1MDAzQ1wiLFxuICBcImx0Y2NcIjpcIlxcdTJBQTZcIixcbiAgXCJsdGNpclwiOlwiXFx1MkE3OVwiLFxuICBcImx0ZG90XCI6XCJcXHUyMkQ2XCIsXG4gIFwibHRocmVlXCI6XCJcXHUyMkNCXCIsXG4gIFwibHRpbWVzXCI6XCJcXHUyMkM5XCIsXG4gIFwibHRsYXJyXCI6XCJcXHUyOTc2XCIsXG4gIFwibHRxdWVzdFwiOlwiXFx1MkE3QlwiLFxuICBcImx0cmlcIjpcIlxcdTI1QzNcIixcbiAgXCJsdHJpZVwiOlwiXFx1MjJCNFwiLFxuICBcImx0cmlmXCI6XCJcXHUyNUMyXCIsXG4gIFwibHRyUGFyXCI6XCJcXHUyOTk2XCIsXG4gIFwibHVyZHNoYXJcIjpcIlxcdTI5NEFcIixcbiAgXCJsdXJ1aGFyXCI6XCJcXHUyOTY2XCIsXG4gIFwibHZlcnRuZXFxXCI6XCJcXHUyMjY4XFx1RkUwMFwiLFxuICBcImx2bkVcIjpcIlxcdTIyNjhcXHVGRTAwXCIsXG4gIFwibWFjclwiOlwiXFx1MDBBRlwiLFxuICBcIm1hbGVcIjpcIlxcdTI2NDJcIixcbiAgXCJtYWx0XCI6XCJcXHUyNzIwXCIsXG4gIFwibWFsdGVzZVwiOlwiXFx1MjcyMFwiLFxuICBcIk1hcFwiOlwiXFx1MjkwNVwiLFxuICBcIm1hcFwiOlwiXFx1MjFBNlwiLFxuICBcIm1hcHN0b1wiOlwiXFx1MjFBNlwiLFxuICBcIm1hcHN0b2Rvd25cIjpcIlxcdTIxQTdcIixcbiAgXCJtYXBzdG9sZWZ0XCI6XCJcXHUyMUE0XCIsXG4gIFwibWFwc3RvdXBcIjpcIlxcdTIxQTVcIixcbiAgXCJtYXJrZXJcIjpcIlxcdTI1QUVcIixcbiAgXCJtY29tbWFcIjpcIlxcdTJBMjlcIixcbiAgXCJNY3lcIjpcIlxcdTA0MUNcIixcbiAgXCJtY3lcIjpcIlxcdTA0M0NcIixcbiAgXCJtZGFzaFwiOlwiXFx1MjAxNFwiLFxuICBcIm1ERG90XCI6XCJcXHUyMjNBXCIsXG4gIFwibWVhc3VyZWRhbmdsZVwiOlwiXFx1MjIyMVwiLFxuICBcIk1lZGl1bVNwYWNlXCI6XCJcXHUyMDVGXCIsXG4gIFwiTWVsbGludHJmXCI6XCJcXHUyMTMzXCIsXG4gIFwiTWZyXCI6XCJcXHVEODM1XFx1REQxMFwiLFxuICBcIm1mclwiOlwiXFx1RDgzNVxcdUREMkFcIixcbiAgXCJtaG9cIjpcIlxcdTIxMjdcIixcbiAgXCJtaWNyb1wiOlwiXFx1MDBCNVwiLFxuICBcIm1pZFwiOlwiXFx1MjIyM1wiLFxuICBcIm1pZGFzdFwiOlwiXFx1MDAyQVwiLFxuICBcIm1pZGNpclwiOlwiXFx1MkFGMFwiLFxuICBcIm1pZGRvdFwiOlwiXFx1MDBCN1wiLFxuICBcIm1pbnVzXCI6XCJcXHUyMjEyXCIsXG4gIFwibWludXNiXCI6XCJcXHUyMjlGXCIsXG4gIFwibWludXNkXCI6XCJcXHUyMjM4XCIsXG4gIFwibWludXNkdVwiOlwiXFx1MkEyQVwiLFxuICBcIk1pbnVzUGx1c1wiOlwiXFx1MjIxM1wiLFxuICBcIm1sY3BcIjpcIlxcdTJBREJcIixcbiAgXCJtbGRyXCI6XCJcXHUyMDI2XCIsXG4gIFwibW5wbHVzXCI6XCJcXHUyMjEzXCIsXG4gIFwibW9kZWxzXCI6XCJcXHUyMkE3XCIsXG4gIFwiTW9wZlwiOlwiXFx1RDgzNVxcdURENDRcIixcbiAgXCJtb3BmXCI6XCJcXHVEODM1XFx1REQ1RVwiLFxuICBcIm1wXCI6XCJcXHUyMjEzXCIsXG4gIFwiTXNjclwiOlwiXFx1MjEzM1wiLFxuICBcIm1zY3JcIjpcIlxcdUQ4MzVcXHVEQ0MyXCIsXG4gIFwibXN0cG9zXCI6XCJcXHUyMjNFXCIsXG4gIFwiTXVcIjpcIlxcdTAzOUNcIixcbiAgXCJtdVwiOlwiXFx1MDNCQ1wiLFxuICBcIm11bHRpbWFwXCI6XCJcXHUyMkI4XCIsXG4gIFwibXVtYXBcIjpcIlxcdTIyQjhcIixcbiAgXCJuYWJsYVwiOlwiXFx1MjIwN1wiLFxuICBcIk5hY3V0ZVwiOlwiXFx1MDE0M1wiLFxuICBcIm5hY3V0ZVwiOlwiXFx1MDE0NFwiLFxuICBcIm5hbmdcIjpcIlxcdTIyMjBcXHUyMEQyXCIsXG4gIFwibmFwXCI6XCJcXHUyMjQ5XCIsXG4gIFwibmFwRVwiOlwiXFx1MkE3MFxcdTAzMzhcIixcbiAgXCJuYXBpZFwiOlwiXFx1MjI0QlxcdTAzMzhcIixcbiAgXCJuYXBvc1wiOlwiXFx1MDE0OVwiLFxuICBcIm5hcHByb3hcIjpcIlxcdTIyNDlcIixcbiAgXCJuYXR1clwiOlwiXFx1MjY2RVwiLFxuICBcIm5hdHVyYWxcIjpcIlxcdTI2NkVcIixcbiAgXCJuYXR1cmFsc1wiOlwiXFx1MjExNVwiLFxuICBcIm5ic3BcIjpcIlxcdTAwQTBcIixcbiAgXCJuYnVtcFwiOlwiXFx1MjI0RVxcdTAzMzhcIixcbiAgXCJuYnVtcGVcIjpcIlxcdTIyNEZcXHUwMzM4XCIsXG4gIFwibmNhcFwiOlwiXFx1MkE0M1wiLFxuICBcIk5jYXJvblwiOlwiXFx1MDE0N1wiLFxuICBcIm5jYXJvblwiOlwiXFx1MDE0OFwiLFxuICBcIk5jZWRpbFwiOlwiXFx1MDE0NVwiLFxuICBcIm5jZWRpbFwiOlwiXFx1MDE0NlwiLFxuICBcIm5jb25nXCI6XCJcXHUyMjQ3XCIsXG4gIFwibmNvbmdkb3RcIjpcIlxcdTJBNkRcXHUwMzM4XCIsXG4gIFwibmN1cFwiOlwiXFx1MkE0MlwiLFxuICBcIk5jeVwiOlwiXFx1MDQxRFwiLFxuICBcIm5jeVwiOlwiXFx1MDQzRFwiLFxuICBcIm5kYXNoXCI6XCJcXHUyMDEzXCIsXG4gIFwibmVcIjpcIlxcdTIyNjBcIixcbiAgXCJuZWFyaGtcIjpcIlxcdTI5MjRcIixcbiAgXCJuZUFyclwiOlwiXFx1MjFEN1wiLFxuICBcIm5lYXJyXCI6XCJcXHUyMTk3XCIsXG4gIFwibmVhcnJvd1wiOlwiXFx1MjE5N1wiLFxuICBcIm5lZG90XCI6XCJcXHUyMjUwXFx1MDMzOFwiLFxuICBcIk5lZ2F0aXZlTWVkaXVtU3BhY2VcIjpcIlxcdTIwMEJcIixcbiAgXCJOZWdhdGl2ZVRoaWNrU3BhY2VcIjpcIlxcdTIwMEJcIixcbiAgXCJOZWdhdGl2ZVRoaW5TcGFjZVwiOlwiXFx1MjAwQlwiLFxuICBcIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZVwiOlwiXFx1MjAwQlwiLFxuICBcIm5lcXVpdlwiOlwiXFx1MjI2MlwiLFxuICBcIm5lc2VhclwiOlwiXFx1MjkyOFwiLFxuICBcIm5lc2ltXCI6XCJcXHUyMjQyXFx1MDMzOFwiLFxuICBcIk5lc3RlZEdyZWF0ZXJHcmVhdGVyXCI6XCJcXHUyMjZCXCIsXG4gIFwiTmVzdGVkTGVzc0xlc3NcIjpcIlxcdTIyNkFcIixcbiAgXCJOZXdMaW5lXCI6XCJcXHUwMDBBXCIsXG4gIFwibmV4aXN0XCI6XCJcXHUyMjA0XCIsXG4gIFwibmV4aXN0c1wiOlwiXFx1MjIwNFwiLFxuICBcIk5mclwiOlwiXFx1RDgzNVxcdUREMTFcIixcbiAgXCJuZnJcIjpcIlxcdUQ4MzVcXHVERDJCXCIsXG4gIFwibmdFXCI6XCJcXHUyMjY3XFx1MDMzOFwiLFxuICBcIm5nZVwiOlwiXFx1MjI3MVwiLFxuICBcIm5nZXFcIjpcIlxcdTIyNzFcIixcbiAgXCJuZ2VxcVwiOlwiXFx1MjI2N1xcdTAzMzhcIixcbiAgXCJuZ2Vxc2xhbnRcIjpcIlxcdTJBN0VcXHUwMzM4XCIsXG4gIFwibmdlc1wiOlwiXFx1MkE3RVxcdTAzMzhcIixcbiAgXCJuR2dcIjpcIlxcdTIyRDlcXHUwMzM4XCIsXG4gIFwibmdzaW1cIjpcIlxcdTIyNzVcIixcbiAgXCJuR3RcIjpcIlxcdTIyNkJcXHUyMEQyXCIsXG4gIFwibmd0XCI6XCJcXHUyMjZGXCIsXG4gIFwibmd0clwiOlwiXFx1MjI2RlwiLFxuICBcIm5HdHZcIjpcIlxcdTIyNkJcXHUwMzM4XCIsXG4gIFwibmhBcnJcIjpcIlxcdTIxQ0VcIixcbiAgXCJuaGFyclwiOlwiXFx1MjFBRVwiLFxuICBcIm5ocGFyXCI6XCJcXHUyQUYyXCIsXG4gIFwibmlcIjpcIlxcdTIyMEJcIixcbiAgXCJuaXNcIjpcIlxcdTIyRkNcIixcbiAgXCJuaXNkXCI6XCJcXHUyMkZBXCIsXG4gIFwibml2XCI6XCJcXHUyMjBCXCIsXG4gIFwiTkpjeVwiOlwiXFx1MDQwQVwiLFxuICBcIm5qY3lcIjpcIlxcdTA0NUFcIixcbiAgXCJubEFyclwiOlwiXFx1MjFDRFwiLFxuICBcIm5sYXJyXCI6XCJcXHUyMTlBXCIsXG4gIFwibmxkclwiOlwiXFx1MjAyNVwiLFxuICBcIm5sRVwiOlwiXFx1MjI2NlxcdTAzMzhcIixcbiAgXCJubGVcIjpcIlxcdTIyNzBcIixcbiAgXCJuTGVmdGFycm93XCI6XCJcXHUyMUNEXCIsXG4gIFwibmxlZnRhcnJvd1wiOlwiXFx1MjE5QVwiLFxuICBcIm5MZWZ0cmlnaHRhcnJvd1wiOlwiXFx1MjFDRVwiLFxuICBcIm5sZWZ0cmlnaHRhcnJvd1wiOlwiXFx1MjFBRVwiLFxuICBcIm5sZXFcIjpcIlxcdTIyNzBcIixcbiAgXCJubGVxcVwiOlwiXFx1MjI2NlxcdTAzMzhcIixcbiAgXCJubGVxc2xhbnRcIjpcIlxcdTJBN0RcXHUwMzM4XCIsXG4gIFwibmxlc1wiOlwiXFx1MkE3RFxcdTAzMzhcIixcbiAgXCJubGVzc1wiOlwiXFx1MjI2RVwiLFxuICBcIm5MbFwiOlwiXFx1MjJEOFxcdTAzMzhcIixcbiAgXCJubHNpbVwiOlwiXFx1MjI3NFwiLFxuICBcIm5MdFwiOlwiXFx1MjI2QVxcdTIwRDJcIixcbiAgXCJubHRcIjpcIlxcdTIyNkVcIixcbiAgXCJubHRyaVwiOlwiXFx1MjJFQVwiLFxuICBcIm5sdHJpZVwiOlwiXFx1MjJFQ1wiLFxuICBcIm5MdHZcIjpcIlxcdTIyNkFcXHUwMzM4XCIsXG4gIFwibm1pZFwiOlwiXFx1MjIyNFwiLFxuICBcIk5vQnJlYWtcIjpcIlxcdTIwNjBcIixcbiAgXCJOb25CcmVha2luZ1NwYWNlXCI6XCJcXHUwMEEwXCIsXG4gIFwiTm9wZlwiOlwiXFx1MjExNVwiLFxuICBcIm5vcGZcIjpcIlxcdUQ4MzVcXHVERDVGXCIsXG4gIFwiTm90XCI6XCJcXHUyQUVDXCIsXG4gIFwibm90XCI6XCJcXHUwMEFDXCIsXG4gIFwiTm90Q29uZ3J1ZW50XCI6XCJcXHUyMjYyXCIsXG4gIFwiTm90Q3VwQ2FwXCI6XCJcXHUyMjZEXCIsXG4gIFwiTm90RG91YmxlVmVydGljYWxCYXJcIjpcIlxcdTIyMjZcIixcbiAgXCJOb3RFbGVtZW50XCI6XCJcXHUyMjA5XCIsXG4gIFwiTm90RXF1YWxcIjpcIlxcdTIyNjBcIixcbiAgXCJOb3RFcXVhbFRpbGRlXCI6XCJcXHUyMjQyXFx1MDMzOFwiLFxuICBcIk5vdEV4aXN0c1wiOlwiXFx1MjIwNFwiLFxuICBcIk5vdEdyZWF0ZXJcIjpcIlxcdTIyNkZcIixcbiAgXCJOb3RHcmVhdGVyRXF1YWxcIjpcIlxcdTIyNzFcIixcbiAgXCJOb3RHcmVhdGVyRnVsbEVxdWFsXCI6XCJcXHUyMjY3XFx1MDMzOFwiLFxuICBcIk5vdEdyZWF0ZXJHcmVhdGVyXCI6XCJcXHUyMjZCXFx1MDMzOFwiLFxuICBcIk5vdEdyZWF0ZXJMZXNzXCI6XCJcXHUyMjc5XCIsXG4gIFwiTm90R3JlYXRlclNsYW50RXF1YWxcIjpcIlxcdTJBN0VcXHUwMzM4XCIsXG4gIFwiTm90R3JlYXRlclRpbGRlXCI6XCJcXHUyMjc1XCIsXG4gIFwiTm90SHVtcERvd25IdW1wXCI6XCJcXHUyMjRFXFx1MDMzOFwiLFxuICBcIk5vdEh1bXBFcXVhbFwiOlwiXFx1MjI0RlxcdTAzMzhcIixcbiAgXCJub3RpblwiOlwiXFx1MjIwOVwiLFxuICBcIm5vdGluZG90XCI6XCJcXHUyMkY1XFx1MDMzOFwiLFxuICBcIm5vdGluRVwiOlwiXFx1MjJGOVxcdTAzMzhcIixcbiAgXCJub3RpbnZhXCI6XCJcXHUyMjA5XCIsXG4gIFwibm90aW52YlwiOlwiXFx1MjJGN1wiLFxuICBcIm5vdGludmNcIjpcIlxcdTIyRjZcIixcbiAgXCJOb3RMZWZ0VHJpYW5nbGVcIjpcIlxcdTIyRUFcIixcbiAgXCJOb3RMZWZ0VHJpYW5nbGVCYXJcIjpcIlxcdTI5Q0ZcXHUwMzM4XCIsXG4gIFwiTm90TGVmdFRyaWFuZ2xlRXF1YWxcIjpcIlxcdTIyRUNcIixcbiAgXCJOb3RMZXNzXCI6XCJcXHUyMjZFXCIsXG4gIFwiTm90TGVzc0VxdWFsXCI6XCJcXHUyMjcwXCIsXG4gIFwiTm90TGVzc0dyZWF0ZXJcIjpcIlxcdTIyNzhcIixcbiAgXCJOb3RMZXNzTGVzc1wiOlwiXFx1MjI2QVxcdTAzMzhcIixcbiAgXCJOb3RMZXNzU2xhbnRFcXVhbFwiOlwiXFx1MkE3RFxcdTAzMzhcIixcbiAgXCJOb3RMZXNzVGlsZGVcIjpcIlxcdTIyNzRcIixcbiAgXCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlclwiOlwiXFx1MkFBMlxcdTAzMzhcIixcbiAgXCJOb3ROZXN0ZWRMZXNzTGVzc1wiOlwiXFx1MkFBMVxcdTAzMzhcIixcbiAgXCJub3RuaVwiOlwiXFx1MjIwQ1wiLFxuICBcIm5vdG5pdmFcIjpcIlxcdTIyMENcIixcbiAgXCJub3RuaXZiXCI6XCJcXHUyMkZFXCIsXG4gIFwibm90bml2Y1wiOlwiXFx1MjJGRFwiLFxuICBcIk5vdFByZWNlZGVzXCI6XCJcXHUyMjgwXCIsXG4gIFwiTm90UHJlY2VkZXNFcXVhbFwiOlwiXFx1MkFBRlxcdTAzMzhcIixcbiAgXCJOb3RQcmVjZWRlc1NsYW50RXF1YWxcIjpcIlxcdTIyRTBcIixcbiAgXCJOb3RSZXZlcnNlRWxlbWVudFwiOlwiXFx1MjIwQ1wiLFxuICBcIk5vdFJpZ2h0VHJpYW5nbGVcIjpcIlxcdTIyRUJcIixcbiAgXCJOb3RSaWdodFRyaWFuZ2xlQmFyXCI6XCJcXHUyOUQwXFx1MDMzOFwiLFxuICBcIk5vdFJpZ2h0VHJpYW5nbGVFcXVhbFwiOlwiXFx1MjJFRFwiLFxuICBcIk5vdFNxdWFyZVN1YnNldFwiOlwiXFx1MjI4RlxcdTAzMzhcIixcbiAgXCJOb3RTcXVhcmVTdWJzZXRFcXVhbFwiOlwiXFx1MjJFMlwiLFxuICBcIk5vdFNxdWFyZVN1cGVyc2V0XCI6XCJcXHUyMjkwXFx1MDMzOFwiLFxuICBcIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWxcIjpcIlxcdTIyRTNcIixcbiAgXCJOb3RTdWJzZXRcIjpcIlxcdTIyODJcXHUyMEQyXCIsXG4gIFwiTm90U3Vic2V0RXF1YWxcIjpcIlxcdTIyODhcIixcbiAgXCJOb3RTdWNjZWVkc1wiOlwiXFx1MjI4MVwiLFxuICBcIk5vdFN1Y2NlZWRzRXF1YWxcIjpcIlxcdTJBQjBcXHUwMzM4XCIsXG4gIFwiTm90U3VjY2VlZHNTbGFudEVxdWFsXCI6XCJcXHUyMkUxXCIsXG4gIFwiTm90U3VjY2VlZHNUaWxkZVwiOlwiXFx1MjI3RlxcdTAzMzhcIixcbiAgXCJOb3RTdXBlcnNldFwiOlwiXFx1MjI4M1xcdTIwRDJcIixcbiAgXCJOb3RTdXBlcnNldEVxdWFsXCI6XCJcXHUyMjg5XCIsXG4gIFwiTm90VGlsZGVcIjpcIlxcdTIyNDFcIixcbiAgXCJOb3RUaWxkZUVxdWFsXCI6XCJcXHUyMjQ0XCIsXG4gIFwiTm90VGlsZGVGdWxsRXF1YWxcIjpcIlxcdTIyNDdcIixcbiAgXCJOb3RUaWxkZVRpbGRlXCI6XCJcXHUyMjQ5XCIsXG4gIFwiTm90VmVydGljYWxCYXJcIjpcIlxcdTIyMjRcIixcbiAgXCJucGFyXCI6XCJcXHUyMjI2XCIsXG4gIFwibnBhcmFsbGVsXCI6XCJcXHUyMjI2XCIsXG4gIFwibnBhcnNsXCI6XCJcXHUyQUZEXFx1MjBFNVwiLFxuICBcIm5wYXJ0XCI6XCJcXHUyMjAyXFx1MDMzOFwiLFxuICBcIm5wb2xpbnRcIjpcIlxcdTJBMTRcIixcbiAgXCJucHJcIjpcIlxcdTIyODBcIixcbiAgXCJucHJjdWVcIjpcIlxcdTIyRTBcIixcbiAgXCJucHJlXCI6XCJcXHUyQUFGXFx1MDMzOFwiLFxuICBcIm5wcmVjXCI6XCJcXHUyMjgwXCIsXG4gIFwibnByZWNlcVwiOlwiXFx1MkFBRlxcdTAzMzhcIixcbiAgXCJuckFyclwiOlwiXFx1MjFDRlwiLFxuICBcIm5yYXJyXCI6XCJcXHUyMTlCXCIsXG4gIFwibnJhcnJjXCI6XCJcXHUyOTMzXFx1MDMzOFwiLFxuICBcIm5yYXJyd1wiOlwiXFx1MjE5RFxcdTAzMzhcIixcbiAgXCJuUmlnaHRhcnJvd1wiOlwiXFx1MjFDRlwiLFxuICBcIm5yaWdodGFycm93XCI6XCJcXHUyMTlCXCIsXG4gIFwibnJ0cmlcIjpcIlxcdTIyRUJcIixcbiAgXCJucnRyaWVcIjpcIlxcdTIyRURcIixcbiAgXCJuc2NcIjpcIlxcdTIyODFcIixcbiAgXCJuc2NjdWVcIjpcIlxcdTIyRTFcIixcbiAgXCJuc2NlXCI6XCJcXHUyQUIwXFx1MDMzOFwiLFxuICBcIk5zY3JcIjpcIlxcdUQ4MzVcXHVEQ0E5XCIsXG4gIFwibnNjclwiOlwiXFx1RDgzNVxcdURDQzNcIixcbiAgXCJuc2hvcnRtaWRcIjpcIlxcdTIyMjRcIixcbiAgXCJuc2hvcnRwYXJhbGxlbFwiOlwiXFx1MjIyNlwiLFxuICBcIm5zaW1cIjpcIlxcdTIyNDFcIixcbiAgXCJuc2ltZVwiOlwiXFx1MjI0NFwiLFxuICBcIm5zaW1lcVwiOlwiXFx1MjI0NFwiLFxuICBcIm5zbWlkXCI6XCJcXHUyMjI0XCIsXG4gIFwibnNwYXJcIjpcIlxcdTIyMjZcIixcbiAgXCJuc3FzdWJlXCI6XCJcXHUyMkUyXCIsXG4gIFwibnNxc3VwZVwiOlwiXFx1MjJFM1wiLFxuICBcIm5zdWJcIjpcIlxcdTIyODRcIixcbiAgXCJuc3ViRVwiOlwiXFx1MkFDNVxcdTAzMzhcIixcbiAgXCJuc3ViZVwiOlwiXFx1MjI4OFwiLFxuICBcIm5zdWJzZXRcIjpcIlxcdTIyODJcXHUyMEQyXCIsXG4gIFwibnN1YnNldGVxXCI6XCJcXHUyMjg4XCIsXG4gIFwibnN1YnNldGVxcVwiOlwiXFx1MkFDNVxcdTAzMzhcIixcbiAgXCJuc3VjY1wiOlwiXFx1MjI4MVwiLFxuICBcIm5zdWNjZXFcIjpcIlxcdTJBQjBcXHUwMzM4XCIsXG4gIFwibnN1cFwiOlwiXFx1MjI4NVwiLFxuICBcIm5zdXBFXCI6XCJcXHUyQUM2XFx1MDMzOFwiLFxuICBcIm5zdXBlXCI6XCJcXHUyMjg5XCIsXG4gIFwibnN1cHNldFwiOlwiXFx1MjI4M1xcdTIwRDJcIixcbiAgXCJuc3Vwc2V0ZXFcIjpcIlxcdTIyODlcIixcbiAgXCJuc3Vwc2V0ZXFxXCI6XCJcXHUyQUM2XFx1MDMzOFwiLFxuICBcIm50Z2xcIjpcIlxcdTIyNzlcIixcbiAgXCJOdGlsZGVcIjpcIlxcdTAwRDFcIixcbiAgXCJudGlsZGVcIjpcIlxcdTAwRjFcIixcbiAgXCJudGxnXCI6XCJcXHUyMjc4XCIsXG4gIFwibnRyaWFuZ2xlbGVmdFwiOlwiXFx1MjJFQVwiLFxuICBcIm50cmlhbmdsZWxlZnRlcVwiOlwiXFx1MjJFQ1wiLFxuICBcIm50cmlhbmdsZXJpZ2h0XCI6XCJcXHUyMkVCXCIsXG4gIFwibnRyaWFuZ2xlcmlnaHRlcVwiOlwiXFx1MjJFRFwiLFxuICBcIk51XCI6XCJcXHUwMzlEXCIsXG4gIFwibnVcIjpcIlxcdTAzQkRcIixcbiAgXCJudW1cIjpcIlxcdTAwMjNcIixcbiAgXCJudW1lcm9cIjpcIlxcdTIxMTZcIixcbiAgXCJudW1zcFwiOlwiXFx1MjAwN1wiLFxuICBcIm52YXBcIjpcIlxcdTIyNERcXHUyMEQyXCIsXG4gIFwiblZEYXNoXCI6XCJcXHUyMkFGXCIsXG4gIFwiblZkYXNoXCI6XCJcXHUyMkFFXCIsXG4gIFwibnZEYXNoXCI6XCJcXHUyMkFEXCIsXG4gIFwibnZkYXNoXCI6XCJcXHUyMkFDXCIsXG4gIFwibnZnZVwiOlwiXFx1MjI2NVxcdTIwRDJcIixcbiAgXCJudmd0XCI6XCJcXHUwMDNFXFx1MjBEMlwiLFxuICBcIm52SGFyclwiOlwiXFx1MjkwNFwiLFxuICBcIm52aW5maW5cIjpcIlxcdTI5REVcIixcbiAgXCJudmxBcnJcIjpcIlxcdTI5MDJcIixcbiAgXCJudmxlXCI6XCJcXHUyMjY0XFx1MjBEMlwiLFxuICBcIm52bHRcIjpcIlxcdTAwM0NcXHUyMEQyXCIsXG4gIFwibnZsdHJpZVwiOlwiXFx1MjJCNFxcdTIwRDJcIixcbiAgXCJudnJBcnJcIjpcIlxcdTI5MDNcIixcbiAgXCJudnJ0cmllXCI6XCJcXHUyMkI1XFx1MjBEMlwiLFxuICBcIm52c2ltXCI6XCJcXHUyMjNDXFx1MjBEMlwiLFxuICBcIm53YXJoa1wiOlwiXFx1MjkyM1wiLFxuICBcIm53QXJyXCI6XCJcXHUyMUQ2XCIsXG4gIFwibndhcnJcIjpcIlxcdTIxOTZcIixcbiAgXCJud2Fycm93XCI6XCJcXHUyMTk2XCIsXG4gIFwibnduZWFyXCI6XCJcXHUyOTI3XCIsXG4gIFwiT2FjdXRlXCI6XCJcXHUwMEQzXCIsXG4gIFwib2FjdXRlXCI6XCJcXHUwMEYzXCIsXG4gIFwib2FzdFwiOlwiXFx1MjI5QlwiLFxuICBcIm9jaXJcIjpcIlxcdTIyOUFcIixcbiAgXCJPY2lyY1wiOlwiXFx1MDBENFwiLFxuICBcIm9jaXJjXCI6XCJcXHUwMEY0XCIsXG4gIFwiT2N5XCI6XCJcXHUwNDFFXCIsXG4gIFwib2N5XCI6XCJcXHUwNDNFXCIsXG4gIFwib2Rhc2hcIjpcIlxcdTIyOURcIixcbiAgXCJPZGJsYWNcIjpcIlxcdTAxNTBcIixcbiAgXCJvZGJsYWNcIjpcIlxcdTAxNTFcIixcbiAgXCJvZGl2XCI6XCJcXHUyQTM4XCIsXG4gIFwib2RvdFwiOlwiXFx1MjI5OVwiLFxuICBcIm9kc29sZFwiOlwiXFx1MjlCQ1wiLFxuICBcIk9FbGlnXCI6XCJcXHUwMTUyXCIsXG4gIFwib2VsaWdcIjpcIlxcdTAxNTNcIixcbiAgXCJvZmNpclwiOlwiXFx1MjlCRlwiLFxuICBcIk9mclwiOlwiXFx1RDgzNVxcdUREMTJcIixcbiAgXCJvZnJcIjpcIlxcdUQ4MzVcXHVERDJDXCIsXG4gIFwib2dvblwiOlwiXFx1MDJEQlwiLFxuICBcIk9ncmF2ZVwiOlwiXFx1MDBEMlwiLFxuICBcIm9ncmF2ZVwiOlwiXFx1MDBGMlwiLFxuICBcIm9ndFwiOlwiXFx1MjlDMVwiLFxuICBcIm9oYmFyXCI6XCJcXHUyOUI1XCIsXG4gIFwib2htXCI6XCJcXHUwM0E5XCIsXG4gIFwib2ludFwiOlwiXFx1MjIyRVwiLFxuICBcIm9sYXJyXCI6XCJcXHUyMUJBXCIsXG4gIFwib2xjaXJcIjpcIlxcdTI5QkVcIixcbiAgXCJvbGNyb3NzXCI6XCJcXHUyOUJCXCIsXG4gIFwib2xpbmVcIjpcIlxcdTIwM0VcIixcbiAgXCJvbHRcIjpcIlxcdTI5QzBcIixcbiAgXCJPbWFjclwiOlwiXFx1MDE0Q1wiLFxuICBcIm9tYWNyXCI6XCJcXHUwMTREXCIsXG4gIFwiT21lZ2FcIjpcIlxcdTAzQTlcIixcbiAgXCJvbWVnYVwiOlwiXFx1MDNDOVwiLFxuICBcIk9taWNyb25cIjpcIlxcdTAzOUZcIixcbiAgXCJvbWljcm9uXCI6XCJcXHUwM0JGXCIsXG4gIFwib21pZFwiOlwiXFx1MjlCNlwiLFxuICBcIm9taW51c1wiOlwiXFx1MjI5NlwiLFxuICBcIk9vcGZcIjpcIlxcdUQ4MzVcXHVERDQ2XCIsXG4gIFwib29wZlwiOlwiXFx1RDgzNVxcdURENjBcIixcbiAgXCJvcGFyXCI6XCJcXHUyOUI3XCIsXG4gIFwiT3BlbkN1cmx5RG91YmxlUXVvdGVcIjpcIlxcdTIwMUNcIixcbiAgXCJPcGVuQ3VybHlRdW90ZVwiOlwiXFx1MjAxOFwiLFxuICBcIm9wZXJwXCI6XCJcXHUyOUI5XCIsXG4gIFwib3BsdXNcIjpcIlxcdTIyOTVcIixcbiAgXCJPclwiOlwiXFx1MkE1NFwiLFxuICBcIm9yXCI6XCJcXHUyMjI4XCIsXG4gIFwib3JhcnJcIjpcIlxcdTIxQkJcIixcbiAgXCJvcmRcIjpcIlxcdTJBNURcIixcbiAgXCJvcmRlclwiOlwiXFx1MjEzNFwiLFxuICBcIm9yZGVyb2ZcIjpcIlxcdTIxMzRcIixcbiAgXCJvcmRmXCI6XCJcXHUwMEFBXCIsXG4gIFwib3JkbVwiOlwiXFx1MDBCQVwiLFxuICBcIm9yaWdvZlwiOlwiXFx1MjJCNlwiLFxuICBcIm9yb3JcIjpcIlxcdTJBNTZcIixcbiAgXCJvcnNsb3BlXCI6XCJcXHUyQTU3XCIsXG4gIFwib3J2XCI6XCJcXHUyQTVCXCIsXG4gIFwib1NcIjpcIlxcdTI0QzhcIixcbiAgXCJPc2NyXCI6XCJcXHVEODM1XFx1RENBQVwiLFxuICBcIm9zY3JcIjpcIlxcdTIxMzRcIixcbiAgXCJPc2xhc2hcIjpcIlxcdTAwRDhcIixcbiAgXCJvc2xhc2hcIjpcIlxcdTAwRjhcIixcbiAgXCJvc29sXCI6XCJcXHUyMjk4XCIsXG4gIFwiT3RpbGRlXCI6XCJcXHUwMEQ1XCIsXG4gIFwib3RpbGRlXCI6XCJcXHUwMEY1XCIsXG4gIFwiT3RpbWVzXCI6XCJcXHUyQTM3XCIsXG4gIFwib3RpbWVzXCI6XCJcXHUyMjk3XCIsXG4gIFwib3RpbWVzYXNcIjpcIlxcdTJBMzZcIixcbiAgXCJPdW1sXCI6XCJcXHUwMEQ2XCIsXG4gIFwib3VtbFwiOlwiXFx1MDBGNlwiLFxuICBcIm92YmFyXCI6XCJcXHUyMzNEXCIsXG4gIFwiT3ZlckJhclwiOlwiXFx1MjAzRVwiLFxuICBcIk92ZXJCcmFjZVwiOlwiXFx1MjNERVwiLFxuICBcIk92ZXJCcmFja2V0XCI6XCJcXHUyM0I0XCIsXG4gIFwiT3ZlclBhcmVudGhlc2lzXCI6XCJcXHUyM0RDXCIsXG4gIFwicGFyXCI6XCJcXHUyMjI1XCIsXG4gIFwicGFyYVwiOlwiXFx1MDBCNlwiLFxuICBcInBhcmFsbGVsXCI6XCJcXHUyMjI1XCIsXG4gIFwicGFyc2ltXCI6XCJcXHUyQUYzXCIsXG4gIFwicGFyc2xcIjpcIlxcdTJBRkRcIixcbiAgXCJwYXJ0XCI6XCJcXHUyMjAyXCIsXG4gIFwiUGFydGlhbERcIjpcIlxcdTIyMDJcIixcbiAgXCJQY3lcIjpcIlxcdTA0MUZcIixcbiAgXCJwY3lcIjpcIlxcdTA0M0ZcIixcbiAgXCJwZXJjbnRcIjpcIlxcdTAwMjVcIixcbiAgXCJwZXJpb2RcIjpcIlxcdTAwMkVcIixcbiAgXCJwZXJtaWxcIjpcIlxcdTIwMzBcIixcbiAgXCJwZXJwXCI6XCJcXHUyMkE1XCIsXG4gIFwicGVydGVua1wiOlwiXFx1MjAzMVwiLFxuICBcIlBmclwiOlwiXFx1RDgzNVxcdUREMTNcIixcbiAgXCJwZnJcIjpcIlxcdUQ4MzVcXHVERDJEXCIsXG4gIFwiUGhpXCI6XCJcXHUwM0E2XCIsXG4gIFwicGhpXCI6XCJcXHUwM0M2XCIsXG4gIFwicGhpdlwiOlwiXFx1MDNENVwiLFxuICBcInBobW1hdFwiOlwiXFx1MjEzM1wiLFxuICBcInBob25lXCI6XCJcXHUyNjBFXCIsXG4gIFwiUGlcIjpcIlxcdTAzQTBcIixcbiAgXCJwaVwiOlwiXFx1MDNDMFwiLFxuICBcInBpdGNoZm9ya1wiOlwiXFx1MjJENFwiLFxuICBcInBpdlwiOlwiXFx1MDNENlwiLFxuICBcInBsYW5ja1wiOlwiXFx1MjEwRlwiLFxuICBcInBsYW5ja2hcIjpcIlxcdTIxMEVcIixcbiAgXCJwbGFua3ZcIjpcIlxcdTIxMEZcIixcbiAgXCJwbHVzXCI6XCJcXHUwMDJCXCIsXG4gIFwicGx1c2FjaXJcIjpcIlxcdTJBMjNcIixcbiAgXCJwbHVzYlwiOlwiXFx1MjI5RVwiLFxuICBcInBsdXNjaXJcIjpcIlxcdTJBMjJcIixcbiAgXCJwbHVzZG9cIjpcIlxcdTIyMTRcIixcbiAgXCJwbHVzZHVcIjpcIlxcdTJBMjVcIixcbiAgXCJwbHVzZVwiOlwiXFx1MkE3MlwiLFxuICBcIlBsdXNNaW51c1wiOlwiXFx1MDBCMVwiLFxuICBcInBsdXNtblwiOlwiXFx1MDBCMVwiLFxuICBcInBsdXNzaW1cIjpcIlxcdTJBMjZcIixcbiAgXCJwbHVzdHdvXCI6XCJcXHUyQTI3XCIsXG4gIFwicG1cIjpcIlxcdTAwQjFcIixcbiAgXCJQb2luY2FyZXBsYW5lXCI6XCJcXHUyMTBDXCIsXG4gIFwicG9pbnRpbnRcIjpcIlxcdTJBMTVcIixcbiAgXCJQb3BmXCI6XCJcXHUyMTE5XCIsXG4gIFwicG9wZlwiOlwiXFx1RDgzNVxcdURENjFcIixcbiAgXCJwb3VuZFwiOlwiXFx1MDBBM1wiLFxuICBcIlByXCI6XCJcXHUyQUJCXCIsXG4gIFwicHJcIjpcIlxcdTIyN0FcIixcbiAgXCJwcmFwXCI6XCJcXHUyQUI3XCIsXG4gIFwicHJjdWVcIjpcIlxcdTIyN0NcIixcbiAgXCJwckVcIjpcIlxcdTJBQjNcIixcbiAgXCJwcmVcIjpcIlxcdTJBQUZcIixcbiAgXCJwcmVjXCI6XCJcXHUyMjdBXCIsXG4gIFwicHJlY2FwcHJveFwiOlwiXFx1MkFCN1wiLFxuICBcInByZWNjdXJseWVxXCI6XCJcXHUyMjdDXCIsXG4gIFwiUHJlY2VkZXNcIjpcIlxcdTIyN0FcIixcbiAgXCJQcmVjZWRlc0VxdWFsXCI6XCJcXHUyQUFGXCIsXG4gIFwiUHJlY2VkZXNTbGFudEVxdWFsXCI6XCJcXHUyMjdDXCIsXG4gIFwiUHJlY2VkZXNUaWxkZVwiOlwiXFx1MjI3RVwiLFxuICBcInByZWNlcVwiOlwiXFx1MkFBRlwiLFxuICBcInByZWNuYXBwcm94XCI6XCJcXHUyQUI5XCIsXG4gIFwicHJlY25lcXFcIjpcIlxcdTJBQjVcIixcbiAgXCJwcmVjbnNpbVwiOlwiXFx1MjJFOFwiLFxuICBcInByZWNzaW1cIjpcIlxcdTIyN0VcIixcbiAgXCJQcmltZVwiOlwiXFx1MjAzM1wiLFxuICBcInByaW1lXCI6XCJcXHUyMDMyXCIsXG4gIFwicHJpbWVzXCI6XCJcXHUyMTE5XCIsXG4gIFwicHJuYXBcIjpcIlxcdTJBQjlcIixcbiAgXCJwcm5FXCI6XCJcXHUyQUI1XCIsXG4gIFwicHJuc2ltXCI6XCJcXHUyMkU4XCIsXG4gIFwicHJvZFwiOlwiXFx1MjIwRlwiLFxuICBcIlByb2R1Y3RcIjpcIlxcdTIyMEZcIixcbiAgXCJwcm9mYWxhclwiOlwiXFx1MjMyRVwiLFxuICBcInByb2ZsaW5lXCI6XCJcXHUyMzEyXCIsXG4gIFwicHJvZnN1cmZcIjpcIlxcdTIzMTNcIixcbiAgXCJwcm9wXCI6XCJcXHUyMjFEXCIsXG4gIFwiUHJvcG9ydGlvblwiOlwiXFx1MjIzN1wiLFxuICBcIlByb3BvcnRpb25hbFwiOlwiXFx1MjIxRFwiLFxuICBcInByb3B0b1wiOlwiXFx1MjIxRFwiLFxuICBcInByc2ltXCI6XCJcXHUyMjdFXCIsXG4gIFwicHJ1cmVsXCI6XCJcXHUyMkIwXCIsXG4gIFwiUHNjclwiOlwiXFx1RDgzNVxcdURDQUJcIixcbiAgXCJwc2NyXCI6XCJcXHVEODM1XFx1RENDNVwiLFxuICBcIlBzaVwiOlwiXFx1MDNBOFwiLFxuICBcInBzaVwiOlwiXFx1MDNDOFwiLFxuICBcInB1bmNzcFwiOlwiXFx1MjAwOFwiLFxuICBcIlFmclwiOlwiXFx1RDgzNVxcdUREMTRcIixcbiAgXCJxZnJcIjpcIlxcdUQ4MzVcXHVERDJFXCIsXG4gIFwicWludFwiOlwiXFx1MkEwQ1wiLFxuICBcIlFvcGZcIjpcIlxcdTIxMUFcIixcbiAgXCJxb3BmXCI6XCJcXHVEODM1XFx1REQ2MlwiLFxuICBcInFwcmltZVwiOlwiXFx1MjA1N1wiLFxuICBcIlFzY3JcIjpcIlxcdUQ4MzVcXHVEQ0FDXCIsXG4gIFwicXNjclwiOlwiXFx1RDgzNVxcdURDQzZcIixcbiAgXCJxdWF0ZXJuaW9uc1wiOlwiXFx1MjEwRFwiLFxuICBcInF1YXRpbnRcIjpcIlxcdTJBMTZcIixcbiAgXCJxdWVzdFwiOlwiXFx1MDAzRlwiLFxuICBcInF1ZXN0ZXFcIjpcIlxcdTIyNUZcIixcbiAgXCJRVU9UXCI6XCJcXHUwMDIyXCIsXG4gIFwicXVvdFwiOlwiXFx1MDAyMlwiLFxuICBcInJBYXJyXCI6XCJcXHUyMURCXCIsXG4gIFwicmFjZVwiOlwiXFx1MjIzRFxcdTAzMzFcIixcbiAgXCJSYWN1dGVcIjpcIlxcdTAxNTRcIixcbiAgXCJyYWN1dGVcIjpcIlxcdTAxNTVcIixcbiAgXCJyYWRpY1wiOlwiXFx1MjIxQVwiLFxuICBcInJhZW1wdHl2XCI6XCJcXHUyOUIzXCIsXG4gIFwiUmFuZ1wiOlwiXFx1MjdFQlwiLFxuICBcInJhbmdcIjpcIlxcdTI3RTlcIixcbiAgXCJyYW5nZFwiOlwiXFx1Mjk5MlwiLFxuICBcInJhbmdlXCI6XCJcXHUyOUE1XCIsXG4gIFwicmFuZ2xlXCI6XCJcXHUyN0U5XCIsXG4gIFwicmFxdW9cIjpcIlxcdTAwQkJcIixcbiAgXCJSYXJyXCI6XCJcXHUyMUEwXCIsXG4gIFwickFyclwiOlwiXFx1MjFEMlwiLFxuICBcInJhcnJcIjpcIlxcdTIxOTJcIixcbiAgXCJyYXJyYXBcIjpcIlxcdTI5NzVcIixcbiAgXCJyYXJyYlwiOlwiXFx1MjFFNVwiLFxuICBcInJhcnJiZnNcIjpcIlxcdTI5MjBcIixcbiAgXCJyYXJyY1wiOlwiXFx1MjkzM1wiLFxuICBcInJhcnJmc1wiOlwiXFx1MjkxRVwiLFxuICBcInJhcnJoa1wiOlwiXFx1MjFBQVwiLFxuICBcInJhcnJscFwiOlwiXFx1MjFBQ1wiLFxuICBcInJhcnJwbFwiOlwiXFx1Mjk0NVwiLFxuICBcInJhcnJzaW1cIjpcIlxcdTI5NzRcIixcbiAgXCJSYXJydGxcIjpcIlxcdTI5MTZcIixcbiAgXCJyYXJydGxcIjpcIlxcdTIxQTNcIixcbiAgXCJyYXJyd1wiOlwiXFx1MjE5RFwiLFxuICBcInJBdGFpbFwiOlwiXFx1MjkxQ1wiLFxuICBcInJhdGFpbFwiOlwiXFx1MjkxQVwiLFxuICBcInJhdGlvXCI6XCJcXHUyMjM2XCIsXG4gIFwicmF0aW9uYWxzXCI6XCJcXHUyMTFBXCIsXG4gIFwiUkJhcnJcIjpcIlxcdTI5MTBcIixcbiAgXCJyQmFyclwiOlwiXFx1MjkwRlwiLFxuICBcInJiYXJyXCI6XCJcXHUyOTBEXCIsXG4gIFwicmJicmtcIjpcIlxcdTI3NzNcIixcbiAgXCJyYnJhY2VcIjpcIlxcdTAwN0RcIixcbiAgXCJyYnJhY2tcIjpcIlxcdTAwNURcIixcbiAgXCJyYnJrZVwiOlwiXFx1Mjk4Q1wiLFxuICBcInJicmtzbGRcIjpcIlxcdTI5OEVcIixcbiAgXCJyYnJrc2x1XCI6XCJcXHUyOTkwXCIsXG4gIFwiUmNhcm9uXCI6XCJcXHUwMTU4XCIsXG4gIFwicmNhcm9uXCI6XCJcXHUwMTU5XCIsXG4gIFwiUmNlZGlsXCI6XCJcXHUwMTU2XCIsXG4gIFwicmNlZGlsXCI6XCJcXHUwMTU3XCIsXG4gIFwicmNlaWxcIjpcIlxcdTIzMDlcIixcbiAgXCJyY3ViXCI6XCJcXHUwMDdEXCIsXG4gIFwiUmN5XCI6XCJcXHUwNDIwXCIsXG4gIFwicmN5XCI6XCJcXHUwNDQwXCIsXG4gIFwicmRjYVwiOlwiXFx1MjkzN1wiLFxuICBcInJkbGRoYXJcIjpcIlxcdTI5NjlcIixcbiAgXCJyZHF1b1wiOlwiXFx1MjAxRFwiLFxuICBcInJkcXVvclwiOlwiXFx1MjAxRFwiLFxuICBcInJkc2hcIjpcIlxcdTIxQjNcIixcbiAgXCJSZVwiOlwiXFx1MjExQ1wiLFxuICBcInJlYWxcIjpcIlxcdTIxMUNcIixcbiAgXCJyZWFsaW5lXCI6XCJcXHUyMTFCXCIsXG4gIFwicmVhbHBhcnRcIjpcIlxcdTIxMUNcIixcbiAgXCJyZWFsc1wiOlwiXFx1MjExRFwiLFxuICBcInJlY3RcIjpcIlxcdTI1QURcIixcbiAgXCJSRUdcIjpcIlxcdTAwQUVcIixcbiAgXCJyZWdcIjpcIlxcdTAwQUVcIixcbiAgXCJSZXZlcnNlRWxlbWVudFwiOlwiXFx1MjIwQlwiLFxuICBcIlJldmVyc2VFcXVpbGlicml1bVwiOlwiXFx1MjFDQlwiLFxuICBcIlJldmVyc2VVcEVxdWlsaWJyaXVtXCI6XCJcXHUyOTZGXCIsXG4gIFwicmZpc2h0XCI6XCJcXHUyOTdEXCIsXG4gIFwicmZsb29yXCI6XCJcXHUyMzBCXCIsXG4gIFwiUmZyXCI6XCJcXHUyMTFDXCIsXG4gIFwicmZyXCI6XCJcXHVEODM1XFx1REQyRlwiLFxuICBcInJIYXJcIjpcIlxcdTI5NjRcIixcbiAgXCJyaGFyZFwiOlwiXFx1MjFDMVwiLFxuICBcInJoYXJ1XCI6XCJcXHUyMUMwXCIsXG4gIFwicmhhcnVsXCI6XCJcXHUyOTZDXCIsXG4gIFwiUmhvXCI6XCJcXHUwM0ExXCIsXG4gIFwicmhvXCI6XCJcXHUwM0MxXCIsXG4gIFwicmhvdlwiOlwiXFx1MDNGMVwiLFxuICBcIlJpZ2h0QW5nbGVCcmFja2V0XCI6XCJcXHUyN0U5XCIsXG4gIFwiUmlnaHRBcnJvd1wiOlwiXFx1MjE5MlwiLFxuICBcIlJpZ2h0YXJyb3dcIjpcIlxcdTIxRDJcIixcbiAgXCJyaWdodGFycm93XCI6XCJcXHUyMTkyXCIsXG4gIFwiUmlnaHRBcnJvd0JhclwiOlwiXFx1MjFFNVwiLFxuICBcIlJpZ2h0QXJyb3dMZWZ0QXJyb3dcIjpcIlxcdTIxQzRcIixcbiAgXCJyaWdodGFycm93dGFpbFwiOlwiXFx1MjFBM1wiLFxuICBcIlJpZ2h0Q2VpbGluZ1wiOlwiXFx1MjMwOVwiLFxuICBcIlJpZ2h0RG91YmxlQnJhY2tldFwiOlwiXFx1MjdFN1wiLFxuICBcIlJpZ2h0RG93blRlZVZlY3RvclwiOlwiXFx1Mjk1RFwiLFxuICBcIlJpZ2h0RG93blZlY3RvclwiOlwiXFx1MjFDMlwiLFxuICBcIlJpZ2h0RG93blZlY3RvckJhclwiOlwiXFx1Mjk1NVwiLFxuICBcIlJpZ2h0Rmxvb3JcIjpcIlxcdTIzMEJcIixcbiAgXCJyaWdodGhhcnBvb25kb3duXCI6XCJcXHUyMUMxXCIsXG4gIFwicmlnaHRoYXJwb29udXBcIjpcIlxcdTIxQzBcIixcbiAgXCJyaWdodGxlZnRhcnJvd3NcIjpcIlxcdTIxQzRcIixcbiAgXCJyaWdodGxlZnRoYXJwb29uc1wiOlwiXFx1MjFDQ1wiLFxuICBcInJpZ2h0cmlnaHRhcnJvd3NcIjpcIlxcdTIxQzlcIixcbiAgXCJyaWdodHNxdWlnYXJyb3dcIjpcIlxcdTIxOURcIixcbiAgXCJSaWdodFRlZVwiOlwiXFx1MjJBMlwiLFxuICBcIlJpZ2h0VGVlQXJyb3dcIjpcIlxcdTIxQTZcIixcbiAgXCJSaWdodFRlZVZlY3RvclwiOlwiXFx1Mjk1QlwiLFxuICBcInJpZ2h0dGhyZWV0aW1lc1wiOlwiXFx1MjJDQ1wiLFxuICBcIlJpZ2h0VHJpYW5nbGVcIjpcIlxcdTIyQjNcIixcbiAgXCJSaWdodFRyaWFuZ2xlQmFyXCI6XCJcXHUyOUQwXCIsXG4gIFwiUmlnaHRUcmlhbmdsZUVxdWFsXCI6XCJcXHUyMkI1XCIsXG4gIFwiUmlnaHRVcERvd25WZWN0b3JcIjpcIlxcdTI5NEZcIixcbiAgXCJSaWdodFVwVGVlVmVjdG9yXCI6XCJcXHUyOTVDXCIsXG4gIFwiUmlnaHRVcFZlY3RvclwiOlwiXFx1MjFCRVwiLFxuICBcIlJpZ2h0VXBWZWN0b3JCYXJcIjpcIlxcdTI5NTRcIixcbiAgXCJSaWdodFZlY3RvclwiOlwiXFx1MjFDMFwiLFxuICBcIlJpZ2h0VmVjdG9yQmFyXCI6XCJcXHUyOTUzXCIsXG4gIFwicmluZ1wiOlwiXFx1MDJEQVwiLFxuICBcInJpc2luZ2RvdHNlcVwiOlwiXFx1MjI1M1wiLFxuICBcInJsYXJyXCI6XCJcXHUyMUM0XCIsXG4gIFwicmxoYXJcIjpcIlxcdTIxQ0NcIixcbiAgXCJybG1cIjpcIlxcdTIwMEZcIixcbiAgXCJybW91c3RcIjpcIlxcdTIzQjFcIixcbiAgXCJybW91c3RhY2hlXCI6XCJcXHUyM0IxXCIsXG4gIFwicm5taWRcIjpcIlxcdTJBRUVcIixcbiAgXCJyb2FuZ1wiOlwiXFx1MjdFRFwiLFxuICBcInJvYXJyXCI6XCJcXHUyMUZFXCIsXG4gIFwicm9icmtcIjpcIlxcdTI3RTdcIixcbiAgXCJyb3BhclwiOlwiXFx1Mjk4NlwiLFxuICBcIlJvcGZcIjpcIlxcdTIxMURcIixcbiAgXCJyb3BmXCI6XCJcXHVEODM1XFx1REQ2M1wiLFxuICBcInJvcGx1c1wiOlwiXFx1MkEyRVwiLFxuICBcInJvdGltZXNcIjpcIlxcdTJBMzVcIixcbiAgXCJSb3VuZEltcGxpZXNcIjpcIlxcdTI5NzBcIixcbiAgXCJycGFyXCI6XCJcXHUwMDI5XCIsXG4gIFwicnBhcmd0XCI6XCJcXHUyOTk0XCIsXG4gIFwicnBwb2xpbnRcIjpcIlxcdTJBMTJcIixcbiAgXCJycmFyclwiOlwiXFx1MjFDOVwiLFxuICBcIlJyaWdodGFycm93XCI6XCJcXHUyMURCXCIsXG4gIFwicnNhcXVvXCI6XCJcXHUyMDNBXCIsXG4gIFwiUnNjclwiOlwiXFx1MjExQlwiLFxuICBcInJzY3JcIjpcIlxcdUQ4MzVcXHVEQ0M3XCIsXG4gIFwiUnNoXCI6XCJcXHUyMUIxXCIsXG4gIFwicnNoXCI6XCJcXHUyMUIxXCIsXG4gIFwicnNxYlwiOlwiXFx1MDA1RFwiLFxuICBcInJzcXVvXCI6XCJcXHUyMDE5XCIsXG4gIFwicnNxdW9yXCI6XCJcXHUyMDE5XCIsXG4gIFwicnRocmVlXCI6XCJcXHUyMkNDXCIsXG4gIFwicnRpbWVzXCI6XCJcXHUyMkNBXCIsXG4gIFwicnRyaVwiOlwiXFx1MjVCOVwiLFxuICBcInJ0cmllXCI6XCJcXHUyMkI1XCIsXG4gIFwicnRyaWZcIjpcIlxcdTI1QjhcIixcbiAgXCJydHJpbHRyaVwiOlwiXFx1MjlDRVwiLFxuICBcIlJ1bGVEZWxheWVkXCI6XCJcXHUyOUY0XCIsXG4gIFwicnVsdWhhclwiOlwiXFx1Mjk2OFwiLFxuICBcInJ4XCI6XCJcXHUyMTFFXCIsXG4gIFwiU2FjdXRlXCI6XCJcXHUwMTVBXCIsXG4gIFwic2FjdXRlXCI6XCJcXHUwMTVCXCIsXG4gIFwic2JxdW9cIjpcIlxcdTIwMUFcIixcbiAgXCJTY1wiOlwiXFx1MkFCQ1wiLFxuICBcInNjXCI6XCJcXHUyMjdCXCIsXG4gIFwic2NhcFwiOlwiXFx1MkFCOFwiLFxuICBcIlNjYXJvblwiOlwiXFx1MDE2MFwiLFxuICBcInNjYXJvblwiOlwiXFx1MDE2MVwiLFxuICBcInNjY3VlXCI6XCJcXHUyMjdEXCIsXG4gIFwic2NFXCI6XCJcXHUyQUI0XCIsXG4gIFwic2NlXCI6XCJcXHUyQUIwXCIsXG4gIFwiU2NlZGlsXCI6XCJcXHUwMTVFXCIsXG4gIFwic2NlZGlsXCI6XCJcXHUwMTVGXCIsXG4gIFwiU2NpcmNcIjpcIlxcdTAxNUNcIixcbiAgXCJzY2lyY1wiOlwiXFx1MDE1RFwiLFxuICBcInNjbmFwXCI6XCJcXHUyQUJBXCIsXG4gIFwic2NuRVwiOlwiXFx1MkFCNlwiLFxuICBcInNjbnNpbVwiOlwiXFx1MjJFOVwiLFxuICBcInNjcG9saW50XCI6XCJcXHUyQTEzXCIsXG4gIFwic2NzaW1cIjpcIlxcdTIyN0ZcIixcbiAgXCJTY3lcIjpcIlxcdTA0MjFcIixcbiAgXCJzY3lcIjpcIlxcdTA0NDFcIixcbiAgXCJzZG90XCI6XCJcXHUyMkM1XCIsXG4gIFwic2RvdGJcIjpcIlxcdTIyQTFcIixcbiAgXCJzZG90ZVwiOlwiXFx1MkE2NlwiLFxuICBcInNlYXJoa1wiOlwiXFx1MjkyNVwiLFxuICBcInNlQXJyXCI6XCJcXHUyMUQ4XCIsXG4gIFwic2VhcnJcIjpcIlxcdTIxOThcIixcbiAgXCJzZWFycm93XCI6XCJcXHUyMTk4XCIsXG4gIFwic2VjdFwiOlwiXFx1MDBBN1wiLFxuICBcInNlbWlcIjpcIlxcdTAwM0JcIixcbiAgXCJzZXN3YXJcIjpcIlxcdTI5MjlcIixcbiAgXCJzZXRtaW51c1wiOlwiXFx1MjIxNlwiLFxuICBcInNldG1uXCI6XCJcXHUyMjE2XCIsXG4gIFwic2V4dFwiOlwiXFx1MjczNlwiLFxuICBcIlNmclwiOlwiXFx1RDgzNVxcdUREMTZcIixcbiAgXCJzZnJcIjpcIlxcdUQ4MzVcXHVERDMwXCIsXG4gIFwic2Zyb3duXCI6XCJcXHUyMzIyXCIsXG4gIFwic2hhcnBcIjpcIlxcdTI2NkZcIixcbiAgXCJTSENIY3lcIjpcIlxcdTA0MjlcIixcbiAgXCJzaGNoY3lcIjpcIlxcdTA0NDlcIixcbiAgXCJTSGN5XCI6XCJcXHUwNDI4XCIsXG4gIFwic2hjeVwiOlwiXFx1MDQ0OFwiLFxuICBcIlNob3J0RG93bkFycm93XCI6XCJcXHUyMTkzXCIsXG4gIFwiU2hvcnRMZWZ0QXJyb3dcIjpcIlxcdTIxOTBcIixcbiAgXCJzaG9ydG1pZFwiOlwiXFx1MjIyM1wiLFxuICBcInNob3J0cGFyYWxsZWxcIjpcIlxcdTIyMjVcIixcbiAgXCJTaG9ydFJpZ2h0QXJyb3dcIjpcIlxcdTIxOTJcIixcbiAgXCJTaG9ydFVwQXJyb3dcIjpcIlxcdTIxOTFcIixcbiAgXCJzaHlcIjpcIlxcdTAwQURcIixcbiAgXCJTaWdtYVwiOlwiXFx1MDNBM1wiLFxuICBcInNpZ21hXCI6XCJcXHUwM0MzXCIsXG4gIFwic2lnbWFmXCI6XCJcXHUwM0MyXCIsXG4gIFwic2lnbWF2XCI6XCJcXHUwM0MyXCIsXG4gIFwic2ltXCI6XCJcXHUyMjNDXCIsXG4gIFwic2ltZG90XCI6XCJcXHUyQTZBXCIsXG4gIFwic2ltZVwiOlwiXFx1MjI0M1wiLFxuICBcInNpbWVxXCI6XCJcXHUyMjQzXCIsXG4gIFwic2ltZ1wiOlwiXFx1MkE5RVwiLFxuICBcInNpbWdFXCI6XCJcXHUyQUEwXCIsXG4gIFwic2ltbFwiOlwiXFx1MkE5RFwiLFxuICBcInNpbWxFXCI6XCJcXHUyQTlGXCIsXG4gIFwic2ltbmVcIjpcIlxcdTIyNDZcIixcbiAgXCJzaW1wbHVzXCI6XCJcXHUyQTI0XCIsXG4gIFwic2ltcmFyclwiOlwiXFx1Mjk3MlwiLFxuICBcInNsYXJyXCI6XCJcXHUyMTkwXCIsXG4gIFwiU21hbGxDaXJjbGVcIjpcIlxcdTIyMThcIixcbiAgXCJzbWFsbHNldG1pbnVzXCI6XCJcXHUyMjE2XCIsXG4gIFwic21hc2hwXCI6XCJcXHUyQTMzXCIsXG4gIFwic21lcGFyc2xcIjpcIlxcdTI5RTRcIixcbiAgXCJzbWlkXCI6XCJcXHUyMjIzXCIsXG4gIFwic21pbGVcIjpcIlxcdTIzMjNcIixcbiAgXCJzbXRcIjpcIlxcdTJBQUFcIixcbiAgXCJzbXRlXCI6XCJcXHUyQUFDXCIsXG4gIFwic210ZXNcIjpcIlxcdTJBQUNcXHVGRTAwXCIsXG4gIFwiU09GVGN5XCI6XCJcXHUwNDJDXCIsXG4gIFwic29mdGN5XCI6XCJcXHUwNDRDXCIsXG4gIFwic29sXCI6XCJcXHUwMDJGXCIsXG4gIFwic29sYlwiOlwiXFx1MjlDNFwiLFxuICBcInNvbGJhclwiOlwiXFx1MjMzRlwiLFxuICBcIlNvcGZcIjpcIlxcdUQ4MzVcXHVERDRBXCIsXG4gIFwic29wZlwiOlwiXFx1RDgzNVxcdURENjRcIixcbiAgXCJzcGFkZXNcIjpcIlxcdTI2NjBcIixcbiAgXCJzcGFkZXN1aXRcIjpcIlxcdTI2NjBcIixcbiAgXCJzcGFyXCI6XCJcXHUyMjI1XCIsXG4gIFwic3FjYXBcIjpcIlxcdTIyOTNcIixcbiAgXCJzcWNhcHNcIjpcIlxcdTIyOTNcXHVGRTAwXCIsXG4gIFwic3FjdXBcIjpcIlxcdTIyOTRcIixcbiAgXCJzcWN1cHNcIjpcIlxcdTIyOTRcXHVGRTAwXCIsXG4gIFwiU3FydFwiOlwiXFx1MjIxQVwiLFxuICBcInNxc3ViXCI6XCJcXHUyMjhGXCIsXG4gIFwic3FzdWJlXCI6XCJcXHUyMjkxXCIsXG4gIFwic3FzdWJzZXRcIjpcIlxcdTIyOEZcIixcbiAgXCJzcXN1YnNldGVxXCI6XCJcXHUyMjkxXCIsXG4gIFwic3FzdXBcIjpcIlxcdTIyOTBcIixcbiAgXCJzcXN1cGVcIjpcIlxcdTIyOTJcIixcbiAgXCJzcXN1cHNldFwiOlwiXFx1MjI5MFwiLFxuICBcInNxc3Vwc2V0ZXFcIjpcIlxcdTIyOTJcIixcbiAgXCJzcXVcIjpcIlxcdTI1QTFcIixcbiAgXCJTcXVhcmVcIjpcIlxcdTI1QTFcIixcbiAgXCJzcXVhcmVcIjpcIlxcdTI1QTFcIixcbiAgXCJTcXVhcmVJbnRlcnNlY3Rpb25cIjpcIlxcdTIyOTNcIixcbiAgXCJTcXVhcmVTdWJzZXRcIjpcIlxcdTIyOEZcIixcbiAgXCJTcXVhcmVTdWJzZXRFcXVhbFwiOlwiXFx1MjI5MVwiLFxuICBcIlNxdWFyZVN1cGVyc2V0XCI6XCJcXHUyMjkwXCIsXG4gIFwiU3F1YXJlU3VwZXJzZXRFcXVhbFwiOlwiXFx1MjI5MlwiLFxuICBcIlNxdWFyZVVuaW9uXCI6XCJcXHUyMjk0XCIsXG4gIFwic3F1YXJmXCI6XCJcXHUyNUFBXCIsXG4gIFwic3F1ZlwiOlwiXFx1MjVBQVwiLFxuICBcInNyYXJyXCI6XCJcXHUyMTkyXCIsXG4gIFwiU3NjclwiOlwiXFx1RDgzNVxcdURDQUVcIixcbiAgXCJzc2NyXCI6XCJcXHVEODM1XFx1RENDOFwiLFxuICBcInNzZXRtblwiOlwiXFx1MjIxNlwiLFxuICBcInNzbWlsZVwiOlwiXFx1MjMyM1wiLFxuICBcInNzdGFyZlwiOlwiXFx1MjJDNlwiLFxuICBcIlN0YXJcIjpcIlxcdTIyQzZcIixcbiAgXCJzdGFyXCI6XCJcXHUyNjA2XCIsXG4gIFwic3RhcmZcIjpcIlxcdTI2MDVcIixcbiAgXCJzdHJhaWdodGVwc2lsb25cIjpcIlxcdTAzRjVcIixcbiAgXCJzdHJhaWdodHBoaVwiOlwiXFx1MDNENVwiLFxuICBcInN0cm5zXCI6XCJcXHUwMEFGXCIsXG4gIFwiU3ViXCI6XCJcXHUyMkQwXCIsXG4gIFwic3ViXCI6XCJcXHUyMjgyXCIsXG4gIFwic3ViZG90XCI6XCJcXHUyQUJEXCIsXG4gIFwic3ViRVwiOlwiXFx1MkFDNVwiLFxuICBcInN1YmVcIjpcIlxcdTIyODZcIixcbiAgXCJzdWJlZG90XCI6XCJcXHUyQUMzXCIsXG4gIFwic3VibXVsdFwiOlwiXFx1MkFDMVwiLFxuICBcInN1Ym5FXCI6XCJcXHUyQUNCXCIsXG4gIFwic3VibmVcIjpcIlxcdTIyOEFcIixcbiAgXCJzdWJwbHVzXCI6XCJcXHUyQUJGXCIsXG4gIFwic3VicmFyclwiOlwiXFx1Mjk3OVwiLFxuICBcIlN1YnNldFwiOlwiXFx1MjJEMFwiLFxuICBcInN1YnNldFwiOlwiXFx1MjI4MlwiLFxuICBcInN1YnNldGVxXCI6XCJcXHUyMjg2XCIsXG4gIFwic3Vic2V0ZXFxXCI6XCJcXHUyQUM1XCIsXG4gIFwiU3Vic2V0RXF1YWxcIjpcIlxcdTIyODZcIixcbiAgXCJzdWJzZXRuZXFcIjpcIlxcdTIyOEFcIixcbiAgXCJzdWJzZXRuZXFxXCI6XCJcXHUyQUNCXCIsXG4gIFwic3Vic2ltXCI6XCJcXHUyQUM3XCIsXG4gIFwic3Vic3ViXCI6XCJcXHUyQUQ1XCIsXG4gIFwic3Vic3VwXCI6XCJcXHUyQUQzXCIsXG4gIFwic3VjY1wiOlwiXFx1MjI3QlwiLFxuICBcInN1Y2NhcHByb3hcIjpcIlxcdTJBQjhcIixcbiAgXCJzdWNjY3VybHllcVwiOlwiXFx1MjI3RFwiLFxuICBcIlN1Y2NlZWRzXCI6XCJcXHUyMjdCXCIsXG4gIFwiU3VjY2VlZHNFcXVhbFwiOlwiXFx1MkFCMFwiLFxuICBcIlN1Y2NlZWRzU2xhbnRFcXVhbFwiOlwiXFx1MjI3RFwiLFxuICBcIlN1Y2NlZWRzVGlsZGVcIjpcIlxcdTIyN0ZcIixcbiAgXCJzdWNjZXFcIjpcIlxcdTJBQjBcIixcbiAgXCJzdWNjbmFwcHJveFwiOlwiXFx1MkFCQVwiLFxuICBcInN1Y2NuZXFxXCI6XCJcXHUyQUI2XCIsXG4gIFwic3VjY25zaW1cIjpcIlxcdTIyRTlcIixcbiAgXCJzdWNjc2ltXCI6XCJcXHUyMjdGXCIsXG4gIFwiU3VjaFRoYXRcIjpcIlxcdTIyMEJcIixcbiAgXCJTdW1cIjpcIlxcdTIyMTFcIixcbiAgXCJzdW1cIjpcIlxcdTIyMTFcIixcbiAgXCJzdW5nXCI6XCJcXHUyNjZBXCIsXG4gIFwiU3VwXCI6XCJcXHUyMkQxXCIsXG4gIFwic3VwXCI6XCJcXHUyMjgzXCIsXG4gIFwic3VwMVwiOlwiXFx1MDBCOVwiLFxuICBcInN1cDJcIjpcIlxcdTAwQjJcIixcbiAgXCJzdXAzXCI6XCJcXHUwMEIzXCIsXG4gIFwic3VwZG90XCI6XCJcXHUyQUJFXCIsXG4gIFwic3VwZHN1YlwiOlwiXFx1MkFEOFwiLFxuICBcInN1cEVcIjpcIlxcdTJBQzZcIixcbiAgXCJzdXBlXCI6XCJcXHUyMjg3XCIsXG4gIFwic3VwZWRvdFwiOlwiXFx1MkFDNFwiLFxuICBcIlN1cGVyc2V0XCI6XCJcXHUyMjgzXCIsXG4gIFwiU3VwZXJzZXRFcXVhbFwiOlwiXFx1MjI4N1wiLFxuICBcInN1cGhzb2xcIjpcIlxcdTI3QzlcIixcbiAgXCJzdXBoc3ViXCI6XCJcXHUyQUQ3XCIsXG4gIFwic3VwbGFyclwiOlwiXFx1Mjk3QlwiLFxuICBcInN1cG11bHRcIjpcIlxcdTJBQzJcIixcbiAgXCJzdXBuRVwiOlwiXFx1MkFDQ1wiLFxuICBcInN1cG5lXCI6XCJcXHUyMjhCXCIsXG4gIFwic3VwcGx1c1wiOlwiXFx1MkFDMFwiLFxuICBcIlN1cHNldFwiOlwiXFx1MjJEMVwiLFxuICBcInN1cHNldFwiOlwiXFx1MjI4M1wiLFxuICBcInN1cHNldGVxXCI6XCJcXHUyMjg3XCIsXG4gIFwic3Vwc2V0ZXFxXCI6XCJcXHUyQUM2XCIsXG4gIFwic3Vwc2V0bmVxXCI6XCJcXHUyMjhCXCIsXG4gIFwic3Vwc2V0bmVxcVwiOlwiXFx1MkFDQ1wiLFxuICBcInN1cHNpbVwiOlwiXFx1MkFDOFwiLFxuICBcInN1cHN1YlwiOlwiXFx1MkFENFwiLFxuICBcInN1cHN1cFwiOlwiXFx1MkFENlwiLFxuICBcInN3YXJoa1wiOlwiXFx1MjkyNlwiLFxuICBcInN3QXJyXCI6XCJcXHUyMUQ5XCIsXG4gIFwic3dhcnJcIjpcIlxcdTIxOTlcIixcbiAgXCJzd2Fycm93XCI6XCJcXHUyMTk5XCIsXG4gIFwic3dud2FyXCI6XCJcXHUyOTJBXCIsXG4gIFwic3psaWdcIjpcIlxcdTAwREZcIixcbiAgXCJUYWJcIjpcIlxcdTAwMDlcIixcbiAgXCJ0YXJnZXRcIjpcIlxcdTIzMTZcIixcbiAgXCJUYXVcIjpcIlxcdTAzQTRcIixcbiAgXCJ0YXVcIjpcIlxcdTAzQzRcIixcbiAgXCJ0YnJrXCI6XCJcXHUyM0I0XCIsXG4gIFwiVGNhcm9uXCI6XCJcXHUwMTY0XCIsXG4gIFwidGNhcm9uXCI6XCJcXHUwMTY1XCIsXG4gIFwiVGNlZGlsXCI6XCJcXHUwMTYyXCIsXG4gIFwidGNlZGlsXCI6XCJcXHUwMTYzXCIsXG4gIFwiVGN5XCI6XCJcXHUwNDIyXCIsXG4gIFwidGN5XCI6XCJcXHUwNDQyXCIsXG4gIFwidGRvdFwiOlwiXFx1MjBEQlwiLFxuICBcInRlbHJlY1wiOlwiXFx1MjMxNVwiLFxuICBcIlRmclwiOlwiXFx1RDgzNVxcdUREMTdcIixcbiAgXCJ0ZnJcIjpcIlxcdUQ4MzVcXHVERDMxXCIsXG4gIFwidGhlcmU0XCI6XCJcXHUyMjM0XCIsXG4gIFwiVGhlcmVmb3JlXCI6XCJcXHUyMjM0XCIsXG4gIFwidGhlcmVmb3JlXCI6XCJcXHUyMjM0XCIsXG4gIFwiVGhldGFcIjpcIlxcdTAzOThcIixcbiAgXCJ0aGV0YVwiOlwiXFx1MDNCOFwiLFxuICBcInRoZXRhc3ltXCI6XCJcXHUwM0QxXCIsXG4gIFwidGhldGF2XCI6XCJcXHUwM0QxXCIsXG4gIFwidGhpY2thcHByb3hcIjpcIlxcdTIyNDhcIixcbiAgXCJ0aGlja3NpbVwiOlwiXFx1MjIzQ1wiLFxuICBcIlRoaWNrU3BhY2VcIjpcIlxcdTIwNUZcXHUyMDBBXCIsXG4gIFwidGhpbnNwXCI6XCJcXHUyMDA5XCIsXG4gIFwiVGhpblNwYWNlXCI6XCJcXHUyMDA5XCIsXG4gIFwidGhrYXBcIjpcIlxcdTIyNDhcIixcbiAgXCJ0aGtzaW1cIjpcIlxcdTIyM0NcIixcbiAgXCJUSE9STlwiOlwiXFx1MDBERVwiLFxuICBcInRob3JuXCI6XCJcXHUwMEZFXCIsXG4gIFwiVGlsZGVcIjpcIlxcdTIyM0NcIixcbiAgXCJ0aWxkZVwiOlwiXFx1MDJEQ1wiLFxuICBcIlRpbGRlRXF1YWxcIjpcIlxcdTIyNDNcIixcbiAgXCJUaWxkZUZ1bGxFcXVhbFwiOlwiXFx1MjI0NVwiLFxuICBcIlRpbGRlVGlsZGVcIjpcIlxcdTIyNDhcIixcbiAgXCJ0aW1lc1wiOlwiXFx1MDBEN1wiLFxuICBcInRpbWVzYlwiOlwiXFx1MjJBMFwiLFxuICBcInRpbWVzYmFyXCI6XCJcXHUyQTMxXCIsXG4gIFwidGltZXNkXCI6XCJcXHUyQTMwXCIsXG4gIFwidGludFwiOlwiXFx1MjIyRFwiLFxuICBcInRvZWFcIjpcIlxcdTI5MjhcIixcbiAgXCJ0b3BcIjpcIlxcdTIyQTRcIixcbiAgXCJ0b3Bib3RcIjpcIlxcdTIzMzZcIixcbiAgXCJ0b3BjaXJcIjpcIlxcdTJBRjFcIixcbiAgXCJUb3BmXCI6XCJcXHVEODM1XFx1REQ0QlwiLFxuICBcInRvcGZcIjpcIlxcdUQ4MzVcXHVERDY1XCIsXG4gIFwidG9wZm9ya1wiOlwiXFx1MkFEQVwiLFxuICBcInRvc2FcIjpcIlxcdTI5MjlcIixcbiAgXCJ0cHJpbWVcIjpcIlxcdTIwMzRcIixcbiAgXCJUUkFERVwiOlwiXFx1MjEyMlwiLFxuICBcInRyYWRlXCI6XCJcXHUyMTIyXCIsXG4gIFwidHJpYW5nbGVcIjpcIlxcdTI1QjVcIixcbiAgXCJ0cmlhbmdsZWRvd25cIjpcIlxcdTI1QkZcIixcbiAgXCJ0cmlhbmdsZWxlZnRcIjpcIlxcdTI1QzNcIixcbiAgXCJ0cmlhbmdsZWxlZnRlcVwiOlwiXFx1MjJCNFwiLFxuICBcInRyaWFuZ2xlcVwiOlwiXFx1MjI1Q1wiLFxuICBcInRyaWFuZ2xlcmlnaHRcIjpcIlxcdTI1QjlcIixcbiAgXCJ0cmlhbmdsZXJpZ2h0ZXFcIjpcIlxcdTIyQjVcIixcbiAgXCJ0cmlkb3RcIjpcIlxcdTI1RUNcIixcbiAgXCJ0cmllXCI6XCJcXHUyMjVDXCIsXG4gIFwidHJpbWludXNcIjpcIlxcdTJBM0FcIixcbiAgXCJUcmlwbGVEb3RcIjpcIlxcdTIwREJcIixcbiAgXCJ0cmlwbHVzXCI6XCJcXHUyQTM5XCIsXG4gIFwidHJpc2JcIjpcIlxcdTI5Q0RcIixcbiAgXCJ0cml0aW1lXCI6XCJcXHUyQTNCXCIsXG4gIFwidHJwZXppdW1cIjpcIlxcdTIzRTJcIixcbiAgXCJUc2NyXCI6XCJcXHVEODM1XFx1RENBRlwiLFxuICBcInRzY3JcIjpcIlxcdUQ4MzVcXHVEQ0M5XCIsXG4gIFwiVFNjeVwiOlwiXFx1MDQyNlwiLFxuICBcInRzY3lcIjpcIlxcdTA0NDZcIixcbiAgXCJUU0hjeVwiOlwiXFx1MDQwQlwiLFxuICBcInRzaGN5XCI6XCJcXHUwNDVCXCIsXG4gIFwiVHN0cm9rXCI6XCJcXHUwMTY2XCIsXG4gIFwidHN0cm9rXCI6XCJcXHUwMTY3XCIsXG4gIFwidHdpeHRcIjpcIlxcdTIyNkNcIixcbiAgXCJ0d29oZWFkbGVmdGFycm93XCI6XCJcXHUyMTlFXCIsXG4gIFwidHdvaGVhZHJpZ2h0YXJyb3dcIjpcIlxcdTIxQTBcIixcbiAgXCJVYWN1dGVcIjpcIlxcdTAwREFcIixcbiAgXCJ1YWN1dGVcIjpcIlxcdTAwRkFcIixcbiAgXCJVYXJyXCI6XCJcXHUyMTlGXCIsXG4gIFwidUFyclwiOlwiXFx1MjFEMVwiLFxuICBcInVhcnJcIjpcIlxcdTIxOTFcIixcbiAgXCJVYXJyb2NpclwiOlwiXFx1Mjk0OVwiLFxuICBcIlVicmN5XCI6XCJcXHUwNDBFXCIsXG4gIFwidWJyY3lcIjpcIlxcdTA0NUVcIixcbiAgXCJVYnJldmVcIjpcIlxcdTAxNkNcIixcbiAgXCJ1YnJldmVcIjpcIlxcdTAxNkRcIixcbiAgXCJVY2lyY1wiOlwiXFx1MDBEQlwiLFxuICBcInVjaXJjXCI6XCJcXHUwMEZCXCIsXG4gIFwiVWN5XCI6XCJcXHUwNDIzXCIsXG4gIFwidWN5XCI6XCJcXHUwNDQzXCIsXG4gIFwidWRhcnJcIjpcIlxcdTIxQzVcIixcbiAgXCJVZGJsYWNcIjpcIlxcdTAxNzBcIixcbiAgXCJ1ZGJsYWNcIjpcIlxcdTAxNzFcIixcbiAgXCJ1ZGhhclwiOlwiXFx1Mjk2RVwiLFxuICBcInVmaXNodFwiOlwiXFx1Mjk3RVwiLFxuICBcIlVmclwiOlwiXFx1RDgzNVxcdUREMThcIixcbiAgXCJ1ZnJcIjpcIlxcdUQ4MzVcXHVERDMyXCIsXG4gIFwiVWdyYXZlXCI6XCJcXHUwMEQ5XCIsXG4gIFwidWdyYXZlXCI6XCJcXHUwMEY5XCIsXG4gIFwidUhhclwiOlwiXFx1Mjk2M1wiLFxuICBcInVoYXJsXCI6XCJcXHUyMUJGXCIsXG4gIFwidWhhcnJcIjpcIlxcdTIxQkVcIixcbiAgXCJ1aGJsa1wiOlwiXFx1MjU4MFwiLFxuICBcInVsY29yblwiOlwiXFx1MjMxQ1wiLFxuICBcInVsY29ybmVyXCI6XCJcXHUyMzFDXCIsXG4gIFwidWxjcm9wXCI6XCJcXHUyMzBGXCIsXG4gIFwidWx0cmlcIjpcIlxcdTI1RjhcIixcbiAgXCJVbWFjclwiOlwiXFx1MDE2QVwiLFxuICBcInVtYWNyXCI6XCJcXHUwMTZCXCIsXG4gIFwidW1sXCI6XCJcXHUwMEE4XCIsXG4gIFwiVW5kZXJCYXJcIjpcIlxcdTAwNUZcIixcbiAgXCJVbmRlckJyYWNlXCI6XCJcXHUyM0RGXCIsXG4gIFwiVW5kZXJCcmFja2V0XCI6XCJcXHUyM0I1XCIsXG4gIFwiVW5kZXJQYXJlbnRoZXNpc1wiOlwiXFx1MjNERFwiLFxuICBcIlVuaW9uXCI6XCJcXHUyMkMzXCIsXG4gIFwiVW5pb25QbHVzXCI6XCJcXHUyMjhFXCIsXG4gIFwiVW9nb25cIjpcIlxcdTAxNzJcIixcbiAgXCJ1b2dvblwiOlwiXFx1MDE3M1wiLFxuICBcIlVvcGZcIjpcIlxcdUQ4MzVcXHVERDRDXCIsXG4gIFwidW9wZlwiOlwiXFx1RDgzNVxcdURENjZcIixcbiAgXCJVcEFycm93XCI6XCJcXHUyMTkxXCIsXG4gIFwiVXBhcnJvd1wiOlwiXFx1MjFEMVwiLFxuICBcInVwYXJyb3dcIjpcIlxcdTIxOTFcIixcbiAgXCJVcEFycm93QmFyXCI6XCJcXHUyOTEyXCIsXG4gIFwiVXBBcnJvd0Rvd25BcnJvd1wiOlwiXFx1MjFDNVwiLFxuICBcIlVwRG93bkFycm93XCI6XCJcXHUyMTk1XCIsXG4gIFwiVXBkb3duYXJyb3dcIjpcIlxcdTIxRDVcIixcbiAgXCJ1cGRvd25hcnJvd1wiOlwiXFx1MjE5NVwiLFxuICBcIlVwRXF1aWxpYnJpdW1cIjpcIlxcdTI5NkVcIixcbiAgXCJ1cGhhcnBvb25sZWZ0XCI6XCJcXHUyMUJGXCIsXG4gIFwidXBoYXJwb29ucmlnaHRcIjpcIlxcdTIxQkVcIixcbiAgXCJ1cGx1c1wiOlwiXFx1MjI4RVwiLFxuICBcIlVwcGVyTGVmdEFycm93XCI6XCJcXHUyMTk2XCIsXG4gIFwiVXBwZXJSaWdodEFycm93XCI6XCJcXHUyMTk3XCIsXG4gIFwiVXBzaVwiOlwiXFx1MDNEMlwiLFxuICBcInVwc2lcIjpcIlxcdTAzQzVcIixcbiAgXCJ1cHNpaFwiOlwiXFx1MDNEMlwiLFxuICBcIlVwc2lsb25cIjpcIlxcdTAzQTVcIixcbiAgXCJ1cHNpbG9uXCI6XCJcXHUwM0M1XCIsXG4gIFwiVXBUZWVcIjpcIlxcdTIyQTVcIixcbiAgXCJVcFRlZUFycm93XCI6XCJcXHUyMUE1XCIsXG4gIFwidXB1cGFycm93c1wiOlwiXFx1MjFDOFwiLFxuICBcInVyY29yblwiOlwiXFx1MjMxRFwiLFxuICBcInVyY29ybmVyXCI6XCJcXHUyMzFEXCIsXG4gIFwidXJjcm9wXCI6XCJcXHUyMzBFXCIsXG4gIFwiVXJpbmdcIjpcIlxcdTAxNkVcIixcbiAgXCJ1cmluZ1wiOlwiXFx1MDE2RlwiLFxuICBcInVydHJpXCI6XCJcXHUyNUY5XCIsXG4gIFwiVXNjclwiOlwiXFx1RDgzNVxcdURDQjBcIixcbiAgXCJ1c2NyXCI6XCJcXHVEODM1XFx1RENDQVwiLFxuICBcInV0ZG90XCI6XCJcXHUyMkYwXCIsXG4gIFwiVXRpbGRlXCI6XCJcXHUwMTY4XCIsXG4gIFwidXRpbGRlXCI6XCJcXHUwMTY5XCIsXG4gIFwidXRyaVwiOlwiXFx1MjVCNVwiLFxuICBcInV0cmlmXCI6XCJcXHUyNUI0XCIsXG4gIFwidXVhcnJcIjpcIlxcdTIxQzhcIixcbiAgXCJVdW1sXCI6XCJcXHUwMERDXCIsXG4gIFwidXVtbFwiOlwiXFx1MDBGQ1wiLFxuICBcInV3YW5nbGVcIjpcIlxcdTI5QTdcIixcbiAgXCJ2YW5ncnRcIjpcIlxcdTI5OUNcIixcbiAgXCJ2YXJlcHNpbG9uXCI6XCJcXHUwM0Y1XCIsXG4gIFwidmFya2FwcGFcIjpcIlxcdTAzRjBcIixcbiAgXCJ2YXJub3RoaW5nXCI6XCJcXHUyMjA1XCIsXG4gIFwidmFycGhpXCI6XCJcXHUwM0Q1XCIsXG4gIFwidmFycGlcIjpcIlxcdTAzRDZcIixcbiAgXCJ2YXJwcm9wdG9cIjpcIlxcdTIyMURcIixcbiAgXCJ2QXJyXCI6XCJcXHUyMUQ1XCIsXG4gIFwidmFyclwiOlwiXFx1MjE5NVwiLFxuICBcInZhcnJob1wiOlwiXFx1MDNGMVwiLFxuICBcInZhcnNpZ21hXCI6XCJcXHUwM0MyXCIsXG4gIFwidmFyc3Vic2V0bmVxXCI6XCJcXHUyMjhBXFx1RkUwMFwiLFxuICBcInZhcnN1YnNldG5lcXFcIjpcIlxcdTJBQ0JcXHVGRTAwXCIsXG4gIFwidmFyc3Vwc2V0bmVxXCI6XCJcXHUyMjhCXFx1RkUwMFwiLFxuICBcInZhcnN1cHNldG5lcXFcIjpcIlxcdTJBQ0NcXHVGRTAwXCIsXG4gIFwidmFydGhldGFcIjpcIlxcdTAzRDFcIixcbiAgXCJ2YXJ0cmlhbmdsZWxlZnRcIjpcIlxcdTIyQjJcIixcbiAgXCJ2YXJ0cmlhbmdsZXJpZ2h0XCI6XCJcXHUyMkIzXCIsXG4gIFwiVmJhclwiOlwiXFx1MkFFQlwiLFxuICBcInZCYXJcIjpcIlxcdTJBRThcIixcbiAgXCJ2QmFydlwiOlwiXFx1MkFFOVwiLFxuICBcIlZjeVwiOlwiXFx1MDQxMlwiLFxuICBcInZjeVwiOlwiXFx1MDQzMlwiLFxuICBcIlZEYXNoXCI6XCJcXHUyMkFCXCIsXG4gIFwiVmRhc2hcIjpcIlxcdTIyQTlcIixcbiAgXCJ2RGFzaFwiOlwiXFx1MjJBOFwiLFxuICBcInZkYXNoXCI6XCJcXHUyMkEyXCIsXG4gIFwiVmRhc2hsXCI6XCJcXHUyQUU2XCIsXG4gIFwiVmVlXCI6XCJcXHUyMkMxXCIsXG4gIFwidmVlXCI6XCJcXHUyMjI4XCIsXG4gIFwidmVlYmFyXCI6XCJcXHUyMkJCXCIsXG4gIFwidmVlZXFcIjpcIlxcdTIyNUFcIixcbiAgXCJ2ZWxsaXBcIjpcIlxcdTIyRUVcIixcbiAgXCJWZXJiYXJcIjpcIlxcdTIwMTZcIixcbiAgXCJ2ZXJiYXJcIjpcIlxcdTAwN0NcIixcbiAgXCJWZXJ0XCI6XCJcXHUyMDE2XCIsXG4gIFwidmVydFwiOlwiXFx1MDA3Q1wiLFxuICBcIlZlcnRpY2FsQmFyXCI6XCJcXHUyMjIzXCIsXG4gIFwiVmVydGljYWxMaW5lXCI6XCJcXHUwMDdDXCIsXG4gIFwiVmVydGljYWxTZXBhcmF0b3JcIjpcIlxcdTI3NThcIixcbiAgXCJWZXJ0aWNhbFRpbGRlXCI6XCJcXHUyMjQwXCIsXG4gIFwiVmVyeVRoaW5TcGFjZVwiOlwiXFx1MjAwQVwiLFxuICBcIlZmclwiOlwiXFx1RDgzNVxcdUREMTlcIixcbiAgXCJ2ZnJcIjpcIlxcdUQ4MzVcXHVERDMzXCIsXG4gIFwidmx0cmlcIjpcIlxcdTIyQjJcIixcbiAgXCJ2bnN1YlwiOlwiXFx1MjI4MlxcdTIwRDJcIixcbiAgXCJ2bnN1cFwiOlwiXFx1MjI4M1xcdTIwRDJcIixcbiAgXCJWb3BmXCI6XCJcXHVEODM1XFx1REQ0RFwiLFxuICBcInZvcGZcIjpcIlxcdUQ4MzVcXHVERDY3XCIsXG4gIFwidnByb3BcIjpcIlxcdTIyMURcIixcbiAgXCJ2cnRyaVwiOlwiXFx1MjJCM1wiLFxuICBcIlZzY3JcIjpcIlxcdUQ4MzVcXHVEQ0IxXCIsXG4gIFwidnNjclwiOlwiXFx1RDgzNVxcdURDQ0JcIixcbiAgXCJ2c3VibkVcIjpcIlxcdTJBQ0JcXHVGRTAwXCIsXG4gIFwidnN1Ym5lXCI6XCJcXHUyMjhBXFx1RkUwMFwiLFxuICBcInZzdXBuRVwiOlwiXFx1MkFDQ1xcdUZFMDBcIixcbiAgXCJ2c3VwbmVcIjpcIlxcdTIyOEJcXHVGRTAwXCIsXG4gIFwiVnZkYXNoXCI6XCJcXHUyMkFBXCIsXG4gIFwidnppZ3phZ1wiOlwiXFx1Mjk5QVwiLFxuICBcIldjaXJjXCI6XCJcXHUwMTc0XCIsXG4gIFwid2NpcmNcIjpcIlxcdTAxNzVcIixcbiAgXCJ3ZWRiYXJcIjpcIlxcdTJBNUZcIixcbiAgXCJXZWRnZVwiOlwiXFx1MjJDMFwiLFxuICBcIndlZGdlXCI6XCJcXHUyMjI3XCIsXG4gIFwid2VkZ2VxXCI6XCJcXHUyMjU5XCIsXG4gIFwid2VpZXJwXCI6XCJcXHUyMTE4XCIsXG4gIFwiV2ZyXCI6XCJcXHVEODM1XFx1REQxQVwiLFxuICBcIndmclwiOlwiXFx1RDgzNVxcdUREMzRcIixcbiAgXCJXb3BmXCI6XCJcXHVEODM1XFx1REQ0RVwiLFxuICBcIndvcGZcIjpcIlxcdUQ4MzVcXHVERDY4XCIsXG4gIFwid3BcIjpcIlxcdTIxMThcIixcbiAgXCJ3clwiOlwiXFx1MjI0MFwiLFxuICBcIndyZWF0aFwiOlwiXFx1MjI0MFwiLFxuICBcIldzY3JcIjpcIlxcdUQ4MzVcXHVEQ0IyXCIsXG4gIFwid3NjclwiOlwiXFx1RDgzNVxcdURDQ0NcIixcbiAgXCJ4Y2FwXCI6XCJcXHUyMkMyXCIsXG4gIFwieGNpcmNcIjpcIlxcdTI1RUZcIixcbiAgXCJ4Y3VwXCI6XCJcXHUyMkMzXCIsXG4gIFwieGR0cmlcIjpcIlxcdTI1QkRcIixcbiAgXCJYZnJcIjpcIlxcdUQ4MzVcXHVERDFCXCIsXG4gIFwieGZyXCI6XCJcXHVEODM1XFx1REQzNVwiLFxuICBcInhoQXJyXCI6XCJcXHUyN0ZBXCIsXG4gIFwieGhhcnJcIjpcIlxcdTI3RjdcIixcbiAgXCJYaVwiOlwiXFx1MDM5RVwiLFxuICBcInhpXCI6XCJcXHUwM0JFXCIsXG4gIFwieGxBcnJcIjpcIlxcdTI3RjhcIixcbiAgXCJ4bGFyclwiOlwiXFx1MjdGNVwiLFxuICBcInhtYXBcIjpcIlxcdTI3RkNcIixcbiAgXCJ4bmlzXCI6XCJcXHUyMkZCXCIsXG4gIFwieG9kb3RcIjpcIlxcdTJBMDBcIixcbiAgXCJYb3BmXCI6XCJcXHVEODM1XFx1REQ0RlwiLFxuICBcInhvcGZcIjpcIlxcdUQ4MzVcXHVERDY5XCIsXG4gIFwieG9wbHVzXCI6XCJcXHUyQTAxXCIsXG4gIFwieG90aW1lXCI6XCJcXHUyQTAyXCIsXG4gIFwieHJBcnJcIjpcIlxcdTI3RjlcIixcbiAgXCJ4cmFyclwiOlwiXFx1MjdGNlwiLFxuICBcIlhzY3JcIjpcIlxcdUQ4MzVcXHVEQ0IzXCIsXG4gIFwieHNjclwiOlwiXFx1RDgzNVxcdURDQ0RcIixcbiAgXCJ4c3FjdXBcIjpcIlxcdTJBMDZcIixcbiAgXCJ4dXBsdXNcIjpcIlxcdTJBMDRcIixcbiAgXCJ4dXRyaVwiOlwiXFx1MjVCM1wiLFxuICBcInh2ZWVcIjpcIlxcdTIyQzFcIixcbiAgXCJ4d2VkZ2VcIjpcIlxcdTIyQzBcIixcbiAgXCJZYWN1dGVcIjpcIlxcdTAwRERcIixcbiAgXCJ5YWN1dGVcIjpcIlxcdTAwRkRcIixcbiAgXCJZQWN5XCI6XCJcXHUwNDJGXCIsXG4gIFwieWFjeVwiOlwiXFx1MDQ0RlwiLFxuICBcIlljaXJjXCI6XCJcXHUwMTc2XCIsXG4gIFwieWNpcmNcIjpcIlxcdTAxNzdcIixcbiAgXCJZY3lcIjpcIlxcdTA0MkJcIixcbiAgXCJ5Y3lcIjpcIlxcdTA0NEJcIixcbiAgXCJ5ZW5cIjpcIlxcdTAwQTVcIixcbiAgXCJZZnJcIjpcIlxcdUQ4MzVcXHVERDFDXCIsXG4gIFwieWZyXCI6XCJcXHVEODM1XFx1REQzNlwiLFxuICBcIllJY3lcIjpcIlxcdTA0MDdcIixcbiAgXCJ5aWN5XCI6XCJcXHUwNDU3XCIsXG4gIFwiWW9wZlwiOlwiXFx1RDgzNVxcdURENTBcIixcbiAgXCJ5b3BmXCI6XCJcXHVEODM1XFx1REQ2QVwiLFxuICBcIllzY3JcIjpcIlxcdUQ4MzVcXHVEQ0I0XCIsXG4gIFwieXNjclwiOlwiXFx1RDgzNVxcdURDQ0VcIixcbiAgXCJZVWN5XCI6XCJcXHUwNDJFXCIsXG4gIFwieXVjeVwiOlwiXFx1MDQ0RVwiLFxuICBcIll1bWxcIjpcIlxcdTAxNzhcIixcbiAgXCJ5dW1sXCI6XCJcXHUwMEZGXCIsXG4gIFwiWmFjdXRlXCI6XCJcXHUwMTc5XCIsXG4gIFwiemFjdXRlXCI6XCJcXHUwMTdBXCIsXG4gIFwiWmNhcm9uXCI6XCJcXHUwMTdEXCIsXG4gIFwiemNhcm9uXCI6XCJcXHUwMTdFXCIsXG4gIFwiWmN5XCI6XCJcXHUwNDE3XCIsXG4gIFwiemN5XCI6XCJcXHUwNDM3XCIsXG4gIFwiWmRvdFwiOlwiXFx1MDE3QlwiLFxuICBcInpkb3RcIjpcIlxcdTAxN0NcIixcbiAgXCJ6ZWV0cmZcIjpcIlxcdTIxMjhcIixcbiAgXCJaZXJvV2lkdGhTcGFjZVwiOlwiXFx1MjAwQlwiLFxuICBcIlpldGFcIjpcIlxcdTAzOTZcIixcbiAgXCJ6ZXRhXCI6XCJcXHUwM0I2XCIsXG4gIFwiWmZyXCI6XCJcXHUyMTI4XCIsXG4gIFwiemZyXCI6XCJcXHVEODM1XFx1REQzN1wiLFxuICBcIlpIY3lcIjpcIlxcdTA0MTZcIixcbiAgXCJ6aGN5XCI6XCJcXHUwNDM2XCIsXG4gIFwiemlncmFyclwiOlwiXFx1MjFERFwiLFxuICBcIlpvcGZcIjpcIlxcdTIxMjRcIixcbiAgXCJ6b3BmXCI6XCJcXHVEODM1XFx1REQ2QlwiLFxuICBcIlpzY3JcIjpcIlxcdUQ4MzVcXHVEQ0I1XCIsXG4gIFwienNjclwiOlwiXFx1RDgzNVxcdURDQ0ZcIixcbiAgXCJ6d2pcIjpcIlxcdTIwMERcIixcbiAgXCJ6d25qXCI6XCJcXHUyMDBDXCJcbn07XG4iLCIvLyBMaXN0IG9mIHZhbGlkIGh0bWwgYmxvY2tzIG5hbWVzLCBhY2NvcnRpbmcgdG8gY29tbW9ubWFyayBzcGVjXG4vLyBodHRwOi8vamdtLmdpdGh1Yi5pby9Db21tb25NYXJrL3NwZWMuaHRtbCNodG1sLWJsb2Nrc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBodG1sX2Jsb2NrcyA9IHt9O1xuXG5bXG4gICdhcnRpY2xlJyxcbiAgJ2FzaWRlJyxcbiAgJ2J1dHRvbicsXG4gICdibG9ja3F1b3RlJyxcbiAgJ2JvZHknLFxuICAnY2FudmFzJyxcbiAgJ2NhcHRpb24nLFxuICAnY29sJyxcbiAgJ2NvbGdyb3VwJyxcbiAgJ2RkJyxcbiAgJ2RpdicsXG4gICdkbCcsXG4gICdkdCcsXG4gICdlbWJlZCcsXG4gICdmaWVsZHNldCcsXG4gICdmaWdjYXB0aW9uJyxcbiAgJ2ZpZ3VyZScsXG4gICdmb290ZXInLFxuICAnZm9ybScsXG4gICdoMScsXG4gICdoMicsXG4gICdoMycsXG4gICdoNCcsXG4gICdoNScsXG4gICdoNicsXG4gICdoZWFkZXInLFxuICAnaGdyb3VwJyxcbiAgJ2hyJyxcbiAgJ2lmcmFtZScsXG4gICdsaScsXG4gICdtYXAnLFxuICAnb2JqZWN0JyxcbiAgJ29sJyxcbiAgJ291dHB1dCcsXG4gICdwJyxcbiAgJ3ByZScsXG4gICdwcm9ncmVzcycsXG4gICdzY3JpcHQnLFxuICAnc2VjdGlvbicsXG4gICdzdHlsZScsXG4gICd0YWJsZScsXG4gICd0Ym9keScsXG4gICd0ZCcsXG4gICd0ZXh0YXJlYScsXG4gICd0Zm9vdCcsXG4gICd0aCcsXG4gICd0cicsXG4gICd0aGVhZCcsXG4gICd1bCcsXG4gICd2aWRlbydcbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyBodG1sX2Jsb2Nrc1tuYW1lXSA9IHRydWU7IH0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaHRtbF9ibG9ja3M7XG4iLCIvLyBSZWdleHBzIHRvIG1hdGNoIGh0bWwgZWxlbWVudHNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIHJlcGxhY2UocmVnZXgsIG9wdGlvbnMpIHtcbiAgcmVnZXggPSByZWdleC5zb3VyY2U7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8ICcnO1xuXG4gIHJldHVybiBmdW5jdGlvbiBzZWxmKG5hbWUsIHZhbCkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB2YWwgPSB2YWwuc291cmNlIHx8IHZhbDtcbiAgICByZWdleCA9IHJlZ2V4LnJlcGxhY2UobmFtZSwgdmFsKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcbn1cblxuXG52YXIgYXR0cl9uYW1lICAgICA9IC9bYS16QS1aXzpdW2EtekEtWjAtOTouXy1dKi87XG5cbnZhciB1bnF1b3RlZCAgICAgID0gL1teXCInPTw+YFxceDAwLVxceDIwXSsvO1xudmFyIHNpbmdsZV9xdW90ZWQgPSAvJ1teJ10qJy87XG52YXIgZG91YmxlX3F1b3RlZCA9IC9cIlteXCJdKlwiLztcblxuLyplc2xpbnQgbm8tc3BhY2VkLWZ1bmM6MCovXG52YXIgYXR0cl92YWx1ZSAgPSByZXBsYWNlKC8oPzp1bnF1b3RlZHxzaW5nbGVfcXVvdGVkfGRvdWJsZV9xdW90ZWQpLylcbiAgICAgICAgICAgICAgICAgICAgKCd1bnF1b3RlZCcsIHVucXVvdGVkKVxuICAgICAgICAgICAgICAgICAgICAoJ3NpbmdsZV9xdW90ZWQnLCBzaW5nbGVfcXVvdGVkKVxuICAgICAgICAgICAgICAgICAgICAoJ2RvdWJsZV9xdW90ZWQnLCBkb3VibGVfcXVvdGVkKVxuICAgICAgICAgICAgICAgICAgICAoKTtcblxudmFyIGF0dHJpYnV0ZSAgID0gcmVwbGFjZSgvKD86XFxzK2F0dHJfbmFtZSg/Olxccyo9XFxzKmF0dHJfdmFsdWUpPykvKVxuICAgICAgICAgICAgICAgICAgICAoJ2F0dHJfbmFtZScsIGF0dHJfbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgKCdhdHRyX3ZhbHVlJywgYXR0cl92YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgKCk7XG5cbnZhciBvcGVuX3RhZyAgICA9IHJlcGxhY2UoLzxbQS1aYS16XVtBLVphLXowLTldKmF0dHJpYnV0ZSpcXHMqXFwvPz4vKVxuICAgICAgICAgICAgICAgICAgICAoJ2F0dHJpYnV0ZScsIGF0dHJpYnV0ZSlcbiAgICAgICAgICAgICAgICAgICAgKCk7XG5cbnZhciBjbG9zZV90YWcgICA9IC88XFwvW0EtWmEtel1bQS1aYS16MC05XSpcXHMqPi87XG52YXIgY29tbWVudCAgICAgPSAvPCEtLShbXi1dK3xbLV1bXi1dKykqLS0+LztcbnZhciBwcm9jZXNzaW5nICA9IC88Wz9dLio/Wz9dPi87XG52YXIgZGVjbGFyYXRpb24gPSAvPCFbQS1aXStcXHMrW14+XSo+LztcbnZhciBjZGF0YSAgICAgICA9IC88IVxcW0NEQVRBXFxbKFteXFxdXSt8XFxdW15cXF1dfFxcXVxcXVtePl0pKlxcXVxcXT4vO1xuXG52YXIgSFRNTF9UQUdfUkUgPSByZXBsYWNlKC9eKD86b3Blbl90YWd8Y2xvc2VfdGFnfGNvbW1lbnR8cHJvY2Vzc2luZ3xkZWNsYXJhdGlvbnxjZGF0YSkvKVxuICAoJ29wZW5fdGFnJywgb3Blbl90YWcpXG4gICgnY2xvc2VfdGFnJywgY2xvc2VfdGFnKVxuICAoJ2NvbW1lbnQnLCBjb21tZW50KVxuICAoJ3Byb2Nlc3NpbmcnLCBwcm9jZXNzaW5nKVxuICAoJ2RlY2xhcmF0aW9uJywgZGVjbGFyYXRpb24pXG4gICgnY2RhdGEnLCBjZGF0YSlcbiAgKCk7XG5cblxubW9kdWxlLmV4cG9ydHMuSFRNTF9UQUdfUkUgPSBIVE1MX1RBR19SRTtcbiIsIi8vIExpc3Qgb2YgdmFsaWQgdXJsIHNjaGVtYXMsIGFjY29ydGluZyB0byBjb21tb25tYXJrIHNwZWNcbi8vIGh0dHA6Ly9qZ20uZ2l0aHViLmlvL0NvbW1vbk1hcmsvc3BlYy5odG1sI2F1dG9saW5rc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdjb2FwJyxcbiAgJ2RvaScsXG4gICdqYXZhc2NyaXB0JyxcbiAgJ2FhYScsXG4gICdhYWFzJyxcbiAgJ2Fib3V0JyxcbiAgJ2FjYXAnLFxuICAnY2FwJyxcbiAgJ2NpZCcsXG4gICdjcmlkJyxcbiAgJ2RhdGEnLFxuICAnZGF2JyxcbiAgJ2RpY3QnLFxuICAnZG5zJyxcbiAgJ2ZpbGUnLFxuICAnZnRwJyxcbiAgJ2dlbycsXG4gICdnbycsXG4gICdnb3BoZXInLFxuICAnaDMyMycsXG4gICdodHRwJyxcbiAgJ2h0dHBzJyxcbiAgJ2lheCcsXG4gICdpY2FwJyxcbiAgJ2ltJyxcbiAgJ2ltYXAnLFxuICAnaW5mbycsXG4gICdpcHAnLFxuICAnaXJpcycsXG4gICdpcmlzLmJlZXAnLFxuICAnaXJpcy54cGMnLFxuICAnaXJpcy54cGNzJyxcbiAgJ2lyaXMubHd6JyxcbiAgJ2xkYXAnLFxuICAnbWFpbHRvJyxcbiAgJ21pZCcsXG4gICdtc3JwJyxcbiAgJ21zcnBzJyxcbiAgJ210cXAnLFxuICAnbXVwZGF0ZScsXG4gICduZXdzJyxcbiAgJ25mcycsXG4gICduaScsXG4gICduaWgnLFxuICAnbm50cCcsXG4gICdvcGFxdWVsb2NrdG9rZW4nLFxuICAncG9wJyxcbiAgJ3ByZXMnLFxuICAncnRzcCcsXG4gICdzZXJ2aWNlJyxcbiAgJ3Nlc3Npb24nLFxuICAnc2h0dHAnLFxuICAnc2lldmUnLFxuICAnc2lwJyxcbiAgJ3NpcHMnLFxuICAnc21zJyxcbiAgJ3NubXAnLFxuICAnc29hcC5iZWVwJyxcbiAgJ3NvYXAuYmVlcHMnLFxuICAndGFnJyxcbiAgJ3RlbCcsXG4gICd0ZWxuZXQnLFxuICAndGZ0cCcsXG4gICd0aGlzbWVzc2FnZScsXG4gICd0bjMyNzAnLFxuICAndGlwJyxcbiAgJ3R2JyxcbiAgJ3VybicsXG4gICd2ZW1taScsXG4gICd3cycsXG4gICd3c3MnLFxuICAneGNvbicsXG4gICd4Y29uLXVzZXJpZCcsXG4gICd4bWxycGMuYmVlcCcsXG4gICd4bWxycGMuYmVlcHMnLFxuICAneG1wcCcsXG4gICd6MzkuNTByJyxcbiAgJ3ozOS41MHMnLFxuICAnYWRpdW14dHJhJyxcbiAgJ2FmcCcsXG4gICdhZnMnLFxuICAnYWltJyxcbiAgJ2FwdCcsXG4gICdhdHRhY2htZW50JyxcbiAgJ2F3JyxcbiAgJ2Jlc2hhcmUnLFxuICAnYml0Y29pbicsXG4gICdib2xvJyxcbiAgJ2NhbGx0bycsXG4gICdjaHJvbWUnLFxuICAnY2hyb21lLWV4dGVuc2lvbicsXG4gICdjb20tZXZlbnRicml0ZS1hdHRlbmRlZScsXG4gICdjb250ZW50JyxcbiAgJ2N2cycsXG4gICdkbG5hLXBsYXlzaW5nbGUnLFxuICAnZGxuYS1wbGF5Y29udGFpbmVyJyxcbiAgJ2R0bicsXG4gICdkdmInLFxuICAnZWQyaycsXG4gICdmYWNldGltZScsXG4gICdmZWVkJyxcbiAgJ2ZpbmdlcicsXG4gICdmaXNoJyxcbiAgJ2dnJyxcbiAgJ2dpdCcsXG4gICdnaXptb3Byb2plY3QnLFxuICAnZ3RhbGsnLFxuICAnaGNwJyxcbiAgJ2ljb24nLFxuICAnaXBuJyxcbiAgJ2lyYycsXG4gICdpcmM2JyxcbiAgJ2lyY3MnLFxuICAnaXRtcycsXG4gICdqYXInLFxuICAnam1zJyxcbiAgJ2tleXBhcmMnLFxuICAnbGFzdGZtJyxcbiAgJ2xkYXBzJyxcbiAgJ21hZ25ldCcsXG4gICdtYXBzJyxcbiAgJ21hcmtldCcsXG4gICdtZXNzYWdlJyxcbiAgJ21tcycsXG4gICdtcy1oZWxwJyxcbiAgJ21zbmltJyxcbiAgJ211bWJsZScsXG4gICdtdm4nLFxuICAnbm90ZXMnLFxuICAnb2lkJyxcbiAgJ3BhbG0nLFxuICAncGFwYXJhenppJyxcbiAgJ3BsYXRmb3JtJyxcbiAgJ3Byb3h5JyxcbiAgJ3BzeWMnLFxuICAncXVlcnknLFxuICAncmVzJyxcbiAgJ3Jlc291cmNlJyxcbiAgJ3JtaScsXG4gICdyc3luYycsXG4gICdydG1wJyxcbiAgJ3NlY29uZGxpZmUnLFxuICAnc2Z0cCcsXG4gICdzZ24nLFxuICAnc2t5cGUnLFxuICAnc21iJyxcbiAgJ3NvbGRhdCcsXG4gICdzcG90aWZ5JyxcbiAgJ3NzaCcsXG4gICdzdGVhbScsXG4gICdzdm4nLFxuICAndGVhbXNwZWFrJyxcbiAgJ3RoaW5ncycsXG4gICd1ZHAnLFxuICAndW5yZWFsJyxcbiAgJ3V0MjAwNCcsXG4gICd2ZW50cmlsbycsXG4gICd2aWV3LXNvdXJjZScsXG4gICd3ZWJjYWwnLFxuICAnd3RhaScsXG4gICd3eWNpd3lnJyxcbiAgJ3hmaXJlJyxcbiAgJ3hyaScsXG4gICd5bXNncidcbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiB0eXBlT2Yob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gIHJldHVybiB0eXBlT2Yob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBoYXMob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdFxuICAgID8gaGFzT3duLmNhbGwob2JqZWN0LCBrZXkpXG4gICAgOiBmYWxzZTtcbn1cblxuLy8gRXh0ZW5kIG9iamVjdHNcbi8vXG5mdW5jdGlvbiBhc3NpZ24ob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkgeyByZXR1cm47IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIFVORVNDQVBFX01EX1JFID0gL1xcXFwoW1xcXFwhXCIjJCUmJygpKissLlxcLzo7PD0+P0BbXFxdXl9ge3x9fi1dKS9nO1xuXG5mdW5jdGlvbiB1bmVzY2FwZU1kKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuICByZXR1cm4gc3RyLnJlcGxhY2UoVU5FU0NBUEVfTURfUkUsICckMScpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRW50aXR5Q29kZShjKSB7XG4gIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXG4gIC8vIGJyb2tlbiBzZXF1ZW5jZVxuICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERGRkYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIC8vIG5ldmVyIHVzZWRcbiAgaWYgKGMgPj0gMHhGREQwICYmIGMgPD0gMHhGREVGKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoKGMgJiAweEZGRkYpID09PSAweEZGRkYgfHwgKGMgJiAweEZGRkYpID09PSAweEZGRkUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIC8vIGNvbnRyb2wgY29kZXNcbiAgaWYgKGMgPj0gMHgwMCAmJiBjIDw9IDB4MDgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID09PSAweDBCKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA+PSAweDBFICYmIGMgPD0gMHgxRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPj0gMHg3RiAmJiBjIDw9IDB4OUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIC8vIG91dCBvZiByYW5nZVxuICBpZiAoYyA+IDB4MTBGRkZGKSB7IHJldHVybiBmYWxzZTsgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZnJvbUNvZGVQb2ludChjKSB7XG4gIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXG4gIGlmIChjID4gMHhmZmZmKSB7XG4gICAgYyAtPSAweDEwMDAwO1xuICAgIHZhciBzdXJyb2dhdGUxID0gMHhkODAwICsgKGMgPj4gMTApLFxuICAgICAgICBzdXJyb2dhdGUyID0gMHhkYzAwICsgKGMgJiAweDNmZik7XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzdXJyb2dhdGUxLCBzdXJyb2dhdGUyKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbn1cblxudmFyIE5BTUVEX0VOVElUWV9SRSAgID0gLyYoW2EteiNdW2EtejAtOV17MSwzMX0pOy9naTtcbnZhciBESUdJVEFMX0VOVElUWV9URVNUX1JFID0gL14jKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKS9pO1xudmFyIGVudGl0aWVzID0gcmVxdWlyZSgnLi9lbnRpdGllcycpO1xuXG5mdW5jdGlvbiByZXBsYWNlRW50aXR5UGF0dGVybihtYXRjaCwgbmFtZSkge1xuICB2YXIgY29kZSA9IDA7XG5cbiAgaWYgKGhhcyhlbnRpdGllcywgbmFtZSkpIHtcbiAgICByZXR1cm4gZW50aXRpZXNbbmFtZV07XG4gIH0gZWxzZSBpZiAobmFtZS5jaGFyQ29kZUF0KDApID09PSAweDIzLyogIyAqLyAmJiBESUdJVEFMX0VOVElUWV9URVNUX1JFLnRlc3QobmFtZSkpIHtcbiAgICBjb2RlID0gbmFtZVsxXS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgcGFyc2VJbnQobmFtZS5zbGljZSgyKSwgMTYpXG4gICAgOlxuICAgICAgcGFyc2VJbnQobmFtZS5zbGljZSgxKSwgMTApO1xuICAgIGlmIChpc1ZhbGlkRW50aXR5Q29kZShjb2RlKSkge1xuICAgICAgcmV0dXJuIGZyb21Db2RlUG9pbnQoY29kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaDtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUVudGl0aWVzKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJyYnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShOQU1FRF9FTlRJVFlfUkUsIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIEhUTUxfRVNDQVBFX1RFU1RfUkUgPSAvWyY8PlwiXS87XG52YXIgSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSA9IC9bJjw+XCJdL2c7XG52YXIgSFRNTF9SRVBMQUNFTUVOVFMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7J1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZVVuc2FmZUNoYXIoY2gpIHtcbiAgcmV0dXJuIEhUTUxfUkVQTEFDRU1FTlRTW2NoXTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHIpIHtcbiAgaWYgKEhUTUxfRVNDQVBFX1RFU1RfUkUudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKEhUTUxfRVNDQVBFX1JFUExBQ0VfUkUsIHJlcGxhY2VVbnNhZmVDaGFyKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnRzLmFzc2lnbiAgICAgICAgICAgID0gYXNzaWduO1xuZXhwb3J0cy5pc1N0cmluZyAgICAgICAgICA9IGlzU3RyaW5nO1xuZXhwb3J0cy5oYXMgICAgICAgICAgICAgICA9IGhhcztcbmV4cG9ydHMudW5lc2NhcGVNZCAgICAgICAgPSB1bmVzY2FwZU1kO1xuZXhwb3J0cy5pc1ZhbGlkRW50aXR5Q29kZSA9IGlzVmFsaWRFbnRpdHlDb2RlO1xuZXhwb3J0cy5mcm9tQ29kZVBvaW50ICAgICA9IGZyb21Db2RlUG9pbnQ7XG5leHBvcnRzLnJlcGxhY2VFbnRpdGllcyAgID0gcmVwbGFjZUVudGl0aWVzO1xuZXhwb3J0cy5lc2NhcGVIdG1sICAgICAgICA9IGVzY2FwZUh0bWw7XG4iLCIvLyBDb21tb25tYXJrIGRlZmF1bHQgb3B0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIHRydWUsICAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIHRydWUsICAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcbiAgICBsaW5rVGFyZ2V0OiAgICcnLCAgICAgICAgICAgLy8gc2V0IHRhcmdldCB0byBvcGVuIGxpbmsgaW5cblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIFNldCBkb3VibGVzIHRvICfCq8K7JyBmb3IgUnVzc2lhbiwgJ+KAnuKAnCcgZm9yIEdlcm1hbi5cbiAgICBxdW90ZXM6ICfigJzigJ3igJjigJknLFxuXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxuICAgIC8vIG9yICcnIGlmIGlucHV0IG5vdCBjaGFuZ2VkXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMjAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnYmxvY2snLFxuICAgICAgICAnaW5saW5lJyxcbiAgICAgICAgJ3JlZmVyZW5jZXMnLFxuICAgICAgICAnYWJicjInXG4gICAgICBdXG4gICAgfSxcblxuICAgIGJsb2NrOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnYmxvY2txdW90ZScsXG4gICAgICAgICdjb2RlJyxcbiAgICAgICAgJ2ZlbmNlcycsXG4gICAgICAgICdoZWFkaW5nJyxcbiAgICAgICAgJ2hyJyxcbiAgICAgICAgJ2h0bWxibG9jaycsXG4gICAgICAgICdsaGVhZGluZycsXG4gICAgICAgICdsaXN0JyxcbiAgICAgICAgJ3BhcmFncmFwaCdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgaW5saW5lOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnYXV0b2xpbmsnLFxuICAgICAgICAnYmFja3RpY2tzJyxcbiAgICAgICAgJ2VtcGhhc2lzJyxcbiAgICAgICAgJ2VudGl0eScsXG4gICAgICAgICdlc2NhcGUnLFxuICAgICAgICAnaHRtbHRhZycsXG4gICAgICAgICdsaW5rcycsXG4gICAgICAgICduZXdsaW5lJyxcbiAgICAgICAgJ3RleHQnXG4gICAgICBdXG4gICAgfVxuICB9XG59O1xuIiwiLy8gUmVtYXJrYWJsZSBkZWZhdWx0IG9wdGlvbnNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICBmYWxzZSwgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICBmYWxzZSwgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG4gICAgbGlua1RhcmdldDogICAnJywgICAgICAgICAgIC8vIHNldCB0YXJnZXQgdG8gb3BlbiBsaW5rIGluXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBTZXQgZG91YmxlcyB0byAnwqvCuycgZm9yIFJ1c3NpYW4sICfigJ7igJwnIGZvciBHZXJtYW4uXG4gICAgcXVvdGVzOiAn4oCc4oCd4oCY4oCZJyxcblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiBpbnB1dCBub3QgY2hhbmdlZFxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XG4gICAgLy9cbiAgICBoaWdobGlnaHQ6IG51bGwsXG5cbiAgICBtYXhOZXN0aW5nOiAgIDIwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ2Jsb2NrJyxcbiAgICAgICAgJ2lubGluZScsXG4gICAgICAgICdyZWZlcmVuY2VzJyxcbiAgICAgICAgJ3JlcGxhY2VtZW50cycsXG4gICAgICAgICdsaW5raWZ5JyxcbiAgICAgICAgJ3NtYXJ0cXVvdGVzJyxcbiAgICAgICAgJ3JlZmVyZW5jZXMnLFxuICAgICAgICAnYWJicjInLFxuICAgICAgICAnZm9vdG5vdGVfdGFpbCdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgYmxvY2s6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdibG9ja3F1b3RlJyxcbiAgICAgICAgJ2NvZGUnLFxuICAgICAgICAnZmVuY2VzJyxcbiAgICAgICAgJ2Zvb3Rub3RlJyxcbiAgICAgICAgJ2hlYWRpbmcnLFxuICAgICAgICAnaHInLFxuICAgICAgICAnaHRtbGJsb2NrJyxcbiAgICAgICAgJ2xoZWFkaW5nJyxcbiAgICAgICAgJ2xpc3QnLFxuICAgICAgICAncGFyYWdyYXBoJyxcbiAgICAgICAgJ3RhYmxlJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBpbmxpbmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdhdXRvbGluaycsXG4gICAgICAgICdiYWNrdGlja3MnLFxuICAgICAgICAnZGVsJyxcbiAgICAgICAgJ2VtcGhhc2lzJyxcbiAgICAgICAgJ2VudGl0eScsXG4gICAgICAgICdlc2NhcGUnLFxuICAgICAgICAnZm9vdG5vdGVfcmVmJyxcbiAgICAgICAgJ2h0bWx0YWcnLFxuICAgICAgICAnbGlua3MnLFxuICAgICAgICAnbmV3bGluZScsXG4gICAgICAgICd0ZXh0J1xuICAgICAgXVxuICAgIH1cbiAgfVxufTtcbiIsIi8vIFJlbWFya2FibGUgZGVmYXVsdCBvcHRpb25zXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3B0aW9uczoge1xuICAgIGh0bWw6ICAgICAgICAgZmFsc2UsICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxuICAgIHhodG1sT3V0OiAgICAgZmFsc2UsICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuICAgIGxpbmtUYXJnZXQ6ICAgJycsICAgICAgICAgICAvLyBzZXQgdGFyZ2V0IHRvIG9wZW4gbGluayBpblxuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxuXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gU2V0IGRvdWJsZXMgdG8gJ8KrwrsnIGZvciBSdXNzaWFuLCAn4oCe4oCcJyBmb3IgR2VybWFuLlxuICAgIHF1b3RlczogICAgICAgJ+KAnOKAneKAmOKAmScsXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgaW5wdXQgbm90IGNoYW5nZWRcbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiAgICAgbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgIDIwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuICAgIC8vIERvbid0IHJlc3RyaWN0IGNvcmUvYmxvY2svaW5saW5lIHJ1bGVzXG4gICAgY29yZToge30sXG4gICAgYmxvY2s6IHt9LFxuICAgIGlubGluZToge31cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcGxhY2VFbnRpdGllcyA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLnJlcGxhY2VFbnRpdGllcztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVMaW5rKHVybCkge1xuICB2YXIgbm9ybWFsaXplZCA9IHJlcGxhY2VFbnRpdGllcyh1cmwpO1xuICAvLyBXZSBzaG91bGRuJ3QgY2FyZSBhYm91dCB0aGUgcmVzdWx0IG9mIG1hbGZvcm1lZCBVUklzLFxuICAvLyBhbmQgc2hvdWxkIG5vdCB0aHJvdyBhbiBleGNlcHRpb24uXG4gIHRyeSB7XG4gICAgbm9ybWFsaXplZCA9IGRlY29kZVVSSShub3JtYWxpemVkKTtcbiAgfSBjYXRjaCAoZXJyKSB7fVxuICByZXR1cm4gZW5jb2RlVVJJKG5vcm1hbGl6ZWQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVSZWZlcmVuY2Uoc3RyKSB7XG4gIC8vIHVzZSAudG9VcHBlckNhc2UoKSBpbnN0ZWFkIG9mIC50b0xvd2VyQ2FzZSgpXG4gIC8vIGhlcmUgdG8gYXZvaWQgYSBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGVcbiAgLy8gbWVtYmVycyAobW9zdCBub3RhYmx5LCBgX19wcm90b19fYClcbiAgcmV0dXJuIHN0ci50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRvVXBwZXJDYXNlKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBub3JtYWxpemVMaW5rID0gcmVxdWlyZSgnLi9ub3JtYWxpemVfbGluaycpO1xudmFyIHVuZXNjYXBlTWQgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZU1kO1xuXG4vKipcbiAqIFBhcnNlIGxpbmsgZGVzdGluYXRpb25cbiAqXG4gKiAgIC0gb24gc3VjY2VzcyBpdCByZXR1cm5zIGEgc3RyaW5nIGFuZCB1cGRhdGVzIHN0YXRlLnBvcztcbiAqICAgLSBvbiBmYWlsdXJlIGl0IHJldHVybnMgbnVsbFxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSAge051bWJlcn0gcG9zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLCBwb3MpIHtcbiAgdmFyIGNvZGUsIGxldmVsLCBsaW5rLFxuICAgICAgc3RhcnQgPSBwb3MsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4M0MgLyogPCAqLykge1xuICAgIHBvcysrO1xuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKGNvZGUgPT09IDB4MEEgLyogXFxuICovKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgaWYgKGNvZGUgPT09IDB4M0UgLyogPiAqLykge1xuICAgICAgICBsaW5rID0gbm9ybWFsaXplTGluayh1bmVzY2FwZU1kKHN0YXRlLnNyYy5zbGljZShzdGFydCArIDEsIHBvcykpKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5wYXJzZXIudmFsaWRhdGVMaW5rKGxpbmspKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBzdGF0ZS5wb3MgPSBwb3MgKyAxO1xuICAgICAgICBzdGF0ZS5saW5rQ29udGVudCA9IGxpbms7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHBvcysrO1xuICAgIH1cblxuICAgIC8vIG5vIGNsb3NpbmcgJz4nXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gdGhpcyBzaG91bGQgYmUgLi4uIH0gZWxzZSB7IC4uLiBicmFuY2hcblxuICBsZXZlbCA9IDA7XG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjb2RlID09PSAweDIwKSB7IGJyZWFrOyB9XG5cbiAgICBpZiAoY29kZSA+IDB4MDggJiYgY29kZSA8IDB4MGUpIHsgYnJlYWs7IH1cblxuICAgIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgIHBvcyArPSAyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4MjggLyogKCAqLykge1xuICAgICAgbGV2ZWwrKztcbiAgICAgIGlmIChsZXZlbCA+IDEpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyOSAvKiApICovKSB7XG4gICAgICBsZXZlbC0tO1xuICAgICAgaWYgKGxldmVsIDwgMCkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSBwb3MpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGluayA9IHVuZXNjYXBlTWQoc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MpKTtcbiAgaWYgKCFzdGF0ZS5wYXJzZXIudmFsaWRhdGVMaW5rKGxpbmspKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHN0YXRlLmxpbmtDb250ZW50ID0gbGluaztcbiAgc3RhdGUucG9zID0gcG9zO1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUGFyc2UgbGluayBsYWJlbHNcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBmaXJzdCBjaGFyYWN0ZXIgKGBbYCkgYWxyZWFkeSBtYXRjaGVzO1xuICogcmV0dXJucyB0aGUgZW5kIG9mIHRoZSBsYWJlbC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGFydCkge1xuICB2YXIgbGV2ZWwsIGZvdW5kLCBtYXJrZXIsXG4gICAgICBsYWJlbEVuZCA9IC0xLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zLFxuICAgICAgb2xkRmxhZyA9IHN0YXRlLmlzSW5MYWJlbDtcblxuICBpZiAoc3RhdGUuaXNJbkxhYmVsKSB7IHJldHVybiAtMTsgfVxuXG4gIGlmIChzdGF0ZS5sYWJlbFVubWF0Y2hlZFNjb3Blcykge1xuICAgIHN0YXRlLmxhYmVsVW5tYXRjaGVkU2NvcGVzLS07XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhcnQgKyAxO1xuICBzdGF0ZS5pc0luTGFiZWwgPSB0cnVlO1xuICBsZXZlbCA9IDE7XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyA8IG1heCkge1xuICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyk7XG4gICAgaWYgKG1hcmtlciA9PT0gMHg1QiAvKiBbICovKSB7XG4gICAgICBsZXZlbCsrO1xuICAgIH0gZWxzZSBpZiAobWFya2VyID09PSAweDVEIC8qIF0gKi8pIHtcbiAgICAgIGxldmVsLS07XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5wYXJzZXIuc2tpcFRva2VuKHN0YXRlKTtcbiAgfVxuXG4gIGlmIChmb3VuZCkge1xuICAgIGxhYmVsRW5kID0gc3RhdGUucG9zO1xuICAgIHN0YXRlLmxhYmVsVW5tYXRjaGVkU2NvcGVzID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sYWJlbFVubWF0Y2hlZFNjb3BlcyA9IGxldmVsIC0gMTtcbiAgfVxuXG4gIC8vIHJlc3RvcmUgb2xkIHN0YXRlXG4gIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgc3RhdGUuaXNJbkxhYmVsID0gb2xkRmxhZztcblxuICByZXR1cm4gbGFiZWxFbmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1bmVzY2FwZU1kID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVNZDtcblxuLyoqXG4gKiBQYXJzZSBsaW5rIHRpdGxlXG4gKlxuICogICAtIG9uIHN1Y2Nlc3MgaXQgcmV0dXJucyBhIHN0cmluZyBhbmQgdXBkYXRlcyBzdGF0ZS5wb3M7XG4gKiAgIC0gb24gZmFpbHVyZSBpdCByZXR1cm5zIG51bGxcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBvc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtUaXRsZShzdGF0ZSwgcG9zKSB7XG4gIHZhciBjb2RlLFxuICAgICAgc3RhcnQgPSBwb3MsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChtYXJrZXIgIT09IDB4MjIgLyogXCIgKi8gJiYgbWFya2VyICE9PSAweDI3IC8qICcgKi8gJiYgbWFya2VyICE9PSAweDI4IC8qICggKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zKys7XG5cbiAgLy8gaWYgb3BlbmluZyBtYXJrZXIgaXMgXCIoXCIsIHN3aXRjaCBpdCB0byBjbG9zaW5nIG1hcmtlciBcIilcIlxuICBpZiAobWFya2VyID09PSAweDI4KSB7IG1hcmtlciA9IDB4Mjk7IH1cblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNvZGUgPT09IG1hcmtlcikge1xuICAgICAgc3RhdGUucG9zID0gcG9zICsgMTtcbiAgICAgIHN0YXRlLmxpbmtDb250ZW50ID0gdW5lc2NhcGVNZChzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQgKyAxLCBwb3MpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICBwb3MgKz0gMjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgYXNzaWduICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS5hc3NpZ247XG52YXIgUmVuZGVyZXIgICAgID0gcmVxdWlyZSgnLi9yZW5kZXJlcicpO1xudmFyIFBhcnNlckNvcmUgICA9IHJlcXVpcmUoJy4vcGFyc2VyX2NvcmUnKTtcbnZhciBQYXJzZXJCbG9jayAgPSByZXF1aXJlKCcuL3BhcnNlcl9ibG9jaycpO1xudmFyIFBhcnNlcklubGluZSA9IHJlcXVpcmUoJy4vcGFyc2VyX2lubGluZScpO1xudmFyIFJ1bGVyICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuLyoqXG4gKiBQcmVzZXQgY29uZmlnc1xuICovXG5cbnZhciBjb25maWcgPSB7XG4gICdkZWZhdWx0JzogICAgcmVxdWlyZSgnLi9jb25maWdzL2RlZmF1bHQnKSxcbiAgJ2Z1bGwnOiAgICAgICByZXF1aXJlKCcuL2NvbmZpZ3MvZnVsbCcpLFxuICAnY29tbW9ubWFyayc6IHJlcXVpcmUoJy4vY29uZmlncy9jb21tb25tYXJrJylcbn07XG5cbi8qKlxuICogVGhlIGBTdGF0ZUNvcmVgIGNsYXNzIG1hbmFnZXMgc3RhdGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGBpbnN0YW5jZWAgUmVtYXJrYWJsZSBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgIE1hcmtkb3duIHN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IGBlbnZgXG4gKi9cblxuZnVuY3Rpb24gU3RhdGVDb3JlKGluc3RhbmNlLCBzdHIsIGVudikge1xuICB0aGlzLnNyYyA9IHN0cjtcbiAgdGhpcy5lbnYgPSBlbnY7XG4gIHRoaXMub3B0aW9ucyA9IGluc3RhbmNlLm9wdGlvbnM7XG4gIHRoaXMudG9rZW5zID0gW107XG4gIHRoaXMuaW5saW5lTW9kZSA9IGZhbHNlO1xuXG4gIHRoaXMuaW5saW5lID0gaW5zdGFuY2UuaW5saW5lO1xuICB0aGlzLmJsb2NrID0gaW5zdGFuY2UuYmxvY2s7XG4gIHRoaXMucmVuZGVyZXIgPSBpbnN0YW5jZS5yZW5kZXJlcjtcbiAgdGhpcy50eXBvZ3JhcGhlciA9IGluc3RhbmNlLnR5cG9ncmFwaGVyO1xufVxuXG4vKipcbiAqIFRoZSBtYWluIGBSZW1hcmthYmxlYCBjbGFzcy4gQ3JlYXRlIGFuIGluc3RhbmNlIG9mXG4gKiBgUmVtYXJrYWJsZWAgd2l0aCBhIGBwcmVzZXRgIGFuZC9vciBgb3B0aW9uc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBwcmVzZXRgIElmIG5vIHByZXNldCBpcyBnaXZlbiwgYGRlZmF1bHRgIGlzIHVzZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKi9cblxuZnVuY3Rpb24gUmVtYXJrYWJsZShwcmVzZXQsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwcmVzZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHByZXNldDtcbiAgICBwcmVzZXQgPSAnZGVmYXVsdCc7XG4gIH1cblxuICB0aGlzLmlubGluZSAgID0gbmV3IFBhcnNlcklubGluZSgpO1xuICB0aGlzLmJsb2NrICAgID0gbmV3IFBhcnNlckJsb2NrKCk7XG4gIHRoaXMuY29yZSAgICAgPSBuZXcgUGFyc2VyQ29yZSgpO1xuICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG4gIHRoaXMucnVsZXIgICAgPSBuZXcgUnVsZXIoKTtcblxuICB0aGlzLm9wdGlvbnMgID0ge307XG4gIHRoaXMuY29uZmlndXJlKGNvbmZpZ1twcmVzZXRdKTtcbiAgdGhpcy5zZXQob3B0aW9ucyB8fCB7fSk7XG59XG5cbi8qKlxuICogU2V0IG9wdGlvbnMgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gcGFzc2luZyB0aGVtXG4gKiB0byB0aGUgY29uc3RydWN0b3IuXG4gKlxuICogYGBganNcbiAqIG1kLnNldCh7dHlwb2dyYXBoZXI6IHRydWV9KTtcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZW1hcmthYmxlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQmF0Y2ggbG9hZGVyIGZvciBjb21wb25lbnRzIHJ1bGVzIHN0YXRlcywgYW5kIG9wdGlvbnNcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBwcmVzZXRzYFxuICovXG5cblJlbWFya2FibGUucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChwcmVzZXRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXByZXNldHMpIHsgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgcmVtYXJrYWJsZWAgcHJlc2V0LCBjaGVjayBuYW1lL2NvbnRlbnQnKTsgfVxuICBpZiAocHJlc2V0cy5vcHRpb25zKSB7IHNlbGYuc2V0KHByZXNldHMub3B0aW9ucyk7IH1cbiAgaWYgKHByZXNldHMuY29tcG9uZW50cykge1xuICAgIE9iamVjdC5rZXlzKHByZXNldHMuY29tcG9uZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlcykge1xuICAgICAgICBzZWxmW25hbWVdLnJ1bGVyLmVuYWJsZShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMsIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIFVzZSBhIHBsdWdpbi5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1kID0gbmV3IFJlbWFya2FibGUoKTtcbiAqXG4gKiBtZC51c2UocGx1Z2luMSlcbiAqICAgLnVzZShwbHVnaW4yLCBvcHRzKVxuICogICAudXNlKHBsdWdpbjMpO1xuICogYGBgXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGBwbHVnaW5gXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBgUmVtYXJrYWJsZWAgZm9yIGNoYWluaW5nXG4gKi9cblxuUmVtYXJrYWJsZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKHBsdWdpbiwgb3B0aW9ucykge1xuICBwbHVnaW4odGhpcywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIFBhcnNlIHRoZSBpbnB1dCBgc3RyaW5nYCBhbmQgcmV0dXJuIGEgdG9rZW5zIGFycmF5LlxuICogTW9kaWZpZXMgYGVudmAgd2l0aCBkZWZpbml0aW9ucyBkYXRhLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gYHN0cmluZ2BcbiAqIEBwYXJhbSAge09iamVjdH0gYGVudmBcbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiB0b2tlbnNcbiAqL1xuXG5SZW1hcmthYmxlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzdHIsIGVudikge1xuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGVDb3JlKHRoaXMsIHN0ciwgZW52KTtcbiAgdGhpcy5jb3JlLnByb2Nlc3Moc3RhdGUpO1xuICByZXR1cm4gc3RhdGUudG9rZW5zO1xufTtcblxuLyoqXG4gKiBUaGUgbWFpbiBgLnJlbmRlcigpYCBtZXRob2QgdGhhdCBkb2VzIGFsbCB0aGUgbWFnaWMgOilcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdHJpbmdgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBlbnZgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlbmRlcmVkIEhUTUwuXG4gKi9cblxuUmVtYXJrYWJsZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHN0ciwgZW52KSB7XG4gIGVudiA9IGVudiB8fCB7fTtcbiAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMucGFyc2Uoc3RyLCBlbnYpLCB0aGlzLm9wdGlvbnMsIGVudik7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBjb250ZW50IGBzdHJpbmdgIGFzIGEgc2luZ2xlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdHJpbmdgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBlbnZgXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgdG9rZW5zXG4gKi9cblxuUmVtYXJrYWJsZS5wcm90b3R5cGUucGFyc2VJbmxpbmUgPSBmdW5jdGlvbiAoc3RyLCBlbnYpIHtcbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlQ29yZSh0aGlzLCBzdHIsIGVudik7XG4gIHN0YXRlLmlubGluZU1vZGUgPSB0cnVlO1xuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG4gIHJldHVybiBzdGF0ZS50b2tlbnM7XG59O1xuXG4vKipcbiAqIFJlbmRlciBhIHNpbmdsZSBjb250ZW50IGBzdHJpbmdgLCB3aXRob3V0IHdyYXBwaW5nIGl0XG4gKiB0byBwYXJhZ3JhcGhzXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgc3RyYFxuICogQHBhcmFtICB7T2JqZWN0fSBgZW52YFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cblJlbWFya2FibGUucHJvdG90eXBlLnJlbmRlcklubGluZSA9IGZ1bmN0aW9uIChzdHIsIGVudikge1xuICBlbnYgPSBlbnYgfHwge307XG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlSW5saW5lKHN0ciwgZW52KSwgdGhpcy5vcHRpb25zLCBlbnYpO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlbWFya2FibGVgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZW1hcmthYmxlO1xuXG4vKipcbiAqIEV4cG9zZSBgdXRpbHNgLCBVc2VmdWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgY3VzdG9tXG4gKiByZW5kZXJpbmcuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMudXRpbHMgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIExvY2FsIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBSdWxlciAgICAgID0gcmVxdWlyZSgnLi9ydWxlcicpO1xudmFyIFN0YXRlQmxvY2sgPSByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrJyk7XG5cbi8qKlxuICogUGFyc2VyIHJ1bGVzXG4gKi9cblxudmFyIF9ydWxlcyA9IFtcbiAgWyAnY29kZScsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svY29kZScpIF0sXG4gIFsgJ2ZlbmNlcycsICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2ZlbmNlcycpLCAgICAgWyAncGFyYWdyYXBoJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcgXSBdLFxuICBbICdibG9ja3F1b3RlJywgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9ibG9ja3F1b3RlJyksIFsgJ3BhcmFncmFwaCcsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcbiAgWyAnaHInLCAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaHInKSwgICAgICAgICBbICdwYXJhZ3JhcGgnLCAnYmxvY2txdW90ZScsICdsaXN0JyBdIF0sXG4gIFsgJ2xpc3QnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2xpc3QnKSwgICAgICAgWyAncGFyYWdyYXBoJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAnZm9vdG5vdGUnLCAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svZm9vdG5vdGUnKSwgICBbICdwYXJhZ3JhcGgnIF0gXSxcbiAgWyAnaGVhZGluZycsICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaGVhZGluZycpLCAgICBbICdwYXJhZ3JhcGgnLCAnYmxvY2txdW90ZScgXSBdLFxuICBbICdsaGVhZGluZycsICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9saGVhZGluZycpIF0sXG4gIFsgJ2h0bWxibG9jaycsICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2h0bWxibG9jaycpLCAgWyAncGFyYWdyYXBoJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAndGFibGUnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svdGFibGUnKSwgICAgICBbICdwYXJhZ3JhcGgnIF0gXSxcbiAgWyAnZGVmbGlzdCcsICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svZGVmbGlzdCcpLCAgICBbICdwYXJhZ3JhcGgnIF0gXSxcbiAgWyAncGFyYWdyYXBoJywgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svcGFyYWdyYXBoJykgXVxuXTtcblxuLyoqXG4gKiBCbG9jayBQYXJzZXIgY2xhc3NcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQYXJzZXJCbG9jaygpIHtcbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSwge1xuICAgICAgYWx0OiAoX3J1bGVzW2ldWzJdIHx8IFtdKS5zbGljZSgpXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSB0b2tlbnMgZm9yIHRoZSBnaXZlbiBpbnB1dCByYW5nZS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBzdGF0ZWAgSGFzIHByb3BlcnRpZXMgbGlrZSBgc3JjYCwgYHBhcnNlcmAsIGBvcHRpb25zYCBldGNcbiAqIEBwYXJhbSAge051bWJlcn0gYHN0YXJ0TGluZWBcbiAqIEBwYXJhbSAge051bWJlcn0gYGVuZExpbmVgXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5QYXJzZXJCbG9jay5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSkge1xuICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKTtcbiAgdmFyIGxlbiA9IHJ1bGVzLmxlbmd0aDtcbiAgdmFyIGxpbmUgPSBzdGFydExpbmU7XG4gIHZhciBoYXNFbXB0eUxpbmVzID0gZmFsc2U7XG4gIHZhciBvaywgaTtcblxuICB3aGlsZSAobGluZSA8IGVuZExpbmUpIHtcbiAgICBzdGF0ZS5saW5lID0gbGluZSA9IHN0YXRlLnNraXBFbXB0eUxpbmVzKGxpbmUpO1xuICAgIGlmIChsaW5lID49IGVuZExpbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFRlcm1pbmF0aW9uIGNvbmRpdGlvbiBmb3IgbmVzdGVkIGNhbGxzLlxuICAgIC8vIE5lc3RlZCBjYWxscyBjdXJyZW50bHkgdXNlZCBmb3IgYmxvY2txdW90ZXMgJiBsaXN0c1xuICAgIGlmIChzdGF0ZS50U2hpZnRbbGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUubGluZWBcbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUudG9rZW5zYFxuICAgIC8vIC0gcmV0dXJuIHRydWVcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgbGluZSwgZW5kTGluZSwgZmFsc2UpO1xuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldCBzdGF0ZS50aWdodCBpZmYgd2UgaGFkIGFuIGVtcHR5IGxpbmUgYmVmb3JlIGN1cnJlbnQgdGFnXG4gICAgLy8gaS5lLiBsYXRlc3QgZW1wdHkgbGluZSBzaG91bGQgbm90IGNvdW50XG4gICAgc3RhdGUudGlnaHQgPSAhaGFzRW1wdHlMaW5lcztcblxuICAgIC8vIHBhcmFncmFwaCBtaWdodCBcImVhdFwiIG9uZSBuZXdsaW5lIGFmdGVyIGl0IGluIG5lc3RlZCBsaXN0c1xuICAgIGlmIChzdGF0ZS5pc0VtcHR5KHN0YXRlLmxpbmUgLSAxKSkge1xuICAgICAgaGFzRW1wdHlMaW5lcyA9IHRydWU7XG4gICAgfVxuXG4gICAgbGluZSA9IHN0YXRlLmxpbmU7XG5cbiAgICBpZiAobGluZSA8IGVuZExpbmUgJiYgc3RhdGUuaXNFbXB0eShsaW5lKSkge1xuICAgICAgaGFzRW1wdHlMaW5lcyA9IHRydWU7XG4gICAgICBsaW5lKys7XG5cbiAgICAgIC8vIHR3byBlbXB0eSBsaW5lcyBzaG91bGQgc3RvcCB0aGUgcGFyc2VyIGluIGxpc3QgbW9kZVxuICAgICAgaWYgKGxpbmUgPCBlbmRMaW5lICYmIHN0YXRlLnBhcmVudFR5cGUgPT09ICdsaXN0JyAmJiBzdGF0ZS5pc0VtcHR5KGxpbmUpKSB7IGJyZWFrOyB9XG4gICAgICBzdGF0ZS5saW5lID0gbGluZTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBUQUJTX1NDQU5fUkUgPSAvW1xcblxcdF0vZztcbnZhciBORVdMSU5FU19SRSAgPSAvXFxyW1xcblxcdTAwODVdfFtcXHUyNDI0XFx1MjAyOFxcdTAwODVdL2c7XG52YXIgU1BBQ0VTX1JFICAgID0gL1xcdTAwYTAvZztcblxuLyoqXG4gKiBUb2tlbml6ZSB0aGUgZ2l2ZW4gYHN0cmAuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgc3RyYCBTb3VyY2Ugc3RyaW5nXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHBhcmFtICB7T2JqZWN0fSBgZW52YFxuICogQHBhcmFtICB7QXJyYXl9IGBvdXRUb2tlbnNgXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5QYXJzZXJCbG9jay5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zLCBlbnYsIG91dFRva2Vucykge1xuICB2YXIgc3RhdGUsIGxpbmVTdGFydCA9IDAsIGxhc3RUYWJQb3MgPSAwO1xuICBpZiAoIXN0cikgeyByZXR1cm4gW107IH1cblxuICAvLyBOb3JtYWxpemUgc3BhY2VzXG4gIHN0ciA9IHN0ci5yZXBsYWNlKFNQQUNFU19SRSwgJyAnKTtcblxuICAvLyBOb3JtYWxpemUgbmV3bGluZXNcbiAgc3RyID0gc3RyLnJlcGxhY2UoTkVXTElORVNfUkUsICdcXG4nKTtcblxuICAvLyBSZXBsYWNlIHRhYnMgd2l0aCBwcm9wZXIgbnVtYmVyIG9mIHNwYWNlcyAoMS4uNClcbiAgaWYgKHN0ci5pbmRleE9mKCdcXHQnKSA+PSAwKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoVEFCU19TQ0FOX1JFLCBmdW5jdGlvbiAobWF0Y2gsIG9mZnNldCkge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmIChzdHIuY2hhckNvZGVBdChvZmZzZXQpID09PSAweDBBKSB7XG4gICAgICAgIGxpbmVTdGFydCA9IG9mZnNldCArIDE7XG4gICAgICAgIGxhc3RUYWJQb3MgPSAwO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSAnICAgICcuc2xpY2UoKG9mZnNldCAtIGxpbmVTdGFydCAtIGxhc3RUYWJQb3MpICUgNCk7XG4gICAgICBsYXN0VGFiUG9zID0gb2Zmc2V0IC0gbGluZVN0YXJ0ICsgMTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0ZSA9IG5ldyBTdGF0ZUJsb2NrKHN0ciwgdGhpcywgb3B0aW9ucywgZW52LCBvdXRUb2tlbnMpO1xuICB0aGlzLnRva2VuaXplKHN0YXRlLCBzdGF0ZS5saW5lLCBzdGF0ZS5saW5lTWF4KTtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBQYXJzZXJCbG9ja2BcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlckJsb2NrO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIExvY2FsIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBSdWxlciA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuLyoqXG4gKiBDb3JlIHBhcnNlciBgcnVsZXNgXG4gKi9cblxudmFyIF9ydWxlcyA9IFtcbiAgWyAnYmxvY2snLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvYmxvY2snKSAgICAgICAgICBdLFxuICBbICdhYmJyJywgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9hYmJyJykgICAgICAgICAgIF0sXG4gIFsgJ3JlZmVyZW5jZXMnLCAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL3JlZmVyZW5jZXMnKSAgICAgXSxcbiAgWyAnaW5saW5lJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvaW5saW5lJykgICAgICAgICBdLFxuICBbICdmb290bm90ZV90YWlsJywgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9mb290bm90ZV90YWlsJykgIF0sXG4gIFsgJ2FiYnIyJywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2FiYnIyJykgICAgICAgICAgXSxcbiAgWyAncmVwbGFjZW1lbnRzJywgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzJykgICBdLFxuICBbICdzbWFydHF1b3RlcycsICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9zbWFydHF1b3RlcycpICAgIF0sXG4gIFsgJ2xpbmtpZnknLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2xpbmtpZnknKSAgICAgICAgXVxuXTtcblxuLyoqXG4gKiBDbGFzcyBmb3IgdG9wIGxldmVsIChgY29yZWApIHBhcnNlciBydWxlc1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIENvcmUoKSB7XG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFByb2Nlc3MgcnVsZXMgd2l0aCB0aGUgZ2l2ZW4gYHN0YXRlYFxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gYHN0YXRlYFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29yZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgaSwgbCwgcnVsZXM7XG4gIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyk7XG4gIGZvciAoaSA9IDAsIGwgPSBydWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBydWxlc1tpXShzdGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhwb3NlIGBDb3JlYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQ29yZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgUnVsZXIgICAgICAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG52YXIgU3RhdGVJbmxpbmUgPSByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUnKTtcbnZhciB1dGlscyAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJyk7XG5cbi8qKlxuICogSW5saW5lIFBhcnNlciBgcnVsZXNgXG4gKi9cblxudmFyIF9ydWxlcyA9IFtcbiAgWyAndGV4dCcsICAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvdGV4dCcpIF0sXG4gIFsgJ25ld2xpbmUnLCAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL25ld2xpbmUnKSBdLFxuICBbICdlc2NhcGUnLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lc2NhcGUnKSBdLFxuICBbICdiYWNrdGlja3MnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9iYWNrdGlja3MnKSBdLFxuICBbICdkZWwnLCAgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9kZWwnKSBdLFxuICBbICdpbnMnLCAgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9pbnMnKSBdLFxuICBbICdtYXJrJywgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9tYXJrJykgXSxcbiAgWyAnZW1waGFzaXMnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZW1waGFzaXMnKSBdLFxuICBbICdzdWInLCAgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdWInKSBdLFxuICBbICdzdXAnLCAgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdXAnKSBdLFxuICBbICdsaW5rcycsICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9saW5rcycpIF0sXG4gIFsgJ2Zvb3Rub3RlX2lubGluZScsIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2Zvb3Rub3RlX2lubGluZScpIF0sXG4gIFsgJ2Zvb3Rub3RlX3JlZicsICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2Zvb3Rub3RlX3JlZicpIF0sXG4gIFsgJ2F1dG9saW5rJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2F1dG9saW5rJykgXSxcbiAgWyAnaHRtbHRhZycsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvaHRtbHRhZycpIF0sXG4gIFsgJ2VudGl0eScsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VudGl0eScpIF1cbl07XG5cbi8qKlxuICogSW5saW5lIFBhcnNlciBjbGFzcy4gTm90ZSB0aGF0IGxpbmsgdmFsaWRhdGlvbiBpcyBzdHJpY3RlclxuICogaW4gUmVtYXJrYWJsZSB0aGFuIHdoYXQgaXMgc3BlY2lmaWVkIGJ5IENvbW1vbk1hcmsuIElmIHlvdVxuICogd2FudCB0byBjaGFuZ2UgdGhpcyB5b3UgY2FuIHVzZSBhIGN1c3RvbSB2YWxpZGF0b3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUGFyc2VySW5saW5lKCkge1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdKTtcbiAgfVxuXG4gIC8vIENhbiBiZSBvdmVycmlkZGVuIHdpdGggYSBjdXN0b20gdmFsaWRhdG9yXG4gIHRoaXMudmFsaWRhdGVMaW5rID0gdmFsaWRhdGVMaW5rO1xufVxuXG4vKipcbiAqIFNraXAgYSBzaW5nbGUgdG9rZW4gYnkgcnVubmluZyBhbGwgcnVsZXMgaW4gdmFsaWRhdGlvbiBtb2RlLlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHJ1bGUgcmVwb3J0cyBzdWNjZXNzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gYHN0YXRlYFxuICogQGFwaSBwcml2YWdlXG4gKi9cblxuUGFyc2VySW5saW5lLnByb3RvdHlwZS5za2lwVG9rZW4gPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyk7XG4gIHZhciBsZW4gPSBydWxlcy5sZW5ndGg7XG4gIHZhciBwb3MgPSBzdGF0ZS5wb3M7XG4gIHZhciBpLCBjYWNoZWRfcG9zO1xuXG4gIGlmICgoY2FjaGVkX3BvcyA9IHN0YXRlLmNhY2hlR2V0KHBvcykpID4gMCkge1xuICAgIHN0YXRlLnBvcyA9IGNhY2hlZF9wb3M7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHJ1bGVzW2ldKHN0YXRlLCB0cnVlKSkge1xuICAgICAgc3RhdGUuY2FjaGVTZXQocG9zLCBzdGF0ZS5wb3MpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnBvcysrO1xuICBzdGF0ZS5jYWNoZVNldChwb3MsIHN0YXRlLnBvcyk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRva2VucyBmb3IgdGhlIGdpdmVuIGlucHV0IHJhbmdlLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gYHN0YXRlYFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUGFyc2VySW5saW5lLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKTtcbiAgdmFyIGxlbiA9IHJ1bGVzLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHN0YXRlLnBvc01heDtcbiAgdmFyIG9rLCBpO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBlbmQpIHtcblxuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgdGhlIHJ1bGUgc2hvdWxkOlxuICAgIC8vXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnBvc2BcbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUudG9rZW5zYFxuICAgIC8vIC0gcmV0dXJuIHRydWVcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIGZhbHNlKTtcblxuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvaykge1xuICAgICAgaWYgKHN0YXRlLnBvcyA+PSBlbmQpIHsgYnJlYWs7IH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3N0YXRlLnBvcysrXTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wZW5kaW5nKSB7XG4gICAgc3RhdGUucHVzaFBlbmRpbmcoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gaW5wdXQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gYHN0cmBcbiAqIEBwYXJhbSAge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBlbnZgXG4gKiBAcGFyYW0gIHtBcnJheX0gYG91dFRva2Vuc2BcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBhcnNlcklubGluZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zLCBlbnYsIG91dFRva2Vucykge1xuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGVJbmxpbmUoc3RyLCB0aGlzLCBvcHRpb25zLCBlbnYsIG91dFRva2Vucyk7XG4gIHRoaXMudG9rZW5pemUoc3RhdGUpO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgZ2l2ZW4gYHVybGAgYnkgY2hlY2tpbmcgZm9yIGJhZCBwcm90b2NvbHMuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgdXJsYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUxpbmsodXJsKSB7XG4gIHZhciBCQURfUFJPVE9DT0xTID0gWyAndmJzY3JpcHQnLCAnamF2YXNjcmlwdCcsICdmaWxlJywgJ2RhdGEnIF07XG4gIHZhciBzdHIgPSB1cmwudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIC8vIENhcmUgYWJvdXQgZGlnaXRhbCBlbnRpdGllcyBcImphdmFzY3JpcHQmI3gzQTthbGVydCgxKVwiXG4gIHN0ciA9IHV0aWxzLnJlcGxhY2VFbnRpdGllcyhzdHIpO1xuICBpZiAoc3RyLmluZGV4T2YoJzonKSAhPT0gLTEgJiYgQkFEX1BST1RPQ09MUy5pbmRleE9mKHN0ci5zcGxpdCgnOicpWzBdKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRXhwb3NlIGBQYXJzZXJJbmxpbmVgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJJbmxpbmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTG9jYWwgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKTtcbnZhciBydWxlcyA9IHJlcXVpcmUoJy4vcnVsZXMnKTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlbmRlcmVyYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XG5cbi8qKlxuICogUmVuZGVyZXIgY2xhc3MuIFJlbmRlcnMgSFRNTCBhbmQgZXhwb3NlcyBgcnVsZXNgIHRvIGFsbG93XG4gKiBsb2NhbCBtb2RpZmljYXRpb25zLlxuICovXG5cbmZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuICB0aGlzLnJ1bGVzID0gdXRpbHMuYXNzaWduKHt9LCBydWxlcyk7XG5cbiAgLy8gZXhwb3J0ZWQgaGVscGVyLCBmb3IgY3VzdG9tIHJ1bGVzIG9ubHlcbiAgdGhpcy5nZXRCcmVhayA9IHJ1bGVzLmdldEJyZWFrO1xufVxuXG4vKipcbiAqIFJlbmRlciBhIHN0cmluZyBvZiBpbmxpbmUgSFRNTCB3aXRoIHRoZSBnaXZlbiBgdG9rZW5zYCBhbmRcbiAqIGBvcHRpb25zYC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gYHRva2Vuc2BcbiAqIEBwYXJhbSAge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBlbnZgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIF9ydWxlcyA9IHRoaXMucnVsZXM7XG4gIHZhciBsZW4gPSB0b2tlbnMubGVuZ3RoLCBpID0gMDtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIHdoaWxlIChsZW4tLSkge1xuICAgIHJlc3VsdCArPSBfcnVsZXNbdG9rZW5zW2ldLnR5cGVdKHRva2VucywgaSsrLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmVuZGVyIGEgc3RyaW5nIG9mIEhUTUwgd2l0aCB0aGUgZ2l2ZW4gYHRva2Vuc2AgYW5kXG4gKiBgb3B0aW9uc2AuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGB0b2tlbnNgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHBhcmFtICB7T2JqZWN0fSBgZW52YFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gIHZhciBfcnVsZXMgPSB0aGlzLnJ1bGVzO1xuICB2YXIgbGVuID0gdG9rZW5zLmxlbmd0aCwgaSA9IC0xO1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlcklubGluZSh0b2tlbnNbaV0uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSBfcnVsZXNbdG9rZW5zW2ldLnR5cGVdKHRva2VucywgaSwgb3B0aW9ucywgZW52LCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUnVsZXIgaXMgYSBoZWxwZXIgY2xhc3MgZm9yIGJ1aWxkaW5nIHJlc3BvbnNpYmlsaXR5IGNoYWlucyBmcm9tXG4gKiBwYXJzZSBydWxlcy4gSXQgYWxsb3dzOlxuICpcbiAqICAgLSBlYXN5IHN0YWNrIHJ1bGVzIGNoYWluc1xuICogICAtIGdldHRpbmcgbWFpbiBjaGFpbiBhbmQgbmFtZWQgY2hhaW5zIGNvbnRlbnQgKGFzIGFycmF5cyBvZiBmdW5jdGlvbnMpXG4gKlxuICogSGVscGVyIG1ldGhvZHMsIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFJ1bGVyKCkge1xuICAvLyBMaXN0IG9mIGFkZGVkIHJ1bGVzLiBFYWNoIGVsZW1lbnQgaXM6XG4gIC8vXG4gIC8vIHsgbmFtZTogWFhYLFxuICAvLyAgIGVuYWJsZWQ6IEJvb2xlYW4sXG4gIC8vICAgZm46IEZ1bmN0aW9uKCksXG4gIC8vICAgYWx0OiBbIG5hbWUyLCBuYW1lMyBdIH1cbiAgLy9cbiAgdGhpcy5fX3J1bGVzX18gPSBbXTtcblxuICAvLyBDYWNoZWQgcnVsZSBjaGFpbnMuXG4gIC8vXG4gIC8vIEZpcnN0IGxldmVsIC0gY2hhaW4gbmFtZSwgJycgZm9yIGRlZmF1bHQuXG4gIC8vIFNlY29uZCBsZXZlbCAtIGRpZ2l0YWwgYW5jaG9yIGZvciBmYXN0IGZpbHRlcmluZyBieSBjaGFyY29kZXMuXG4gIC8vXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn1cblxuLyoqXG4gKiBGaW5kIHRoZSBpbmRleCBvZiBhIHJ1bGUgYnkgYG5hbWVgLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gYG5hbWVgXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBnaXZlbiBgbmFtZWBcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJ1bGVyLnByb3RvdHlwZS5fX2ZpbmRfXyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBsZW4gPSB0aGlzLl9fcnVsZXNfXy5sZW5ndGg7XG4gIHZhciBpID0gLTE7XG5cbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAgaWYgKHRoaXMuX19ydWxlc19fWysraV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn07XG5cbi8qKlxuICogQnVpbGQgdGhlIHJ1bGVzIGxvb2t1cCBjYWNoZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJ1bGVyLnByb3RvdHlwZS5fX2NvbXBpbGVfXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2hhaW5zID0gWyAnJyBdO1xuXG4gIC8vIGNvbGxlY3QgdW5pcXVlIG5hbWVzXG4gIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBpZiAoIXJ1bGUuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJ1bGUuYWx0LmZvckVhY2goZnVuY3Rpb24gKGFsdE5hbWUpIHtcbiAgICAgIGlmIChjaGFpbnMuaW5kZXhPZihhbHROYW1lKSA8IDApIHtcbiAgICAgICAgY2hhaW5zLnB1c2goYWx0TmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHNlbGYuX19jYWNoZV9fID0ge307XG5cbiAgY2hhaW5zLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dID0gW107XG4gICAgc2VsZi5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgaWYgKCFydWxlLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhaW4gJiYgcnVsZS5hbHQuaW5kZXhPZihjaGFpbikgPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXS5wdXNoKHJ1bGUuZm4pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogUnVsZXIgcHVibGljIG1ldGhvZHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8qKlxuICogUmVwbGFjZSBydWxlIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgbmFtZWAgUnVsZSBuYW1lXG4gKiBAcGFyYW0gIHtGdW5jdGlvbiBgZm5gXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBvcHRpb25zYFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUnVsZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaWR4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgbmFtZSk7XG4gIH1cblxuICB0aGlzLl9fcnVsZXNfX1tpZHhdLmZuID0gZm47XG4gIHRoaXMuX19ydWxlc19fW2lkeF0uYWx0ID0gb3B0LmFsdCB8fCBbXTtcbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBBZGQgYSBydWxlIHRvIHRoZSBjaGFpbiBiZWZvcmUgZ2l2ZW4gdGhlIGBydWxlTmFtZWAuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSAgIGBiZWZvcmVOYW1lYFxuICogQHBhcmFtICB7U3RyaW5nfSAgIGBydWxlTmFtZWBcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBgZm5gXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgYG9wdGlvbnNgXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SdWxlci5wcm90b3R5cGUuYmVmb3JlID0gZnVuY3Rpb24gKGJlZm9yZU5hbWUsIHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaWR4ID0gdGhpcy5fX2ZpbmRfXyhiZWZvcmVOYW1lKTtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBydWxlIG5vdCBmb3VuZDogJyArIGJlZm9yZU5hbWUpO1xuICB9XG5cbiAgdGhpcy5fX3J1bGVzX18uc3BsaWNlKGlkeCwgMCwge1xuICAgIG5hbWU6IHJ1bGVOYW1lLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZm46IGZuLFxuICAgIGFsdDogb3B0LmFsdCB8fCBbXVxuICB9KTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59O1xuXG4vKipcbiAqIEFkZCBhIHJ1bGUgdG8gdGhlIGNoYWluIGFmdGVyIHRoZSBnaXZlbiBgcnVsZU5hbWVgLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gICBgYWZ0ZXJOYW1lYFxuICogQHBhcmFtICB7U3RyaW5nfSAgIGBydWxlTmFtZWBcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBgZm5gXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgYG9wdGlvbnNgXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SdWxlci5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAoYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18oYWZ0ZXJOYW1lKTtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBydWxlIG5vdCBmb3VuZDogJyArIGFmdGVyTmFtZSk7XG4gIH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaWR4ICsgMSwgMCwge1xuICAgIG5hbWU6IHJ1bGVOYW1lLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZm46IGZuLFxuICAgIGFsdDogb3B0LmFsdCB8fCBbXVxuICB9KTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59O1xuXG4vKipcbiAqIEFkZCBhIHJ1bGUgdG8gdGhlIGVuZCBvZiBjaGFpbi5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgYHJ1bGVOYW1lYFxuICogQHBhcmFtICB7RnVuY3Rpb259IGBmbmBcbiAqIEBwYXJhbSAge09iamVjdH0gICBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5SdWxlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5fX3J1bGVzX18ucHVzaCh7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbjogZm4sXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gIH0pO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cbi8qKlxuICogRW5hYmxlIGEgcnVsZSBvciBsaXN0IG9mIHJ1bGVzLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gYGxpc3RgIE5hbWUgb3IgYXJyYXkgb2YgcnVsZSBuYW1lcyB0byBlbmFibGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGBzdHJpY3RgIElmIGB0cnVlYCwgYWxsIG5vbiBsaXN0ZWQgcnVsZXMgd2lsbCBiZSBkaXNhYmxlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJ1bGVyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAobGlzdCwgc3RyaWN0KSB7XG4gIGxpc3QgPSAhQXJyYXkuaXNBcnJheShsaXN0KVxuICAgID8gWyBsaXN0IF1cbiAgICA6IGxpc3Q7XG5cbiAgLy8gSW4gc3RyaWN0IG1vZGUgZGlzYWJsZSBhbGwgZXhpc3RpbmcgcnVsZXMgZmlyc3RcbiAgaWYgKHN0cmljdCkge1xuICAgIHRoaXMuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgIHJ1bGUuZW5hYmxlZCA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGVuYWJsZVxuICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fX2ZpbmRfXyhuYW1lKTtcbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IHRydWU7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBEaXNhYmxlIGEgcnVsZSBvciBsaXN0IG9mIHJ1bGVzLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gYGxpc3RgIE5hbWUgb3IgYXJyYXkgb2YgcnVsZSBuYW1lcyB0byBkaXNhYmxlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SdWxlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gIGxpc3QgPSAhQXJyYXkuaXNBcnJheShsaXN0KVxuICAgID8gWyBsaXN0IF1cbiAgICA6IGxpc3Q7XG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGRpc2FibGVcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18obmFtZSk7XG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUnVsZXMgbWFuYWdlcjogaW52YWxpZCBydWxlIG5hbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICB0aGlzLl9fcnVsZXNfX1tpZHhdLmVuYWJsZWQgPSBmYWxzZTtcbiAgfSwgdGhpcyk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgYSBydWxlcyBsaXN0IGFzIGFuIGFycmF5IG9mIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBjaGFpbk5hbWVgXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SdWxlci5wcm90b3R5cGUuZ2V0UnVsZXMgPSBmdW5jdGlvbiAoY2hhaW5OYW1lKSB7XG4gIGlmICh0aGlzLl9fY2FjaGVfXyA9PT0gbnVsbCkge1xuICAgIHRoaXMuX19jb21waWxlX18oKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fX2NhY2hlX19bY2hhaW5OYW1lXSB8fCBbXTtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBSdWxlcmBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIExvY2FsIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBoYXMgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLmhhcztcbnZhciB1bmVzY2FwZU1kICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLnVuZXNjYXBlTWQ7XG52YXIgcmVwbGFjZUVudGl0aWVzID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS5yZXBsYWNlRW50aXRpZXM7XG52YXIgZXNjYXBlSHRtbCAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS5lc2NhcGVIdG1sO1xuXG4vKipcbiAqIFJlbmRlcmVyIHJ1bGVzIGNhY2hlXG4gKi9cblxudmFyIHJ1bGVzID0ge307XG5cbi8qKlxuICogQmxvY2txdW90ZXNcbiAqL1xuXG5ydWxlcy5ibG9ja3F1b3RlX29wZW4gPSBmdW5jdGlvbigvKiB0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPGJsb2NrcXVvdGU+XFxuJztcbn07XG5cbnJ1bGVzLmJsb2NrcXVvdGVfY2xvc2UgPSBmdW5jdGlvbih0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPC9ibG9ja3F1b3RlPicgKyBnZXRCcmVhayh0b2tlbnMsIGlkeCk7XG59O1xuXG4vKipcbiAqIENvZGVcbiAqL1xuXG5ydWxlcy5jb2RlID0gZnVuY3Rpb24odG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICBpZiAodG9rZW5zW2lkeF0uYmxvY2spIHtcbiAgICByZXR1cm4gJzxwcmU+PGNvZGU+JyArIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgKyAnPC9jb2RlPjwvcHJlPicgKyBnZXRCcmVhayh0b2tlbnMsIGlkeCk7XG4gIH1cbiAgcmV0dXJuICc8Y29kZT4nICsgZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KSArICc8L2NvZGU+Jztcbn07XG5cbi8qKlxuICogRmVuY2VkIGNvZGUgYmxvY2tzXG4gKi9cblxucnVsZXMuZmVuY2UgPSBmdW5jdGlvbih0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBpbnN0YW5jZSkge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcbiAgdmFyIGxhbmdDbGFzcyA9ICcnO1xuICB2YXIgbGFuZ1ByZWZpeCA9IG9wdGlvbnMubGFuZ1ByZWZpeDtcbiAgdmFyIGxhbmdOYW1lID0gJycsIGZlbmNlcywgZmVuY2VOYW1lO1xuICB2YXIgaGlnaGxpZ2h0ZWQ7XG5cbiAgaWYgKHRva2VuLnBhcmFtcykge1xuXG4gICAgLy9cbiAgICAvLyBgYGBmb28gYmFyXG4gICAgLy9cbiAgICAvLyBUcnkgY3VzdG9tIHJlbmRlcmVyIFwiZm9vXCIgZmlyc3QuIFRoYXQgd2lsbCBzaW1wbGlmeSBvdmVyd3JpdGVcbiAgICAvLyBmb3IgZGlhZ3JhbXMsIGxhdGV4LCBhbmQgYW55IG90aGVyIGZlbmNlZCBibG9jayB3aXRoIGN1c3RvbSBsb29rXG4gICAgLy9cblxuICAgIGZlbmNlcyA9IHRva2VuLnBhcmFtcy5zcGxpdCgvXFxzKy9nKTtcbiAgICBmZW5jZU5hbWUgPSBmZW5jZXMuam9pbignICcpO1xuXG4gICAgaWYgKGhhcyhpbnN0YW5jZS5ydWxlcy5mZW5jZV9jdXN0b20sIGZlbmNlc1swXSkpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5ydWxlcy5mZW5jZV9jdXN0b21bZmVuY2VzWzBdXSh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgbGFuZ05hbWUgPSBlc2NhcGVIdG1sKHJlcGxhY2VFbnRpdGllcyh1bmVzY2FwZU1kKGZlbmNlTmFtZSkpKTtcbiAgICBsYW5nQ2xhc3MgPSAnIGNsYXNzPVwiJyArIGxhbmdQcmVmaXggKyBsYW5nTmFtZSArICdcIic7XG4gIH1cblxuICBpZiAob3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICBoaWdobGlnaHRlZCA9IG9wdGlvbnMuaGlnaGxpZ2h0LmFwcGx5KG9wdGlvbnMuaGlnaGxpZ2h0LCBbIHRva2VuLmNvbnRlbnQgXS5jb25jYXQoZmVuY2VzKSlcbiAgICAgIHx8IGVzY2FwZUh0bWwodG9rZW4uY29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgaGlnaGxpZ2h0ZWQgPSBlc2NhcGVIdG1sKHRva2VuLmNvbnRlbnQpO1xuICB9XG5cbiAgcmV0dXJuICc8cHJlPjxjb2RlJyArIGxhbmdDbGFzcyArICc+J1xuICAgICAgICArIGhpZ2hsaWdodGVkXG4gICAgICAgICsgJzwvY29kZT48L3ByZT4nXG4gICAgICAgICsgZ2V0QnJlYWsodG9rZW5zLCBpZHgpO1xufTtcblxucnVsZXMuZmVuY2VfY3VzdG9tID0ge307XG5cbi8qKlxuICogSGVhZGluZ3NcbiAqL1xuXG5ydWxlcy5oZWFkaW5nX29wZW4gPSBmdW5jdGlvbih0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPGgnICsgdG9rZW5zW2lkeF0uaExldmVsICsgJz4nO1xufTtcbnJ1bGVzLmhlYWRpbmdfY2xvc2UgPSBmdW5jdGlvbih0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPC9oJyArIHRva2Vuc1tpZHhdLmhMZXZlbCArICc+XFxuJztcbn07XG5cbi8qKlxuICogSG9yaXpvbnRhbCBydWxlc1xuICovXG5cbnJ1bGVzLmhyID0gZnVuY3Rpb24odG9rZW5zLCBpZHgsIG9wdGlvbnMgLyosIGVudiAqLykge1xuICByZXR1cm4gKG9wdGlvbnMueGh0bWxPdXQgPyAnPGhyIC8+JyA6ICc8aHI+JykgKyBnZXRCcmVhayh0b2tlbnMsIGlkeCk7XG59O1xuXG4vKipcbiAqIEJ1bGxldHNcbiAqL1xuXG5ydWxlcy5idWxsZXRfbGlzdF9vcGVuID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzx1bD5cXG4nO1xufTtcbnJ1bGVzLmJ1bGxldF9saXN0X2Nsb3NlID0gZnVuY3Rpb24odG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzwvdWw+JyArIGdldEJyZWFrKHRva2VucywgaWR4KTtcbn07XG5cbi8qKlxuICogTGlzdCBpdGVtc1xuICovXG5cbnJ1bGVzLmxpc3RfaXRlbV9vcGVuID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzxsaT4nO1xufTtcbnJ1bGVzLmxpc3RfaXRlbV9jbG9zZSA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8L2xpPlxcbic7XG59O1xuXG4vKipcbiAqIE9yZGVyZWQgbGlzdCBpdGVtc1xuICovXG5cbnJ1bGVzLm9yZGVyZWRfbGlzdF9vcGVuID0gZnVuY3Rpb24odG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcbiAgdmFyIG9yZGVyID0gdG9rZW4ub3JkZXIgPiAxID8gJyBzdGFydD1cIicgKyB0b2tlbi5vcmRlciArICdcIicgOiAnJztcbiAgcmV0dXJuICc8b2wnICsgb3JkZXIgKyAnPlxcbic7XG59O1xucnVsZXMub3JkZXJlZF9saXN0X2Nsb3NlID0gZnVuY3Rpb24odG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzwvb2w+JyArIGdldEJyZWFrKHRva2VucywgaWR4KTtcbn07XG5cbi8qKlxuICogUGFyYWdyYXBoc1xuICovXG5cbnJ1bGVzLnBhcmFncmFwaF9vcGVuID0gZnVuY3Rpb24odG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gdG9rZW5zW2lkeF0udGlnaHQgPyAnJyA6ICc8cD4nO1xufTtcbnJ1bGVzLnBhcmFncmFwaF9jbG9zZSA9IGZ1bmN0aW9uKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgdmFyIGFkZEJyZWFrID0gISh0b2tlbnNbaWR4XS50aWdodCAmJiBpZHggJiYgdG9rZW5zW2lkeCAtIDFdLnR5cGUgPT09ICdpbmxpbmUnICYmICF0b2tlbnNbaWR4IC0gMV0uY29udGVudCk7XG4gIHJldHVybiAodG9rZW5zW2lkeF0udGlnaHQgPyAnJyA6ICc8L3A+JykgKyAoYWRkQnJlYWsgPyBnZXRCcmVhayh0b2tlbnMsIGlkeCkgOiAnJyk7XG59O1xuXG4vKipcbiAqIExpbmtzXG4gKi9cblxucnVsZXMubGlua19vcGVuID0gZnVuY3Rpb24odG9rZW5zLCBpZHgsIG9wdGlvbnMgLyogZW52ICovKSB7XG4gIHZhciB0aXRsZSA9IHRva2Vuc1tpZHhdLnRpdGxlID8gKCcgdGl0bGU9XCInICsgZXNjYXBlSHRtbChyZXBsYWNlRW50aXRpZXModG9rZW5zW2lkeF0udGl0bGUpKSArICdcIicpIDogJyc7XG4gIHZhciB0YXJnZXQgPSBvcHRpb25zLmxpbmtUYXJnZXQgPyAoJyB0YXJnZXQ9XCInICsgb3B0aW9ucy5saW5rVGFyZ2V0ICsgJ1wiJykgOiAnJztcbiAgcmV0dXJuICc8YSBocmVmPVwiJyArIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uaHJlZikgKyAnXCInICsgdGl0bGUgKyB0YXJnZXQgKyAnPic7XG59O1xucnVsZXMubGlua19jbG9zZSA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8L2E+Jztcbn07XG5cbi8qKlxuICogSW1hZ2VzXG4gKi9cblxucnVsZXMuaW1hZ2UgPSBmdW5jdGlvbih0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHZhciBzcmMgPSAnIHNyYz1cIicgKyBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLnNyYykgKyAnXCInO1xuICB2YXIgdGl0bGUgPSB0b2tlbnNbaWR4XS50aXRsZSA/ICgnIHRpdGxlPVwiJyArIGVzY2FwZUh0bWwocmVwbGFjZUVudGl0aWVzKHRva2Vuc1tpZHhdLnRpdGxlKSkgKyAnXCInKSA6ICcnO1xuICB2YXIgYWx0ID0gJyBhbHQ9XCInICsgKHRva2Vuc1tpZHhdLmFsdCA/IGVzY2FwZUh0bWwocmVwbGFjZUVudGl0aWVzKHVuZXNjYXBlTWQodG9rZW5zW2lkeF0uYWx0KSkpIDogJycpICsgJ1wiJztcbiAgdmFyIHN1ZmZpeCA9IG9wdGlvbnMueGh0bWxPdXQgPyAnIC8nIDogJyc7XG4gIHJldHVybiAnPGltZycgKyBzcmMgKyBhbHQgKyB0aXRsZSArIHN1ZmZpeCArICc+Jztcbn07XG5cbi8qKlxuICogVGFibGVzXG4gKi9cblxucnVsZXMudGFibGVfb3BlbiA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8dGFibGU+XFxuJztcbn07XG5ydWxlcy50YWJsZV9jbG9zZSA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8L3RhYmxlPlxcbic7XG59O1xucnVsZXMudGhlYWRfb3BlbiA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8dGhlYWQ+XFxuJztcbn07XG5ydWxlcy50aGVhZF9jbG9zZSA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8L3RoZWFkPlxcbic7XG59O1xucnVsZXMudGJvZHlfb3BlbiA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8dGJvZHk+XFxuJztcbn07XG5ydWxlcy50Ym9keV9jbG9zZSA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8L3Rib2R5Plxcbic7XG59O1xucnVsZXMudHJfb3BlbiA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8dHI+Jztcbn07XG5ydWxlcy50cl9jbG9zZSA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8L3RyPlxcbic7XG59O1xucnVsZXMudGhfb3BlbiA9IGZ1bmN0aW9uKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG4gIHJldHVybiAnPHRoJ1xuICAgICsgKHRva2VuLmFsaWduID8gJyBzdHlsZT1cInRleHQtYWxpZ246JyArIHRva2VuLmFsaWduICsgJ1wiJyA6ICcnKVxuICAgICsgJz4nO1xufTtcbnJ1bGVzLnRoX2Nsb3NlID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzwvdGg+Jztcbn07XG5ydWxlcy50ZF9vcGVuID0gZnVuY3Rpb24odG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcbiAgcmV0dXJuICc8dGQnXG4gICAgKyAodG9rZW4uYWxpZ24gPyAnIHN0eWxlPVwidGV4dC1hbGlnbjonICsgdG9rZW4uYWxpZ24gKyAnXCInIDogJycpXG4gICAgKyAnPic7XG59O1xucnVsZXMudGRfY2xvc2UgPSBmdW5jdGlvbigvKiB0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPC90ZD4nO1xufTtcblxuLyoqXG4gKiBCb2xkXG4gKi9cblxucnVsZXMuc3Ryb25nX29wZW4gPSBmdW5jdGlvbigvKiB0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPHN0cm9uZz4nO1xufTtcbnJ1bGVzLnN0cm9uZ19jbG9zZSA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8L3N0cm9uZz4nO1xufTtcblxuLyoqXG4gKiBJdGFsaWNpemVcbiAqL1xuXG5ydWxlcy5lbV9vcGVuID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzxlbT4nO1xufTtcbnJ1bGVzLmVtX2Nsb3NlID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzwvZW0+Jztcbn07XG5cbi8qKlxuICogU3RyaWtldGhyb3VnaFxuICovXG5cbnJ1bGVzLmRlbF9vcGVuID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzxkZWw+Jztcbn07XG5ydWxlcy5kZWxfY2xvc2UgPSBmdW5jdGlvbigvKiB0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPC9kZWw+Jztcbn07XG5cbi8qKlxuICogSW5zZXJ0XG4gKi9cblxucnVsZXMuaW5zX29wZW4gPSBmdW5jdGlvbigvKiB0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPGlucz4nO1xufTtcbnJ1bGVzLmluc19jbG9zZSA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8L2lucz4nO1xufTtcblxuLyoqXG4gKiBIaWdobGlnaHRcbiAqL1xuXG5ydWxlcy5tYXJrX29wZW4gPSBmdW5jdGlvbigvKiB0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPG1hcms+Jztcbn07XG5ydWxlcy5tYXJrX2Nsb3NlID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzwvbWFyaz4nO1xufTtcblxuLyoqXG4gKiBTdXBlci0gYW5kIHN1Yi1zY3JpcHRcbiAqL1xuXG5ydWxlcy5zdWIgPSBmdW5jdGlvbih0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPHN1Yj4nICsgZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KSArICc8L3N1Yj4nO1xufTtcbnJ1bGVzLnN1cCA9IGZ1bmN0aW9uKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8c3VwPicgKyBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpICsgJzwvc3VwPic7XG59O1xuXG4vKipcbiAqIEJyZWFrc1xuICovXG5cbnJ1bGVzLmhhcmRicmVhayA9IGZ1bmN0aW9uKHRva2VucywgaWR4LCBvcHRpb25zIC8qLCBlbnYgKi8pIHtcbiAgcmV0dXJuIG9wdGlvbnMueGh0bWxPdXQgPyAnPGJyIC8+XFxuJyA6ICc8YnI+XFxuJztcbn07XG5ydWxlcy5zb2Z0YnJlYWsgPSBmdW5jdGlvbih0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHJldHVybiBvcHRpb25zLmJyZWFrcyA/IChvcHRpb25zLnhodG1sT3V0ID8gJzxiciAvPlxcbicgOiAnPGJyPlxcbicpIDogJ1xcbic7XG59O1xuXG4vKipcbiAqIFRleHRcbiAqL1xuXG5ydWxlcy50ZXh0ID0gZnVuY3Rpb24odG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KTtcbn07XG5cbi8qKlxuICogQ29udGVudFxuICovXG5cbnJ1bGVzLmh0bWxibG9jayA9IGZ1bmN0aW9uKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG59O1xucnVsZXMuaHRtbHRhZyA9IGZ1bmN0aW9uKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG59O1xuXG4vKipcbiAqIEFiYnJldmlhdGlvbnMsIGluaXRpYWxpc21cbiAqL1xuXG5ydWxlcy5hYmJyX29wZW4gPSBmdW5jdGlvbih0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPGFiYnIgdGl0bGU9XCInICsgZXNjYXBlSHRtbChyZXBsYWNlRW50aXRpZXModG9rZW5zW2lkeF0udGl0bGUpKSArICdcIj4nO1xufTtcbnJ1bGVzLmFiYnJfY2xvc2UgPSBmdW5jdGlvbigvKiB0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPC9hYmJyPic7XG59O1xuXG4vKipcbiAqIEZvb3Rub3Rlc1xuICovXG5cbnJ1bGVzLmZvb3Rub3RlX3JlZiA9IGZ1bmN0aW9uKHRva2VucywgaWR4KSB7XG4gIHZhciBuID0gTnVtYmVyKHRva2Vuc1tpZHhdLmlkICsgMSkudG9TdHJpbmcoKTtcbiAgdmFyIGlkID0gJ2ZucmVmJyArIG47XG4gIGlmICh0b2tlbnNbaWR4XS5zdWJJZCA+IDApIHtcbiAgICBpZCArPSAnOicgKyB0b2tlbnNbaWR4XS5zdWJJZDtcbiAgfVxuICByZXR1cm4gJzxzdXAgY2xhc3M9XCJmb290bm90ZS1yZWZcIj48YSBocmVmPVwiI2ZuJyArIG4gKyAnXCIgaWQ9XCInICsgaWQgKyAnXCI+WycgKyBuICsgJ108L2E+PC9zdXA+Jztcbn07XG5ydWxlcy5mb290bm90ZV9ibG9ja19vcGVuID0gZnVuY3Rpb24odG9rZW5zLCBpZHgsIG9wdGlvbnMpIHtcbiAgdmFyIGhyID0gb3B0aW9ucy54aHRtbE91dFxuICAgID8gJzxociBjbGFzcz1cImZvb3Rub3Rlcy1zZXBcIiAvPlxcbidcbiAgICA6ICc8aHIgY2xhc3M9XCJmb290bm90ZXMtc2VwXCI+XFxuJztcbiAgcmV0dXJuIGhyICsgJzxzZWN0aW9uIGNsYXNzPVwiZm9vdG5vdGVzXCI+XFxuPG9sIGNsYXNzPVwiZm9vdG5vdGVzLWxpc3RcIj5cXG4nO1xufTtcbnJ1bGVzLmZvb3Rub3RlX2Jsb2NrX2Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnPC9vbD5cXG48L3NlY3Rpb24+XFxuJztcbn07XG5ydWxlcy5mb290bm90ZV9vcGVuID0gZnVuY3Rpb24odG9rZW5zLCBpZHgpIHtcbiAgdmFyIGlkID0gTnVtYmVyKHRva2Vuc1tpZHhdLmlkICsgMSkudG9TdHJpbmcoKTtcbiAgcmV0dXJuICc8bGkgaWQ9XCJmbicgKyBpZCArICdcIiAgY2xhc3M9XCJmb290bm90ZS1pdGVtXCI+Jztcbn07XG5ydWxlcy5mb290bm90ZV9jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJzwvbGk+XFxuJztcbn07XG5ydWxlcy5mb290bm90ZV9hbmNob3IgPSBmdW5jdGlvbih0b2tlbnMsIGlkeCkge1xuICB2YXIgbiA9IE51bWJlcih0b2tlbnNbaWR4XS5pZCArIDEpLnRvU3RyaW5nKCk7XG4gIHZhciBpZCA9ICdmbnJlZicgKyBuO1xuICBpZiAodG9rZW5zW2lkeF0uc3ViSWQgPiAwKSB7XG4gICAgaWQgKz0gJzonICsgdG9rZW5zW2lkeF0uc3ViSWQ7XG4gIH1cbiAgcmV0dXJuICcgPGEgaHJlZj1cIiMnICsgaWQgKyAnXCIgY2xhc3M9XCJmb290bm90ZS1iYWNrcmVmXCI+4oapPC9hPic7XG59O1xuXG4vKipcbiAqIERlZmluaXRpb24gbGlzdHNcbiAqL1xuXG5ydWxlcy5kbF9vcGVuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnPGRsPlxcbic7XG59O1xucnVsZXMuZHRfb3BlbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJzxkdD4nO1xufTtcbnJ1bGVzLmRkX29wZW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICc8ZGQ+Jztcbn07XG5ydWxlcy5kbF9jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJzwvZGw+XFxuJztcbn07XG5ydWxlcy5kdF9jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJzwvZHQ+XFxuJztcbn07XG5ydWxlcy5kZF9jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJzwvZGQ+XFxuJztcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uc1xuICovXG5cbmZ1bmN0aW9uIG5leHRUb2tlbih0b2tlbnMsIGlkeCkge1xuICBpZiAoKytpZHggPj0gdG9rZW5zLmxlbmd0aCAtIDIpIHtcbiAgICByZXR1cm4gaWR4O1xuICB9XG4gIGlmICgodG9rZW5zW2lkeF0udHlwZSA9PT0gJ3BhcmFncmFwaF9vcGVuJyAmJiB0b2tlbnNbaWR4XS50aWdodCkgJiZcbiAgICAgICh0b2tlbnNbaWR4ICsgMV0udHlwZSA9PT0gJ2lubGluZScgJiYgdG9rZW5zW2lkeCArIDFdLmNvbnRlbnQubGVuZ3RoID09PSAwKSAmJlxuICAgICAgKHRva2Vuc1tpZHggKyAyXS50eXBlID09PSAncGFyYWdyYXBoX2Nsb3NlJyAmJiB0b2tlbnNbaWR4ICsgMl0udGlnaHQpKSB7XG4gICAgcmV0dXJuIG5leHRUb2tlbih0b2tlbnMsIGlkeCArIDIpO1xuICB9XG4gIHJldHVybiBpZHg7XG59XG5cbi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIGBcXG5gIGlzIG5lZWRlZCBiZWZvcmUgdGhlIG5leHQgdG9rZW4uXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGB0b2tlbnNgXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGBpZHhgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IEVtcHR5IHN0cmluZyBvciBuZXdsaW5lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZ2V0QnJlYWsgPSBydWxlcy5nZXRCcmVhayA9IGZ1bmN0aW9uIGdldEJyZWFrKHRva2VucywgaWR4KSB7XG4gIGlkeCA9IG5leHRUb2tlbih0b2tlbnMsIGlkeCk7XG4gIGlmIChpZHggPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tpZHhdLnR5cGUgPT09ICdsaXN0X2l0ZW1fY2xvc2UnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiAnXFxuJztcbn07XG5cbi8qKlxuICogRXhwb3NlIGBydWxlc2BcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJ1bGVzO1xuIiwiLy8gQmxvY2sgcXVvdGVzXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2NrcXVvdGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBuZXh0TGluZSwgbGFzdExpbmVFbXB0eSwgb2xkVFNoaWZ0LCBvbGRCTWFya3MsIG9sZEluZGVudCwgb2xkUGFyZW50VHlwZSwgbGluZXMsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsXG4gICAgICBpLCBsLCB0ZXJtaW5hdGUsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgaWYgKHBvcyA+IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjaGVjayB0aGUgYmxvY2sgcXVvdGUgbWFya2VyXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKykgIT09IDB4M0UvKiA+ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzdGF0ZS5sZXZlbCA+PSBzdGF0ZS5vcHRpb25zLm1heE5lc3RpbmcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gd2Uga25vdyB0aGF0IGl0J3MgZ29pbmcgdG8gYmUgYSB2YWxpZCBibG9ja3F1b3RlLFxuICAvLyBzbyBubyBwb2ludCB0cnlpbmcgdG8gZmluZCB0aGUgZW5kIG9mIGl0IGluIHNpbGVudCBtb2RlXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBza2lwIG9uZSBvcHRpb25hbCBzcGFjZSBhZnRlciAnPidcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjApIHsgcG9zKys7IH1cblxuICBvbGRJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gIHN0YXRlLmJsa0luZGVudCA9IDA7XG5cbiAgb2xkQk1hcmtzID0gWyBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSA9IHBvcztcblxuICAvLyBjaGVjayBpZiB3ZSBoYXZlIGFuIGVtcHR5IGJsb2NrcXVvdGVcbiAgcG9zID0gcG9zIDwgbWF4ID8gc3RhdGUuc2tpcFNwYWNlcyhwb3MpIDogcG9zO1xuICBsYXN0TGluZUVtcHR5ID0gcG9zID49IG1heDtcblxuICBvbGRUU2hpZnQgPSBbIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdIF07XG4gIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG5cbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUucGFyc2VyLnJ1bGVyLmdldFJ1bGVzKCdibG9ja3F1b3RlJyk7XG5cbiAgLy8gU2VhcmNoIHRoZSBlbmQgb2YgdGhlIGJsb2NrXG4gIC8vXG4gIC8vIEJsb2NrIGVuZHMgd2l0aCBlaXRoZXI6XG4gIC8vICAxLiBhbiBlbXB0eSBsaW5lIG91dHNpZGU6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID4gdGVzdFxuICAvL1xuICAvLyAgICAgYGBgXG4gIC8vICAyLiBhbiBlbXB0eSBsaW5lIGluc2lkZTpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPlxuICAvLyAgICAgdGVzdFxuICAvLyAgICAgYGBgXG4gIC8vICAzLiBhbm90aGVyIHRhZ1xuICAvLyAgICAgYGBgXG4gIC8vICAgICA+IHRlc3RcbiAgLy8gICAgICAtIC0gLVxuICAvLyAgICAgYGBgXG4gIGZvciAobmV4dExpbmUgPSBzdGFydExpbmUgKyAxOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaWYgKHBvcyA+PSBtYXgpIHtcbiAgICAgIC8vIENhc2UgMTogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhpcyBsaW5lIGlzIGVtcHR5LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSA9PT0gMHgzRS8qID4gKi8pIHtcbiAgICAgIC8vIFRoaXMgbGluZSBpcyBpbnNpZGUgdGhlIGJsb2NrcXVvdGUuXG5cbiAgICAgIC8vIHNraXAgb25lIG9wdGlvbmFsIHNwYWNlIGFmdGVyICc+J1xuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjApIHsgcG9zKys7IH1cblxuICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5iTWFya3NbbmV4dExpbmVdID0gcG9zO1xuXG4gICAgICBwb3MgPSBwb3MgPCBtYXggPyBzdGF0ZS5za2lwU3BhY2VzKHBvcykgOiBwb3M7XG4gICAgICBsYXN0TGluZUVtcHR5ID0gcG9zID49IG1heDtcblxuICAgICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS50U2hpZnRbbmV4dExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW25leHRMaW5lXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIENhc2UgMjogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhlIGxhc3QgbGluZSB3YXMgZW1wdHkuXG4gICAgaWYgKGxhc3RMaW5lRW1wdHkpIHsgYnJlYWs7IH1cblxuICAgIC8vIENhc2UgMzogYW5vdGhlciB0YWcgZm91bmQuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuXG4gICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG5cbiAgICAvLyBBIG5lZ2F0aXZlIG51bWJlciBtZWFucyB0aGF0IHRoaXMgaXMgYSBwYXJhZ3JhcGggY29udGludWF0aW9uO1xuICAgIC8vXG4gICAgLy8gQW55IG5lZ2F0aXZlIG51bWJlciB3aWxsIGRvIHRoZSBqb2IgaGVyZSwgYnV0IGl0J3MgYmV0dGVyIGZvciBpdFxuICAgIC8vIHRvIGJlIGxhcmdlIGVub3VnaCB0byBtYWtlIGFueSBidWdzIG9idmlvdXMuXG4gICAgc3RhdGUudFNoaWZ0W25leHRMaW5lXSA9IC0xMzM3O1xuICB9XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAnYmxvY2txdW90ZSc7XG4gIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiAnYmxvY2txdW90ZV9vcGVuJyxcbiAgICBsaW5lczogbGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdLFxuICAgIGxldmVsOiBzdGF0ZS5sZXZlbCsrXG4gIH0pO1xuICBzdGF0ZS5wYXJzZXIudG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgbmV4dExpbmUpO1xuICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJ2Jsb2NrcXVvdGVfY2xvc2UnLFxuICAgIGxldmVsOiAtLXN0YXRlLmxldmVsXG4gIH0pO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcbiAgbGluZXNbMV0gPSBzdGF0ZS5saW5lO1xuXG4gIC8vIFJlc3RvcmUgb3JpZ2luYWwgdFNoaWZ0OyB0aGlzIG1pZ2h0IG5vdCBiZSBuZWNlc3Nhcnkgc2luY2UgdGhlIHBhcnNlclxuICAvLyBoYXMgYWxyZWFkeSBiZWVuIGhlcmUsIGJ1dCBqdXN0IHRvIG1ha2Ugc3VyZSB3ZSBjYW4gZG8gdGhhdC5cbiAgZm9yIChpID0gMDsgaSA8IG9sZFRTaGlmdC5sZW5ndGg7IGkrKykge1xuICAgIHN0YXRlLmJNYXJrc1tpICsgc3RhcnRMaW5lXSA9IG9sZEJNYXJrc1tpXTtcbiAgICBzdGF0ZS50U2hpZnRbaSArIHN0YXJ0TGluZV0gPSBvbGRUU2hpZnRbaV07XG4gIH1cbiAgc3RhdGUuYmxrSW5kZW50ID0gb2xkSW5kZW50O1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIENvZGUgYmxvY2sgKDQgc3BhY2VzIHBhZGRlZClcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29kZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLyosIHNpbGVudCovKSB7XG4gIHZhciBuZXh0TGluZSwgbGFzdDtcblxuICBpZiAoc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPCA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhc3QgPSBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgd2hpbGUgKG5leHRMaW5lIDwgZW5kTGluZSkge1xuICAgIGlmIChzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKSkge1xuICAgICAgbmV4dExpbmUrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoc3RhdGUudFNoaWZ0W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICBuZXh0TGluZSsrO1xuICAgICAgbGFzdCA9IG5leHRMaW5lO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJ2NvZGUnLFxuICAgIGNvbnRlbnQ6IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbGFzdCwgNCArIHN0YXRlLmJsa0luZGVudCwgdHJ1ZSksXG4gICAgYmxvY2s6IHRydWUsXG4gICAgbGluZXM6IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF0sXG4gICAgbGV2ZWw6IHN0YXRlLmxldmVsXG4gIH0pO1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIERlZmluaXRpb24gbGlzdHNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIFNlYXJjaCBgWzp+XVtcXG4gXWAsIHJldHVybnMgbmV4dCBwb3MgYWZ0ZXIgbWFya2VyIG9uIHN1Y2Nlc3Ncbi8vIG9yIC0xIG9uIGZhaWwuXG5mdW5jdGlvbiBza2lwTWFya2VyKHN0YXRlLCBsaW5lKSB7XG4gIHZhciBwb3MsIG1hcmtlcixcbiAgICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW2xpbmVdICsgc3RhdGUudFNoaWZ0W2xpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW2xpbmVdO1xuXG4gIGlmIChzdGFydCA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XG5cbiAgLy8gQ2hlY2sgYnVsbGV0XG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KyspO1xuICBpZiAobWFya2VyICE9PSAweDdFLyogfiAqLyAmJiBtYXJrZXIgIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiAtMTsgfVxuXG4gIHBvcyA9IHN0YXRlLnNraXBTcGFjZXMoc3RhcnQpO1xuXG4gIC8vIHJlcXVpcmUgc3BhY2UgYWZ0ZXIgXCI6XCJcbiAgaWYgKHN0YXJ0ID09PSBwb3MpIHsgcmV0dXJuIC0xOyB9XG5cbiAgLy8gbm8gZW1wdHkgZGVmaW5pdGlvbnMsIGUuZy4gXCIgIDogXCJcbiAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XG5cbiAgcmV0dXJuIHBvcztcbn1cblxuZnVuY3Rpb24gbWFya1RpZ2h0UGFyYWdyYXBocyhzdGF0ZSwgaWR4KSB7XG4gIHZhciBpLCBsLFxuICAgICAgbGV2ZWwgPSBzdGF0ZS5sZXZlbCArIDI7XG5cbiAgZm9yIChpID0gaWR4ICsgMiwgbCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAyOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHN0YXRlLnRva2Vuc1tpXS5sZXZlbCA9PT0gbGV2ZWwgJiYgc3RhdGUudG9rZW5zW2ldLnR5cGUgPT09ICdwYXJhZ3JhcGhfb3BlbicpIHtcbiAgICAgIHN0YXRlLnRva2Vuc1tpICsgMl0udGlnaHQgPSB0cnVlO1xuICAgICAgc3RhdGUudG9rZW5zW2ldLnRpZ2h0ID0gdHJ1ZTtcbiAgICAgIGkgKz0gMjtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZsaXN0KHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY29udGVudFN0YXJ0LFxuICAgICAgZGRMaW5lLFxuICAgICAgZHRMaW5lLFxuICAgICAgaXRlbUxpbmVzLFxuICAgICAgbGlzdExpbmVzLFxuICAgICAgbGlzdFRva0lkeCxcbiAgICAgIG5leHRMaW5lLFxuICAgICAgb2xkSW5kZW50LFxuICAgICAgb2xkRERJbmRlbnQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgb2xkVFNoaWZ0LFxuICAgICAgb2xkVGlnaHQsXG4gICAgICBwcmV2RW1wdHlFbmQsXG4gICAgICB0aWdodDtcblxuICBpZiAoc2lsZW50KSB7XG4gICAgLy8gcXVpcms6IHZhbGlkYXRpb24gbW9kZSB2YWxpZGF0ZXMgYSBkZCBibG9jayBvbmx5LCBub3QgYSB3aG9sZSBkZWZsaXN0XG4gICAgaWYgKHN0YXRlLmRkSW5kZW50IDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICByZXR1cm4gc2tpcE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSA+PSAwO1xuICB9XG5cbiAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuICBpZiAoc3RhdGUuaXNFbXB0eShuZXh0TGluZSkpIHtcbiAgICBpZiAoKytuZXh0TGluZSA+IGVuZExpbmUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIH1cblxuICBpZiAoc3RhdGUudFNoaWZ0W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29udGVudFN0YXJ0ID0gc2tpcE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICBpZiAoY29udGVudFN0YXJ0IDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc3RhdGUubGV2ZWwgPj0gc3RhdGUub3B0aW9ucy5tYXhOZXN0aW5nKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFN0YXJ0IGxpc3RcbiAgbGlzdFRva0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG5cbiAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgIHR5cGU6ICdkbF9vcGVuJyxcbiAgICBsaW5lczogbGlzdExpbmVzID0gWyBzdGFydExpbmUsIDAgXSxcbiAgICBsZXZlbDogc3RhdGUubGV2ZWwrK1xuICB9KTtcblxuICAvL1xuICAvLyBJdGVyYXRlIGxpc3QgaXRlbXNcbiAgLy9cblxuICBkdExpbmUgPSBzdGFydExpbmU7XG4gIGRkTGluZSA9IG5leHRMaW5lO1xuXG4gIC8vIE9uZSBkZWZpbml0aW9uIGxpc3QgY2FuIGNvbnRhaW4gbXVsdGlwbGUgRFRzLFxuICAvLyBhbmQgb25lIERUIGNhbiBiZSBmb2xsb3dlZCBieSBtdWx0aXBsZSBERHMuXG4gIC8vXG4gIC8vIFRodXMsIHRoZXJlIGlzIHR3byBsb29wcyBoZXJlLCBhbmQgbGFiZWwgaXNcbiAgLy8gbmVlZGVkIHRvIGJyZWFrIG91dCBvZiB0aGUgc2Vjb25kIG9uZVxuICAvL1xuICAvKmVzbGludCBuby1sYWJlbHM6MCxibG9jay1zY29wZWQtdmFyOjAqL1xuICBPVVRFUjpcbiAgZm9yICg7Oykge1xuICAgIHRpZ2h0ID0gdHJ1ZTtcbiAgICBwcmV2RW1wdHlFbmQgPSBmYWxzZTtcblxuICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgIHR5cGU6ICdkdF9vcGVuJyxcbiAgICAgIGxpbmVzOiBbIGR0TGluZSwgZHRMaW5lIF0sXG4gICAgICBsZXZlbDogc3RhdGUubGV2ZWwrK1xuICAgIH0pO1xuICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgIHR5cGU6ICdpbmxpbmUnLFxuICAgICAgY29udGVudDogc3RhdGUuZ2V0TGluZXMoZHRMaW5lLCBkdExpbmUgKyAxLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCksXG4gICAgICBsZXZlbDogc3RhdGUubGV2ZWwgKyAxLFxuICAgICAgbGluZXM6IFsgZHRMaW5lLCBkdExpbmUgXSxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH0pO1xuICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgIHR5cGU6ICdkdF9jbG9zZScsXG4gICAgICBsZXZlbDogLS1zdGF0ZS5sZXZlbFxuICAgIH0pO1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnZGRfb3BlbicsXG4gICAgICAgIGxpbmVzOiBpdGVtTGluZXMgPSBbIG5leHRMaW5lLCAwIF0sXG4gICAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbCsrXG4gICAgICB9KTtcblxuICAgICAgb2xkVGlnaHQgPSBzdGF0ZS50aWdodDtcbiAgICAgIG9sZERESW5kZW50ID0gc3RhdGUuZGRJbmRlbnQ7XG4gICAgICBvbGRJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgICBvbGRUU2hpZnQgPSBzdGF0ZS50U2hpZnRbZGRMaW5lXTtcbiAgICAgIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICAgICAgc3RhdGUuYmxrSW5kZW50ID0gc3RhdGUuZGRJbmRlbnQgPSBzdGF0ZS50U2hpZnRbZGRMaW5lXSArIDI7XG4gICAgICBzdGF0ZS50U2hpZnRbZGRMaW5lXSA9IGNvbnRlbnRTdGFydCAtIHN0YXRlLmJNYXJrc1tkZExpbmVdO1xuICAgICAgc3RhdGUudGlnaHQgPSB0cnVlO1xuICAgICAgc3RhdGUucGFyZW50VHlwZSA9ICdkZWZsaXN0JztcblxuICAgICAgc3RhdGUucGFyc2VyLnRva2VuaXplKHN0YXRlLCBkZExpbmUsIGVuZExpbmUsIHRydWUpO1xuXG4gICAgICAvLyBJZiBhbnkgb2YgbGlzdCBpdGVtIGlzIHRpZ2h0LCBtYXJrIGxpc3QgYXMgdGlnaHRcbiAgICAgIGlmICghc3RhdGUudGlnaHQgfHwgcHJldkVtcHR5RW5kKSB7XG4gICAgICAgIHRpZ2h0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBJdGVtIGJlY29tZSBsb29zZSBpZiBmaW5pc2ggd2l0aCBlbXB0eSBsaW5lLFxuICAgICAgLy8gYnV0IHdlIHNob3VsZCBmaWx0ZXIgbGFzdCBlbGVtZW50LCBiZWNhdXNlIGl0IG1lYW5zIGxpc3QgZmluaXNoXG4gICAgICBwcmV2RW1wdHlFbmQgPSAoc3RhdGUubGluZSAtIGRkTGluZSkgPiAxICYmIHN0YXRlLmlzRW1wdHkoc3RhdGUubGluZSAtIDEpO1xuXG4gICAgICBzdGF0ZS50U2hpZnRbZGRMaW5lXSA9IG9sZFRTaGlmdDtcbiAgICAgIHN0YXRlLnRpZ2h0ID0gb2xkVGlnaHQ7XG4gICAgICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcbiAgICAgIHN0YXRlLmJsa0luZGVudCA9IG9sZEluZGVudDtcbiAgICAgIHN0YXRlLmRkSW5kZW50ID0gb2xkRERJbmRlbnQ7XG5cbiAgICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2RkX2Nsb3NlJyxcbiAgICAgICAgbGV2ZWw6IC0tc3RhdGUubGV2ZWxcbiAgICAgIH0pO1xuXG4gICAgICBpdGVtTGluZXNbMV0gPSBuZXh0TGluZSA9IHN0YXRlLmxpbmU7XG5cbiAgICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrIE9VVEVSOyB9XG5cbiAgICAgIGlmIChzdGF0ZS50U2hpZnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrIE9VVEVSOyB9XG4gICAgICBjb250ZW50U3RhcnQgPSBza2lwTWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XG4gICAgICBpZiAoY29udGVudFN0YXJ0IDwgMCkgeyBicmVhazsgfVxuXG4gICAgICBkZExpbmUgPSBuZXh0TGluZTtcblxuICAgICAgLy8gZ28gdG8gdGhlIG5leHQgbG9vcCBpdGVyYXRpb246XG4gICAgICAvLyBpbnNlcnQgREQgdGFnIGFuZCByZXBlYXQgY2hlY2tpbmdcbiAgICB9XG5cbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkgeyBicmVhazsgfVxuICAgIGR0TGluZSA9IG5leHRMaW5lO1xuXG4gICAgaWYgKHN0YXRlLmlzRW1wdHkoZHRMaW5lKSkgeyBicmVhazsgfVxuICAgIGlmIChzdGF0ZS50U2hpZnRbZHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgZGRMaW5lID0gZHRMaW5lICsgMTtcbiAgICBpZiAoZGRMaW5lID49IGVuZExpbmUpIHsgYnJlYWs7IH1cbiAgICBpZiAoc3RhdGUuaXNFbXB0eShkZExpbmUpKSB7IGRkTGluZSsrOyB9XG4gICAgaWYgKGRkTGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICBpZiAoc3RhdGUudFNoaWZ0W2RkTGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cbiAgICBjb250ZW50U3RhcnQgPSBza2lwTWFya2VyKHN0YXRlLCBkZExpbmUpO1xuICAgIGlmIChjb250ZW50U3RhcnQgPCAwKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBnbyB0byB0aGUgbmV4dCBsb29wIGl0ZXJhdGlvbjpcbiAgICAvLyBpbnNlcnQgRFQgYW5kIEREIHRhZ3MgYW5kIHJlcGVhdCBjaGVja2luZ1xuICB9XG5cbiAgLy8gRmluaWxpemUgbGlzdFxuICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJ2RsX2Nsb3NlJyxcbiAgICBsZXZlbDogLS1zdGF0ZS5sZXZlbFxuICB9KTtcbiAgbGlzdExpbmVzWzFdID0gbmV4dExpbmU7XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gIC8vIG1hcmsgcGFyYWdyYXBocyB0aWdodCBpZiBuZWVkZWRcbiAgaWYgKHRpZ2h0KSB7XG4gICAgbWFya1RpZ2h0UGFyYWdyYXBocyhzdGF0ZSwgbGlzdFRva0lkeCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBmZW5jZXMgKGBgYCBsYW5nLCB+fn4gbGFuZylcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmVuY2VzKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgbWFya2VyLCBsZW4sIHBhcmFtcywgbmV4dExpbmUsIG1lbSxcbiAgICAgIGhhdmVFbmRNYXJrZXIgPSBmYWxzZSxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICBpZiAocG9zICsgMyA+IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChtYXJrZXIgIT09IDB4N0UvKiB+ICovICYmIG1hcmtlciAhPT0gMHg2MCAvKiBgICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gc2NhbiBtYXJrZXIgbGVuZ3RoXG4gIG1lbSA9IHBvcztcbiAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcblxuICBsZW4gPSBwb3MgLSBtZW07XG5cbiAgaWYgKGxlbiA8IDMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcGFyYW1zID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KS50cmltKCk7XG5cbiAgaWYgKHBhcmFtcy5pbmRleE9mKCdgJykgPj0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBTaW5jZSBzdGFydCBpcyBmb3VuZCwgd2UgY2FuIHJlcG9ydCBzdWNjZXNzIGhlcmUgaW4gdmFsaWRhdGlvbiBtb2RlXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBzZWFyY2ggZW5kIG9mIGJsb2NrXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuXG4gIGZvciAoOzspIHtcbiAgICBuZXh0TGluZSsrO1xuICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7XG4gICAgICAvLyB1bmNsb3NlZCBibG9jayBzaG91bGQgYmUgYXV0b2Nsb3NlZCBieSBlbmQgb2YgZG9jdW1lbnQuXG4gICAgICAvLyBhbHNvIGJsb2NrIHNlZW1zIHRvIGJlIGF1dG9jbG9zZWQgYnkgZW5kIG9mIHBhcmVudFxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcG9zID0gbWVtID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhdGUudFNoaWZ0W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgLy8gbm9uLWVtcHR5IGxpbmUgd2l0aCBuZWdhdGl2ZSBpbmRlbnQgc2hvdWxkIHN0b3AgdGhlIGxpc3Q6XG4gICAgICAvLyAtIGBgYFxuICAgICAgLy8gIHRlc3RcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSBtYXJrZXIpIHsgY29udGludWU7IH1cblxuICAgIGlmIChzdGF0ZS50U2hpZnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgIC8vIGNsb3NpbmcgZmVuY2Ugc2hvdWxkIGJlIGluZGVudGVkIGxlc3MgdGhhbiA0IHNwYWNlc1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcblxuICAgIC8vIGNsb3NpbmcgY29kZSBmZW5jZSBtdXN0IGJlIGF0IGxlYXN0IGFzIGxvbmcgYXMgdGhlIG9wZW5pbmcgb25lXG4gICAgaWYgKHBvcyAtIG1lbSA8IGxlbikgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRhaWwgaGFzIHNwYWNlcyBvbmx5XG4gICAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xuXG4gICAgaWYgKHBvcyA8IG1heCkgeyBjb250aW51ZTsgfVxuXG4gICAgaGF2ZUVuZE1hcmtlciA9IHRydWU7XG4gICAgLy8gZm91bmQhXG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBJZiBhIGZlbmNlIGhhcyBoZWFkaW5nIHNwYWNlcywgdGhleSBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGl0cyBpbm5lciBibG9ja1xuICBsZW4gPSBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmUgKyAoaGF2ZUVuZE1hcmtlciA/IDEgOiAwKTtcbiAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgIHR5cGU6ICdmZW5jZScsXG4gICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgY29udGVudDogc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lICsgMSwgbmV4dExpbmUsIGxlbiwgdHJ1ZSksXG4gICAgbGluZXM6IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF0sXG4gICAgbGV2ZWw6IHN0YXRlLmxldmVsXG4gIH0pO1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFByb2Nlc3MgZm9vdG5vdGUgcmVmZXJlbmNlIGxpc3RcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9vdG5vdGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBvbGRCTWFyaywgb2xkVFNoaWZ0LCBvbGRQYXJlbnRUeXBlLCBwb3MsIGxhYmVsLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gbGluZSBzaG91bGQgYmUgYXQgbGVhc3QgNSBjaGFycyAtIFwiW154XTpcIlxuICBpZiAoc3RhcnQgKyA0ID4gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCkgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQgKyAxKSAhPT0gMHg1RS8qIF4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5sZXZlbCA+PSBzdGF0ZS5vcHRpb25zLm1heE5lc3RpbmcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgZm9yIChwb3MgPSBzdGFydCArIDI7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAocG9zID09PSBzdGFydCArIDIpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIG5vIGVtcHR5IGZvb3Rub3RlIGxhYmVsc1xuICBpZiAocG9zICsgMSA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQoKytwb3MpICE9PSAweDNBIC8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cbiAgcG9zKys7XG5cbiAgaWYgKCFzdGF0ZS5lbnYuZm9vdG5vdGVzKSB7IHN0YXRlLmVudi5mb290bm90ZXMgPSB7fTsgfVxuICBpZiAoIXN0YXRlLmVudi5mb290bm90ZXMucmVmcykgeyBzdGF0ZS5lbnYuZm9vdG5vdGVzLnJlZnMgPSB7fTsgfVxuICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCArIDIsIHBvcyAtIDIpO1xuICBzdGF0ZS5lbnYuZm9vdG5vdGVzLnJlZnNbJzonICsgbGFiZWxdID0gLTE7XG5cbiAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgIHR5cGU6ICdmb290bm90ZV9yZWZlcmVuY2Vfb3BlbicsXG4gICAgbGFiZWw6IGxhYmVsLFxuICAgIGxldmVsOiBzdGF0ZS5sZXZlbCsrXG4gIH0pO1xuXG4gIG9sZEJNYXJrID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG4gIG9sZFRTaGlmdCA9IHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBzdGF0ZS5za2lwU3BhY2VzKHBvcykgLSBwb3M7XG4gIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdID0gcG9zO1xuICBzdGF0ZS5ibGtJbmRlbnQgKz0gNDtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdmb290bm90ZSc7XG5cbiAgaWYgKHN0YXRlLnRTaGlmdFtzdGFydExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gKz0gc3RhdGUuYmxrSW5kZW50O1xuICAgIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdIC09IHN0YXRlLmJsa0luZGVudDtcbiAgfVxuXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCB0cnVlKTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcbiAgc3RhdGUuYmxrSW5kZW50IC09IDQ7XG4gIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gb2xkVFNoaWZ0O1xuICBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSA9IG9sZEJNYXJrO1xuXG4gIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiAnZm9vdG5vdGVfcmVmZXJlbmNlX2Nsb3NlJyxcbiAgICBsZXZlbDogLS1zdGF0ZS5sZXZlbFxuICB9KTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBoZWFkaW5nICgjLCAjIywgLi4uKVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoZWFkaW5nKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsIGxldmVsLCB0bXAsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY2ggID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAoY2ggIT09IDB4MjMvKiAjICovIHx8IHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gY291bnQgaGVhZGluZyBsZXZlbFxuICBsZXZlbCA9IDE7XG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoKytwb3MpO1xuICB3aGlsZSAoY2ggPT09IDB4MjMvKiAjICovICYmIHBvcyA8IG1heCAmJiBsZXZlbCA8PSA2KSB7XG4gICAgbGV2ZWwrKztcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KCsrcG9zKTtcbiAgfVxuXG4gIGlmIChsZXZlbCA+IDYgfHwgKHBvcyA8IG1heCAmJiBjaCAhPT0gMHgyMC8qIHNwYWNlICovKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gTGV0J3MgY3V0IHRhaWxzIGxpa2UgJyAgICAjIyMgICcgZnJvbSB0aGUgZW5kIG9mIHN0cmluZ1xuXG4gIG1heCA9IHN0YXRlLnNraXBDaGFyc0JhY2sobWF4LCAweDIwLCBwb3MpOyAvLyBzcGFjZVxuICB0bXAgPSBzdGF0ZS5za2lwQ2hhcnNCYWNrKG1heCwgMHgyMywgcG9zKTsgLy8gI1xuICBpZiAodG1wID4gcG9zICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHRtcCAtIDEpID09PSAweDIwLyogc3BhY2UgKi8pIHtcbiAgICBtYXggPSB0bXA7XG4gIH1cblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgMTtcblxuICBzdGF0ZS50b2tlbnMucHVzaCh7IHR5cGU6ICdoZWFkaW5nX29wZW4nLFxuICAgIGhMZXZlbDogbGV2ZWwsXG4gICAgbGluZXM6IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF0sXG4gICAgbGV2ZWw6IHN0YXRlLmxldmVsXG4gIH0pO1xuXG4gIC8vIG9ubHkgaWYgaGVhZGVyIGlzIG5vdCBlbXB0eVxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgdHlwZTogJ2lubGluZScsXG4gICAgICBjb250ZW50OiBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpLnRyaW0oKSxcbiAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbCArIDEsXG4gICAgICBsaW5lczogWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXSxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH0pO1xuICB9XG4gIHN0YXRlLnRva2Vucy5wdXNoKHsgdHlwZTogJ2hlYWRpbmdfY2xvc2UnLCBoTGV2ZWw6IGxldmVsLCBsZXZlbDogc3RhdGUubGV2ZWwgfSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gSG9yaXpvbnRhbCBydWxlXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhyKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgbWFya2VyLCBjbnQsIGNoLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICBwb3MgKz0gc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG5cbiAgaWYgKHBvcyA+IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgLy8gQ2hlY2sgaHIgbWFya2VyXG4gIGlmIChtYXJrZXIgIT09IDB4MkEvKiAqICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4MkQvKiAtICovICYmXG4gICAgICBtYXJrZXIgIT09IDB4NUYvKiBfICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gbWFya2VycyBjYW4gYmUgbWl4ZWQgd2l0aCBzcGFjZXMsIGJ1dCB0aGVyZSBzaG91bGQgYmUgYXQgbGVhc3QgMyBvbmVcblxuICBjbnQgPSAxO1xuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgaWYgKGNoICE9PSBtYXJrZXIgJiYgY2ggIT09IDB4MjAvKiBzcGFjZSAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAoY2ggPT09IG1hcmtlcikgeyBjbnQrKzsgfVxuICB9XG5cbiAgaWYgKGNudCA8IDMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyAxO1xuICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJ2hyJyxcbiAgICBsaW5lczogWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXSxcbiAgICBsZXZlbDogc3RhdGUubGV2ZWxcbiAgfSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gSFRNTCBibG9ja1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGJsb2NrX25hbWVzID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfYmxvY2tzJyk7XG5cblxudmFyIEhUTUxfVEFHX09QRU5fUkUgPSAvXjwoW2EtekEtWl17MSwxNX0pW1xcc1xcLz5dLztcbnZhciBIVE1MX1RBR19DTE9TRV9SRSA9IC9ePFxcLyhbYS16QS1aXXsxLDE1fSlbXFxzPl0vO1xuXG5mdW5jdGlvbiBpc0xldHRlcihjaCkge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICB2YXIgbGMgPSBjaCB8IDB4MjA7IC8vIHRvIGxvd2VyIGNhc2VcbiAgcmV0dXJuIChsYyA+PSAweDYxLyogYSAqLykgJiYgKGxjIDw9IDB4N2EvKiB6ICovKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBodG1sYmxvY2soc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbWF0Y2gsIG5leHRMaW5lLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSxcbiAgICAgIHNoaWZ0ID0gc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG5cbiAgcG9zICs9IHNoaWZ0O1xuXG4gIGlmICghc3RhdGUub3B0aW9ucy5odG1sKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaGlmdCA+IDMgfHwgcG9zICsgMiA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG5cbiAgaWYgKGNoID09PSAweDIxLyogISAqLyB8fCBjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAvLyBEaXJlY3RpdmUgc3RhcnQgLyBjb21tZW50IHN0YXJ0IC8gcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBzdGFydFxuICAgIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICB9IGVsc2UgaWYgKGNoID09PSAweDJGLyogLyAqLyB8fCBpc0xldHRlcihjaCkpIHtcblxuICAgIC8vIFByb2JhYmx5IHN0YXJ0IG9yIGVuZCBvZiB0YWdcbiAgICBpZiAoY2ggPT09IDB4MkYvKiBcXCAqLykge1xuICAgICAgLy8gY2xvc2luZyB0YWdcbiAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KS5tYXRjaChIVE1MX1RBR19DTE9TRV9SRSk7XG4gICAgICBpZiAoIW1hdGNoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvcGVuaW5nIHRhZ1xuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpLm1hdGNoKEhUTUxfVEFHX09QRU5fUkUpO1xuICAgICAgaWYgKCFtYXRjaCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHRhZyBuYW1lIGlzIHZhbGlkXG4gICAgaWYgKGJsb2NrX25hbWVzW21hdGNoWzFdLnRvTG93ZXJDYXNlKCldICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIHdlIGFyZSBoZXJlIC0gd2UgZGV0ZWN0ZWQgSFRNTCBibG9jay5cbiAgLy8gTGV0J3Mgcm9sbCBkb3duIHRpbGwgZW1wdHkgbGluZSAoYmxvY2sgZW5kKS5cbiAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuICB3aGlsZSAobmV4dExpbmUgPCBzdGF0ZS5saW5lTWF4ICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKSkge1xuICAgIG5leHRMaW5lKys7XG4gIH1cblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG4gIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiAnaHRtbGJsb2NrJyxcbiAgICBsZXZlbDogc3RhdGUubGV2ZWwsXG4gICAgbGluZXM6IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF0sXG4gICAgY29udGVudDogc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgMCwgdHJ1ZSlcbiAgfSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gbGhlYWRpbmcgKC0tLSwgPT09KVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaGVhZGluZyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLyosIHNpbGVudCovKSB7XG4gIHZhciBtYXJrZXIsIHBvcywgbWF4LFxuICAgICAgbmV4dCA9IHN0YXJ0TGluZSArIDE7XG5cbiAgaWYgKG5leHQgPj0gZW5kTGluZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnRTaGlmdFtuZXh0XSA8IHN0YXRlLmJsa0luZGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBTY2FuIG5leHQgbGluZVxuXG4gIGlmIChzdGF0ZS50U2hpZnRbbmV4dF0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0XSArIHN0YXRlLnRTaGlmdFtuZXh0XTtcbiAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRdO1xuXG4gIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiYgbWFya2VyICE9PSAweDNELyogPSAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuXG4gIHBvcyA9IHN0YXRlLnNraXBTcGFjZXMocG9zKTtcblxuICBpZiAocG9zIDwgbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG5cbiAgc3RhdGUubGluZSA9IG5leHQgKyAxO1xuICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJ2hlYWRpbmdfb3BlbicsXG4gICAgaExldmVsOiBtYXJrZXIgPT09IDB4M0QvKiA9ICovID8gMSA6IDIsXG4gICAgbGluZXM6IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF0sXG4gICAgbGV2ZWw6IHN0YXRlLmxldmVsXG4gIH0pO1xuICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJ2lubGluZScsXG4gICAgY29udGVudDogc3RhdGUuc3JjLnNsaWNlKHBvcywgc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV0pLnRyaW0oKSxcbiAgICBsZXZlbDogc3RhdGUubGV2ZWwgKyAxLFxuICAgIGxpbmVzOiBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSAtIDEgXSxcbiAgICBjaGlsZHJlbjogW11cbiAgfSk7XG4gIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiAnaGVhZGluZ19jbG9zZScsXG4gICAgaExldmVsOiBtYXJrZXIgPT09IDB4M0QvKiA9ICovID8gMSA6IDIsXG4gICAgbGV2ZWw6IHN0YXRlLmxldmVsXG4gIH0pO1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIExpc3RzXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBTZWFyY2ggYFstKypdW1xcbiBdYCwgcmV0dXJucyBuZXh0IHBvcyBhcnRlciBtYXJrZXIgb24gc3VjY2Vzc1xuLy8gb3IgLTEgb24gZmFpbC5cbmZ1bmN0aW9uIHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpIHtcbiAgdmFyIG1hcmtlciwgcG9zLCBtYXg7XG5cbiAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICAvLyBDaGVjayBidWxsZXRcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyQi8qICsgKi8pIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjApIHtcbiAgICAvLyBcIiAxLnRlc3QgXCIgLSBpcyBub3QgYSBsaXN0IGl0ZW1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICByZXR1cm4gcG9zO1xufVxuXG4vLyBTZWFyY2ggYFxcZCtbLildW1xcbiBdYCwgcmV0dXJucyBuZXh0IHBvcyBhcnRlciBtYXJrZXIgb24gc3VjY2Vzc1xuLy8gb3IgLTEgb24gZmFpbC5cbmZ1bmN0aW9uIHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gIHZhciBjaCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICBpZiAocG9zICsgMSA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XG5cbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgaWYgKGNoIDwgMHgzMC8qIDAgKi8gfHwgY2ggPiAweDM5LyogOSAqLykgeyByZXR1cm4gLTE7IH1cblxuICBmb3IgKDs7KSB7XG4gICAgLy8gRU9MIC0+IGZhaWxcbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gLTE7IH1cblxuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gICAgaWYgKGNoID49IDB4MzAvKiAwICovICYmIGNoIDw9IDB4MzkvKiA5ICovKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmb3VuZCB2YWxpZCBtYXJrZXJcbiAgICBpZiAoY2ggPT09IDB4MjkvKiApICovIHx8IGNoID09PSAweDJlLyogLiAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cblxuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjAvKiBzcGFjZSAqLykge1xuICAgIC8vIFwiIDEudGVzdCBcIiAtIGlzIG5vdCBhIGxpc3QgaXRlbVxuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gcG9zO1xufVxuXG5mdW5jdGlvbiBtYXJrVGlnaHRQYXJhZ3JhcGhzKHN0YXRlLCBpZHgpIHtcbiAgdmFyIGksIGwsXG4gICAgICBsZXZlbCA9IHN0YXRlLmxldmVsICsgMjtcblxuICBmb3IgKGkgPSBpZHggKyAyLCBsID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDI7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoc3RhdGUudG9rZW5zW2ldLmxldmVsID09PSBsZXZlbCAmJiBzdGF0ZS50b2tlbnNbaV0udHlwZSA9PT0gJ3BhcmFncmFwaF9vcGVuJykge1xuICAgICAgc3RhdGUudG9rZW5zW2kgKyAyXS50aWdodCA9IHRydWU7XG4gICAgICBzdGF0ZS50b2tlbnNbaV0udGlnaHQgPSB0cnVlO1xuICAgICAgaSArPSAyO1xuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlzdChzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIG5leHRMaW5lLFxuICAgICAgaW5kZW50LFxuICAgICAgb2xkVFNoaWZ0LFxuICAgICAgb2xkSW5kZW50LFxuICAgICAgb2xkVGlnaHQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgc3RhcnQsXG4gICAgICBwb3NBZnRlck1hcmtlcixcbiAgICAgIG1heCxcbiAgICAgIGluZGVudEFmdGVyTWFya2VyLFxuICAgICAgbWFya2VyVmFsdWUsXG4gICAgICBtYXJrZXJDaGFyQ29kZSxcbiAgICAgIGlzT3JkZXJlZCxcbiAgICAgIGNvbnRlbnRTdGFydCxcbiAgICAgIGxpc3RUb2tJZHgsXG4gICAgICBwcmV2RW1wdHlFbmQsXG4gICAgICBsaXN0TGluZXMsXG4gICAgICBpdGVtTGluZXMsXG4gICAgICB0aWdodCA9IHRydWUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsXG4gICAgICBpLCBsLCB0ZXJtaW5hdGU7XG5cbiAgLy8gRGV0ZWN0IGxpc3QgdHlwZSBhbmQgcG9zaXRpb24gYWZ0ZXIgbWFya2VyXG4gIGlmICgocG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkpID49IDApIHtcbiAgICBpc09yZGVyZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XG4gICAgaXNPcmRlcmVkID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxldmVsID49IHN0YXRlLm9wdGlvbnMubWF4TmVzdGluZykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBXZSBzaG91bGQgdGVybWluYXRlIGxpc3Qgb24gc3R5bGUgY2hhbmdlLiBSZW1lbWJlciBmaXJzdCBvbmUgdG8gY29tcGFyZS5cbiAgbWFya2VyQ2hhckNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3NBZnRlck1hcmtlciAtIDEpO1xuXG4gIC8vIEZvciB2YWxpZGF0aW9uIG1vZGUgd2UgY2FuIHRlcm1pbmF0ZSBpbW1lZGlhdGVseVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gU3RhcnQgbGlzdFxuICBsaXN0VG9rSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aDtcblxuICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgc3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICAgIG1hcmtlclZhbHVlID0gTnVtYmVyKHN0YXRlLnNyYy5zdWJzdHIoc3RhcnQsIHBvc0FmdGVyTWFya2VyIC0gc3RhcnQgLSAxKSk7XG5cbiAgICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgICB0eXBlOiAnb3JkZXJlZF9saXN0X29wZW4nLFxuICAgICAgb3JkZXI6IG1hcmtlclZhbHVlLFxuICAgICAgbGluZXM6IGxpc3RMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF0sXG4gICAgICBsZXZlbDogc3RhdGUubGV2ZWwrK1xuICAgIH0pO1xuXG4gIH0gZWxzZSB7XG4gICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgdHlwZTogJ2J1bGxldF9saXN0X29wZW4nLFxuICAgICAgbGluZXM6IGxpc3RMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF0sXG4gICAgICBsZXZlbDogc3RhdGUubGV2ZWwrK1xuICAgIH0pO1xuICB9XG5cbiAgLy9cbiAgLy8gSXRlcmF0ZSBsaXN0IGl0ZW1zXG4gIC8vXG5cbiAgbmV4dExpbmUgPSBzdGFydExpbmU7XG4gIHByZXZFbXB0eUVuZCA9IGZhbHNlO1xuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5wYXJzZXIucnVsZXIuZ2V0UnVsZXMoJ2xpc3QnKTtcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgY29udGVudFN0YXJ0ID0gc3RhdGUuc2tpcFNwYWNlcyhwb3NBZnRlck1hcmtlcik7XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGlmIChjb250ZW50U3RhcnQgPj0gbWF4KSB7XG4gICAgICAvLyB0cmltbWluZyBzcGFjZSBpbiBcIi0gICAgXFxuICAzXCIgY2FzZSwgaW5kZW50IGlzIDEgaGVyZVxuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRlbnRBZnRlck1hcmtlciA9IGNvbnRlbnRTdGFydCAtIHBvc0FmdGVyTWFya2VyO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIDQgc3BhY2VzLCB0aGUgaW5kZW50IGlzIDFcbiAgICAvLyAodGhlIHJlc3QgaXMganVzdCBpbmRlbnRlZCBjb2RlIGJsb2NrKVxuICAgIGlmIChpbmRlbnRBZnRlck1hcmtlciA+IDQpIHsgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxOyB9XG5cbiAgICAvLyBJZiBpbmRlbnQgaXMgbGVzcyB0aGFuIDEsIGFzc3VtZSB0aGF0IGl0J3Mgb25lLCBleGFtcGxlOlxuICAgIC8vICBcIi1cXG4gIHRlc3RcIlxuICAgIGlmIChpbmRlbnRBZnRlck1hcmtlciA8IDEpIHsgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxOyB9XG5cbiAgICAvLyBcIiAgLSAgdGVzdFwiXG4gICAgLy8gIF5eXl5eIC0gY2FsY3VsYXRpbmcgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdGhpbmdcbiAgICBpbmRlbnQgPSAocG9zQWZ0ZXJNYXJrZXIgLSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdKSArIGluZGVudEFmdGVyTWFya2VyO1xuXG4gICAgLy8gUnVuIHN1YnBhcnNlciAmIHdyaXRlIHRva2Vuc1xuICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgIHR5cGU6ICdsaXN0X2l0ZW1fb3BlbicsXG4gICAgICBsaW5lczogaXRlbUxpbmVzID0gWyBzdGFydExpbmUsIDAgXSxcbiAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbCsrXG4gICAgfSk7XG5cbiAgICBvbGRJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgb2xkVGlnaHQgPSBzdGF0ZS50aWdodDtcbiAgICBvbGRUU2hpZnQgPSBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IGNvbnRlbnRTdGFydCAtIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdO1xuICAgIHN0YXRlLmJsa0luZGVudCA9IGluZGVudDtcbiAgICBzdGF0ZS50aWdodCA9IHRydWU7XG4gICAgc3RhdGUucGFyZW50VHlwZSA9ICdsaXN0JztcblxuICAgIHN0YXRlLnBhcnNlci50b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCB0cnVlKTtcblxuICAgIC8vIElmIGFueSBvZiBsaXN0IGl0ZW0gaXMgdGlnaHQsIG1hcmsgbGlzdCBhcyB0aWdodFxuICAgIGlmICghc3RhdGUudGlnaHQgfHwgcHJldkVtcHR5RW5kKSB7XG4gICAgICB0aWdodCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBJdGVtIGJlY29tZSBsb29zZSBpZiBmaW5pc2ggd2l0aCBlbXB0eSBsaW5lLFxuICAgIC8vIGJ1dCB3ZSBzaG91bGQgZmlsdGVyIGxhc3QgZWxlbWVudCwgYmVjYXVzZSBpdCBtZWFucyBsaXN0IGZpbmlzaFxuICAgIHByZXZFbXB0eUVuZCA9IChzdGF0ZS5saW5lIC0gc3RhcnRMaW5lKSA+IDEgJiYgc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSk7XG5cbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBvbGRJbmRlbnQ7XG4gICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBvbGRUU2hpZnQ7XG4gICAgc3RhdGUudGlnaHQgPSBvbGRUaWdodDtcbiAgICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgIHR5cGU6ICdsaXN0X2l0ZW1fY2xvc2UnLFxuICAgICAgbGV2ZWw6IC0tc3RhdGUubGV2ZWxcbiAgICB9KTtcblxuICAgIG5leHRMaW5lID0gc3RhcnRMaW5lID0gc3RhdGUubGluZTtcbiAgICBpdGVtTGluZXNbMV0gPSBuZXh0TGluZTtcbiAgICBjb250ZW50U3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcblxuICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICBpZiAoc3RhdGUuaXNFbXB0eShuZXh0TGluZSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gVHJ5IHRvIGNoZWNrIGlmIGxpc3QgaXMgdGVybWluYXRlZCBvciBjb250aW51ZWQuXG4gICAgLy9cbiAgICBpZiAoc3RhdGUudFNoaWZ0W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgLy8gZmFpbCBpZiB0ZXJtaW5hdGluZyBibG9jayBmb3VuZFxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cblxuICAgIC8vIGZhaWwgaWYgbGlzdCBoYXMgYW5vdGhlciB0eXBlXG4gICAgaWYgKGlzT3JkZXJlZCkge1xuICAgICAgcG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIG5leHRMaW5lKTtcbiAgICAgIGlmIChwb3NBZnRlck1hcmtlciA8IDApIHsgYnJlYWs7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgcG9zQWZ0ZXJNYXJrZXIgPSBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIGlmIChtYXJrZXJDaGFyQ29kZSAhPT0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKSkgeyBicmVhazsgfVxuICB9XG5cbiAgLy8gRmluaWxpemUgbGlzdFxuICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgdHlwZTogaXNPcmRlcmVkID8gJ29yZGVyZWRfbGlzdF9jbG9zZScgOiAnYnVsbGV0X2xpc3RfY2xvc2UnLFxuICAgIGxldmVsOiAtLXN0YXRlLmxldmVsXG4gIH0pO1xuICBsaXN0TGluZXNbMV0gPSBuZXh0TGluZTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgLy8gbWFyayBwYXJhZ3JhcGhzIHRpZ2h0IGlmIG5lZWRlZFxuICBpZiAodGlnaHQpIHtcbiAgICBtYXJrVGlnaHRQYXJhZ3JhcGhzKHN0YXRlLCBsaXN0VG9rSWR4KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFBhcmFncmFwaFxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJhZ3JhcGgoc3RhdGUsIHN0YXJ0TGluZS8qLCBlbmRMaW5lKi8pIHtcbiAgdmFyIGVuZExpbmUsIGNvbnRlbnQsIHRlcm1pbmF0ZSwgaSwgbCxcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcztcblxuICBlbmRMaW5lID0gc3RhdGUubGluZU1heDtcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIGlmIChuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpKSB7XG4gICAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUucGFyc2VyLnJ1bGVyLmdldFJ1bGVzKCdwYXJhZ3JhcGgnKTtcblxuICAgIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgICAgLy8gaXQncyBjb25zaWRlcmVkIGEgbGF6eSBjb250aW51YXRpb24gcmVnYXJkbGVzcyBvZiB3aGF0J3MgdGhlcmVcbiAgICAgIGlmIChzdGF0ZS50U2hpZnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gICAgfVxuICB9XG5cbiAgY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG4gIGlmIChjb250ZW50Lmxlbmd0aCkge1xuICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgIHR5cGU6ICdwYXJhZ3JhcGhfb3BlbicsXG4gICAgICB0aWdodDogZmFsc2UsXG4gICAgICBsaW5lczogWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXSxcbiAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbFxuICAgIH0pO1xuICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgIHR5cGU6ICdpbmxpbmUnLFxuICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbCArIDEsXG4gICAgICBsaW5lczogWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXSxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH0pO1xuICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgIHR5cGU6ICdwYXJhZ3JhcGhfY2xvc2UnLFxuICAgICAgdGlnaHQ6IGZhbHNlLFxuICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQYXJzZXIgc3RhdGUgY2xhc3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIFN0YXRlQmxvY2soc3JjLCBwYXJzZXIsIG9wdGlvbnMsIGVudiwgdG9rZW5zKSB7XG4gIHZhciBjaCwgcywgc3RhcnQsIHBvcywgbGVuLCBpbmRlbnQsIGluZGVudF9mb3VuZDtcblxuICB0aGlzLnNyYyA9IHNyYztcblxuICAvLyBTaG9ydGN1dHMgdG8gc2ltcGxpZnkgbmVzdGVkIGNhbGxzXG4gIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgdGhpcy5lbnYgPSBlbnY7XG5cbiAgLy9cbiAgLy8gSW50ZXJuYWwgc3RhdGUgdmFydGlhYmxlc1xuICAvL1xuXG4gIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuXG4gIHRoaXMuYk1hcmtzID0gW107ICAvLyBsaW5lIGJlZ2luIG9mZnNldHMgZm9yIGZhc3QganVtcHNcbiAgdGhpcy5lTWFya3MgPSBbXTsgIC8vIGxpbmUgZW5kIG9mZnNldHMgZm9yIGZhc3QganVtcHNcbiAgdGhpcy50U2hpZnQgPSBbXTsgIC8vIGluZGVudCBmb3IgZWFjaCBsaW5lXG5cbiAgLy8gYmxvY2sgcGFyc2VyIHZhcmlhYmxlc1xuICB0aGlzLmJsa0luZGVudCAgPSAwOyAvLyByZXF1aXJlZCBibG9jayBjb250ZW50IGluZGVudFxuICAgICAgICAgICAgICAgICAgICAgICAvLyAoZm9yIGV4YW1wbGUsIGlmIHdlIGFyZSBpbiBsaXN0KVxuICB0aGlzLmxpbmUgICAgICAgPSAwOyAvLyBsaW5lIGluZGV4IGluIHNyY1xuICB0aGlzLmxpbmVNYXggICAgPSAwOyAvLyBsaW5lcyBjb3VudFxuICB0aGlzLnRpZ2h0ICAgICAgPSBmYWxzZTsgIC8vIGxvb3NlL3RpZ2h0IG1vZGUgZm9yIGxpc3RzXG4gIHRoaXMucGFyZW50VHlwZSA9ICdyb290JzsgLy8gaWYgYGxpc3RgLCBibG9jayBwYXJzZXIgc3RvcHMgb24gdHdvIG5ld2xpbmVzXG4gIHRoaXMuZGRJbmRlbnQgICA9IC0xOyAvLyBpbmRlbnQgb2YgdGhlIGN1cnJlbnQgZGQgYmxvY2sgKC0xIGlmIHRoZXJlIGlzbid0IGFueSlcblxuICB0aGlzLmxldmVsID0gMDtcblxuICAvLyByZW5kZXJlclxuICB0aGlzLnJlc3VsdCA9ICcnO1xuXG4gIC8vIENyZWF0ZSBjYWNoZXNcbiAgLy8gR2VuZXJhdGUgbWFya2Vycy5cbiAgcyA9IHRoaXMuc3JjO1xuICBpbmRlbnQgPSAwO1xuICBpbmRlbnRfZm91bmQgPSBmYWxzZTtcblxuICBmb3IgKHN0YXJ0ID0gcG9zID0gaW5kZW50ID0gMCwgbGVuID0gcy5sZW5ndGg7IHBvcyA8IGxlbjsgcG9zKyspIHtcbiAgICBjaCA9IHMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpbmRlbnRfZm91bmQpIHtcbiAgICAgIGlmIChjaCA9PT0gMHgyMC8qIHNwYWNlICovKSB7XG4gICAgICAgIGluZGVudCsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGVudF9mb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDBBIHx8IHBvcyA9PT0gbGVuIC0gMSkge1xuICAgICAgaWYgKGNoICE9PSAweDBBKSB7IHBvcysrOyB9XG4gICAgICB0aGlzLmJNYXJrcy5wdXNoKHN0YXJ0KTtcbiAgICAgIHRoaXMuZU1hcmtzLnB1c2gocG9zKTtcbiAgICAgIHRoaXMudFNoaWZ0LnB1c2goaW5kZW50KTtcblxuICAgICAgaW5kZW50X2ZvdW5kID0gZmFsc2U7XG4gICAgICBpbmRlbnQgPSAwO1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1c2ggZmFrZSBlbnRyeSB0byBzaW1wbGlmeSBjYWNoZSBib3VuZHMgY2hlY2tzXG4gIHRoaXMuYk1hcmtzLnB1c2gocy5sZW5ndGgpO1xuICB0aGlzLmVNYXJrcy5wdXNoKHMubGVuZ3RoKTtcbiAgdGhpcy50U2hpZnQucHVzaCgwKTtcblxuICB0aGlzLmxpbmVNYXggPSB0aGlzLmJNYXJrcy5sZW5ndGggLSAxOyAvLyBkb24ndCBjb3VudCBsYXN0IGZha2UgbGluZVxufVxuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eShsaW5lKSB7XG4gIHJldHVybiB0aGlzLmJNYXJrc1tsaW5lXSArIHRoaXMudFNoaWZ0W2xpbmVdID49IHRoaXMuZU1hcmtzW2xpbmVdO1xufTtcblxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcEVtcHR5TGluZXMgPSBmdW5jdGlvbiBza2lwRW1wdHlMaW5lcyhmcm9tKSB7XG4gIGZvciAodmFyIG1heCA9IHRoaXMubGluZU1heDsgZnJvbSA8IG1heDsgZnJvbSsrKSB7XG4gICAgaWYgKHRoaXMuYk1hcmtzW2Zyb21dICsgdGhpcy50U2hpZnRbZnJvbV0gPCB0aGlzLmVNYXJrc1tmcm9tXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmcm9tO1xufTtcblxuLy8gU2tpcCBzcGFjZXMgZnJvbSBnaXZlbiBwb3NpdGlvbi5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBTcGFjZXMgPSBmdW5jdGlvbiBza2lwU3BhY2VzKHBvcykge1xuICBmb3IgKHZhciBtYXggPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBpZiAodGhpcy5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDIwLyogc3BhY2UgKi8pIHsgYnJlYWs7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gU2tpcCBjaGFyIGNvZGVzIGZyb20gZ2l2ZW4gcG9zaXRpb25cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBDaGFycyA9IGZ1bmN0aW9uIHNraXBDaGFycyhwb3MsIGNvZGUpIHtcbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5zcmMubGVuZ3RoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgaWYgKHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gY29kZSkgeyBicmVhazsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBTa2lwIGNoYXIgY29kZXMgcmV2ZXJzZSBmcm9tIGdpdmVuIHBvc2l0aW9uIC0gMVxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcENoYXJzQmFjayA9IGZ1bmN0aW9uIHNraXBDaGFyc0JhY2socG9zLCBjb2RlLCBtaW4pIHtcbiAgaWYgKHBvcyA8PSBtaW4pIHsgcmV0dXJuIHBvczsgfVxuXG4gIHdoaWxlIChwb3MgPiBtaW4pIHtcbiAgICBpZiAoY29kZSAhPT0gdGhpcy5zcmMuY2hhckNvZGVBdCgtLXBvcykpIHsgcmV0dXJuIHBvcyArIDE7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gY3V0IGxpbmVzIHJhbmdlIGZyb20gc291cmNlLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuZ2V0TGluZXMgPSBmdW5jdGlvbiBnZXRMaW5lcyhiZWdpbiwgZW5kLCBpbmRlbnQsIGtlZXBMYXN0TEYpIHtcbiAgdmFyIGksIGZpcnN0LCBsYXN0LCBxdWV1ZSwgc2hpZnQsXG4gICAgICBsaW5lID0gYmVnaW47XG5cbiAgaWYgKGJlZ2luID49IGVuZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIE9wdDogZG9uJ3QgdXNlIHB1c2ggcXVldWUgZm9yIHNpbmdsZSBsaW5lO1xuICBpZiAobGluZSArIDEgPT09IGVuZCkge1xuICAgIGZpcnN0ID0gdGhpcy5iTWFya3NbbGluZV0gKyBNYXRoLm1pbih0aGlzLnRTaGlmdFtsaW5lXSwgaW5kZW50KTtcbiAgICBsYXN0ID0ga2VlcExhc3RMRiA/IHRoaXMuZU1hcmtzW2xpbmVdICsgMSA6IHRoaXMuZU1hcmtzW2xpbmVdO1xuICAgIHJldHVybiB0aGlzLnNyYy5zbGljZShmaXJzdCwgbGFzdCk7XG4gIH1cblxuICBxdWV1ZSA9IG5ldyBBcnJheShlbmQgLSBiZWdpbik7XG5cbiAgZm9yIChpID0gMDsgbGluZSA8IGVuZDsgbGluZSsrLCBpKyspIHtcbiAgICBzaGlmdCA9IHRoaXMudFNoaWZ0W2xpbmVdO1xuICAgIGlmIChzaGlmdCA+IGluZGVudCkgeyBzaGlmdCA9IGluZGVudDsgfVxuICAgIGlmIChzaGlmdCA8IDApIHsgc2hpZnQgPSAwOyB9XG5cbiAgICBmaXJzdCA9IHRoaXMuYk1hcmtzW2xpbmVdICsgc2hpZnQ7XG5cbiAgICBpZiAobGluZSArIDEgPCBlbmQgfHwga2VlcExhc3RMRikge1xuICAgICAgLy8gTm8gbmVlZCBmb3IgYm91bmRzIGNoZWNrIGJlY2F1c2Ugd2UgaGF2ZSBmYWtlIGVudHJ5IG9uIHRhaWwuXG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV0gKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV07XG4gICAgfVxuXG4gICAgcXVldWVbaV0gPSB0aGlzLnNyYy5zbGljZShmaXJzdCwgbGFzdCk7XG4gIH1cblxuICByZXR1cm4gcXVldWUuam9pbignJyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVCbG9jaztcbiIsIi8vIEdGTSB0YWJsZSwgbm9uLXN0YW5kYXJkXG5cbid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBnZXRMaW5lKHN0YXRlLCBsaW5lKSB7XG4gIHZhciBwb3MgPSBzdGF0ZS5iTWFya3NbbGluZV0gKyBzdGF0ZS5ibGtJbmRlbnQsXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbGluZV07XG5cbiAgcmV0dXJuIHN0YXRlLnNyYy5zdWJzdHIocG9zLCBtYXggLSBwb3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRhYmxlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsIGxpbmVUZXh0LCBwb3MsIGksIG5leHRMaW5lLCByb3dzLCBjZWxsLFxuICAgICAgYWxpZ25zLCB0LCB0YWJsZUxpbmVzLCB0Ym9keUxpbmVzO1xuXG4gIC8vIHNob3VsZCBoYXZlIGF0IGxlYXN0IHRocmVlIGxpbmVzXG4gIGlmIChzdGFydExpbmUgKyAyID4gZW5kTGluZSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgaWYgKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzZWNvbmQgbGluZSBzaG91bGQgYmUgJ3wnIG9yICctJ1xuXG4gIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICBpZiAocG9zID49IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICBpZiAoY2ggIT09IDB4N0MvKiB8ICovICYmIGNoICE9PSAweDJELyogLSAqLyAmJiBjaCAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBzdGFydExpbmUgKyAxKTtcbiAgaWYgKCEvXlstOnwgXSskLy50ZXN0KGxpbmVUZXh0KSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICByb3dzID0gbGluZVRleHQuc3BsaXQoJ3wnKTtcbiAgaWYgKHJvd3MgPD0gMikgeyByZXR1cm4gZmFsc2U7IH1cbiAgYWxpZ25zID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgdCA9IHJvd3NbaV0udHJpbSgpO1xuICAgIGlmICghdCkge1xuICAgICAgLy8gYWxsb3cgZW1wdHkgY29sdW1ucyBiZWZvcmUgYW5kIGFmdGVyIHRhYmxlLCBidXQgbm90IGluIGJldHdlZW4gY29sdW1ucztcbiAgICAgIC8vIGUuZy4gYWxsb3cgYCB8LS0tfCBgLCBkaXNhbGxvdyBgIC0tLXx8LS0tIGBcbiAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IHJvd3MubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eOj8tKzo/JC8udGVzdCh0KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAodC5jaGFyQ29kZUF0KHQubGVuZ3RoIC0gMSkgPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBhbGlnbnMucHVzaCh0LmNoYXJDb2RlQXQoMCkgPT09IDB4M0EvKiA6ICovID8gJ2NlbnRlcicgOiAncmlnaHQnKTtcbiAgICB9IGVsc2UgaWYgKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGFsaWducy5wdXNoKCdsZWZ0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsaWducy5wdXNoKCcnKTtcbiAgICB9XG4gIH1cblxuICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSkudHJpbSgpO1xuICBpZiAobGluZVRleHQuaW5kZXhPZignfCcpID09PSAtMSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgcm93cyA9IGxpbmVUZXh0LnJlcGxhY2UoL15cXHx8XFx8JC9nLCAnJykuc3BsaXQoJ3wnKTtcbiAgaWYgKGFsaWducy5sZW5ndGggIT09IHJvd3MubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgIHR5cGU6ICd0YWJsZV9vcGVuJyxcbiAgICBsaW5lczogdGFibGVMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF0sXG4gICAgbGV2ZWw6IHN0YXRlLmxldmVsKytcbiAgfSk7XG4gIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiAndGhlYWRfb3BlbicsXG4gICAgbGluZXM6IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF0sXG4gICAgbGV2ZWw6IHN0YXRlLmxldmVsKytcbiAgfSk7XG5cbiAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgIHR5cGU6ICd0cl9vcGVuJyxcbiAgICBsaW5lczogWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXSxcbiAgICBsZXZlbDogc3RhdGUubGV2ZWwrK1xuICB9KTtcbiAgZm9yIChpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgICB0eXBlOiAndGhfb3BlbicsXG4gICAgICBhbGlnbjogYWxpZ25zW2ldLFxuICAgICAgbGluZXM6IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF0sXG4gICAgICBsZXZlbDogc3RhdGUubGV2ZWwrK1xuICAgIH0pO1xuICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgIHR5cGU6ICdpbmxpbmUnLFxuICAgICAgY29udGVudDogcm93c1tpXS50cmltKCksXG4gICAgICBsaW5lczogWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXSxcbiAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbCxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH0pO1xuICAgIHN0YXRlLnRva2Vucy5wdXNoKHsgdHlwZTogJ3RoX2Nsb3NlJywgbGV2ZWw6IC0tc3RhdGUubGV2ZWwgfSk7XG4gIH1cbiAgc3RhdGUudG9rZW5zLnB1c2goeyB0eXBlOiAndHJfY2xvc2UnLCBsZXZlbDogLS1zdGF0ZS5sZXZlbCB9KTtcbiAgc3RhdGUudG9rZW5zLnB1c2goeyB0eXBlOiAndGhlYWRfY2xvc2UnLCBsZXZlbDogLS1zdGF0ZS5sZXZlbCB9KTtcblxuICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJ3Rib2R5X29wZW4nLFxuICAgIGxpbmVzOiB0Ym9keUxpbmVzID0gWyBzdGFydExpbmUgKyAyLCAwIF0sXG4gICAgbGV2ZWw6IHN0YXRlLmxldmVsKytcbiAgfSk7XG5cbiAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDI7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgIGlmIChzdGF0ZS50U2hpZnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIG5leHRMaW5lKS50cmltKCk7XG4gICAgaWYgKGxpbmVUZXh0LmluZGV4T2YoJ3wnKSA9PT0gLTEpIHsgYnJlYWs7IH1cbiAgICByb3dzID0gbGluZVRleHQucmVwbGFjZSgvXlxcfHxcXHwkL2csICcnKS5zcGxpdCgnfCcpO1xuXG4gICAgc3RhdGUudG9rZW5zLnB1c2goeyB0eXBlOiAndHJfb3BlbicsIGxldmVsOiBzdGF0ZS5sZXZlbCsrIH0pO1xuICAgIGZvciAoaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGF0ZS50b2tlbnMucHVzaCh7IHR5cGU6ICd0ZF9vcGVuJywgYWxpZ246IGFsaWduc1tpXSwgbGV2ZWw6IHN0YXRlLmxldmVsKysgfSk7XG4gICAgICAvLyAweDdjID09PSAnfCdcbiAgICAgIGNlbGwgPSByb3dzW2ldLnN1YnN0cmluZyhcbiAgICAgICAgICByb3dzW2ldLmNoYXJDb2RlQXQoMCkgPT09IDB4N2MgPyAxIDogMCxcbiAgICAgICAgICByb3dzW2ldLmNoYXJDb2RlQXQocm93c1tpXS5sZW5ndGggLSAxKSA9PT0gMHg3YyA/IHJvd3NbaV0ubGVuZ3RoIC0gMSA6IHJvd3NbaV0ubGVuZ3RoXG4gICAgICApLnRyaW0oKTtcbiAgICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2lubGluZScsXG4gICAgICAgIGNvbnRlbnQ6IGNlbGwsXG4gICAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbCxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICB9KTtcbiAgICAgIHN0YXRlLnRva2Vucy5wdXNoKHsgdHlwZTogJ3RkX2Nsb3NlJywgbGV2ZWw6IC0tc3RhdGUubGV2ZWwgfSk7XG4gICAgfVxuICAgIHN0YXRlLnRva2Vucy5wdXNoKHsgdHlwZTogJ3RyX2Nsb3NlJywgbGV2ZWw6IC0tc3RhdGUubGV2ZWwgfSk7XG4gIH1cbiAgc3RhdGUudG9rZW5zLnB1c2goeyB0eXBlOiAndGJvZHlfY2xvc2UnLCBsZXZlbDogLS1zdGF0ZS5sZXZlbCB9KTtcbiAgc3RhdGUudG9rZW5zLnB1c2goeyB0eXBlOiAndGFibGVfY2xvc2UnLCBsZXZlbDogLS1zdGF0ZS5sZXZlbCB9KTtcblxuICB0YWJsZUxpbmVzWzFdID0gdGJvZHlMaW5lc1sxXSA9IG5leHRMaW5lO1xuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFBhcnNlIGFiYnJldmlhdGlvbiBkZWZpbml0aW9ucywgaS5lLiBgKlthYmJyXTogZGVzY3JpcHRpb25gXG4vL1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFN0YXRlSW5saW5lICAgID0gcmVxdWlyZSgnLi4vcnVsZXNfaW5saW5lL3N0YXRlX2lubGluZScpO1xudmFyIHBhcnNlTGlua0xhYmVsID0gcmVxdWlyZSgnLi4vaGVscGVycy9wYXJzZV9saW5rX2xhYmVsJyk7XG5cblxuZnVuY3Rpb24gcGFyc2VBYmJyKHN0ciwgcGFyc2VySW5saW5lLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIHN0YXRlLCBsYWJlbEVuZCwgcG9zLCBtYXgsIGxhYmVsLCB0aXRsZTtcblxuICBpZiAoc3RyLmNoYXJDb2RlQXQoMCkgIT09IDB4MkEvKiAqICovKSB7IHJldHVybiAtMTsgfVxuICBpZiAoc3RyLmNoYXJDb2RlQXQoMSkgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiAtMTsgfVxuXG4gIGlmIChzdHIuaW5kZXhPZignXTonKSA9PT0gLTEpIHsgcmV0dXJuIC0xOyB9XG5cbiAgc3RhdGUgPSBuZXcgU3RhdGVJbmxpbmUoc3RyLCBwYXJzZXJJbmxpbmUsIG9wdGlvbnMsIGVudiwgW10pO1xuICBsYWJlbEVuZCA9IHBhcnNlTGlua0xhYmVsKHN0YXRlLCAxKTtcblxuICBpZiAobGFiZWxFbmQgPCAwIHx8IHN0ci5jaGFyQ29kZUF0KGxhYmVsRW5kICsgMSkgIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiAtMTsgfVxuXG4gIG1heCA9IHN0YXRlLnBvc01heDtcblxuICAvLyBhYmJyIHRpdGxlIGlzIGFsd2F5cyBvbmUgbGluZSwgc28gbG9va2luZyBmb3IgZW5kaW5nIFwiXFxuXCIgaGVyZVxuICBmb3IgKHBvcyA9IGxhYmVsRW5kICsgMjsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDBBKSB7IGJyZWFrOyB9XG4gIH1cblxuICBsYWJlbCA9IHN0ci5zbGljZSgyLCBsYWJlbEVuZCk7XG4gIHRpdGxlID0gc3RyLnNsaWNlKGxhYmVsRW5kICsgMiwgcG9zKS50cmltKCk7XG4gIGlmICh0aXRsZS5sZW5ndGggPT09IDApIHsgcmV0dXJuIC0xOyB9XG4gIGlmICghZW52LmFiYnJldmlhdGlvbnMpIHsgZW52LmFiYnJldmlhdGlvbnMgPSB7fTsgfVxuICAvLyBwcmVwZW5kICc6JyB0byBhdm9pZCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgbWVtYmVyc1xuICBpZiAodHlwZW9mIGVudi5hYmJyZXZpYXRpb25zWyc6JyArIGxhYmVsXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbnYuYWJicmV2aWF0aW9uc1snOicgKyBsYWJlbF0gPSB0aXRsZTtcbiAgfVxuXG4gIHJldHVybiBwb3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWJicihzdGF0ZSkge1xuICB2YXIgdG9rZW5zID0gc3RhdGUudG9rZW5zLCBpLCBsLCBjb250ZW50LCBwb3M7XG5cbiAgaWYgKHN0YXRlLmlubGluZU1vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBQYXJzZSBpbmxpbmVzXG4gIGZvciAoaSA9IDEsIGwgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA8IGw7IGkrKykge1xuICAgIGlmICh0b2tlbnNbaSAtIDFdLnR5cGUgPT09ICdwYXJhZ3JhcGhfb3BlbicgJiZcbiAgICAgICAgdG9rZW5zW2ldLnR5cGUgPT09ICdpbmxpbmUnICYmXG4gICAgICAgIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3BhcmFncmFwaF9jbG9zZScpIHtcblxuICAgICAgY29udGVudCA9IHRva2Vuc1tpXS5jb250ZW50O1xuICAgICAgd2hpbGUgKGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIHBvcyA9IHBhcnNlQWJicihjb250ZW50LCBzdGF0ZS5pbmxpbmUsIHN0YXRlLm9wdGlvbnMsIHN0YXRlLmVudik7XG4gICAgICAgIGlmIChwb3MgPCAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKHBvcykudHJpbSgpO1xuICAgICAgfVxuXG4gICAgICB0b2tlbnNbaV0uY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICBpZiAoIWNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIHRva2Vuc1tpIC0gMV0udGlnaHQgPSB0cnVlO1xuICAgICAgICB0b2tlbnNbaSArIDFdLnRpZ2h0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4iLCIvLyBFbmNsb3NlIGFiYnJldmlhdGlvbnMgaW4gPGFiYnI+IHRhZ3Ncbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFBVTkNUX0NIQVJTID0gJyBcXG4oKVtdXFwnXCIuLCE/LSc7XG5cblxuLy8gZnJvbSBHb29nbGUgY2xvc3VyZSBsaWJyYXJ5XG4vLyBodHRwOi8vY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC1oaXN0b3J5L2RvY3MvbG9jYWxfY2xvc3VyZV9nb29nX3N0cmluZ19zdHJpbmcuanMuc291cmNlLmh0bWwjbGluZTEwMjFcbmZ1bmN0aW9uIHJlZ0VzY2FwZShzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoLyhbLSgpXFxbXFxde30rPyouJFxcXnwsOiM8IVxcXFxdKS9nLCAnXFxcXCQxJyk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhYmJyMihzdGF0ZSkge1xuICB2YXIgaSwgaiwgbCwgdG9rZW5zLCB0b2tlbiwgdGV4dCwgbm9kZXMsIHBvcywgbGV2ZWwsIHJlZywgbSwgcmVnVGV4dCxcbiAgICAgIGJsb2NrVG9rZW5zID0gc3RhdGUudG9rZW5zO1xuXG4gIGlmICghc3RhdGUuZW52LmFiYnJldmlhdGlvbnMpIHsgcmV0dXJuOyB9XG4gIGlmICghc3RhdGUuZW52LmFiYnJSZWdFeHApIHtcbiAgICByZWdUZXh0ID0gJyhefFsnICsgUFVOQ1RfQ0hBUlMuc3BsaXQoJycpLm1hcChyZWdFc2NhcGUpLmpvaW4oJycpICsgJ10pJ1xuICAgICAgICAgICAgKyAnKCcgKyBPYmplY3Qua2V5cyhzdGF0ZS5lbnYuYWJicmV2aWF0aW9ucykubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHguc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH0pLm1hcChyZWdFc2NhcGUpLmpvaW4oJ3wnKSArICcpJ1xuICAgICAgICAgICAgKyAnKCR8WycgKyBQVU5DVF9DSEFSUy5zcGxpdCgnJykubWFwKHJlZ0VzY2FwZSkuam9pbignJykgKyAnXSknO1xuICAgIHN0YXRlLmVudi5hYmJyUmVnRXhwID0gbmV3IFJlZ0V4cChyZWdUZXh0LCAnZycpO1xuICB9XG4gIHJlZyA9IHN0YXRlLmVudi5hYmJyUmVnRXhwO1xuXG4gIGZvciAoaiA9IDAsIGwgPSBibG9ja1Rva2Vucy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICBpZiAoYmxvY2tUb2tlbnNbal0udHlwZSAhPT0gJ2lubGluZScpIHsgY29udGludWU7IH1cbiAgICB0b2tlbnMgPSBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbjtcblxuICAgIC8vIFdlIHNjYW4gZnJvbSB0aGUgZW5kLCB0byBrZWVwIHBvc2l0aW9uIHdoZW4gbmV3IHRhZ3MgYWRkZWQuXG4gICAgZm9yIChpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIGlmICh0b2tlbi50eXBlICE9PSAndGV4dCcpIHsgY29udGludWU7IH1cblxuICAgICAgcG9zID0gMDtcbiAgICAgIHRleHQgPSB0b2tlbi5jb250ZW50O1xuICAgICAgcmVnLmxhc3RJbmRleCA9IDA7XG4gICAgICBsZXZlbCA9IHRva2VuLmxldmVsO1xuICAgICAgbm9kZXMgPSBbXTtcblxuICAgICAgd2hpbGUgKChtID0gcmVnLmV4ZWModGV4dCkpKSB7XG4gICAgICAgIGlmIChyZWcubGFzdEluZGV4ID4gcG9zKSB7XG4gICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICBjb250ZW50OiB0ZXh0LnNsaWNlKHBvcywgbS5pbmRleCArIG1bMV0ubGVuZ3RoKSxcbiAgICAgICAgICAgIGxldmVsOiBsZXZlbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ2FiYnJfb3BlbicsXG4gICAgICAgICAgdGl0bGU6IHN0YXRlLmVudi5hYmJyZXZpYXRpb25zWyc6JyArIG1bMl1dLFxuICAgICAgICAgIGxldmVsOiBsZXZlbCsrXG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgY29udGVudDogbVsyXSxcbiAgICAgICAgICBsZXZlbDogbGV2ZWxcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdhYmJyX2Nsb3NlJyxcbiAgICAgICAgICBsZXZlbDogLS1sZXZlbFxuICAgICAgICB9KTtcbiAgICAgICAgcG9zID0gcmVnLmxhc3RJbmRleCAtIG1bM10ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW5vZGVzLmxlbmd0aCkgeyBjb250aW51ZTsgfVxuXG4gICAgICBpZiAocG9zIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIGNvbnRlbnQ6IHRleHQuc2xpY2UocG9zKSxcbiAgICAgICAgICBsZXZlbDogbGV2ZWxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlcGxhY2UgY3VycmVudCBub2RlXG4gICAgICBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbiA9IHRva2VucyA9IFtdLmNvbmNhdCh0b2tlbnMuc2xpY2UoMCwgaSksIG5vZGVzLCB0b2tlbnMuc2xpY2UoaSArIDEpKTtcbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2soc3RhdGUpIHtcblxuICBpZiAoc3RhdGUuaW5saW5lTW9kZSkge1xuICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgIHR5cGU6ICdpbmxpbmUnLFxuICAgICAgY29udGVudDogc3RhdGUuc3JjLnJlcGxhY2UoL1xcbi9nLCAnICcpLnRyaW0oKSxcbiAgICAgIGxldmVsOiAwLFxuICAgICAgbGluZXM6IFsgMCwgMSBdLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5ibG9jay5wYXJzZShzdGF0ZS5zcmMsIHN0YXRlLm9wdGlvbnMsIHN0YXRlLmVudiwgc3RhdGUudG9rZW5zKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvb3Rub3RlX2Jsb2NrKHN0YXRlKSB7XG4gIHZhciBpLCBsLCBqLCB0LCBsYXN0UGFyYWdyYXBoLCBsaXN0LCB0b2tlbnMsIGN1cnJlbnQsIGN1cnJlbnRMYWJlbCxcbiAgICAgIGxldmVsID0gMCxcbiAgICAgIGluc2lkZVJlZiA9IGZhbHNlLFxuICAgICAgcmVmVG9rZW5zID0ge307XG5cbiAgaWYgKCFzdGF0ZS5lbnYuZm9vdG5vdGVzKSB7IHJldHVybjsgfVxuXG4gIHN0YXRlLnRva2VucyA9IHN0YXRlLnRva2Vucy5maWx0ZXIoZnVuY3Rpb24odG9rKSB7XG4gICAgaWYgKHRvay50eXBlID09PSAnZm9vdG5vdGVfcmVmZXJlbmNlX29wZW4nKSB7XG4gICAgICBpbnNpZGVSZWYgPSB0cnVlO1xuICAgICAgY3VycmVudCA9IFtdO1xuICAgICAgY3VycmVudExhYmVsID0gdG9rLmxhYmVsO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodG9rLnR5cGUgPT09ICdmb290bm90ZV9yZWZlcmVuY2VfY2xvc2UnKSB7XG4gICAgICBpbnNpZGVSZWYgPSBmYWxzZTtcbiAgICAgIC8vIHByZXBlbmQgJzonIHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBtZW1iZXJzXG4gICAgICByZWZUb2tlbnNbJzonICsgY3VycmVudExhYmVsXSA9IGN1cnJlbnQ7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbnNpZGVSZWYpIHsgY3VycmVudC5wdXNoKHRvayk7IH1cbiAgICByZXR1cm4gIWluc2lkZVJlZjtcbiAgfSk7XG5cbiAgaWYgKCFzdGF0ZS5lbnYuZm9vdG5vdGVzLmxpc3QpIHsgcmV0dXJuOyB9XG4gIGxpc3QgPSBzdGF0ZS5lbnYuZm9vdG5vdGVzLmxpc3Q7XG5cbiAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgIHR5cGU6ICdmb290bm90ZV9ibG9ja19vcGVuJyxcbiAgICBsZXZlbDogbGV2ZWwrK1xuICB9KTtcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgdHlwZTogJ2Zvb3Rub3RlX29wZW4nLFxuICAgICAgaWQ6IGksXG4gICAgICBsZXZlbDogbGV2ZWwrK1xuICAgIH0pO1xuXG4gICAgaWYgKGxpc3RbaV0udG9rZW5zKSB7XG4gICAgICB0b2tlbnMgPSBbXTtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3BhcmFncmFwaF9vcGVuJyxcbiAgICAgICAgdGlnaHQ6IGZhbHNlLFxuICAgICAgICBsZXZlbDogbGV2ZWwrK1xuICAgICAgfSk7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdpbmxpbmUnLFxuICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICBjaGlsZHJlbjogbGlzdFtpXS50b2tlbnNcbiAgICAgIH0pO1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAncGFyYWdyYXBoX2Nsb3NlJyxcbiAgICAgICAgdGlnaHQ6IGZhbHNlLFxuICAgICAgICBsZXZlbDogLS1sZXZlbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChsaXN0W2ldLmxhYmVsKSB7XG4gICAgICB0b2tlbnMgPSByZWZUb2tlbnNbJzonICsgbGlzdFtpXS5sYWJlbF07XG4gICAgfVxuXG4gICAgc3RhdGUudG9rZW5zID0gc3RhdGUudG9rZW5zLmNvbmNhdCh0b2tlbnMpO1xuICAgIGlmIChzdGF0ZS50b2tlbnNbc3RhdGUudG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgPT09ICdwYXJhZ3JhcGhfY2xvc2UnKSB7XG4gICAgICBsYXN0UGFyYWdyYXBoID0gc3RhdGUudG9rZW5zLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0UGFyYWdyYXBoID0gbnVsbDtcbiAgICB9XG5cbiAgICB0ID0gbGlzdFtpXS5jb3VudCA+IDAgPyBsaXN0W2ldLmNvdW50IDogMTtcbiAgICBmb3IgKGogPSAwOyBqIDwgdDsgaisrKSB7XG4gICAgICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdmb290bm90ZV9hbmNob3InLFxuICAgICAgICBpZDogaSxcbiAgICAgICAgc3ViSWQ6IGosXG4gICAgICAgIGxldmVsOiBsZXZlbFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RQYXJhZ3JhcGgpIHtcbiAgICAgIHN0YXRlLnRva2Vucy5wdXNoKGxhc3RQYXJhZ3JhcGgpO1xuICAgIH1cblxuICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgIHR5cGU6ICdmb290bm90ZV9jbG9zZScsXG4gICAgICBsZXZlbDogLS1sZXZlbFxuICAgIH0pO1xuICB9XG4gIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiAnZm9vdG5vdGVfYmxvY2tfY2xvc2UnLFxuICAgIGxldmVsOiAtLWxldmVsXG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmxpbmUoc3RhdGUpIHtcbiAgdmFyIHRva2VucyA9IHN0YXRlLnRva2VucywgdG9rLCBpLCBsO1xuXG4gIC8vIFBhcnNlIGlubGluZXNcbiAgZm9yIChpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0b2sgPSB0b2tlbnNbaV07XG4gICAgaWYgKHRvay50eXBlID09PSAnaW5saW5lJykge1xuICAgICAgc3RhdGUuaW5saW5lLnBhcnNlKHRvay5jb250ZW50LCBzdGF0ZS5vcHRpb25zLCBzdGF0ZS5lbnYsIHRvay5jaGlsZHJlbik7XG4gICAgfVxuICB9XG59O1xuIiwiLy8gUmVwbGFjZSBsaW5rLWxpa2UgdGV4dHMgd2l0aCBsaW5rIG5vZGVzLlxuLy9cbi8vIEN1cnJlbnRseSByZXN0cmljdGVkIGJ5IGBpbmxpbmUudmFsaWRhdGVMaW5rKClgIHRvIGh0dHAvaHR0cHMvZnRwXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBBdXRvbGlua2VyID0gcmVxdWlyZSgnYXV0b2xpbmtlcicpO1xuXG5cbnZhciBMSU5LX1NDQU5fUkUgPSAvd3d3fEB8XFw6XFwvXFwvLztcblxuXG5mdW5jdGlvbiBpc0xpbmtPcGVuKHN0cikge1xuICByZXR1cm4gL148YVs+XFxzXS9pLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGlzTGlua0Nsb3NlKHN0cikge1xuICByZXR1cm4gL148XFwvYVxccyo+L2kudGVzdChzdHIpO1xufVxuXG4vLyBTdHVwaWQgZmFicmljIHRvIGF2b2lkIHNpbmdsZXRvbnMsIGZvciB0aHJlYWQgc2FmZXR5LlxuLy8gUmVxdWlyZWQgZm9yIGVuZ2luZXMgbGlrZSBOYXNob3JuLlxuLy9cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtpZmllcigpIHtcbiAgdmFyIGxpbmtzID0gW107XG4gIHZhciBhdXRvbGlua2VyID0gbmV3IEF1dG9saW5rZXIoe1xuICAgIHN0cmlwUHJlZml4OiBmYWxzZSxcbiAgICB1cmw6IHRydWUsXG4gICAgZW1haWw6IHRydWUsXG4gICAgdHdpdHRlcjogZmFsc2UsXG4gICAgcmVwbGFjZUZuOiBmdW5jdGlvbiAobGlua2VyLCBtYXRjaCkge1xuICAgICAgLy8gT25seSBjb2xsZWN0IG1hdGNoZWQgc3RyaW5ncyBidXQgZG9uJ3QgY2hhbmdlIGFueXRoaW5nLlxuICAgICAgc3dpdGNoIChtYXRjaC5nZXRUeXBlKCkpIHtcbiAgICAgICAgLyplc2xpbnQgZGVmYXVsdC1jYXNlOjAqL1xuICAgICAgICBjYXNlICd1cmwnOlxuICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2gubWF0Y2hlZFRleHQsXG4gICAgICAgICAgICB1cmw6IG1hdGNoLmdldFVybCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2VtYWlsJzpcbiAgICAgICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoLm1hdGNoZWRUZXh0LFxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGVtYWlsIHByb3RvY29sXG4gICAgICAgICAgICB1cmw6ICdtYWlsdG86JyArIG1hdGNoLmdldEVtYWlsKCkucmVwbGFjZSgvXm1haWx0bzovaSwgJycpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGxpbmtzOiBsaW5rcyxcbiAgICBhdXRvbGlua2VyOiBhdXRvbGlua2VyXG4gIH07XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5raWZ5KHN0YXRlKSB7XG4gIHZhciBpLCBqLCBsLCB0b2tlbnMsIHRva2VuLCB0ZXh0LCBub2RlcywgbG4sIHBvcywgbGV2ZWwsIGh0bWxMaW5rTGV2ZWwsXG4gICAgICBibG9ja1Rva2VucyA9IHN0YXRlLnRva2VucyxcbiAgICAgIGxpbmtpZmllciA9IG51bGwsIGxpbmtzLCBhdXRvbGlua2VyO1xuXG4gIGlmICghc3RhdGUub3B0aW9ucy5saW5raWZ5KSB7IHJldHVybjsgfVxuXG4gIGZvciAoaiA9IDAsIGwgPSBibG9ja1Rva2Vucy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICBpZiAoYmxvY2tUb2tlbnNbal0udHlwZSAhPT0gJ2lubGluZScpIHsgY29udGludWU7IH1cbiAgICB0b2tlbnMgPSBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbjtcblxuICAgIGh0bWxMaW5rTGV2ZWwgPSAwO1xuXG4gICAgLy8gV2Ugc2NhbiBmcm9tIHRoZSBlbmQsIHRvIGtlZXAgcG9zaXRpb24gd2hlbiBuZXcgdGFncyBhZGRlZC5cbiAgICAvLyBVc2UgcmV2ZXJzZWQgbG9naWMgaW4gbGlua3Mgc3RhcnQvZW5kIG1hdGNoXG4gICAgZm9yIChpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgLy8gU2tpcCBjb250ZW50IG9mIG1hcmtkb3duIGxpbmtzXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmtfY2xvc2UnKSB7XG4gICAgICAgIGktLTtcbiAgICAgICAgd2hpbGUgKHRva2Vuc1tpXS5sZXZlbCAhPT0gdG9rZW4ubGV2ZWwgJiYgdG9rZW5zW2ldLnR5cGUgIT09ICdsaW5rX29wZW4nKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGNvbnRlbnQgb2YgaHRtbCB0YWcgbGlua3NcbiAgICAgIGlmICh0b2tlbi50eXBlID09PSAnaHRtbHRhZycpIHtcbiAgICAgICAgaWYgKGlzTGlua09wZW4odG9rZW4uY29udGVudCkgJiYgaHRtbExpbmtMZXZlbCA+IDApIHtcbiAgICAgICAgICBodG1sTGlua0xldmVsLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGlua0Nsb3NlKHRva2VuLmNvbnRlbnQpKSB7XG4gICAgICAgICAgaHRtbExpbmtMZXZlbCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaHRtbExpbmtMZXZlbCA+IDApIHsgY29udGludWU7IH1cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiBMSU5LX1NDQU5fUkUudGVzdCh0b2tlbi5jb250ZW50KSkge1xuXG4gICAgICAgIC8vIEluaXQgbGlua2lmaWVyIGluIGxhenkgbWFubmVyLCBvbmx5IGlmIHJlcXVpcmVkLlxuICAgICAgICBpZiAoIWxpbmtpZmllcikge1xuICAgICAgICAgIGxpbmtpZmllciA9IGNyZWF0ZUxpbmtpZmllcigpO1xuICAgICAgICAgIGxpbmtzID0gbGlua2lmaWVyLmxpbmtzO1xuICAgICAgICAgIGF1dG9saW5rZXIgPSBsaW5raWZpZXIuYXV0b2xpbmtlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHQgPSB0b2tlbi5jb250ZW50O1xuICAgICAgICBsaW5rcy5sZW5ndGggPSAwO1xuICAgICAgICBhdXRvbGlua2VyLmxpbmsodGV4dCk7XG5cbiAgICAgICAgaWYgKCFsaW5rcy5sZW5ndGgpIHsgY29udGludWU7IH1cblxuICAgICAgICAvLyBOb3cgc3BsaXQgc3RyaW5nIHRvIG5vZGVzXG4gICAgICAgIG5vZGVzID0gW107XG4gICAgICAgIGxldmVsID0gdG9rZW4ubGV2ZWw7XG5cbiAgICAgICAgZm9yIChsbiA9IDA7IGxuIDwgbGlua3MubGVuZ3RoOyBsbisrKSB7XG5cbiAgICAgICAgICBpZiAoIXN0YXRlLmlubGluZS52YWxpZGF0ZUxpbmsobGlua3NbbG5dLnVybCkpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIHBvcyA9IHRleHQuaW5kZXhPZihsaW5rc1tsbl0udGV4dCk7XG5cbiAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICBsZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgY29udGVudDogdGV4dC5zbGljZSgwLCBwb3MpLFxuICAgICAgICAgICAgICBsZXZlbDogbGV2ZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdsaW5rX29wZW4nLFxuICAgICAgICAgICAgaHJlZjogbGlua3NbbG5dLnVybCxcbiAgICAgICAgICAgIHRpdGxlOiAnJyxcbiAgICAgICAgICAgIGxldmVsOiBsZXZlbCsrXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICBjb250ZW50OiBsaW5rc1tsbl0udGV4dCxcbiAgICAgICAgICAgIGxldmVsOiBsZXZlbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2xpbmtfY2xvc2UnLFxuICAgICAgICAgICAgbGV2ZWw6IC0tbGV2ZWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShwb3MgKyBsaW5rc1tsbl0udGV4dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgY29udGVudDogdGV4dCxcbiAgICAgICAgICAgIGxldmVsOiBsZXZlbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjZSBjdXJyZW50IG5vZGVcbiAgICAgICAgYmxvY2tUb2tlbnNbal0uY2hpbGRyZW4gPSB0b2tlbnMgPSBbXS5jb25jYXQodG9rZW5zLnNsaWNlKDAsIGkpLCBub2RlcywgdG9rZW5zLnNsaWNlKGkgKyAxKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTdGF0ZUlubGluZSAgICAgICAgICA9IHJlcXVpcmUoJy4uL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUnKTtcbnZhciBwYXJzZUxpbmtMYWJlbCAgICAgICA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbCcpO1xudmFyIHBhcnNlTGlua0Rlc3RpbmF0aW9uID0gcmVxdWlyZSgnLi4vaGVscGVycy9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uJyk7XG52YXIgcGFyc2VMaW5rVGl0bGUgICAgICAgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUnKTtcbnZhciBub3JtYWxpemVSZWZlcmVuY2UgICA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvbm9ybWFsaXplX3JlZmVyZW5jZScpO1xuXG5cbmZ1bmN0aW9uIHBhcnNlUmVmZXJlbmNlKHN0ciwgcGFyc2VyLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIHN0YXRlLCBsYWJlbEVuZCwgcG9zLCBtYXgsIGNvZGUsIHN0YXJ0LCBocmVmLCB0aXRsZSwgbGFiZWw7XG5cbiAgaWYgKHN0ci5jaGFyQ29kZUF0KDApICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gLTE7IH1cblxuICBpZiAoc3RyLmluZGV4T2YoJ106JykgPT09IC0xKSB7IHJldHVybiAtMTsgfVxuXG4gIHN0YXRlID0gbmV3IFN0YXRlSW5saW5lKHN0ciwgcGFyc2VyLCBvcHRpb25zLCBlbnYsIFtdKTtcbiAgbGFiZWxFbmQgPSBwYXJzZUxpbmtMYWJlbChzdGF0ZSwgMCk7XG5cbiAgaWYgKGxhYmVsRW5kIDwgMCB8fCBzdHIuY2hhckNvZGVBdChsYWJlbEVuZCArIDEpICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gLTE7IH1cblxuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICBeXl4gc2tpcCBvcHRpb25hbCB3aGl0ZXNwYWNlIGhlcmVcbiAgZm9yIChwb3MgPSBsYWJlbEVuZCArIDI7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY29kZSAhPT0gMHgyMCAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gIH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgIF5eXl5eXl5eXl5eIHBhcnNlIHRoaXNcbiAgaWYgKCFwYXJzZUxpbmtEZXN0aW5hdGlvbihzdGF0ZSwgcG9zKSkgeyByZXR1cm4gLTE7IH1cbiAgaHJlZiA9IHN0YXRlLmxpbmtDb250ZW50O1xuICBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIF5eXiBza2lwcGluZyB0aG9zZSBzcGFjZXNcbiAgc3RhcnQgPSBwb3M7XG4gIGZvciAocG9zID0gcG9zICsgMTsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjb2RlICE9PSAweDIwICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNlIHRoaXNcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHBhcnNlTGlua1RpdGxlKHN0YXRlLCBwb3MpKSB7XG4gICAgdGl0bGUgPSBzdGF0ZS5saW5rQ29udGVudDtcbiAgICBwb3MgPSBzdGF0ZS5wb3M7XG4gIH0gZWxzZSB7XG4gICAgdGl0bGUgPSAnJztcbiAgICBwb3MgPSBzdGFydDtcbiAgfVxuXG4gIC8vIGVuc3VyZSB0aGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgaXMgZW1wdHlcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwLyogc3BhY2UgKi8pIHsgcG9zKys7IH1cbiAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDBBKSB7IHJldHVybiAtMTsgfVxuXG4gIGxhYmVsID0gbm9ybWFsaXplUmVmZXJlbmNlKHN0ci5zbGljZSgxLCBsYWJlbEVuZCkpO1xuICBpZiAodHlwZW9mIGVudi5yZWZlcmVuY2VzW2xhYmVsXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbnYucmVmZXJlbmNlc1tsYWJlbF0gPSB7IHRpdGxlOiB0aXRsZSwgaHJlZjogaHJlZiB9O1xuICB9XG5cbiAgcmV0dXJuIHBvcztcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlZmVyZW5jZXMoc3RhdGUpIHtcbiAgdmFyIHRva2VucyA9IHN0YXRlLnRva2VucywgaSwgbCwgY29udGVudCwgcG9zO1xuXG4gIHN0YXRlLmVudi5yZWZlcmVuY2VzID0gc3RhdGUuZW52LnJlZmVyZW5jZXMgfHwge307XG5cbiAgaWYgKHN0YXRlLmlubGluZU1vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBTY2FuIGRlZmluaXRpb25zIGluIHBhcmFncmFwaCBpbmxpbmVzXG4gIGZvciAoaSA9IDEsIGwgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA8IGw7IGkrKykge1xuICAgIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gJ2lubGluZScgJiZcbiAgICAgICAgdG9rZW5zW2kgLSAxXS50eXBlID09PSAncGFyYWdyYXBoX29wZW4nICYmXG4gICAgICAgIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3BhcmFncmFwaF9jbG9zZScpIHtcblxuICAgICAgY29udGVudCA9IHRva2Vuc1tpXS5jb250ZW50O1xuICAgICAgd2hpbGUgKGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIHBvcyA9IHBhcnNlUmVmZXJlbmNlKGNvbnRlbnQsIHN0YXRlLmlubGluZSwgc3RhdGUub3B0aW9ucywgc3RhdGUuZW52KTtcbiAgICAgICAgaWYgKHBvcyA8IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UocG9zKS50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIHRva2Vuc1tpXS5jb250ZW50ID0gY29udGVudDtcbiAgICAgIGlmICghY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgdG9rZW5zW2kgLSAxXS50aWdodCA9IHRydWU7XG4gICAgICAgIHRva2Vuc1tpICsgMV0udGlnaHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbiIsIi8vIFNpbXBsZSB0eXBvZ3JhcGhpY2FsIHJlcGxhY2VtZW50c1xuLy9cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzpcbi8vIC0gZnJhY3Rpb25hbHMgMS8yLCAxLzQsIDMvNCAtPiDCvSwgwrwsIMK+XG4vLyAtIG1pbHRpcGxpY2F0aW9uIDIgeCA0IC0+IDIgw5cgNFxuXG52YXIgUkFSRV9SRSA9IC9cXCstfFxcLlxcLnxcXD9cXD9cXD9cXD98ISEhIXwsLHwtLS87XG5cbnZhciBTQ09QRURfQUJCUl9SRSA9IC9cXCgoY3x0bXxyfHApXFwpL2lnO1xudmFyIFNDT1BFRF9BQkJSID0ge1xuICAnYyc6ICfCqScsXG4gICdyJzogJ8KuJyxcbiAgJ3AnOiAnwqcnLFxuICAndG0nOiAn4oSiJ1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZVNjb3BlZEFiYnIoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignKCcpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFNDT1BFRF9BQkJSX1JFLCBmdW5jdGlvbihtYXRjaCwgbmFtZSkge1xuICAgIHJldHVybiBTQ09QRURfQUJCUltuYW1lLnRvTG93ZXJDYXNlKCldO1xuICB9KTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAgdmFyIGksIHRva2VuLCB0ZXh0LCBpbmxpbmVUb2tlbnMsIGJsa0lkeDtcblxuICBpZiAoIXN0YXRlLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gJ2lubGluZScpIHsgY29udGludWU7IH1cblxuICAgIGlubGluZVRva2VucyA9IHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuO1xuXG4gICAgZm9yIChpID0gaW5saW5lVG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0b2tlbiA9IGlubGluZVRva2Vuc1tpXTtcbiAgICAgIGlmICh0b2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgdGV4dCA9IHRva2VuLmNvbnRlbnQ7XG5cbiAgICAgICAgdGV4dCA9IHJlcGxhY2VTY29wZWRBYmJyKHRleHQpO1xuXG4gICAgICAgIGlmIChSQVJFX1JFLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcKy0vZywgJ8KxJylcbiAgICAgICAgICAgIC8vIC4uLCAuLi4sIC4uLi4uLi4gLT4g4oCmXG4gICAgICAgICAgICAvLyBidXQgPy4uLi4uICYgIS4uLi4uIC0+ID8uLiAmICEuLlxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcLnsyLH0vZywgJ+KApicpLnJlcGxhY2UoLyhbPyFdKeKApi9nLCAnJDEuLicpXG4gICAgICAgICAgICAucmVwbGFjZSgvKFs/IV0pezQsfS9nLCAnJDEkMSQxJykucmVwbGFjZSgvLHsyLH0vZywgJywnKVxuICAgICAgICAgICAgLy8gZW0tZGFzaFxuICAgICAgICAgICAgLnJlcGxhY2UoLyhefFteLV0pLS0tKFteLV18JCkvbWcsICckMVxcdTIwMTQkMicpXG4gICAgICAgICAgICAvLyBlbi1kYXNoXG4gICAgICAgICAgICAucmVwbGFjZSgvKF58XFxzKS0tKFxcc3wkKS9tZywgJyQxXFx1MjAxMyQyJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXnxbXi1cXHNdKS0tKFteLVxcc118JCkvbWcsICckMVxcdTIwMTMkMicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW4uY29udGVudCA9IHRleHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIiwiLy8gQ29udmVydCBzdHJhaWdodCBxdW90YXRpb24gbWFya3MgdG8gdHlwb2dyYXBoaWMgb25lc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgUVVPVEVfVEVTVF9SRSA9IC9bJ1wiXS87XG52YXIgUVVPVEVfUkUgPSAvWydcIl0vZztcbnZhciBQVU5DVF9SRSA9IC9bLVxccygpXFxbXFxdXS87XG52YXIgQVBPU1RST1BIRSA9ICfigJknO1xuXG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGF0IGBwb3NgXG4vLyBjb3VsZCBiZSBpbnNpZGUgYSB3b3JkLlxuZnVuY3Rpb24gaXNMZXR0ZXIoc3RyLCBwb3MpIHtcbiAgaWYgKHBvcyA8IDAgfHwgcG9zID49IHN0ci5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiAhUFVOQ1RfUkUudGVzdChzdHJbcG9zXSk7XG59XG5cblxuZnVuY3Rpb24gcmVwbGFjZUF0KHN0ciwgaW5kZXgsIGNoKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKDAsIGluZGV4KSArIGNoICsgc3RyLnN1YnN0cihpbmRleCArIDEpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc21hcnRxdW90ZXMoc3RhdGUpIHtcbiAgLyplc2xpbnQgbWF4LWRlcHRoOjAqL1xuICB2YXIgaSwgdG9rZW4sIHRleHQsIHQsIHBvcywgbWF4LCB0aGlzTGV2ZWwsIGxhc3RTcGFjZSwgbmV4dFNwYWNlLCBpdGVtLFxuICAgICAgY2FuT3BlbiwgY2FuQ2xvc2UsIGosIGlzU2luZ2xlLCBibGtJZHgsIHRva2VucyxcbiAgICAgIHN0YWNrO1xuXG4gIGlmICghc3RhdGUub3B0aW9ucy50eXBvZ3JhcGhlcikgeyByZXR1cm47IH1cblxuICBzdGFjayA9IFtdO1xuXG4gIGZvciAoYmxrSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDE7IGJsa0lkeCA+PSAwOyBibGtJZHgtLSkge1xuXG4gICAgaWYgKHN0YXRlLnRva2Vuc1tibGtJZHhdLnR5cGUgIT09ICdpbmxpbmUnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICB0b2tlbnMgPSBzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbjtcbiAgICBzdGFjay5sZW5ndGggPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIGlmICh0b2tlbi50eXBlICE9PSAndGV4dCcgfHwgUVVPVEVfVEVTVF9SRS50ZXN0KHRva2VuLnRleHQpKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIHRoaXNMZXZlbCA9IHRva2Vuc1tpXS5sZXZlbDtcblxuICAgICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDw9IHRoaXNMZXZlbCkgeyBicmVhazsgfVxuICAgICAgfVxuICAgICAgc3RhY2subGVuZ3RoID0gaiArIDE7XG5cbiAgICAgIHRleHQgPSB0b2tlbi5jb250ZW50O1xuICAgICAgcG9zID0gMDtcbiAgICAgIG1heCA9IHRleHQubGVuZ3RoO1xuXG4gICAgICAvKmVzbGludCBuby1sYWJlbHM6MCxibG9jay1zY29wZWQtdmFyOjAqL1xuICAgICAgT1VURVI6XG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIFFVT1RFX1JFLmxhc3RJbmRleCA9IHBvcztcbiAgICAgICAgdCA9IFFVT1RFX1JFLmV4ZWModGV4dCk7XG4gICAgICAgIGlmICghdCkgeyBicmVhazsgfVxuXG4gICAgICAgIGxhc3RTcGFjZSA9ICFpc0xldHRlcih0ZXh0LCB0LmluZGV4IC0gMSk7XG4gICAgICAgIHBvcyA9IHQuaW5kZXggKyAxO1xuICAgICAgICBpc1NpbmdsZSA9ICh0WzBdID09PSBcIidcIik7XG4gICAgICAgIG5leHRTcGFjZSA9ICFpc0xldHRlcih0ZXh0LCBwb3MpO1xuXG4gICAgICAgIGlmICghbmV4dFNwYWNlICYmICFsYXN0U3BhY2UpIHtcbiAgICAgICAgICAvLyBtaWRkbGUgb2Ygd29yZFxuICAgICAgICAgIGlmIChpc1NpbmdsZSkge1xuICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBBUE9TVFJPUEhFKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjYW5PcGVuID0gIW5leHRTcGFjZTtcbiAgICAgICAgY2FuQ2xvc2UgPSAhbGFzdFNwYWNlO1xuXG4gICAgICAgIGlmIChjYW5DbG9zZSkge1xuICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgYSBjbG9zaW5nIHF1b3RlLCByZXdpbmQgdGhlIHN0YWNrIHRvIGdldCBhIG1hdGNoXG4gICAgICAgICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgIGl0ZW0gPSBzdGFja1tqXTtcbiAgICAgICAgICAgIGlmIChzdGFja1tqXS5sZXZlbCA8IHRoaXNMZXZlbCkgeyBicmVhazsgfVxuICAgICAgICAgICAgaWYgKGl0ZW0uc2luZ2xlID09PSBpc1NpbmdsZSAmJiBzdGFja1tqXS5sZXZlbCA9PT0gdGhpc0xldmVsKSB7XG4gICAgICAgICAgICAgIGl0ZW0gPSBzdGFja1tqXTtcbiAgICAgICAgICAgICAgaWYgKGlzU2luZ2xlKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQsIGl0ZW0ucG9zLCBzdGF0ZS5vcHRpb25zLnF1b3Rlc1syXSk7XG4gICAgICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBzdGF0ZS5vcHRpb25zLnF1b3Rlc1szXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQsIGl0ZW0ucG9zLCBzdGF0ZS5vcHRpb25zLnF1b3Rlc1swXSk7XG4gICAgICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBzdGF0ZS5vcHRpb25zLnF1b3Rlc1sxXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gajtcbiAgICAgICAgICAgICAgY29udGludWUgT1VURVI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbk9wZW4pIHtcbiAgICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICAgIHRva2VuOiBpLFxuICAgICAgICAgICAgcG9zOiB0LmluZGV4LFxuICAgICAgICAgICAgc2luZ2xlOiBpc1NpbmdsZSxcbiAgICAgICAgICAgIGxldmVsOiB0aGlzTGV2ZWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChjYW5DbG9zZSAmJiBpc1NpbmdsZSkge1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgQVBPU1RST1BIRSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4iLCIvLyBQcm9jZXNzIGF1dG9saW5rcyAnPHByb3RvY29sOi4uLj4nXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHVybF9zY2hlbWFzICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXJsX3NjaGVtYXMnKTtcbnZhciBub3JtYWxpemVMaW5rID0gcmVxdWlyZSgnLi4vaGVscGVycy9ub3JtYWxpemVfbGluaycpO1xuXG5cbi8qZXNsaW50IG1heC1sZW46MCovXG52YXIgRU1BSUxfUkUgICAgPSAvXjwoW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKik+LztcbnZhciBBVVRPTElOS19SRSA9IC9ePChbYS16QS1aLlxcLV17MSwyNX0pOihbXjw+XFx4MDAtXFx4MjBdKik+LztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF1dG9saW5rKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHRhaWwsIGxpbmtNYXRjaCwgZW1haWxNYXRjaCwgdXJsLCBmdWxsVXJsLCBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHRhaWwgPSBzdGF0ZS5zcmMuc2xpY2UocG9zKTtcblxuICBpZiAodGFpbC5pbmRleE9mKCc+JykgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxpbmtNYXRjaCA9IHRhaWwubWF0Y2goQVVUT0xJTktfUkUpO1xuXG4gIGlmIChsaW5rTWF0Y2gpIHtcbiAgICBpZiAodXJsX3NjaGVtYXMuaW5kZXhPZihsaW5rTWF0Y2hbMV0udG9Mb3dlckNhc2UoKSkgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgdXJsID0gbGlua01hdGNoWzBdLnNsaWNlKDEsIC0xKTtcbiAgICBmdWxsVXJsID0gbm9ybWFsaXplTGluayh1cmwpO1xuICAgIGlmICghc3RhdGUucGFyc2VyLnZhbGlkYXRlTGluayh1cmwpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgIHN0YXRlLnB1c2goe1xuICAgICAgICB0eXBlOiAnbGlua19vcGVuJyxcbiAgICAgICAgaHJlZjogZnVsbFVybCxcbiAgICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsXG4gICAgICB9KTtcbiAgICAgIHN0YXRlLnB1c2goe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIGNvbnRlbnQ6IHVybCxcbiAgICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsICsgMVxuICAgICAgfSk7XG4gICAgICBzdGF0ZS5wdXNoKHsgdHlwZTogJ2xpbmtfY2xvc2UnLCBsZXZlbDogc3RhdGUubGV2ZWwgfSk7XG4gICAgfVxuXG4gICAgc3RhdGUucG9zICs9IGxpbmtNYXRjaFswXS5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBlbWFpbE1hdGNoID0gdGFpbC5tYXRjaChFTUFJTF9SRSk7XG5cbiAgaWYgKGVtYWlsTWF0Y2gpIHtcblxuICAgIHVybCA9IGVtYWlsTWF0Y2hbMF0uc2xpY2UoMSwgLTEpO1xuXG4gICAgZnVsbFVybCA9IG5vcm1hbGl6ZUxpbmsoJ21haWx0bzonICsgdXJsKTtcbiAgICBpZiAoIXN0YXRlLnBhcnNlci52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgc3RhdGUucHVzaCh7XG4gICAgICAgIHR5cGU6ICdsaW5rX29wZW4nLFxuICAgICAgICBocmVmOiBmdWxsVXJsLFxuICAgICAgICBsZXZlbDogc3RhdGUubGV2ZWxcbiAgICAgIH0pO1xuICAgICAgc3RhdGUucHVzaCh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgY29udGVudDogdXJsLFxuICAgICAgICBsZXZlbDogc3RhdGUubGV2ZWwgKyAxXG4gICAgICB9KTtcbiAgICAgIHN0YXRlLnB1c2goeyB0eXBlOiAnbGlua19jbG9zZScsIGxldmVsOiBzdGF0ZS5sZXZlbCB9KTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gZW1haWxNYXRjaFswXS5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiLy8gUGFyc2UgYmFja3RpY2tzXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYWNrdGlja3Moc3RhdGUsIHNpbGVudCkge1xuICB2YXIgc3RhcnQsIG1heCwgbWFya2VyLCBtYXRjaFN0YXJ0LCBtYXRjaEVuZCxcbiAgICAgIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAoY2ggIT09IDB4NjAvKiBgICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHN0YXJ0ID0gcG9zO1xuICBwb3MrKztcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg2MC8qIGAgKi8pIHsgcG9zKys7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcyk7XG5cbiAgbWF0Y2hTdGFydCA9IG1hdGNoRW5kID0gcG9zO1xuXG4gIHdoaWxlICgobWF0Y2hTdGFydCA9IHN0YXRlLnNyYy5pbmRleE9mKCdgJywgbWF0Y2hFbmQpKSAhPT0gLTEpIHtcbiAgICBtYXRjaEVuZCA9IG1hdGNoU3RhcnQgKyAxO1xuXG4gICAgd2hpbGUgKG1hdGNoRW5kIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KG1hdGNoRW5kKSA9PT0gMHg2MC8qIGAgKi8pIHsgbWF0Y2hFbmQrKzsgfVxuXG4gICAgaWYgKG1hdGNoRW5kIC0gbWF0Y2hTdGFydCA9PT0gbWFya2VyLmxlbmd0aCkge1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgc3RhdGUucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgIGNvbnRlbnQ6IHN0YXRlLnNyYy5zbGljZShwb3MsIG1hdGNoU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvWyBcXG5dKy9nLCAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpLFxuICAgICAgICAgIGJsb2NrOiBmYWxzZSxcbiAgICAgICAgICBsZXZlbDogc3RhdGUubGV2ZWxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBtYXRjaEVuZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gbWFya2VyOyB9XG4gIHN0YXRlLnBvcyArPSBtYXJrZXIubGVuZ3RoO1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQcm9jZXNzIH5+ZGVsZXRlZCB0ZXh0fn5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlbChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBmb3VuZCxcbiAgICAgIHBvcyxcbiAgICAgIHN0YWNrLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBsYXN0Q2hhcixcbiAgICAgIG5leHRDaGFyO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCkgIT09IDB4N0UvKiB+ICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc2lsZW50KSB7IHJldHVybiBmYWxzZTsgfSAvLyBkb24ndCBydW4gYW55IHBhaXJzIGluIHZhbGlkYXRpb24gbW9kZVxuICBpZiAoc3RhcnQgKyA0ID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0ICsgMSkgIT09IDB4N0UvKiB+ICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUubGV2ZWwgPj0gc3RhdGUub3B0aW9ucy5tYXhOZXN0aW5nKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhc3RDaGFyID0gc3RhcnQgPiAwID8gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQgLSAxKSA6IC0xO1xuICBuZXh0Q2hhciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0ICsgMik7XG5cbiAgaWYgKGxhc3RDaGFyID09PSAweDdFLyogfiAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKG5leHRDaGFyID09PSAweDdFLyogfiAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKG5leHRDaGFyID09PSAweDIwIHx8IG5leHRDaGFyID09PSAweDBBKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IHN0YXJ0ICsgMjtcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDdFLyogfiAqLykgeyBwb3MrKzsgfVxuICBpZiAocG9zID4gc3RhcnQgKyAzKSB7XG4gICAgLy8gc2VxdWVuY2Ugb2YgNCsgbWFya2VycyB0YWtpbmcgYXMgbGl0ZXJhbCwgc2FtZSBhcyBpbiBhIGVtcGhhc2lzXG4gICAgc3RhdGUucG9zICs9IHBvcyAtIHN0YXJ0O1xuICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MpOyB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydCArIDI7XG4gIHN0YWNrID0gMTtcblxuICB3aGlsZSAoc3RhdGUucG9zICsgMSA8IG1heCkge1xuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpID09PSAweDdFLyogfiAqLykge1xuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyArIDEpID09PSAweDdFLyogfiAqLykge1xuICAgICAgICBsYXN0Q2hhciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyAtIDEpO1xuICAgICAgICBuZXh0Q2hhciA9IHN0YXRlLnBvcyArIDIgPCBtYXggPyBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MgKyAyKSA6IC0xO1xuICAgICAgICBpZiAobmV4dENoYXIgIT09IDB4N0UvKiB+ICovICYmIGxhc3RDaGFyICE9PSAweDdFLyogfiAqLykge1xuICAgICAgICAgIGlmIChsYXN0Q2hhciAhPT0gMHgyMCAmJiBsYXN0Q2hhciAhPT0gMHgwQSkge1xuICAgICAgICAgICAgLy8gY2xvc2luZyAnfn4nXG4gICAgICAgICAgICBzdGFjay0tO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgIT09IDB4MjAgJiYgbmV4dENoYXIgIT09IDB4MEEpIHtcbiAgICAgICAgICAgIC8vIG9wZW5pbmcgJ35+J1xuICAgICAgICAgICAgc3RhY2srKztcbiAgICAgICAgICB9IC8vIGVsc2Uge1xuICAgICAgICAgICAgLy8gIC8vIHN0YW5kYWxvbmUgJyB+fiAnIGluZGVudGVkIHdpdGggc3BhY2VzXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgaWYgKHN0YWNrIDw9IDApIHtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLnBhcnNlci5za2lwVG9rZW4oc3RhdGUpO1xuICB9XG5cbiAgaWYgKCFmb3VuZCkge1xuICAgIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCBlbmRpbmcgdGFnLCBzbyBpdCdzIG5vdCB2YWxpZCBlbXBoYXNpc1xuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGZvdW5kIVxuICBzdGF0ZS5wb3NNYXggPSBzdGF0ZS5wb3M7XG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgMjtcblxuICBpZiAoIXNpbGVudCkge1xuICAgIHN0YXRlLnB1c2goeyB0eXBlOiAnZGVsX29wZW4nLCBsZXZlbDogc3RhdGUubGV2ZWwrKyB9KTtcbiAgICBzdGF0ZS5wYXJzZXIudG9rZW5pemUoc3RhdGUpO1xuICAgIHN0YXRlLnB1c2goeyB0eXBlOiAnZGVsX2Nsb3NlJywgbGV2ZWw6IC0tc3RhdGUubGV2ZWwgfSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGF0ZS5wb3NNYXggKyAyO1xuICBzdGF0ZS5wb3NNYXggPSBtYXg7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFByb2Nlc3MgKnRoaXMqIGFuZCBfdGhhdF9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIGlzQWxwaGFOdW0oY29kZSkge1xuICByZXR1cm4gKGNvZGUgPj0gMHgzMCAvKiAwICovICYmIGNvZGUgPD0gMHgzOSAvKiA5ICovKSB8fFxuICAgICAgICAgKGNvZGUgPj0gMHg0MSAvKiBBICovICYmIGNvZGUgPD0gMHg1QSAvKiBaICovKSB8fFxuICAgICAgICAgKGNvZGUgPj0gMHg2MSAvKiBhICovICYmIGNvZGUgPD0gMHg3QSAvKiB6ICovKTtcbn1cblxuLy8gcGFyc2Ugc2VxdWVuY2Ugb2YgZW1waGFzaXMgbWFya2Vycyxcbi8vIFwic3RhcnRcIiBzaG91bGQgcG9pbnQgYXQgYSB2YWxpZCBtYXJrZXJcbmZ1bmN0aW9uIHNjYW5EZWxpbXMoc3RhdGUsIHN0YXJ0KSB7XG4gIHZhciBwb3MgPSBzdGFydCwgbGFzdENoYXIsIG5leHRDaGFyLCBjb3VudCxcbiAgICAgIGNhbl9vcGVuID0gdHJ1ZSxcbiAgICAgIGNhbl9jbG9zZSA9IHRydWUsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgbGFzdENoYXIgPSBzdGFydCA+IDAgPyBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCAtIDEpIDogLTE7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSBtYXJrZXIpIHsgcG9zKys7IH1cbiAgaWYgKHBvcyA+PSBtYXgpIHsgY2FuX29wZW4gPSBmYWxzZTsgfVxuICBjb3VudCA9IHBvcyAtIHN0YXJ0O1xuXG4gIGlmIChjb3VudCA+PSA0KSB7XG4gICAgLy8gc2VxdWVuY2Ugb2YgZm91ciBvciBtb3JlIHVuZXNjYXBlZCBtYXJrZXJzIGNhbid0IHN0YXJ0L2VuZCBhbiBlbXBoYXNpc1xuICAgIGNhbl9vcGVuID0gY2FuX2Nsb3NlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgbmV4dENoYXIgPSBwb3MgPCBtYXggPyBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpIDogLTE7XG5cbiAgICAvLyBjaGVjayB3aGl0ZXNwYWNlIGNvbmRpdGlvbnNcbiAgICBpZiAobmV4dENoYXIgPT09IDB4MjAgfHwgbmV4dENoYXIgPT09IDB4MEEpIHsgY2FuX29wZW4gPSBmYWxzZTsgfVxuICAgIGlmIChsYXN0Q2hhciA9PT0gMHgyMCB8fCBsYXN0Q2hhciA9PT0gMHgwQSkgeyBjYW5fY2xvc2UgPSBmYWxzZTsgfVxuXG4gICAgaWYgKG1hcmtlciA9PT0gMHg1RiAvKiBfICovKSB7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBhcmVuJ3QgaW5zaWRlIHRoZSB3b3JkXG4gICAgICBpZiAoaXNBbHBoYU51bShsYXN0Q2hhcikpIHsgY2FuX29wZW4gPSBmYWxzZTsgfVxuICAgICAgaWYgKGlzQWxwaGFOdW0obmV4dENoYXIpKSB7IGNhbl9jbG9zZSA9IGZhbHNlOyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjYW5fb3BlbjogY2FuX29wZW4sXG4gICAgY2FuX2Nsb3NlOiBjYW5fY2xvc2UsXG4gICAgZGVsaW1zOiBjb3VudFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHN0YXJ0Q291bnQsXG4gICAgICBjb3VudCxcbiAgICAgIGZvdW5kLFxuICAgICAgb2xkQ291bnQsXG4gICAgICBuZXdDb3VudCxcbiAgICAgIHN0YWNrLFxuICAgICAgcmVzLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg1Ri8qIF8gKi8gJiYgbWFya2VyICE9PSAweDJBIC8qICogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGRvbid0IHJ1biBhbnkgcGFpcnMgaW4gdmFsaWRhdGlvbiBtb2RlXG5cbiAgcmVzID0gc2NhbkRlbGltcyhzdGF0ZSwgc3RhcnQpO1xuICBzdGFydENvdW50ID0gcmVzLmRlbGltcztcbiAgaWYgKCFyZXMuY2FuX29wZW4pIHtcbiAgICBzdGF0ZS5wb3MgKz0gc3RhcnRDb3VudDtcbiAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgc3RhdGUucG9zKTsgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxldmVsID49IHN0YXRlLm9wdGlvbnMubWF4TmVzdGluZykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydCArIHN0YXJ0Q291bnQ7XG4gIHN0YWNrID0gWyBzdGFydENvdW50IF07XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyA8IG1heCkge1xuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpID09PSBtYXJrZXIpIHtcbiAgICAgIHJlcyA9IHNjYW5EZWxpbXMoc3RhdGUsIHN0YXRlLnBvcyk7XG4gICAgICBjb3VudCA9IHJlcy5kZWxpbXM7XG4gICAgICBpZiAocmVzLmNhbl9jbG9zZSkge1xuICAgICAgICBvbGRDb3VudCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBuZXdDb3VudCA9IGNvdW50O1xuXG4gICAgICAgIHdoaWxlIChvbGRDb3VudCAhPT0gbmV3Q291bnQpIHtcbiAgICAgICAgICBpZiAobmV3Q291bnQgPCBvbGRDb3VudCkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChvbGRDb3VudCAtIG5ld0NvdW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFzc2VydChuZXdDb3VudCA+IG9sZENvdW50KVxuICAgICAgICAgIG5ld0NvdW50IC09IG9sZENvdW50O1xuXG4gICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkgeyBicmVhazsgfVxuICAgICAgICAgIHN0YXRlLnBvcyArPSBvbGRDb3VudDtcbiAgICAgICAgICBvbGRDb3VudCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHN0YXJ0Q291bnQgPSBvbGRDb3VudDtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucG9zICs9IGNvdW50O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcy5jYW5fb3BlbikgeyBzdGFjay5wdXNoKGNvdW50KTsgfVxuICAgICAgc3RhdGUucG9zICs9IGNvdW50O1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc3RhdGUucGFyc2VyLnNraXBUb2tlbihzdGF0ZSk7XG4gIH1cblxuICBpZiAoIWZvdW5kKSB7XG4gICAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kIGVuZGluZyB0YWcsIHNvIGl0J3Mgbm90IHZhbGlkIGVtcGhhc2lzXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZm91bmQhXG4gIHN0YXRlLnBvc01heCA9IHN0YXRlLnBvcztcbiAgc3RhdGUucG9zID0gc3RhcnQgKyBzdGFydENvdW50O1xuXG4gIGlmICghc2lsZW50KSB7XG4gICAgaWYgKHN0YXJ0Q291bnQgPT09IDIgfHwgc3RhcnRDb3VudCA9PT0gMykge1xuICAgICAgc3RhdGUucHVzaCh7IHR5cGU6ICdzdHJvbmdfb3BlbicsIGxldmVsOiBzdGF0ZS5sZXZlbCsrIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhcnRDb3VudCA9PT0gMSB8fCBzdGFydENvdW50ID09PSAzKSB7XG4gICAgICBzdGF0ZS5wdXNoKHsgdHlwZTogJ2VtX29wZW4nLCBsZXZlbDogc3RhdGUubGV2ZWwrKyB9KTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wYXJzZXIudG9rZW5pemUoc3RhdGUpO1xuXG4gICAgaWYgKHN0YXJ0Q291bnQgPT09IDEgfHwgc3RhcnRDb3VudCA9PT0gMykge1xuICAgICAgc3RhdGUucHVzaCh7IHR5cGU6ICdlbV9jbG9zZScsIGxldmVsOiAtLXN0YXRlLmxldmVsIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhcnRDb3VudCA9PT0gMiB8fCBzdGFydENvdW50ID09PSAzKSB7XG4gICAgICBzdGF0ZS5wdXNoKHsgdHlwZTogJ3N0cm9uZ19jbG9zZScsIGxldmVsOiAtLXN0YXRlLmxldmVsIH0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXRlLnBvc01heCArIHN0YXJ0Q291bnQ7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2VzcyBodG1sIGVudGl0eSAtICYjMTIzOywgJiN4QUY7LCAmcXVvdDssIC4uLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbnRpdGllcyAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lbnRpdGllcycpO1xudmFyIGhhcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaGFzO1xudmFyIGlzVmFsaWRFbnRpdHlDb2RlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNWYWxpZEVudGl0eUNvZGU7XG52YXIgZnJvbUNvZGVQb2ludCAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5mcm9tQ29kZVBvaW50O1xuXG5cbnZhciBESUdJVEFMX1JFID0gL14mIygoPzp4W2EtZjAtOV17MSw4fXxbMC05XXsxLDh9KSk7L2k7XG52YXIgTkFNRURfUkUgICA9IC9eJihbYS16XVthLXowLTldezEsMzF9KTsvaTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVudGl0eShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgY29kZSwgbWF0Y2gsIHBvcyA9IHN0YXRlLnBvcywgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI2LyogJiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAocG9zICsgMSA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG5cbiAgICBpZiAoY2ggPT09IDB4MjMgLyogIyAqLykge1xuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChESUdJVEFMX1JFKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgIGNvZGUgPSBtYXRjaFsxXVswXS50b0xvd2VyQ2FzZSgpID09PSAneCcgPyBwYXJzZUludChtYXRjaFsxXS5zbGljZSgxKSwgMTYpIDogcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgICBzdGF0ZS5wZW5kaW5nICs9IGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUpID8gZnJvbUNvZGVQb2ludChjb2RlKSA6IGZyb21Db2RlUG9pbnQoMHhGRkZEKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChOQU1FRF9SRSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKGhhcyhlbnRpdGllcywgbWF0Y2hbMV0pKSB7XG4gICAgICAgICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBlbnRpdGllc1ttYXRjaFsxXV07IH1cbiAgICAgICAgICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSAnJic7IH1cbiAgc3RhdGUucG9zKys7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFByb2NlZXNzIGVzY2FwZWQgY2hhcnMgYW5kIGhhcmRicmVha3NcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVNDQVBFRCA9IFtdO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7IEVTQ0FQRUQucHVzaCgwKTsgfVxuXG4nXFxcXCFcIiMkJSZcXCcoKSorLC4vOjs8PT4/QFtdXl9ge3x9fi0nXG4gIC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihjaCkgeyBFU0NBUEVEW2NoLmNoYXJDb2RlQXQoMCldID0gMTsgfSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlc2NhcGUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIHBvcyA9IHN0YXRlLnBvcywgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDVDLyogXFwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zKys7XG5cbiAgaWYgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjaCA8IDI1NiAmJiBFU0NBUEVEW2NoXSAhPT0gMCkge1xuICAgICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmNbcG9zXTsgfVxuICAgICAgc3RhdGUucG9zICs9IDI7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHN0YXRlLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdoYXJkYnJlYWsnLFxuICAgICAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgICAvLyBza2lwIGxlYWRpbmcgd2hpdGVzcGFjZXMgZnJvbSBuZXh0IGxpbmVcbiAgICAgIHdoaWxlIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCkgeyBwb3MrKzsgfVxuXG4gICAgICBzdGF0ZS5wb3MgPSBwb3M7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9ICdcXFxcJzsgfVxuICBzdGF0ZS5wb3MrKztcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2VzcyBpbmxpbmUgZm9vdG5vdGVzICheWy4uLl0pXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlTGlua0xhYmVsID0gcmVxdWlyZSgnLi4vaGVscGVycy9wYXJzZV9saW5rX2xhYmVsJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb290bm90ZV9pbmxpbmUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgbGFiZWxTdGFydCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgZm9vdG5vdGVJZCxcbiAgICAgIG9sZExlbmd0aCxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGFydCArIDIgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQpICE9PSAweDVFLyogXiAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0ICsgMSkgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUubGV2ZWwgPj0gc3RhdGUub3B0aW9ucy5tYXhOZXN0aW5nKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhYmVsU3RhcnQgPSBzdGFydCArIDI7XG4gIGxhYmVsRW5kID0gcGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXJ0ICsgMSk7XG5cbiAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kICddJywgc28gaXQncyBub3QgYSB2YWxpZCBub3RlXG4gIGlmIChsYWJlbEVuZCA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiB0aGUgbGluaywgYW5kIGtub3cgZm9yIGEgZmFjdCBpdCdzIGEgdmFsaWQgbGluaztcbiAgLy8gc28gYWxsIHRoYXQncyBsZWZ0IHRvIGRvIGlzIHRvIGNhbGwgdG9rZW5pemVyLlxuICAvL1xuICBpZiAoIXNpbGVudCkge1xuICAgIGlmICghc3RhdGUuZW52LmZvb3Rub3RlcykgeyBzdGF0ZS5lbnYuZm9vdG5vdGVzID0ge307IH1cbiAgICBpZiAoIXN0YXRlLmVudi5mb290bm90ZXMubGlzdCkgeyBzdGF0ZS5lbnYuZm9vdG5vdGVzLmxpc3QgPSBbXTsgfVxuICAgIGZvb3Rub3RlSWQgPSBzdGF0ZS5lbnYuZm9vdG5vdGVzLmxpc3QubGVuZ3RoO1xuXG4gICAgc3RhdGUucG9zID0gbGFiZWxTdGFydDtcbiAgICBzdGF0ZS5wb3NNYXggPSBsYWJlbEVuZDtcblxuICAgIHN0YXRlLnB1c2goe1xuICAgICAgdHlwZTogJ2Zvb3Rub3RlX3JlZicsXG4gICAgICBpZDogZm9vdG5vdGVJZCxcbiAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbFxuICAgIH0pO1xuICAgIHN0YXRlLmxpbmtMZXZlbCsrO1xuICAgIG9sZExlbmd0aCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG4gICAgc3RhdGUucGFyc2VyLnRva2VuaXplKHN0YXRlKTtcbiAgICBzdGF0ZS5lbnYuZm9vdG5vdGVzLmxpc3RbZm9vdG5vdGVJZF0gPSB7IHRva2Vuczogc3RhdGUudG9rZW5zLnNwbGljZShvbGRMZW5ndGgpIH07XG4gICAgc3RhdGUubGlua0xldmVsLS07XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBsYWJlbEVuZCArIDE7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2VzcyBmb290bm90ZSByZWZlcmVuY2VzIChbXi4uLl0pXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvb3Rub3RlX3JlZihzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBsYWJlbCxcbiAgICAgIHBvcyxcbiAgICAgIGZvb3Rub3RlSWQsXG4gICAgICBmb290bm90ZVN1YklkLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgLy8gc2hvdWxkIGJlIGF0IGxlYXN0IDQgY2hhcnMgLSBcIlteeF1cIlxuICBpZiAoc3RhcnQgKyAzID4gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICghc3RhdGUuZW52LmZvb3Rub3RlcyB8fCAhc3RhdGUuZW52LmZvb3Rub3Rlcy5yZWZzKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0ICsgMSkgIT09IDB4NUUvKiBeICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUubGV2ZWwgPj0gc3RhdGUub3B0aW9ucy5tYXhOZXN0aW5nKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGZvciAocG9zID0gc3RhcnQgKyAyOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjApIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MEEpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUQgLyogXSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBvcyA9PT0gc3RhcnQgKyAyKSB7IHJldHVybiBmYWxzZTsgfSAvLyBubyBlbXB0eSBmb290bm90ZSBsYWJlbHNcbiAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHBvcysrO1xuXG4gIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0ICsgMiwgcG9zIC0gMSk7XG4gIGlmICh0eXBlb2Ygc3RhdGUuZW52LmZvb3Rub3Rlcy5yZWZzWyc6JyArIGxhYmVsXSA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBpZiAoIXN0YXRlLmVudi5mb290bm90ZXMubGlzdCkgeyBzdGF0ZS5lbnYuZm9vdG5vdGVzLmxpc3QgPSBbXTsgfVxuXG4gICAgaWYgKHN0YXRlLmVudi5mb290bm90ZXMucmVmc1snOicgKyBsYWJlbF0gPCAwKSB7XG4gICAgICBmb290bm90ZUlkID0gc3RhdGUuZW52LmZvb3Rub3Rlcy5saXN0Lmxlbmd0aDtcbiAgICAgIHN0YXRlLmVudi5mb290bm90ZXMubGlzdFtmb290bm90ZUlkXSA9IHsgbGFiZWw6IGxhYmVsLCBjb3VudDogMCB9O1xuICAgICAgc3RhdGUuZW52LmZvb3Rub3Rlcy5yZWZzWyc6JyArIGxhYmVsXSA9IGZvb3Rub3RlSWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvb3Rub3RlSWQgPSBzdGF0ZS5lbnYuZm9vdG5vdGVzLnJlZnNbJzonICsgbGFiZWxdO1xuICAgIH1cblxuICAgIGZvb3Rub3RlU3ViSWQgPSBzdGF0ZS5lbnYuZm9vdG5vdGVzLmxpc3RbZm9vdG5vdGVJZF0uY291bnQ7XG4gICAgc3RhdGUuZW52LmZvb3Rub3Rlcy5saXN0W2Zvb3Rub3RlSWRdLmNvdW50Kys7XG5cbiAgICBzdGF0ZS5wdXNoKHtcbiAgICAgIHR5cGU6ICdmb290bm90ZV9yZWYnLFxuICAgICAgaWQ6IGZvb3Rub3RlSWQsXG4gICAgICBzdWJJZDogZm9vdG5vdGVTdWJJZCxcbiAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbFxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICBzdGF0ZS5wb3NNYXggPSBtYXg7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFByb2Nlc3MgaHRtbCB0YWdzXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgSFRNTF9UQUdfUkUgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9yZScpLkhUTUxfVEFHX1JFO1xuXG5cbmZ1bmN0aW9uIGlzTGV0dGVyKGNoKSB7XG4gIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXG4gIHZhciBsYyA9IGNoIHwgMHgyMDsgLy8gdG8gbG93ZXIgY2FzZVxuICByZXR1cm4gKGxjID49IDB4NjEvKiBhICovKSAmJiAobGMgPD0gMHg3YS8qIHogKi8pO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHRtbHRhZyhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbWF0Y2gsIG1heCwgcG9zID0gc3RhdGUucG9zO1xuXG4gIGlmICghc3RhdGUub3B0aW9ucy5odG1sKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIENoZWNrIHN0YXJ0XG4gIG1heCA9IHN0YXRlLnBvc01heDtcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovIHx8XG4gICAgICBwb3MgKyAyID49IG1heCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFF1aWNrIGZhaWwgb24gc2Vjb25kIGNoYXJcbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgaWYgKGNoICE9PSAweDIxLyogISAqLyAmJlxuICAgICAgY2ggIT09IDB4M0YvKiA/ICovICYmXG4gICAgICBjaCAhPT0gMHgyRi8qIC8gKi8gJiZcbiAgICAgICFpc0xldHRlcihjaCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKEhUTUxfVEFHX1JFKTtcbiAgaWYgKCFtYXRjaCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXNpbGVudCkge1xuICAgIHN0YXRlLnB1c2goe1xuICAgICAgdHlwZTogJ2h0bWx0YWcnLFxuICAgICAgY29udGVudDogc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgbWF0Y2hbMF0ubGVuZ3RoKSxcbiAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbFxuICAgIH0pO1xuICB9XG4gIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFByb2Nlc3MgKytpbnNlcnRlZCB0ZXh0KytcblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlucyhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBmb3VuZCxcbiAgICAgIHBvcyxcbiAgICAgIHN0YWNrLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBsYXN0Q2hhcixcbiAgICAgIG5leHRDaGFyO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCkgIT09IDB4MkIvKiArICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc2lsZW50KSB7IHJldHVybiBmYWxzZTsgfSAvLyBkb24ndCBydW4gYW55IHBhaXJzIGluIHZhbGlkYXRpb24gbW9kZVxuICBpZiAoc3RhcnQgKyA0ID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0ICsgMSkgIT09IDB4MkIvKiArICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUubGV2ZWwgPj0gc3RhdGUub3B0aW9ucy5tYXhOZXN0aW5nKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhc3RDaGFyID0gc3RhcnQgPiAwID8gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQgLSAxKSA6IC0xO1xuICBuZXh0Q2hhciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0ICsgMik7XG5cbiAgaWYgKGxhc3RDaGFyID09PSAweDJCLyogKyAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKG5leHRDaGFyID09PSAweDJCLyogKyAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKG5leHRDaGFyID09PSAweDIwIHx8IG5leHRDaGFyID09PSAweDBBKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IHN0YXJ0ICsgMjtcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDJCLyogKyAqLykgeyBwb3MrKzsgfVxuICBpZiAocG9zICE9PSBzdGFydCArIDIpIHtcbiAgICAvLyBzZXF1ZW5jZSBvZiAzKyBtYXJrZXJzIHRha2luZyBhcyBsaXRlcmFsLCBzYW1lIGFzIGluIGEgZW1waGFzaXNcbiAgICBzdGF0ZS5wb3MgKz0gcG9zIC0gc3RhcnQ7XG4gICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcyk7IH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgMjtcbiAgc3RhY2sgPSAxO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgKyAxIDwgbWF4KSB7XG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcykgPT09IDB4MkIvKiArICovKSB7XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zICsgMSkgPT09IDB4MkIvKiArICovKSB7XG4gICAgICAgIGxhc3RDaGFyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zIC0gMSk7XG4gICAgICAgIG5leHRDaGFyID0gc3RhdGUucG9zICsgMiA8IG1heCA/IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyArIDIpIDogLTE7XG4gICAgICAgIGlmIChuZXh0Q2hhciAhPT0gMHgyQi8qICsgKi8gJiYgbGFzdENoYXIgIT09IDB4MkIvKiArICovKSB7XG4gICAgICAgICAgaWYgKGxhc3RDaGFyICE9PSAweDIwICYmIGxhc3RDaGFyICE9PSAweDBBKSB7XG4gICAgICAgICAgICAvLyBjbG9zaW5nICcrKydcbiAgICAgICAgICAgIHN0YWNrLS07XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciAhPT0gMHgyMCAmJiBuZXh0Q2hhciAhPT0gMHgwQSkge1xuICAgICAgICAgICAgLy8gb3BlbmluZyAnKysnXG4gICAgICAgICAgICBzdGFjaysrO1xuICAgICAgICAgIH0gLy8gZWxzZSB7XG4gICAgICAgICAgICAvLyAgLy8gc3RhbmRhbG9uZSAnICsrICcgaW5kZW50ZWQgd2l0aCBzcGFjZXNcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICBpZiAoc3RhY2sgPD0gMCkge1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUucGFyc2VyLnNraXBUb2tlbihzdGF0ZSk7XG4gIH1cblxuICBpZiAoIWZvdW5kKSB7XG4gICAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kIGVuZGluZyB0YWcsIHNvIGl0J3Mgbm90IHZhbGlkIGVtcGhhc2lzXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZm91bmQhXG4gIHN0YXRlLnBvc01heCA9IHN0YXRlLnBvcztcbiAgc3RhdGUucG9zID0gc3RhcnQgKyAyO1xuXG4gIGlmICghc2lsZW50KSB7XG4gICAgc3RhdGUucHVzaCh7IHR5cGU6ICdpbnNfb3BlbicsIGxldmVsOiBzdGF0ZS5sZXZlbCsrIH0pO1xuICAgIHN0YXRlLnBhcnNlci50b2tlbml6ZShzdGF0ZSk7XG4gICAgc3RhdGUucHVzaCh7IHR5cGU6ICdpbnNfY2xvc2UnLCBsZXZlbDogLS1zdGF0ZS5sZXZlbCB9KTtcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXRlLnBvc01heCArIDI7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2VzcyBbbGlua3NdKDx0bz4gXCJzdHVmZlwiKVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZUxpbmtMYWJlbCAgICAgICA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbCcpO1xudmFyIHBhcnNlTGlua0Rlc3RpbmF0aW9uID0gcmVxdWlyZSgnLi4vaGVscGVycy9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uJyk7XG52YXIgcGFyc2VMaW5rVGl0bGUgICAgICAgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUnKTtcbnZhciBub3JtYWxpemVSZWZlcmVuY2UgICA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvbm9ybWFsaXplX3JlZmVyZW5jZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlua3Moc3RhdGUsIHNpbGVudCkge1xuICB2YXIgbGFiZWxTdGFydCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgbGFiZWwsXG4gICAgICBocmVmLFxuICAgICAgdGl0bGUsXG4gICAgICBwb3MsXG4gICAgICByZWYsXG4gICAgICBjb2RlLFxuICAgICAgaXNJbWFnZSA9IGZhbHNlLFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgaWYgKG1hcmtlciA9PT0gMHgyMS8qICEgKi8pIHtcbiAgICBpc0ltYWdlID0gdHJ1ZTtcbiAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3N0YXJ0KTtcbiAgfVxuXG4gIGlmIChtYXJrZXIgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUubGV2ZWwgPj0gc3RhdGUub3B0aW9ucy5tYXhOZXN0aW5nKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhYmVsU3RhcnQgPSBzdGFydCArIDE7XG4gIGxhYmVsRW5kID0gcGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXJ0KTtcblxuICAvLyBwYXJzZXIgZmFpbGVkIHRvIGZpbmQgJ10nLCBzbyBpdCdzIG5vdCBhIHZhbGlkIGxpbmtcbiAgaWYgKGxhYmVsRW5kIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyOC8qICggKi8pIHtcbiAgICAvL1xuICAgIC8vIElubGluZSBsaW5rXG4gICAgLy9cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgIHBvcysrO1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmIChjb2RlICE9PSAweDIwICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgIF5eXl5eXiBwYXJzaW5nIGxpbmsgZGVzdGluYXRpb25cbiAgICBzdGFydCA9IHBvcztcbiAgICBpZiAocGFyc2VMaW5rRGVzdGluYXRpb24oc3RhdGUsIHBvcykpIHtcbiAgICAgIGhyZWYgPSBzdGF0ZS5saW5rQ29udGVudDtcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgaHJlZiA9ICcnO1xuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKGNvZGUgIT09IDB4MjAgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNpbmcgbGluayB0aXRsZVxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiBwYXJzZUxpbmtUaXRsZShzdGF0ZSwgcG9zKSkge1xuICAgICAgdGl0bGUgPSBzdGF0ZS5saW5rQ29udGVudDtcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmIChjb2RlICE9PSAweDIwICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGUgPSAnJztcbiAgICB9XG5cbiAgICBpZiAocG9zID49IG1heCB8fCBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI5LyogKSAqLykge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBwb3MrKztcbiAgfSBlbHNlIHtcbiAgICAvL1xuICAgIC8vIExpbmsgcmVmZXJlbmNlXG4gICAgLy9cblxuICAgIC8vIGRvIG5vdCBhbGxvdyBuZXN0ZWQgcmVmZXJlbmNlIGxpbmtzXG4gICAgaWYgKHN0YXRlLmxpbmtMZXZlbCA+IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBbZm9vXSAgW2Jhcl1cbiAgICAvLyAgICAgIF5eIG9wdGlvbmFsIHdoaXRlc3BhY2UgKGNhbiBpbmNsdWRlIG5ld2xpbmVzKVxuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmIChjb2RlICE9PSAweDIwICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUIvKiBbICovKSB7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICBwb3MgPSBwYXJzZUxpbmtMYWJlbChzdGF0ZSwgcG9zKTtcbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gc3RhcnQgLSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvdmVycyBsYWJlbCA9PT0gJycgYW5kIGxhYmVsID09PSB1bmRlZmluZWRcbiAgICAvLyAoY29sbGFwc2VkIHJlZmVyZW5jZSBsaW5rIGFuZCBzaG9ydGN1dCByZWZlcmVuY2UgbGluayByZXNwZWN0aXZlbHkpXG4gICAgaWYgKCFsYWJlbCkge1xuICAgICAgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgICAgfVxuICAgICAgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpO1xuICAgIH1cblxuICAgIHJlZiA9IHN0YXRlLmVudi5yZWZlcmVuY2VzW25vcm1hbGl6ZVJlZmVyZW5jZShsYWJlbCldO1xuICAgIGlmICghcmVmKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhyZWYgPSByZWYuaHJlZjtcbiAgICB0aXRsZSA9IHJlZi50aXRsZTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIGZvdW5kIHRoZSBlbmQgb2YgdGhlIGxpbmssIGFuZCBrbm93IGZvciBhIGZhY3QgaXQncyBhIHZhbGlkIGxpbms7XG4gIC8vIHNvIGFsbCB0aGF0J3MgbGVmdCB0byBkbyBpcyB0byBjYWxsIHRva2VuaXplci5cbiAgLy9cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBzdGF0ZS5wb3MgPSBsYWJlbFN0YXJ0O1xuICAgIHN0YXRlLnBvc01heCA9IGxhYmVsRW5kO1xuXG4gICAgaWYgKGlzSW1hZ2UpIHtcbiAgICAgIHN0YXRlLnB1c2goe1xuICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICBzcmM6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgYWx0OiBzdGF0ZS5zcmMuc3Vic3RyKGxhYmVsU3RhcnQsIGxhYmVsRW5kIC0gbGFiZWxTdGFydCksXG4gICAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnB1c2goe1xuICAgICAgICB0eXBlOiAnbGlua19vcGVuJyxcbiAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICBsZXZlbDogc3RhdGUubGV2ZWwrK1xuICAgICAgfSk7XG4gICAgICBzdGF0ZS5saW5rTGV2ZWwrKztcbiAgICAgIHN0YXRlLnBhcnNlci50b2tlbml6ZShzdGF0ZSk7XG4gICAgICBzdGF0ZS5saW5rTGV2ZWwtLTtcbiAgICAgIHN0YXRlLnB1c2goeyB0eXBlOiAnbGlua19jbG9zZScsIGxldmVsOiAtLXN0YXRlLmxldmVsIH0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQcm9jZXNzID09aGlnaGxpZ2h0ZWQgdGV4dD09XG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWwoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgZm91bmQsXG4gICAgICBwb3MsXG4gICAgICBzdGFjayxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxuICAgICAgbGFzdENoYXIsXG4gICAgICBuZXh0Q2hhcjtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQpICE9PSAweDNELyogPSAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gZmFsc2U7IH0gLy8gZG9uJ3QgcnVuIGFueSBwYWlycyBpbiB2YWxpZGF0aW9uIG1vZGVcbiAgaWYgKHN0YXJ0ICsgNCA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCArIDEpICE9PSAweDNELyogPSAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLmxldmVsID49IHN0YXRlLm9wdGlvbnMubWF4TmVzdGluZykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYXN0Q2hhciA9IHN0YXJ0ID4gMCA/IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0IC0gMSkgOiAtMTtcbiAgbmV4dENoYXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCArIDIpO1xuXG4gIGlmIChsYXN0Q2hhciA9PT0gMHgzRC8qID0gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChuZXh0Q2hhciA9PT0gMHgzRC8qID0gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChuZXh0Q2hhciA9PT0gMHgyMCB8fCBuZXh0Q2hhciA9PT0gMHgwQSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSBzdGFydCArIDI7XG4gIHdoaWxlIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgzRC8qID0gKi8pIHsgcG9zKys7IH1cbiAgaWYgKHBvcyAhPT0gc3RhcnQgKyAyKSB7XG4gICAgLy8gc2VxdWVuY2Ugb2YgMysgbWFya2VycyB0YWtpbmcgYXMgbGl0ZXJhbCwgc2FtZSBhcyBpbiBhIGVtcGhhc2lzXG4gICAgc3RhdGUucG9zICs9IHBvcyAtIHN0YXJ0O1xuICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MpOyB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydCArIDI7XG4gIHN0YWNrID0gMTtcblxuICB3aGlsZSAoc3RhdGUucG9zICsgMSA8IG1heCkge1xuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpID09PSAweDNELyogPSAqLykge1xuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyArIDEpID09PSAweDNELyogPSAqLykge1xuICAgICAgICBsYXN0Q2hhciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyAtIDEpO1xuICAgICAgICBuZXh0Q2hhciA9IHN0YXRlLnBvcyArIDIgPCBtYXggPyBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MgKyAyKSA6IC0xO1xuICAgICAgICBpZiAobmV4dENoYXIgIT09IDB4M0QvKiA9ICovICYmIGxhc3RDaGFyICE9PSAweDNELyogPSAqLykge1xuICAgICAgICAgIGlmIChsYXN0Q2hhciAhPT0gMHgyMCAmJiBsYXN0Q2hhciAhPT0gMHgwQSkge1xuICAgICAgICAgICAgLy8gY2xvc2luZyAnPT0nXG4gICAgICAgICAgICBzdGFjay0tO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgIT09IDB4MjAgJiYgbmV4dENoYXIgIT09IDB4MEEpIHtcbiAgICAgICAgICAgIC8vIG9wZW5pbmcgJz09J1xuICAgICAgICAgICAgc3RhY2srKztcbiAgICAgICAgICB9IC8vIGVsc2Uge1xuICAgICAgICAgICAgLy8gIC8vIHN0YW5kYWxvbmUgJyA9PSAnIGluZGVudGVkIHdpdGggc3BhY2VzXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgaWYgKHN0YWNrIDw9IDApIHtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLnBhcnNlci5za2lwVG9rZW4oc3RhdGUpO1xuICB9XG5cbiAgaWYgKCFmb3VuZCkge1xuICAgIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCBlbmRpbmcgdGFnLCBzbyBpdCdzIG5vdCB2YWxpZCBlbXBoYXNpc1xuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGZvdW5kIVxuICBzdGF0ZS5wb3NNYXggPSBzdGF0ZS5wb3M7XG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgMjtcblxuICBpZiAoIXNpbGVudCkge1xuICAgIHN0YXRlLnB1c2goeyB0eXBlOiAnbWFya19vcGVuJywgbGV2ZWw6IHN0YXRlLmxldmVsKysgfSk7XG4gICAgc3RhdGUucGFyc2VyLnRva2VuaXplKHN0YXRlKTtcbiAgICBzdGF0ZS5wdXNoKHsgdHlwZTogJ21hcmtfY2xvc2UnLCBsZXZlbDogLS1zdGF0ZS5sZXZlbCB9KTtcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXRlLnBvc01heCArIDI7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2Vlc3MgJ1xcbidcblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5ld2xpbmUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgcG1heCwgbWF4LCBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEvKiBcXG4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG1heCA9IHN0YXRlLnBlbmRpbmcubGVuZ3RoIC0gMTtcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIC8vICcgIFxcbicgLT4gaGFyZGJyZWFrXG4gIC8vIExvb2t1cCBpbiBwZW5kaW5nIGNoYXJzIGlzIGJhZCBwcmFjdGljZSEgRG9uJ3QgY29weSB0byBvdGhlciBydWxlcyFcbiAgLy8gUGVuZGluZyBzdHJpbmcgaXMgc3RvcmVkIGluIGNvbmNhdCBtb2RlLCBpbmRleGVkIGxvb2t1cHMgd2lsbCBjYXVzZVxuICAvLyBjb252ZXJ0aW9uIHRvIGZsYXQgbW9kZS5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBpZiAocG1heCA+PSAwICYmIHN0YXRlLnBlbmRpbmcuY2hhckNvZGVBdChwbWF4KSA9PT0gMHgyMCkge1xuICAgICAgaWYgKHBtYXggPj0gMSAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCAtIDEpID09PSAweDIwKSB7XG4gICAgICAgIC8vIFN0cmlwIG91dCBhbGwgdHJhaWxpbmcgc3BhY2VzIG9uIHRoaXMgbGluZS5cbiAgICAgICAgZm9yICh2YXIgaSA9IHBtYXggLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQoaSkgIT09IDB4MjApIHtcbiAgICAgICAgICAgIHN0YXRlLnBlbmRpbmcgPSBzdGF0ZS5wZW5kaW5nLnN1YnN0cmluZygwLCBpICsgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ2hhcmRicmVhaycsXG4gICAgICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcuc2xpY2UoMCwgLTEpO1xuICAgICAgICBzdGF0ZS5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnc29mdGJyZWFrJyxcbiAgICAgICAgICBsZXZlbDogc3RhdGUubGV2ZWxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHVzaCh7XG4gICAgICAgIHR5cGU6ICdzb2Z0YnJlYWsnLFxuICAgICAgICBsZXZlbDogc3RhdGUubGV2ZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHBvcysrO1xuXG4gIC8vIHNraXAgaGVhZGluZyBzcGFjZXMgZm9yIG5leHQgbGluZVxuICB3aGlsZSAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjApIHsgcG9zKys7IH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIElubGluZSBwYXJzZXIgc3RhdGVcblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBTdGF0ZUlubGluZShzcmMsIHBhcnNlcklubGluZSwgb3B0aW9ucywgZW52LCBvdXRUb2tlbnMpIHtcbiAgdGhpcy5zcmMgPSBzcmM7XG4gIHRoaXMuZW52ID0gZW52O1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLnBhcnNlciA9IHBhcnNlcklubGluZTtcbiAgdGhpcy50b2tlbnMgPSBvdXRUb2tlbnM7XG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy5wb3NNYXggPSB0aGlzLnNyYy5sZW5ndGg7XG4gIHRoaXMubGV2ZWwgPSAwO1xuICB0aGlzLnBlbmRpbmcgPSAnJztcbiAgdGhpcy5wZW5kaW5nTGV2ZWwgPSAwO1xuXG4gIHRoaXMuY2FjaGUgPSBbXTsgICAgICAgIC8vIFN0b3JlcyB7IHN0YXJ0OiBlbmQgfSBwYWlycy4gVXNlZnVsIGZvciBiYWNrdHJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW1pemF0aW9uIG9mIHBhaXJzIHBhcnNlIChlbXBoYXNpcywgc3RyaWtlcykuXG5cbiAgLy8gTGluayBwYXJzZXIgc3RhdGUgdmFyc1xuXG4gIHRoaXMuaXNJbkxhYmVsID0gZmFsc2U7IC8vIFNldCB0cnVlIHdoZW4gc2VlayBsaW5rIGxhYmVsIC0gd2Ugc2hvdWxkIGRpc2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJwYWlyZWRcIiBydWxlcyAoZW1waGFzaXMsIHN0cmlrZXMpIHRvIG5vdCBza2lwXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRhaWxpbmcgYF1gXG5cbiAgdGhpcy5saW5rTGV2ZWwgPSAwOyAgICAgLy8gSW5jcmVtZW50IGZvciBlYWNoIG5lc3RpbmcgbGluay4gVXNlZCB0byBwcmV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lc3RpbmcgaW4gZGVmaW5pdGlvbnNcblxuICB0aGlzLmxpbmtDb250ZW50ID0gJyc7ICAvLyBUZW1wb3Jhcnkgc3RvcmFnZSBmb3IgbGluayB1cmxcblxuICB0aGlzLmxhYmVsVW5tYXRjaGVkU2NvcGVzID0gMDsgLy8gVHJhY2sgdW5wYWlyZWQgYFtgIGZvciBsaW5rIGxhYmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGJhY2t0cmFjayBvcHRpbWl6YXRpb24pXG59XG5cbi8vIEZsdXNoIHBlbmRpbmcgdGV4dFxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5wdXNoUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJ3RleHQnLFxuICAgIGNvbnRlbnQ6IHRoaXMucGVuZGluZyxcbiAgICBsZXZlbDogdGhpcy5wZW5kaW5nTGV2ZWxcbiAgfSk7XG4gIHRoaXMucGVuZGluZyA9ICcnO1xufTtcblxuLy8gUHVzaCBuZXcgdG9rZW4gdG8gXCJzdHJlYW1cIi5cbi8vIElmIHBlbmRpbmcgdGV4dCBleGlzdHMgLSBmbHVzaCBpdCBhcyB0ZXh0IHRva2VuXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgaWYgKHRoaXMucGVuZGluZykge1xuICAgIHRoaXMucHVzaFBlbmRpbmcoKTtcbiAgfVxuXG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICB0aGlzLnBlbmRpbmdMZXZlbCA9IHRoaXMubGV2ZWw7XG59O1xuXG4vLyBTdG9yZSB2YWx1ZSB0byBjYWNoZS5cbi8vICEhISBJbXBsZW1lbnRhdGlvbiBoYXMgcGFyc2VyLXNwZWNpZmljIG9wdGltaXphdGlvbnNcbi8vICEhISBrZXlzIE1VU1QgYmUgaW50ZWdlciwgPj0gMDsgdmFsdWVzIE1VU1QgYmUgaW50ZWdlciwgPiAwXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLmNhY2hlU2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLmNhY2hlLmxlbmd0aDsgaSA8PSBrZXk7IGkrKykge1xuICAgIHRoaXMuY2FjaGUucHVzaCgwKTtcbiAgfVxuXG4gIHRoaXMuY2FjaGVba2V5XSA9IHZhbDtcbn07XG5cbi8vIEdldCBjYWNoZSB2YWx1ZVxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5jYWNoZUdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleSA8IHRoaXMuY2FjaGUubGVuZ3RoID8gdGhpcy5jYWNoZVtrZXldIDogMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVJbmxpbmU7XG4iLCIvLyBQcm9jZXNzIH5zdWJzY3JpcHR+XG5cbid1c2Ugc3RyaWN0JztcblxuLy8gc2FtZSBhcyBVTkVTQ0FQRV9NRF9SRSBwbHVzIGEgc3BhY2VcbnZhciBVTkVTQ0FQRV9SRSA9IC9cXFxcKFsgXFxcXCFcIiMkJSYnKCkqKywuXFwvOjs8PT4/QFtcXF1eX2B7fH1+LV0pL2c7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ViKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGZvdW5kLFxuICAgICAgY29udGVudCxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCkgIT09IDB4N0UvKiB+ICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc2lsZW50KSB7IHJldHVybiBmYWxzZTsgfSAvLyBkb24ndCBydW4gYW55IHBhaXJzIGluIHZhbGlkYXRpb24gbW9kZVxuICBpZiAoc3RhcnQgKyAyID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLmxldmVsID49IHN0YXRlLm9wdGlvbnMubWF4TmVzdGluZykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydCArIDE7XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyA8IG1heCkge1xuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpID09PSAweDdFLyogfiAqLykge1xuICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc3RhdGUucGFyc2VyLnNraXBUb2tlbihzdGF0ZSk7XG4gIH1cblxuICBpZiAoIWZvdW5kIHx8IHN0YXJ0ICsgMSA9PT0gc3RhdGUucG9zKSB7XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCArIDEsIHN0YXRlLnBvcyk7XG5cbiAgLy8gZG9uJ3QgYWxsb3cgdW5lc2NhcGVkIHNwYWNlcy9uZXdsaW5lcyBpbnNpZGVcbiAgaWYgKGNvbnRlbnQubWF0Y2goLyhefFteXFxcXF0pKFxcXFxcXFxcKSpcXHMvKSkge1xuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGZvdW5kIVxuICBzdGF0ZS5wb3NNYXggPSBzdGF0ZS5wb3M7XG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgMTtcblxuICBpZiAoIXNpbGVudCkge1xuICAgIHN0YXRlLnB1c2goe1xuICAgICAgdHlwZTogJ3N1YicsXG4gICAgICBsZXZlbDogc3RhdGUubGV2ZWwsXG4gICAgICBjb250ZW50OiBjb250ZW50LnJlcGxhY2UoVU5FU0NBUEVfUkUsICckMScpXG4gICAgfSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGF0ZS5wb3NNYXggKyAxO1xuICBzdGF0ZS5wb3NNYXggPSBtYXg7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFByb2Nlc3MgXnN1cGVyc2NyaXB0XlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIHNhbWUgYXMgVU5FU0NBUEVfTURfUkUgcGx1cyBhIHNwYWNlXG52YXIgVU5FU0NBUEVfUkUgPSAvXFxcXChbIFxcXFwhXCIjJCUmJygpKissLlxcLzo7PD0+P0BbXFxdXl9ge3x9fi1dKS9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN1cChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBmb3VuZCxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQpICE9PSAweDVFLyogXiAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gZmFsc2U7IH0gLy8gZG9uJ3QgcnVuIGFueSBwYWlycyBpbiB2YWxpZGF0aW9uIG1vZGVcbiAgaWYgKHN0YXJ0ICsgMiA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5sZXZlbCA+PSBzdGF0ZS5vcHRpb25zLm1heE5lc3RpbmcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc3RhdGUucG9zID0gc3RhcnQgKyAxO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBtYXgpIHtcbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSA9PT0gMHg1RS8qIF4gKi8pIHtcbiAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHN0YXRlLnBhcnNlci5za2lwVG9rZW4oc3RhdGUpO1xuICB9XG5cbiAgaWYgKCFmb3VuZCB8fCBzdGFydCArIDEgPT09IHN0YXRlLnBvcykge1xuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQgKyAxLCBzdGF0ZS5wb3MpO1xuXG4gIC8vIGRvbid0IGFsbG93IHVuZXNjYXBlZCBzcGFjZXMvbmV3bGluZXMgaW5zaWRlXG4gIGlmIChjb250ZW50Lm1hdGNoKC8oXnxbXlxcXFxdKShcXFxcXFxcXCkqXFxzLykpIHtcbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBmb3VuZCFcbiAgc3RhdGUucG9zTWF4ID0gc3RhdGUucG9zO1xuICBzdGF0ZS5wb3MgPSBzdGFydCArIDE7XG5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBzdGF0ZS5wdXNoKHtcbiAgICAgIHR5cGU6ICdzdXAnLFxuICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsLFxuICAgICAgY29udGVudDogY29udGVudC5yZXBsYWNlKFVORVNDQVBFX1JFLCAnJDEnKVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhdGUucG9zTWF4ICsgMTtcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBTa2lwIHRleHQgY2hhcmFjdGVycyBmb3IgdGV4dCB0b2tlbiwgcGxhY2UgdGhvc2UgdG8gcGVuZGluZyBidWZmZXJcbi8vIGFuZCBpbmNyZW1lbnQgY3VycmVudCBwb3NcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBSdWxlIHRvIHNraXAgcHVyZSB0ZXh0XG4vLyAne30kJUB+Kz06JyByZXNlcnZlZCBmb3IgZXh0ZW50aW9uc1xuXG5mdW5jdGlvbiBpc1Rlcm1pbmF0b3JDaGFyKGNoKSB7XG4gIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDB4MEEvKiBcXG4gKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4MkEvKiAqICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDVFLyogXiAqLzpcbiAgICBjYXNlIDB4NUIvKiBbICovOlxuICAgIGNhc2UgMHg1RC8qIF0gKi86XG4gICAgY2FzZSAweDIxLyogISAqLzpcbiAgICBjYXNlIDB4MjYvKiAmICovOlxuICAgIGNhc2UgMHgzQy8qIDwgKi86XG4gICAgY2FzZSAweDNFLyogPiAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3RC8qIH0gKi86XG4gICAgY2FzZSAweDI0LyogJCAqLzpcbiAgICBjYXNlIDB4MjUvKiAlICovOlxuICAgIGNhc2UgMHg0MC8qIEAgKi86XG4gICAgY2FzZSAweDdFLyogfiAqLzpcbiAgICBjYXNlIDB4MkIvKiArICovOlxuICAgIGNhc2UgMHgzRC8qID0gKi86XG4gICAgY2FzZSAweDNBLyogOiAqLzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcztcblxuICB3aGlsZSAocG9zIDwgc3RhdGUucG9zTWF4ICYmICFpc1Rlcm1pbmF0b3JDaGFyKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocG9zID09PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhdGUucG9zLCBwb3MpOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8gKyBcIiBcIiArIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJleHBvcnQgY29uc3Qgb25saW5lVXJsID1cbiAgXCJodHRwczovL2V1MS5wcmlzbWEuc2gvYm9hei1ibGFrZS04OTUxZTEvbWl0aHJpbC1wcmVzZW50ZXIvZGV2XCJcbiIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnXHJcbmltcG9ydCBTdHJlYW0gZnJvbSAnbWl0aHJpbC1zdHJlYW0nXHJcblxyXG5pbXBvcnQgUHJlc2VudGF0aW9ucyBmcm9tICcuL3ByZXNlbnRhdGlvbnMvY29tcG9uZW50LmpzJ1xyXG5pbXBvcnQgU2xpZGVzIGZyb20gJy4vc2xpZGVzL2NvbXBvbmVudC5qcydcclxuaW1wb3J0IEVkaXRvciBmcm9tICcuL2VkaXRvci9jb21wb25lbnQuanMnXHJcbmltcG9ydCBMYXlvdXQgZnJvbSAnLi9sYXlvdXQvY29tcG9uZW50LmpzJ1xyXG5pbXBvcnQgU2xpZGVTaG93IGZyb20gJy4vc2xpZGVzaG93L2NvbXBvbmVudC5qcydcclxuaW1wb3J0IHsgZ2V0UHJlc2VudGF0aW9ucyB9IGZyb20gJy4vcHJlc2VudGF0aW9ucy9tb2RlbC5qcydcclxuaW1wb3J0IHsgbG9nIH0gZnJvbSAnLi9zZXJ2aWNlcy9pbmRleC5qcydcclxuXHJcbmNvbnN0IG1ha2VSb3V0ZXMgPSBtZGwgPT4ge1xyXG4gIGxldCBtb2RlbCA9IFN0cmVhbShtZGwpXHJcbiAgcmV0dXJuIHtcclxuICAgICcvcHJlc2VudGF0aW9ucyc6IHtcclxuICAgICAgdmlldzogKCkgPT4gbShMYXlvdXQsIG1vZGVsKCksIG0oUHJlc2VudGF0aW9ucywgbW9kZWwoKSkpLFxyXG4gICAgfSxcclxuICAgICcvcHJlc2VudGF0aW9uLzppZC9zbGlkZXMnOiB7XHJcbiAgICAgIHZpZXc6ICgpID0+IG0oTGF5b3V0LCBtb2RlbCgpLCBtKFNsaWRlcywgbW9kZWwoKSkpLFxyXG4gICAgfSxcclxuICAgICcvZWRpdC86cGlkL3NsaWRlLzppZCc6IHtcclxuICAgICAgdmlldzogKCkgPT4gbShMYXlvdXQsIG1vZGVsKCksIG0oRWRpdG9yLCBtb2RlbCgpKSksXHJcbiAgICB9LFxyXG4gICAgJy9zbGlkZXNob3cvOmlkJzoge1xyXG4gICAgICB2aWV3OiAoKSA9PiBtKExheW91dCwgbW9kZWwoKSwgbShTbGlkZVNob3csIG1vZGVsKCkpKSxcclxuICAgIH0sXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgQXBwID0gKHsgYXR0cnM6IG1vZGVsIH0pID0+IHtcclxuICBjb25zdCBzdGF0ZSA9IHtcclxuICAgIGVycm9yczogJycsXHJcbiAgfVxyXG5cclxuICBjb25zdCBvbkVycm9yID0gZXJyb3IgPT4ge1xyXG4gICAgbG9nKCdlcnJvcicpKGVycm9yKVxyXG4gICAgc3RhdGUuZXJyb3IgPSBlcnJvclxyXG4gIH1cclxuXHJcbiAgY29uc3Qgb25TdWNjZXNzID0gTW9kZWxzID0+IGR0byA9PiAoTW9kZWxzLlByZXNlbnRhdGlvbnMgPSBkdG8pXHJcblxyXG4gIGNvbnN0IGZpbmRQcmVzZW50YXRpb25zID0gKHsgYXR0cnM6IHsgTW9kZWxzIH0gfSkgPT5cclxuICAgIGdldFByZXNlbnRhdGlvbnMoKS5mb3JrKG9uRXJyb3IsIG9uU3VjY2VzcyhNb2RlbHMpKVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgb25pbml0OiBmaW5kUHJlc2VudGF0aW9ucyxcclxuICAgIG9uY3JlYXRlOiAoeyBkb20gfSkgPT4ge1xyXG4gICAgICBjb25zdCBtYWluID0gZG9tLnF1ZXJ5U2VsZWN0b3IoJy5tYWluJylcclxuXHJcbiAgICAgIG0ucm91dGUobWFpbiwgJy9wcmVzZW50YXRpb25zJywgbWFrZVJvdXRlcyhtb2RlbCkpXHJcbiAgICB9LFxyXG4gICAgdmlldzogKHsgY2hpbGRyZW4gfSkgPT4ge1xyXG4gICAgICByZXR1cm4gbSgnLmFwcCcsW20oJy5tYWluJywgY2hpbGRyZW4pXSlcclxuICAgIH0sXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBcHBcclxuIiwiaW1wb3J0IFN0cmVhbSBmcm9tICdtaXRocmlsLXN0cmVhbSdcclxuXHJcbmNvbnN0IFNsaWRlTW9kZWwgPSB7XHJcbiAgdGl0bGU6ICcnLFxyXG4gIGNvbnRlbnRzOiAnJyxcclxuICBvcmRlcjogMCxcclxuICBwcmVzZW50YXRpb25faWQ6ICcnLFxyXG59XHJcblxyXG5jb25zdCBTbGlkZXMgPSBbXVxyXG5cclxuY29uc3QgUHJlc2VudGF0aW9ucyA9IFtdXHJcblxyXG5jb25zdCBTbGlkZVNob3dTdHJ1Y3QgPSB7XHJcbiAga2V5czogbmV3IFNldCgpLFxyXG4gIHZhbHVlczoge30sXHJcbiAgaXRlbXM6IFN0cmVhbShbXSksXHJcbn1cclxuXHJcbmNvbnN0IEN1cnJlbnRQcmVzZW50YXRpb24gPSB7XHJcbiAgdGl0bGU6ICcnLFxyXG4gIGlkOiAnJyxcclxuICBzbGlkZVNob3c6IFN0cmVhbShbXSksXHJcbiAgU2xpZGVzLFxyXG59XHJcblxyXG5jb25zdCBnZXRQcm9maWxlID0gKHcpICA9PiB7XHJcbiAgaWYgKHcgPCA2NjgpIHJldHVybiAncGhvbmUnXHJcbiAgaWYgKHcgPCA5MjApIHJldHVybiAndGFibGV0J1xyXG4gIHJldHVybiAnZGVza3RvcCdcclxufVxyXG5cclxuY29uc3QgTW9kZWxzID0ge1xyXG4gIHByb2ZpbGU6ICBnZXRQcm9maWxlKHdpbmRvdy5pbm5lcldpZHRoKSxcclxuICBTbGlkZVNob3dTdHJ1Y3QsXHJcbiAgUHJlc2VudGF0aW9ucyxcclxuICBDdXJyZW50UHJlc2VudGF0aW9uLFxyXG4gIFNsaWRlTW9kZWwsXHJcbiAgdG9nZ2xlTW9kYWw6IGZhbHNlLFxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNb2RlbHNcclxuIiwiaW1wb3J0IG0gZnJvbSBcIm1pdGhyaWxcIlxyXG5pbXBvcnQgeyBpc0VtcHR5LCBsZW5ndGgsIHNwbGl0LCB2aWV3LCBsZW5zUHJvcCB9IGZyb20gXCJyYW1kYVwiXHJcblxyXG5jb25zdCB0b2dnbGVNb2RhbCA9IG1vZGVsID0+IHtcclxuICByZXR1cm4gW1xyXG4gICAgbShcclxuICAgICAgXCJhLnRvb2xiYXItaXRlbVwiLFxyXG4gICAgICB7XHJcbiAgICAgICAgb25jbGljazogKCkgPT4gKG1vZGVsLnRvZ2dsZU1vZGFsID0gIW1vZGVsLnRvZ2dsZU1vZGFsKSxcclxuICAgICAgfSxcclxuICAgICAgXCJBZGQgTmV3XCJcclxuICAgICksXHJcbiAgXVxyXG59XHJcbmNvbnN0IHRvUHJlc2VudGF0aW9ucyA9IFtcclxuICBtKFxyXG4gICAgXCJhLnRvb2xiYXItaXRlbVwiLFxyXG4gICAge1xyXG4gICAgICBvbmNyZWF0ZTogbS5yb3V0ZS5saW5rLFxyXG4gICAgICBocmVmOiBcIi9wcmVzZW50YXRpb25zXCIsXHJcbiAgICB9LFxyXG4gICAgXCJQcmVzZW50YXRpb25zXCJcclxuICApLFxyXG5dXHJcblxyXG5jb25zdCB0b1NsaWRlcyA9IG1vZGVsID0+IFtcclxuICBtKFxyXG4gICAgXCJhLnRvb2xiYXItaXRlbVwiLFxyXG4gICAge1xyXG4gICAgICBvbmNyZWF0ZTogbS5yb3V0ZS5saW5rLFxyXG4gICAgICBocmVmOiBgL3ByZXNlbnRhdGlvbi8ke21vZGVsLkN1cnJlbnRQcmVzZW50YXRpb24uaWR9L3NsaWRlc2AsXHJcbiAgICB9LFxyXG4gICAgXCJzbGlkZXNcIlxyXG4gICksXHJcbl1cclxuXHJcbmNvbnN0IHRvU2xpZGVTaG93ID0gbW9kZWwgPT4gW1xyXG4gIG0oXHJcbiAgICBcImEudG9vbGJhci1pdGVtXCIsXHJcbiAgICB7XHJcbiAgICAgIGRpc2FibGVkOiBpc0VtcHR5KGxlbmd0aChtb2RlbC5DdXJyZW50UHJlc2VudGF0aW9uLnNsaWRlU2hvdykpXHJcbiAgICAgICAgPyB0cnVlXHJcbiAgICAgICAgOiBmYWxzZSxcclxuICAgICAgb25jcmVhdGU6IG0ucm91dGUubGluayxcclxuICAgICAgaHJlZjogYC9zbGlkZXNob3cvJHttb2RlbC5DdXJyZW50UHJlc2VudGF0aW9uLmlkfWAsXHJcbiAgICB9LFxyXG4gICAgXCJTbGlkZSBTaG93XCJcclxuICApLFxyXG5dXHJcblxyXG5jb25zdCBuYXZWaWV3ID0gbW9kZWwgPT4gcGFnZSA9PiB7XHJcbiAgc3dpdGNoIChwYWdlKSB7XHJcbiAgICBjYXNlIFwicHJlc2VudGF0aW9uXCI6XHJcbiAgICAgIHJldHVybiBbdG9QcmVzZW50YXRpb25zLCB0b1NsaWRlU2hvdyhtb2RlbCldXHJcbiAgICAgIGJyZWFrXHJcblxyXG4gICAgY2FzZSBcInNsaWRlc2hvd1wiOlxyXG4gICAgICByZXR1cm4gW3RvUHJlc2VudGF0aW9ucywgdG9TbGlkZXMobW9kZWwpXVxyXG4gICAgICBicmVha1xyXG5cclxuICAgIGNhc2UgXCJzbGlkZXNcIjpcclxuICAgICAgcmV0dXJuIFt0b1ByZXNlbnRhdGlvbnMsIHRvU2xpZGVTaG93KG1vZGVsKV1cclxuICAgICAgYnJlYWtcclxuXHJcbiAgICBjYXNlIFwiZWRpdFwiOlxyXG4gICAgICByZXR1cm4gW3RvUHJlc2VudGF0aW9ucywgdG9TbGlkZXMobW9kZWwpLCB0b1NsaWRlU2hvdyhtb2RlbCldXHJcbiAgICAgIGJyZWFrXHJcbiAgICBkZWZhdWx0OlxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgYWN0aW9uVmlldyA9IG1vZGVsID0+IHBhZ2UgPT4ge1xyXG4gIHN3aXRjaCAocGFnZSkge1xyXG4gICAgY2FzZSBcInByZXNlbnRhdGlvbnNcIjpcclxuICAgICAgcmV0dXJuIFt0b2dnbGVNb2RhbChtb2RlbCldXHJcbiAgICAgIGJyZWFrXHJcbiAgICBjYXNlIFwicHJlc2VudGF0aW9uXCI6XHJcbiAgICAgIHJldHVybiBbdG9nZ2xlTW9kYWwobW9kZWwpXVxyXG4gICAgICBicmVha1xyXG4gICAgZGVmYXVsdDpcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IFRvb2xiYXIgPSAoeyBhdHRyczogeyBNb2RlbHMgfSB9KSA9PiB7XHJcbiAgY29uc3QgY3VycmVudFBhZ2UgPSB2aWV3KGxlbnNQcm9wKDEpLCBzcGxpdChcIi9cIiwgbS5yb3V0ZS5nZXQoKSkpXHJcbiAgcmV0dXJuIHtcclxuICAgIHZpZXc6ICh7IGF0dHJzOiB7IE1vZGVscyB9IH0pID0+XHJcbiAgICAgIG0oXCIudG9vbGJhclwiLCBbXHJcbiAgICAgICAgbShcIi50b29sYmFyLWxlZnRcIiwgW25hdlZpZXcoTW9kZWxzKShjdXJyZW50UGFnZSldKSxcclxuICAgICAgICBtKFwiLnRvb2xiYXItcmlnaHRcIiwgW2FjdGlvblZpZXcoTW9kZWxzKShjdXJyZW50UGFnZSldKSxcclxuICAgICAgXSksXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUb29sYmFyXHJcbiIsImltcG9ydCBtIGZyb20gXCJtaXRocmlsXCJcclxuaW1wb3J0IHsgbG9hZFNsaWRlLCBlZGl0U2xpZGUgfSBmcm9tIFwiLi9tb2RlbC5qc1wiXHJcbmltcG9ydCByZW1hcmthYmxlIGZyb20gXCJyZW1hcmthYmxlXCJcclxuXHJcbmNvbnN0IG1kID0gbmV3IHJlbWFya2FibGUoXCJmdWxsXCIsIHtcclxuICBiYXNlVXJsOiBudWxsLFxyXG4gIGJyZWFrczogZmFsc2UsXHJcbiAgZ2ZtOiB0cnVlLFxyXG4gIGhlYWRlcklkczogdHJ1ZSxcclxuICBoZWFkZXJQcmVmaXg6IFwiXCIsXHJcbiAgaGlnaGxpZ2h0OiBudWxsLFxyXG4gIGxhbmdQcmVmaXg6IFwibGFuZy1cIixcclxuICBtYW5nbGU6IHRydWUsXHJcbiAgcGVkYW50aWM6IGZhbHNlLFxyXG4gIHNhbml0aXplOiBmYWxzZSxcclxuICBzYW5pdGl6ZXI6IG51bGwsXHJcbiAgc2lsZW50OiB0cnVlLFxyXG4gIHNtYXJ0TGlzdHM6IHRydWUsXHJcbiAgc21hcnR5cGFudHM6IHRydWUsXHJcbiAgdGFibGVzOiB0cnVlLFxyXG4gIHhodG1sOiB0cnVlLFxyXG4gIGh0bWw6IHRydWUsXHJcbiAgbGlua2lmeTogdHJ1ZSxcclxuICBsaW5rVGFyZ2V0OiBcIlwiLFxyXG4gIHR5cG9ncmFwaGVyOiB0cnVlLFxyXG4gIHF1b3RlczogXCLigJzigJ3igJjigJlcIixcclxufSlcclxuXHJcbmNvbnN0IEVkaXRvciA9ICgpID0+IHtcclxuICBsZXQgc3RhdGUgPSB7IHByZXNlbnRhdGlvbklkOiBcIlwiLCBzbGlkZTogeyB0aXRsZTogXCJcIiwgY29udGVudDogXCJcIiwgaWQ6IFwiXCIgfSB9XHJcblxyXG4gIGNvbnN0IHRvU2xpZGVzID0gXyA9PlxyXG4gICAgbS5yb3V0ZS5zZXQoYC9wcmVzZW50YXRpb24vJHtzdGF0ZS5wcmVzZW50YXRpb25JZH0vc2xpZGVzYClcclxuXHJcbiAgY29uc3Qgb25FcnJvciA9IGVycm9yID0+IGxvZyhcImVycm9yXCIpKGVycm9yKVxyXG5cclxuICBjb25zdCBvblN1Y2Nlc3MgPSBzbGlkZSA9PiB7XHJcbiAgICBzdGF0ZS5zbGlkZSA9IHNsaWRlXHJcbiAgfVxyXG5cclxuICBjb25zdCBnZXRTbGlkZSA9ICgpID0+IHtcclxuICAgIHN0YXRlLnNsaWRlLmlkID0gbS5yb3V0ZS5wYXJhbShcImlkXCIpXHJcbiAgICBzdGF0ZS5wcmVzZW50YXRpb25JZCA9IG0ucm91dGUucGFyYW0oXCJwaWRcIilcclxuICAgIHJldHVybiBsb2FkU2xpZGUoc3RhdGUuc2xpZGUuaWQpLmZvcmsob25FcnJvciwgb25TdWNjZXNzKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgdXBkYXRlSW5wdXQgPSBpbnB1dCA9PiBlID0+IChzdGF0ZS5zbGlkZVtpbnB1dF0gPSBlLnRhcmdldC52YWx1ZSlcclxuXHJcbiAgY29uc3Qgc2F2ZSA9IGUgPT4ge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcblxyXG4gICAgZWRpdFNsaWRlKHN0YXRlLnNsaWRlKS5mb3JrKG9uRXJyb3IsICgpID0+IHRvU2xpZGVzKCkpXHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgb25jcmVhdGU6IGdldFNsaWRlLFxyXG4gICAgdmlldzogKHsgYXR0cnM6IHsgTW9kZWxzIH0gfSkgPT5cclxuICAgICAgbShcIi5jb250YWluZXJcIiwgW1xyXG4gICAgICAgIG0oXCIuZWRpdG9yLWxlZnQuY2FyZFwiLCBbXHJcbiAgICAgICAgICBtKFwiLmNhcmQtaGVhZGVyXCIsIFtcclxuICAgICAgICAgICAgbShcImlucHV0LmVkaXRvci1pbnB1dFwiLCB7XHJcbiAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXHJcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiU2xpZGUgVGl0bGVcIixcclxuICAgICAgICAgICAgICBvbmlucHV0OiB1cGRhdGVJbnB1dChcInRpdGxlXCIpLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiBzdGF0ZS5zbGlkZS50aXRsZSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICBdKSxcclxuICAgICAgICAgIG0oXCJ0ZXh0YXJlYS5lZGl0b3ItdGV4dFwiLCB7XHJcbiAgICAgICAgICAgIG9uaW5wdXQ6IHVwZGF0ZUlucHV0KFwiY29udGVudFwiKSxcclxuICAgICAgICAgICAgdmFsdWU6IHN0YXRlLnNsaWRlLmNvbnRlbnQsXHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICAgIG0oXCIuY2FyZC1mb290ZXJcIiwgW1xyXG4gICAgICAgICAgICBtKFxyXG4gICAgICAgICAgICAgIFwiYnV0dG9uLmNhcmQtYnRuXCIsXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb25jbGljazogc2F2ZSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIFwiU2F2ZVwiXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIG0oXHJcbiAgICAgICAgICAgICAgXCJidXR0b24uY2FyZC1idG5cIixcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiB0b1NsaWRlcyxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIFwiQ2FuY2VsXCJcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgIF0pLFxyXG4gICAgICAgIF0pLFxyXG4gICAgICAgIG0oXCIuZWRpdG9yLXJpZ2h0XCIsIG0udHJ1c3QobWQucmVuZGVyKHN0YXRlLnNsaWRlLmNvbnRlbnQgfHwgXCJcIikpKSxcclxuICAgICAgXSksXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFZGl0b3JcclxuIiwiaW1wb3J0IHsgZ2V0UWxUYXNrIH0gZnJvbSAnLi4vc2VydmljZXMvcmVxdWVzdHMuanMnXHJcbmltcG9ydCB7IHBhdGggfSBmcm9tICdyYW1kYSdcclxuXHJcbmV4cG9ydCBjb25zdCBsb2FkU2xpZGUgPSBpZCA9PiB7XHJcbiAgbGV0IHEgPSBgeyBzbGlkZSh3aGVyZTp7aWQ6JHtKU09OLnN0cmluZ2lmeShpZCl9fSl7XHJcbiAgICAgICAgICAgICAgaWQgY29udGVudCB0aXRsZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9YFxyXG4gIHJldHVybiBnZXRRbFRhc2socSkubWFwKHBhdGgoWydkYXRhJywgJ3NsaWRlJ10pKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZWRpdFNsaWRlID0gKHsgaWQsIHRpdGxlLCBjb250ZW50IH0pID0+IHtcclxuICBsZXQgcSA9IGBtdXRhdGlvbiB7XHJcbiAgICAgICAgICAgIHVwZGF0ZVNsaWRlKFxyXG4gICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAke0pTT04uc3RyaW5naWZ5KHRpdGxlKX1cclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICR7SlNPTi5zdHJpbmdpZnkoY29udGVudCl9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHdoZXJlOiB7XHJcbiAgICAgICAgICAgICAgICBpZDogJHtKU09OLnN0cmluZ2lmeShpZCl9XHJcbiAgICAgICAgICAgICAgfSkge1xyXG4gICAgICAgICAgICAgICAgaWRcclxuICAgICAgICAgICAgICAgIHRpdGxlXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1gXHJcblxyXG4gIHJldHVybiBnZXRRbFRhc2socSkubWFwKHBhdGgoWydkYXRhJywgJ3VwZGF0ZVByZXNlbnRhdGlvbicsICdTbGlkZXMnXSkpXHJcbn1cclxuIiwiLy8gaW5kZXguanN4XHJcblxyXG5pbXBvcnQgbSBmcm9tIFwibWl0aHJpbFwiXHJcbmNvbnN0IHJvb3QgPSBkb2N1bWVudC5ib2R5XHJcblxyXG5pbXBvcnQgXCIuL3N0eWxlcy9pbmRleC5jc3NcIlxyXG5pbXBvcnQgTW9kZWxzIGZyb20gXCIuL01vZGVscy5qc1wiXHJcbmltcG9ydCBBcHAgZnJvbSBcIi4vQXBwLmpzXCJcclxuXHJcbm0ucmVuZGVyKHJvb3QsIG0oQXBwLCB7IE1vZGVscyB9KSlcclxuIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCdcclxuaW1wb3J0IFRvb2xiYXIgZnJvbSAnLi4vVG9vbGJhci9jb21wb25lbnQuanMnXHJcblxyXG5jb25zdCBMYXlvdXQgPSB7XHJcbiAgdmlldzogKHsgY2hpbGRyZW4sIGF0dHJzOiBNb2RlbHMgfSkgPT4gW20oVG9vbGJhciwgTW9kZWxzKSwgY2hpbGRyZW5dLFxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMYXlvdXRcclxuIiwiaW1wb3J0IG0gZnJvbSBcIm1pdGhyaWxcIlxyXG5pbXBvcnQgeyBsb2cgfSBmcm9tIFwiLi4vLi4vc2VydmljZXMvaW5kZXguanNcIlxyXG5pbXBvcnQgeyB3aXRob3V0IH0gZnJvbSBcInJhbWRhXCJcclxuaW1wb3J0IHsgZGVsZXRlUHJlc2VudGF0aW9uc1Rhc2sgfSBmcm9tIFwiLi4vbW9kZWwuanNcIlxyXG5pbXBvcnQgVGFzayBmcm9tIFwiZGF0YS50YXNrXCJcclxuXHJcbmNvbnN0IFByZXNlbnRhdGlvbiA9ICh7IGF0dHJzOiB7IHRpdGxlLCBpZCwgTW9kZWxzIH0gfSkgPT4ge1xyXG4gIGNvbnN0IG9uRXJyb3IgPSB0YXNrID0+IGVycm9yID0+IGxvZyhgZXJyb3Igd2l0aCAke3Rhc2t9YCkoZXJyb3IpXHJcbiAgY29uc3Qgb25TdWNjZXNzID0gbW9kZWxzID0+IGRlbGV0ZWQgPT4ge1xyXG4gICAgcmV0dXJuIChNb2RlbHMuUHJlc2VudGF0aW9ucyA9IHdpdGhvdXQoW2RlbGV0ZWRdLCBNb2RlbHMuUHJlc2VudGF0aW9ucykpXHJcbiAgfVxyXG5cclxuICBjb25zdCBhdXRoRGVsZXRlVGFzayA9IGlkID0+XHJcbiAgICB3aW5kb3cuY29uZmlybShcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGU/XCIpXHJcbiAgICAgID8gVGFzay5vZihpZClcclxuICAgICAgOiBUYXNrLnJlamVjdGVkKGlkKVxyXG5cclxuICBjb25zdCByZW1vdmVQcmVzVGFzayA9IHBJZCA9PlxyXG4gICAgYXV0aERlbGV0ZVRhc2socElkKVxyXG4gICAgICAuY2hhaW4oZGVsZXRlUHJlc2VudGF0aW9uc1Rhc2spXHJcbiAgICAgIC5mb3JrKG9uRXJyb3IoXCJkZWxldGluZ1wiKSwgb25TdWNjZXNzKE1vZGVscykpXHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB2aWV3OiAoeyBhdHRyczogeyB0aXRsZSwgaWQsIE1vZGVscyB9IH0pID0+XHJcbiAgICAgIG0oXCIuY2FyZFwiLCBbXHJcbiAgICAgICAgbShcImRpdi5jYXJkLWhlYWRlclwiLCBbXHJcbiAgICAgICAgICBtKFxyXG4gICAgICAgICAgICBcIi5jYXJkLWJ0bi5mdWxsLXdpZHRoXCIsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiBtLnJvdXRlLnNldChgL3ByZXNlbnRhdGlvbi8ke2lkfS9zbGlkZXNgKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGl0bGVcclxuICAgICAgICAgICksXHJcbiAgICAgICAgICBtKFwiYnV0dG9uLmNhcmQtZGVsZXRlXCIsIHtcclxuICAgICAgICAgICAgb25jbGljazogKCkgPT4gcmVtb3ZlUHJlc1Rhc2soaWQpLFxyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgXSksXHJcbiAgICAgICAgbShcImRpdi5jYXJkLWJvZHlcIiwgW10pLFxyXG4gICAgICAgIG0oXCJkaXYuY2FyZC1mb290ZXJcIiwgW10pLFxyXG4gICAgICBdKSxcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFByZXNlbnRhdGlvblxyXG4iLCJpbXBvcnQgbSBmcm9tICdtaXRocmlsJ1xyXG5pbXBvcnQgeyBjbG9uZSB9IGZyb20gJ3JhbWRhJ1xyXG5pbXBvcnQge1xyXG4gIGFuaW1hdGVGYWRlSW4sXHJcbn0gZnJvbSAnLi4vc2VydmljZXMvYW5pbWF0aW9ucy5qcydcclxuaW1wb3J0IFByZXNlbnRhdGlvbk1vZGFsIGZyb20gJy4vcHJlc2VudGF0aW9uTW9kYWwuanMnXHJcbmltcG9ydCBQcmVzZW50YXRpb24gZnJvbSAnLi9QcmVzZW50YXRpb24vY29tcG9uZW50LmpzJ1xyXG5cclxuXHJcbmNvbnN0IFByZXNlbnRhdGlvbnMgPSAoeyBhdHRyczogeyBNb2RlbHMgfSB9KSA9PiB7XHJcbiAgY29uc3Qgc3RhdGUgPSB7XHJcbiAgICBlcnJvcnM6IFtdLFxyXG4gICAgdGl0bGU6ICcnLFxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHZpZXc6ICh7IGF0dHJzOiB7IE1vZGVscyB9IH0pID0+IFtcclxuICAgICAgTW9kZWxzLnRvZ2dsZU1vZGFsXHJcbiAgICAgICAgPyBtKFByZXNlbnRhdGlvbk1vZGFsLCB7XHJcbiAgICAgICAgICAgIE1vZGVscyxcclxuICAgICAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgICAgIHRvZ2dsZU1vZGFsOiAoKSA9PiAoTW9kZWxzLnRvZ2dsZU1vZGFsID0gIU1vZGVscy50b2dnbGVNb2RhbCksXHJcbiAgICAgICAgICAgIHByZXNlbnRhdGlvbnM6IE1vZGVscy5QcmVzZW50YXRpb25zLFxyXG4gICAgICAgICAgICBwcmVzZW50YXRpb25Nb2RlbDogY2xvbmUoTW9kZWxzLlByZXNlbnRhdGlvbk1vZGVsKSxcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgOiAnJyxcclxuXHJcbiAgICAgIG0oXHJcbiAgICAgICAgJy5jb250YWluZXIucHJlc2VudGF0aW9ucycsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgb25jcmVhdGU6ICh7IGRvbSB9KSA9PiBhbmltYXRlRmFkZUluKHsgZG9tIH0pLFxyXG4gICAgICAgICAgb25CZWZvcmVSZW1vdmU6ICh2bm9kZSwgZG9uZSkgPT4ge1xyXG4gICAgICAgICAgICB2bm9kZS5kb20uYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgZG9uZSlcclxuICAgICAgICAgICAgdm5vZGUuZG9tLnN0eWxlLmFuaW1hdGlvbiA9ICdmYWRlT3V0IDFzJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIFtcclxuICAgICAgICAgIE1vZGVscy5QcmVzZW50YXRpb25zICYmXHJcbiAgICAgICAgICAgIE1vZGVscy5QcmVzZW50YXRpb25zLm1hcCgoeyB0aXRsZSwgaWQgfSkgPT5cclxuICAgICAgICAgICAgICBtKFByZXNlbnRhdGlvbiwge1xyXG4gICAgICAgICAgICAgICAga2V5OiBpZCxcclxuICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgICAgICAgICBNb2RlbHMsXHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICBdXHJcbiAgICAgICksXHJcbiAgICBdLFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUHJlc2VudGF0aW9uc1xyXG4iLCJpbXBvcnQgeyBnZXRRbFRhc2sgfSBmcm9tICcuLi9zZXJ2aWNlcy9yZXF1ZXN0cy5qcydcclxuaW1wb3J0IHsgcGF0aCB9IGZyb20gJ3JhbWRhJ1xyXG5cclxuaW1wb3J0IHsgbG9nIH0gZnJvbSAnLi4vc2VydmljZXMvaW5kZXguanMnXHJcbmNvbnN0IHRvVmlld01vZGVsID0gKHsgZGF0YSwgZXJyb3JzIH0pID0+IHtcclxuICBjb25zb2xlLmxvZygnZXJyb3JzJywgZXJyb3JzKVxyXG4gIGNvbnNvbGUubG9nKCdkYXRhJywgZGF0YSlcclxuICByZXR1cm4geyBkYXRhLCBlcnJvcnMgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0UHJlc2VudGF0aW9ucyA9ICgpID0+XHJcbiAgZ2V0UWxUYXNrKGBxdWVyeSB7XHJcbiAgcHJlc2VudGF0aW9uc3sgaWQsIHRpdGxlfVxyXG59YCkubWFwKHBhdGgoWydkYXRhJywgJ3ByZXNlbnRhdGlvbnMnXSkpXHJcblxyXG5leHBvcnQgY29uc3Qgc2F2ZVByZXNlbnRhdGlvblRhc2sgPSBzdGF0ZSA9PiB7XHJcbiAgY29uc3QgcSA9IGBtdXRhdGlvbiB7XHJcbiAgICBjcmVhdGVQcmVzZW50YXRpb24oZGF0YToge3RpdGxlOiAke0pTT04uc3RyaW5naWZ5KHN0YXRlLnRpdGxlKX19KVxyXG4gICAgeyB0aXRsZSBpZH1cclxuICB9YFxyXG4gIHJldHVybiBnZXRRbFRhc2socSkubWFwKHBhdGgoWydkYXRhJywgJ2NyZWF0ZVByZXNlbnRhdGlvbiddKSlcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGRlbGV0ZVByZXNlbnRhdGlvbnNUYXNrID0gaWQgPT4ge1xyXG4gIGNvbnN0IHEgPSBgbXV0YXRpb24ge1xyXG4gICAgZGVsZXRlUHJlc2VudGF0aW9uKHdoZXJlOiB7aWQ6ICR7SlNPTi5zdHJpbmdpZnkoaWQpfX0pXHJcbiAgICB7IHRpdGxlIGlkfVxyXG4gIH1gXHJcbiAgcmV0dXJuIGdldFFsVGFzayhxKS5tYXAocGF0aChbJ2RhdGEnLCAnZGVsZXRlUHJlc2VudGF0aW9uJ10pKVxyXG59XHJcbiIsImltcG9ydCBtIGZyb20gXCJtaXRocmlsXCJcclxuaW1wb3J0IHsgc2F2ZVByZXNlbnRhdGlvblRhc2sgfSBmcm9tIFwiLi9tb2RlbC5qc1wiXHJcbmltcG9ydCB7IGxvZyB9IGZyb20gXCIuLi9zZXJ2aWNlcy9pbmRleC5qc1wiXHJcblxyXG5jb25zdCBQcmVzZW50YXRpb25Nb2RhbCA9ICh7IGF0dHJzIH0pID0+IHtcclxuICBjb25zdCBvbkVycm9yID0gZXJyb3JzID0+IHtcclxuICAgIGxvZyhcImVycm9yXCIpKGVycm9ycylcclxuICAgIGF0dHJzLnN0YXRlLmVycm9ycyA9IGVycm9yc1xyXG4gICAgYXR0cnMudG9nZ2xlTW9kYWwoKVxyXG4gIH1cclxuICBjb25zdCBvblN1Y2Nlc3MgPSBwID0+IHtcclxuICAgIGF0dHJzLnN0YXRlLnRpdGxlID0gXCJcIlxyXG4gICAgYXR0cnMuc3RhdGUuZXJyb3JzID0gW11cclxuICAgIGF0dHJzLnByZXNlbnRhdGlvbnMucHVzaChwKVxyXG4gICAgYXR0cnMudG9nZ2xlTW9kYWwoKVxyXG4gIH1cclxuXHJcbiAgY29uc3Qgc2F2ZSA9IGUgPT4ge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICBzYXZlUHJlc2VudGF0aW9uVGFzayhhdHRycy5zdGF0ZSkuZm9yayhvbkVycm9yLCBvblN1Y2Nlc3MpXHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgdmlldzogKCkgPT5cclxuICAgICAgbShcImFydGljbGUubW9kYWwtY29udGFpbmVyXCIsIFtcclxuICAgICAgICBtKFwiLmNhcmRcIiwgW1xyXG4gICAgICAgICAgbShcclxuICAgICAgICAgICAgXCIuY2FyZC1oZWFkZXJcIixcclxuICAgICAgICAgICAgbShcImJ1dHRvbi5jYXJkLWRlbGV0ZVwiLCB7XHJcbiAgICAgICAgICAgICAgb25jbGljazogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzLnRvZ2dsZU1vZGFsKClcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBcImNsb3NlXCIsXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgbShcIi5jYXJkLWJvZHlcIiwgW1xyXG4gICAgICAgICAgICBtKFwiZmllbGRzZXRcIiwgW1xyXG4gICAgICAgICAgICAgIG0oXCJsYWJlbC5tb2RhbC1sYWJlbFwiLCBcIlByZXNlbnRhdGlvbiBOYW1lXCIpLFxyXG4gICAgICAgICAgICAgIG0oXCJpbnB1dC5tb2RhbC1pbnB1dFwiLCB7XHJcbiAgICAgICAgICAgICAgICBhdXRvZm9jdXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcclxuICAgICAgICAgICAgICAgIG9uY2hhbmdlOiBlID0+IChhdHRycy5zdGF0ZS50aXRsZSA9IGUudGFyZ2V0LnZhbHVlKSxcclxuICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgXSksXHJcbiAgICAgICAgICBdKSxcclxuICAgICAgICAgIG0oXHJcbiAgICAgICAgICAgIFwiLmNhcmQtZm9vdGVyXCIsXHJcbiAgICAgICAgICAgIG0oXCJidXR0b24uY2FyZC1idG5cIiwgeyBvbmNsaWNrOiBzYXZlIH0sIFwic2F2ZSBwcmVzZW50YXRpb25cIilcclxuICAgICAgICAgICksXHJcbiAgICAgICAgXSksXHJcbiAgICAgIF0pLFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUHJlc2VudGF0aW9uTW9kYWxcclxuIiwiaW1wb3J0IG0gZnJvbSBcIm1pdGhyaWxcIlxyXG5pbXBvcnQgVGFzayBmcm9tIFwiZGF0YS50YXNrXCJcclxuaW1wb3J0IHsgbWFrZVF1ZXJ5IH0gZnJvbSBcIi4vaW5kZXguanNcIlxyXG5pbXBvcnQgeyBvbmxpbmVVcmwgfSBmcm9tIFwiLi4vLi4vc2VjcmV0LmpzXCJcclxuXHJcbmV4cG9ydCBjb25zdCBwb3N0UWwgPSBxdWVyeSA9PlxyXG4gIG5ldyBUYXNrKChyZWosIHJlcykgPT5cclxuICAgIG1cclxuICAgICAgLnJlcXVlc3Qoe1xyXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgdXJsOiBgJHtvbmxpbmVVcmx9YCxcclxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxyXG4gICAgICAgIGJvZHk6IG1ha2VRdWVyeShxdWVyeSksXHJcbiAgICAgIH0pXHJcbiAgICAgIC50aGVuKHJlcywgcmVqKVxyXG4gIClcclxuXHJcbmNvbnN0IHBvc3RUYXNrID0gdXJsID0+ICh7IGR0byB9KSA9PlxyXG4gIG5ldyBUYXNrKChyZWosIHJlcykgPT5cclxuICAgIG1cclxuICAgICAgLnJlcXVlc3Qoe1xyXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgdXJsOiBgJHtvbmxpbmVVcmx9LyR7dXJsfWAsXHJcbiAgICAgICAgYm9keTogZHRvLFxyXG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXHJcbiAgICAgIH0pXHJcbiAgICAgIC50aGVuKHJlcywgcmVqKVxyXG4gIClcclxuXHJcbmNvbnN0IHB1dFRhc2sgPSB1cmwgPT4gKHsgZHRvIH0pID0+XHJcbiAgbmV3IFRhc2soKHJlaiwgcmVzKSA9PlxyXG4gICAgbVxyXG4gICAgICAucmVxdWVzdCh7XHJcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxyXG4gICAgICAgIHVybDogYCR7b25saW5lVXJsfS8ke3VybH1gLFxyXG4gICAgICAgIGJvZHk6IGR0byxcclxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxyXG4gICAgICB9KVxyXG4gICAgICAudGhlbihyZXMsIHJlailcclxuICApXHJcblxyXG5jb25zdCBnZXRUYXNrID0gdXJsID0+XHJcbiAgbmV3IFRhc2soKHJlaiwgcmVzKSA9PlxyXG4gICAgbVxyXG4gICAgICAucmVxdWVzdCh7XHJcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxyXG4gICAgICAgIHVybDogYCR7b25saW5lVXJsfS8ke3VybH1gLFxyXG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXHJcbiAgICAgIH0pXHJcbiAgICAgIC50aGVuKHJlcywgcmVqKVxyXG4gIClcclxuXHJcbmNvbnN0IGRlbGV0ZVRhc2sgPSB1cmwgPT4gaWQgPT5cclxuICBuZXcgVGFzaygocmVqLCByZXMpID0+XHJcbiAgICBtXHJcbiAgICAgIC5yZXF1ZXN0KHtcclxuICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXHJcbiAgICAgICAgdXJsOiBgJHtvbmxpbmVVcmx9LyR7dXJsfS8ke2lkfWAsXHJcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcclxuICAgICAgfSlcclxuICAgICAgLnRoZW4ocmVzLCByZWopXHJcbiAgKVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgeyBwb3N0VGFzaywgcHV0VGFzaywgZ2V0VGFzaywgZGVsZXRlVGFzaywgcG9zdFFsIH1cclxuIiwiaW1wb3J0IGFuaW1lIGZyb20gXCJhbmltZWpzXCJcclxuXHJcbmV4cG9ydCBjb25zdCBhbmltYXRlU2xpZGVFbnRyYW5jZSA9ICh7IGRvbSB9KSA9PiB7XHJcbiAgcmV0dXJuIGRvbS5hbmltYXRlKFxyXG4gICAgW1xyXG4gICAgICB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUzZCgyMCUsMCwwKVwiLCBvcGFjaXR5OiAwIH0sXHJcbiAgICAgIHsgdHJhbnNmb3JtOiBcIm5vbmVcIiwgb3BhY2l0eTogMSB9XHJcbiAgICBdLFxyXG4gICAge1xyXG4gICAgICBkdXJhdGlvbjogNjUwXHJcbiAgICB9XHJcbiAgKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYW5pbWF0ZUVudHJhbmNlUmlnaHQgPSAoeyBkb20gfSkgPT4ge1xyXG4gIHJldHVybiBkb20uYW5pbWF0ZShcclxuICAgIFtcclxuICAgICAge1xyXG4gICAgICAgIGFuaW1hdGlvbjogXCJcIixcclxuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlM2QoMTAwJSwwLDApXCIsXHJcbiAgICAgICAgc2NhbGU6IDIsXHJcbiAgICAgICAgb3BhY2l0eTogMFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgYW5pbWF0aW9uOiBcInN0cmV0Y2hSaWdodCAxcyBlYXNlLWluLW91dCBib3RoXCIsXHJcbiAgICAgICAgdHJhbnNmb3JtOiBcIm5vbmVcIixcclxuICAgICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICAgIHNjYWxlOiAxXHJcbiAgICAgIH1cclxuICAgIF0sXHJcbiAgICB7XHJcbiAgICAgIGR1cmF0aW9uOiAzNTBcclxuICAgIH1cclxuICApXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBhbmltYXRlQ2hpbGRFbnRyYW5jZSA9ICh7IGRvbSB9KSA9PiB7XHJcbiAgY29uc29sZS5sb2coXCJ3dGZcIiwgZG9tKVxyXG4gIGxldCBjaGlsZHJlbiA9IFsuLi5kb20uY2hpbGRyZW5dXHJcblxyXG4gIHJldHVybiBjaGlsZHJlbi5tYXAoKGNoaWxkLCBpbmRleCkgPT4ge1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIGNoaWxkLmFuaW1hdGUoXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IFwidHJhbnNsYXRlM2QoMCwtMTAwJSwwKVwiLCBvcGFjaXR5OiAwIH0sXHJcbiAgICAgICAgICB7IHRyYW5zZm9ybTogXCJub25lXCIsIG9wYWNpdHk6IDEgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgZHVyYXRpb246IDg1MFxyXG4gICAgICAgIH1cclxuICAgICAgKVxyXG4gICAgfSwgKGluZGV4ICsgMSkgKiAyMDApXHJcbiAgfSlcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGFuaW1hdGVFeGl0ID0gKGRvbSkgPT4ge1xyXG4gIGxldCBjaGlsZHJlbiA9IFsuLi5kb20uY2hpbGRyZW5dXHJcblxyXG4gIGxldCBhbmltID0gYW5pbWF0ZShbXHJcbiAgICB7IHRyYW5zZm9ybTogXCJub25lXCIsIG9wYWNpdHk6IDEgfSxcclxuICAgIHsgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZTNkKDI1JSwxMDAlLDApXCIsIG9wYWNpdHk6IDAgfVxyXG4gIF0pXHJcblxyXG4gIGxldCB3YWFwaSA9IGNoaWxkcmVuLm1hcCgoY2hpbGQpID0+XHJcbiAgICBjaGlsZC5hbmltYXRlKGFuaW0sIHtcclxuICAgICAgZHVyYXRpb246IDg1MFxyXG4gICAgfSlcclxuICApXHJcblxyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgd2FhcGkub25maW5pc2ggPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgIHJlc29sdmUoKVxyXG4gICAgfVxyXG4gIH0pXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBhbmltYXRlRmFkZUluID0gKHsgZG9tIH0pID0+IHtcclxuICBsZXQgY2hpbGRyZW4gPSBbLi4uZG9tLmNoaWxkcmVuXVxyXG4gIGNoaWxkcmVuLm1hcCgoY2hpbGQsIGluZGV4KSA9PiB7XHJcbiAgICBjaGlsZC5zdHlsZS5vcGFjaXR5ID0gMFxyXG4gICAgY2hpbGQuc3R5bGUudHJhbnNpdGlvbiA9IFwib3BhY2l0eSAuNHMgZWFzZS1pbi1vdXRcIlxyXG5cclxuICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgY2hpbGQuc3R5bGUub3BhY2l0eSA9IDFcclxuICAgIH0sIChpbmRleCArIDEpICogMjAwKVxyXG4gIH0pXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBhbmltYXRlRmFkZU91dCA9ICh7IGRvbSB9KSA9PiB7XHJcbiAgbGV0IGFuaW0gPSBbXHJcbiAgICB7IHRyYW5zaXRpb246IFwib3BhY2l0eSAuNHMgZWFzZS1pbi1vdXRcIiB9LFxyXG4gICAgeyB0cmFuc2Zvcm06IFwibm9uZVwiLCBvcGFjaXR5OiAxIH0sXHJcbiAgICB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUzZCgyNSUsMTAwJSwwKVwiLCBvcGFjaXR5OiAwIH1cclxuICBdXHJcbiAgbGV0IHdhYXBpID0gZG9tLmFuaW1hdGUoYW5pbSwge1xyXG4gICAgZHVyYXRpb246IDg1MFxyXG4gIH0pXHJcblxyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgd2FhcGkub25maW5pc2ggPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgIHJlc29sdmUoKVxyXG4gICAgfVxyXG4gIH0pXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBhbmltZUVudHJhbmNlID0gKHsgZG9tIH0pID0+IHtcclxuICBsZXQgY2hpbGRyZW4gPSBbLi4uZG9tLmNoaWxkcmVuXVxyXG4gIGNvbnNvbGUubG9nKGNoaWxkcmVuKVxyXG4gIGNvbnN0IHJlcyA9IGNoaWxkcmVuLm1hcCgoZWwpID0+XHJcbiAgICBhbmltZSh7XHJcbiAgICAgIHRhcmdldDogZWwsXHJcbiAgICAgIGVhc2luZzogXCJlYXNlSW5RdWFkXCIsXHJcbiAgICAgIHRyYW5zbGF0ZVg6IDI1MCxcclxuICAgICAgb2Zmc2V0OiAwXHJcbiAgICB9KVxyXG4gIClcclxuXHJcbiAgY29uc29sZS5sb2coXCJhbmltXCIsIHJlcylcclxuICByZXR1cm4gcmVzXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBib3VuY2VFbnRyYW5jZSA9ICh7IGRvbSB9KSA9PiB7XHJcbiAgcmV0dXJuIGRvbS5hbmltYXRlKHtcclxuICAgIGFuaW1hdGlvbjogXCJhbmltYXRpb24gMTAwMG1zIGxpbmVhciBib3RoXCIsXHJcbiAgICBrZXlmcmFtZXM6IHtcclxuICAgICAgXCIwJVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBcIm1hdHJpeDNkKDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCIzLjQlXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDEuMzE2LCAwLCAwLCAwLCAwLCAxLjQwNywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIjQuNyVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMS40NSwgMCwgMCwgMCwgMCwgMS41OTksIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCI2LjgxJVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgxLjY1OSwgMCwgMCwgMCwgMCwgMS44OTMsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCI5LjQxJVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgxLjg4MywgMCwgMCwgMCwgMCwgMi4xNjgsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCIxMC4yMSVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMS45NDIsIDAsIDAsIDAsIDAsIDIuMjI2LCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiMTMuNjElXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDIuMTIzLCAwLCAwLCAwLCAwLCAyLjMzMiwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIjE0LjExJVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgyLjE0MSwgMCwgMCwgMCwgMCwgMi4zMzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCIxNy41MiVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMi4yMDgsIDAsIDAsIDAsIDAsIDIuMjM5LCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiMTguNzIlXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDIuMjEyLCAwLCAwLCAwLCAwLCAyLjE4NywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIjIxLjMyJVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgyLjE5NiwgMCwgMCwgMCwgMCwgMi4wNjksIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCIyNC4zMiVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMi4xNTEsIDAsIDAsIDAsIDAsIDEuOTYsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCIyNS4yMyVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMi4xMzQsIDAsIDAsIDAsIDAsIDEuOTM4LCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiMjkuMDMlXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDIuMDYzLCAwLCAwLCAwLCAwLCAxLjg5NywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIjI5LjkzJVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgyLjA0OCwgMCwgMCwgMCwgMCwgMS44OTksIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCIzNS41NCVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMS45NzksIDAsIDAsIDAsIDAsIDEuOTYyLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiMzYuNzQlXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDEuOTcyLCAwLCAwLCAwLCAwLCAxLjk3OSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIjQxLjA0JVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgxLjk2MSwgMCwgMCwgMCwgMCwgMi4wMjIsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCI0NC40NCVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMS45NjYsIDAsIDAsIDAsIDAsIDIuMDMyLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiNTIuMTUlXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDEuOTkxLCAwLCAwLCAwLCAwLCAyLjAwNiwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIjU5Ljg2JVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgyLjAwNiwgMCwgMCwgMCwgMCwgMS45OSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIjYzLjI2JVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgyLjAwNywgMCwgMCwgMCwgMCwgMS45OTIsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCI3NS4yOCVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMi4wMDEsIDAsIDAsIDAsIDAsIDIuMDAzLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiODUuNDklXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDEuOTk5LCAwLCAwLCAwLCAwLCAyLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiOTAuNjklXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDEuOTk5LCAwLCAwLCAwLCAwLCAxLjk5OSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIjEwMCVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTogXCJtYXRyaXgzZCgyLCAwLCAwLCAwLCAwLCAyLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KVxyXG59XHJcbiIsImltcG9ydCBTdHJlYW0gZnJvbSAnbWl0aHJpbC1zdHJlYW0nXHJcblxyXG5jb25zdCBtYWtlUXVlcnkgPSBzdHJpbmcgPT4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdHJpbmcpKVxyXG5cclxuY29uc3QgcmVwZWF0ID0gbiA9PiBmID0+IHggPT4ge1xyXG4gIGxldCBtID0gblxyXG4gIHdoaWxlICh0cnVlKSB7XHJcbiAgICBpZiAobSA9PT0gMCkgcmV0dXJuIHhcclxuICAgIGVsc2UgKG0gPSBtIC0gMSksICh4ID0gZih4KSlcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IHdhaXQgPSBuID0+IGYgPT4geCA9PiB7XHJcbiAgbGV0IG0gPSBuXHJcbiAgd2hpbGUgKHRydWUpIHtcclxuICAgIGlmIChtID09PSAwKSByZXR1cm4geFxyXG4gICAgZWxzZSAobSA9IG0gLSAxKSwgKHggPSBmKHgpKVxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgbG9nID0gbSA9PiB2ID0+IHtcclxuICBjb25zb2xlLmxvZyhtLCB2KVxyXG4gIHJldHVybiB2XHJcbn1cclxuXHJcbmNvbnN0IHZpZXdNb2RlbE1hcCA9IHNpZ25hdHVyZSA9PiB7XHJcbiAgdmFyIF9tYXAgPSB7fVxyXG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcclxuICAgIGlmICghX21hcFtrZXldKSB7XHJcbiAgICAgIF9tYXBba2V5XSA9IHt9XHJcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc2lnbmF0dXJlKSBfbWFwW2tleV1bcHJvcF0gPSBTdHJlYW0oc2lnbmF0dXJlW3Byb3BdKCkpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gX21hcFtrZXldXHJcbiAgfVxyXG59XHJcbmV4cG9ydCB7IHZpZXdNb2RlbE1hcCwgbG9nLCByZXBlYXQsIHdhaXQsIG1ha2VRdWVyeSB9XHJcbiIsImltcG9ydCBodHRwVGFza3MgZnJvbSAnLi9UYXNrcy5qcydcclxuaW1wb3J0IFRhc2sgZnJvbSAnZGF0YS50YXNrJ1xyXG5pbXBvcnQgeyBzZXF1ZW5jZSB9IGZyb20gJ3JhbWRhJ1xyXG5cclxuaW1wb3J0IHsgbG9nIH0gZnJvbSAnLi9pbmRleC5qcydcclxuXHJcbmV4cG9ydCBjb25zdCBmaW5kUHJlc2VudGF0aW9uc1Rhc2sgPSAoKSA9PiBodHRwVGFza3MuZ2V0VGFzaygncHJlc2VudGF0aW9ucycpXHJcblxyXG5leHBvcnQgY29uc3QgZ2V0UWxUYXNrID0gcXVlcnkgPT4gaHR0cFRhc2tzLnBvc3RRbCh7IHF1ZXJ5IH0pXHJcblxyXG5leHBvcnQgY29uc3Qgc2F2ZVByZXNlbnRhdGlvblRhc2sgPSBkdG8gPT5cclxuICBodHRwVGFza3MucG9zdFRhc2soYHByZXNlbnRhdGlvbnNgKSh7XHJcbiAgICBkdG8sXHJcbiAgfSlcclxuXHJcbmV4cG9ydCBjb25zdCBkZWxldGVQcmVzZW50YXRpb25zVGFzayA9IGlkID0+XHJcbiAgaHR0cFRhc2tzLmRlbGV0ZVRhc2soJ3ByZXNlbnRhdGlvbnMnKShpZClcclxuXHJcbmV4cG9ydCBjb25zdCBmaW5kU2xpZGVzVGFzayA9IGlkID0+XHJcbiAgaHR0cFRhc2tzLmdldFRhc2soYHByZXNlbnRhdGlvbnMvJHtpZH0vc2xpZGVzYClcclxuXHJcbmV4cG9ydCBjb25zdCBzYXZlU2xpZGVUYXNrID0gZHRvID0+IGh0dHBUYXNrcy5wb3N0VGFzayhgc2xpZGVzYCkoeyBkdG8gfSlcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVTbGlkZVRhc2sgPSBpZCA9PiBkdG8gPT5cclxuICBodHRwVGFza3MucHV0VGFzayhgc2xpZGVzLyR7aWR9YCkoeyBkdG8gfSlcclxuXHJcbmV4cG9ydCBjb25zdCBkZWxldGVTbGlkZVRhc2sgPSBpZCA9PiBodHRwVGFza3MuZGVsZXRlVGFzaygnc2xpZGVzJykoaWQpXHJcblxyXG5leHBvcnQgY29uc3QgbG9hZFNsaWRlVGFzayA9IGlkID0+IGh0dHBUYXNrcy5nZXRUYXNrKGBzbGlkZXMvJHtpZH1gKVxyXG4iLCJpbXBvcnQgbSBmcm9tIFwibWl0aHJpbFwiXHJcbmltcG9ydCB7IGNvbmNhdCwgZXFQcm9wcywgY29tcG9zZSwgZmlsdGVyLCBtYXAsIHByb3BFcSwgaGVhZCB9IGZyb20gXCJyYW1kYVwiXHJcbmltcG9ydCB7IGxvZyB9IGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9pbmRleC5qc1wiXHJcbmltcG9ydCB7IGFuaW1hdGVFeGl0LCBhbmltYXRlRmFkZUluIH0gZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2FuaW1hdGlvbnMuanNcIlxyXG5pbXBvcnQge1xyXG4gIGZvckdyZWF0ZXIsXHJcbiAgcmVkdWNlT3JkZXIsXHJcbiAgdXBkYXRlUmVtb3ZlU2xpZGUsXHJcbiAgdXBkYXRlU2xpZGVUYXNrLFxyXG59IGZyb20gXCIuLi9tb2RlbC5qc1wiXHJcbmltcG9ydCByZW1hcmthYmxlIGZyb20gXCJyZW1hcmthYmxlXCJcclxuXHJcbmNvbnN0IG1kID0gbmV3IHJlbWFya2FibGUoXCJmdWxsXCIsIHtcclxuICBiYXNlVXJsOiBudWxsLFxyXG4gIGJyZWFrczogZmFsc2UsXHJcbiAgZ2ZtOiB0cnVlLFxyXG4gIGhlYWRlcklkczogdHJ1ZSxcclxuICBoZWFkZXJQcmVmaXg6IFwiXCIsXHJcbiAgaGlnaGxpZ2h0OiBudWxsLFxyXG4gIGxhbmdQcmVmaXg6IFwibGFuZy1cIixcclxuICBtYW5nbGU6IHRydWUsXHJcbiAgcGVkYW50aWM6IGZhbHNlLFxyXG4gIHNhbml0aXplOiBmYWxzZSxcclxuICBzYW5pdGl6ZXI6IG51bGwsXHJcbiAgc2lsZW50OiB0cnVlLFxyXG4gIHNtYXJ0TGlzdHM6IHRydWUsXHJcbiAgc21hcnR5cGFudHM6IHRydWUsXHJcbiAgdGFibGVzOiB0cnVlLFxyXG4gIHhodG1sOiB0cnVlLFxyXG4gIGh0bWw6IHRydWUsXHJcbiAgbGlua2lmeTogdHJ1ZSxcclxuICBsaW5rVGFyZ2V0OiBcIlwiLFxyXG4gIHR5cG9ncmFwaGVyOiB0cnVlLFxyXG4gIHF1b3RlczogXCLigJzigJ3igJjigJlcIixcclxufSlcclxuXHJcbmNvbnN0IFByZXZpZXcgPSAoeyBhdHRyczogeyBnZXRTbGlkZXMsIE1vZGVscywgcywga2V5LCBzdGF0ZSB9IH0pID0+IHtcclxuICBjb25zdCBvbkVycm9yID0gdGFzayA9PiBlcnJvciA9PiBsb2coYGVycm9yIHdpdGggJHt0YXNrfWApKGVycm9yKVxyXG4gIGNvbnN0IG9uU3VjY2VzcyA9IF8gPT4gZ2V0U2xpZGVzKHsgYXR0cnM6IHsgTW9kZWxzIH0gfSlcclxuXHJcbiAgY29uc3QgdXBkYXRlQW5kU2F2ZVNsaWRlVGFzayA9IHNsaWRlcyA9PiB7XHJcbiAgICByZXR1cm4gdXBkYXRlU2xpZGVUYXNrKE1vZGVscy5DdXJyZW50UHJlc2VudGF0aW9uLmlkKShzbGlkZXMpLmZvcmsoXHJcbiAgICAgIG9uRXJyb3IoXCJ1cGRhdGluZ1wiKSxcclxuICAgICAgb25TdWNjZXNzXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICBjb25zdCByZW1vdmVTbGlkZVRhc2sgPSBzID0+IHtcclxuICAgIGxldCB0YWlsID0gY29tcG9zZShcclxuICAgICAgbWFwKHJlZHVjZU9yZGVyKSxcclxuICAgICAgZmlsdGVyKGZvckdyZWF0ZXIocykpXHJcbiAgICApKHN0YXRlLnJpZ2h0KCkpXHJcbiAgICBsZXQgcmVtb3ZlU2xpZGUgPSB1cGRhdGVSZW1vdmVTbGlkZShzKVxyXG5cclxuICAgIGxldCB1cGRhdGVMaXN0ID0gY29uY2F0KHJlbW92ZVNsaWRlLCB0YWlsKVxyXG5cclxuICAgIHVwZGF0ZUFuZFNhdmVTbGlkZVRhc2sodXBkYXRlTGlzdClcclxuICB9XHJcblxyXG4gIGNvbnN0IGhhbmRsZURyYWdTdGFydCA9IGV2ID0+IHtcclxuICAgIGV2LnRhcmdldC5zdHlsZS5vcGFjaXR5ID0gXCIwLjRcIlxyXG4gICAgZXYuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcIm1vdmVcIlxyXG4gICAgZXYuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIFwicHJldmlld1wiKVxyXG4gICAgc3RhdGUucHJldmlld0RyYWcuZHJhZyA9IGhlYWQoZmlsdGVyKHByb3BFcShcImlkXCIsIHMuaWQpLCBzdGF0ZS5yaWdodCgpKSlcclxuICB9XHJcblxyXG4gIGNvbnN0IGhhbmRsZURyYWdPdmVyID0gZXYgPT4ge1xyXG4gICAgZXYucHJldmVudERlZmF1bHQoKVxyXG5cclxuICAgIGlmIChzdGF0ZS5wcmV2aWV3RHJhZy5kcmFnKSBzdGF0ZS5wcmV2aWV3RHJhZy5kcm9wID0gc1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaGFuZGxlRHJhZ0xlYXZlID0gZXYgPT4ge1xyXG4gICAgZXYucHJldmVudERlZmF1bHQoKVxyXG4gICAgc3RhdGUucHJldmlld0RyYWcuZHJvcCA9IG51bGxcclxuICB9XHJcblxyXG4gIGNvbnN0IGhhbmRsZURyb3AgPSBldiA9PiBldi5wcmV2ZW50RGVmYXVsdCgpXHJcblxyXG4gIGNvbnN0IGhhbmRsZURyYWdFbmQgPSBldiA9PiB7XHJcbiAgICBldi50YXJnZXQuc3R5bGUub3BhY2l0eSA9IFwiMVwiXHJcbiAgICBzdGF0ZS5zbGlkZURyYWcuZHJhZ2dpbmcgPSBmYWxzZVxyXG4gICAgaWYgKHN0YXRlLnByZXZpZXdEcmFnLmRyb3ApIHtcclxuICAgICAgbGV0IHN0YXJ0ID0gc3RhdGUucHJldmlld0RyYWcuZHJhZy5vcmRlclxyXG4gICAgICBsZXQgZW5kID0gc3RhdGUucHJldmlld0RyYWcuZHJvcC5vcmRlclxyXG5cclxuICAgICAgbGV0IGRyYWdnZWQgPSBzdGF0ZS5wcmV2aWV3RHJhZy5kcmFnXHJcbiAgICAgIGxldCBkcm9wcGVkID0gc3RhdGUucHJldmlld0RyYWcuZHJvcFxyXG5cclxuICAgICAgc3RhdGUucHJldmlld0RyYWcuZHJhZyA9IE1vZGVscy5TbGlkZU1vZGVsXHJcbiAgICAgIHN0YXRlLnByZXZpZXdEcmFnLmRyb3AgPSBNb2RlbHMuU2xpZGVNb2RlbFxyXG5cclxuICAgICAgaWYgKCFlcVByb3BzKFwiaWRcIiwgZHJhZ2dlZCwgZHJvcHBlZCkpIHtcclxuICAgICAgICBkcmFnZ2VkLm9yZGVyID0gZW5kXHJcbiAgICAgICAgZHJvcHBlZC5vcmRlciA9IHN0YXJ0XHJcblxyXG4gICAgICAgIHVwZGF0ZUFuZFNhdmVTbGlkZVRhc2soW2RyYWdnZWQsIGRyb3BwZWRdKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgb25jcmVhdGU6ICh7IGRvbSB9KSA9PiBhbmltYXRlRmFkZUluKHsgZG9tIH0pLFxyXG4gICAgdmlldzogKHsgYXR0cnM6IHsgcywgc3RhdGUgfSB9KSA9PlxyXG4gICAgICBtKFxyXG4gICAgICAgIFwiLmNhcmQucHJldmlld1wiLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcclxuICAgICAgICAgIG9uZHJhZ3N0YXJ0OiBoYW5kbGVEcmFnU3RhcnQsXHJcbiAgICAgICAgICBvbmRyYWdlbmQ6IGhhbmRsZURyYWdFbmQsXHJcbiAgICAgICAgICBvbmRyYWdvdmVyOiBoYW5kbGVEcmFnT3ZlcixcclxuICAgICAgICAgIG9uZHJvcDogaGFuZGxlRHJvcCxcclxuICAgICAgICAgIG9uZHJhZ2xlYXZlOiBoYW5kbGVEcmFnTGVhdmUsXHJcbiAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBvcGFjaXR5OlxyXG4gICAgICAgICAgICAgIHN0YXRlLnByZXZpZXdEcmFnLmRyb3AgJiYgc3RhdGUucHJldmlld0RyYWcuZHJvcC5pZCA9PSBzLmlkXHJcbiAgICAgICAgICAgICAgICA/IDAuNFxyXG4gICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIFtcclxuICAgICAgICAgIG0oXCIuY2FyZC1oZWFkZXJcIiwgW1xyXG4gICAgICAgICAgICBtKFwic3Bhbi5zbGlkZVBvc2l0aW9uXCIsIHMub3JkZXIpLFxyXG4gICAgICAgICAgICBtKFwiYS5wcmV2aWV3LWRlbGV0ZS5jYXJkLWRlbGV0ZVwiLCB7XHJcbiAgICAgICAgICAgICAgb25jbGljazogKCkgPT4gcmVtb3ZlU2xpZGVUYXNrKHMpLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgIF0pLFxyXG4gICAgICAgICAgbShcIi5jYXJkLWJvZHlcIiwgbS50cnVzdChtZC5yZW5kZXIocy5jb250ZW50KSkpLFxyXG4gICAgICAgIF1cclxuICAgICAgKSxcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFByZXZpZXdcclxuIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCdcclxuaW1wb3J0IFRhc2sgZnJvbSAnZGF0YS50YXNrJ1xyXG5pbXBvcnQgeyBsb2csIG1ha2VRdWVyeSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2luZGV4LmpzJ1xyXG5pbXBvcnQgeyB0YWtlLCBwcm9wIH0gZnJvbSAncmFtZGEnXHJcbmltcG9ydCB7XHJcbiAgdXBkYXRlU2xpZGVEcmFnU3RhcnQsXHJcbiAgdXBkYXRlU2xpZGVEcmFnRW5kLFxyXG4gIHVwZGF0ZVN0YXRlRHJhZ0VuZCxcclxuICB1cGRhdGVTbGlkZVRhc2ssXHJcbiAgZGVsZXRlU2xpZGVUYXNrLFxyXG59IGZyb20gJy4uL21vZGVsLmpzJ1xyXG5cclxuY29uc3QgU2xpZGUgPSAoeyBhdHRyczogeyBnZXRTbGlkZXMsIE1vZGVscywgcywga2V5LCBzdGF0ZSB9IH0pID0+IHtcclxuICBjb25zdCBvbkVycm9yID0gdGFzayA9PiBlcnJvciA9PiBsb2coYGVycm9yIHdpdGggJHt0YXNrfWApKGVycm9yKVxyXG4gIGNvbnN0IG9uU3VjY2VzcyA9IF8gPT4gZ2V0U2xpZGVzKHsgYXR0cnM6IHsgTW9kZWxzIH0gfSlcclxuXHJcbiAgY29uc3QgYXV0aERlbGV0ZVRhc2sgPSBpZCA9PlxyXG4gICAgd2luZG93LmNvbmZpcm0oJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGU/JylcclxuICAgICAgPyBUYXNrLm9mKGlkKVxyXG4gICAgICA6IFRhc2sucmVqZWN0ZWQoaWQpXHJcblxyXG4gIGNvbnN0IHJlbW92ZVNsaWRlVGFzayA9IGlkID0+XHJcbiAgICBhdXRoRGVsZXRlVGFzayhpZClcclxuICAgICAgLmNoYWluKGRlbGV0ZVNsaWRlVGFzayhzdGF0ZS5wcmVzZW50YXRpb25JZCkpXHJcbiAgICAgIC5mb3JrKG9uRXJyb3IoJ2RlbGV0aW5nJyksIG9uU3VjY2VzcylcclxuXHJcbiAgY29uc3QgYWRkU2xpZGVUb1Nob3cgPSBzID0+IHtcclxuICAgIHVwZGF0ZVNsaWRlVGFzayhzdGF0ZS5wcmVzZW50YXRpb25JZCkoW3NdKS5mb3JrKG9uRXJyb3IoJ3VwZGF0aW5nJyksIF8gPT4ge1xyXG4gICAgICBzdGF0ZS5zbGlkZURyYWcgPSB7XHJcbiAgICAgICAgZHJhZ0lkOiAnJyxcclxuICAgICAgICBkcmFnZ2luZzogZmFsc2UsXHJcbiAgICAgICAgZHJvcHBhYmxlOiBmYWxzZSxcclxuICAgICAgfVxyXG4gICAgICBvblN1Y2Nlc3MoKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGNvbnN0IGhhbmRsZURyYWdTdGFydCA9IGV2ID0+IHtcclxuICAgIGV2LnRhcmdldC5zdHlsZS5vcGFjaXR5ID0gJzAuNCdcclxuICAgIGV2LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gJ21vdmUnXHJcbiAgICBldi5kYXRhVHJhbnNmZXIuc2V0RGF0YSgndGV4dC9wbGFpbicsICdzbGlkZScpXHJcbiAgICBzdGF0ZS5zbGlkZURyYWcgPSB1cGRhdGVTbGlkZURyYWdTdGFydChzKShzdGF0ZS5zbGlkZURyYWcpXHJcbiAgfVxyXG5cclxuICBjb25zdCBoYW5kbGVEcmFnRW5kID0gZXYgPT4ge1xyXG4gICAgZXYudGFyZ2V0LnN0eWxlLm9wYWNpdHkgPSAnMSdcclxuICAgIGlmIChzdGF0ZS5zbGlkZURyYWcuZHJvcHBhYmxlKSB7XHJcbiAgICAgIGxldCBfc2xpZGUgPSB1cGRhdGVTbGlkZURyYWdFbmQoc3RhdGUucmlnaHQoKS5sZW5ndGgpKHMpXHJcblxyXG4gICAgICB1cGRhdGVTdGF0ZURyYWdFbmQoc3RhdGUuc2xpZGVEcmFnKVxyXG4gICAgICByZXR1cm4gYWRkU2xpZGVUb1Nob3coX3NsaWRlKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHZpZXc6ICh7IGF0dHJzOiB7IHMsIHN0YXRlIH0gfSkgPT5cclxuICAgICAgbShcclxuICAgICAgICAnLmNhcmQnLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGlkOiBzLmlkLFxyXG4gICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgb25kcmFnc3RhcnQ6IGhhbmRsZURyYWdTdGFydCxcclxuICAgICAgICAgIG9uZHJhZ2VuZDogaGFuZGxlRHJhZ0VuZCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIFtcclxuICAgICAgICAgIG0oJ2Rpdi5jYXJkLWhlYWRlcicsIFtcclxuICAgICAgICAgICAgbSggJ2gxLnRpdGxlJywgbSgnc3BhbicsIHRha2UoMTUsIHMudGl0bGUpKSksXHJcbiAgICAgICAgICAgIG0oJ2J1dHRvbi5jYXJkLWRlbGV0ZScsIHtcclxuICAgICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiByZW1vdmVTbGlkZVRhc2socy5pZCksXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgXSksXHJcbiAgICAgICAgICBtKCcuY2FyZC1mb290ZXInLCBtKCdhLmNhcmQtYnRuJyx7XHJcbiAgICAgICAgICAgICAgb25jbGljazogKCkgPT5cclxuICAgICAgICAgICAgICAgIG0ucm91dGUuc2V0KGAvZWRpdC8ke3N0YXRlLnByZXNlbnRhdGlvbklkfS9zbGlkZS8ke3MuaWR9YCksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBtKCdpLmZhcyBmYS1lZGl0JyksXHJcbiAgICAgICAgICAgICAgKSlcclxuICAgICAgICBdXHJcbiAgICAgICksXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTbGlkZVxyXG4iLCJpbXBvcnQgbSBmcm9tIFwibWl0aHJpbFwiXHJcbmltcG9ydCBTdHJlYW0gZnJvbSBcIm1pdGhyaWwtc3RyZWFtXCJcclxuaW1wb3J0IHtcclxuICBjbG9uZSxcclxuICBmaWx0ZXIsXHJcbiAgcHJvcEVxLFxyXG4gIHByb3AsXHJcbiAgd2l0aG91dCxcclxuICBjb25jYXQsXHJcbiAgaGVhZCxcclxuICBzb3J0QnlcclxufSBmcm9tIFwicmFtZGFcIlxyXG5pbXBvcnQgU2xpZGVzTW9kYWwgZnJvbSBcIi4vc2xpZGVzTW9kYWwuanNcIlxyXG5pbXBvcnQgU2xpZGUgZnJvbSBcIi4vU2xpZGUvY29tcG9uZW50LmpzXCJcclxuaW1wb3J0IFByZXZpZXcgZnJvbSBcIi4vUHJldmlldy9jb21wb25lbnQuanNcIlxyXG5pbXBvcnQgeyBsb2FkU2xpZGVzIH0gZnJvbSBcIi4vbW9kZWwuanNcIlxyXG5pbXBvcnQgeyBsb2cgfSBmcm9tIFwiLi4vc2VydmljZXMvaW5kZXguanNcIlxyXG5cclxuY29uc3QgU2xpZGVzID0gKHsgYXR0cnM6IHsgTW9kZWxzIH0gfSkgPT4ge1xyXG4gIGNvbnN0IHN0YXRlID0ge1xyXG4gICAgbGVmdDogU3RyZWFtKFtdKSxcclxuICAgIHJpZ2h0OiBTdHJlYW0oW10pLFxyXG4gICAgc2xpZGVEcmFnOiB7XHJcbiAgICAgIGRyYWdJZDogXCJcIixcclxuICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxyXG4gICAgICBkcm9wcGFibGU6IGZhbHNlXHJcbiAgICB9LFxyXG4gICAgcHJldmlld0RyYWc6IHtcclxuICAgICAgZHJhZzogbnVsbCxcclxuICAgICAgZHJvcDogbnVsbFxyXG4gICAgfSxcclxuICAgIHByZXNlbnRhdGlvbklkOiBcIlwiXHJcbiAgfVxyXG5cclxuICBjb25zdCBvbkVycm9yID0gbG9nKFwiZXJyb3JcIilcclxuXHJcbiAgY29uc3Qgb25TdWNjZXNzID0gKHByZXNlbnRhdGlvbikgPT4ge1xyXG4gICAgbGV0IHNsaWRlcyA9IE1vZGVscy5DdXJyZW50UHJlc2VudGF0aW9uLlNsaWRlc1xyXG5cclxuICAgIHN0YXRlLmxlZnQoZmlsdGVyKHByb3BFcShcIm9yZGVyXCIsIDApLCBzbGlkZXMpKVxyXG5cclxuICAgIHN0YXRlLnJpZ2h0KHNvcnRCeShwcm9wKFwib3JkZXJcIiksIHdpdGhvdXQoc3RhdGUubGVmdCgpLCBzbGlkZXMpKSlcclxuXHJcbiAgICBNb2RlbHMuQ3VycmVudFByZXNlbnRhdGlvbi5zbGlkZVNob3cgPSBTdHJlYW0oc3RhdGUucmlnaHQoKSlcclxuICB9XHJcblxyXG4gIGNvbnN0IGdldFNsaWRlcyA9ICh7IGF0dHJzOiB7IE1vZGVscyB9IH0pID0+IHtcclxuICAgIHN0YXRlLnByZXNlbnRhdGlvbklkID0gbS5yb3V0ZS5wYXJhbShcImlkXCIpXHJcbiAgICByZXR1cm4gbG9hZFNsaWRlcyhzdGF0ZS5wcmVzZW50YXRpb25JZCkoTW9kZWxzKS5mb3JrKG9uRXJyb3IsIG9uU3VjY2VzcylcclxuICB9XHJcblxyXG4gIGNvbnN0IGhhbmRsZURyYWdFbnRlciA9IChldikgPT4ge1xyXG4gICAgZXYucHJldmVudERlZmF1bHQoKVxyXG4gICAgc3RhdGUuYkNvbG9yID0gdHJ1ZVxyXG4gIH1cclxuXHJcbiAgY29uc3QgaGFuZGxlRHJhZ0xlYXZlID0gKGV2KSA9PiB7XHJcbiAgICBldi5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICBzdGF0ZS5zbGlkZURyYWcuZHJhZ2dpbmcgPSBmYWxzZVxyXG4gICAgc3RhdGUuc2xpZGVEcmFnLmRyb3BwYWJsZSA9IGZhbHNlXHJcbiAgICBzdGF0ZS5iQ29sb3IgPSBmYWxzZVxyXG4gIH1cclxuXHJcbiAgY29uc3QgaGFuZGxlRHJvcCA9IChldikgPT4ge1xyXG4gICAgZXYucHJldmVudERlZmF1bHQoKVxyXG4gICAgbGV0IHR5cGUgPSBldi5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHQvcGxhaW5cIilcclxuICAgIGlmIChzdGF0ZS5zbGlkZURyYWcuZHJhZ2dpbmcpIHtcclxuICAgICAgaWYgKHR5cGUgPT0gXCJzbGlkZVwiKSB7XHJcbiAgICAgICAgbGV0IGl0ZW0gPSBoZWFkKFxyXG4gICAgICAgICAgZmlsdGVyKHByb3BFcShcImlkXCIsIHN0YXRlLnNsaWRlRHJhZy5kcmFnSWQpLCBzdGF0ZS5sZWZ0KCkpXHJcbiAgICAgICAgKVxyXG4gICAgICAgIHN0YXRlLnNsaWRlRHJhZy5kcm9wcGFibGUgPSB0cnVlXHJcbiAgICAgICAgaXRlbS5vcmRlciA9IHN0YXRlLnJpZ2h0KCkubGVuZ3RoICsgMVxyXG4gICAgICAgIHN0YXRlLmxlZnQod2l0aG91dChbaXRlbV0sIHN0YXRlLmxlZnQoKSkpXHJcbiAgICAgICAgc3RhdGUucmlnaHQoY29uY2F0KHN0YXRlLnJpZ2h0KCksIFtpdGVtXSkpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGl0ZW0gPSBoZWFkKFxyXG4gICAgICAgICAgZmlsdGVyKHByb3BFcShcImlkXCIsIHN0YXRlLnNsaWRlRHJhZy5kcmFnSWQpLCBzdGF0ZS5yaWdodCgpKVxyXG4gICAgICAgIClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgaGFuZGxlRHJhZ092ZXIgPSAoZXYpID0+IHtcclxuICAgIGV2LnByZXZlbnREZWZhdWx0KClcclxuICAgIGxldCB0eXBlID0gZXYuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpXHJcbiAgICBzdGF0ZS5zbGlkZURyYWcuZHJhZ2dpbmcgPSB0cnVlXHJcbiAgICBldi5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwibW92ZVwiXHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgb25pbml0OiBnZXRTbGlkZXMsXHJcbiAgICB2aWV3OiAoeyBhdHRyczogeyBNb2RlbHMgfSB9KSA9PiBbXHJcbiAgICAgIE1vZGVscy50b2dnbGVNb2RhbFxyXG4gICAgICAgID8gbShTbGlkZXNNb2RhbCwge1xyXG4gICAgICAgICAgICB0b2dnbGVNb2RhbDogKCkgPT4gKE1vZGVscy50b2dnbGVNb2RhbCA9ICFNb2RlbHMudG9nZ2xlTW9kYWwpLFxyXG4gICAgICAgICAgICBsZWZ0OiBzdGF0ZS5sZWZ0LFxyXG4gICAgICAgICAgICBzbGlkZTogY2xvbmUoTW9kZWxzLlNsaWRlTW9kZWwpLFxyXG4gICAgICAgICAgICBnZXRTbGlkZXMsXHJcbiAgICAgICAgICAgIE1vZGVscyxcclxuICAgICAgICAgICAgcElkOiBzdGF0ZS5wcmVzZW50YXRpb25JZFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICA6IFwiXCIsXHJcbiAgICAgIG0oXCIuY29udGFpbmVyLnNsaWRlc1wiLCBbXHJcbiAgICAgICAgbShcclxuICAgICAgICAgIGBhc2lkZS5sZWZ0LWRyYWcgJHtzdGF0ZS5sZWZ0KCkubGVuZ3RoID09IDAgPyBcIi5pc0RyYWdnaW5nXCIgOiBcIlwifWAsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG9uQmVmb3JlUmVtb3ZlOiAodm5vZGUsIGRvbmUpID0+IHtcclxuICAgICAgICAgICAgICB2bm9kZS5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBkb25lKVxyXG4gICAgICAgICAgICAgIHZub2RlLmRvbS5zdHlsZS5hbmltYXRpb24gPSBcImZhZGVPdXQgMXNcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgW1xyXG4gICAgICAgICAgICBzdGF0ZS5sZWZ0KCkubWFwKChzKSA9PlxyXG4gICAgICAgICAgICAgIG0oU2xpZGUsIHtcclxuICAgICAgICAgICAgICAgIGtleTogcy5pZCxcclxuICAgICAgICAgICAgICAgIE1vZGVscyxcclxuICAgICAgICAgICAgICAgIGdldFNsaWRlcyxcclxuICAgICAgICAgICAgICAgIHMsXHJcbiAgICAgICAgICAgICAgICBzdGF0ZVxyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgIF1cclxuICAgICAgICApLFxyXG5cclxuICAgICAgICBtKFxyXG4gICAgICAgICAgYHNlY3Rpb24ucmlnaHQtZHJhZyR7c3RhdGUuc2xpZGVEcmFnLmRyYWdnaW5nID8gXCIuaXNEcmFnZ2luZ1wiIDogXCJcIn1gLFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBvbkJlZm9yZVJlbW92ZTogKHZub2RlLCBkb25lKSA9PiB7XHJcbiAgICAgICAgICAgICAgdm5vZGUuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgZG9uZSlcclxuICAgICAgICAgICAgICB2bm9kZS5kb20uc3R5bGUuYW5pbWF0aW9uID0gXCJmYWRlT3V0IDFzXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25kcmFnbGVhdmU6IGhhbmRsZURyYWdMZWF2ZSxcclxuICAgICAgICAgICAgb25kcm9wOiBoYW5kbGVEcm9wLFxyXG4gICAgICAgICAgICBvbmRyYWdvdmVyOiBoYW5kbGVEcmFnT3ZlcixcclxuICAgICAgICAgICAgb25kcmFnZW50ZXI6IGhhbmRsZURyYWdFbnRlclxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHN0YXRlLnJpZ2h0KCkubWFwKChzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBtKFByZXZpZXcsIHtcclxuICAgICAgICAgICAgICBrZXk6IHMuaWQsXHJcbiAgICAgICAgICAgICAgTW9kZWxzLFxyXG4gICAgICAgICAgICAgIGdldFNsaWRlcyxcclxuICAgICAgICAgICAgICBzLFxyXG4gICAgICAgICAgICAgIHN0YXRlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIClcclxuICAgICAgXSlcclxuICAgIF1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNsaWRlc1xyXG4iLCJpbXBvcnQgeyBnZXRRbFRhc2sgfSBmcm9tICcuLi9zZXJ2aWNlcy9yZXF1ZXN0cy5qcydcclxuaW1wb3J0IHsgY29tcG9zZSwgbHQsIHByb3AsIGd0LCBzZXQsIGxlbnNQcm9wLCBzdWJ0cmFjdCwgcGF0aCB9IGZyb20gJ3JhbWRhJ1xyXG5cclxuY29uc3QgdG9WaWV3TW9kZWwgPSBtb2RlbCA9PiBwcmVzZW50YXRpb25zID0+XHJcbiAgKG1vZGVsLkN1cnJlbnRQcmVzZW50YXRpb24gPSBwcmVzZW50YXRpb25zKVxyXG5cclxuZXhwb3J0IGNvbnN0IHRvU3RydWN0ID0gKGFjYywgaXRlbSkgPT4ge1xyXG4gIGlmIChpdGVtLm9yZGVyID4gMCAmJiAhYWNjLmtleXMuaGFzKGl0ZW0uaWQpKSB7XHJcbiAgICBpdGVtLm9yZGVyID0gYWNjLmtleXMuc2l6ZSArIDFcclxuICAgIGFjYy5rZXlzLmFkZChpdGVtLmlkKVxyXG4gICAgYWNjLnZhbHVlc1tpdGVtLm9yZGVyXSA9IGl0ZW1cclxuICAgIGFjYy5pdGVtcyhPYmplY3Qua2V5cyhhY2MudmFsdWVzKSlcclxuICAgIHJldHVybiBhY2NcclxuICB9XHJcbiAgcmV0dXJuIGFjY1xyXG59XHJcblxyXG5jb25zdCBvcmRlck9mID0gc2xpZGUgPT4gcHJvcCgnb3JkZXInLCBzbGlkZSlcclxuXHJcbmV4cG9ydCBjb25zdCBmb3JHcmVhdGVyID0gcmVtb3ZlU2xpZGUgPT4gY2hlY2tTbGlkZSA9PlxyXG4gIGx0KG9yZGVyT2YocmVtb3ZlU2xpZGUpLCBvcmRlck9mKGNoZWNrU2xpZGUpKVxyXG5cclxuZXhwb3J0IGNvbnN0IGZvckxlc3MgPSByZW1vdmVTbGlkZSA9PiBjaGVja1NsaWRlID0+XHJcbiAgZ3Qob3JkZXJPZihyZW1vdmVTbGlkZSksIG9yZGVyT2YoY2hlY2tTbGlkZSkpXHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlT3JkZXIgPSBzbGlkZSA9PlxyXG4gIHNldChsZW5zUHJvcCgnb3JkZXInLCBzbGlkZSksIHN1YnRyYWN0KG9yZGVyT2Yoc2xpZGUpLCAxKSwgc2xpZGUpXHJcblxyXG5leHBvcnQgY29uc3QgZ2V0SWQgPSBpdGVtID0+IHByb3AoJ2lkJywgaXRlbSlcclxuXHJcbmNvbnN0IHJlc2V0T3JkZXIgPSBzbGlkZSA9PiBzZXQobGVuc1Byb3AoJ29yZGVyJywgc2xpZGUpLCAwLCBzbGlkZSlcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVSZW1vdmVTbGlkZSA9IGNvbXBvc2UoQXJyYXkub2YsIHJlc2V0T3JkZXIpXHJcblxyXG5jb25zdCB1cGRhdGVJZCA9IHNsaWRlID0+IHNsaWRlRHJhZyA9PlxyXG4gIHNldChsZW5zUHJvcCgnZHJhZ0lkJywgc2xpZGVEcmFnKSwgcHJvcCgnaWQnLCBzbGlkZSksIHNsaWRlRHJhZylcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVTbGlkZURyYWdTdGFydCA9IHNsaWRlID0+XHJcbiAgY29tcG9zZSh1cGRhdGVJZChzbGlkZSksIHVwZGF0ZURyYWcpXHJcblxyXG5jb25zdCB1cGRhdGVPcmRlciA9IGxlbmd0aCA9PiBzbGlkZSA9PiBzZXQobGVuc1Byb3AoJ29yZGVyJyksIGxlbmd0aCwgc2xpZGUpXHJcblxyXG5leHBvcnQgY29uc3QgdXBkYXRlU2xpZGVEcmFnRW5kID0gbGVuZ3RoID0+IGNvbXBvc2UodXBkYXRlT3JkZXIobGVuZ3RoKSlcclxuXHJcbmNvbnN0IHVwZGF0ZURyYWcgPSBzdGF0ZSA9PiBzZXQobGVuc1Byb3AoJ2RyYWdnaW5nJywgZmFsc2UsIHN0YXRlKSlcclxuXHJcbmNvbnN0IHVwZGF0ZURyb3AgPSBzdGF0ZSA9PiBzZXQobGVuc1Byb3AoJ2Ryb3BwYWJsZScsIGZhbHNlLCBzdGF0ZSkpXHJcblxyXG5leHBvcnQgY29uc3QgdXBkYXRlU3RhdGVEcmFnRW5kID0gY29tcG9zZSh1cGRhdGVEcm9wLCB1cGRhdGVEcmFnKVxyXG5cclxuZXhwb3J0IGNvbnN0IGxvYWRTbGlkZXMgPSBpZCA9PiBtb2RlbCA9PlxyXG4gIGdldFFsVGFzayhcclxuICAgIGB7IHByZXNlbnRhdGlvbih3aGVyZTp7aWQ6JHtKU09OLnN0cmluZ2lmeShpZCl9fSl7XHJcbiAgICAgIGlkLCB0aXRsZSwgU2xpZGVzIHsgaWQgdGl0bGUgY29udGVudCBvcmRlciB9XHJcbiAgICB9IH1gXHJcbiAgKVxyXG4gICAgLm1hcChwYXRoKFsnZGF0YScsICdwcmVzZW50YXRpb24nXSkpXHJcbiAgICAubWFwKHRvVmlld01vZGVsKG1vZGVsKSlcclxuXHJcbmV4cG9ydCBjb25zdCBzYXZlU2xpZGVUYXNrID0gKHsgdGl0bGUsIG9yZGVyLCBwcmVzZW50YXRpb25faWQgfSkgPT4ge1xyXG4gIGxldCBxID0gYG11dGF0aW9uIHtcclxuICAgICAgICAgICAgdXBkYXRlUHJlc2VudGF0aW9uKFxyXG4gICAgICAgICAgICAgIHdoZXJlOiB7XHJcbiAgICAgICAgICAgICAgICBpZDogJHtKU09OLnN0cmluZ2lmeShwcmVzZW50YXRpb25faWQpfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgIFNsaWRlczp7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICR7SlNPTi5zdHJpbmdpZnkodGl0bGUpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgb3JkZXI6ICR7SlNPTi5zdHJpbmdpZnkob3JkZXIpfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgIH0pe1xyXG4gICAgaWQgdGl0bGUgU2xpZGVzIHsgaWQgdGl0bGUgY29udGVudCBvcmRlciB9XHJcbiAgfSB9YFxyXG5cclxuICByZXR1cm4gZ2V0UWxUYXNrKHEpLm1hcChwYXRoKFsnZGF0YScsICd1cGRhdGVQcmVzZW50YXRpb24nLCAnU2xpZGVzJ10pKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZGVsZXRlU2xpZGVUYXNrID0gcHJlc2VudGF0aW9uX2lkID0+IGlkID0+IHtcclxuICBsZXQgcSA9IGBtdXRhdGlvbiB7XHJcbiAgICAgICAgICAgIHVwZGF0ZVByZXNlbnRhdGlvbihcclxuICAgICAgICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgICAgICAgaWQ6ICR7SlNPTi5zdHJpbmdpZnkocHJlc2VudGF0aW9uX2lkKX1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICBTbGlkZXM6e1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSA6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZDogJHtKU09OLnN0cmluZ2lmeShpZCl9XHJcbiAgICAgICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgIH0pe1xyXG4gICAgaWQgdGl0bGUgU2xpZGVzIHsgaWQgdGl0bGUgY29udGVudCBvcmRlcn1cclxuICB9IH1gXHJcblxyXG4gIHJldHVybiBnZXRRbFRhc2socSkubWFwKHBhdGgoWydkYXRhJywgJ3VwZGF0ZVByZXNlbnRhdGlvbicsICdTbGlkZXMnXSkpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVTbGlkZVRhc2sgPSBwcmVzZW50YXRpb25faWQgPT4gc2xpZGVzID0+IHtcclxuICBsZXQgcWxTbGlkZXMgPSBzbGlkZXMubWFwKFxyXG4gICAgc2xpZGUgPT5cclxuICAgICAgYHtcclxuICAgICAgd2hlcmU6IHtcclxuICAgICAgICBpZDogJHtKU09OLnN0cmluZ2lmeShzbGlkZS5pZCl9XHJcbiAgICAgIH1cclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIG9yZGVyOiAke0pTT04uc3RyaW5naWZ5KHNsaWRlLm9yZGVyKX1cclxuICAgICAgfVxyXG4gICAgfWBcclxuICApXHJcblxyXG4gIGxldCBxID0gYG11dGF0aW9uIHtcclxuICAgICAgICAgICAgdXBkYXRlUHJlc2VudGF0aW9uKFxyXG4gICAgICAgICAgICAgIHdoZXJlOiB7XHJcbiAgICAgICAgICAgICAgICBpZDogJHtKU09OLnN0cmluZ2lmeShwcmVzZW50YXRpb25faWQpfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBTbGlkZXM6e1xyXG4gICAgICAgICAgICAgICAgICB1cGRhdGUgOiBbJHtxbFNsaWRlc31dXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICB7IGlkIHRpdGxlIFNsaWRlcyB7IGlkIHRpdGxlIGNvbnRlbnQgb3JkZXIgfSB9IFxyXG4gICAgICAgIH1gXHJcblxyXG4gIHJldHVybiBnZXRRbFRhc2socSkubWFwKHBhdGgoWydkYXRhJywgJ3VwZGF0ZVByZXNlbnRhdGlvbicsICdTbGlkZXMnXSkpXHJcbn1cclxuIiwiaW1wb3J0IG0gZnJvbSBcIm1pdGhyaWxcIlxyXG5pbXBvcnQgeyBhc3NvYyB9IGZyb20gXCJyYW1kYVwiXHJcbmltcG9ydCB7IHNhdmVTbGlkZVRhc2sgfSBmcm9tIFwiLi9tb2RlbC5qc1wiXHJcblxyXG5jb25zdCBTbGlkZXNNb2RhbCA9ICh7XHJcbiAgYXR0cnM6IHsgbGVmdCwgcElkLCBzbGlkZSwgdG9nZ2xlTW9kYWwsIGdldFNsaWRlcywgTW9kZWxzIH0sXHJcbn0pID0+IHtcclxuICBjb25zdCBzdGF0ZSA9IHtcclxuICAgIGVycm9yczogXCJcIixcclxuICAgIHRpdGxlOiBcIlwiLFxyXG4gIH1cclxuXHJcbiAgY29uc3Qgb25FcnJvciA9IGVycm9ycyA9PiB7XHJcbiAgICBsb2coXCJlcnJvclwiKShlcnJvcnMpXHJcbiAgICBzdGF0ZS5lcnJvcnMgPSBlcnJvcnNcclxuICB9XHJcblxyXG4gIGNvbnN0IG9uU3VjY2VzcyA9IHNsaWRlcyA9PiB7XHJcbiAgICBnZXRTbGlkZXMoeyBhdHRyczogeyBNb2RlbHMgfSB9KVxyXG4gICAgcmV0dXJuIHRvZ2dsZU1vZGFsKClcclxuICB9XHJcblxyXG4gIGNvbnN0IHNhdmUgPSBlID0+IHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgbGV0IGR0byA9IGFzc29jKFwicHJlc2VudGF0aW9uX2lkXCIsIHBJZCwgYXNzb2MoXCJ0aXRsZVwiLCBzdGF0ZS50aXRsZSwgc2xpZGUpKVxyXG4gICAgc2F2ZVNsaWRlVGFzayhkdG8pLmZvcmsob25FcnJvciwgb25TdWNjZXNzKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHZpZXc6ICgpID0+XHJcbiAgICAgIG0oXCJhcnRpY2xlLm1vZGFsLWNvbnRhaW5lclwiLCBbXHJcbiAgICAgICAgbShcIi5jYXJkXCIsIFtcclxuICAgICAgICAgIG0oXHJcbiAgICAgICAgICAgIFwiLmNhcmQtaGVhZGVyXCIsXHJcbiAgICAgICAgICAgIG0oXCJidXR0b24uY2FyZC1kZWxldGVcIiwge1xyXG4gICAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b2dnbGVNb2RhbCgpXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogXCJjbG9zZVwiLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIG0oXCIuY2FyZC1ib2R5XCIsIFtcclxuICAgICAgICAgICAgbShcImZpZWxkc2V0XCIsIFtcclxuICAgICAgICAgICAgICBtKFwibGFiZWwubW9kYWwtbGFiZWxcIiwgXCJTbGlkZSBUaXRsZVwiKSxcclxuICAgICAgICAgICAgICBtKFwiaW5wdXQubW9kYWwtaW5wdXRcIiwge1xyXG4gICAgICAgICAgICAgICAgYXV0b2ZvY3VzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXHJcbiAgICAgICAgICAgICAgICBvbmNoYW5nZTogZSA9PiAoc3RhdGUudGl0bGUgPSBlLnRhcmdldC52YWx1ZSksXHJcbiAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIF0pLFxyXG4gICAgICAgICAgXSksXHJcbiAgICAgICAgICBtKFxyXG4gICAgICAgICAgICBcIi5jYXJkLWZvb3RlclwiLFxyXG4gICAgICAgICAgICBtKFwiYnV0dG9uLmNhcmQtYnRuXCIsIHsgb25jbGljazogc2F2ZSB9LCBcInNhdmUgc2xpZGVcIilcclxuICAgICAgICAgICksXHJcbiAgICAgICAgXSksXHJcbiAgICAgIF0pLFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2xpZGVzTW9kYWxcclxuIiwiaW1wb3J0IG0gZnJvbSBcIm1pdGhyaWxcIlxyXG5pbXBvcnQgeyBwbHVjayB9IGZyb20gXCJyYW1kYVwiXHJcbmltcG9ydCB7IGFuaW1hdGVFbnRyYW5jZVJpZ2h0IH0gZnJvbSBcIi4uL3NlcnZpY2VzL2FuaW1hdGlvbnMuanNcIlxyXG5pbXBvcnQgcmVtYXJrYWJsZSBmcm9tIFwicmVtYXJrYWJsZVwiXHJcblxyXG5jb25zdCBtZCA9IG5ldyByZW1hcmthYmxlKFwiZnVsbFwiLCB7XHJcbiAgYmFzZVVybDogbnVsbCxcclxuICBicmVha3M6IGZhbHNlLFxyXG4gIGdmbTogdHJ1ZSxcclxuICBoZWFkZXJJZHM6IHRydWUsXHJcbiAgaGVhZGVyUHJlZml4OiBcIlwiLFxyXG4gIGhpZ2hsaWdodDogbnVsbCxcclxuICBsYW5nUHJlZml4OiBcImxhbmctXCIsXHJcbiAgbWFuZ2xlOiB0cnVlLFxyXG4gIHBlZGFudGljOiBmYWxzZSxcclxuICBzYW5pdGl6ZTogZmFsc2UsXHJcbiAgc2FuaXRpemVyOiBudWxsLFxyXG4gIHNpbGVudDogdHJ1ZSxcclxuICBzbWFydExpc3RzOiB0cnVlLFxyXG4gIHNtYXJ0eXBhbnRzOiB0cnVlLFxyXG4gIHRhYmxlczogdHJ1ZSxcclxuICB4aHRtbDogdHJ1ZSxcclxuICBodG1sOiB0cnVlLFxyXG4gIGxpbmtpZnk6IHRydWUsXHJcbiAgbGlua1RhcmdldDogXCJcIixcclxuICB0eXBvZ3JhcGhlcjogdHJ1ZSxcclxuICBxdW90ZXM6IFwi4oCc4oCd4oCY4oCZXCIsXHJcbn0pXHJcblxyXG5jb25zdCBTbGlkZVNob3cgPSAoeyBhdHRyczogeyBNb2RlbHMgfSB9KSA9PiB7XHJcbiAgY29uc3Qgc3RhdGUgPSB7XHJcbiAgICBjdXJzb3I6IDAsXHJcbiAgICBzaXplOiBNb2RlbHMuQ3VycmVudFByZXNlbnRhdGlvbi5zbGlkZVNob3coKS5sZW5ndGgsXHJcbiAgICBjb250ZW50czogcGx1Y2soXCJjb250ZW50XCIsIE1vZGVscy5DdXJyZW50UHJlc2VudGF0aW9uLnNsaWRlU2hvdygpKSxcclxuICB9XHJcblxyXG4gIGNvbnN0IG5leHRTbGlkZSA9IGRvbSA9PiB7XHJcbiAgICBkb20uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uc2Nyb2xsSW50b1ZpZXcoeyBiZWhhdmlvdXI6IFwic21vb3RoXCIgfSlcclxuICAgIHN0YXRlLmN1cnNvciA9PSBzdGF0ZS5zaXplIC0gMSA/IHN0YXRlLmN1cnNvciA6IHN0YXRlLmN1cnNvcisrXHJcbiAgfVxyXG5cclxuICBjb25zdCBwcmV2U2xpZGUgPSBkb20gPT4ge1xyXG4gICAgZG9tLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLnNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3VyOiBcInNtb290aFwiIH0pXHJcbiAgICBzdGF0ZS5jdXJzb3IgPT0gMCA/IHN0YXRlLmN1cnNvciA6IHN0YXRlLmN1cnNvci0tXHJcbiAgfVxyXG5cclxuICBjb25zdCBjaGFuZ2VTbGlkZSA9IChrZXksIHRhcmdldCkgPT4ge1xyXG4gICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxyXG4gICAgICAgIHByZXZTbGlkZSh0YXJnZXQpXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcclxuICAgICAgICBuZXh0U2xpZGUodGFyZ2V0KVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgb25pbml0OiAoc3RhdGUuc2xpZGUgPSBzdGF0ZS5jb250ZW50c1tzdGF0ZS5jdXJzb3JdKSxcclxuICAgIHZpZXc6ICh7IGF0dHJzOiB7IE1vZGVscyB9IH0pID0+IHtcclxuICAgICAgcmV0dXJuIG0oXHJcbiAgICAgICAgXCIuc2xpZGVzaG93XCIsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdGFiaW5kZXg6IDAsXHJcbiAgICAgICAgICBvbmtleXVwOiAoeyBrZXksIHRhcmdldCB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNoYW5nZVNsaWRlKGtleSwgdGFyZ2V0KVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIG0oXHJcbiAgICAgICAgICBcIi5zbGlkZWNhcmRcIixcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgb251cGRhdGU6ICh7IGRvbSB9KSA9PiBhbmltYXRlRW50cmFuY2VSaWdodCh7IGRvbSB9KSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBtLnRydXN0KG1kLnJlbmRlcihzdGF0ZS5jb250ZW50c1tzdGF0ZS5jdXJzb3JdKSB8fCBcIn4gRklOIH5cIilcclxuICAgICAgICApXHJcbiAgICAgIClcclxuICAgIH0sXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTbGlkZVNob3dcclxuIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL2Nzcy1sb2FkZXIvMC4yOC4xMS9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2luZGV4LmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvc3R5bGUtbG9hZGVyLzAuMjAuMy9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9jc3MtbG9hZGVyLzAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRleC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9jc3MtbG9hZGVyLzAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRleC5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9