/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/.registry.npmjs.org/animejs/3.0.1/node_modules/animejs/lib/anime.es.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/animejs/3.0.1/node_modules/animejs/lib/anime.es.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*
 * anime.js v3.0.1
 * (c) 2019 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */

// Defaults

var defaultInstanceSettings = {
  update: null,
  begin: null,
  loopBegin: null,
  changeBegin: null,
  change: null,
  changeComplete: null,
  loopComplete: null,
  complete: null,
  loop: 1,
  direction: 'normal',
  autoplay: true,
  timelineOffset: 0
};

var defaultTweenSettings = {
  duration: 1000,
  delay: 0,
  endDelay: 0,
  easing: 'easeOutElastic(1, .5)',
  round: 0
};

var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective'];

// Caching

var cache = {
  CSS: {},
  springs: {}
};

// Utils

function minMax(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

function stringContains(str, text) {
  return str.indexOf(text) > -1;
}

function applyArguments(func, args) {
  return func.apply(null, args);
}

var is = {
  arr: function (a) { return Array.isArray(a); },
  obj: function (a) { return stringContains(Object.prototype.toString.call(a), 'Object'); },
  pth: function (a) { return is.obj(a) && a.hasOwnProperty('totalLength'); },
  svg: function (a) { return a instanceof SVGElement; },
  inp: function (a) { return a instanceof HTMLInputElement; },
  dom: function (a) { return a.nodeType || is.svg(a); },
  str: function (a) { return typeof a === 'string'; },
  fnc: function (a) { return typeof a === 'function'; },
  und: function (a) { return typeof a === 'undefined'; },
  hex: function (a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a); },
  rgb: function (a) { return /^rgb/.test(a); },
  hsl: function (a) { return /^hsl/.test(a); },
  col: function (a) { return (is.hex(a) || is.rgb(a) || is.hsl(a)); },
  key: function (a) { return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes'; }
};

// Easings

function parseEasingParameters(string) {
  var match = /\(([^)]+)\)/.exec(string);
  return match ? match[1].split(',').map(function (p) { return parseFloat(p); }) : [];
}

// Spring solver inspired by Webkit Copyright Â© 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js

function spring(string, duration) {

  var params = parseEasingParameters(string);
  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
  var velocity =  minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

  function solver(t) {
    var progress = duration ? (duration * t) / 1000 : t;
    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a + b * progress) * Math.exp(-progress * w0);
    }
    if (t === 0 || t === 1) { return t; }
    return 1 - progress;
  }

  function getDuration() {
    var cached = cache.springs[string];
    if (cached) { return cached; }
    var frame = 1/6;
    var elapsed = 0;
    var rest = 0;
    while(true) {
      elapsed += frame;
      if (solver(elapsed) === 1) {
        rest++;
        if (rest >= 16) { break; }
      } else {
        rest = 0;
      }
    }
    var duration = elapsed * frame * 1000;
    cache.springs[string] = duration;
    return duration;
  }

  return duration ? solver : getDuration;

}

// Elastic easing adapted from jQueryUI http://api.jqueryui.com/easings/

function elastic(amplitude, period) {
  if ( amplitude === void 0 ) amplitude = 1;
  if ( period === void 0 ) period = .5;

  var a = minMax(amplitude, 1, 10);
  var p = minMax(period, .1, 2);
  return function (t) {
    return (t === 0 || t === 1) ? t : 
      -a * Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2) * Math.asin(1 / a))) * (Math.PI * 2)) / p);
  }
}

// Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function

function steps(steps) {
  if ( steps === void 0 ) steps = 10;

  return function (t) { return Math.round(t * steps) * (1 / steps); };
}

// BezierEasing https://github.com/gre/bezier-easing

var bezier = (function () {

  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1 }
  function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1 }
  function C(aA1)      { return 3.0 * aA1 }

  function calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT }
  function getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1) }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX, currentT, i = 0;
    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) { aB = currentT; } else { aA = currentT; }
    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);
    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < 4; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0.0) { return aGuessT; }
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }

  function bezier(mX1, mY1, mX2, mY2) {

    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) { return; }
    var sampleValues = new Float32Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {

      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;

      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= 0.001) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }

    }

    return function (x) {
      if (mX1 === mY1 && mX2 === mY2) { return x; }
      if (x === 0 || x === 1) { return x; }
      return calcBezier(getTForX(x), mY1, mY2);
    }

  }

  return bezier;

})();

var penner = (function () {

  var names = ['Quad', 'Cubic', 'Quart', 'Quint', 'Sine', 'Expo', 'Circ', 'Back', 'Elastic'];

  // Approximated Penner equations http://matthewlein.com/ceaser/

  var curves = {
    In: [
      [0.550, 0.085, 0.680, 0.530], /* inQuad */
      [0.550, 0.055, 0.675, 0.190], /* inCubic */
      [0.895, 0.030, 0.685, 0.220], /* inQuart */
      [0.755, 0.050, 0.855, 0.060], /* inQuint */
      [0.470, 0.000, 0.745, 0.715], /* inSine */
      [0.950, 0.050, 0.795, 0.035], /* inExpo */
      [0.600, 0.040, 0.980, 0.335], /* inCirc */
      [0.600,-0.280, 0.735, 0.045], /* inBack */
      elastic /* inElastic */
    ],
    Out: [
      [0.250, 0.460, 0.450, 0.940], /* outQuad */
      [0.215, 0.610, 0.355, 1.000], /* outCubic */
      [0.165, 0.840, 0.440, 1.000], /* outQuart */
      [0.230, 1.000, 0.320, 1.000], /* outQuint */
      [0.390, 0.575, 0.565, 1.000], /* outSine */
      [0.190, 1.000, 0.220, 1.000], /* outExpo */
      [0.075, 0.820, 0.165, 1.000], /* outCirc */
      [0.175, 0.885, 0.320, 1.275], /* outBack */
      function (a, p) { return function (t) { return 1 - elastic(a, p)(1 - t); }; } /* outElastic */
    ],
    InOut: [
      [0.455, 0.030, 0.515, 0.955], /* inOutQuad */
      [0.645, 0.045, 0.355, 1.000], /* inOutCubic */
      [0.770, 0.000, 0.175, 1.000], /* inOutQuart */
      [0.860, 0.000, 0.070, 1.000], /* inOutQuint */
      [0.445, 0.050, 0.550, 0.950], /* inOutSine */
      [1.000, 0.000, 0.000, 1.000], /* inOutExpo */
      [0.785, 0.135, 0.150, 0.860], /* inOutCirc */
      [0.680,-0.550, 0.265, 1.550], /* inOutBack */
      function (a, p) { return function (t) { return t < .5 ? elastic(a, p)(t * 2) / 2 : 1 - elastic(a, p)(t * -2 + 2) / 2; }; } /* inOutElastic */
    ]
  };

  var eases = { 
    linear: [0.250, 0.250, 0.750, 0.750]
  };

  var loop = function ( coords ) {
    curves[coords].forEach(function (ease, i) {
      eases['ease'+coords+names[i]] = ease;
    });
  };

  for (var coords in curves) loop( coords );

  return eases;

})();

function parseEasings(easing, duration) {
  if (is.fnc(easing)) { return easing; }
  var name = easing.split('(')[0];
  var ease = penner[name];
  var args = parseEasingParameters(easing);
  switch (name) {
    case 'spring' : return spring(easing, duration);
    case 'cubicBezier' : return applyArguments(bezier, args);
    case 'steps' : return applyArguments(steps, args);
    default : return is.fnc(ease) ? applyArguments(ease, args) : applyArguments(bezier, ease);
  }
}

// Strings

function selectString(str) {
  try {
    var nodes = document.querySelectorAll(str);
    return nodes;
  } catch(e) {
    return;
  }
}

// Arrays

function filterArray(arr, callback) {
  var len = arr.length;
  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
  var result = [];
  for (var i = 0; i < len; i++) {
    if (i in arr) {
      var val = arr[i];
      if (callback.call(thisArg, val, i, arr)) {
        result.push(val);
      }
    }
  }
  return result;
}

function flattenArray(arr) {
  return arr.reduce(function (a, b) { return a.concat(is.arr(b) ? flattenArray(b) : b); }, []);
}

function toArray(o) {
  if (is.arr(o)) { return o; }
  if (is.str(o)) { o = selectString(o) || o; }
  if (o instanceof NodeList || o instanceof HTMLCollection) { return [].slice.call(o); }
  return [o];
}

function arrayContains(arr, val) {
  return arr.some(function (a) { return a === val; });
}

// Objects

function cloneObject(o) {
  var clone = {};
  for (var p in o) { clone[p] = o[p]; }
  return clone;
}

function replaceObjectProps(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o1) { o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p]; }
  return o;
}

function mergeObjects(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o2) { o[p] = is.und(o1[p]) ? o2[p] : o1[p]; }
  return o;
}

// Colors

function rgbToRgba(rgbValue) {
  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
  return rgb ? ("rgba(" + (rgb[1]) + ",1)") : rgbValue;
}

function hexToRgba(hexValue) {
  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var hex = hexValue.replace(rgx, function (m, r, g, b) { return r + r + g + g + b + b; } );
  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  var r = parseInt(rgb[1], 16);
  var g = parseInt(rgb[2], 16);
  var b = parseInt(rgb[3], 16);
  return ("rgba(" + r + "," + g + "," + b + ",1)");
}

function hslToRgba(hslValue) {
  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
  var h = parseInt(hsl[1], 10) / 360;
  var s = parseInt(hsl[2], 10) / 100;
  var l = parseInt(hsl[3], 10) / 100;
  var a = hsl[4] || 1;
  function hue2rgb(p, q, t) {
    if (t < 0) { t += 1; }
    if (t > 1) { t -= 1; }
    if (t < 1/6) { return p + (q - p) * 6 * t; }
    if (t < 1/2) { return q; }
    if (t < 2/3) { return p + (q - p) * (2/3 - t) * 6; }
    return p;
  }
  var r, g, b;
  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return ("rgba(" + (r * 255) + "," + (g * 255) + "," + (b * 255) + "," + a + ")");
}

function colorToRgb(val) {
  if (is.rgb(val)) { return rgbToRgba(val); }
  if (is.hex(val)) { return hexToRgba(val); }
  if (is.hsl(val)) { return hslToRgba(val); }
}

// Units

function getUnit(val) {
  var split = /([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
  if (split) { return split[2]; }
}

function getTransformUnit(propName) {
  if (stringContains(propName, 'translate') || propName === 'perspective') { return 'px'; }
  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) { return 'deg'; }
}

// Values

function getFunctionValue(val, animatable) {
  if (!is.fnc(val)) { return val; }
  return val(animatable.target, animatable.id, animatable.total);
}

function getAttribute(el, prop) {
  return el.getAttribute(prop);
}

function convertPxToUnit(el, value, unit) {
  var valueUnit = getUnit(value);
  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) { return value; }
  var cached = cache.CSS[value + unit];
  if (!is.und(cached)) { return cached; }
  var baseline = 100;
  var tempEl = document.createElement(el.tagName);
  var parentEl = (el.parentNode && (el.parentNode !== document)) ? el.parentNode : document.body;
  parentEl.appendChild(tempEl);
  tempEl.style.position = 'absolute';
  tempEl.style.width = baseline + unit;
  var factor = baseline / tempEl.offsetWidth;
  parentEl.removeChild(tempEl);
  var convertedUnit = factor * parseFloat(value);
  cache.CSS[value + unit] = convertedUnit;
  return convertedUnit;
}

function getCSSValue(el, prop, unit) {
  if (prop in el.style) {
    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
    return unit ? convertPxToUnit(el, value, unit) : value;
  }
}

function getAnimationType(el, prop) {
  if (is.dom(el) && !is.inp(el) && (getAttribute(el, prop) || (is.svg(el) && el[prop]))) { return 'attribute'; }
  if (is.dom(el) && arrayContains(validTransforms, prop)) { return 'transform'; }
  if (is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) { return 'css'; }
  if (el[prop] != null) { return 'object'; }
}

function getElementTransforms(el) {
  if (!is.dom(el)) { return; }
  var str = el.style.transform || '';
  var reg  = /(\w+)\(([^)]*)\)/g;
  var transforms = new Map();
  var m; while (m = reg.exec(str)) { transforms.set(m[1], m[2]); }
  return transforms;
}

function getTransformValue(el, propName, animatable, unit) {
  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
  var value = getElementTransforms(el).get(propName) || defaultVal;
  if (animatable) {
    animatable.transforms.list.set(propName, value);
    animatable.transforms['last'] = propName;
  }
  return unit ? convertPxToUnit(el, value, unit) : value;
}

function getOriginalTargetValue(target, propName, unit, animatable) {
  switch (getAnimationType(target, propName)) {
    case 'transform': return getTransformValue(target, propName, animatable, unit);
    case 'css': return getCSSValue(target, propName, unit);
    case 'attribute': return getAttribute(target, propName);
    default: return target[propName] || 0;
  }
}

function getRelativeValue(to, from) {
  var operator = /^(\*=|\+=|-=)/.exec(to);
  if (!operator) { return to; }
  var u = getUnit(to) || 0;
  var x = parseFloat(from);
  var y = parseFloat(to.replace(operator[0], ''));
  switch (operator[0][0]) {
    case '+': return x + y + u;
    case '-': return x - y + u;
    case '*': return x * y + u;
  }
}

function validateValue(val, unit) {
  if (is.col(val)) { return colorToRgb(val); }
  var originalUnit = getUnit(val);
  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
  return unit && !/\s/g.test(val) ? unitLess + unit : unitLess;
}

// getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getCircleLength(el) {
  return Math.PI * 2 * getAttribute(el, 'r');
}

function getRectLength(el) {
  return (getAttribute(el, 'width') * 2) + (getAttribute(el, 'height') * 2);
}

function getLineLength(el) {
  return getDistance(
    {x: getAttribute(el, 'x1'), y: getAttribute(el, 'y1')}, 
    {x: getAttribute(el, 'x2'), y: getAttribute(el, 'y2')}
  );
}

function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos;
  for (var i = 0 ; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);
    if (i > 0) { totalLength += getDistance(previousPos, currentPos); }
    previousPos = currentPos;
  }
  return totalLength;
}

function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
}

// Path animation

function getTotalLength(el) {
  if (el.getTotalLength) { return el.getTotalLength(); }
  switch(el.tagName.toLowerCase()) {
    case 'circle': return getCircleLength(el);
    case 'rect': return getRectLength(el);
    case 'line': return getLineLength(el);
    case 'polyline': return getPolylineLength(el);
    case 'polygon': return getPolygonLength(el);
  }
}

function setDashoffset(el) {
  var pathLength = getTotalLength(el);
  el.setAttribute('stroke-dasharray', pathLength);
  return pathLength;
}

// Motion path

function getParentSvgEl(el) {
  var parentEl = el.parentNode;
  while (is.svg(parentEl)) {
    parentEl = parentEl.parentNode;
    if (!is.svg(parentEl.parentNode)) { break; }
  }
  return parentEl;
}

function getParentSvg(pathEl, svgData) {
  var svg = svgData || {};
  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
  var rect = parentSvgEl.getBoundingClientRect();
  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
  var width = rect.width;
  var height = rect.height;
  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
  return {
    el: parentSvgEl,
    viewBox: viewBox,
    x: viewBox[0] / 1,
    y: viewBox[1] / 1,
    w: width / viewBox[2],
    h: height / viewBox[3]
  }
}

function getPath(path, percent) {
  var pathEl = is.str(path) ? selectString(path)[0] : path;
  var p = percent || 100;
  return function(property) {
    return {
      property: property,
      el: pathEl,
      svg: getParentSvg(pathEl),
      totalLength: getTotalLength(pathEl) * (p / 100)
    }
  }
}

function getPathProgress(path, progress) {
  function point(offset) {
    if ( offset === void 0 ) offset = 0;

    var l = progress + offset >= 1 ? progress + offset : 0;
    return path.el.getPointAtLength(l);
  }
  var svg = getParentSvg(path.el, path.svg);
  var p = point();
  var p0 = point(-1);
  var p1 = point(+1);
  switch (path.property) {
    case 'x': return (p.x - svg.x) * svg.w;
    case 'y': return (p.y - svg.y) * svg.h;
    case 'angle': return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
  }
}

// Decompose value

function decomposeValue(val, unit) {
  var rgx = /-?\d*\.?\d+/g;
  var value = validateValue((is.pth(val) ? val.totalLength : val), unit) + '';
  return {
    original: value,
    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
    strings: (is.str(val) || unit) ? value.split(rgx) : []
  }
}

// Animatables

function parseTargets(targets) {
  var targetsArray = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets))) : [];
  return filterArray(targetsArray, function (item, pos, self) { return self.indexOf(item) === pos; });
}

function getAnimatables(targets) {
  var parsed = parseTargets(targets);
  return parsed.map(function (t, i) {
    return {target: t, id: i, total: parsed.length, transforms: { list: getElementTransforms(t) } };
  });
}

// Properties

function normalizePropertyTweens(prop, tweenSettings) {
  var settings = cloneObject(tweenSettings);
  // Override duration if easing is a spring
  if (/^spring/.test(settings.easing)) { settings.duration = spring(settings.easing); }
  if (is.arr(prop)) {
    var l = prop.length;
    var isFromTo = (l === 2 && !is.obj(prop[0]));
    if (!isFromTo) {
      // Duration divided by the number of tweens
      if (!is.fnc(tweenSettings.duration)) { settings.duration = tweenSettings.duration / l; }
    } else {
      // Transform [from, to] values shorthand to a valid tween value
      prop = {value: prop};
    }
  }
  var propArray = is.arr(prop) ? prop : [prop];
  return propArray.map(function (v, i) {
    var obj = (is.obj(v) && !is.pth(v)) ? v : {value: v};
    // Default delay value should only be applied to the first tween
    if (is.und(obj.delay)) { obj.delay = !i ? tweenSettings.delay : 0; }
    // Default endDelay value should only be applied to the last tween
    if (is.und(obj.endDelay)) { obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0; }
    return obj;
  }).map(function (k) { return mergeObjects(k, settings); });
}


function flattenKeyframes(keyframes) {
  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) { return Object.keys(key); })), function (p) { return is.key(p); })
  .reduce(function (a,b) { if (a.indexOf(b) < 0) { a.push(b); } return a; }, []);
  var properties = {};
  var loop = function ( i ) {
    var propName = propertyNames[i];
    properties[propName] = keyframes.map(function (key) {
      var newKey = {};
      for (var p in key) {
        if (is.key(p)) {
          if (p == propName) { newKey.value = key[p]; }
        } else {
          newKey[p] = key[p];
        }
      }
      return newKey;
    });
  };

  for (var i = 0; i < propertyNames.length; i++) loop( i );
  return properties;
}

function getProperties(tweenSettings, params) {
  var properties = [];
  var keyframes = params.keyframes;
  if (keyframes) { params = mergeObjects(flattenKeyframes(keyframes), params); }
  for (var p in params) {
    if (is.key(p)) {
      properties.push({
        name: p,
        tweens: normalizePropertyTweens(params[p], tweenSettings)
      });
    }
  }
  return properties;
}

// Tweens

function normalizeTweenValues(tween, animatable) {
  var t = {};
  for (var p in tween) {
    var value = getFunctionValue(tween[p], animatable);
    if (is.arr(value)) {
      value = value.map(function (v) { return getFunctionValue(v, animatable); });
      if (value.length === 1) { value = value[0]; }
    }
    t[p] = value;
  }
  t.duration = parseFloat(t.duration);
  t.delay = parseFloat(t.delay);
  return t;
}

function normalizeTweens(prop, animatable) {
  var previousTween;
  return prop.tweens.map(function (t) {
    var tween = normalizeTweenValues(t, animatable);
    var tweenValue = tween.value;
    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
    var toUnit = getUnit(to);
    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
    var previousValue = previousTween ? previousTween.to.original : originalValue;
    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
    var fromUnit = getUnit(from) || getUnit(originalValue);
    var unit = toUnit || fromUnit;
    if (is.und(to)) { to = previousValue; }
    tween.from = decomposeValue(from, unit);
    tween.to = decomposeValue(getRelativeValue(to, from), unit);
    tween.start = previousTween ? previousTween.end : 0;
    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
    tween.easing = parseEasings(tween.easing, tween.duration);
    tween.isPath = is.pth(tweenValue);
    tween.isColor = is.col(tween.from.original);
    if (tween.isColor) { tween.round = 1; }
    previousTween = tween;
    return tween;
  });
}

// Tween progress

var setProgressValue = {
  css: function (t, p, v) { return t.style[p] = v; },
  attribute: function (t, p, v) { return t.setAttribute(p, v); },
  object: function (t, p, v) { return t[p] = v; },
  transform: function (t, p, v, transforms, manual) {
    transforms.list.set(p, v);
    if (p === transforms.last || manual) {
      var str = '';
      transforms.list.forEach(function (value, prop) { str += prop + "(" + value + ") "; });
      t.style.transform = str;
    }
  }
};

// Set Value helper

function setTargetsValue(targets, properties) {
  var animatables = getAnimatables(targets);
  animatables.forEach(function (animatable) {
    for (var property in properties) {
      var value = getFunctionValue(properties[property], animatable);
      var target = animatable.target;
      var valueUnit = getUnit(value);
      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
      var unit = valueUnit || getUnit(originalValue);
      var to = getRelativeValue(validateValue(value, unit), originalValue);
      var animType = getAnimationType(target, property);
      setProgressValue[animType](target, property, to, animatable.transforms, true);
    }
  });
}

// Animations

function createAnimation(animatable, prop) {
  var animType = getAnimationType(animatable.target, prop.name);
  if (animType) {
    var tweens = normalizeTweens(prop, animatable);
    var lastTween = tweens[tweens.length - 1];
    return {
      type: animType,
      property: prop.name,
      animatable: animatable,
      tweens: tweens,
      duration: lastTween.end,
      delay: tweens[0].delay,
      endDelay: lastTween.endDelay
    }
  }
}

function getAnimations(animatables, properties) {
  return filterArray(flattenArray(animatables.map(function (animatable) {
    return properties.map(function (prop) {
      return createAnimation(animatable, prop);
    });
  })), function (a) { return !is.und(a); });
}

// Create Instance

function getInstanceTimings(animations, tweenSettings) {
  var animLength = animations.length;
  var getTlOffset = function (anim) { return anim.timelineOffset ? anim.timelineOffset : 0; };
  var timings = {};
  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration; })) : tweenSettings.duration;
  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.delay; })) : tweenSettings.delay;
  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration - anim.endDelay; })) : tweenSettings.endDelay;
  return timings;
}

var instanceID = 0;

function createNewInstance(params) {
  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
  var properties = getProperties(tweenSettings, params);
  var animatables = getAnimatables(params.targets);
  var animations = getAnimations(animatables, properties);
  var timings = getInstanceTimings(animations, tweenSettings);
  var id = instanceID;
  instanceID++;
  return mergeObjects(instanceSettings, {
    id: id,
    children: [],
    animatables: animatables,
    animations: animations,
    duration: timings.duration,
    delay: timings.delay,
    endDelay: timings.endDelay
  });
}

// Core

var activeInstances = [];
var pausedInstances = [];
var raf;

var engine = (function () {
  function play() { 
    raf = requestAnimationFrame(step);
  }
  function step(t) {
    var activeInstancesLength = activeInstances.length;
    if (activeInstancesLength) {
      var i = 0;
      while (i < activeInstancesLength) {
        var activeInstance = activeInstances[i];
        if (!activeInstance.paused) {
          activeInstance.tick(t);
        } else {
          var instanceIndex = activeInstances.indexOf(activeInstance);
          if (instanceIndex > -1) {
            activeInstances.splice(instanceIndex, 1);
            activeInstancesLength = activeInstances.length;
          }
        }
        i++;
      }
      play();
    } else {
      raf = cancelAnimationFrame(raf);
    }
  }
  return play;
})();

function handleVisibilityChange() {
  if (document.hidden) {
    activeInstances.forEach(function (ins) { return ins.pause(); });
    pausedInstances = activeInstances.slice(0);
    activeInstances = [];
  } else {
    pausedInstances.forEach(function (ins) { return ins.play(); });
  }
}

if (typeof document !== 'undefined') {
  document.addEventListener('visibilitychange', handleVisibilityChange);
}

// Public Instance

function anime(params) {
  if ( params === void 0 ) params = {};


  var startTime = 0, lastTime = 0, now = 0;
  var children, childrenLength = 0;
  var resolve = null;

  function makePromise(instance) {
    var promise = window.Promise && new Promise(function (_resolve) { return resolve = _resolve; });
    instance.finished = promise;
    return promise;
  }

  var instance = createNewInstance(params);
  var promise = makePromise(instance);

  function toggleInstanceDirection() {
    var direction = instance.direction;
    if (direction !== 'alternate') {
      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
    }
    instance.reversed = !instance.reversed;
    children.forEach(function (child) { return child.reversed = instance.reversed; });
  }

  function adjustTime(time) {
    return instance.reversed ? instance.duration - time : time;
  }

  function resetTime() {
    startTime = 0;
    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
  }

  function seekCild(time, child) {
    if (child) { child.seek(time - child.timelineOffset); }
  }

  function syncInstanceChildren(time) {
    if (!instance.reversePlayback) {
      for (var i = 0; i < childrenLength; i++) { seekCild(time, children[i]); }
    } else {
      for (var i$1 = childrenLength; i$1--;) { seekCild(time, children[i$1]); }
    }
  }

  function setAnimationsProgress(insTime) {
    var i = 0;
    var animations = instance.animations;
    var animationsLength = animations.length;
    while (i < animationsLength) {
      var anim = animations[i];
      var animatable = anim.animatable;
      var tweens = anim.tweens;
      var tweenLength = tweens.length - 1;
      var tween = tweens[tweenLength];
      // Only check for keyframes if there is more than one tween
      if (tweenLength) { tween = filterArray(tweens, function (t) { return (insTime < t.end); })[0] || tween; }
      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
      var strings = tween.to.strings;
      var round = tween.round;
      var numbers = [];
      var toNumbersLength = tween.to.numbers.length;
      var progress = (void 0);
      for (var n = 0; n < toNumbersLength; n++) {
        var value = (void 0);
        var toNumber = tween.to.numbers[n];
        var fromNumber = tween.from.numbers[n] || 0;
        if (!tween.isPath) {
          value = fromNumber + (eased * (toNumber - fromNumber));
        } else {
          value = getPathProgress(tween.value, eased * toNumber);
        }
        if (round) {
          if (!(tween.isColor && n > 2)) {
            value = Math.round(value * round) / round;
          }
        }
        numbers.push(value);
      }
      // Manual Array.reduce for better performances
      var stringsLength = strings.length;
      if (!stringsLength) {
        progress = numbers[0];
      } else {
        progress = strings[0];
        for (var s = 0; s < stringsLength; s++) {
          var a = strings[s];
          var b = strings[s + 1];
          var n$1 = numbers[s];
          if (!isNaN(n$1)) {
            if (!b) {
              progress += n$1 + ' ';
            } else {
              progress += n$1 + b;
            }
          }
        }
      }
      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
      anim.currentValue = progress;
      i++;
    }
  }

  function setCallback(cb) {
    if (instance[cb] && !instance.passThrough) { instance[cb](instance); }
  }

  function countIteration() {
    if (instance.remaining && instance.remaining !== true) {
      instance.remaining--;
    }
  }

  function setInstanceProgress(engineTime) {
    var insDuration = instance.duration;
    var insDelay = instance.delay;
    var insEndDelay = insDuration - instance.endDelay;
    var insTime = adjustTime(engineTime);
    instance.progress = minMax((insTime / insDuration) * 100, 0, 100);
    instance.reversePlayback = insTime < instance.currentTime;
    if (children) { syncInstanceChildren(insTime); }
    if (!instance.began && instance.currentTime > 0) {
      instance.began = true;
      setCallback('begin');
      setCallback('loopBegin');
    }
    if (insTime <= insDelay && instance.currentTime !== 0) {
      setAnimationsProgress(0);
    }
    if ((insTime >= insEndDelay && instance.currentTime !== insDuration) || !insDuration) {
      setAnimationsProgress(insDuration);
    }
    if (insTime > insDelay && insTime < insEndDelay) {
      if (!instance.changeBegan) {
        instance.changeBegan = true;
        instance.changeCompleted = false;
        setCallback('changeBegin');
      }
      setCallback('change');
      setAnimationsProgress(insTime);
    } else {
      if (instance.changeBegan) {
        instance.changeCompleted = true;
        instance.changeBegan = false;
        setCallback('changeComplete');
      }
    }
    instance.currentTime = minMax(insTime, 0, insDuration);
    if (instance.began) { setCallback('update'); }
    if (engineTime >= insDuration) {
      lastTime = 0;
      countIteration();
      if (instance.remaining) {
        startTime = now;
        setCallback('loopComplete');
        setCallback('loopBegin');
        if (instance.direction === 'alternate') { toggleInstanceDirection(); }
      } else {
        instance.paused = true;
        if (!instance.completed) {
          instance.completed = true;
          setCallback('loopComplete');
          setCallback('complete');
          if (!instance.passThrough && 'Promise' in window) {
            resolve();
            promise = makePromise(instance);
          }
        }
      }
    }
  }

  instance.reset = function() {
    var direction = instance.direction;
    instance.passThrough = false;
    instance.currentTime = 0;
    instance.progress = 0;
    instance.paused = true;
    instance.began = false;
    instance.changeBegan = false;
    instance.completed = false;
    instance.changeCompleted = false;
    instance.reversePlayback = false;
    instance.reversed = direction === 'reverse';
    instance.remaining = instance.loop;
    children = instance.children;
    childrenLength = children.length;
    for (var i = childrenLength; i--;) { instance.children[i].reset(); }
    if (instance.reversed && instance.loop !== true || (direction === 'alternate' && instance.loop === 1)) { instance.remaining++; }
    setAnimationsProgress(0);
  };

  // Set Value helper

  instance.set = function(targets, properties) {
    setTargetsValue(targets, properties);
    return instance;
  };

  instance.tick = function(t) {
    now = t;
    if (!startTime) { startTime = now; }
    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
  };

  instance.seek = function(time) {
    setInstanceProgress(adjustTime(time));
  };

  instance.pause = function() {
    instance.paused = true;
    resetTime();
  };

  instance.play = function() {
    if (!instance.paused) { return; }
    if (instance.completed) { instance.reset(); }
    instance.paused = false;
    activeInstances.push(instance);
    resetTime();
    if (!raf) { engine(); }
  };

  instance.reverse = function() {
    toggleInstanceDirection();
    resetTime();
  };

  instance.restart = function() {
    instance.reset();
    instance.play();
  };

  instance.reset();

  if (instance.autoplay) { instance.play(); }

  return instance;

}

// Remove targets from animation

function removeTargetsFromAnimations(targetsArray, animations) {
  for (var a = animations.length; a--;) {
    if (arrayContains(targetsArray, animations[a].animatable.target)) {
      animations.splice(a, 1);
    }
  }
}

function removeTargets(targets) {
  var targetsArray = parseTargets(targets);
  for (var i = activeInstances.length; i--;) {
    var instance = activeInstances[i];
    var animations = instance.animations;
    var children = instance.children;
    removeTargetsFromAnimations(targetsArray, animations);
    for (var c = children.length; c--;) {
      var child = children[c];
      var childAnimations = child.animations;
      removeTargetsFromAnimations(targetsArray, childAnimations);
      if (!childAnimations.length && !child.children.length) { children.splice(c, 1); }
    }
    if (!animations.length && !children.length) { instance.pause(); }
  }
}

// Stagger helpers

function stagger(val, params) {
  if ( params === void 0 ) params = {};

  var direction = params.direction || 'normal';
  var easing = params.easing ? parseEasings(params.easing) : null;
  var grid = params.grid;
  var axis = params.axis;
  var fromIndex = params.from || 0;
  var fromFirst = fromIndex === 'first';
  var fromCenter = fromIndex === 'center';
  var fromLast = fromIndex === 'last';
  var isRange = is.arr(val);
  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
  var val2 = isRange ? parseFloat(val[1]) : 0;
  var unit = getUnit(isRange ? val[1] : val) || 0;
  var start = params.start || 0 + (isRange ? val1 : 0);
  var values = [];
  var maxValue = 0;
  return function (el, i, t) {
    if (fromFirst) { fromIndex = 0; }
    if (fromCenter) { fromIndex = (t - 1) / 2; }
    if (fromLast) { fromIndex = t - 1; }
    if (!values.length) {
      for (var index = 0; index < t; index++) {
        if (!grid) {
          values.push(Math.abs(fromIndex - index));
        } else {
          var fromX = !fromCenter ? fromIndex%grid[0] : (grid[0]-1)/2;
          var fromY = !fromCenter ? Math.floor(fromIndex/grid[0]) : (grid[1]-1)/2;
          var toX = index%grid[0];
          var toY = Math.floor(index/grid[0]);
          var distanceX = fromX - toX;
          var distanceY = fromY - toY;
          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
          if (axis === 'x') { value = -distanceX; }
          if (axis === 'y') { value = -distanceY; }
          values.push(value);
        }
        maxValue = Math.max.apply(Math, values);
      }
      if (easing) { values = values.map(function (val) { return easing(val / maxValue) * maxValue; }); }
      if (direction === 'reverse') { values = values.map(function (val) { return axis ? (val < 0) ? val * -1 : -val : Math.abs(maxValue - val); }); }
    }
    var spacing = isRange ? (val2 - val1) / maxValue : val1;
    return start + (spacing * (Math.round(values[i] * 100) / 100)) + unit;
  }
}

// Timeline

function timeline(params) {
  if ( params === void 0 ) params = {};

  var tl = anime(params);
  tl.duration = 0;
  tl.add = function(instanceParams, timelineOffset) {
    var tlIndex = activeInstances.indexOf(tl);
    var children = tl.children;
    if (tlIndex > -1) { activeInstances.splice(tlIndex, 1); }
    function passThrough(ins) { ins.passThrough = true; }
    for (var i = 0; i < children.length; i++) { passThrough(children[i]); }
    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
    insParams.targets = insParams.targets || params.targets;
    var tlDuration = tl.duration;
    insParams.autoplay = false;
    insParams.direction = tl.direction;
    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
    passThrough(tl);
    tl.seek(insParams.timelineOffset);
    var ins = anime(insParams);
    passThrough(ins);
    children.push(ins);
    var timings = getInstanceTimings(children, params);
    tl.delay = timings.delay;
    tl.endDelay = timings.endDelay;
    tl.duration = timings.duration;
    tl.seek(0);
    tl.reset();
    if (tl.autoplay) { tl.play(); }
    return tl;
  };
  return tl;
}

anime.version = '3.0.1';
anime.speed = 1;
anime.running = activeInstances;
anime.remove = removeTargets;
anime.get = getOriginalTargetValue;
anime.set = setTargetsValue;
anime.convertPx = convertPxToUnit;
anime.path = getPath;
anime.setDashoffset = setDashoffset;
anime.stagger = stagger;
anime.timeline = timeline;
anime.easing = parseEasings;
anime.penner = penner;
anime.random = function (min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; };

/* harmony default export */ __webpack_exports__["default"] = (anime);


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/autolinker/0.15.3/node_modules/autolinker/dist/Autolinker.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/autolinker/0.15.3/node_modules/autolinker/dist/Autolinker.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
  if (true) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return (root['Autolinker'] = factory());
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(this, function () {

/*!
 * Autolinker.js
 * 0.15.3
 *
 * Copyright(c) 2015 Gregory Jacobs <greg@greg-jacobs.com>
 * MIT Licensed. http://www.opensource.org/licenses/mit-license.php
 *
 * https://github.com/gregjacobs/Autolinker.js
 */
/**
 * @class Autolinker
 * @extends Object
 * 
 * Utility class used to process a given string of text, and wrap the URLs, email addresses, and Twitter handles in 
 * the appropriate anchor (&lt;a&gt;) tags to turn them into links.
 * 
 * Any of the configuration options may be provided in an Object (map) provided to the Autolinker constructor, which
 * will configure how the {@link #link link()} method will process the links.
 * 
 * For example:
 * 
 *     var autolinker = new Autolinker( {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *     
 *     var html = autolinker.link( "Joe went to www.yahoo.com" );
 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
 * 
 * 
 * The {@link #static-link static link()} method may also be used to inline options into a single call, which may
 * be more convenient for one-off uses. For example:
 * 
 *     var html = Autolinker.link( "Joe went to www.yahoo.com", {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
 * 
 * 
 * ## Custom Replacements of Links
 * 
 * If the configuration options do not provide enough flexibility, a {@link #replaceFn} may be provided to fully customize
 * the output of Autolinker. This function is called once for each URL/Email/Twitter handle match that is encountered.
 * 
 * For example:
 * 
 *     var input = "...";  // string with URLs, Email Addresses, and Twitter Handles
 *     
 *     var linkedText = Autolinker.link( input, {
 *         replaceFn : function( autolinker, match ) {
 *             console.log( "href = ", match.getAnchorHref() );
 *             console.log( "text = ", match.getAnchorText() );
 *         
 *             switch( match.getType() ) {
 *                 case 'url' : 
 *                     console.log( "url: ", match.getUrl() );
 *                     
 *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {
 *                         var tag = autolinker.getTagBuilder().build( match );  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes
 *                         tag.setAttr( 'rel', 'nofollow' );
 *                         tag.addClass( 'external-link' );
 *                         
 *                         return tag;
 *                         
 *                     } else {
 *                         return true;  // let Autolinker perform its normal anchor tag replacement
 *                     }
 *                     
 *                 case 'email' :
 *                     var email = match.getEmail();
 *                     console.log( "email: ", email );
 *                     
 *                     if( email === "my@own.address" ) {
 *                         return false;  // don't auto-link this particular email address; leave as-is
 *                     } else {
 *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)
 *                     }
 *                 
 *                 case 'twitter' :
 *                     var twitterHandle = match.getTwitterHandle();
 *                     console.log( twitterHandle );
 *                     
 *                     return '<a href="http://newplace.to.link.twitter.handles.to/">' + twitterHandle + '</a>';
 *             }
 *         }
 *     } );
 * 
 * 
 * The function may return the following values:
 * 
 * - `true` (Boolean): Allow Autolinker to replace the match as it normally would.
 * - `false` (Boolean): Do not replace the current match at all - leave as-is.
 * - Any String: If a string is returned from the function, the string will be used directly as the replacement HTML for
 *   the match.
 * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify an HTML tag before writing out its HTML text.
 * 
 * @constructor
 * @param {Object} [config] The configuration options for the Autolinker instance, specified in an Object (map).
 */
var Autolinker = function( cfg ) {
	Autolinker.Util.assign( this, cfg );  // assign the properties of `cfg` onto the Autolinker instance. Prototype properties will be used for missing configs.
};


Autolinker.prototype = {
	constructor : Autolinker,  // fix constructor property
	
	/**
	 * @cfg {Boolean} urls
	 * 
	 * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.
	 */
	urls : true,
	
	/**
	 * @cfg {Boolean} email
	 * 
	 * `true` if email addresses should be automatically linked, `false` if they should not be.
	 */
	email : true,
	
	/**
	 * @cfg {Boolean} twitter
	 * 
	 * `true` if Twitter handles ("@example") should be automatically linked, `false` if they should not be.
	 */
	twitter : true,
	
	/**
	 * @cfg {Boolean} newWindow
	 * 
	 * `true` if the links should open in a new window, `false` otherwise.
	 */
	newWindow : true,
	
	/**
	 * @cfg {Boolean} stripPrefix
	 * 
	 * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped from the beginning of URL links' text, 
	 * `false` otherwise.
	 */
	stripPrefix : true,
	
	/**
	 * @cfg {Number} truncate
	 * 
	 * A number for how many characters long URLs/emails/twitter handles should be truncated to inside the text of 
	 * a link. If the URL/email/twitter is over this number of characters, it will be truncated to this length by 
	 * adding a two period ellipsis ('..') to the end of the string.
	 * 
	 * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file' truncated to 25 characters might look
	 * something like this: 'yahoo.com/some/long/pat..'
	 */
	truncate : undefined,
	
	/**
	 * @cfg {String} className
	 * 
	 * A CSS class name to add to the generated links. This class will be added to all links, as well as this class
	 * plus url/email/twitter suffixes for styling url/email/twitter links differently.
	 * 
	 * For example, if this config is provided as "myLink", then:
	 * 
	 * - URL links will have the CSS classes: "myLink myLink-url"
	 * - Email links will have the CSS classes: "myLink myLink-email", and
	 * - Twitter links will have the CSS classes: "myLink myLink-twitter"
	 */
	className : "",
	
	/**
	 * @cfg {Function} replaceFn
	 * 
	 * A function to individually process each URL/Email/Twitter match found in the input string.
	 * 
	 * See the class's description for usage.
	 * 
	 * This function is called with the following parameters:
	 * 
	 * @cfg {Autolinker} replaceFn.autolinker The Autolinker instance, which may be used to retrieve child objects from (such
	 *   as the instance's {@link #getTagBuilder tag builder}).
	 * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which can be used to retrieve information about the
	 *   {@link Autolinker.match.Url URL}/{@link Autolinker.match.Email email}/{@link Autolinker.match.Twitter Twitter}
	 *   match that the `replaceFn` is currently processing.
	 */
	
	
	/**
	 * @private
	 * @property {Autolinker.htmlParser.HtmlParser} htmlParser
	 * 
	 * The HtmlParser instance used to skip over HTML tags, while finding text nodes to process. This is lazily instantiated
	 * in the {@link #getHtmlParser} method.
	 */
	htmlParser : undefined,
	
	/**
	 * @private
	 * @property {Autolinker.matchParser.MatchParser} matchParser
	 * 
	 * The MatchParser instance used to find URL/email/Twitter matches in the text nodes of an input string passed to
	 * {@link #link}. This is lazily instantiated in the {@link #getMatchParser} method.
	 */
	matchParser : undefined,
	
	/**
	 * @private
	 * @property {Autolinker.AnchorTagBuilder} tagBuilder
	 * 
	 * The AnchorTagBuilder instance used to build the URL/email/Twitter replacement anchor tags. This is lazily instantiated
	 * in the {@link #getTagBuilder} method.
	 */
	tagBuilder : undefined,
	
	
	/**
	 * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML. 
	 * Does not link URLs found within HTML tags.
	 * 
	 * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result
	 * will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
	 * 
	 * This method finds the text around any HTML elements in the input `textOrHtml`, which will be the text that is processed.
	 * Any original HTML elements will be left as-is, as well as the text that is already wrapped in anchor (&lt;a&gt;) tags.
	 * 
	 * @param {String} textOrHtml The HTML or text to link URLs, email addresses, and Twitter handles within (depending on if
	 *   the {@link #urls}, {@link #email}, and {@link #twitter} options are enabled).
	 * @return {String} The HTML, with URLs/emails/Twitter handles automatically linked.
	 */
	link : function( textOrHtml ) {
		var htmlParser = this.getHtmlParser(),
		    htmlNodes = htmlParser.parse( textOrHtml ),
		    anchorTagStackCount = 0,  // used to only process text around anchor tags, and any inner text/html they may have
		    resultHtml = [];
		
		for( var i = 0, len = htmlNodes.length; i < len; i++ ) {
			var node = htmlNodes[ i ],
			    nodeType = node.getType(),
			    nodeText = node.getText();
			
			if( nodeType === 'element' ) {
				// Process HTML nodes in the input `textOrHtml`
				if( node.getTagName() === 'a' ) {
					if( !node.isClosing() ) {  // it's the start <a> tag
						anchorTagStackCount++;
					} else {   // it's the end </a> tag
						anchorTagStackCount = Math.max( anchorTagStackCount - 1, 0 );  // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0
					}
				}
				resultHtml.push( nodeText );  // now add the text of the tag itself verbatim
				
			} else if( nodeType === 'entity' ) {
				resultHtml.push( nodeText );  // append HTML entity nodes (such as '&nbsp;') verbatim
				
			} else {
				// Process text nodes in the input `textOrHtml`
				if( anchorTagStackCount === 0 ) {
					// If we're not within an <a> tag, process the text node to linkify
					var linkifiedStr = this.linkifyStr( nodeText );
					resultHtml.push( linkifiedStr );
					
				} else {
					// `text` is within an <a> tag, simply append the text - we do not want to autolink anything 
					// already within an <a>...</a> tag
					resultHtml.push( nodeText );
				}
			}
		}
		
		return resultHtml.join( "" );
	},
	
	
	/**
	 * Process the text that lies in between HTML tags, performing the anchor tag replacements for matched 
	 * URLs/emails/Twitter handles, and returns the string with the replacements made. 
	 * 
	 * This method does the actual wrapping of URLs/emails/Twitter handles with anchor tags.
	 * 
	 * @private
	 * @param {String} str The string of text to auto-link.
	 * @return {String} The text with anchor tags auto-filled.
	 */
	linkifyStr : function( str ) {
		return this.getMatchParser().replace( str, this.createMatchReturnVal, this );
	},
	
	
	/**
	 * Creates the return string value for a given match in the input string, for the {@link #processTextNode} method.
	 * 
	 * This method handles the {@link #replaceFn}, if one was provided.
	 * 
	 * @private
	 * @param {Autolinker.match.Match} match The Match object that represents the match.
	 * @return {String} The string that the `match` should be replaced with. This is usually the anchor tag string, but
	 *   may be the `matchStr` itself if the match is not to be replaced.
	 */
	createMatchReturnVal : function( match ) {
		// Handle a custom `replaceFn` being provided
		var replaceFnResult;
		if( this.replaceFn ) {
			replaceFnResult = this.replaceFn.call( this, this, match );  // Autolinker instance is the context, and the first arg
		}
		
		if( typeof replaceFnResult === 'string' ) {
			return replaceFnResult;  // `replaceFn` returned a string, use that
			
		} else if( replaceFnResult === false ) {
			return match.getMatchedText();  // no replacement for the match
			
		} else if( replaceFnResult instanceof Autolinker.HtmlTag ) {
			return replaceFnResult.toString();
		
		} else {  // replaceFnResult === true, or no/unknown return value from function
			// Perform Autolinker's default anchor tag generation
			var tagBuilder = this.getTagBuilder(),
			    anchorTag = tagBuilder.build( match );  // returns an Autolinker.HtmlTag instance
			
			return anchorTag.toString();
		}
	},
	
	
	/**
	 * Lazily instantiates and returns the {@link #htmlParser} instance for this Autolinker instance.
	 * 
	 * @protected
	 * @return {Autolinker.htmlParser.HtmlParser}
	 */
	getHtmlParser : function() {
		var htmlParser = this.htmlParser;
		
		if( !htmlParser ) {
			htmlParser = this.htmlParser = new Autolinker.htmlParser.HtmlParser();
		}
		
		return htmlParser;
	},
	
	
	/**
	 * Lazily instantiates and returns the {@link #matchParser} instance for this Autolinker instance.
	 * 
	 * @protected
	 * @return {Autolinker.matchParser.MatchParser}
	 */
	getMatchParser : function() {
		var matchParser = this.matchParser;
		
		if( !matchParser ) {
			matchParser = this.matchParser = new Autolinker.matchParser.MatchParser( {
				urls : this.urls,
				email : this.email,
				twitter : this.twitter,
				stripPrefix : this.stripPrefix
			} );
		}
		
		return matchParser;
	},
	
	
	/**
	 * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it
	 * if it does not yet exist.
	 * 
	 * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that 
	 * Autolinker would normally generate, and then allow for modifications before returning it. For example:
	 * 
	 *     var html = Autolinker.link( "Test google.com", {
	 *         replaceFn : function( autolinker, match ) {
	 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance
	 *             tag.setAttr( 'rel', 'nofollow' );
	 *             
	 *             return tag;
	 *         }
	 *     } );
	 *     
	 *     // generated html:
	 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
	 * 
	 * @return {Autolinker.AnchorTagBuilder}
	 */
	getTagBuilder : function() {
		var tagBuilder = this.tagBuilder;
		
		if( !tagBuilder ) {
			tagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder( {
				newWindow   : this.newWindow,
				truncate    : this.truncate,
				className   : this.className
			} );
		}
		
		return tagBuilder;
	}

};


/**
 * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML. 
 * Does not link URLs found within HTML tags.
 * 
 * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result
 * will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
 * 
 * Example:
 * 
 *     var linkedText = Autolinker.link( "Go to google.com", { newWindow: false } );
 *     // Produces: "Go to <a href="http://google.com">google.com</a>"
 * 
 * @static
 * @param {String} textOrHtml The HTML or text to find URLs, email addresses, and Twitter handles within (depending on if
 *   the {@link #urls}, {@link #email}, and {@link #twitter} options are enabled).
 * @param {Object} [options] Any of the configuration options for the Autolinker class, specified in an Object (map).
 *   See the class description for an example call.
 * @return {String} The HTML text, with URLs automatically linked
 */
Autolinker.link = function( textOrHtml, options ) {
	var autolinker = new Autolinker( options );
	return autolinker.link( textOrHtml );
};


// Autolinker Namespaces
Autolinker.match = {};
Autolinker.htmlParser = {};
Autolinker.matchParser = {};
/*global Autolinker */
/*jshint eqnull:true, boss:true */
/**
 * @class Autolinker.Util
 * @singleton
 * 
 * A few utility methods for Autolinker.
 */
Autolinker.Util = {
	
	/**
	 * @property {Function} abstractMethod
	 * 
	 * A function object which represents an abstract method.
	 */
	abstractMethod : function() { throw "abstract"; },
	
	
	/**
	 * Assigns (shallow copies) the properties of `src` onto `dest`.
	 * 
	 * @param {Object} dest The destination object.
	 * @param {Object} src The source object.
	 * @return {Object} The destination object (`dest`)
	 */
	assign : function( dest, src ) {
		for( var prop in src ) {
			if( src.hasOwnProperty( prop ) ) {
				dest[ prop ] = src[ prop ];
			}
		}
		
		return dest;
	},
	
	
	/**
	 * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.
	 * 
	 * @param {Function} superclass The constructor function for the superclass.
	 * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the
	 *   special property `constructor`, which will be used as the new subclass's constructor function.
	 * @return {Function} The new subclass function.
	 */
	extend : function( superclass, protoProps ) {
		var superclassProto = superclass.prototype;
		
		var F = function() {};
		F.prototype = superclassProto;
		
		var subclass;
		if( protoProps.hasOwnProperty( 'constructor' ) ) {
			subclass = protoProps.constructor;
		} else {
			subclass = function() { superclassProto.constructor.apply( this, arguments ); };
		}
		
		var subclassProto = subclass.prototype = new F();  // set up prototype chain
		subclassProto.constructor = subclass;  // fix constructor property
		subclassProto.superclass = superclassProto;
		
		delete protoProps.constructor;  // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there
		Autolinker.Util.assign( subclassProto, protoProps );
		
		return subclass;
	},
	
	
	/**
	 * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the
	 * end of the string (by default, two periods: '..'). If the `str` length does not exceed 
	 * `len`, the string will be returned unchanged.
	 * 
	 * @param {String} str The string to truncate and add an ellipsis to.
	 * @param {Number} truncateLen The length to truncate the string at.
	 * @param {String} [ellipsisChars=..] The ellipsis character(s) to add to the end of `str`
	 *   when truncated. Defaults to '..'
	 */
	ellipsis : function( str, truncateLen, ellipsisChars ) {
		if( str.length > truncateLen ) {
			ellipsisChars = ( ellipsisChars == null ) ? '..' : ellipsisChars;
			str = str.substring( 0, truncateLen - ellipsisChars.length ) + ellipsisChars;
		}
		return str;
	},
	
	
	/**
	 * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).
	 * 
	 * @param {Array} arr The array to find an element of.
	 * @param {*} element The element to find in the array, and return the index of.
	 * @return {Number} The index of the `element`, or -1 if it was not found.
	 */
	indexOf : function( arr, element ) {
		if( Array.prototype.indexOf ) {
			return arr.indexOf( element );
			
		} else {
			for( var i = 0, len = arr.length; i < len; i++ ) {
				if( arr[ i ] === element ) return i;
			}
			return -1;
		}
	},
	
	
	
	/**
	 * Performs the functionality of what modern browsers do when `String.prototype.split()` is called
	 * with a regular expression that contains capturing parenthesis.
	 * 
	 * For example:
	 * 
	 *     // Modern browsers: 
	 *     "a,b,c".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]
	 *     
	 *     // Old IE (including IE8):
	 *     "a,b,c".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]
	 *     
	 * This method emulates the functionality of modern browsers for the old IE case.
	 * 
	 * @param {String} str The string to split.
	 * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting
	 *   character(s) will be spliced into the array, as in the "modern browsers" example in the 
	 *   description of this method. 
	 *   Note #1: the supplied regular expression **must** have the 'g' flag specified.
	 *   Note #2: for simplicity's sake, the regular expression does not need 
	 *   to contain capturing parenthesis - it will be assumed that any match has them.
	 * @return {String[]} The split array of strings, with the splitting character(s) included.
	 */
	splitAndCapture : function( str, splitRegex ) {
		if( !splitRegex.global ) throw new Error( "`splitRegex` must have the 'g' flag set" );
		
		var result = [],
		    lastIdx = 0,
		    match;
		
		while( match = splitRegex.exec( str ) ) {
			result.push( str.substring( lastIdx, match.index ) );
			result.push( match[ 0 ] );  // push the splitting char(s)
			
			lastIdx = match.index + match[ 0 ].length;
		}
		result.push( str.substring( lastIdx ) );
		
		return result;
	}
	
};
/*global Autolinker */
/*jshint boss:true */
/**
 * @class Autolinker.HtmlTag
 * @extends Object
 * 
 * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.
 * 
 * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use
 * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.
 * 
 * ## Examples
 * 
 * Example instantiation:
 * 
 *     var tag = new Autolinker.HtmlTag( {
 *         tagName : 'a',
 *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },
 *         innerHtml : 'Google'
 *     } );
 *     
 *     tag.toString();  // <a href="http://google.com" class="external-link">Google</a>
 *     
 *     // Individual accessor methods
 *     tag.getTagName();                 // 'a'
 *     tag.getAttr( 'href' );            // 'http://google.com'
 *     tag.hasClass( 'external-link' );  // true
 * 
 * 
 * Using mutator methods (which may be used in combination with instantiation config properties):
 * 
 *     var tag = new Autolinker.HtmlTag();
 *     tag.setTagName( 'a' );
 *     tag.setAttr( 'href', 'http://google.com' );
 *     tag.addClass( 'external-link' );
 *     tag.setInnerHtml( 'Google' );
 *     
 *     tag.getTagName();                 // 'a'
 *     tag.getAttr( 'href' );            // 'http://google.com'
 *     tag.hasClass( 'external-link' );  // true
 *     
 *     tag.toString();  // <a href="http://google.com" class="external-link">Google</a>
 *     
 * 
 * ## Example use within a {@link Autolinker#replaceFn replaceFn}
 * 
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( autolinker, match ) {
 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text
 *             tag.setAttr( 'rel', 'nofollow' );
 *             
 *             return tag;
 *         }
 *     } );
 *     
 *     // generated html:
 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
 *     
 *     
 * ## Example use with a new tag for the replacement
 * 
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( autolinker, match ) {
 *             var tag = new Autolinker.HtmlTag( {
 *                 tagName : 'button',
 *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },
 *                 innerHtml : 'Load URL: ' + match.getAnchorText()
 *             } );
 *             
 *             return tag;
 *         }
 *     } );
 *     
 *     // generated html:
 *     //   Test <button title="Load URL: http://google.com">Load URL: google.com</button>
 */
Autolinker.HtmlTag = Autolinker.Util.extend( Object, {
	
	/**
	 * @cfg {String} tagName
	 * 
	 * The tag name. Ex: 'a', 'button', etc.
	 * 
	 * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toString}
	 * is executed.
	 */
	
	/**
	 * @cfg {Object.<String, String>} attrs
	 * 
	 * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the
	 * values are the attribute values.
	 */
	
	/**
	 * @cfg {String} innerHtml
	 * 
	 * The inner HTML for the tag. 
	 * 
	 * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym 
	 * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}
	 * if you prefer, but this one is recommended.
	 */
	
	/**
	 * @cfg {String} innerHTML
	 * 
	 * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version
	 * for acronym names.
	 */
	
	
	/**
	 * @protected
	 * @property {RegExp} whitespaceRegex
	 * 
	 * Regular expression used to match whitespace in a string of CSS classes.
	 */
	whitespaceRegex : /\s+/,
	
	
	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration properties for this class, in an Object (map)
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
		
		this.innerHtml = this.innerHtml || this.innerHTML;  // accept either the camelCased form or the fully capitalized acronym
	},
	
	
	/**
	 * Sets the tag name that will be used to generate the tag with.
	 * 
	 * @param {String} tagName
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setTagName : function( tagName ) {
		this.tagName = tagName;
		return this;
	},
	
	
	/**
	 * Retrieves the tag name.
	 * 
	 * @return {String}
	 */
	getTagName : function() {
		return this.tagName || "";
	},
	
	
	/**
	 * Sets an attribute on the HtmlTag.
	 * 
	 * @param {String} attrName The attribute name to set.
	 * @param {String} attrValue The attribute value to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setAttr : function( attrName, attrValue ) {
		var tagAttrs = this.getAttrs();
		tagAttrs[ attrName ] = attrValue;
		
		return this;
	},
	
	
	/**
	 * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.
	 * 
	 * @param {String} name The attribute name to retrieve.
	 * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.
	 */
	getAttr : function( attrName ) {
		return this.getAttrs()[ attrName ];
	},
	
	
	/**
	 * Sets one or more attributes on the HtmlTag.
	 * 
	 * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setAttrs : function( attrs ) {
		var tagAttrs = this.getAttrs();
		Autolinker.Util.assign( tagAttrs, attrs );
		
		return this;
	},
	
	
	/**
	 * Retrieves the attributes Object (map) for the HtmlTag.
	 * 
	 * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.
	 */
	getAttrs : function() {
		return this.attrs || ( this.attrs = {} );
	},
	
	
	/**
	 * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.
	 * 
	 * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setClass : function( cssClass ) {
		return this.setAttr( 'class', cssClass );
	},
	
	
	/**
	 * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.
	 * 
	 * @param {String} cssClass One or more space-separated CSS classes to add.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	addClass : function( cssClass ) {
		var classAttr = this.getClass(),
		    whitespaceRegex = this.whitespaceRegex,
		    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
		    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
		    newClasses = cssClass.split( whitespaceRegex ),
		    newClass;
		
		while( newClass = newClasses.shift() ) {
			if( indexOf( classes, newClass ) === -1 ) {
				classes.push( newClass );
			}
		}
		
		this.getAttrs()[ 'class' ] = classes.join( " " );
		return this;
	},
	
	
	/**
	 * Convenience method to remove one or more CSS classes from the HtmlTag.
	 * 
	 * @param {String} cssClass One or more space-separated CSS classes to remove.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	removeClass : function( cssClass ) {
		var classAttr = this.getClass(),
		    whitespaceRegex = this.whitespaceRegex,
		    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
		    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
		    removeClasses = cssClass.split( whitespaceRegex ),
		    removeClass;
		
		while( classes.length && ( removeClass = removeClasses.shift() ) ) {
			var idx = indexOf( classes, removeClass );
			if( idx !== -1 ) {
				classes.splice( idx, 1 );
			}
		}
		
		this.getAttrs()[ 'class' ] = classes.join( " " );
		return this;
	},
	
	
	/**
	 * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when
	 * there are multiple.
	 * 
	 * @return {String}
	 */
	getClass : function() {
		return this.getAttrs()[ 'class' ] || "";
	},
	
	
	/**
	 * Convenience method to check if the tag has a CSS class or not.
	 * 
	 * @param {String} cssClass The CSS class to check for.
	 * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.
	 */
	hasClass : function( cssClass ) {
		return ( ' ' + this.getClass() + ' ' ).indexOf( ' ' + cssClass + ' ' ) !== -1;
	},
	
	
	/**
	 * Sets the inner HTML for the tag.
	 * 
	 * @param {String} html The inner HTML to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setInnerHtml : function( html ) {
		this.innerHtml = html;
		
		return this;
	},
	
	
	/**
	 * Retrieves the inner HTML for the tag.
	 * 
	 * @return {String}
	 */
	getInnerHtml : function() {
		return this.innerHtml || "";
	},
	
	
	/**
	 * Override of superclass method used to generate the HTML string for the tag.
	 * 
	 * @return {String}
	 */
	toString : function() {
		var tagName = this.getTagName(),
		    attrsStr = this.buildAttrsStr();
		
		attrsStr = ( attrsStr ) ? ' ' + attrsStr : '';  // prepend a space if there are actually attributes
		
		return [ '<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>' ].join( "" );
	},
	
	
	/**
	 * Support method for {@link #toString}, returns the string space-separated key="value" pairs, used to populate 
	 * the stringified HtmlTag.
	 * 
	 * @protected
	 * @return {String} Example return: `attr1="value1" attr2="value2"`
	 */
	buildAttrsStr : function() {
		if( !this.attrs ) return "";  // no `attrs` Object (map) has been set, return empty string
		
		var attrs = this.getAttrs(),
		    attrsArr = [];
		
		for( var prop in attrs ) {
			if( attrs.hasOwnProperty( prop ) ) {
				attrsArr.push( prop + '="' + attrs[ prop ] + '"' );
			}
		}
		return attrsArr.join( " " );
	}
	
} );
/*global Autolinker */
/*jshint sub:true */
/**
 * @protected
 * @class Autolinker.AnchorTagBuilder
 * @extends Object
 * 
 * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is found.
 * 
 * Normally this class is instantiated, configured, and used internally by an {@link Autolinker} instance, but may 
 * actually be retrieved in a {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag} instances
 * which may be modified before returning from the {@link Autolinker#replaceFn replaceFn}. For example:
 * 
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( autolinker, match ) {
 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance
 *             tag.setAttr( 'rel', 'nofollow' );
 *             
 *             return tag;
 *         }
 *     } );
 *     
 *     // generated html:
 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
 */
Autolinker.AnchorTagBuilder = Autolinker.Util.extend( Object, {
	
	/**
	 * @cfg {Boolean} newWindow
	 * @inheritdoc Autolinker#newWindow
	 */
	
	/**
	 * @cfg {Number} truncate
	 * @inheritdoc Autolinker#truncate
	 */
	
	/**
	 * @cfg {String} className
	 * @inheritdoc Autolinker#className
	 */
	
	
	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
	},
	
	
	/**
	 * Generates the actual anchor (&lt;a&gt;) tag to use in place of the matched URL/email/Twitter text,
	 * via its `match` object.
	 * 
	 * @param {Autolinker.match.Match} match The Match instance to generate an anchor tag from.
	 * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.
	 */
	build : function( match ) {
		var tag = new Autolinker.HtmlTag( {
			tagName   : 'a',
			attrs     : this.createAttrs( match.getType(), match.getAnchorHref() ),
			innerHtml : this.processAnchorText( match.getAnchorText() )
		} );
		
		return tag;
	},
	
	
	/**
	 * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;) tag being generated.
	 * 
	 * @protected
	 * @param {"url"/"email"/"twitter"} matchType The type of match that an anchor tag is being generated for.
	 * @param {String} href The href for the anchor tag.
	 * @return {Object} A key/value Object (map) of the anchor tag's attributes. 
	 */
	createAttrs : function( matchType, anchorHref ) {
		var attrs = {
			'href' : anchorHref  // we'll always have the `href` attribute
		};
		
		var cssClass = this.createCssClass( matchType );
		if( cssClass ) {
			attrs[ 'class' ] = cssClass;
		}
		if( this.newWindow ) {
			attrs[ 'target' ] = "_blank";
		}
		
		return attrs;
	},
	
	
	/**
	 * Creates the CSS class that will be used for a given anchor tag, based on the `matchType` and the {@link #className}
	 * config.
	 * 
	 * @private
	 * @param {"url"/"email"/"twitter"} matchType The type of match that an anchor tag is being generated for.
	 * @return {String} The CSS class string for the link. Example return: "myLink myLink-url". If no {@link #className}
	 *   was configured, returns an empty string.
	 */
	createCssClass : function( matchType ) {
		var className = this.className;
		
		if( !className ) 
			return "";
		else
			return className + " " + className + "-" + matchType;  // ex: "myLink myLink-url", "myLink myLink-email", or "myLink myLink-twitter"
	},
	
	
	/**
	 * Processes the `anchorText` by truncating the text according to the {@link #truncate} config.
	 * 
	 * @private
	 * @param {String} anchorText The anchor tag's text (i.e. what will be displayed).
	 * @return {String} The processed `anchorText`.
	 */
	processAnchorText : function( anchorText ) {
		anchorText = this.doTruncate( anchorText );
		
		return anchorText;
	},
	
	
	/**
	 * Performs the truncation of the `anchorText`, if the `anchorText` is longer than the {@link #truncate} option.
	 * Truncates the text to 2 characters fewer than the {@link #truncate} option, and adds ".." to the end.
	 * 
	 * @private
	 * @param {String} text The anchor tag's text (i.e. what will be displayed).
	 * @return {String} The truncated anchor text.
	 */
	doTruncate : function( anchorText ) {
		return Autolinker.Util.ellipsis( anchorText, this.truncate || Number.POSITIVE_INFINITY );
	}
	
} );
/*global Autolinker */
/**
 * @private
 * @class Autolinker.htmlParser.HtmlParser
 * @extends Object
 * 
 * An HTML parser implementation which simply walks an HTML string and returns an array of 
 * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.
 * 
 * Autolinker uses this to only link URLs/emails/Twitter handles within text nodes, effectively ignoring / "walking
 * around" HTML tags.
 */
Autolinker.htmlParser.HtmlParser = Autolinker.Util.extend( Object, {
	
	/**
	 * @private
	 * @property {RegExp} htmlRegex
	 * 
	 * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and
	 * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.
	 * 
	 * Capturing groups:
	 * 
	 * 1. The "!DOCTYPE" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.
	 * 2. If it is an end tag, this group will have the '/'.
	 * 3. The tag name for all tags (other than the &lt;!DOCTYPE&gt; tag)
	 */
	htmlRegex : (function() {
		var tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,
		    attrNameRegex = /[^\s\0"'>\/=\x01-\x1F\x7F]+/,   // the unicode range accounts for excluding control chars, and the delete char
		    attrValueRegex = /(?:"[^"]*?"|'[^']*?'|[^'"=<>`\s]+)/, // double quoted, single quoted, or unquoted attribute values
		    nameEqualsValueRegex = attrNameRegex.source + '(?:\\s*=\\s*' + attrValueRegex.source + ')?';  // optional '=[value]'
		
		return new RegExp( [
			// for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">) 
			'(?:',
				'<(!DOCTYPE)',  // *** Capturing Group 1 - If it's a doctype tag
					
					// Zero or more attributes following the tag name
					'(?:',
						'\\s+',  // one or more whitespace chars before an attribute
						
						// Either:
						// A. attr="value", or 
						// B. "value" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">) 
						'(?:', nameEqualsValueRegex, '|', attrValueRegex.source + ')',
					')*',
				'>',
			')',
			
			'|',
			
			// All other HTML tags (i.e. tags that are not <!DOCTYPE>)
			'(?:',
				'<(/)?',  // Beginning of a tag. Either '<' for a start tag, or '</' for an end tag. 
				          // *** Capturing Group 2: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.
			
					// *** Capturing Group 3 - The tag name
					'(' + tagNameRegex.source + ')',
					
					// Zero or more attributes following the tag name
					'(?:',
						'\\s+',                // one or more whitespace chars before an attribute
						nameEqualsValueRegex,  // attr="value" (with optional ="value" part)
					')*',
					
					'\\s*/?',  // any trailing spaces and optional '/' before the closing '>'
				'>',
			')'
		].join( "" ), 'gi' );
	} )(),
	
	/**
	 * @private
	 * @property {RegExp} htmlCharacterEntitiesRegex
	 *
	 * The regular expression that matches common HTML character entities.
	 * 
	 * Ignoring &amp; as it could be part of a query string -- handling it separately.
	 */
	htmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,
	
	
	/**
	 * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes} to represent
	 * the HTML structure of the input string. 
	 * 
	 * @param {String} html The HTML to parse.
	 * @return {Autolinker.htmlParser.HtmlNode[]}
	 */
	parse : function( html ) {
		var htmlRegex = this.htmlRegex,
		    currentResult,
		    lastIndex = 0,
		    textAndEntityNodes,
		    nodes = [];  // will be the result of the method
		
		while( ( currentResult = htmlRegex.exec( html ) ) !== null ) {
			var tagText = currentResult[ 0 ],
			    tagName = currentResult[ 1 ] || currentResult[ 3 ],  // The <!DOCTYPE> tag (ex: "!DOCTYPE"), or another tag (ex: "a" or "img") 
			    isClosingTag = !!currentResult[ 2 ],
			    inBetweenTagsText = html.substring( lastIndex, currentResult.index );
			
			// Push TextNodes and EntityNodes for any text found between tags
			if( inBetweenTagsText ) {
				textAndEntityNodes = this.parseTextAndEntityNodes( inBetweenTagsText );
				nodes.push.apply( nodes, textAndEntityNodes );
			}
			
			// Push the ElementNode
			nodes.push( this.createElementNode( tagText, tagName, isClosingTag ) );
			
			lastIndex = currentResult.index + tagText.length;
		}
		
		// Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.
		if( lastIndex < html.length ) {
			var text = html.substring( lastIndex );
			
			// Push TextNodes and EntityNodes for any text found between tags
			if( text ) {
				textAndEntityNodes = this.parseTextAndEntityNodes( text );
				nodes.push.apply( nodes, textAndEntityNodes );
			}
		}
		
		return nodes;
	},
	
	
	/**
	 * Parses text and HTML entity nodes from a given string. The input string should not have any HTML tags (elements)
	 * within it.
	 * 
	 * @private
	 * @param {String} text The text to parse.
	 * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to represent the 
	 *   {@link Autolinker.htmlParser.TextNode TextNodes} and {@link Autolinker.htmlParser.EntityNode EntityNodes} found.
	 */
	parseTextAndEntityNodes : function( text ) {
		var nodes = [],
		    textAndEntityTokens = Autolinker.Util.splitAndCapture( text, this.htmlCharacterEntitiesRegex );  // split at HTML entities, but include the HTML entities in the results array
		
		// Every even numbered token is a TextNode, and every odd numbered token is an EntityNode
		// For example: an input `text` of "Test &quot;this&quot; today" would turn into the 
		//   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]
		for( var i = 0, len = textAndEntityTokens.length; i < len; i += 2 ) {
			var textToken = textAndEntityTokens[ i ],
			    entityToken = textAndEntityTokens[ i + 1 ];
			
			if( textToken ) nodes.push( this.createTextNode( textToken ) );
			if( entityToken ) nodes.push( this.createEntityNode( entityToken ) );
		}
		return nodes;
	},
	
	
	/**
	 * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.
	 * 
	 * @private
	 * @param {String} tagText The full text of the tag (element) that was matched, including its attributes.
	 * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would be passed to this method as "img".
	 * @param {Boolean} isClosingTag `true` if it's a closing tag, false otherwise.
	 * @return {Autolinker.htmlParser.ElementNode}
	 */
	createElementNode : function( tagText, tagName, isClosingTag ) {
		return new Autolinker.htmlParser.ElementNode( {
			text    : tagText,
			tagName : tagName.toLowerCase(),
			closing : isClosingTag
		} );
	},
	
	
	/**
	 * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.
	 * 
	 * @private
	 * @param {String} text The text that was matched for the HTML entity (such as '&amp;nbsp;').
	 * @return {Autolinker.htmlParser.EntityNode}
	 */
	createEntityNode : function( text ) {
		return new Autolinker.htmlParser.EntityNode( { text: text } );
	},
	
	
	/**
	 * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.
	 * 
	 * @private
	 * @param {String} text The text that was matched.
	 * @return {Autolinker.htmlParser.TextNode}
	 */
	createTextNode : function( text ) {
		return new Autolinker.htmlParser.TextNode( { text: text } );
	}
	
} );
/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.htmlParser.HtmlNode
 * 
 * Represents an HTML node found in an input string. An HTML node is one of the following:
 * 
 * 1. An {@link Autolinker.htmlParser.ElementNode ElementNode}, which represents HTML tags.
 * 2. A {@link Autolinker.htmlParser.TextNode TextNode}, which represents text outside or within HTML tags.
 * 3. A {@link Autolinker.htmlParser.EntityNode EntityNode}, which represents one of the known HTML
 *    entities that Autolinker looks for. This includes common ones such as &amp;quot; and &amp;nbsp;
 */
Autolinker.htmlParser.HtmlNode = Autolinker.Util.extend( Object, {
	
	/**
	 * @cfg {String} text (required)
	 * 
	 * The original text that was matched for the HtmlNode. 
	 * 
	 * - In the case of an {@link Autolinker.htmlParser.ElementNode ElementNode}, this will be the tag's
	 *   text.
	 * - In the case of a {@link Autolinker.htmlParser.TextNode TextNode}, this will be the text itself.
	 * - In the case of a {@link Autolinker.htmlParser.EntityNode EntityNode}, this will be the text of
	 *   the HTML entity.
	 */
	text : "",
	
	
	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
	},

	
	/**
	 * Returns a string name for the type of node that this class represents.
	 * 
	 * @abstract
	 * @return {String}
	 */
	getType : Autolinker.Util.abstractMethod,
	
	
	/**
	 * Retrieves the {@link #text} for the HtmlNode.
	 * 
	 * @return {String}
	 */
	getText : function() {
		return this.text;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.ElementNode
 * @extends Autolinker.htmlParser.HtmlNode
 * 
 * Represents an HTML element node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 * 
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.
 */
Autolinker.htmlParser.ElementNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {
	
	/**
	 * @cfg {String} tagName (required)
	 * 
	 * The name of the tag that was matched.
	 */
	tagName : '',
	
	/**
	 * @cfg {Boolean} closing (required)
	 * 
	 * `true` if the element (tag) is a closing tag, `false` if its an opening tag.
	 */
	closing : false,

	
	/**
	 * Returns a string name for the type of node that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'element';
	},
	

	/**
	 * Returns the HTML element's (tag's) name. Ex: for an &lt;img&gt; tag, returns "img".
	 * 
	 * @return {String}
	 */
	getTagName : function() {
		return this.tagName;
	},
	
	
	/**
	 * Determines if the HTML element (tag) is a closing tag. Ex: &lt;div&gt; returns
	 * `false`, while &lt;/div&gt; returns `true`.
	 * 
	 * @return {Boolean}
	 */
	isClosing : function() {
		return this.closing;
	}
	
} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.EntityNode
 * @extends Autolinker.htmlParser.HtmlNode
 * 
 * Represents a known HTML entity node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 * Ex: '&amp;nbsp;', or '&amp#160;' (which will be retrievable from the {@link #getText} method.
 * 
 * Note that this class will only be returned from the HtmlParser for the set of checked HTML entity nodes 
 * defined by the {@link Autolinker.htmlParser.HtmlParser#htmlCharacterEntitiesRegex}.
 * 
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.
 */
Autolinker.htmlParser.EntityNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {
	
	/**
	 * Returns a string name for the type of node that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'entity';
	}
	
} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.TextNode
 * @extends Autolinker.htmlParser.HtmlNode
 * 
 * Represents a text node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 * 
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.
 */
Autolinker.htmlParser.TextNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {
	
	/**
	 * Returns a string name for the type of node that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'text';
	}
	
} );
/*global Autolinker */
/**
 * @private
 * @class Autolinker.matchParser.MatchParser
 * @extends Object
 * 
 * Used by Autolinker to parse {@link #urls URLs}, {@link #emails email addresses}, and {@link #twitter Twitter handles}, 
 * given an input string of text.
 * 
 * The MatchParser is fed a non-HTML string in order to search out URLs, email addresses and Twitter handles. Autolinker
 * first uses the {@link HtmlParser} to "walk around" HTML tags, and then the text around the HTML tags is passed into
 * the MatchParser in order to find the actual matches.
 */
Autolinker.matchParser.MatchParser = Autolinker.Util.extend( Object, {
	
	/**
	 * @cfg {Boolean} urls
	 * 
	 * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.
	 */
	urls : true,
	
	/**
	 * @cfg {Boolean} email
	 * 
	 * `true` if email addresses should be automatically linked, `false` if they should not be.
	 */
	email : true,
	
	/**
	 * @cfg {Boolean} twitter
	 * 
	 * `true` if Twitter handles ("@example") should be automatically linked, `false` if they should not be.
	 */
	twitter : true,
	
	/**
	 * @cfg {Boolean} stripPrefix
	 * 
	 * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped from the beginning of URL links' text
	 * in {@link Autolinker.match.Url URL matches}, `false` otherwise.
	 * 
	 * TODO: Handle this before a URL Match object is instantiated.
	 */
	stripPrefix : true,
	
	
	/**
	 * @private
	 * @property {RegExp} matcherRegex
	 * 
	 * The regular expression that matches URLs, email addresses, and Twitter handles.
	 * 
	 * This regular expression has the following capturing groups:
	 * 
	 * 1. Group that is used to determine if there is a Twitter handle match (i.e. \@someTwitterUser). Simply check for its 
	 *    existence to determine if there is a Twitter handle match. The next couple of capturing groups give information 
	 *    about the Twitter handle match.
	 * 2. The whitespace character before the \@sign in a Twitter handle. This is needed because there are no lookbehinds in
	 *    JS regular expressions, and can be used to reconstruct the original string in a replace().
	 * 3. The Twitter handle itself in a Twitter match. If the match is '@someTwitterUser', the handle is 'someTwitterUser'.
	 * 4. Group that matches an email address. Used to determine if the match is an email address, as well as holding the full 
	 *    address. Ex: 'me@my.com'
	 * 5. Group that matches a URL in the input text. Ex: 'http://google.com', 'www.google.com', or just 'google.com'.
	 *    This also includes a path, url parameters, or hash anchors. Ex: google.com/path/to/file?q1=1&q2=2#myAnchor
	 * 6. Group that matches a protocol URL (i.e. 'http://google.com'). This is used to match protocol URLs with just a single
	 *    word, like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
	 * 7. A protocol-relative ('//') match for the case of a 'www.' prefixed URL. Will be an empty string if it is not a 
	 *    protocol-relative match. We need to know the character before the '//' in order to determine if it is a valid match
	 *    or the // was in a string we don't want to auto-link.
	 * 8. A protocol-relative ('//') match for the case of a known TLD prefixed URL. Will be an empty string if it is not a 
	 *    protocol-relative match. See #6 for more info. 
	 */
	matcherRegex : (function() {
		var twitterRegex = /(^|[^\w])@(\w{1,15})/,              // For matching a twitter handle. Ex: @gregory_jacobs
		    
		    emailRegex = /(?:[\-;:&=\+\$,\w\.]+@)/,             // something@ for email addresses (a.k.a. local-part)
		    
		    protocolRegex = /(?:[A-Za-z][-.+A-Za-z0-9]+:(?![A-Za-z][-.+A-Za-z0-9]+:\/\/)(?!\d+\/?)(?:\/\/)?)/,  // match protocol, allow in format "http://" or "mailto:". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match "link:"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)
		    wwwRegex = /(?:www\.)/,                             // starting with 'www.'
		    domainNameRegex = /[A-Za-z0-9\.\-]*[A-Za-z0-9\-]/,  // anything looking at all like a domain, non-unicode domains, not ending in a period
		    tldRegex = /\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\b/,   // match our known top level domains (TLDs)
		    
		    // Allow optional path, query string, and hash anchor, not ending in the following characters: "?!:,.;"
		    // http://blog.codinghorror.com/the-problem-with-urls/
		    urlSuffixRegex = /[\-A-Za-z0-9+&@#\/%=~_()|'$*\[\]?!:,.;]*[\-A-Za-z0-9+&@#\/%=~_()|'$*\[\]]/;
		
		return new RegExp( [
			'(',  // *** Capturing group $1, which can be used to check for a twitter handle match. Use group $3 for the actual twitter handle though. $2 may be used to reconstruct the original string in a replace() 
				// *** Capturing group $2, which matches the whitespace character before the '@' sign (needed because of no lookbehinds), and 
				// *** Capturing group $3, which matches the actual twitter handle
				twitterRegex.source,
			')',
			
			'|',
			
			'(',  // *** Capturing group $4, which is used to determine an email match
				emailRegex.source,
				domainNameRegex.source,
				tldRegex.source,
			')',
			
			'|',
			
			'(',  // *** Capturing group $5, which is used to match a URL
				'(?:', // parens to cover match for protocol (optional), and domain
					'(',  // *** Capturing group $6, for a protocol-prefixed url (ex: http://google.com)
						protocolRegex.source,
						domainNameRegex.source,
					')',
					
					'|',
					
					'(?:',  // non-capturing paren for a 'www.' prefixed url (ex: www.google.com)
						'(.?//)?',  // *** Capturing group $7 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character
						wwwRegex.source,
						domainNameRegex.source,
					')',
					
					'|',
					
					'(?:',  // non-capturing paren for known a TLD url (ex: google.com)
						'(.?//)?',  // *** Capturing group $8 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character
						domainNameRegex.source,
						tldRegex.source,
					')',
				')',
				
				'(?:' + urlSuffixRegex.source + ')?',  // match for path, query string, and/or hash anchor - optional
			')'
		].join( "" ), 'gi' );
	} )(),
	
	/**
	 * @private
	 * @property {RegExp} charBeforeProtocolRelMatchRegex
	 * 
	 * The regular expression used to retrieve the character before a protocol-relative URL match.
	 * 
	 * This is used in conjunction with the {@link #matcherRegex}, which needs to grab the character before a protocol-relative
	 * '//' due to the lack of a negative look-behind in JavaScript regular expressions. The character before the match is stripped
	 * from the URL.
	 */
	charBeforeProtocolRelMatchRegex : /^(.)?\/\//,
	
	/**
	 * @private
	 * @property {Autolinker.MatchValidator} matchValidator
	 * 
	 * The MatchValidator object, used to filter out any false positives from the {@link #matcherRegex}. See
	 * {@link Autolinker.MatchValidator} for details.
	 */
	
	
	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
	
		this.matchValidator = new Autolinker.MatchValidator();
	},
	
	
	/**
	 * Parses the input `text` to search for URLs/emails/Twitter handles, and calls the `replaceFn`
	 * to allow replacements of the matches. Returns the `text` with matches replaced.
	 * 
	 * @param {String} text The text to search and repace matches in.
	 * @param {Function} replaceFn The iterator function to handle the replacements. The function takes a
	 *   single argument, a {@link Autolinker.match.Match} object, and should return the text that should
	 *   make the replacement.
	 * @param {Object} [contextObj=window] The context object ("scope") to run the `replaceFn` in.
	 * @return {String}
	 */
	replace : function( text, replaceFn, contextObj ) {
		var me = this;  // for closure
		
		return text.replace( this.matcherRegex, function( matchStr, $1, $2, $3, $4, $5, $6, $7, $8 ) {
			var matchDescObj = me.processCandidateMatch( matchStr, $1, $2, $3, $4, $5, $6, $7, $8 );  // "match description" object
			
			// Return out with no changes for match types that are disabled (url, email, twitter), or for matches that are 
			// invalid (false positives from the matcherRegex, which can't use look-behinds since they are unavailable in JS).
			if( !matchDescObj ) {
				return matchStr;
				
			} else {
				// Generate replacement text for the match from the `replaceFn`
				var replaceStr = replaceFn.call( contextObj, matchDescObj.match );
				return matchDescObj.prefixStr + replaceStr + matchDescObj.suffixStr;
			}
		} );
	},
	
	
	/**
	 * Processes a candidate match from the {@link #matcherRegex}. 
	 * 
	 * Not all matches found by the regex are actual URL/email/Twitter matches, as determined by the {@link #matchValidator}. In
	 * this case, the method returns `null`. Otherwise, a valid Object with `prefixStr`, `match`, and `suffixStr` is returned.
	 * 
	 * @private
	 * @param {String} matchStr The full match that was found by the {@link #matcherRegex}.
	 * @param {String} twitterMatch The matched text of a Twitter handle, if the match is a Twitter match.
	 * @param {String} twitterHandlePrefixWhitespaceChar The whitespace char before the @ sign in a Twitter handle match. This 
	 *   is needed because of no lookbehinds in JS regexes, and is need to re-include the character for the anchor tag replacement.
	 * @param {String} twitterHandle The actual Twitter user (i.e the word after the @ sign in a Twitter match).
	 * @param {String} emailAddressMatch The matched email address for an email address match.
	 * @param {String} urlMatch The matched URL string for a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match
	 *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
	 * @param {String} wwwProtocolRelativeMatch The '//' for a protocol-relative match from a 'www' url, with the character that 
	 *   comes before the '//'.
	 * @param {String} tldProtocolRelativeMatch The '//' for a protocol-relative match from a TLD (top level domain) match, with 
	 *   the character that comes before the '//'.
	 *   
	 * @return {Object} A "match description object". This will be `null` if the match was invalid, or if a match type is disabled.
	 *   Otherwise, this will be an Object (map) with the following properties:
	 * @return {String} return.prefixStr The char(s) that should be prepended to the replacement string. These are char(s) that
	 *   were needed to be included from the regex match that were ignored by processing code, and should be re-inserted into 
	 *   the replacement stream.
	 * @return {String} return.suffixStr The char(s) that should be appended to the replacement string. These are char(s) that
	 *   were needed to be included from the regex match that were ignored by processing code, and should be re-inserted into 
	 *   the replacement stream.
	 * @return {Autolinker.match.Match} return.match The Match object that represents the match that was found.
	 */
	processCandidateMatch : function( 
		matchStr, twitterMatch, twitterHandlePrefixWhitespaceChar, twitterHandle, 
		emailAddressMatch, urlMatch, protocolUrlMatch, wwwProtocolRelativeMatch, tldProtocolRelativeMatch
	) {
		// Note: The `matchStr` variable wil be fixed up to remove characters that are no longer needed (which will 
		// be added to `prefixStr` and `suffixStr`).
		
		var protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,
		    match,  // Will be an Autolinker.match.Match object
		    
		    prefixStr = "",       // A string to use to prefix the anchor tag that is created. This is needed for the Twitter handle match
		    suffixStr = "";       // A string to suffix the anchor tag that is created. This is used if there is a trailing parenthesis that should not be auto-linked.
		    
		
		// Return out with `null` for match types that are disabled (url, email, twitter), or for matches that are 
		// invalid (false positives from the matcherRegex, which can't use look-behinds since they are unavailable in JS).
		if(
			( twitterMatch && !this.twitter ) || ( emailAddressMatch && !this.email ) || ( urlMatch && !this.urls ) ||
			!this.matchValidator.isValidMatch( urlMatch, protocolUrlMatch, protocolRelativeMatch ) 
		) {
			return null;
		}
		
		// Handle a closing parenthesis at the end of the match, and exclude it if there is not a matching open parenthesis
		// in the match itself. 
		if( this.matchHasUnbalancedClosingParen( matchStr ) ) {
			matchStr = matchStr.substr( 0, matchStr.length - 1 );  // remove the trailing ")"
			suffixStr = ")";  // this will be added after the generated <a> tag
		}
		
		
		if( emailAddressMatch ) {
			match = new Autolinker.match.Email( { matchedText: matchStr, email: emailAddressMatch } );
			
		} else if( twitterMatch ) {
			// fix up the `matchStr` if there was a preceding whitespace char, which was needed to determine the match 
			// itself (since there are no look-behinds in JS regexes)
			if( twitterHandlePrefixWhitespaceChar ) {
				prefixStr = twitterHandlePrefixWhitespaceChar;
				matchStr = matchStr.slice( 1 );  // remove the prefixed whitespace char from the match
			}
			match = new Autolinker.match.Twitter( { matchedText: matchStr, twitterHandle: twitterHandle } );
			
		} else {  // url match
			// If it's a protocol-relative '//' match, remove the character before the '//' (which the matcherRegex needed
			// to match due to the lack of a negative look-behind in JavaScript regular expressions)
			if( protocolRelativeMatch ) {
				var charBeforeMatch = protocolRelativeMatch.match( this.charBeforeProtocolRelMatchRegex )[ 1 ] || "";
				
				if( charBeforeMatch ) {  // fix up the `matchStr` if there was a preceding char before a protocol-relative match, which was needed to determine the match itself (since there are no look-behinds in JS regexes)
					prefixStr = charBeforeMatch;
					matchStr = matchStr.slice( 1 );  // remove the prefixed char from the match
				}
			}
			
			match = new Autolinker.match.Url( {
				matchedText : matchStr,
				url : matchStr,
				protocolUrlMatch : !!protocolUrlMatch,
				protocolRelativeMatch : !!protocolRelativeMatch,
				stripPrefix : this.stripPrefix
			} );
		}
		
		return {
			prefixStr : prefixStr,
			suffixStr : suffixStr,
			match     : match
		};
	},
	
	
	/**
	 * Determines if a match found has an unmatched closing parenthesis. If so, this parenthesis will be removed
	 * from the match itself, and appended after the generated anchor tag in {@link #processTextNode}.
	 * 
	 * A match may have an extra closing parenthesis at the end of the match because the regular expression must include parenthesis
	 * for URLs such as "wikipedia.com/something_(disambiguation)", which should be auto-linked. 
	 * 
	 * However, an extra parenthesis *will* be included when the URL itself is wrapped in parenthesis, such as in the case of
	 * "(wikipedia.com/something_(disambiguation))". In this case, the last closing parenthesis should *not* be part of the URL 
	 * itself, and this method will return `true`.
	 * 
	 * @private
	 * @param {String} matchStr The full match string from the {@link #matcherRegex}.
	 * @return {Boolean} `true` if there is an unbalanced closing parenthesis at the end of the `matchStr`, `false` otherwise.
	 */
	matchHasUnbalancedClosingParen : function( matchStr ) {
		var lastChar = matchStr.charAt( matchStr.length - 1 );
		
		if( lastChar === ')' ) {
			var openParensMatch = matchStr.match( /\(/g ),
			    closeParensMatch = matchStr.match( /\)/g ),
			    numOpenParens = ( openParensMatch && openParensMatch.length ) || 0,
			    numCloseParens = ( closeParensMatch && closeParensMatch.length ) || 0;
			
			if( numOpenParens < numCloseParens ) {
				return true;
			}
		}
		
		return false;
	}
	
} );
/*global Autolinker */
/*jshint scripturl:true */
/**
 * @private
 * @class Autolinker.MatchValidator
 * @extends Object
 * 
 * Used by Autolinker to filter out false positives from the {@link Autolinker#matcherRegex}.
 * 
 * Due to the limitations of regular expressions (including the missing feature of look-behinds in JS regular expressions),
 * we cannot always determine the validity of a given match. This class applies a bit of additional logic to filter out any
 * false positives that have been matched by the {@link Autolinker#matcherRegex}.
 */
Autolinker.MatchValidator = Autolinker.Util.extend( Object, {
	
	/**
	 * @private
	 * @property {RegExp} invalidProtocolRelMatchRegex
	 * 
	 * The regular expression used to check a potential protocol-relative URL match, coming from the 
	 * {@link Autolinker#matcherRegex}. A protocol-relative URL is, for example, "//yahoo.com"
	 * 
	 * This regular expression checks to see if there is a word character before the '//' match in order to determine if 
	 * we should actually autolink a protocol-relative URL. This is needed because there is no negative look-behind in 
	 * JavaScript regular expressions. 
	 * 
	 * For instance, we want to autolink something like "Go to: //google.com", but we don't want to autolink something 
	 * like "abc//google.com"
	 */
	invalidProtocolRelMatchRegex : /^[\w]\/\//,
	
	/**
	 * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'
	 * 
	 * @private
	 * @property {RegExp} hasFullProtocolRegex
	 */
	hasFullProtocolRegex : /^[A-Za-z][-.+A-Za-z0-9]+:\/\//,
	
	/**
	 * Regex to find the URI scheme, such as 'mailto:'.
	 * 
	 * This is used to filter out 'javascript:' and 'vbscript:' schemes.
	 * 
	 * @private
	 * @property {RegExp} uriSchemeRegex
	 */
	uriSchemeRegex : /^[A-Za-z][-.+A-Za-z0-9]+:/,
	
	/**
	 * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')
	 * 
	 * @private
	 * @property {RegExp} hasWordCharAfterProtocolRegex
	 */
	hasWordCharAfterProtocolRegex : /:[^\s]*?[A-Za-z]/,
	
	
	/**
	 * Determines if a given match found by {@link Autolinker#processTextNode} is valid. Will return `false` for:
	 * 
	 * 1) URL matches which do not have at least have one period ('.') in the domain name (effectively skipping over 
	 *    matches like "abc:def"). However, URL matches with a protocol will be allowed (ex: 'http://localhost')
	 * 2) URL matches which do not have at least one word character in the domain name (effectively skipping over
	 *    matches like "git:1.0").
	 * 3) A protocol-relative url match (a URL beginning with '//') whose previous character is a word character 
	 *    (effectively skipping over strings like "abc//google.com")
	 * 
	 * Otherwise, returns `true`.
	 * 
	 * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match
	 *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
	 * @param {String} protocolRelativeMatch The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding
	 *   character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character
	 *   preceding the '//'.
	 * @return {Boolean} `true` if the match given is valid and should be processed, or `false` if the match is invalid and/or 
	 *   should just not be processed.
	 */
	isValidMatch : function( urlMatch, protocolUrlMatch, protocolRelativeMatch ) {
		if(
			( protocolUrlMatch && !this.isValidUriScheme( protocolUrlMatch ) ) ||
			this.urlMatchDoesNotHaveProtocolOrDot( urlMatch, protocolUrlMatch ) ||       // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')
			this.urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch, protocolUrlMatch ) ||  // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like "git:1.0"
			this.isInvalidProtocolRelativeMatch( protocolRelativeMatch )                 // A protocol-relative match which has a word character in front of it (so we can skip something like "abc//google.com")
		) {
			return false;
		}
		
		return true;
	},
	
	
	/**
	 * Determines if the URI scheme is a valid scheme to be autolinked. Returns `false` if the scheme is 
	 * 'javascript:' or 'vbscript:'
	 * 
	 * @private
	 * @param {String} uriSchemeMatch The match URL string for a full URI scheme match. Ex: 'http://yahoo.com' 
	 *   or 'mailto:a@a.com'.
	 * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.
	 */
	isValidUriScheme : function( uriSchemeMatch ) {
		var uriScheme = uriSchemeMatch.match( this.uriSchemeRegex )[ 0 ].toLowerCase();
		
		return ( uriScheme !== 'javascript:' && uriScheme !== 'vbscript:' );
	},
	
	
	/**
	 * Determines if a URL match does not have either:
	 * 
	 * a) a full protocol (i.e. 'http://'), or
	 * b) at least one dot ('.') in the domain name (for a non-full-protocol match).
	 * 
	 * Either situation is considered an invalid URL (ex: 'git:d' does not have either the '://' part, or at least one dot
	 * in the domain name. If the match was 'git:abc.com', we would consider this valid.)
	 * 
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match
	 *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.
	 * @return {Boolean} `true` if the URL match does not have a full protocol, or at least one dot ('.') in a non-full-protocol
	 *   match.
	 */
	urlMatchDoesNotHaveProtocolOrDot : function( urlMatch, protocolUrlMatch ) {
		return ( !!urlMatch && ( !protocolUrlMatch || !this.hasFullProtocolRegex.test( protocolUrlMatch ) ) && urlMatch.indexOf( '.' ) === -1 );
	},
	
	
	/**
	 * Determines if a URL match does not have at least one word character after the protocol (i.e. in the domain name).
	 * 
	 * At least one letter character must exist in the domain name after a protocol match. Ex: skip over something 
	 * like "git:1.0"
	 * 
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to
	 *   know whether or not we have a protocol in the URL string, in order to check for a word character after the protocol
	 *   separator (':').
	 * @return {Boolean} `true` if the URL match does not have at least one word character in it after the protocol, `false`
	 *   otherwise.
	 */
	urlMatchDoesNotHaveAtLeastOneWordChar : function( urlMatch, protocolUrlMatch ) {
		if( urlMatch && protocolUrlMatch ) {
			return !this.hasWordCharAfterProtocolRegex.test( urlMatch );
		} else {
			return false;
		}
	},
	
	
	/**
	 * Determines if a protocol-relative match is an invalid one. This method returns `true` if there is a `protocolRelativeMatch`,
	 * and that match contains a word character before the '//' (i.e. it must contain whitespace or nothing before the '//' in
	 * order to be considered valid).
	 * 
	 * @private
	 * @param {String} protocolRelativeMatch The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding
	 *   character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character
	 *   preceding the '//'.
	 * @return {Boolean} `true` if it is an invalid protocol-relative match, `false` otherwise.
	 */
	isInvalidProtocolRelativeMatch : function( protocolRelativeMatch ) {
		return ( !!protocolRelativeMatch && this.invalidProtocolRelMatchRegex.test( protocolRelativeMatch ) );
	}

} );
/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.match.Match
 * 
 * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a 
 * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.
 * 
 * For example:
 * 
 *     var input = "...";  // string with URLs, Email Addresses, and Twitter Handles
 *     
 *     var linkedText = Autolinker.link( input, {
 *         replaceFn : function( autolinker, match ) {
 *             console.log( "href = ", match.getAnchorHref() );
 *             console.log( "text = ", match.getAnchorText() );
 *         
 *             switch( match.getType() ) {
 *                 case 'url' : 
 *                     console.log( "url: ", match.getUrl() );
 *                     
 *                 case 'email' :
 *                     console.log( "email: ", match.getEmail() );
 *                     
 *                 case 'twitter' :
 *                     console.log( "twitter: ", match.getTwitterHandle() );
 *             }
 *         }
 *     } );
 *     
 * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.
 */
Autolinker.match.Match = Autolinker.Util.extend( Object, {
	
	/**
	 * @cfg {String} matchedText (required)
	 * 
	 * The original text that was matched.
	 */
	
	
	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
	},

	
	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @abstract
	 * @return {String}
	 */
	getType : Autolinker.Util.abstractMethod,
	
	
	/**
	 * Returns the original text that was matched.
	 * 
	 * @return {String}
	 */
	getMatchedText : function() {
		return this.matchedText;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @abstract
	 * @return {String}
	 */
	getAnchorHref : Autolinker.Util.abstractMethod,
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @abstract
	 * @return {String}
	 */
	getAnchorText : Autolinker.Util.abstractMethod

} );
/*global Autolinker */
/**
 * @class Autolinker.match.Email
 * @extends Autolinker.match.Match
 * 
 * Represents a Email match found in an input string which should be Autolinked.
 * 
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Email = Autolinker.Util.extend( Autolinker.match.Match, {
	
	/**
	 * @cfg {String} email (required)
	 * 
	 * The email address that was matched.
	 */
	

	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'email';
	},
	
	
	/**
	 * Returns the email address that was matched.
	 * 
	 * @return {String}
	 */
	getEmail : function() {
		return this.email;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'mailto:' + this.email;
	},
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorText : function() {
		return this.email;
	}
	
} );
/*global Autolinker */
/**
 * @class Autolinker.match.Twitter
 * @extends Autolinker.match.Match
 * 
 * Represents a Twitter match found in an input string which should be Autolinked.
 * 
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Twitter = Autolinker.Util.extend( Autolinker.match.Match, {
	
	/**
	 * @cfg {String} twitterHandle (required)
	 * 
	 * The Twitter handle that was matched.
	 */
	

	/**
	 * Returns the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'twitter';
	},
	
	
	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getTwitterHandle : function() {
		return this.twitterHandle;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'https://twitter.com/' + this.twitterHandle;
	},
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorText : function() {
		return '@' + this.twitterHandle;
	}
	
} );
/*global Autolinker */
/**
 * @class Autolinker.match.Url
 * @extends Autolinker.match.Match
 * 
 * Represents a Url match found in an input string which should be Autolinked.
 * 
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Url = Autolinker.Util.extend( Autolinker.match.Match, {
	
	/**
	 * @cfg {String} url (required)
	 * 
	 * The url that was matched.
	 */
	
	/**
	 * @cfg {Boolean} protocolUrlMatch (required)
	 * 
	 * `true` if the URL is a match which already has a protocol (i.e. 'http://'), `false` if the match was from a 'www' or
	 * known TLD match.
	 */
	
	/**
	 * @cfg {Boolean} protocolRelativeMatch (required)
	 * 
	 * `true` if the URL is a protocol-relative match. A protocol-relative match is a URL that starts with '//',
	 * and will be either http:// or https:// based on the protocol that the site is loaded under.
	 */
	
	/**
	 * @cfg {Boolean} stripPrefix (required)
	 * @inheritdoc Autolinker#stripPrefix
	 */
	

	/**
	 * @private
	 * @property {RegExp} urlPrefixRegex
	 * 
	 * A regular expression used to remove the 'http://' or 'https://' and/or the 'www.' from URLs.
	 */
	urlPrefixRegex: /^(https?:\/\/)?(www\.)?/i,
	
	/**
	 * @private
	 * @property {RegExp} protocolRelativeRegex
	 * 
	 * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes
	 * of {@link #getAnchorText}. A protocol-relative URL is, for example, "//yahoo.com"
	 */
	protocolRelativeRegex : /^\/\//,
	
	/**
	 * @private
	 * @property {Boolean} protocolPrepended
	 * 
	 * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the
	 * {@link #url} did not have a protocol)
	 */
	protocolPrepended : false,
	

	/**
	 * Returns a string name for the type of match that this class represents.
	 * 
	 * @return {String}
	 */
	getType : function() {
		return 'url';
	},
	
	
	/**
	 * Returns the url that was matched, assuming the protocol to be 'http://' if the original
	 * match was missing a protocol.
	 * 
	 * @return {String}
	 */
	getUrl : function() {
		var url = this.url;
		
		// if the url string doesn't begin with a protocol, assume 'http://'
		if( !this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended ) {
			url = this.url = 'http://' + url;
			
			this.protocolPrepended = true;
		}
		
		return url;
	},
	

	/**
	 * Returns the anchor href that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorHref : function() {
		var url = this.getUrl();
		
		return url.replace( /&amp;/g, '&' );  // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html 
	},
	
	
	/**
	 * Returns the anchor text that should be generated for the match.
	 * 
	 * @return {String}
	 */
	getAnchorText : function() {
		var anchorText = this.getUrl();
		
		if( this.protocolRelativeMatch ) {
			// Strip off any protocol-relative '//' from the anchor text
			anchorText = this.stripProtocolRelativePrefix( anchorText );
		}
		if( this.stripPrefix ) {
			anchorText = this.stripUrlPrefix( anchorText );
		}
		anchorText = this.removeTrailingSlash( anchorText );  // remove trailing slash, if there is one
		
		return anchorText;
	},
	
	
	// ---------------------------------------
	
	// Utility Functionality
	
	/**
	 * Strips the URL prefix (such as "http://" or "https://") from the given text.
	 * 
	 * @private
	 * @param {String} text The text of the anchor that is being generated, for which to strip off the
	 *   url prefix (such as stripping off "http://")
	 * @return {String} The `anchorText`, with the prefix stripped.
	 */
	stripUrlPrefix : function( text ) {
		return text.replace( this.urlPrefixRegex, '' );
	},
	
	
	/**
	 * Strips any protocol-relative '//' from the anchor text.
	 * 
	 * @private
	 * @param {String} text The text of the anchor that is being generated, for which to strip off the
	 *   protocol-relative prefix (such as stripping off "//")
	 * @return {String} The `anchorText`, with the protocol-relative prefix stripped.
	 */
	stripProtocolRelativePrefix : function( text ) {
		return text.replace( this.protocolRelativeRegex, '' );
	},
	
	
	/**
	 * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.
	 * 
	 * @private
	 * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing
	 *   slash ('/') that may exist.
	 * @return {String} The `anchorText`, with the trailing slash removed.
	 */
	removeTrailingSlash : function( anchorText ) {
		if( anchorText.charAt( anchorText.length - 1 ) === '/' ) {
			anchorText = anchorText.slice( 0, -1 );
		}
		return anchorText;
	}
	
} );
return Autolinker;

}));


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/animations.css":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/animations.css ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/*\r\n==============================================\r\nCSS3 ANIMATION CHEAT SHEET\r\n==============================================\r\n\r\nMade by Justin Aguilar\r\n\r\nwww.justinaguilar.com/animations/\r\n\r\nQuestions, comments, concerns, love letters:\r\njustin@justinaguilar.com\r\n==============================================\r\n*/\r\n\r\n/*\r\n==============================================\r\nslideDown\r\n==============================================\r\n*/\r\n\r\n\r\n.slideDown{\r\n\tanimation-name: slideDown;\r\n\t-webkit-animation-name: slideDown;\r\n\r\n\tanimation-duration: 1s;\r\n\t-webkit-animation-duration: 1s;\r\n\r\n\tanimation-timing-function: ease;\r\n\t-webkit-animation-timing-function: ease;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes slideDown {\r\n\t0% {\r\n\t\ttransform: translateY(-100%);\r\n\t}\r\n\t50%{\r\n\t\ttransform: translateY(8%);\r\n\t}\r\n\t65%{\r\n\t\ttransform: translateY(-4%);\r\n\t}\r\n\t80%{\r\n\t\ttransform: translateY(4%);\r\n\t}\r\n\t95%{\r\n\t\ttransform: translateY(-2%);\r\n\t}\r\n\t100% {\r\n\t\ttransform: translateY(0%);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes slideDown {\r\n\t0% {\r\n\t\t-webkit-transform: translateY(-100%);\r\n\t}\r\n\t50%{\r\n\t\t-webkit-transform: translateY(8%);\r\n\t}\r\n\t65%{\r\n\t\t-webkit-transform: translateY(-4%);\r\n\t}\r\n\t80%{\r\n\t\t-webkit-transform: translateY(4%);\r\n\t}\r\n\t95%{\r\n\t\t-webkit-transform: translateY(-2%);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: translateY(0%);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nslideUp\r\n==============================================\r\n*/\r\n\r\n\r\n.slideUp{\r\n\tanimation-name: slideUp;\r\n\t-webkit-animation-name: slideUp;\r\n\r\n\tanimation-duration: 1s;\r\n\t-webkit-animation-duration: 1s;\r\n\r\n\tanimation-timing-function: ease;\r\n\t-webkit-animation-timing-function: ease;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes slideUp {\r\n\t0% {\r\n\t\ttransform: translateY(100%);\r\n\t}\r\n\t50%{\r\n\t\ttransform: translateY(-8%);\r\n\t}\r\n\t65%{\r\n\t\ttransform: translateY(4%);\r\n\t}\r\n\t80%{\r\n\t\ttransform: translateY(-4%);\r\n\t}\r\n\t95%{\r\n\t\ttransform: translateY(2%);\r\n\t}\r\n\t100% {\r\n\t\ttransform: translateY(0%);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes slideUp {\r\n\t0% {\r\n\t\t-webkit-transform: translateY(100%);\r\n\t}\r\n\t50%{\r\n\t\t-webkit-transform: translateY(-8%);\r\n\t}\r\n\t65%{\r\n\t\t-webkit-transform: translateY(4%);\r\n\t}\r\n\t80%{\r\n\t\t-webkit-transform: translateY(-4%);\r\n\t}\r\n\t95%{\r\n\t\t-webkit-transform: translateY(2%);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: translateY(0%);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nslideLeft\r\n==============================================\r\n*/\r\n\r\n\r\n.slideLeft{\r\n\tanimation-name: slideLeft;\r\n\t-webkit-animation-name: slideLeft;\r\n\r\n\tanimation-duration: 1s;\r\n\t-webkit-animation-duration: 1s;\r\n\r\n\tanimation-timing-function: ease-in-out;\r\n\t-webkit-animation-timing-function: ease-in-out;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes slideLeft {\r\n\t0% {\r\n\t\ttransform: translateX(150%);\r\n\t}\r\n\t50%{\r\n\t\ttransform: translateX(-8%);\r\n\t}\r\n\t65%{\r\n\t\ttransform: translateX(4%);\r\n\t}\r\n\t80%{\r\n\t\ttransform: translateX(-4%);\r\n\t}\r\n\t95%{\r\n\t\ttransform: translateX(2%);\r\n\t}\r\n\t100% {\r\n\t\ttransform: translateX(0%);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes slideLeft {\r\n\t0% {\r\n\t\t-webkit-transform: translateX(150%);\r\n\t}\r\n\t50%{\r\n\t\t-webkit-transform: translateX(-8%);\r\n\t}\r\n\t65%{\r\n\t\t-webkit-transform: translateX(4%);\r\n\t}\r\n\t80%{\r\n\t\t-webkit-transform: translateX(-4%);\r\n\t}\r\n\t95%{\r\n\t\t-webkit-transform: translateX(2%);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: translateX(0%);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nslideRight\r\n==============================================\r\n*/\r\n\r\n\r\n.slideRight{\r\n\tanimation-name: slideRight;\r\n\t-webkit-animation-name: slideRight;\r\n\r\n\tanimation-duration: 1s;\r\n\t-webkit-animation-duration: 1s;\r\n\r\n\tanimation-timing-function: ease-in-out;\r\n\t-webkit-animation-timing-function: ease-in-out;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes slideRight {\r\n\t0% {\r\n\t\ttransform: translateX(-150%);\r\n\t}\r\n\t50%{\r\n\t\ttransform: translateX(8%);\r\n\t}\r\n\t65%{\r\n\t\ttransform: translateX(-4%);\r\n\t}\r\n\t80%{\r\n\t\ttransform: translateX(4%);\r\n\t}\r\n\t95%{\r\n\t\ttransform: translateX(-2%);\r\n\t}\r\n\t100% {\r\n\t\ttransform: translateX(0%);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes slideRight {\r\n\t0% {\r\n\t\t-webkit-transform: translateX(-150%);\r\n\t}\r\n\t50%{\r\n\t\t-webkit-transform: translateX(8%);\r\n\t}\r\n\t65%{\r\n\t\t-webkit-transform: translateX(-4%);\r\n\t}\r\n\t80%{\r\n\t\t-webkit-transform: translateX(4%);\r\n\t}\r\n\t95%{\r\n\t\t-webkit-transform: translateX(-2%);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: translateX(0%);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nslideExpandUp\r\n==============================================\r\n*/\r\n\r\n\r\n.slideExpandUp{\r\n\tanimation-name: slideExpandUp;\r\n\t-webkit-animation-name: slideExpandUp;\r\n\r\n\tanimation-duration: 1.6s;\r\n\t-webkit-animation-duration: 1.6s;\r\n\r\n\tanimation-timing-function: ease-out;\r\n\t-webkit-animation-timing-function: ease -out;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes slideExpandUp {\r\n\t0% {\r\n\t\ttransform: translateY(100%) scaleX(0.5);\r\n\t}\r\n\t30%{\r\n\t\ttransform: translateY(-8%) scaleX(0.5);\r\n\t}\r\n\t40%{\r\n\t\ttransform: translateY(2%) scaleX(0.5);\r\n\t}\r\n\t50%{\r\n\t\ttransform: translateY(0%) scaleX(1.1);\r\n\t}\r\n\t60%{\r\n\t\ttransform: translateY(0%) scaleX(0.9);\r\n\t}\r\n\t70% {\r\n\t\ttransform: translateY(0%) scaleX(1.05);\r\n\t}\r\n\t80%{\r\n\t\ttransform: translateY(0%) scaleX(0.95);\r\n\t}\r\n\t90% {\r\n\t\ttransform: translateY(0%) scaleX(1.02);\r\n\t}\r\n\t100%{\r\n\t\ttransform: translateY(0%) scaleX(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes slideExpandUp {\r\n\t0% {\r\n\t\t-webkit-transform: translateY(100%) scaleX(0.5);\r\n\t}\r\n\t30%{\r\n\t\t-webkit-transform: translateY(-8%) scaleX(0.5);\r\n\t}\r\n\t40%{\r\n\t\t-webkit-transform: translateY(2%) scaleX(0.5);\r\n\t}\r\n\t50%{\r\n\t\t-webkit-transform: translateY(0%) scaleX(1.1);\r\n\t}\r\n\t60%{\r\n\t\t-webkit-transform: translateY(0%) scaleX(0.9);\r\n\t}\r\n\t70% {\r\n\t\t-webkit-transform: translateY(0%) scaleX(1.05);\r\n\t}\r\n\t80%{\r\n\t\t-webkit-transform: translateY(0%) scaleX(0.95);\r\n\t}\r\n\t90% {\r\n\t\t-webkit-transform: translateY(0%) scaleX(1.02);\r\n\t}\r\n\t100%{\r\n\t\t-webkit-transform: translateY(0%) scaleX(1);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nexpandUp\r\n==============================================\r\n*/\r\n\r\n\r\n.expandUp{\r\n\tanimation-name: expandUp;\r\n\t-webkit-animation-name: expandUp;\r\n\r\n\tanimation-duration: 0.7s;\r\n\t-webkit-animation-duration: 0.7s;\r\n\r\n\tanimation-timing-function: ease;\r\n\t-webkit-animation-timing-function: ease;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes expandUp {\r\n\t0% {\r\n\t\ttransform: translateY(100%) scale(0.6) scaleY(0.5);\r\n\t}\r\n\t60%{\r\n\t\ttransform: translateY(-7%) scaleY(1.12);\r\n\t}\r\n\t75%{\r\n\t\ttransform: translateY(3%);\r\n\t}\r\n\t100% {\r\n\t\ttransform: translateY(0%) scale(1) scaleY(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes expandUp {\r\n\t0% {\r\n\t\t-webkit-transform: translateY(100%) scale(0.6) scaleY(0.5);\r\n\t}\r\n\t60%{\r\n\t\t-webkit-transform: translateY(-7%) scaleY(1.12);\r\n\t}\r\n\t75%{\r\n\t\t-webkit-transform: translateY(3%);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: translateY(0%) scale(1) scaleY(1);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nfadeIn\r\n==============================================\r\n*/\r\n\r\n.fadeIn{\r\n\tanimation-name: fadeIn;\r\n\t-webkit-animation-name: fadeIn;\r\n\r\n\tanimation-duration: 1.5s;\r\n\t-webkit-animation-duration: 1.5s;\r\n\r\n\tanimation-timing-function: ease-in-out;\r\n\t-webkit-animation-timing-function: ease-in-out;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes fadeIn {\r\n\t0% {\r\n\t\ttransform: scale(0);\r\n\t\topacity: 0.0;\r\n\t}\r\n\t60% {\r\n\t\ttransform: scale(1.1);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scale(0.9);\r\n\t\topacity: 1;\r\n\t}\r\n\t100% {\r\n\t\ttransform: scale(1);\r\n\t\topacity: 1;\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes fadeIn {\r\n\t0% {\r\n\t\t-webkit-transform: scale(0);\r\n\t\topacity: 0.0;\r\n\t}\r\n\t60% {\r\n\t\t-webkit-transform: scale(1.1);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scale(0.9);\r\n\t\topacity: 1;\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scale(1);\r\n\t\topacity: 1;\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nexpandOpen\r\n==============================================\r\n*/\r\n\r\n\r\n.expandOpen{\r\n\tanimation-name: expandOpen;\r\n\t-webkit-animation-name: expandOpen;\r\n\r\n\tanimation-duration: 1.2s;\r\n\t-webkit-animation-duration: 1.2s;\r\n\r\n\tanimation-timing-function: ease-out;\r\n\t-webkit-animation-timing-function: ease-out;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes expandOpen {\r\n\t0% {\r\n\t\ttransform: scale(1.8);\r\n\t}\r\n\t50% {\r\n\t\ttransform: scale(0.95);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scale(1.05);\r\n\t}\r\n\t90% {\r\n\t\ttransform: scale(0.98);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scale(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes expandOpen {\r\n\t0% {\r\n\t\t-webkit-transform: scale(1.8);\r\n\t}\r\n\t50% {\r\n\t\t-webkit-transform: scale(0.95);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scale(1.05);\r\n\t}\r\n\t90% {\r\n\t\t-webkit-transform: scale(0.98);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scale(1);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nbigEntrance\r\n==============================================\r\n*/\r\n\r\n\r\n.bigEntrance{\r\n\tanimation-name: bigEntrance;\r\n\t-webkit-animation-name: bigEntrance;\r\n\r\n\tanimation-duration: 1.6s;\r\n\t-webkit-animation-duration: 1.6s;\r\n\r\n\tanimation-timing-function: ease-out;\r\n\t-webkit-animation-timing-function: ease-out;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes bigEntrance {\r\n\t0% {\r\n\t\ttransform: scale(0.3) rotate(6deg) translateX(-30%) translateY(30%);\r\n\t\topacity: 0.2;\r\n\t}\r\n\t30% {\r\n\t\ttransform: scale(1.03) rotate(-2deg) translateX(2%) translateY(-2%);\r\n\t\topacity: 1;\r\n\t}\r\n\t45% {\r\n\t\ttransform: scale(0.98) rotate(1deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t60% {\r\n\t\ttransform: scale(1.01) rotate(-1deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t75% {\r\n\t\ttransform: scale(0.99) rotate(1deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t90% {\r\n\t\ttransform: scale(1.01) rotate(0deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t100% {\r\n\t\ttransform: scale(1) rotate(0deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes bigEntrance {\r\n\t0% {\r\n\t\t-webkit-transform: scale(0.3) rotate(6deg) translateX(-30%) translateY(30%);\r\n\t\topacity: 0.2;\r\n\t}\r\n\t30% {\r\n\t\t-webkit-transform: scale(1.03) rotate(-2deg) translateX(2%) translateY(-2%);\r\n\t\topacity: 1;\r\n\t}\r\n\t45% {\r\n\t\t-webkit-transform: scale(0.98) rotate(1deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t60% {\r\n\t\t-webkit-transform: scale(1.01) rotate(-1deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t75% {\r\n\t\t-webkit-transform: scale(0.99) rotate(1deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t90% {\r\n\t\t-webkit-transform: scale(1.01) rotate(0deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scale(1) rotate(0deg) translateX(0%) translateY(0%);\r\n\t\topacity: 1;\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nhatch\r\n==============================================\r\n*/\r\n\r\n.hatch{\r\n\tanimation-name: hatch;\r\n\t-webkit-animation-name: hatch;\r\n\r\n\tanimation-duration: 2s;\r\n\t-webkit-animation-duration: 2s;\r\n\r\n\tanimation-timing-function: ease-in-out;\r\n\t-webkit-animation-timing-function: ease-in-out;\r\n\r\n\ttransform-origin: 50% 100%;\r\n\t-ms-transform-origin: 50% 100%;\r\n\t-webkit-transform-origin: 50% 100%;\r\n\r\n\tvisibility: visible !important;\r\n}\r\n\r\n@keyframes hatch {\r\n\t0% {\r\n\t\ttransform: rotate(0deg) scaleY(0.6);\r\n\t}\r\n\t20% {\r\n\t\ttransform: rotate(-2deg) scaleY(1.05);\r\n\t}\r\n\t35% {\r\n\t\ttransform: rotate(2deg) scaleY(1);\r\n\t}\r\n\t50% {\r\n\t\ttransform: rotate(-2deg);\r\n\t}\r\n\t65% {\r\n\t\ttransform: rotate(1deg);\r\n\t}\r\n\t80% {\r\n\t\ttransform: rotate(-1deg);\r\n\t}\r\n\t100% {\r\n\t\ttransform: rotate(0deg);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes hatch {\r\n\t0% {\r\n\t\t-webkit-transform: rotate(0deg) scaleY(0.6);\r\n\t}\r\n\t20% {\r\n\t\t-webkit-transform: rotate(-2deg) scaleY(1.05);\r\n\t}\r\n\t35% {\r\n\t\t-webkit-transform: rotate(2deg) scaleY(1);\r\n\t}\r\n\t50% {\r\n\t\t-webkit-transform: rotate(-2deg);\r\n\t}\r\n\t65% {\r\n\t\t-webkit-transform: rotate(1deg);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: rotate(-1deg);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: rotate(0deg);\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n==============================================\r\nbounce\r\n==============================================\r\n*/\r\n\r\n\r\n.bounce{\r\n\tanimation-name: bounce;\r\n\t-webkit-animation-name: bounce;\r\n\r\n\tanimation-duration: 1.6s;\r\n\t-webkit-animation-duration: 1.6s;\r\n\r\n\tanimation-timing-function: ease;\r\n\t-webkit-animation-timing-function: ease;\r\n\r\n\ttransform-origin: 50% 100%;\r\n\t-ms-transform-origin: 50% 100%;\r\n\t-webkit-transform-origin: 50% 100%;\r\n}\r\n\r\n@keyframes bounce {\r\n\t0% {\r\n\t\ttransform: translateY(0%) scaleY(0.6);\r\n\t}\r\n\t60%{\r\n\t\ttransform: translateY(-100%) scaleY(1.1);\r\n\t}\r\n\t70%{\r\n\t\ttransform: translateY(0%) scaleY(0.95) scaleX(1.05);\r\n\t}\r\n\t80%{\r\n\t\ttransform: translateY(0%) scaleY(1.05) scaleX(1);\r\n\t}\r\n\t90%{\r\n\t\ttransform: translateY(0%) scaleY(0.95) scaleX(1);\r\n\t}\r\n\t100%{\r\n\t\ttransform: translateY(0%) scaleY(1) scaleX(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes bounce {\r\n\t0% {\r\n\t\t-webkit-transform: translateY(0%) scaleY(0.6);\r\n\t}\r\n\t60%{\r\n\t\t-webkit-transform: translateY(-100%) scaleY(1.1);\r\n\t}\r\n\t70%{\r\n\t\t-webkit-transform: translateY(0%) scaleY(0.95) scaleX(1.05);\r\n\t}\r\n\t80%{\r\n\t\t-webkit-transform: translateY(0%) scaleY(1.05) scaleX(1);\r\n\t}\r\n\t90%{\r\n\t\t-webkit-transform: translateY(0%) scaleY(0.95) scaleX(1);\r\n\t}\r\n\t100%{\r\n\t\t-webkit-transform: translateY(0%) scaleY(1) scaleX(1);\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n==============================================\r\npulse\r\n==============================================\r\n*/\r\n\r\n.pulse{\r\n\tanimation-name: pulse;\r\n\t-webkit-animation-name: pulse;\r\n\r\n\tanimation-duration: 1.5s;\r\n\t-webkit-animation-duration: 1.5s;\r\n\r\n\tanimation-iteration-count: infinite;\r\n\t-webkit-animation-iteration-count: infinite;\r\n}\r\n\r\n@keyframes pulse {\r\n\t0% {\r\n\t\ttransform: scale(0.9);\r\n\t\topacity: 0.7;\r\n\t}\r\n\t50% {\r\n\t\ttransform: scale(1);\r\n\t\topacity: 1;\r\n\t}\r\n\t100% {\r\n\t\ttransform: scale(0.9);\r\n\t\topacity: 0.7;\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes pulse {\r\n\t0% {\r\n\t\t-webkit-transform: scale(0.95);\r\n\t\topacity: 0.7;\r\n\t}\r\n\t50% {\r\n\t\t-webkit-transform: scale(1);\r\n\t\topacity: 1;\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scale(0.95);\r\n\t\topacity: 0.7;\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nfloating\r\n==============================================\r\n*/\r\n\r\n.floating{\r\n\tanimation-name: floating;\r\n\t-webkit-animation-name: floating;\r\n\r\n\tanimation-duration: 1.5s;\r\n\t-webkit-animation-duration: 1.5s;\r\n\r\n\tanimation-iteration-count: infinite;\r\n\t-webkit-animation-iteration-count: infinite;\r\n}\r\n\r\n@keyframes floating {\r\n\t0% {\r\n\t\ttransform: translateY(0%);\r\n\t}\r\n\t50% {\r\n\t\ttransform: translateY(8%);\r\n\t}\r\n\t100% {\r\n\t\ttransform: translateY(0%);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes floating {\r\n\t0% {\r\n\t\t-webkit-transform: translateY(0%);\r\n\t}\r\n\t50% {\r\n\t\t-webkit-transform: translateY(8%);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: translateY(0%);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\ntossing\r\n==============================================\r\n*/\r\n\r\n.tossing{\r\n\tanimation-name: tossing;\r\n\t-webkit-animation-name: tossing;\r\n\r\n\tanimation-duration: 2.5s;\r\n\t-webkit-animation-duration: 2.5s;\r\n\r\n\tanimation-iteration-count: infinite;\r\n\t-webkit-animation-iteration-count: infinite;\r\n}\r\n\r\n@keyframes tossing {\r\n\t0% {\r\n\t\ttransform: rotate(-4deg);\r\n\t}\r\n\t50% {\r\n\t\ttransform: rotate(4deg);\r\n\t}\r\n\t100% {\r\n\t\ttransform: rotate(-4deg);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes tossing {\r\n\t0% {\r\n\t\t-webkit-transform: rotate(-4deg);\r\n\t}\r\n\t50% {\r\n\t\t-webkit-transform: rotate(4deg);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: rotate(-4deg);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\npullUp\r\n==============================================\r\n*/\r\n\r\n.pullUp{\r\n\tanimation-name: pullUp;\r\n\t-webkit-animation-name: pullUp;\r\n\r\n\tanimation-duration: 1.1s;\r\n\t-webkit-animation-duration: 1.1s;\r\n\r\n\tanimation-timing-function: ease-out;\r\n\t-webkit-animation-timing-function: ease-out;\r\n\r\n\ttransform-origin: 50% 100%;\r\n\t-ms-transform-origin: 50% 100%;\r\n\t-webkit-transform-origin: 50% 100%;\r\n}\r\n\r\n@keyframes pullUp {\r\n\t0% {\r\n\t\ttransform: scaleY(0.1);\r\n\t}\r\n\t40% {\r\n\t\ttransform: scaleY(1.02);\r\n\t}\r\n\t60% {\r\n\t\ttransform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleY(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes pullUp {\r\n\t0% {\r\n\t\t-webkit-transform: scaleY(0.1);\r\n\t}\r\n\t40% {\r\n\t\t-webkit-transform: scaleY(1.02);\r\n\t}\r\n\t60% {\r\n\t\t-webkit-transform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleY(1);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\npullDown\r\n==============================================\r\n*/\r\n\r\n.pullDown{\r\n\tanimation-name: pullDown;\r\n\t-webkit-animation-name: pullDown;\r\n\r\n\tanimation-duration: 1.1s;\r\n\t-webkit-animation-duration: 1.1s;\r\n\r\n\tanimation-timing-function: ease-out;\r\n\t-webkit-animation-timing-function: ease-out;\r\n\r\n\ttransform-origin: 50% 0%;\r\n\t-ms-transform-origin: 50% 0%;\r\n\t-webkit-transform-origin: 50% 0%;\r\n}\r\n\r\n@keyframes pullDown {\r\n\t0% {\r\n\t\ttransform: scaleY(0.1);\r\n\t}\r\n\t40% {\r\n\t\ttransform: scaleY(1.02);\r\n\t}\r\n\t60% {\r\n\t\ttransform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleY(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes pullDown {\r\n\t0% {\r\n\t\t-webkit-transform: scaleY(0.1);\r\n\t}\r\n\t40% {\r\n\t\t-webkit-transform: scaleY(1.02);\r\n\t}\r\n\t60% {\r\n\t\t-webkit-transform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleY(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleY(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleY(1);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nstretchLeft\r\n==============================================\r\n*/\r\n\r\n.stretchLeft{\r\n\tanimation-name: stretchLeft;\r\n\t-webkit-animation-name: stretchLeft;\r\n\r\n\tanimation-duration: 1.5s;\r\n\t-webkit-animation-duration: 1.5s;\r\n\r\n\tanimation-timing-function: ease-out;\r\n\t-webkit-animation-timing-function: ease-out;\r\n\r\n\ttransform-origin: 100% 0%;\r\n\t-ms-transform-origin: 100% 0%;\r\n\t-webkit-transform-origin: 100% 0%;\r\n}\r\n\r\n@keyframes stretchLeft {\r\n\t0% {\r\n\t\ttransform: scaleX(0.3);\r\n\t}\r\n\t40% {\r\n\t\ttransform: scaleX(1.02);\r\n\t}\r\n\t60% {\r\n\t\ttransform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleX(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes stretchLeft {\r\n\t0% {\r\n\t\t-webkit-transform: scaleX(0.3);\r\n\t}\r\n\t40% {\r\n\t\t-webkit-transform: scaleX(1.02);\r\n\t}\r\n\t60% {\r\n\t\t-webkit-transform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleX(1);\r\n\t}\r\n}\r\n\r\n/*\r\n==============================================\r\nstretchRight\r\n==============================================\r\n*/\r\n\r\n.stretchRight{\r\n\tanimation-name: stretchRight;\r\n\t-webkit-animation-name: stretchRight;\r\n\r\n\tanimation-duration: 1.5s;\r\n\t-webkit-animation-duration: 1.5s;\r\n\r\n\tanimation-timing-function: ease-out;\r\n\t-webkit-animation-timing-function: ease-out;\r\n\r\n\ttransform-origin: 0% 0%;\r\n\t-ms-transform-origin: 0% 0%;\r\n\t-webkit-transform-origin: 0% 0%;\r\n}\r\n\r\n@keyframes stretchRight {\r\n\t0% {\r\n\t\ttransform: scaleX(0.3);\r\n\t}\r\n\t40% {\r\n\t\ttransform: scaleX(1.02);\r\n\t}\r\n\t60% {\r\n\t\ttransform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\ttransform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\ttransform: scaleX(1);\r\n\t}\r\n}\r\n\r\n@-webkit-keyframes stretchRight {\r\n\t0% {\r\n\t\t-webkit-transform: scaleX(0.3);\r\n\t}\r\n\t40% {\r\n\t\t-webkit-transform: scaleX(1.02);\r\n\t}\r\n\t60% {\r\n\t\t-webkit-transform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleX(0.98);\r\n\t}\r\n\t80% {\r\n\t\t-webkit-transform: scaleX(1.01);\r\n\t}\r\n\t100% {\r\n\t\t-webkit-transform: scaleX(1);\r\n\t}\r\n}", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/editor.css":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/editor.css ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".editor-left {\r\n  overflow: scroll;\r\n  display: flex;\r\n  flex-flow: column;\r\n  justify-content: flex-start;\r\n  align-content: center;\r\n  height: 85vh;\r\n  width: 100%;\r\n  padding: 2px;\r\n}\r\n\r\n.editor-left.card > .card-footer > .card-btn {\r\n  width: 48%;\r\n}\r\n\r\n.editor-right {\r\n  background: white;\r\n  border: 1px dashed green;\r\n  width: 90%;\r\n  overflow-y: scroll;\r\n  height: 85vh;\r\n  padding: 10px;\r\n  display: flex;\r\n  flex-flow: column;\r\n  justify-content: flex-start;\r\n}\r\n\r\n.editor-input {\r\n  width: 100%;\r\n  line-height: 20px;\r\n}\r\n\r\n.editor-text {\r\n  height: 500px;\r\n  margin-bottom: 10px;\r\n}\r\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/index.css":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/index.css ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports
exports.push([module.i, "@import url(https://fonts.googleapis.com/css?family=Rubik);", ""]);
exports.push([module.i, "@import url(https://fonts.googleapis.com/css?family=Inconsolata);", ""]);
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./animations.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/animations.css"), "");
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./slideshow.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/slideshow.css"), "");
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./editor.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/editor.css"), "");
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./modal.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/modal.css"), "");
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./preview.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/preview.css"), "");
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./slides.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/slides.css"), "");
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./presentations.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/presentations.css"), "");
exports.i(__webpack_require__(/*! -!../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./toolbar.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/toolbar.css"), "");

// module
exports.push([module.i, "/* index.css */\r\n\r\n\r\n* {\r\n  box-sizing: border-box;\r\n}\r\n\r\n\r\nbody,\r\nhtml {\r\n  padding: 0;\r\n  margin: 0;\r\n  display: flex;\r\n  flex-direction: column;\r\n  font-family: \"Rubik\", \"Inconsolata\", sans-serif;\r\n}\r\n\r\n.main {\r\n  display: grid;\r\n  grid-template-areas: \"toolbar\" \"body\";\r\n}\r\n\r\n.container {\r\n\r\n  padding: 4px;\r\n  display: flex;\r\n  flex-flow: column;\r\n  justify-content: flex-start;\r\n  align-content: flex-start;\r\n}\r\n\r\n.card {\r\n  position: relative;\r\n  display: flex;\r\n  flex-flow: column;\r\n  justify-content: stretch;\r\n  min-width: 200px;\r\n  max-width: 300px;\r\n  height: fit-content;\r\n  margin: 10px;\r\n  border-radius: 2%;\r\n  background-color: rgba(44, 62, 80, 1);\r\n  box-shadow: 1px 1px 2px 1px #95a5a6;\r\n  color: rgba(236,240,241 ,1);\r\n}\r\n\r\n.card-header {\r\n  max-height: 100px;\r\n  width: 100%;\r\n  padding: 4px;\r\n  background-color: rgba(44, 62, 80, 1);\r\n  border-bottom: 1px #34495e;\r\n  display: flex;\r\n  justify-content: space-around;\r\n  align-content: center;\r\n}\r\n\r\n.card-body {\r\n  max-height: 200px;\r\n  width: 100%;\r\n  padding: 2px;\r\n  background-color: rgba(44, 62, 80, 1);\r\n  border-bottom: 1px #34495e;\r\n}\r\n\r\n.card:hover .card-delete {\r\n  opacity: 1;\r\n}\r\n\r\n.card-footer {\r\n  max-height: 100px;\r\n  width: 100%;\r\n  padding: 2px;\r\n  background-color: rgba(44, 62, 80, 1);\r\n  display: flex;\r\n  flex-flow: wrap;\r\n  justify-content: space-between;\r\n  align-content: center;\r\n}\r\n\r\n.card-delete {\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n  position: absolute;\r\n  top: -5px;\r\n  right: -5px;\r\n  width: 20px;\r\n  height: 20px;\r\n  border-radius: 50%;\r\n  opacity: 0;\r\n  cursor: pointer;\r\n}\r\n\r\n.card-delete:before {\r\n  font-size: 10px;\r\n  content: \"X\";\r\n}\r\n\r\n.card-delete:hover {\r\n  background-color: #e74c3c;\r\n  color: rgba(44, 62, 80, 1);\r\n}\r\n\r\n.card-btn {\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n  height: 40px;\r\n  margin: 2px;\r\n  padding: 10px;\r\n  border-radius: 2px;\r\n  cursor: pointer;\r\n  font-size: 18px;\r\n  transition: all 0.2s;\r\n  display: flex;\r\n  flex-flow: wrap;\r\n}\r\n\r\n.card-btn:hover {\r\n  background-color: rgba(189,195,199,1);\r\n   color: rgba(44, 62, 80, 1);\r\n}\r\n\r\n.language-js {\r\n  display: block;\r\n  padding: 20px;\r\n  font-size: 17px;\r\n  line-height: 1.2em;\r\n  background: rgba(44, 62, 80, 1);\r\n  color: rgba(39, 174, 96, 1);\r\n  border-radius: 6px;\r\n  font-family: Inconsolata;\r\n}\r\n\r\n.language-html {\r\n  font-family: code;\r\n  background: rgba(44, 62, 80, 1);\r\n  background: linear-gradient(180deg, #ccc 0, #ccc 1.2em, #eee 0);\r\n  color: rgba(41, 128, 185, 1);\r\n}\r\n\r\n.full-width {\r\n  width: 100%;\r\n}\r\n\r\n@media only screen and (min-width: 600px) {\r\n  .container {\r\n    flex-flow: row;\r\n  }\r\n}\r\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/modal.css":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/modal.css ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".modal-container {\r\n  position:absolute;\r\n  width: 100%;\r\n  height: 100%;\r\n  background: rgba(44, 62, 80,.9);\r\n  display: flex;\r\n  flex-flow: column;\r\n  justify-content: center;\r\n  z-index: 10;\r\n}\r\n\r\n\r\n.modal-container > .card {\r\n  margin: 0 auto;\r\n}\r\n\r\n.modal-content {\r\n  display: flex;\r\n  flex-flow: column;\r\n  justify-content: center;\r\n  align-content: center;\r\n  width: 80%;\r\n}\r\n\r\n.modal-label {\r\n\r\n}\r\n\r\n.modal-input {\r\n\r\n}\r\n\r\n.modal-close {\r\n  width: 200px;\r\n  height: 40px;\r\n  background: white;\r\n}\r\n\r\n.modal-close:before {\r\n  content: 'Cancel'\r\n}\r\n\r\n.modal-saveBtn {\r\n\r\n}\r\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/presentations.css":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/presentations.css ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "\r\n@keyframes fadeIn {\r\n  0% {\r\n    opacity: 0;\r\n  }\r\n\r\n  100% {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n@keyframes fadeOut {\r\n  0% {\r\n    opacity: 1;\r\n  }\r\n\r\n  100% {\r\n    opacity: 0;\r\n  }\r\n}\r\n\r\n\r\n.presentations {\r\n  animation: fadeIn .5s ease-in-out;\r\n}\r\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/preview.css":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/preview.css ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".preview {\r\n  width: 200px;\r\n  height: 200px;\r\n  margin: 12px;\r\n  overflow: hidden;\r\n}\r\n\r\n.card.preview {\r\n  cursor: grab;\r\n}\r\n\r\n.preview > .card-header {\r\n  background: transparent;\r\n}\r\n\r\n.preview > .card-body {\r\n  position: absolute;\r\n  background: transparent;\r\n}\r\n\r\n.preview > .card-body > * {\r\n  opacity: 0.1;\r\n}\r\n\r\n.preview-delete {\r\n  top: 4px;\r\n  right: 4px;\r\n  z-index: 3;\r\n  cursor: pointer;\r\n}\r\n\r\n.preview-delete:before {\r\n  padding-left: 4px;\r\n}\r\n\r\n.slidePosition {\r\n  color: #e67e22;\r\n  font-size: 6rem;\r\n}\r\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/slides.css":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/slides.css ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".slides {\r\n  justify-content: space-evenly;\r\n  animation: fadeIn 0.5s ease-in-out;\r\n}\r\n\r\n.left-drag {\r\n  grid-area: left-drag;\r\n  display: flex;\r\n  flex-flow: column;\r\n  order: 1;\r\n  border: 1px dashed rgba(44, 62, 80, 0.3);\r\n  height: 88vh;\r\n}\r\n\r\n.left-drag .card:hover {\r\n  cursor: grab;\r\n}\r\n\r\n.right-drag {\r\n  order: 2;\r\n  grid-area: right-drag;\r\n  flex-flow: wrap;\r\n  display: flex;\r\n  min-width: 100%;\r\n  border: 1px dashed rgba(44, 62, 80, 0.3);\r\n}\r\n\r\n.isDragging {\r\n  background: rgba(44, 62, 80, 0.3);\r\n  box-shadow: inset 0 0 1px rgba(44, 62, 80, 1);\r\n}\r\n\r\n.drop {\r\n  cursor: drop;\r\n}\r\n\r\n@media only screen and (min-width: 600px) {\r\n  .slides {\r\n    display: inline-grid;\r\n    grid-template-areas: \"left-drag right-drag\";\r\n    grid-template-columns: 1fr 2fr;\r\n    max-height: 90vh;\r\n  }\r\n}\r\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/slideshow.css":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/slideshow.css ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".slideshow {\r\n  height: 90vh;\r\n  width: 90%;\r\n  margin: 0 auto;\r\n  background: white;\r\n  outline: 0;\r\n}\r\n\r\n.slidecard {\r\n  animation: stretchRight 1s ease-in-out both;\r\n  outline: 0;\r\n}\r\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/toolbar.css":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./src/styles/toolbar.css ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".toolbar {\r\n  display: flex;\r\n  flex-flow: column;\r\n  line-height: 2;\r\n  background: #ecf0f1;\r\n  padding: 2px;\r\n}\r\n\r\n.toolbar-left {\r\n  order: 1;\r\n  grid-area: toolbar-left;\r\n  display: flex;\r\n  flex-flow: wrap;\r\n  justify-content: space-between;\r\n}\r\n\r\n\r\n.toolbar-right {\r\n  order: 2;\r\n  grid-area: toolbar-right;\r\n  display: flex;\r\n  flex-flow: wrap;\r\n  justify-content: space-between;\r\n}\r\n\r\n.toolbar-item {\r\n  text-decoration: none;\r\n  color: rgba(44, 62, 80,1);\r\n  margin: 2px;\r\n  padding: 10px;\r\n  border-radius:2px;\r\n  cursor: pointer;\r\n  transition: all .5s;\r\n}\r\n\r\n.toolbar-item:hover {\r\n  background-color: rgba(44, 62, 80,1);\r\n  color: rgba(236, 240, 241,1.0);\r\n}\r\n\r\n@media only screen and (min-width: 600px) {\r\n  .toolbar {\r\n    display: inline-grid;\r\n    grid-template-areas: \"toolbar-left toolbar-right\";\r\n    line-height: 2;\r\n    background: rgba(236, 240, 241,1.0);\r\n    padding: 2px;\r\n  }\r\n}", ""]);

// exports


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/lib/css-base.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/index.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./task */ "./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/task.js");


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/task.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/task.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate, process) {


/**
 * A helper for delaying the execution of a function.
 * @private
 * @summary (Any... -> Any) -> Void
 */
var delayed = typeof setImmediate !== 'undefined'?  setImmediate
            : typeof process !== 'undefined'?       process.nextTick
            : /* otherwise */                       setTimeout

/**
 * @module lib/task
 */
module.exports = Task;

// -- Implementation ---------------------------------------------------

/**
 * The `Task[Î±, Î²]` structure represents values that depend on time. This
 * allows one to model time-based effects explicitly, such that one can have
 * full knowledge of when they're dealing with delayed computations, latency,
 * or anything that can not be computed immediately.
 *
 * A common use for this structure is to replace the usual Continuation-Passing
 * Style form of programming, in order to be able to compose and sequence
 * time-dependent effects using the generic and powerful monadic operations.
 *
 * @class
 * @summary
 * ((Î± â Void), (Î² â Void) â Void), (Void â Void) â Task[Î±, Î²]
 *
 * Task[Î±, Î²] <: Chain[Î²]
 *               , Monad[Î²]
 *               , Functor[Î²]
 *               , Applicative[Î²]
 *               , Semigroup[Î²]
 *               , Monoid[Î²]
 *               , Show
 */
function Task(computation, cleanup) {
  this.fork = computation;

  this.cleanup = cleanup || function() {};
}

/**
 * Constructs a new `Task[Î±, Î²]` containing the single value `Î²`.
 *
 * `Î²` can be any value, including `null`, `undefined`, or another
 * `Task[Î±, Î²]` structure.
 *
 * @summary Î² â Task[Î±, Î²]
 */
Task.prototype.of = function _of(b) {
  return new Task(function(_, resolve) {
    return resolve(b);
  });
};

Task.of = Task.prototype.of;

/**
 * Constructs a new `Task[Î±, Î²]` containing the single value `Î±`.
 *
 * `Î±` can be any value, including `null`, `undefined`, or another
 * `Task[Î±, Î²]` structure.
 *
 * @summary Î± â Task[Î±, Î²]
 */
Task.prototype.rejected = function _rejected(a) {
  return new Task(function(reject) {
    return reject(a);
  });
};

Task.rejected = Task.prototype.rejected;

// -- Functor ----------------------------------------------------------

/**
 * Transforms the successful value of the `Task[Î±, Î²]` using a regular unary
 * function.
 *
 * @summary @Task[Î±, Î²] => (Î² â Î³) â Task[Î±, Î³]
 */
Task.prototype.map = function _map(f) {
  var fork = this.fork;
  var cleanup = this.cleanup;

  return new Task(function(reject, resolve) {
    return fork(function(a) {
      return reject(a);
    }, function(b) {
      return resolve(f(b));
    });
  }, cleanup);
};

// -- Chain ------------------------------------------------------------

/**
 * Transforms the succesful value of the `Task[Î±, Î²]` using a function to a
 * monad.
 *
 * @summary @Task[Î±, Î²] => (Î² â Task[Î±, Î³]) â Task[Î±, Î³]
 */
Task.prototype.chain = function _chain(f) {
  var fork = this.fork;
  var cleanup = this.cleanup;

  return new Task(function(reject, resolve) {
    return fork(function(a) {
      return reject(a);
    }, function(b) {
      return f(b).fork(reject, resolve);
    });
  }, cleanup);
};

// -- Apply ------------------------------------------------------------

/**
 * Applys the successful value of the `Task[Î±, (Î² â Î³)]` to the successful
 * value of the `Task[Î±, Î²]`
 *
 * @summary @Task[Î±, (Î² â Î³)] => Task[Î±, Î²] â Task[Î±, Î³]
 */

Task.prototype.ap = function _ap(that) {
  var forkThis = this.fork;
  var forkThat = that.fork;
  var cleanupThis = this.cleanup;
  var cleanupThat = that.cleanup;

  function cleanupBoth(state) {
    cleanupThis(state[0]);
    cleanupThat(state[1]);
  }

  return new Task(function(reject, resolve) {
    var func, funcLoaded = false;
    var val, valLoaded = false;
    var rejected = false;
    var allState;

    var thisState = forkThis(guardReject, guardResolve(function(x) {
      funcLoaded = true;
      func = x;
    }));

    var thatState = forkThat(guardReject, guardResolve(function(x) {
      valLoaded = true;
      val = x;
    }));

    function guardResolve(setter) {
      return function(x) {
        if (rejected) {
          return;
        }

        setter(x);
        if (funcLoaded && valLoaded) {
          delayed(function(){ cleanupBoth(allState) });
          return resolve(func(val));
        } else {
          return x;
        }
      }
    }

    function guardReject(x) {
      if (!rejected) {
        rejected = true;
        return reject(x);
      }
    }

    return allState = [thisState, thatState];
  }, cleanupBoth);
};

// -- Semigroup ------------------------------------------------------------

/**
 * Selects the earlier of the two tasks `Task[Î±, Î²]`
 *
 * @summary @Task[Î±, Î²] => Task[Î±, Î²] â Task[Î±, Î²]
 */

Task.prototype.concat = function _concat(that) {
  var forkThis = this.fork;
  var forkThat = that.fork;
  var cleanupThis = this.cleanup;
  var cleanupThat = that.cleanup;

  function cleanupBoth(state) {
    cleanupThis(state[0]);
    cleanupThat(state[1]);
  }

  return new Task(function(reject, resolve) {
    var done = false;
    var allState;
    var thisState = forkThis(guard(reject), guard(resolve));
    var thatState = forkThat(guard(reject), guard(resolve));

    return allState = [thisState, thatState];

    function guard(f) {
      return function(x) {
        if (!done) {
          done = true;
          delayed(function(){ cleanupBoth(allState) })
          return f(x);
        }
      };
    }
  }, cleanupBoth);

};

// -- Monoid ------------------------------------------------------------

/**
 * Returns a Task that will never resolve
 *
 * @summary Void â Task[Î±, _]
 */
Task.empty = function _empty() {
  return new Task(function() {});
};

Task.prototype.empty = Task.empty;

// -- Show -------------------------------------------------------------

/**
 * Returns a textual representation of the `Task[Î±, Î²]`
 *
 * @summary @Task[Î±, Î²] => Void â String
 */
Task.prototype.toString = function _toString() {
  return 'Task';
};

// -- Extracting and recovering ----------------------------------------

/**
 * Transforms a failure value into a new `Task[Î±, Î²]`. Does nothing if the
 * structure already contains a successful value.
 *
 * @summary @Task[Î±, Î²] => (Î± â Task[Î³, Î²]) â Task[Î³, Î²]
 */
Task.prototype.orElse = function _orElse(f) {
  var fork = this.fork;
  var cleanup = this.cleanup;

  return new Task(function(reject, resolve) {
    return fork(function(a) {
      return f(a).fork(reject, resolve);
    }, function(b) {
      return resolve(b);
    });
  }, cleanup);
};

// -- Folds and extended transformations -------------------------------

/**
 * Catamorphism. Takes two functions, applies the leftmost one to the failure
 * value, and the rightmost one to the successful value, depending on which one
 * is present.
 *
 * @summary @Task[Î±, Î²] => (Î± â Î³), (Î² â Î³) â Task[Î´, Î³]
 */
Task.prototype.fold = function _fold(f, g) {
  var fork = this.fork;
  var cleanup = this.cleanup;

  return new Task(function(reject, resolve) {
    return fork(function(a) {
      return resolve(f(a));
    }, function(b) {
      return resolve(g(b));
    });
  }, cleanup);
};

/**
 * Catamorphism.
 *
 * @summary @Task[Î±, Î²] => { Rejected: Î± â Î³, Resolved: Î² â Î³ } â Task[Î´, Î³]
 */
Task.prototype.cata = function _cata(pattern) {
  return this.fold(pattern.Rejected, pattern.Resolved);
};

/**
 * Swaps the disjunction values.
 *
 * @summary @Task[Î±, Î²] => Void â Task[Î², Î±]
 */
Task.prototype.swap = function _swap() {
  var fork = this.fork;
  var cleanup = this.cleanup;

  return new Task(function(reject, resolve) {
    return fork(function(a) {
      return resolve(a);
    }, function(b) {
      return reject(b);
    });
  }, cleanup);
};

/**
 * Maps both sides of the disjunction.
 *
 * @summary @Task[Î±, Î²] => (Î± â Î³), (Î² â Î´) â Task[Î³, Î´]
 */
Task.prototype.bimap = function _bimap(f, g) {
  var fork = this.fork;
  var cleanup = this.cleanup;

  return new Task(function(reject, resolve) {
    return fork(function(a) {
      return reject(f(a));
    }, function(b) {
      return resolve(g(b));
    });
  }, cleanup);
};

/**
 * Maps the left side of the disjunction (failure).
 *
 * @summary @Task[Î±, Î²] => (Î± â Î³) â Task[Î³, Î²]
 */
Task.prototype.rejectedMap = function _rejectedMap(f) {
  var fork = this.fork;
  var cleanup = this.cleanup;

  return new Task(function(reject, resolve) {
    return fork(function(a) {
      return reject(f(a));
    }, function(b) {
      return resolve(b);
    });
  }, cleanup);
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../timers-browserify/2.0.10/node_modules/timers-browserify/main.js */ "./node_modules/.registry.npmjs.org/timers-browserify/2.0.10/node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../../../../process/0.11.10/node_modules/process/browser.js */ "./node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril-stream/1.1.0/node_modules/mithril-stream/stream.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril-stream/1.1.0/node_modules/mithril-stream/stream.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable */
;(function() {
"use strict"
/* eslint-enable */

var guid = 0, HALT = {}
function createStream() {
	function stream() {
		if (arguments.length > 0 && arguments[0] !== HALT) updateStream(stream, arguments[0])
		return stream._state.value
	}
	initStream(stream)

	if (arguments.length > 0 && arguments[0] !== HALT) updateStream(stream, arguments[0])

	return stream
}
function initStream(stream) {
	stream.constructor = createStream
	stream._state = {id: guid++, value: undefined, state: 0, derive: undefined, recover: undefined, deps: {}, parents: [], endStream: undefined, unregister: undefined}
	stream.map = stream["fantasy-land/map"] = map, stream["fantasy-land/ap"] = ap, stream["fantasy-land/of"] = createStream
	stream.valueOf = valueOf, stream.toJSON = toJSON, stream.toString = valueOf

	Object.defineProperties(stream, {
		end: {get: function() {
			if (!stream._state.endStream) {
				var endStream = createStream()
				endStream.map(function(value) {
					if (value === true) {
						unregisterStream(stream)
						endStream._state.unregister = function(){unregisterStream(endStream)}
					}
					return value
				})
				stream._state.endStream = endStream
			}
			return stream._state.endStream
		}}
	})
}
function updateStream(stream, value) {
	updateState(stream, value)
	for (var id in stream._state.deps) updateDependency(stream._state.deps[id], false)
	if (stream._state.unregister != null) stream._state.unregister()
	finalize(stream)
}
function updateState(stream, value) {
	stream._state.value = value
	stream._state.changed = true
	if (stream._state.state !== 2) stream._state.state = 1
}
function updateDependency(stream, mustSync) {
	var state = stream._state, parents = state.parents
	if (parents.length > 0 && parents.every(active) && (mustSync || parents.some(changed))) {
		var value = stream._state.derive()
		if (value === HALT) return false
		updateState(stream, value)
	}
}
function finalize(stream) {
	stream._state.changed = false
	for (var id in stream._state.deps) stream._state.deps[id]._state.changed = false
}

function combine(fn, streams) {
	if (!streams.every(valid)) throw new Error("Ensure that each item passed to stream.combine/stream.merge is a stream")
	return initDependency(createStream(), streams, function() {
		return fn.apply(this, streams.concat([streams.filter(changed)]))
	})
}

function initDependency(dep, streams, derive) {
	var state = dep._state
	state.derive = derive
	state.parents = streams.filter(notEnded)

	registerDependency(dep, state.parents)
	updateDependency(dep, true)

	return dep
}
function registerDependency(stream, parents) {
	for (var i = 0; i < parents.length; i++) {
		parents[i]._state.deps[stream._state.id] = stream
		registerDependency(stream, parents[i]._state.parents)
	}
}
function unregisterStream(stream) {
	for (var i = 0; i < stream._state.parents.length; i++) {
		var parent = stream._state.parents[i]
		delete parent._state.deps[stream._state.id]
	}
	for (var id in stream._state.deps) {
		var dependent = stream._state.deps[id]
		var index = dependent._state.parents.indexOf(stream)
		if (index > -1) dependent._state.parents.splice(index, 1)
	}
	stream._state.state = 2 //ended
	stream._state.deps = {}
}

function map(fn) {return combine(function(stream) {return fn(stream())}, [this])}
function ap(stream) {return combine(function(s1, s2) {return s1()(s2())}, [stream, this])}
function valueOf() {return this._state.value}
function toJSON() {return this._state.value != null && typeof this._state.value.toJSON === "function" ? this._state.value.toJSON() : this._state.value}

function valid(stream) {return stream._state }
function active(stream) {return stream._state.state === 1}
function changed(stream) {return stream._state.changed}
function notEnded(stream) {return stream._state.state !== 2}

function merge(streams) {
	return combine(function() {
		return streams.map(function(s) {return s()})
	}, streams)
}

function scan(reducer, seed, stream) {
	var newStream = combine(function (s) {
		return seed = reducer(seed, s._state.value)
	}, [stream])

	if (newStream._state.state === 0) newStream(seed)

	return newStream
}

function scanMerge(tuples, seed) {
	var streams = tuples.map(function(tuple) {
		var stream = tuple[0]
		if (stream._state.state === 0) stream(undefined)
		return stream
	})

	var newStream = combine(function() {
		var changed = arguments[arguments.length - 1]

		streams.forEach(function(stream, idx) {
			if (changed.indexOf(stream) > -1) {
				seed = tuples[idx][1](seed, stream._state.value)
			}
		})

		return seed
	}, streams)

	return newStream
}

createStream["fantasy-land/of"] = createStream
createStream.merge = merge
createStream.combine = combine
createStream.scan = scan
createStream.scanMerge = scanMerge
createStream.HALT = HALT

if (true) module["exports"] = createStream
else {}

}());


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/mount.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/mount.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Vnode = __webpack_require__(/*! ../render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")

module.exports = function(redrawService) {
	return function(root, component) {
		if (component === null) {
			redrawService.unsubscribe(root)
		} else if (component.view == null && typeof component !== "function") {
			throw new Error("m.mount(element, component) expects a component, not a vnode")
		} else {
			redrawService.subscribe(root, function() { return Vnode(component) })
		}
	}
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/redraw.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/redraw.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var coreRenderer = __webpack_require__(/*! ../render/render */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/render.js")

function throttle(callback) {
	var pending = null
	return function() {
		if (pending === null) {
			pending = requestAnimationFrame(function() {
				pending = null
				callback()
			})
		}
	}
}

module.exports = function($window, throttleMock) {
	var renderService = coreRenderer($window)
	var subscriptions = []
	var rendering = false

	function run(sub) {
		var vnode = sub.c(sub)
		if (vnode !== sub) renderService.render(sub.k, vnode)
	}
	function subscribe(key, callback, onremove) {
		var sub = {k: key, c: callback, r: onremove}
		unsubscribe(key)
		subscriptions.push(sub)
		var vnode = sub.c(sub)
		if (vnode !== sub) renderService.render(sub.k, vnode)
	}
	function unsubscribe(key) {
		for (var i = 0; i < subscriptions.length; i++) {
			var sub = subscriptions[i]
			if (sub.k === key) {
				subscriptions.splice(i, 1)
				renderService.render(sub.k, [])
				if (typeof sub.r === "function") sub.r()
				break
			}
		}
	}
	function sync() {
		if (rendering) throw new Error("Nested m.redraw.sync() call")
		rendering = true
		for (var i = 0; i < subscriptions.length; i++) {
			try { run(subscriptions[i]) }
			catch (e) { if (typeof console !== "undefined") console.error(e) }
		}
		rendering = false
	}

	var redraw = (throttleMock || throttle)(sync)
	redraw.sync = sync
	renderService.setRedraw(redraw)
	return {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/router.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/router.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Vnode = __webpack_require__(/*! ../render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")
var Promise = __webpack_require__(/*! ../promise/promise */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/promise.js")
var coreRouter = __webpack_require__(/*! ../router/router */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/router/router.js")

var sentinel = {}

module.exports = function($window, redrawService) {
	var routeService = coreRouter($window)

	var currentResolver = sentinel, component, attrs, currentPath, lastUpdate
	var route = function(root, defaultRoute, routes) {
		if (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined")
		var init = false
		var bail = function(path) {
			if (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})
			else throw new Error("Could not resolve default route " + defaultRoute)
		}
		function run() {
			init = true
			if (sentinel !== currentResolver) {
				var vnode = Vnode(component, attrs.key, attrs)
				if (currentResolver) vnode = currentResolver.render(vnode)
				return vnode
			}
		}
		routeService.defineRoutes(routes, function(payload, params, path, route) {
			var update = lastUpdate = function(routeResolver, comp) {
				if (update !== lastUpdate) return
				component = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div"
				attrs = params, currentPath = path, lastUpdate = null
				currentResolver = routeResolver.render ? routeResolver : null
				if (init) redrawService.redraw()
				else {
					init = true
					redrawService.redraw.sync()
				}
			}
			if (payload.view || typeof payload === "function") update({}, payload)
			else {
				if (payload.onmatch) {
					Promise.resolve(payload.onmatch(params, path, route)).then(function(resolved) {
						update(payload, resolved)
					}, function () { bail(path) })
				}
				else update(payload, "div")
			}
		}, bail, defaultRoute, function (unsubscribe) {
			redrawService.subscribe(root, function(sub) {
				sub.c = run
				return sub
			}, unsubscribe)
		})
	}
	route.set = function(path, data, options) {
		if (lastUpdate != null) {
			options = options || {}
			options.replace = true
		}
		lastUpdate = null
		routeService.setPath(path, data, options)
	}
	route.get = function() {return currentPath}
	route.prefix = function(prefix) {routeService.prefix = prefix}
	var link = function(options, vnode) {
		vnode.dom.setAttribute("href", routeService.prefix + vnode.attrs.href)
		vnode.dom.onclick = function(e) {
			if (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return
			e.preventDefault()
			e.redraw = false
			var href = this.getAttribute("href")
			if (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)
			route.set(href, undefined, options)
		}
	}
	route.link = function(args) {
		if (args.tag == null) return link.bind(link, args)
		return link({}, args)
	}
	route.param = function(key) {
		if(typeof attrs !== "undefined" && typeof key !== "undefined") return attrs[key]
		return attrs
	}

	return route
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/hyperscript.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/hyperscript.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hyperscript = __webpack_require__(/*! ./render/hyperscript */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/hyperscript.js")

hyperscript.trust = __webpack_require__(/*! ./render/trust */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/trust.js")
hyperscript.fragment = __webpack_require__(/*! ./render/fragment */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/fragment.js")

module.exports = hyperscript


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hyperscript = __webpack_require__(/*! ./hyperscript */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/hyperscript.js")
var m = function m() { return hyperscript.apply(this, arguments) }
m.m = hyperscript
m.trust = hyperscript.trust
m.fragment = hyperscript.fragment

var requestService = __webpack_require__(/*! ./request */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/request.js")
var redrawService = __webpack_require__(/*! ./redraw */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/redraw.js")

requestService.setCompletionCallback(redrawService.redraw)

m.mount = __webpack_require__(/*! ./mount */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/mount.js")
m.route = __webpack_require__(/*! ./route */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/route.js")
m.render = __webpack_require__(/*! ./render */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render.js").render
m.redraw = redrawService.redraw
m.request = requestService.request
m.jsonp = requestService.jsonp
m.parseQueryString = __webpack_require__(/*! ./querystring/parse */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/parse.js")
m.buildQueryString = __webpack_require__(/*! ./querystring/build */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/build.js")
m.parsePathname = __webpack_require__(/*! ./pathname/parse */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/parse.js")
m.buildPathname = __webpack_require__(/*! ./pathname/build */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/build.js")
m.version = __webpack_require__(/*! ./package.json */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/package.json").version
m.vnode = __webpack_require__(/*! ./render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")
m.PromisePolyfill = __webpack_require__(/*! ./promise/polyfill */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/polyfill.js")

module.exports = m


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/mount.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/mount.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redrawService = __webpack_require__(/*! ./redraw */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/redraw.js")

module.exports = __webpack_require__(/*! ./api/mount */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/mount.js")(redrawService)


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/package.json":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/package.json ***!
  \***********************************************************************************************/
/*! exports provided: name, version, description, author, license, unpkg, repository, scripts, devDependencies, bin, lint-staged, dependencies, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"mithril\",\"version\":\"2.0.0-rc.7\",\"description\":\"A framework for building brilliant applications\",\"author\":\"Leo Horie\",\"license\":\"MIT\",\"unpkg\":\"mithril.min.js\",\"repository\":\"MithrilJS/mithril.js\",\"scripts\":{\"dev\":\"node bundler/cli browser.js -output mithril.js -watch\",\"build\":\"npm run build-browser & npm run build-min\",\"build-browser\":\"node bundler/cli browser.js -output mithril.js\",\"build-min\":\"node bundler/cli browser.js -output mithril.min.js -minify\",\"precommit\":\"lint-staged\",\"lintdocs\":\"node docs/lint\",\"gendocs\":\"node docs/generate\",\"lint\":\"eslint . || true\",\"lint:fix\":\"eslint . --fix\",\"perf\":\"node performance/test-perf.js\",\"test\":\"node ospec/bin/ospec\",\"posttest\":\"npm run lint\",\"cover\":\"istanbul cover --print both ospec/bin/ospec\",\"release\":\"npm version -m 'v%s'\",\"preversion\":\"npm run test\",\"version\":\"npm run build && git add mithril.js mithril.min.js\",\"postversion\":\"git push --follow-tags\"},\"devDependencies\":{\"@alrra/travis-scripts\":\"^3.0.1\",\"benchmark\":\"^2.1.4\",\"chokidar\":\"^2.0.4\",\"dedent\":\"^0.7.0\",\"eslint\":\"^5.13.0\",\"gh-pages\":\"^2.0.1\",\"istanbul\":\"^0.4.5\",\"lint-staged\":\"^8.1.3\",\"locater\":\"^1.3.0\",\"marked\":\"^0.6.2\",\"pinpoint\":\"^1.1.0\",\"terser\":\"^3.16.1\"},\"bin\":{\"ospec\":\"./ospec/bin/ospec\"},\"lint-staged\":{\"*.js\":[\"eslint . --fix\",\"git add\"]},\"dependencies\":{}}");

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/assign.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/assign.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Object.assign || function(target, source) {
	if(source) Object.keys(source).forEach(function(key) { target[key] = source[key] })
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/build.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/build.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var buildQueryString = __webpack_require__(/*! ../querystring/build */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/build.js")
var assign = __webpack_require__(/*! ./assign */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/assign.js")

// Returns `path` from `template` + `params`
module.exports = function(template, params) {
	if ((/:([^\/\.-]+)(\.{3})?:/).test(template)) {
		throw new SyntaxError("Template parameter names *must* be separated")
	}
	if (params == null) return template
	var queryIndex = template.indexOf("?")
	var hashIndex = template.indexOf("#")
	var queryEnd = hashIndex < 0 ? template.length : hashIndex
	var pathEnd = queryIndex < 0 ? queryEnd : queryIndex
	var path = template.slice(0, pathEnd)
	var query = {}

	assign(query, params)

	var resolved = path.replace(/:([^\/\.-]+)(\.{3})?/g, function(m, key, variadic) {
		delete query[key]
		// If no such parameter exists, don't interpolate it.
		if (params[key] == null) return m
		// Escape normal parameters, but not variadic ones.
		return variadic ? params[key] : encodeURIComponent(String(params[key]))
	})

	// In case the template substitution adds new query/hash parameters.
	var newQueryIndex = resolved.indexOf("?")
	var newHashIndex = resolved.indexOf("#")
	var newQueryEnd = newHashIndex < 0 ? resolved.length : newHashIndex
	var newPathEnd = newQueryIndex < 0 ? newQueryEnd : newQueryIndex
	var result = resolved.slice(0, newPathEnd)

	if (queryIndex >= 0) result += template.slice(queryIndex, queryEnd)
	if (newQueryIndex >= 0) result += (queryIndex < 0 ? "?" : "&") + resolved.slice(newQueryIndex, newQueryEnd)
	var querystring = buildQueryString(query)
	if (querystring) result += (queryIndex < 0 && newQueryIndex < 0 ? "?" : "&") + querystring
	if (hashIndex >= 0) result += template.slice(hashIndex)
	if (newHashIndex >= 0) result += (hashIndex < 0 ? "" : "&") + resolved.slice(newHashIndex)
	return result
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/compileTemplate.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/compileTemplate.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var parsePathname = __webpack_require__(/*! ./parse */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/parse.js")

// Compiles a template into a function that takes a resolved path (without query
// strings) and returns an object containing the template parameters with their
// parsed values. This expects the input of the compiled template to be the
// output of `parsePathname`. Note that it does *not* remove query parameters
// specified in the template.
module.exports = function(template) {
	var templateData = parsePathname(template)
	var templateKeys = Object.keys(templateData.params)
	var keys = []
	var regexp = new RegExp("^" + templateData.path.replace(
		// I escape literal text so people can use things like `:file.:ext` or
		// `:lang-:locale` in routes. This is all merged into one pass so I
		// don't also accidentally escape `-` and make it harder to detect it to
		// ban it from template parameters.
		/:([^\/.-]+)(\.{3}|\.(?!\.)|-)?|[\\^$*+.()|\[\]{}]/g,
		function(m, key, extra) {
			if (key == null) return "\\" + m
			keys.push({k: key, r: extra === "..."})
			if (extra === "...") return "(.*)"
			if (extra === ".") return "([^/]+)\\."
			return "([^/]+)" + (extra || "")
		}
	) + "$")
	return function(data) {
		// First, check the params. Usually, there isn't any, and it's just
		// checking a static set.
		for (var i = 0; i < templateKeys.length; i++) {
			if (templateData.params[templateKeys[i]] !== data.params[templateKeys[i]]) return false
		}
		// If no interpolations exist, let's skip all the ceremony
		if (!keys.length) return regexp.test(data.path)
		var values = regexp.exec(data.path)
		if (values == null) return false
		for (var i = 0; i < keys.length; i++) {
			data.params[keys[i].k] = keys[i].r ? values[i + 1] : decodeURIComponent(values[i + 1])
		}
		return true
	}
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/parse.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/parse.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var parseQueryString = __webpack_require__(/*! ../querystring/parse */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/parse.js")

// Returns `{path, params}` from `url`
module.exports = function(url) {
	var queryIndex = url.indexOf("?")
	var hashIndex = url.indexOf("#")
	var queryEnd = hashIndex < 0 ? url.length : hashIndex
	var pathEnd = queryIndex < 0 ? queryEnd : queryIndex
	var path = url.slice(0, pathEnd).replace(/\/{2,}/g, "/")

	if (!path) path = "/"
	else {
		if (path[0] !== "/") path = "/" + path
		if (path.length > 1 && path[path.length - 1] === "/") path = path.slice(0, -1)
	}
	return {
		path: path,
		params: queryIndex < 0
			? {}
			: parseQueryString(url.slice(queryIndex + 1, queryEnd)),
	}
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/polyfill.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/polyfill.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {
/** @constructor */
var PromisePolyfill = function(executor) {
	if (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`")
	if (typeof executor !== "function") throw new TypeError("executor must be a function")

	var self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)
	var instance = self._instance = {resolvers: resolvers, rejectors: rejectors}
	var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout
	function handler(list, shouldAbsorb) {
		return function execute(value) {
			var then
			try {
				if (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
					if (value === self) throw new TypeError("Promise can't be resolved w/ itself")
					executeOnce(then.bind(value))
				}
				else {
					callAsync(function() {
						if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value)
						for (var i = 0; i < list.length; i++) list[i](value)
						resolvers.length = 0, rejectors.length = 0
						instance.state = shouldAbsorb
						instance.retry = function() {execute(value)}
					})
				}
			}
			catch (e) {
				rejectCurrent(e)
			}
		}
	}
	function executeOnce(then) {
		var runs = 0
		function run(fn) {
			return function(value) {
				if (runs++ > 0) return
				fn(value)
			}
		}
		var onerror = run(rejectCurrent)
		try {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}
	}

	executeOnce(executor)
}
PromisePolyfill.prototype.then = function(onFulfilled, onRejection) {
	var self = this, instance = self._instance
	function handle(callback, list, next, state) {
		list.push(function(value) {
			if (typeof callback !== "function") next(value)
			else try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}
		})
		if (typeof instance.retry === "function" && state === instance.state) instance.retry()
	}
	var resolveNext, rejectNext
	var promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})
	handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)
	return promise
}
PromisePolyfill.prototype.catch = function(onRejection) {
	return this.then(null, onRejection)
}
PromisePolyfill.prototype.finally = function(callback) {
	return this.then(
		function(value) {
			return PromisePolyfill.resolve(callback()).then(function() {
				return value
			})
		},
		function(reason) {
			return PromisePolyfill.resolve(callback()).then(function() {
				return PromisePolyfill.reject(reason);
			})
		}
	)
}
PromisePolyfill.resolve = function(value) {
	if (value instanceof PromisePolyfill) return value
	return new PromisePolyfill(function(resolve) {resolve(value)})
}
PromisePolyfill.reject = function(value) {
	return new PromisePolyfill(function(resolve, reject) {reject(value)})
}
PromisePolyfill.all = function(list) {
	return new PromisePolyfill(function(resolve, reject) {
		var total = list.length, count = 0, values = []
		if (list.length === 0) resolve([])
		else for (var i = 0; i < list.length; i++) {
			(function(i) {
				function consume(value) {
					count++
					values[i] = value
					if (count === total) resolve(values)
				}
				if (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
					list[i].then(consume, reject)
				}
				else consume(list[i])
			})(i)
		}
	})
}
PromisePolyfill.race = function(list) {
	return new PromisePolyfill(function(resolve, reject) {
		for (var i = 0; i < list.length; i++) {
			list[i].then(resolve, reject)
		}
	})
}

module.exports = PromisePolyfill

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../timers-browserify/2.0.10/node_modules/timers-browserify/main.js */ "./node_modules/.registry.npmjs.org/timers-browserify/2.0.10/node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/promise.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/promise.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var PromisePolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/polyfill.js")

if (typeof window !== "undefined") {
	if (typeof window.Promise === "undefined") {
		window.Promise = PromisePolyfill
	} else if (!window.Promise.prototype.finally) {
		window.Promise.prototype.finally = PromisePolyfill.prototype.finally
	}
	module.exports = window.Promise
} else if (typeof global !== "undefined") {
	if (typeof global.Promise === "undefined") {
		global.Promise = PromisePolyfill
	} else if (!global.Promise.prototype.finally) {
		global.Promise.prototype.finally = PromisePolyfill.prototype.finally
	}
	module.exports = global.Promise
} else {
	module.exports = PromisePolyfill
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/4.35.3_webpack@4.35.3/node_modules/webpack/buildin/global.js */ "./node_modules/.registry.npmjs.org/webpack/4.35.3_webpack@4.35.3/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/build.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/build.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function(object) {
	if (Object.prototype.toString.call(object) !== "[object Object]") return ""

	var args = []
	for (var key in object) {
		destructure(key, object[key])
	}

	return args.join("&")

	function destructure(key, value) {
		if (Array.isArray(value)) {
			for (var i = 0; i < value.length; i++) {
				destructure(key + "[" + i + "]", value[i])
			}
		}
		else if (Object.prototype.toString.call(value) === "[object Object]") {
			for (var i in value) {
				destructure(key + "[" + i + "]", value[i])
			}
		}
		else args.push(encodeURIComponent(key) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""))
	}
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/parse.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/querystring/parse.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// The extra `data` parameter is for if you want to append to an existing
// parameters object.
module.exports = function(string) {
	if (string === "" || string == null) return {}
	if (string.charAt(0) === "?") string = string.slice(1)

	var entries = string.split("&"), counters = {}, data = {}
	for (var i = 0; i < entries.length; i++) {
		var entry = entries[i].split("=")
		var key = decodeURIComponent(entry[0])
		var value = entry.length === 2 ? decodeURIComponent(entry[1]) : ""

		if (value === "true") value = true
		else if (value === "false") value = false

		var levels = key.split(/\]\[?|\[/)
		var cursor = data
		if (key.indexOf("[") > -1) levels.pop()
		for (var j = 0; j < levels.length; j++) {
			var level = levels[j], nextLevel = levels[j + 1]
			var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10))
			var isValue = j === levels.length - 1
			if (level === "") {
				var key = levels.slice(0, j).join()
				if (counters[key] == null) {
					counters[key] = Array.isArray(cursor) ? cursor.length : 0
				}
				level = counters[key]++
			}
			if (isValue) cursor[level] = value
			else if (cursor[level] == null) cursor[level] = isNumber ? [] : {}
			cursor = cursor[level]
		}
	}
	return data
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/redraw.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/redraw.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./api/redraw */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/redraw.js")(window)


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./render/render */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/render.js")(window)


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/fragment.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/fragment.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Vnode = __webpack_require__(/*! ../render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")
var hyperscriptVnode = __webpack_require__(/*! ./hyperscriptVnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/hyperscriptVnode.js")

module.exports = function() {
	var vnode = hyperscriptVnode.apply(0, arguments)

	vnode.tag = "["
	vnode.children = Vnode.normalizeChildren(vnode.children)
	return vnode
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/hyperscript.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/hyperscript.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Vnode = __webpack_require__(/*! ../render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")
var hyperscriptVnode = __webpack_require__(/*! ./hyperscriptVnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/hyperscriptVnode.js")

var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g
var selectorCache = {}
var hasOwn = {}.hasOwnProperty

function isEmpty(object) {
	for (var key in object) if (hasOwn.call(object, key)) return false
	return true
}

function compileSelector(selector) {
	var match, tag = "div", classes = [], attrs = {}
	while (match = selectorParser.exec(selector)) {
		var type = match[1], value = match[2]
		if (type === "" && value !== "") tag = value
		else if (type === "#") attrs.id = value
		else if (type === ".") classes.push(value)
		else if (match[3][0] === "[") {
			var attrValue = match[6]
			if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\")
			if (match[4] === "class") classes.push(attrValue)
			else attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true
		}
	}
	if (classes.length > 0) attrs.className = classes.join(" ")
	return selectorCache[selector] = {tag: tag, attrs: attrs}
}

function execSelector(state, vnode) {
	var attrs = vnode.attrs
	var children = Vnode.normalizeChildren(vnode.children)
	var hasClass = hasOwn.call(attrs, "class")
	var className = hasClass ? attrs.class : attrs.className

	vnode.tag = state.tag
	vnode.attrs = null
	vnode.children = undefined

	if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
		var newAttrs = {}

		for (var key in attrs) {
			if (hasOwn.call(attrs, key)) newAttrs[key] = attrs[key]
		}

		attrs = newAttrs
	}

	for (var key in state.attrs) {
		if (hasOwn.call(state.attrs, key) && key !== "className" && !hasOwn.call(attrs, key)){
			attrs[key] = state.attrs[key]
		}
	}
	if (className != null || state.attrs.className != null) attrs.className =
		className != null
			? state.attrs.className != null
				? String(state.attrs.className) + " " + String(className)
				: className
			: state.attrs.className != null
				? state.attrs.className
				: null

	if (hasClass) attrs.class = null

	for (var key in attrs) {
		if (hasOwn.call(attrs, key) && key !== "key") {
			vnode.attrs = attrs
			break
		}
	}

	if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
		vnode.text = children[0].children
	} else {
		vnode.children = children
	}

	return vnode
}

function hyperscript(selector) {
	if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
		throw Error("The selector must be either a string or a component.");
	}

	var vnode = hyperscriptVnode.apply(1, arguments)

	if (typeof selector === "string") {
		vnode.children = Vnode.normalizeChildren(vnode.children)
		if (selector !== "[") return execSelector(selectorCache[selector] || compileSelector(selector), vnode)
	}

	vnode.tag = selector
	return vnode
}

module.exports = hyperscript


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/hyperscriptVnode.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/hyperscriptVnode.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Vnode = __webpack_require__(/*! ../render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")

// Call via `hyperscriptVnode.apply(startOffset, arguments)`
//
// The reason I do it this way, forwarding the arguments and passing the start
// offset in `this`, is so I don't have to create a temporary array in a
// performance-critical path.
//
// In native ES6, I'd instead add a final `...args` parameter to the
// `hyperscript` and `fragment` factories and define this as
// `hyperscriptVnode(...args)`, since modern engines do optimize that away. But
// ES5 (what Mithril requires thanks to IE support) doesn't give me that luxury,
// and engines aren't nearly intelligent enough to do either of these:
//
// 1. Elide the allocation for `[].slice.call(arguments, 1)` when it's passed to
//    another function only to be indexed.
// 2. Elide an `arguments` allocation when it's passed to any function other
//    than `Function.prototype.apply` or `Reflect.apply`.
//
// In ES6, it'd probably look closer to this (I'd need to profile it, though):
// module.exports = function(attrs, ...children) {
//     if (attrs == null || typeof attrs === "object" && attrs.tag == null && !Array.isArray(attrs)) {
//         if (children.length === 1 && Array.isArray(children[0])) children = children[0]
//     } else {
//         children = children.length === 0 && Array.isArray(attrs) ? attrs : [attrs, ...children]
//         attrs = undefined
//     }
//
//     if (attrs == null) attrs = {}
//     return Vnode("", attrs.key, attrs, children)
// }
module.exports = function() {
	var attrs = arguments[this], start = this + 1, children

	if (attrs == null) {
		attrs = {}
	} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
		attrs = {}
		start = this
	}

	if (arguments.length === start + 1) {
		children = arguments[start]
		if (!Array.isArray(children)) children = [children]
	} else {
		children = []
		while (start < arguments.length) children.push(arguments[start++])
	}

	return Vnode("", attrs.key, attrs, children)
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/render.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/render.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Vnode = __webpack_require__(/*! ../render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")

module.exports = function($window) {
	var $doc = $window.document

	var nameSpace = {
		svg: "http://www.w3.org/2000/svg",
		math: "http://www.w3.org/1998/Math/MathML"
	}

	var redraw
	function setRedraw(callback) {return redraw = callback}

	function getNameSpace(vnode) {
		return vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]
	}

	//sanity check to discourage people from doing `vnode.state = ...`
	function checkState(vnode, original) {
		if (vnode.state !== original) throw new Error("`vnode.state` must not be modified")
	}

	//Note: the hook is passed as the `this` argument to allow proxying the
	//arguments without requiring a full array allocation to do so. It also
	//takes advantage of the fact the current `vnode` is the first argument in
	//all lifecycle methods.
	function callHook(vnode) {
		var original = vnode.state
		try {
			return this.apply(original, arguments)
		} finally {
			checkState(vnode, original)
		}
	}

	// IE11 (at least) throws an UnspecifiedError when accessing document.activeElement when
	// inside an iframe. Catch and swallow this error, and heavy-handidly return null.
	function activeElement() {
		try {
			return $doc.activeElement
		} catch (e) {
			return null
		}
	}
	function validateKeys(vnodes, isKeyed) {
		// Note: this is a *very* perf-sensitive check.
		// Fun fact: merging the loop like this is somehow faster than splitting
		// it, noticeably so.
		for (var i = 1; i < vnodes.length; i++) {
			if ((vnodes[i] != null && vnodes[i].key != null) !== isKeyed) {
				throw new TypeError("Vnodes must either always have keys or never have keys!")
			}
		}
	}
	//create
	function createNodesChecked(parent, vnodes, hooks, nextSibling, ns) {
		if (vnodes.length) {
			validateKeys(vnodes, vnodes[0] != null && vnodes[0].key != null)
			createNodesUnchecked(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)
		}
	}
	function createNodesUnchecked(parent, vnodes, start, end, hooks, nextSibling, ns) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				createNode(parent, vnode, hooks, ns, nextSibling)
			}
		}
	}
	function createNode(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		if (typeof tag === "string") {
			vnode.state = {}
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
			switch (tag) {
				case "#": createText(parent, vnode, nextSibling); break
				case "<": createHTML(parent, vnode, ns, nextSibling); break
				case "[": createFragment(parent, vnode, hooks, ns, nextSibling); break
				default: createElement(parent, vnode, hooks, ns, nextSibling)
			}
		}
		else createComponent(parent, vnode, hooks, ns, nextSibling)
	}
	function createText(parent, vnode, nextSibling) {
		vnode.dom = $doc.createTextNode(vnode.children)
		insertNode(parent, vnode.dom, nextSibling)
	}
	var possibleParents = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}
	function createHTML(parent, vnode, ns, nextSibling) {
		var match = vnode.children.match(/^\s*?<(\w+)/im) || []
		// not using the proper parent makes the child element(s) vanish.
		//     var div = document.createElement("div")
		//     div.innerHTML = "<td>i</td><td>j</td>"
		//     console.log(div.innerHTML)
		// --> "ij", no <td> in sight.
		var temp = $doc.createElement(possibleParents[match[1]] || "div")
		if (ns === "http://www.w3.org/2000/svg") {
			temp.innerHTML = "<svg xmlns=\"http://www.w3.org/2000/svg\">" + vnode.children + "</svg>"
			temp = temp.firstChild
		} else {
			temp.innerHTML = vnode.children
		}
		vnode.dom = temp.firstChild
		vnode.domSize = temp.childNodes.length
		var fragment = $doc.createDocumentFragment()
		var child
		while (child = temp.firstChild) {
			fragment.appendChild(child)
		}
		insertNode(parent, fragment, nextSibling)
	}
	function createFragment(parent, vnode, hooks, ns, nextSibling) {
		var fragment = $doc.createDocumentFragment()
		if (vnode.children != null) {
			var children = vnode.children
			createNodesChecked(fragment, children, hooks, null, ns)
		}
		vnode.dom = fragment.firstChild
		vnode.domSize = fragment.childNodes.length
		insertNode(parent, fragment, nextSibling)
	}
	function createElement(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		var attrs = vnode.attrs
		var is = attrs && attrs.is

		ns = getNameSpace(vnode) || ns

		var element = ns ?
			is ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :
			is ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)
		vnode.dom = element

		if (attrs != null) {
			setAttrs(vnode, attrs, ns)
		}

		insertNode(parent, element, nextSibling)

		if (!maybeSetContentEditable(vnode)) {
			if (vnode.text != null) {
				if (vnode.text !== "") element.textContent = vnode.text
				else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			}
			if (vnode.children != null) {
				var children = vnode.children
				createNodesChecked(element, children, hooks, null, ns)
				if (vnode.tag === "select" && attrs != null) setLateSelectAttrs(vnode, attrs)
			}
		}
	}
	function initComponent(vnode, hooks) {
		var sentinel
		if (typeof vnode.tag.view === "function") {
			vnode.state = Object.create(vnode.tag)
			sentinel = vnode.state.view
			if (sentinel.$$reentrantLock$$ != null) return
			sentinel.$$reentrantLock$$ = true
		} else {
			vnode.state = void 0
			sentinel = vnode.tag
			if (sentinel.$$reentrantLock$$ != null) return
			sentinel.$$reentrantLock$$ = true
			vnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)
		}
		initLifecycle(vnode.state, vnode, hooks)
		if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
		vnode.instance = Vnode.normalize(callHook.call(vnode.state.view, vnode))
		if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
		sentinel.$$reentrantLock$$ = null
	}
	function createComponent(parent, vnode, hooks, ns, nextSibling) {
		initComponent(vnode, hooks)
		if (vnode.instance != null) {
			createNode(parent, vnode.instance, hooks, ns, nextSibling)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0
		}
		else {
			vnode.domSize = 0
		}
	}

	//update
	/**
	 * @param {Element|Fragment} parent - the parent element
	 * @param {Vnode[] | null} old - the list of vnodes of the last `render()` call for
	 *                               this part of the tree
	 * @param {Vnode[] | null} vnodes - as above, but for the current `render()` call.
	 * @param {Function[]} hooks - an accumulator of post-render hooks (oncreate/onupdate)
	 * @param {Element | null} nextSibling - the next DOM node if we're dealing with a
	 *                                       fragment that is not the last item in its
	 *                                       parent
	 * @param {'svg' | 'math' | String | null} ns) - the current XML namespace, if any
	 * @returns void
	 */
	// This function diffs and patches lists of vnodes, both keyed and unkeyed.
	//
	// We will:
	//
	// 1. describe its general structure
	// 2. focus on the diff algorithm optimizations
	// 3. discuss DOM node operations.

	// ## Overview:
	//
	// The updateNodes() function:
	// - deals with trivial cases
	// - determines whether the lists are keyed or unkeyed based on the first non-null node
	//   of each list.
	// - diffs them and patches the DOM if needed (that's the brunt of the code)
	// - manages the leftovers: after diffing, are there:
	//   - old nodes left to remove?
	// 	 - new nodes to insert?
	// 	 deal with them!
	//
	// The lists are only iterated over once, with an exception for the nodes in `old` that
	// are visited in the fourth part of the diff and in the `removeNodes` loop.

	// ## Diffing
	//
	// Reading https://github.com/localvoid/ivi/blob/ddc09d06abaef45248e6133f7040d00d3c6be853/packages/ivi/src/vdom/implementation.ts#L617-L837
	// may be good for context on longest increasing subsequence-based logic for moving nodes.
	//
	// In order to diff keyed lists, one has to
	//
	// 1) match nodes in both lists, per key, and update them accordingly
	// 2) create the nodes present in the new list, but absent in the old one
	// 3) remove the nodes present in the old list, but absent in the new one
	// 4) figure out what nodes in 1) to move in order to minimize the DOM operations.
	//
	// To achieve 1) one can create a dictionary of keys => index (for the old list), then iterate
	// over the new list and for each new vnode, find the corresponding vnode in the old list using
	// the map.
	// 2) is achieved in the same step: if a new node has no corresponding entry in the map, it is new
	// and must be created.
	// For the removals, we actually remove the nodes that have been updated from the old list.
	// The nodes that remain in that list after 1) and 2) have been performed can be safely removed.
	// The fourth step is a bit more complex and relies on the longest increasing subsequence (LIS)
	// algorithm.
	//
	// the longest increasing subsequence is the list of nodes that can remain in place. Imagine going
	// from `1,2,3,4,5` to `4,5,1,2,3` where the numbers are not necessarily the keys, but the indices
	// corresponding to the keyed nodes in the old list (keyed nodes `e,d,c,b,a` => `b,a,e,d,c` would
	//  match the above lists, for example).
	//
	// In there are two increasing subsequences: `4,5` and `1,2,3`, the latter being the longest. We
	// can update those nodes without moving them, and only call `insertNode` on `4` and `5`.
	//
	// @localvoid adapted the algo to also support node deletions and insertions (the `lis` is actually
	// the longest increasing subsequence *of old nodes still present in the new list*).
	//
	// It is a general algorithm that is fireproof in all circumstances, but it requires the allocation
	// and the construction of a `key => oldIndex` map, and three arrays (one with `newIndex => oldIndex`,
	// the `LIS` and a temporary one to create the LIS).
	//
	// So we cheat where we can: if the tails of the lists are identical, they are guaranteed to be part of
	// the LIS and can be updated without moving them.
	//
	// If two nodes are swapped, they are guaranteed not to be part of the LIS, and must be moved (with
	// the exception of the last node if the list is fully reversed).
	//
	// ## Finding the next sibling.
	//
	// `updateNode()` and `createNode()` expect a nextSibling parameter to perform DOM operations.
	// When the list is being traversed top-down, at any index, the DOM nodes up to the previous
	// vnode reflect the content of the new list, whereas the rest of the DOM nodes reflect the old
	// list. The next sibling must be looked for in the old list using `getNextSibling(... oldStart + 1 ...)`.
	//
	// In the other scenarios (swaps, upwards traversal, map-based diff),
	// the new vnodes list is traversed upwards. The DOM nodes at the bottom of the list reflect the
	// bottom part of the new vnodes list, and we can use the `v.dom`  value of the previous node
	// as the next sibling (cached in the `nextSibling` variable).


	// ## DOM node moves
	//
	// In most scenarios `updateNode()` and `createNode()` perform the DOM operations. However,
	// this is not the case if the node moved (second and fourth part of the diff algo). We move
	// the old DOM nodes before updateNode runs because it enables us to use the cached `nextSibling`
	// variable rather than fetching it using `getNextSibling()`.
	//
	// The fourth part of the diff currently inserts nodes unconditionally, leading to issues
	// like #1791 and #1999. We need to be smarter about those situations where adjascent old
	// nodes remain together in the new list in a way that isn't covered by parts one and
	// three of the diff algo.

	function updateNodes(parent, old, vnodes, hooks, nextSibling, ns) {
		if (old === vnodes || old == null && vnodes == null) return
		else if (old == null || old.length === 0) createNodesChecked(parent, vnodes, hooks, nextSibling, ns)
		else if (vnodes == null || vnodes.length === 0) removeNodes(old, 0, old.length)
		else {
			var isOldKeyed = old[0] != null && old[0].key != null
			var isKeyed = vnodes[0] != null && vnodes[0].key != null
			var start = 0, oldStart = 0
			validateKeys(vnodes, isKeyed)
			if (!isOldKeyed) while (oldStart < old.length && old[oldStart] == null) oldStart++
			if (!isKeyed) while (start < vnodes.length && vnodes[start] == null) start++
			if (isKeyed === null && isOldKeyed == null) return // both lists are full of nulls
			if (isOldKeyed !== isKeyed) {
				removeNodes(old, oldStart, old.length)
				createNodesUnchecked(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns)
			} else if (!isKeyed) {
				// Don't index past the end of either list (causes deopts).
				var commonLength = old.length < vnodes.length ? old.length : vnodes.length
				// Rewind if necessary to the first non-null index on either side.
				// We could alternatively either explicitly create or remove nodes when `start !== oldStart`
				// but that would be optimizing for sparse lists which are more rare than dense ones.
				start = start < oldStart ? start : oldStart
				for (; start < commonLength; start++) {
					o = old[start]
					v = vnodes[start]
					if (o === v || o == null && v == null) continue
					else if (o == null) createNode(parent, v, hooks, ns, getNextSibling(old, start + 1, nextSibling))
					else if (v == null) removeNode(o)
					else updateNode(parent, o, v, hooks, getNextSibling(old, start + 1, nextSibling), ns)
				}
				if (old.length > commonLength) removeNodes(old, start, old.length)
				if (vnodes.length > commonLength) createNodesUnchecked(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns)
			} else {
				// keyed diff
				var oldEnd = old.length - 1, end = vnodes.length - 1, map, o, v, oe, ve, topSibling

				// bottom-up
				while (oldEnd >= oldStart && end >= start) {
					oe = old[oldEnd]
					ve = vnodes[end]
					if (oe.key !== ve.key) break
					if (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)
					if (ve.dom != null) nextSibling = ve.dom
					oldEnd--, end--
				}
				// top-down
				while (oldEnd >= oldStart && end >= start) {
					o = old[oldStart]
					v = vnodes[start]
					if (o.key !== v.key) break
					oldStart++, start++
					if (o !== v) updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), ns)
				}
				// swaps and list reversals
				while (oldEnd >= oldStart && end >= start) {
					if (start === end) break
					if (o.key !== ve.key || oe.key !== v.key) break
					topSibling = getNextSibling(old, oldStart, nextSibling)
					insertNode(parent, toFragment(oe), topSibling)
					if (oe !== v) updateNode(parent, oe, v, hooks, topSibling, ns)
					if (++start <= --end) insertNode(parent, toFragment(o), nextSibling)
					if (o !== ve) updateNode(parent, o, ve, hooks, nextSibling, ns)
					if (ve.dom != null) nextSibling = ve.dom
					oldStart++; oldEnd--
					oe = old[oldEnd]
					ve = vnodes[end]
					o = old[oldStart]
					v = vnodes[start]
				}
				// bottom up once again
				while (oldEnd >= oldStart && end >= start) {
					if (oe.key !== ve.key) break
					if (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)
					if (ve.dom != null) nextSibling = ve.dom
					oldEnd--, end--
					oe = old[oldEnd]
					ve = vnodes[end]
				}
				if (start > end) removeNodes(old, oldStart, oldEnd + 1)
				else if (oldStart > oldEnd) createNodesUnchecked(parent, vnodes, start, end + 1, hooks, nextSibling, ns)
				else {
					// inspired by ivi https://github.com/ivijs/ivi/ by Boris Kaul
					var originalNextSibling = nextSibling, vnodesLength = end - start + 1, oldIndices = new Array(vnodesLength), li=0, i=0, pos = 2147483647, matched = 0, map, lisIndices
					for (i = 0; i < vnodesLength; i++) oldIndices[i] = -1
					for (i = end; i >= start; i--) {
						if (map == null) map = getKeyMap(old, oldStart, oldEnd + 1)
						ve = vnodes[i]
						var oldIndex = map[ve.key]
						if (oldIndex != null) {
							pos = (oldIndex < pos) ? oldIndex : -1 // becomes -1 if nodes were re-ordered
							oldIndices[i-start] = oldIndex
							oe = old[oldIndex]
							old[oldIndex] = null
							if (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)
							if (ve.dom != null) nextSibling = ve.dom
							matched++
						}
					}
					nextSibling = originalNextSibling
					if (matched !== oldEnd - oldStart + 1) removeNodes(old, oldStart, oldEnd + 1)
					if (matched === 0) createNodesUnchecked(parent, vnodes, start, end + 1, hooks, nextSibling, ns)
					else {
						if (pos === -1) {
							// the indices of the indices of the items that are part of the
							// longest increasing subsequence in the oldIndices list
							lisIndices = makeLisIndices(oldIndices)
							li = lisIndices.length - 1
							for (i = end; i >= start; i--) {
								v = vnodes[i]
								if (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling)
								else {
									if (lisIndices[li] === i - start) li--
									else insertNode(parent, toFragment(v), nextSibling)
								}
								if (v.dom != null) nextSibling = vnodes[i].dom
							}
						} else {
							for (i = end; i >= start; i--) {
								v = vnodes[i]
								if (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling)
								if (v.dom != null) nextSibling = vnodes[i].dom
							}
						}
					}
				}
			}
		}
	}
	function updateNode(parent, old, vnode, hooks, nextSibling, ns) {
		var oldTag = old.tag, tag = vnode.tag
		if (oldTag === tag) {
			vnode.state = old.state
			vnode.events = old.events
			if (shouldNotUpdate(vnode, old)) return
			if (typeof oldTag === "string") {
				if (vnode.attrs != null) {
					updateLifecycle(vnode.attrs, vnode, hooks)
				}
				switch (oldTag) {
					case "#": updateText(old, vnode); break
					case "<": updateHTML(parent, old, vnode, ns, nextSibling); break
					case "[": updateFragment(parent, old, vnode, hooks, nextSibling, ns); break
					default: updateElement(old, vnode, hooks, ns)
				}
			}
			else updateComponent(parent, old, vnode, hooks, nextSibling, ns)
		}
		else {
			removeNode(old)
			createNode(parent, vnode, hooks, ns, nextSibling)
		}
	}
	function updateText(old, vnode) {
		if (old.children.toString() !== vnode.children.toString()) {
			old.dom.nodeValue = vnode.children
		}
		vnode.dom = old.dom
	}
	function updateHTML(parent, old, vnode, ns, nextSibling) {
		if (old.children !== vnode.children) {
			toFragment(old)
			createHTML(parent, vnode, ns, nextSibling)
		}
		else vnode.dom = old.dom, vnode.domSize = old.domSize
	}
	function updateFragment(parent, old, vnode, hooks, nextSibling, ns) {
		updateNodes(parent, old.children, vnode.children, hooks, nextSibling, ns)
		var domSize = 0, children = vnode.children
		vnode.dom = null
		if (children != null) {
			for (var i = 0; i < children.length; i++) {
				var child = children[i]
				if (child != null && child.dom != null) {
					if (vnode.dom == null) vnode.dom = child.dom
					domSize += child.domSize || 1
				}
			}
			if (domSize !== 1) vnode.domSize = domSize
		}
	}
	function updateElement(old, vnode, hooks, ns) {
		var element = vnode.dom = old.dom
		ns = getNameSpace(vnode) || ns

		if (vnode.tag === "textarea") {
			if (vnode.attrs == null) vnode.attrs = {}
			if (vnode.text != null) {
				vnode.attrs.value = vnode.text //FIXME handle multiple children
				vnode.text = undefined
			}
		}
		updateAttrs(vnode, old.attrs, vnode.attrs, ns)
		if (!maybeSetContentEditable(vnode)) {
			if (old.text != null && vnode.text != null && vnode.text !== "") {
				if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text
			}
			else {
				if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]
				if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
				updateNodes(element, old.children, vnode.children, hooks, null, ns)
			}
		}
	}
	function updateComponent(parent, old, vnode, hooks, nextSibling, ns) {
		vnode.instance = Vnode.normalize(callHook.call(vnode.state.view, vnode))
		if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
		updateLifecycle(vnode.state, vnode, hooks)
		if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)
		if (vnode.instance != null) {
			if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)
			else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, ns)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.instance.domSize
		}
		else if (old.instance != null) {
			removeNode(old.instance)
			vnode.dom = undefined
			vnode.domSize = 0
		}
		else {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
		}
	}
	function getKeyMap(vnodes, start, end) {
		var map = Object.create(null)
		for (; start < end; start++) {
			var vnode = vnodes[start]
			if (vnode != null) {
				var key = vnode.key
				if (key != null) map[key] = start
			}
		}
		return map
	}
	// Lifted from ivi https://github.com/ivijs/ivi/
	// takes a list of unique numbers (-1 is special and can
	// occur multiple times) and returns an array with the indices
	// of the items that are part of the longest increasing
	// subsequece
	var lisTemp = []
	function makeLisIndices(a) {
		var result = [0]
		var u = 0, v = 0, i = 0
		var il = lisTemp.length = a.length
		for (var i = 0; i < il; i++) lisTemp[i] = a[i]
		for (var i = 0; i < il; ++i) {
			if (a[i] === -1) continue
			var j = result[result.length - 1]
			if (a[j] < a[i]) {
				lisTemp[i] = j
				result.push(i)
				continue
			}
			u = 0
			v = result.length - 1
			while (u < v) {
				// Fast integer average without overflow.
				// eslint-disable-next-line no-bitwise
				var c = (u >>> 1) + (v >>> 1) + (u & v & 1)
				if (a[result[c]] < a[i]) {
					u = c + 1
				}
				else {
					v = c
				}
			}
			if (a[i] < a[result[u]]) {
				if (u > 0) lisTemp[i] = result[u - 1]
				result[u] = i
			}
		}
		u = result.length
		v = result[u - 1]
		while (u-- > 0) {
			result[u] = v
			v = lisTemp[v]
		}
		lisTemp.length = 0
		return result
	}

	function toFragment(vnode) {
		var count = vnode.domSize
		if (count != null || vnode.dom == null) {
			var fragment = $doc.createDocumentFragment()
			if (count > 0) {
				var dom = vnode.dom
				while (--count) fragment.appendChild(dom.nextSibling)
				fragment.insertBefore(dom, fragment.firstChild)
			}
			return fragment
		}
		else return vnode.dom
	}
	function getNextSibling(vnodes, i, nextSibling) {
		for (; i < vnodes.length; i++) {
			if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom
		}
		return nextSibling
	}

	function insertNode(parent, dom, nextSibling) {
		if (nextSibling != null) parent.insertBefore(dom, nextSibling)
		else parent.appendChild(dom)
	}

	function maybeSetContentEditable(vnode) {
		if (vnode.attrs == null || (
			vnode.attrs.contenteditable == null && // attribute
			vnode.attrs.contentEditable == null // property
		)) return
		var children = vnode.children
		if (children != null && children.length === 1 && children[0].tag === "<") {
			var content = children[0].children
			if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content
		}
		else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")
	}

	//remove
	function removeNodes(vnodes, start, end) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) removeNode(vnode)
		}
	}
	function removeNode(vnode) {
		var expected = 1, called = 0
		var original = vnode.state
		if (typeof vnode.tag !== "string" && typeof vnode.state.onbeforeremove === "function") {
			var result = callHook.call(vnode.state.onbeforeremove, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
			var result = callHook.call(vnode.attrs.onbeforeremove, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		continuation()
		function continuation() {
			if (++called === expected) {
				checkState(vnode, original)
				onremove(vnode)
				if (vnode.dom) {
					var parent = vnode.dom.parentNode
					var count = vnode.domSize || 1
					while (--count) parent.removeChild(vnode.dom.nextSibling)
					parent.removeChild(vnode.dom)
				}
			}
		}
	}
	function onremove(vnode) {
		if (typeof vnode.tag !== "string" && typeof vnode.state.onremove === "function") callHook.call(vnode.state.onremove, vnode)
		if (vnode.attrs && typeof vnode.attrs.onremove === "function") callHook.call(vnode.attrs.onremove, vnode)
		if (typeof vnode.tag !== "string") {
			if (vnode.instance != null) onremove(vnode.instance)
		} else {
			var children = vnode.children
			if (Array.isArray(children)) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i]
					if (child != null) onremove(child)
				}
			}
		}
	}

	//attrs
	function setAttrs(vnode, attrs, ns) {
		for (var key in attrs) {
			setAttr(vnode, key, null, attrs[key], ns)
		}
	}
	function setAttr(vnode, key, old, value, ns) {
		if (key === "key" || key === "is" || value == null || isLifecycleMethod(key) || (old === value && !isFormAttribute(vnode, key)) && typeof value !== "object") return
		if (key[0] === "o" && key[1] === "n") return updateEvent(vnode, key, value)
		if (key.slice(0, 6) === "xlink:") vnode.dom.setAttributeNS("http://www.w3.org/1999/xlink", key.slice(6), value)
		else if (key === "style") updateStyle(vnode.dom, old, value)
		else if (hasPropertyKey(vnode, key, ns)) {
			if (key === "value") {
				// Only do the coercion if we're actually going to check the value.
				/* eslint-disable no-implicit-coercion */
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === "" + value && vnode.dom === activeElement()) return
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select" && old !== null && vnode.dom.value === "" + value) return
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && old !== null && vnode.dom.value === "" + value) return
				/* eslint-enable no-implicit-coercion */
			}
			// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.
			if (vnode.tag === "input" && key === "type") vnode.dom.setAttribute(key, value)
			else vnode.dom[key] = value
		} else {
			if (typeof value === "boolean") {
				if (value) vnode.dom.setAttribute(key, "")
				else vnode.dom.removeAttribute(key)
			}
			else vnode.dom.setAttribute(key === "className" ? "class" : key, value)
		}
	}
	function removeAttr(vnode, key, old, ns) {
		if (key === "key" || key === "is" || old == null || isLifecycleMethod(key)) return
		if (key[0] === "o" && key[1] === "n" && !isLifecycleMethod(key)) updateEvent(vnode, key, undefined)
		else if (key === "style") updateStyle(vnode.dom, old, null)
		else if (
			hasPropertyKey(vnode, key, ns)
			&& key !== "className"
			&& !(key === "value" && (
				vnode.tag === "option"
				|| vnode.tag === "select" && vnode.dom.selectedIndex === -1 && vnode.dom === activeElement()
			))
			&& !(vnode.tag === "input" && key === "type")
		) {
			vnode.dom[key] = null
		} else {
			var nsLastIndex = key.indexOf(":")
			if (nsLastIndex !== -1) key = key.slice(nsLastIndex + 1)
			if (old !== false) vnode.dom.removeAttribute(key === "className" ? "class" : key)
		}
	}
	function setLateSelectAttrs(vnode, attrs) {
		if ("value" in attrs) {
			if(attrs.value === null) {
				if (vnode.dom.selectedIndex !== -1) vnode.dom.value = null
			} else {
				var normalized = "" + attrs.value // eslint-disable-line no-implicit-coercion
				if (vnode.dom.value !== normalized || vnode.dom.selectedIndex === -1) {
					vnode.dom.value = normalized
				}
			}
		}
		if ("selectedIndex" in attrs) setAttr(vnode, "selectedIndex", null, attrs.selectedIndex, undefined)
	}
	function updateAttrs(vnode, old, attrs, ns) {
		if (attrs != null) {
			for (var key in attrs) {
				setAttr(vnode, key, old && old[key], attrs[key], ns)
			}
		}
		var val
		if (old != null) {
			for (var key in old) {
				if (((val = old[key]) != null) && (attrs == null || attrs[key] == null)) {
					removeAttr(vnode, key, val, ns)
				}
			}
		}
	}
	function isFormAttribute(vnode, attr) {
		return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === activeElement() || vnode.tag === "option" && vnode.dom.parentNode === $doc.activeElement
	}
	function isLifecycleMethod(attr) {
		return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
	}
	function hasPropertyKey(vnode, key, ns) {
		// Filter out namespaced keys
		return ns === undefined && (
			// If it's a custom element, just keep it.
			vnode.tag.indexOf("-") > -1 || vnode.attrs != null && vnode.attrs.is ||
			// If it's a normal element, let's try to avoid a few browser bugs.
			key !== "href" && key !== "list" && key !== "form" && key !== "width" && key !== "height"// && key !== "type"
			// Defer the property check until *after* we check everything.
		) && key in vnode.dom
	}

	//style
	var uppercaseRegex = /[A-Z]/g
	function toLowerCase(capital) { return "-" + capital.toLowerCase() }
	function normalizeKey(key) {
		return key[0] === "-" && key[1] === "-" ? key :
			key === "cssFloat" ? "float" :
				key.replace(uppercaseRegex, toLowerCase)
	}
	function updateStyle(element, old, style) {
		if (old === style) {
			// Styles are equivalent, do nothing.
		} else if (style == null) {
			// New style is missing, just clear it.
			element.style.cssText = ""
		} else if (typeof style !== "object") {
			// New style is a string, let engine deal with patching.
			element.style.cssText = style
		} else if (old == null || typeof old !== "object") {
			// `old` is missing or a string, `style` is an object.
			element.style.cssText = ""
			// Add new style properties
			for (var key in style) {
				var value = style[key]
				if (value != null) element.style.setProperty(normalizeKey(key), String(value))
			}
		} else {
			// Both old & new are (different) objects.
			// Update style properties that have changed
			for (var key in style) {
				var value = style[key]
				if (value != null && (value = String(value)) !== String(old[key])) {
					element.style.setProperty(normalizeKey(key), value)
				}
			}
			// Remove style properties that no longer exist
			for (var key in old) {
				if (old[key] != null && style[key] == null) {
					element.style.removeProperty(normalizeKey(key))
				}
			}
		}
	}

	// Here's an explanation of how this works:
	// 1. The event names are always (by design) prefixed by `on`.
	// 2. The EventListener interface accepts either a function or an object
	//    with a `handleEvent` method.
	// 3. The object does not inherit from `Object.prototype`, to avoid
	//    any potential interference with that (e.g. setters).
	// 4. The event name is remapped to the handler before calling it.
	// 5. In function-based event handlers, `ev.target === this`. We replicate
	//    that below.
	// 6. In function-based event handlers, `return false` prevents the default
	//    action and stops event propagation. We replicate that below.
	function EventDict() {}
	EventDict.prototype = Object.create(null)
	EventDict.prototype.handleEvent = function (ev) {
		var handler = this["on" + ev.type]
		var result
		if (typeof handler === "function") result = handler.call(ev.currentTarget, ev)
		else if (typeof handler.handleEvent === "function") handler.handleEvent(ev)
		if (ev.redraw === false) ev.redraw = undefined
		else if (typeof redraw === "function") redraw()
		if (result === false) {
			ev.preventDefault()
			ev.stopPropagation()
		}
	}

	//event
	function updateEvent(vnode, key, value) {
		if (vnode.events != null) {
			if (vnode.events[key] === value) return
			if (value != null && (typeof value === "function" || typeof value === "object")) {
				if (vnode.events[key] == null) vnode.dom.addEventListener(key.slice(2), vnode.events, false)
				vnode.events[key] = value
			} else {
				if (vnode.events[key] != null) vnode.dom.removeEventListener(key.slice(2), vnode.events, false)
				vnode.events[key] = undefined
			}
		} else if (value != null && (typeof value === "function" || typeof value === "object")) {
			vnode.events = new EventDict()
			vnode.dom.addEventListener(key.slice(2), vnode.events, false)
			vnode.events[key] = value
		}
	}

	//lifecycle
	function initLifecycle(source, vnode, hooks) {
		if (typeof source.oninit === "function") callHook.call(source.oninit, vnode)
		if (typeof source.oncreate === "function") hooks.push(callHook.bind(source.oncreate, vnode))
	}
	function updateLifecycle(source, vnode, hooks) {
		if (typeof source.onupdate === "function") hooks.push(callHook.bind(source.onupdate, vnode))
	}
	function shouldNotUpdate(vnode, old) {
		do {
			if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") {
				var force = callHook.call(vnode.attrs.onbeforeupdate, vnode, old)
				if (force !== undefined && !force) break
			}
			if (typeof vnode.tag !== "string" && typeof vnode.state.onbeforeupdate === "function") {
				var force = callHook.call(vnode.state.onbeforeupdate, vnode, old)
				if (force !== undefined && !force) break
			}
			return false
		} while (false); // eslint-disable-line no-constant-condition
		vnode.dom = old.dom
		vnode.domSize = old.domSize
		vnode.instance = old.instance
		// One would think having the actual latest attributes would be ideal,
		// but it doesn't let us properly diff based on our current internal
		// representation. We have to save not only the old DOM info, but also
		// the attributes used to create it, as we diff *that*, not against the
		// DOM directly (with a few exceptions in `setAttr`). And, of course, we
		// need to save the children and text as they are conceptually not
		// unlike special "attributes" internally.
		vnode.attrs = old.attrs
		vnode.children = old.children
		vnode.text = old.text
		return true
	}

	function render(dom, vnodes) {
		if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")
		var hooks = []
		var active = activeElement()
		var namespace = dom.namespaceURI

		// First time rendering into a node clears it out
		if (dom.vnodes == null) dom.textContent = ""

		vnodes = Vnode.normalizeChildren(Array.isArray(vnodes) ? vnodes : [vnodes])
		updateNodes(dom, dom.vnodes, vnodes, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)
		dom.vnodes = vnodes
		// `document.activeElement` can return null: https://html.spec.whatwg.org/multipage/interaction.html#dom-document-activeelement
		if (active != null && activeElement() !== active && typeof active.focus === "function") active.focus()
		for (var i = 0; i < hooks.length; i++) hooks[i]()
	}

	return {render: render, setRedraw: setRedraw}
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/trust.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/trust.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Vnode = __webpack_require__(/*! ../render/vnode */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js")

module.exports = function(html) {
	if (html == null) html = ""
	return Vnode("<", undefined, undefined, html, undefined, undefined)
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/render/vnode.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function Vnode(tag, key, attrs, children, text, dom) {
	return {tag: tag, key: key, attrs: attrs, children: children, text: text, dom: dom, domSize: undefined, state: undefined, events: undefined, instance: undefined}
}
Vnode.normalize = function(node) {
	if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)
	if (node == null || typeof node === "boolean") return null
	if (typeof node === "object") return node
	return Vnode("#", undefined, undefined, String(node), undefined, undefined)
}
Vnode.normalizeChildren = function(input) {
	var children = []
	for (var i = 0; i < input.length; i++) {
		children[i] = Vnode.normalize(input[i])
	}
	return children
}

module.exports = Vnode


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/request.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/request.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var PromisePolyfill = __webpack_require__(/*! ./promise/promise */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/promise/promise.js")
module.exports = __webpack_require__(/*! ./request/request */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/request/request.js")(window, PromisePolyfill)


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/request/request.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/request/request.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var buildPathname = __webpack_require__(/*! ../pathname/build */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/build.js")

module.exports = function($window, Promise) {
	var callbackCount = 0
	var oncompletion

	function PromiseProxy(executor) {
		return new Promise(executor)
	}

	// In case the global Promise is some userland library's where they rely on
	// `foo instanceof this.constructor`, `this.constructor.resolve(value)`, or
	// similar. Let's *not* break them.
	PromiseProxy.prototype = Promise.prototype
	PromiseProxy.__proto__ = Promise // eslint-disable-line no-proto

	function makeRequest(factory) {
		return function(url, args) {
			if (typeof url !== "string") { args = url; url = url.url }
			else if (args == null) args = {}
			var promise = new Promise(function(resolve, reject) {
				factory(buildPathname(url, args.params), args, function (data) {
					if (typeof args.type === "function") {
						if (Array.isArray(data)) {
							for (var i = 0; i < data.length; i++) {
								data[i] = new args.type(data[i])
							}
						}
						else data = new args.type(data)
					}
					resolve(data)
				}, reject)
			})
			if (args.background === true) return promise
			var count = 0
			function complete() {
				if (--count === 0 && typeof oncompletion === "function") oncompletion()
			}

			return wrap(promise)

			function wrap(promise) {
				var then = promise.then
				// Set the constructor, so engines know to not await or resolve
				// this as a native promise. At the time of writing, this is
				// only necessary for V8, but their behavior is the correct
				// behavior per spec. See this spec issue for more details:
				// https://github.com/tc39/ecma262/issues/1577. Also, see the
				// corresponding comment in `request/tests/test-request.js` for
				// a bit more background on the issue at hand.
				promise.constructor = PromiseProxy
				promise.then = function() {
					count++
					var next = then.apply(promise, arguments)
					next.then(complete, function(e) {
						complete()
						if (count === 0) throw e
					})
					return wrap(next)
				}
				return promise
			}
		}
	}

	function hasHeader(args, name) {
		for (var key in args.headers) {
			if ({}.hasOwnProperty.call(args.headers, key) && name.test(key)) return true
		}
		return false
	}

	return {
		request: makeRequest(function(url, args, resolve, reject) {
			var method = args.method != null ? args.method.toUpperCase() : "GET"
			var body = args.body
			var assumeJSON = (args.serialize == null || args.serialize === JSON.serialize) && !(body instanceof $window.FormData)
			var responseType = args.responseType || (typeof args.extract === "function" ? "" : "json")

			var xhr = new $window.XMLHttpRequest(), aborted = false
			var original = xhr, replacedAbort
			var abort = xhr.abort

			xhr.abort = function() {
				aborted = true
				abort.call(this)
			}

			xhr.open(method, url, args.async !== false, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined)

			if (assumeJSON && body != null && !hasHeader(args, /^content-type$/i)) {
				xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")
			}
			if (typeof args.deserialize !== "function" && !hasHeader(args, /^accept$/i)) {
				xhr.setRequestHeader("Accept", "application/json, text/*")
			}
			if (args.withCredentials) xhr.withCredentials = args.withCredentials
			if (args.timeout) xhr.timeout = args.timeout
			xhr.responseType = responseType

			for (var key in args.headers) {
				if ({}.hasOwnProperty.call(args.headers, key)) {
					xhr.setRequestHeader(key, args.headers[key])
				}
			}

			xhr.onreadystatechange = function(ev) {
				// Don't throw errors on xhr.abort().
				if (aborted) return

				if (ev.target.readyState === 4) {
					try {
						var success = (ev.target.status >= 200 && ev.target.status < 300) || ev.target.status === 304 || (/^file:\/\//i).test(url)
						// When the response type isn't "" or "text",
						// `xhr.responseText` is the wrong thing to use.
						// Browsers do the right thing and throw here, and we
						// should honor that and do the right thing by
						// preferring `xhr.response` where possible/practical.
						var response = ev.target.response, message

						if (responseType === "json") {
							// For IE and Edge, which don't implement
							// `responseType: "json"`.
							if (!ev.target.responseType && typeof args.extract !== "function") response = JSON.parse(ev.target.responseText)
						} else if (!responseType || responseType === "text") {
							// Only use this default if it's text. If a parsed
							// document is needed on old IE and friends (all
							// unsupported), the user should use a custom
							// `config` instead. They're already using this at
							// their own risk.
							if (response == null) response = ev.target.responseText
						}

						if (typeof args.extract === "function") {
							response = args.extract(ev.target, args)
							success = true
						} else if (typeof args.deserialize === "function") {
							response = args.deserialize(response)
						}
						if (success) resolve(response)
						else {
							try { message = ev.target.responseText }
							catch (e) { message = response }
							var error = new Error(message)
							error.code = ev.target.status
							error.response = response
							reject(error)
						}
					}
					catch (e) {
						reject(e)
					}
				}
			}

			if (typeof args.config === "function") {
				xhr = args.config(xhr, args, url) || xhr

				// Propagate the `abort` to any replacement XHR as well.
				if (xhr !== original) {
					replacedAbort = xhr.abort
					xhr.abort = function() {
						aborted = true
						replacedAbort.call(this)
					}
				}
			}

			if (body == null) xhr.send()
			else if (typeof args.serialize === "function") xhr.send(args.serialize(body))
			else if (body instanceof $window.FormData) xhr.send(body)
			else xhr.send(JSON.stringify(body))
		}),
		jsonp: makeRequest(function(url, args, resolve, reject) {
			var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++
			var script = $window.document.createElement("script")
			$window[callbackName] = function(data) {
				delete $window[callbackName]
				script.parentNode.removeChild(script)
				resolve(data)
			}
			script.onerror = function() {
				delete $window[callbackName]
				script.parentNode.removeChild(script)
				reject(new Error("JSONP request failed"))
			}
			script.src = url + (url.indexOf("?") < 0 ? "?" : "&") +
				encodeURIComponent(args.callbackKey || "callback") + "=" +
				encodeURIComponent(callbackName)
			$window.document.documentElement.appendChild(script)
		}),
		setCompletionCallback: function(callback) {
			oncompletion = callback
		},
	}
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/route.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/route.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redrawService = __webpack_require__(/*! ./redraw */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/redraw.js")

module.exports = __webpack_require__(/*! ./api/router */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/api/router.js")(window, redrawService)


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/router/router.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/router/router.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {

var buildPathname = __webpack_require__(/*! ../pathname/build */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/build.js")
var parsePathname = __webpack_require__(/*! ../pathname/parse */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/parse.js")
var compileTemplate = __webpack_require__(/*! ../pathname/compileTemplate */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/compileTemplate.js")
var assign = __webpack_require__(/*! ../pathname/assign */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/pathname/assign.js")

module.exports = function($window) {
	var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout
	var supportsPushState = typeof $window.history.pushState === "function"
	var fireAsync

	return {
		prefix: "#!",

		getPath: function() {
			// Consider the pathname holistically. The prefix might even be invalid,
			// but that's not our problem.
			var prefix = $window.location.hash
			if (this.prefix[0] !== "#") {
				prefix = $window.location.search + prefix
				if (this.prefix[0] !== "?") {
					prefix = $window.location.pathname + prefix
					if (prefix[0] !== "/") prefix = "/" + prefix
				}
			}
			// This seemingly useless `.concat()` speeds up the tests quite a bit,
			// since the representation is consistently a relatively poorly
			// optimized cons string.
			return prefix.concat()
				.replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)
				.slice(this.prefix.length)
		},

		setPath: function(path, data, options) {
			path = buildPathname(path, data)
			if (fireAsync != null) {
				fireAsync()
				var state = options ? options.state : null
				var title = options ? options.title : null
				if (options && options.replace) $window.history.replaceState(state, title, this.prefix + path)
				else $window.history.pushState(state, title, this.prefix + path)
			}
			else {
				$window.location.href = this.prefix + path
			}
		},

		defineRoutes: function(routes, resolve, reject, defaultRoute, subscribe) {
			var self = this
			var compiled = Object.keys(routes).map(function(route) {
				if (route[0] !== "/") throw new SyntaxError("Routes must start with a `/`")
				if ((/:([^\/\.-]+)(\.{3})?:/).test(route)) {
					throw new SyntaxError("Route parameter names must be separated with either `/`, `.`, or `-`")
				}
				return {
					route: route,
					component: routes[route],
					check: compileTemplate(route),
				}
			})
			var unsubscribe, asyncId

			fireAsync = null

			if (defaultRoute != null) {
				var defaultData = parsePathname(defaultRoute)

				if (!compiled.some(function (i) { return i.check(defaultData) })) {
					throw new ReferenceError("Default route doesn't match any known routes")
				}
			}

			function resolveRoute() {
				var path = self.getPath()
				var data = parsePathname(path)

				assign(data.params, $window.history.state)

				for (var i = 0; i < compiled.length; i++) {
					if (compiled[i].check(data)) {
						resolve(compiled[i].component, data.params, path, compiled[i].route)
						return
					}
				}

				reject(path, data.params)
			}

			if (supportsPushState) {
				unsubscribe = function() {
					$window.removeEventListener("popstate", fireAsync, false)
				}
				$window.addEventListener("popstate", fireAsync = function() {
					if (asyncId) return
					asyncId = callAsync(function() {
						asyncId = null
						resolveRoute()
					})
				}, false)
			} else if (this.prefix[0] === "#") {
				unsubscribe = function() {
					$window.removeEventListener("hashchange", resolveRoute, false)
				}
				$window.addEventListener("hashchange", resolveRoute, false)
			}

			subscribe(unsubscribe)
			resolveRoute()
		},
	}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../timers-browserify/2.0.10/node_modules/timers-browserify/main.js */ "./node_modules/.registry.npmjs.org/timers-browserify/2.0.10/node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/F.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/F.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _always__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./always */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js");


/**
 * A function that always returns `false`. Any passed in parameters are ignored.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig * -> Boolean
 * @param {*}
 * @return {Boolean}
 * @see R.always, R.T
 * @example
 *
 *      R.F(); //=> false
 */
var F = /*#__PURE__*/Object(_always__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
/* harmony default export */ __webpack_exports__["default"] = (F);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/T.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/T.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _always__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./always */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js");


/**
 * A function that always returns `true`. Any passed in parameters are ignored.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig * -> Boolean
 * @param {*}
 * @return {Boolean}
 * @see R.always, R.F
 * @example
 *
 *      R.T(); //=> true
 */
var T = /*#__PURE__*/Object(_always__WEBPACK_IMPORTED_MODULE_0__["default"])(true);
/* harmony default export */ __webpack_exports__["default"] = (T);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/__.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/__.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * A special placeholder value used to specify "gaps" within curried functions,
 * allowing partial application of any combination of arguments, regardless of
 * their positions.
 *
 * If `g` is a curried ternary function and `_` is `R.__`, the following are
 * equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2, _)(1, 3)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @constant
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @example
 *
 *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
 *      greet('Alice'); //=> 'Hello, Alice!'
 */
/* harmony default export */ __webpack_exports__["default"] = ({ '@@functional/placeholder': true });

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/add.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/add.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Adds two values.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a
 * @param {Number} b
 * @return {Number}
 * @see R.subtract
 * @example
 *
 *      R.add(2, 3);       //=>  5
 *      R.add(7)(10);      //=> 17
 */
var add = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function add(a, b) {
  return Number(a) + Number(b);
});
/* harmony default export */ __webpack_exports__["default"] = (add);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/addIndex.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/addIndex.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");




/**
 * Creates a new list iteration function from an existing one by adding two new
 * parameters to its callback function: the current index, and the entire list.
 *
 * This would turn, for instance, [`R.map`](#map) function into one that
 * more closely resembles `Array.prototype.map`. Note that this will only work
 * for functions in which the iteration callback function is the first
 * parameter, and where the list is the last parameter. (This latter might be
 * unimportant if the list parameter is not used.)
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Function
 * @category List
 * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
 * @param {Function} fn A list iteration function that does not pass index or list to its callback
 * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
 * @example
 *
 *      var mapIndexed = R.addIndex(R.map);
 *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
 *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
 */
var addIndex = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_1__["default"])(function addIndex(fn) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_2__["default"])(fn.length, function () {
    var idx = 0;
    var origFn = arguments[0];
    var list = arguments[arguments.length - 1];
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = function () {
      var result = origFn.apply(this, Object(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"])(arguments, [idx, list]));
      idx += 1;
      return result;
    };
    return fn.apply(this, args);
  });
});
/* harmony default export */ __webpack_exports__["default"] = (addIndex);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/adjust.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/adjust.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");



/**
 * Applies a function to the value at the given index of an array, returning a
 * new copy of the array with the element at the given index replaced with the
 * result of the function application.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig (a -> a) -> Number -> [a] -> [a]
 * @param {Function} fn The function to apply.
 * @param {Number} idx The index.
 * @param {Array|Arguments} list An array-like object whose value
 *        at the supplied index will be replaced.
 * @return {Array} A copy of the supplied array-like object with
 *         the element at index `idx` replaced with the value
 *         returned by applying `fn` to the existing element.
 * @see R.update
 * @example
 *
 *      R.adjust(R.add(10), 1, [1, 2, 3]);     //=> [1, 12, 3]
 *      R.adjust(R.add(10))(1)([1, 2, 3]);     //=> [1, 12, 3]
 * @symb R.adjust(f, -1, [a, b]) = [a, f(b)]
 * @symb R.adjust(f, 0, [a, b]) = [f(a), b]
 */
var adjust = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_1__["default"])(function adjust(fn, idx, list) {
  if (idx >= list.length || idx < -list.length) {
    return list;
  }
  var start = idx < 0 ? list.length : 0;
  var _idx = start + idx;
  var _list = Object(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"])(list);
  _list[_idx] = fn(list[_idx]);
  return _list;
});
/* harmony default export */ __webpack_exports__["default"] = (adjust);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/all.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/all.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xall__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xall */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xall.js");




/**
 * Returns `true` if all elements of the list match the predicate, `false` if
 * there are any that don't.
 *
 * Dispatches to the `all` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
 *         otherwise.
 * @see R.any, R.none, R.transduce
 * @example
 *
 *      var equals3 = R.equals(3);
 *      R.all(equals3)([3, 3, 3, 3]); //=> true
 *      R.all(equals3)([3, 3, 1, 3]); //=> false
 */
var all = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['all'], _internal_xall__WEBPACK_IMPORTED_MODULE_2__["default"], function all(fn, list) {
  var idx = 0;
  while (idx < list.length) {
    if (!fn(list[idx])) {
      return false;
    }
    idx += 1;
  }
  return true;
}));
/* harmony default export */ __webpack_exports__["default"] = (all);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/allPass.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/allPass.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./max */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js");
/* harmony import */ var _pluck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pluck */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pluck.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");






/**
 * Takes a list of predicates and returns a predicate that returns true for a
 * given list of arguments if every one of the provided predicates is satisfied
 * by those arguments.
 *
 * The function returned is a curried function whose arity matches that of the
 * highest-arity predicate.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Logic
 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
 * @param {Array} predicates An array of predicates to check
 * @return {Function} The combined predicate
 * @see R.anyPass
 * @example
 *
 *      var isQueen = R.propEq('rank', 'Q');
 *      var isSpade = R.propEq('suit', 'â ï¸');
 *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
 *
 *      isQueenOfSpades({rank: 'Q', suit: 'â£ï¸'}); //=> false
 *      isQueenOfSpades({rank: 'Q', suit: 'â ï¸'}); //=> true
 */
var allPass = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function allPass(preds) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_reduce__WEBPACK_IMPORTED_MODULE_4__["default"])(_max__WEBPACK_IMPORTED_MODULE_2__["default"], 0, Object(_pluck__WEBPACK_IMPORTED_MODULE_3__["default"])('length', preds)), function () {
    var idx = 0;
    var len = preds.length;
    while (idx < len) {
      if (!preds[idx].apply(this, arguments)) {
        return false;
      }
      idx += 1;
    }
    return true;
  });
});
/* harmony default export */ __webpack_exports__["default"] = (allPass);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Returns a function that always returns the given value. Note that for
 * non-primitives the value returned is a reference to the original value.
 *
 * This function is known as `const`, `constant`, or `K` (for K combinator) in
 * other languages and libraries.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig a -> (* -> a)
 * @param {*} val The value to wrap in a function
 * @return {Function} A Function :: * -> val.
 * @example
 *
 *      var t = R.always('Tee');
 *      t(); //=> 'Tee'
 */
var always = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function always(val) {
  return function () {
    return val;
  };
});
/* harmony default export */ __webpack_exports__["default"] = (always);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/and.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/and.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns `true` if both arguments are `true`; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig a -> b -> a | b
 * @param {Any} a
 * @param {Any} b
 * @return {Any} the first argument if it is falsy, otherwise the second argument.
 * @see R.both
 * @example
 *
 *      R.and(true, true); //=> true
 *      R.and(true, false); //=> false
 *      R.and(false, true); //=> false
 *      R.and(false, false); //=> false
 */
var and = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function and(a, b) {
  return a && b;
});
/* harmony default export */ __webpack_exports__["default"] = (and);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/any.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/any.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xany__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xany */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xany.js");




/**
 * Returns `true` if at least one of elements of the list match the predicate,
 * `false` otherwise.
 *
 * Dispatches to the `any` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
 *         otherwise.
 * @see R.all, R.none, R.transduce
 * @example
 *
 *      var lessThan0 = R.flip(R.lt)(0);
 *      var lessThan2 = R.flip(R.lt)(2);
 *      R.any(lessThan0)([1, 2]); //=> false
 *      R.any(lessThan2)([1, 2]); //=> true
 */
var any = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['any'], _internal_xany__WEBPACK_IMPORTED_MODULE_2__["default"], function any(fn, list) {
  var idx = 0;
  while (idx < list.length) {
    if (fn(list[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
}));
/* harmony default export */ __webpack_exports__["default"] = (any);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/anyPass.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/anyPass.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./max */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js");
/* harmony import */ var _pluck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pluck */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pluck.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");






/**
 * Takes a list of predicates and returns a predicate that returns true for a
 * given list of arguments if at least one of the provided predicates is
 * satisfied by those arguments.
 *
 * The function returned is a curried function whose arity matches that of the
 * highest-arity predicate.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Logic
 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
 * @param {Array} predicates An array of predicates to check
 * @return {Function} The combined predicate
 * @see R.allPass
 * @example
 *
 *      var isClub = R.propEq('suit', 'â£');
 *      var isSpade = R.propEq('suit', 'â ');
 *      var isBlackCard = R.anyPass([isClub, isSpade]);
 *
 *      isBlackCard({rank: '10', suit: 'â£'}); //=> true
 *      isBlackCard({rank: 'Q', suit: 'â '}); //=> true
 *      isBlackCard({rank: 'Q', suit: 'â¦'}); //=> false
 */
var anyPass = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function anyPass(preds) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_reduce__WEBPACK_IMPORTED_MODULE_4__["default"])(_max__WEBPACK_IMPORTED_MODULE_2__["default"], 0, Object(_pluck__WEBPACK_IMPORTED_MODULE_3__["default"])('length', preds)), function () {
    var idx = 0;
    var len = preds.length;
    while (idx < len) {
      if (preds[idx].apply(this, arguments)) {
        return true;
      }
      idx += 1;
    }
    return false;
  });
});
/* harmony default export */ __webpack_exports__["default"] = (anyPass);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ap.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ap.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");





/**
 * ap applies a list of functions to a list of values.
 *
 * Dispatches to the `ap` method of the second argument, if present. Also
 * treats curried functions as applicatives.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Function
 * @sig [a -> b] -> [a] -> [b]
 * @sig Apply f => f (a -> b) -> f a -> f b
 * @sig (a -> b -> c) -> (a -> b) -> (a -> c)
 * @param {*} applyF
 * @param {*} applyX
 * @return {*}
 * @example
 *
 *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
 *      R.ap([R.concat('tasty '), R.toUpper], ['pizza', 'salad']); //=> ["tasty pizza", "tasty salad", "PIZZA", "SALAD"]
 *
 *      // R.ap can also be used as S combinator
 *      // when only two functions are passed
 *      R.ap(R.concat, R.toUpper)('Ramda') //=> 'RamdaRAMDA'
 * @symb R.ap([f, g], [a, b]) = [f(a), f(b), g(a), g(b)]
 */
var ap = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function ap(applyF, applyX) {
  return typeof applyX['fantasy-land/ap'] === 'function' ? applyX['fantasy-land/ap'](applyF) : typeof applyF.ap === 'function' ? applyF.ap(applyX) : typeof applyF === 'function' ? function (x) {
    return applyF(x)(applyX(x));
  } :
  // else
  Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_2__["default"])(function (acc, f) {
    return Object(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"])(acc, Object(_map__WEBPACK_IMPORTED_MODULE_3__["default"])(f, applyX));
  }, [], applyF);
});
/* harmony default export */ __webpack_exports__["default"] = (ap);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/aperture.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/aperture.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_aperture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_aperture */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_aperture.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xaperture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_xaperture */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xaperture.js");





/**
 * Returns a new list, composed of n-tuples of consecutive elements. If `n` is
 * greater than the length of the list, an empty list is returned.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig Number -> [a] -> [[a]]
 * @param {Number} n The size of the tuples to create
 * @param {Array} list The list to split into `n`-length tuples
 * @return {Array} The resulting list of `n`-length tuples
 * @see R.transduce
 * @example
 *
 *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
 *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
 *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
 */
var aperture = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_2__["default"])([], _internal_xaperture__WEBPACK_IMPORTED_MODULE_3__["default"], _internal_aperture__WEBPACK_IMPORTED_MODULE_0__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (aperture);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/append.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/append.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Returns a new list containing the contents of the given list, followed by
 * the given element.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> [a]
 * @param {*} el The element to add to the end of the new list.
 * @param {Array} list The list of elements to add a new item to.
 *        list.
 * @return {Array} A new list containing the elements of the old list followed by `el`.
 * @see R.prepend
 * @example
 *
 *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
 *      R.append('tests', []); //=> ['tests']
 *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
 */
var append = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function append(el, list) {
  return Object(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"])(list, [el]);
});
/* harmony default export */ __webpack_exports__["default"] = (append);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/apply.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/apply.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Applies function `fn` to the argument list `args`. This is useful for
 * creating a fixed-arity function from a variadic function. `fn` should be a
 * bound function if context is significant.
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Function
 * @sig (*... -> a) -> [*] -> a
 * @param {Function} fn The function which will be called with `args`
 * @param {Array} args The arguments to call `fn` with
 * @return {*} result The result, equivalent to `fn(...args)`
 * @see R.call, R.unapply
 * @example
 *
 *      var nums = [1, 2, 3, -99, 42, 6, 7];
 *      R.apply(Math.max, nums); //=> 42
 * @symb R.apply(f, [a, b, c]) = f(a, b, c)
 */
var apply = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function apply(fn, args) {
  return fn.apply(this, args);
});
/* harmony default export */ __webpack_exports__["default"] = (apply);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/applySpec.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/applySpec.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _apply__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./apply */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/apply.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");
/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./max */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js");
/* harmony import */ var _pluck__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pluck */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pluck.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");
/* harmony import */ var _values__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./values */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/values.js");









/**
 * Given a spec object recursively mapping properties to functions, creates a
 * function producing an object of the same structure, by mapping each property
 * to the result of calling its associated function with the supplied arguments.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Function
 * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
 * @param {Object} spec an object recursively mapping properties to functions for
 *        producing the values for these properties.
 * @return {Function} A function that returns an object of the same structure
 * as `spec', with each property set to the value returned by calling its
 * associated function with the supplied arguments.
 * @see R.converge, R.juxt
 * @example
 *
 *      var getMetrics = R.applySpec({
 *        sum: R.add,
 *        nested: { mul: R.multiply }
 *      });
 *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
 * @symb R.applySpec({ x: f, y: { z: g } })(a, b) = { x: f(a, b), y: { z: g(a, b) } }
 */
var applySpec = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function applySpec(spec) {
  spec = Object(_map__WEBPACK_IMPORTED_MODULE_3__["default"])(function (v) {
    return typeof v == 'function' ? v : applySpec(v);
  }, spec);
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_reduce__WEBPACK_IMPORTED_MODULE_6__["default"])(_max__WEBPACK_IMPORTED_MODULE_4__["default"], 0, Object(_pluck__WEBPACK_IMPORTED_MODULE_5__["default"])('length', Object(_values__WEBPACK_IMPORTED_MODULE_7__["default"])(spec))), function () {
    var args = arguments;
    return Object(_map__WEBPACK_IMPORTED_MODULE_3__["default"])(function (f) {
      return Object(_apply__WEBPACK_IMPORTED_MODULE_1__["default"])(f, args);
    }, spec);
  });
});
/* harmony default export */ __webpack_exports__["default"] = (applySpec);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/applyTo.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/applyTo.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
* Takes a value and applies a function to it.
*
* This function is also known as the `thrush` combinator.
*
* @func
* @memberOf R
 * @since v0.25.0
* @category Function
* @sig a -> (a -> b) -> b
* @param {*} x The value
* @param {Function} f The function to apply
* @return {*} The result of applying `f` to `x`
* @example
*
*      var t42 = R.applyTo(42);
*      t42(R.identity); //=> 42
*      t42(R.add(1)); //=> 43
*/
var applyTo = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function applyTo(x, f) {
  return f(x);
});
/* harmony default export */ __webpack_exports__["default"] = (applyTo);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ascend.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ascend.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Makes an ascending comparator function out of a function that returns a value
 * that can be compared with `<` and `>`.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Function
 * @sig Ord b => (a -> b) -> a -> a -> Number
 * @param {Function} fn A function of arity one that returns a value that can be compared
 * @param {*} a The first item to be compared.
 * @param {*} b The second item to be compared.
 * @return {Number} `-1` if fn(a) < fn(b), `1` if fn(b) < fn(a), otherwise `0`
 * @see R.descend
 * @example
 *
 *      var byAge = R.ascend(R.prop('age'));
 *      var people = [
 *        // ...
 *      ];
 *      var peopleByYoungestFirst = R.sort(byAge, people);
 */
var ascend = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function ascend(fn, a, b) {
  var aa = fn(a);
  var bb = fn(b);
  return aa < bb ? -1 : aa > bb ? 1 : 0;
});
/* harmony default export */ __webpack_exports__["default"] = (ascend);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assoc.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assoc.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Makes a shallow clone of an object, setting or overriding the specified
 * property with the given value. Note that this copies and flattens prototype
 * properties onto the new object as well. All non-primitive properties are
 * copied by reference.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @sig String -> a -> {k: v} -> {k: v}
 * @param {String} prop The property name to set
 * @param {*} val The new value
 * @param {Object} obj The object to clone
 * @return {Object} A new object equivalent to the original except for the changed property.
 * @see R.dissoc
 * @example
 *
 *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
 */
var assoc = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function assoc(prop, val, obj) {
  var result = {};
  for (var p in obj) {
    result[p] = obj[p];
  }
  result[prop] = val;
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (assoc);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assocPath.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assocPath.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");
/* harmony import */ var _internal_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");
/* harmony import */ var _internal_isInteger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_isInteger */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isInteger.js");
/* harmony import */ var _assoc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./assoc */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assoc.js");
/* harmony import */ var _isNil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isNil */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/isNil.js");







/**
 * Makes a shallow clone of an object, setting or overriding the nodes required
 * to create the given path, and placing the specific value at the tail end of
 * that path. Note that this copies and flattens prototype properties onto the
 * new object as well. All non-primitive properties are copied by reference.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig [Idx] -> a -> {a} -> {a}
 * @param {Array} path the path to set
 * @param {*} val The new value
 * @param {Object} obj The object to clone
 * @return {Object} A new object equivalent to the original except along the specified path.
 * @see R.dissocPath
 * @example
 *
 *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
 *
 *      // Any missing or non-object keys in path will be overridden
 *      R.assocPath(['a', 'b', 'c'], 42, {a: 5}); //=> {a: {b: {c: 42}}}
 */
var assocPath = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function assocPath(path, val, obj) {
  if (path.length === 0) {
    return val;
  }
  var idx = path[0];
  if (path.length > 1) {
    var nextObj = !Object(_isNil__WEBPACK_IMPORTED_MODULE_5__["default"])(obj) && Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(idx, obj) ? obj[idx] : Object(_internal_isInteger__WEBPACK_IMPORTED_MODULE_3__["default"])(path[1]) ? [] : {};
    val = assocPath(Array.prototype.slice.call(path, 1), val, nextObj);
  }
  if (Object(_internal_isInteger__WEBPACK_IMPORTED_MODULE_3__["default"])(idx) && Object(_internal_isArray__WEBPACK_IMPORTED_MODULE_2__["default"])(obj)) {
    var arr = [].concat(obj);
    arr[idx] = val;
    return arr;
  } else {
    return Object(_assoc__WEBPACK_IMPORTED_MODULE_4__["default"])(idx, val, obj);
  }
});
/* harmony default export */ __webpack_exports__["default"] = (assocPath);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/binary.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/binary.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _nAry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nAry */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nAry.js");



/**
 * Wraps a function of any arity (including nullary) in a function that accepts
 * exactly 2 parameters. Any extraneous parameters will not be passed to the
 * supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Function
 * @sig (* -> c) -> (a, b -> c)
 * @param {Function} fn The function to wrap.
 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
 *         arity 2.
 * @see R.nAry, R.unary
 * @example
 *
 *      var takesThreeArgs = function(a, b, c) {
 *        return [a, b, c];
 *      };
 *      takesThreeArgs.length; //=> 3
 *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
 *
 *      var takesTwoArgs = R.binary(takesThreeArgs);
 *      takesTwoArgs.length; //=> 2
 *      // Only 2 arguments are passed to the wrapped function
 *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
 * @symb R.binary(f)(a, b, c) = f(a, b)
 */
var binary = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function binary(fn) {
  return Object(_nAry__WEBPACK_IMPORTED_MODULE_1__["default"])(2, fn);
});
/* harmony default export */ __webpack_exports__["default"] = (binary);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/bind.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/bind.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Creates a function that is bound to a context.
 * Note: `R.bind` does not provide the additional argument-binding capabilities of
 * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @category Object
 * @sig (* -> *) -> {*} -> (* -> *)
 * @param {Function} fn The function to bind to context
 * @param {Object} thisObj The context to bind `fn` to
 * @return {Function} A function that will execute in the context of `thisObj`.
 * @see R.partial
 * @example
 *
 *      var log = R.bind(console.log, console);
 *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
 *      // logs {a: 2}
 * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
 */
var bind = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function bind(fn, thisObj) {
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(fn.length, function () {
    return fn.apply(thisObj, arguments);
  });
});
/* harmony default export */ __webpack_exports__["default"] = (bind);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/both.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/both.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isFunction */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isFunction.js");
/* harmony import */ var _and__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./and */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/and.js");
/* harmony import */ var _lift__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lift */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lift.js");





/**
 * A function which calls the two provided functions and returns the `&&`
 * of the results.
 * It returns the result of the first function if it is false-y and the result
 * of the second function otherwise. Note that this is short-circuited,
 * meaning that the second function will not be invoked if the first returns a
 * false-y value.
 *
 * In addition to functions, `R.both` also accepts any fantasy-land compatible
 * applicative functor.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
 * @param {Function} f A predicate
 * @param {Function} g Another predicate
 * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
 * @see R.and
 * @example
 *
 *      var gt10 = R.gt(R.__, 10)
 *      var lt20 = R.lt(R.__, 20)
 *      var f = R.both(gt10, lt20);
 *      f(15); //=> true
 *      f(30); //=> false
 */
var both = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function both(f, g) {
  return Object(_internal_isFunction__WEBPACK_IMPORTED_MODULE_1__["default"])(f) ? function _both() {
    return f.apply(this, arguments) && g.apply(this, arguments);
  } : Object(_lift__WEBPACK_IMPORTED_MODULE_3__["default"])(_and__WEBPACK_IMPORTED_MODULE_2__["default"])(f, g);
});
/* harmony default export */ __webpack_exports__["default"] = (both);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/call.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/call.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curry */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curry.js");


/**
 * Returns the result of calling its first argument with the remaining
 * arguments. This is occasionally useful as a converging function for
 * [`R.converge`](#converge): the first branch can produce a function while the
 * remaining branches produce values to be passed to that function as its
 * arguments.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig (*... -> a),*... -> a
 * @param {Function} fn The function to apply to the remaining arguments.
 * @param {...*} args Any number of positional arguments.
 * @return {*}
 * @see R.apply
 * @example
 *
 *      R.call(R.add, 1, 2); //=> 3
 *
 *      var indentN = R.pipe(R.repeat(' '),
 *                           R.join(''),
 *                           R.replace(/^(?!$)/gm));
 *
 *      var format = R.converge(R.call, [
 *                                  R.pipe(R.prop('indent'), indentN),
 *                                  R.prop('value')
 *                              ]);
 *
 *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
 * @symb R.call(f, a, b) = f(a, b)
 */
var call = /*#__PURE__*/Object(_curry__WEBPACK_IMPORTED_MODULE_0__["default"])(function call(fn) {
  return fn.apply(this, Array.prototype.slice.call(arguments, 1));
});
/* harmony default export */ __webpack_exports__["default"] = (call);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/chain.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/chain.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_makeFlat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_makeFlat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_makeFlat.js");
/* harmony import */ var _internal_xchain__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_xchain */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xchain.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");






/**
 * `chain` maps a function over a list and concatenates the results. `chain`
 * is also known as `flatMap` in some libraries
 *
 * Dispatches to the `chain` method of the second argument, if present,
 * according to the [FantasyLand Chain spec](https://github.com/fantasyland/fantasy-land#chain).
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig Chain m => (a -> m b) -> m a -> m b
 * @param {Function} fn The function to map with
 * @param {Array} list The list to map over
 * @return {Array} The result of flat-mapping `list` with `fn`
 * @example
 *
 *      var duplicate = n => [n, n];
 *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
 *
 *      R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]
 */
var chain = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['fantasy-land/chain', 'chain'], _internal_xchain__WEBPACK_IMPORTED_MODULE_3__["default"], function chain(fn, monad) {
  if (typeof monad === 'function') {
    return function (x) {
      return fn(monad(x))(x);
    };
  }
  return Object(_internal_makeFlat__WEBPACK_IMPORTED_MODULE_2__["default"])(false)(Object(_map__WEBPACK_IMPORTED_MODULE_4__["default"])(fn, monad));
}));
/* harmony default export */ __webpack_exports__["default"] = (chain);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/clamp.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/clamp.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Restricts a number to be within a range.
 *
 * Also works for other ordered types such as Strings and Dates.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Relation
 * @sig Ord a => a -> a -> a -> a
 * @param {Number} minimum The lower limit of the clamp (inclusive)
 * @param {Number} maximum The upper limit of the clamp (inclusive)
 * @param {Number} value Value to be clamped
 * @return {Number} Returns `minimum` when `val < minimum`, `maximum` when `val > maximum`, returns `val` otherwise
 * @example
 *
 *      R.clamp(1, 10, -5) // => 1
 *      R.clamp(1, 10, 15) // => 10
 *      R.clamp(1, 10, 4)  // => 4
 */
var clamp = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function clamp(min, max, value) {
  if (min > max) {
    throw new Error('min must not be greater than max in clamp(min, max, value)');
  }
  return value < min ? min : value > max ? max : value;
});
/* harmony default export */ __webpack_exports__["default"] = (clamp);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/clone.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/clone.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_clone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_clone */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_clone.js");
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");



/**
 * Creates a deep copy of the value which may contain (nested) `Array`s and
 * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are
 * assigned by reference rather than copied
 *
 * Dispatches to a `clone` method if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {*} -> {*}
 * @param {*} value The object or array to clone
 * @return {*} A deeply cloned copy of `val`
 * @example
 *
 *      var objects = [{}, {}, {}];
 *      var objectsClone = R.clone(objects);
 *      objects === objectsClone; //=> false
 *      objects[0] === objectsClone[0]; //=> false
 */
var clone = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_1__["default"])(function clone(value) {
  return value != null && typeof value.clone === 'function' ? value.clone() : Object(_internal_clone__WEBPACK_IMPORTED_MODULE_0__["default"])(value, [], [], true);
});
/* harmony default export */ __webpack_exports__["default"] = (clone);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/comparator.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/comparator.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Makes a comparator function out of a function that reports whether the first
 * element is less than the second.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((a, b) -> Boolean) -> ((a, b) -> Number)
 * @param {Function} pred A predicate function of arity two which will return `true` if the first argument
 * is less than the second, `false` otherwise
 * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`
 * @example
 *
 *      var byAge = R.comparator((a, b) => a.age < b.age);
 *      var people = [
 *        // ...
 *      ];
 *      var peopleByIncreasingAge = R.sort(byAge, people);
 */
var comparator = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function comparator(pred) {
  return function (a, b) {
    return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
  };
});
/* harmony default export */ __webpack_exports__["default"] = (comparator);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/complement.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/complement.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lift */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lift.js");
/* harmony import */ var _not__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./not */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/not.js");



/**
 * Takes a function `f` and returns a function `g` such that if called with the same arguments
 * when `f` returns a "truthy" value, `g` returns `false` and when `f` returns a "falsy" value `g` returns `true`.
 *
 * `R.complement` may be applied to any functor
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category Logic
 * @sig (*... -> *) -> (*... -> Boolean)
 * @param {Function} f
 * @return {Function}
 * @see R.not
 * @example
 *
 *      var isNotNil = R.complement(R.isNil);
 *      isNil(null); //=> true
 *      isNotNil(null); //=> false
 *      isNil(7); //=> false
 *      isNotNil(7); //=> true
 */
var complement = /*#__PURE__*/Object(_lift__WEBPACK_IMPORTED_MODULE_0__["default"])(_not__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (complement);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/compose.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/compose.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return compose; });
/* harmony import */ var _pipe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pipe */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipe.js");
/* harmony import */ var _reverse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reverse */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reverse.js");



/**
 * Performs right-to-left function composition. The rightmost function may have
 * any arity; the remaining functions must be unary.
 *
 * **Note:** The result of compose is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
 * @param {...Function} ...functions The functions to compose
 * @return {Function}
 * @see R.pipe
 * @example
 *
 *      var classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
 *      var yellGreeting = R.compose(R.toUpper, classyGreeting);
 *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
 *
 *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
 *
 * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
 */
function compose() {
  if (arguments.length === 0) {
    throw new Error('compose requires at least one argument');
  }
  return _pipe__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, Object(_reverse__WEBPACK_IMPORTED_MODULE_1__["default"])(arguments));
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/composeK.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/composeK.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return composeK; });
/* harmony import */ var _chain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chain */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/chain.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compose */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/compose.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");




/**
 * Returns the right-to-left Kleisli composition of the provided functions,
 * each of which must return a value of a type supported by [`chain`](#chain).
 *
 * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), f)`.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Function
 * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (a -> m z)
 * @param {...Function} ...functions The functions to compose
 * @return {Function}
 * @see R.pipeK
 * @example
 *
 *       //  get :: String -> Object -> Maybe *
 *       var get = R.curry((propName, obj) => Maybe(obj[propName]))
 *
 *       //  getStateCode :: Maybe String -> Maybe String
 *       var getStateCode = R.composeK(
 *         R.compose(Maybe.of, R.toUpper),
 *         get('state'),
 *         get('address'),
 *         get('user'),
 *       );
 *       getStateCode({"user":{"address":{"state":"ny"}}}); //=> Maybe.Just("NY")
 *       getStateCode({}); //=> Maybe.Nothing()
 * @symb R.composeK(f, g, h)(a) = R.chain(f, R.chain(g, h(a)))
 */
function composeK() {
  if (arguments.length === 0) {
    throw new Error('composeK requires at least one argument');
  }
  var init = Array.prototype.slice.call(arguments);
  var last = init.pop();
  return Object(_compose__WEBPACK_IMPORTED_MODULE_1__["default"])(_compose__WEBPACK_IMPORTED_MODULE_1__["default"].apply(this, Object(_map__WEBPACK_IMPORTED_MODULE_2__["default"])(_chain__WEBPACK_IMPORTED_MODULE_0__["default"], init)), last);
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/composeP.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/composeP.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return composeP; });
/* harmony import */ var _pipeP__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pipeP */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipeP.js");
/* harmony import */ var _reverse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reverse */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reverse.js");



/**
 * Performs right-to-left composition of one or more Promise-returning
 * functions. The rightmost function may have any arity; the remaining
 * functions must be unary.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
 * @param {...Function} functions The functions to compose
 * @return {Function}
 * @see R.pipeP
 * @example
 *
 *      var db = {
 *        users: {
 *          JOE: {
 *            name: 'Joe',
 *            followers: ['STEVE', 'SUZY']
 *          }
 *        }
 *      }
 *
 *      // We'll pretend to do a db lookup which returns a promise
 *      var lookupUser = (userId) => Promise.resolve(db.users[userId])
 *      var lookupFollowers = (user) => Promise.resolve(user.followers)
 *      lookupUser('JOE').then(lookupFollowers)
 *
 *      //  followersForUser :: String -> Promise [UserId]
 *      var followersForUser = R.composeP(lookupFollowers, lookupUser);
 *      followersForUser('JOE').then(followers => console.log('Followers:', followers))
 *      // Followers: ["STEVE","SUZY"]
 */
function composeP() {
  if (arguments.length === 0) {
    throw new Error('composeP requires at least one argument');
  }
  return _pipeP__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, Object(_reverse__WEBPACK_IMPORTED_MODULE_1__["default"])(arguments));
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/concat.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/concat.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");
/* harmony import */ var _internal_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_isFunction */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isFunction.js");
/* harmony import */ var _internal_isString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_isString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isString.js");
/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./toString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toString.js");






/**
 * Returns the result of concatenating the given lists or strings.
 *
 * Note: `R.concat` expects both arguments to be of the same type,
 * unlike the native `Array.prototype.concat` method. It will throw
 * an error if you `concat` an Array with a non-Array value.
 *
 * Dispatches to the `concat` method of the first argument, if present.
 * Can also concatenate two members of a [fantasy-land
 * compatible semigroup](https://github.com/fantasyland/fantasy-land#semigroup).
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a] -> [a]
 * @sig String -> String -> String
 * @param {Array|String} firstList The first list
 * @param {Array|String} secondList The second list
 * @return {Array|String} A list consisting of the elements of `firstList` followed by the elements of
 * `secondList`.
 *
 * @example
 *
 *      R.concat('ABC', 'DEF'); // 'ABCDEF'
 *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
 *      R.concat([], []); //=> []
 */
var concat = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function concat(a, b) {
  if (Object(_internal_isArray__WEBPACK_IMPORTED_MODULE_1__["default"])(a)) {
    if (Object(_internal_isArray__WEBPACK_IMPORTED_MODULE_1__["default"])(b)) {
      return a.concat(b);
    }
    throw new TypeError(Object(_toString__WEBPACK_IMPORTED_MODULE_4__["default"])(b) + ' is not an array');
  }
  if (Object(_internal_isString__WEBPACK_IMPORTED_MODULE_3__["default"])(a)) {
    if (Object(_internal_isString__WEBPACK_IMPORTED_MODULE_3__["default"])(b)) {
      return a + b;
    }
    throw new TypeError(Object(_toString__WEBPACK_IMPORTED_MODULE_4__["default"])(b) + ' is not a string');
  }
  if (a != null && Object(_internal_isFunction__WEBPACK_IMPORTED_MODULE_2__["default"])(a['fantasy-land/concat'])) {
    return a['fantasy-land/concat'](b);
  }
  if (a != null && Object(_internal_isFunction__WEBPACK_IMPORTED_MODULE_2__["default"])(a.concat)) {
    return a.concat(b);
  }
  throw new TypeError(Object(_toString__WEBPACK_IMPORTED_MODULE_4__["default"])(a) + ' does not have a method named "concat" or "fantasy-land/concat"');
});
/* harmony default export */ __webpack_exports__["default"] = (concat);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/cond.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/cond.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");
/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./max */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");






/**
 * Returns a function, `fn`, which encapsulates `if/else, if/else, ...` logic.
 * `R.cond` takes a list of [predicate, transformer] pairs. All of the arguments
 * to `fn` are applied to each of the predicates in turn until one returns a
 * "truthy" value, at which point `fn` returns the result of applying its
 * arguments to the corresponding transformer. If none of the predicates
 * matches, `fn` returns undefined.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Logic
 * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
 * @param {Array} pairs A list of [predicate, transformer]
 * @return {Function}
 * @example
 *
 *      var fn = R.cond([
 *        [R.equals(0),   R.always('water freezes at 0Â°C')],
 *        [R.equals(100), R.always('water boils at 100Â°C')],
 *        [R.T,           temp => 'nothing special happens at ' + temp + 'Â°C']
 *      ]);
 *      fn(0); //=> 'water freezes at 0Â°C'
 *      fn(50); //=> 'nothing special happens at 50Â°C'
 *      fn(100); //=> 'water boils at 100Â°C'
 */
var cond = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_1__["default"])(function cond(pairs) {
  var arity = Object(_reduce__WEBPACK_IMPORTED_MODULE_4__["default"])(_max__WEBPACK_IMPORTED_MODULE_3__["default"], 0, Object(_map__WEBPACK_IMPORTED_MODULE_2__["default"])(function (pair) {
    return pair[0].length;
  }, pairs));
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(arity, function () {
    var idx = 0;
    while (idx < pairs.length) {
      if (pairs[idx][0].apply(this, arguments)) {
        return pairs[idx][1].apply(this, arguments);
      }
      idx += 1;
    }
  });
});
/* harmony default export */ __webpack_exports__["default"] = (cond);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/construct.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/construct.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _constructN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constructN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/constructN.js");



/**
 * Wraps a constructor function inside a curried function that can be called
 * with the same arguments and returns the same type.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (* -> {*}) -> (* -> {*})
 * @param {Function} fn The constructor function to wrap.
 * @return {Function} A wrapped, curried constructor function.
 * @see R.invoker
 * @example
 *
 *      // Constructor function
 *      function Animal(kind) {
 *        this.kind = kind;
 *      };
 *      Animal.prototype.sighting = function() {
 *        return "It's a " + this.kind + "!";
 *      }
 *
 *      var AnimalConstructor = R.construct(Animal)
 *
 *      // Notice we no longer need the 'new' keyword:
 *      AnimalConstructor('Pig'); //=> {"kind": "Pig", "sighting": function (){...}};
 *
 *      var animalTypes = ["Lion", "Tiger", "Bear"];
 *      var animalSighting = R.invoker(0, 'sighting');
 *      var sightNewAnimal = R.compose(animalSighting, AnimalConstructor);
 *      R.map(sightNewAnimal, animalTypes); //=> ["It's a Lion!", "It's a Tiger!", "It's a Bear!"]
 */
var construct = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function construct(Fn) {
  return Object(_constructN__WEBPACK_IMPORTED_MODULE_1__["default"])(Fn.length, Fn);
});
/* harmony default export */ __webpack_exports__["default"] = (construct);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/constructN.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/constructN.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curry */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curry.js");
/* harmony import */ var _nAry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nAry */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nAry.js");




/**
 * Wraps a constructor function inside a curried function that can be called
 * with the same arguments and returns the same type. The arity of the function
 * returned is specified to allow using variadic constructor functions.
 *
 * @func
 * @memberOf R
 * @since v0.4.0
 * @category Function
 * @sig Number -> (* -> {*}) -> (* -> {*})
 * @param {Number} n The arity of the constructor function.
 * @param {Function} Fn The constructor function to wrap.
 * @return {Function} A wrapped, curried constructor function.
 * @example
 *
 *      // Variadic Constructor function
 *      function Salad() {
 *        this.ingredients = arguments;
 *      }
 *
 *      Salad.prototype.recipe = function() {
 *        var instructions = R.map(ingredient => 'Add a dollop of ' + ingredient, this.ingredients);
 *        return R.join('\n', instructions);
 *      };
 *
 *      var ThreeLayerSalad = R.constructN(3, Salad);
 *
 *      // Notice we no longer need the 'new' keyword, and the constructor is curried for 3 arguments.
 *      var salad = ThreeLayerSalad('Mayonnaise')('Potato Chips')('Ketchup');
 *
 *      console.log(salad.recipe());
 *      // Add a dollop of Mayonnaise
 *      // Add a dollop of Potato Chips
 *      // Add a dollop of Ketchup
 */
var constructN = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function constructN(n, Fn) {
  if (n > 10) {
    throw new Error('Constructor with greater than ten arguments');
  }
  if (n === 0) {
    return function () {
      return new Fn();
    };
  }
  return Object(_curry__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_nAry__WEBPACK_IMPORTED_MODULE_2__["default"])(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
    switch (arguments.length) {
      case 1:
        return new Fn($0);
      case 2:
        return new Fn($0, $1);
      case 3:
        return new Fn($0, $1, $2);
      case 4:
        return new Fn($0, $1, $2, $3);
      case 5:
        return new Fn($0, $1, $2, $3, $4);
      case 6:
        return new Fn($0, $1, $2, $3, $4, $5);
      case 7:
        return new Fn($0, $1, $2, $3, $4, $5, $6);
      case 8:
        return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
      case 9:
        return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
      case 10:
        return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
    }
  }));
});
/* harmony default export */ __webpack_exports__["default"] = (constructN);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/contains.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/contains.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_contains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_contains */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Returns `true` if the specified value is equal, in [`R.equals`](#equals)
 * terms, to at least one element of the given list; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> Boolean
 * @param {Object} a The item to compare against.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
 * @see R.any
 * @example
 *
 *      R.contains(3, [1, 2, 3]); //=> true
 *      R.contains(4, [1, 2, 3]); //=> false
 *      R.contains({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
 *      R.contains([42], [[42]]); //=> true
 */
var contains = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(_internal_contains__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (contains);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/converge.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/converge.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_map.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./max */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js");
/* harmony import */ var _pluck__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pluck */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pluck.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");







/**
 * Accepts a converging function and a list of branching functions and returns
 * a new function. When invoked, this new function is applied to some
 * arguments, each branching function is applied to those same arguments. The
 * results of each branching function are passed as arguments to the converging
 * function to produce the return value.
 *
 * @func
 * @memberOf R
 * @since v0.4.2
 * @category Function
 * @sig ((x1, x2, ...) -> z) -> [((a, b, ...) -> x1), ((a, b, ...) -> x2), ...] -> (a -> b -> ... -> z)
 * @param {Function} after A function. `after` will be invoked with the return values of
 *        `fn1` and `fn2` as its arguments.
 * @param {Array} functions A list of functions.
 * @return {Function} A new function.
 * @see R.useWith
 * @example
 *
 *      var average = R.converge(R.divide, [R.sum, R.length])
 *      average([1, 2, 3, 4, 5, 6, 7]) //=> 4
 *
 *      var strangeConcat = R.converge(R.concat, [R.toUpper, R.toLower])
 *      strangeConcat("Yodel") //=> "YODELyodel"
 *
 * @symb R.converge(f, [g, h])(a, b) = f(g(a, b), h(a, b))
 */
var converge = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function converge(after, fns) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_reduce__WEBPACK_IMPORTED_MODULE_5__["default"])(_max__WEBPACK_IMPORTED_MODULE_3__["default"], 0, Object(_pluck__WEBPACK_IMPORTED_MODULE_4__["default"])('length', fns)), function () {
    var args = arguments;
    var context = this;
    return after.apply(context, Object(_internal_map__WEBPACK_IMPORTED_MODULE_1__["default"])(function (fn) {
      return fn.apply(context, args);
    }, fns));
  });
});
/* harmony default export */ __webpack_exports__["default"] = (converge);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/countBy.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/countBy.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reduceBy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reduceBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceBy.js");


/**
 * Counts the elements of a list according to how many match each value of a
 * key generated by the supplied function. Returns an object mapping the keys
 * produced by `fn` to the number of occurrences in the list. Note that all
 * keys are coerced to strings because of how JavaScript objects work.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig (a -> String) -> [a] -> {*}
 * @param {Function} fn The function used to map values to keys.
 * @param {Array} list The list to count elements from.
 * @return {Object} An object mapping keys to number of occurrences in the list.
 * @example
 *
 *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
 *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
 *
 *      var letters = ['a', 'b', 'A', 'a', 'B', 'c'];
 *      R.countBy(R.toLower)(letters);   //=> {'a': 3, 'b': 2, 'c': 1}
 */
var countBy = /*#__PURE__*/Object(_reduceBy__WEBPACK_IMPORTED_MODULE_0__["default"])(function (acc, elem) {
  return acc + 1;
}, 0);
/* harmony default export */ __webpack_exports__["default"] = (countBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curry.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curry.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");



/**
 * Returns a curried equivalent of the provided function. The curried function
 * has two unusual capabilities. First, its arguments needn't be provided one
 * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
 * the following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (* -> a) -> (* -> a)
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curryN
 * @example
 *
 *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
 *
 *      var curriedAddFourNumbers = R.curry(addFourNumbers);
 *      var f = curriedAddFourNumbers(1, 2);
 *      var g = f(3);
 *      g(4); //=> 10
 */
var curry = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function curry(fn) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(fn.length, fn);
});
/* harmony default export */ __webpack_exports__["default"] = (curry);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_curryN__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curryN.js");





/**
 * Returns a curried equivalent of the provided function, with the specified
 * arity. The curried function has two unusual capabilities. First, its
 * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
 * the following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curry
 * @example
 *
 *      var sumArgs = (...args) => R.sum(args);
 *
 *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
 *      var f = curriedAddFourNumbers(1, 2);
 *      var g = f(3);
 *      g(4); //=> 10
 */
var curryN = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_2__["default"])(function curryN(length, fn) {
  if (length === 1) {
    return Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_1__["default"])(fn);
  }
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(length, Object(_internal_curryN__WEBPACK_IMPORTED_MODULE_3__["default"])(length, [], fn));
});
/* harmony default export */ __webpack_exports__["default"] = (curryN);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dec.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dec.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _add__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/add.js");


/**
 * Decrements its argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Math
 * @sig Number -> Number
 * @param {Number} n
 * @return {Number} n - 1
 * @see R.inc
 * @example
 *
 *      R.dec(42); //=> 41
 */
var dec = /*#__PURE__*/Object(_add__WEBPACK_IMPORTED_MODULE_0__["default"])(-1);
/* harmony default export */ __webpack_exports__["default"] = (dec);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/defaultTo.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/defaultTo.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns the second argument if it is not `null`, `undefined` or `NaN`;
 * otherwise the first argument is returned.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Logic
 * @sig a -> b -> a | b
 * @param {a} default The default value.
 * @param {b} val `val` will be returned instead of `default` unless `val` is `null`, `undefined` or `NaN`.
 * @return {*} The second value if it is not `null`, `undefined` or `NaN`, otherwise the default value
 * @example
 *
 *      var defaultTo42 = R.defaultTo(42);
 *
 *      defaultTo42(null);  //=> 42
 *      defaultTo42(undefined);  //=> 42
 *      defaultTo42('Ramda');  //=> 'Ramda'
 *      // parseInt('string') results in NaN
 *      defaultTo42(parseInt('string')); //=> 42
 */
var defaultTo = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function defaultTo(d, v) {
  return v == null || v !== v ? d : v;
});
/* harmony default export */ __webpack_exports__["default"] = (defaultTo);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/descend.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/descend.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Makes a descending comparator function out of a function that returns a value
 * that can be compared with `<` and `>`.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Function
 * @sig Ord b => (a -> b) -> a -> a -> Number
 * @param {Function} fn A function of arity one that returns a value that can be compared
 * @param {*} a The first item to be compared.
 * @param {*} b The second item to be compared.
 * @return {Number} `-1` if fn(a) > fn(b), `1` if fn(b) > fn(a), otherwise `0`
 * @see R.ascend
 * @example
 *
 *      var byAge = R.descend(R.prop('age'));
 *      var people = [
 *        // ...
 *      ];
 *      var peopleByOldestFirst = R.sort(byAge, people);
 */
var descend = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function descend(fn, a, b) {
  var aa = fn(a);
  var bb = fn(b);
  return aa > bb ? -1 : aa < bb ? 1 : 0;
});
/* harmony default export */ __webpack_exports__["default"] = (descend);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/difference.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/difference.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_contains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_contains */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Finds the set (i.e. no duplicates) of all elements in the first list not
 * contained in the second list. Objects and Arrays are compared in terms of
 * value equality, not reference equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` that are not in `list2`.
 * @see R.differenceWith, R.symmetricDifference, R.symmetricDifferenceWith, R.without
 * @example
 *
 *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
 *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
 *      R.difference([{a: 1}, {b: 2}], [{a: 1}, {c: 3}]) //=> [{b: 2}]
 */
var difference = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function difference(first, second) {
  var out = [];
  var idx = 0;
  var firstLen = first.length;
  while (idx < firstLen) {
    if (!Object(_internal_contains__WEBPACK_IMPORTED_MODULE_0__["default"])(first[idx], second) && !Object(_internal_contains__WEBPACK_IMPORTED_MODULE_0__["default"])(first[idx], out)) {
      out[out.length] = first[idx];
    }
    idx += 1;
  }
  return out;
});
/* harmony default export */ __webpack_exports__["default"] = (difference);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/differenceWith.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/differenceWith.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_containsWith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_containsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_containsWith.js");
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");



/**
 * Finds the set (i.e. no duplicates) of all elements in the first list not
 * contained in the second list. Duplication is determined according to the
 * value returned by applying the supplied predicate to two list elements.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` that are not in `list2`.
 * @see R.difference, R.symmetricDifference, R.symmetricDifferenceWith
 * @example
 *
 *      var cmp = (x, y) => x.a === y.a;
 *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
 *      var l2 = [{a: 3}, {a: 4}];
 *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
 */
var differenceWith = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_1__["default"])(function differenceWith(pred, first, second) {
  var out = [];
  var idx = 0;
  var firstLen = first.length;
  while (idx < firstLen) {
    if (!Object(_internal_containsWith__WEBPACK_IMPORTED_MODULE_0__["default"])(pred, first[idx], second) && !Object(_internal_containsWith__WEBPACK_IMPORTED_MODULE_0__["default"])(pred, first[idx], out)) {
      out.push(first[idx]);
    }
    idx += 1;
  }
  return out;
});
/* harmony default export */ __webpack_exports__["default"] = (differenceWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dissoc.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dissoc.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns a new object that does not contain a `prop` property.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Object
 * @sig String -> {k: v} -> {k: v}
 * @param {String} prop The name of the property to dissociate
 * @param {Object} obj The object to clone
 * @return {Object} A new object equivalent to the original but without the specified property
 * @see R.assoc
 * @example
 *
 *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
 */
var dissoc = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function dissoc(prop, obj) {
  var result = {};
  for (var p in obj) {
    result[p] = obj[p];
  }
  delete result[prop];
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (dissoc);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dissocPath.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dissocPath.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isInteger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isInteger */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isInteger.js");
/* harmony import */ var _assoc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assoc */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assoc.js");
/* harmony import */ var _dissoc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dissoc */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dissoc.js");
/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./remove */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/remove.js");
/* harmony import */ var _update__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./update */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/update.js");







/**
 * Makes a shallow clone of an object, omitting the property at the given path.
 * Note that this copies and flattens prototype properties onto the new object
 * as well. All non-primitive properties are copied by reference.
 *
 * @func
 * @memberOf R
 * @since v0.11.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig [Idx] -> {k: v} -> {k: v}
 * @param {Array} path The path to the value to omit
 * @param {Object} obj The object to clone
 * @return {Object} A new object without the property at path
 * @see R.assocPath
 * @example
 *
 *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
 */
var dissocPath = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function dissocPath(path, obj) {
  switch (path.length) {
    case 0:
      return obj;
    case 1:
      return Object(_internal_isInteger__WEBPACK_IMPORTED_MODULE_1__["default"])(path[0]) ? Object(_remove__WEBPACK_IMPORTED_MODULE_4__["default"])(path[0], 1, obj) : Object(_dissoc__WEBPACK_IMPORTED_MODULE_3__["default"])(path[0], obj);
    default:
      var head = path[0];
      var tail = Array.prototype.slice.call(path, 1);
      if (obj[head] == null) {
        return obj;
      } else if (Object(_internal_isInteger__WEBPACK_IMPORTED_MODULE_1__["default"])(path[0])) {
        return Object(_update__WEBPACK_IMPORTED_MODULE_5__["default"])(head, dissocPath(tail, obj[head]), obj);
      } else {
        return Object(_assoc__WEBPACK_IMPORTED_MODULE_2__["default"])(head, dissocPath(tail, obj[head]), obj);
      }
  }
});
/* harmony default export */ __webpack_exports__["default"] = (dissocPath);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/divide.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/divide.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Divides two numbers. Equivalent to `a / b`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The first value.
 * @param {Number} b The second value.
 * @return {Number} The result of `a / b`.
 * @see R.multiply
 * @example
 *
 *      R.divide(71, 100); //=> 0.71
 *
 *      var half = R.divide(R.__, 2);
 *      half(42); //=> 21
 *
 *      var reciprocal = R.divide(1);
 *      reciprocal(4);   //=> 0.25
 */
var divide = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function divide(a, b) {
  return a / b;
});
/* harmony default export */ __webpack_exports__["default"] = (divide);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/drop.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/drop.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xdrop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xdrop */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdrop.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");





/**
 * Returns all but the first `n` elements of the given list, string, or
 * transducer/transformer (or object with a `drop` method).
 *
 * Dispatches to the `drop` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n
 * @param {*} list
 * @return {*} A copy of list without the first `n` elements
 * @see R.take, R.transduce, R.dropLast, R.dropWhile
 * @example
 *
 *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
 *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
 *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
 *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
 *      R.drop(3, 'ramda');               //=> 'da'
 */
var drop = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['drop'], _internal_xdrop__WEBPACK_IMPORTED_MODULE_2__["default"], function drop(n, xs) {
  return Object(_slice__WEBPACK_IMPORTED_MODULE_3__["default"])(Math.max(0, n), Infinity, xs);
}));
/* harmony default export */ __webpack_exports__["default"] = (drop);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropLast.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropLast.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_dropLast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_dropLast */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dropLast.js");
/* harmony import */ var _internal_xdropLast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_xdropLast */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropLast.js");





/**
 * Returns a list containing all but the last `n` elements of the given `list`.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n The number of elements of `list` to skip.
 * @param {Array} list The list of elements to consider.
 * @return {Array} A copy of the list with only the first `list.length - n` elements
 * @see R.takeLast, R.drop, R.dropWhile, R.dropLastWhile
 * @example
 *
 *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
 *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
 *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
 *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
 *      R.dropLast(3, 'ramda');               //=> 'ra'
 */
var dropLast = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xdropLast__WEBPACK_IMPORTED_MODULE_3__["default"], _internal_dropLast__WEBPACK_IMPORTED_MODULE_2__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (dropLast);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropLastWhile.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropLastWhile.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_dropLastWhile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_dropLastWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dropLastWhile.js");
/* harmony import */ var _internal_xdropLastWhile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_xdropLastWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropLastWhile.js");





/**
 * Returns a new list excluding all the tailing elements of a given list which
 * satisfy the supplied predicate function. It passes each value from the right
 * to the supplied predicate function, skipping elements until the predicate
 * function returns a `falsy` value. The predicate function is applied to one argument:
 * *(value)*.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @sig (a -> Boolean) -> String -> String
 * @param {Function} predicate The function to be called on each element
 * @param {Array} xs The collection to iterate over.
 * @return {Array} A new array without any trailing elements that return `falsy` values from the `predicate`.
 * @see R.takeLastWhile, R.addIndex, R.drop, R.dropWhile
 * @example
 *
 *      var lteThree = x => x <= 3;
 *
 *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
 *
 *      R.dropLastWhile(x => x !== 'd' , 'Ramda'); //=> 'Ramd'
 */
var dropLastWhile = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xdropLastWhile__WEBPACK_IMPORTED_MODULE_3__["default"], _internal_dropLastWhile__WEBPACK_IMPORTED_MODULE_2__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (dropLastWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropRepeats.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropRepeats.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xdropRepeatsWith__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xdropRepeatsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropRepeatsWith.js");
/* harmony import */ var _dropRepeatsWith__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dropRepeatsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropRepeatsWith.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");






/**
 * Returns a new list without any consecutively repeating elements.
 * [`R.equals`](#equals) is used to determine equality.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig [a] -> [a]
 * @param {Array} list The array to consider.
 * @return {Array} `list` without repeating elements.
 * @see R.transduce
 * @example
 *
 *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
 */
var dropRepeats = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], /*#__PURE__*/Object(_internal_xdropRepeatsWith__WEBPACK_IMPORTED_MODULE_2__["default"])(_equals__WEBPACK_IMPORTED_MODULE_4__["default"]), /*#__PURE__*/Object(_dropRepeatsWith__WEBPACK_IMPORTED_MODULE_3__["default"])(_equals__WEBPACK_IMPORTED_MODULE_4__["default"])));
/* harmony default export */ __webpack_exports__["default"] = (dropRepeats);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropRepeatsWith.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropRepeatsWith.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xdropRepeatsWith__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xdropRepeatsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropRepeatsWith.js");
/* harmony import */ var _last__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./last */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/last.js");





/**
 * Returns a new list without any consecutively repeating elements. Equality is
 * determined by applying the supplied predicate to each pair of consecutive elements. The
 * first element in a series of equal elements will be preserved.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig ((a, a) -> Boolean) -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list The array to consider.
 * @return {Array} `list` without repeating elements.
 * @see R.transduce
 * @example
 *
 *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
 *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
 */
var dropRepeatsWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xdropRepeatsWith__WEBPACK_IMPORTED_MODULE_2__["default"], function dropRepeatsWith(pred, list) {
  var result = [];
  var idx = 1;
  var len = list.length;
  if (len !== 0) {
    result[0] = list[0];
    while (idx < len) {
      if (!pred(Object(_last__WEBPACK_IMPORTED_MODULE_3__["default"])(result), list[idx])) {
        result[result.length] = list[idx];
      }
      idx += 1;
    }
  }
  return result;
}));
/* harmony default export */ __webpack_exports__["default"] = (dropRepeatsWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropWhile.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropWhile.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xdropWhile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xdropWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropWhile.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");





/**
 * Returns a new list excluding the leading elements of a given list which
 * satisfy the supplied predicate function. It passes each value to the supplied
 * predicate function, skipping elements while the predicate function returns
 * `true`. The predicate function is applied to one argument: *(value)*.
 *
 * Dispatches to the `dropWhile` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @sig (a -> Boolean) -> String -> String
 * @param {Function} fn The function called per iteration.
 * @param {Array} xs The collection to iterate over.
 * @return {Array} A new array.
 * @see R.takeWhile, R.transduce, R.addIndex
 * @example
 *
 *      var lteTwo = x => x <= 2;
 *
 *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
 *
 *      R.dropWhile(x => x !== 'd' , 'Ramda'); //=> 'da'
 */
var dropWhile = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['dropWhile'], _internal_xdropWhile__WEBPACK_IMPORTED_MODULE_2__["default"], function dropWhile(pred, xs) {
  var idx = 0;
  var len = xs.length;
  while (idx < len && pred(xs[idx])) {
    idx += 1;
  }
  return Object(_slice__WEBPACK_IMPORTED_MODULE_3__["default"])(idx, Infinity, xs);
}));
/* harmony default export */ __webpack_exports__["default"] = (dropWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/either.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/either.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isFunction */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isFunction.js");
/* harmony import */ var _lift__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lift */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lift.js");
/* harmony import */ var _or__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./or */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/or.js");





/**
 * A function wrapping calls to the two functions in an `||` operation,
 * returning the result of the first function if it is truth-y and the result
 * of the second function otherwise. Note that this is short-circuited,
 * meaning that the second function will not be invoked if the first returns a
 * truth-y value.
 *
 * In addition to functions, `R.either` also accepts any fantasy-land compatible
 * applicative functor.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
 * @param {Function} f a predicate
 * @param {Function} g another predicate
 * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
 * @see R.or
 * @example
 *
 *      var gt10 = x => x > 10;
 *      var even = x => x % 2 === 0;
 *      var f = R.either(gt10, even);
 *      f(101); //=> true
 *      f(8); //=> true
 */
var either = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function either(f, g) {
  return Object(_internal_isFunction__WEBPACK_IMPORTED_MODULE_1__["default"])(f) ? function _either() {
    return f.apply(this, arguments) || g.apply(this, arguments);
  } : Object(_lift__WEBPACK_IMPORTED_MODULE_2__["default"])(_or__WEBPACK_IMPORTED_MODULE_3__["default"])(f, g);
});
/* harmony default export */ __webpack_exports__["default"] = (either);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/empty.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/empty.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_isArguments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isArguments */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArguments.js");
/* harmony import */ var _internal_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");
/* harmony import */ var _internal_isObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_isObject */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isObject.js");
/* harmony import */ var _internal_isString__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/_isString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isString.js");






/**
 * Returns the empty value of its argument's type. Ramda defines the empty
 * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
 * types are supported if they define `<Type>.empty`,
 * `<Type>.prototype.empty` or implement the
 * [FantasyLand Monoid spec](https://github.com/fantasyland/fantasy-land#monoid).
 *
 * Dispatches to the `empty` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Function
 * @sig a -> a
 * @param {*} x
 * @return {*}
 * @example
 *
 *      R.empty(Just(42));      //=> Nothing()
 *      R.empty([1, 2, 3]);     //=> []
 *      R.empty('unicorns');    //=> ''
 *      R.empty({x: 1, y: 2});  //=> {}
 */
var empty = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function empty(x) {
  return x != null && typeof x['fantasy-land/empty'] === 'function' ? x['fantasy-land/empty']() : x != null && x.constructor != null && typeof x.constructor['fantasy-land/empty'] === 'function' ? x.constructor['fantasy-land/empty']() : x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : Object(_internal_isArray__WEBPACK_IMPORTED_MODULE_2__["default"])(x) ? [] : Object(_internal_isString__WEBPACK_IMPORTED_MODULE_4__["default"])(x) ? '' : Object(_internal_isObject__WEBPACK_IMPORTED_MODULE_3__["default"])(x) ? {} : Object(_internal_isArguments__WEBPACK_IMPORTED_MODULE_1__["default"])(x) ? function () {
    return arguments;
  }() :
  // else
  void 0;
});
/* harmony default export */ __webpack_exports__["default"] = (empty);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/endsWith.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/endsWith.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");
/* harmony import */ var _takeLast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./takeLast */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeLast.js");




/**
 * Checks if a list ends with the provided values
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category List
 * @sig [a] -> Boolean
 * @sig String -> Boolean
 * @param {*} suffix
 * @param {*} list
 * @return {Boolean}
 * @example
 *
 *      R.endsWith('c', 'abc')                //=> true
 *      R.endsWith('b', 'abc')                //=> false
 *      R.endsWith(['c'], ['a', 'b', 'c'])    //=> true
 *      R.endsWith(['b'], ['a', 'b', 'c'])    //=> false
 */
var endsWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function (suffix, list) {
  return Object(_equals__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_takeLast__WEBPACK_IMPORTED_MODULE_2__["default"])(suffix.length, list), suffix);
});
/* harmony default export */ __webpack_exports__["default"] = (endsWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/eqBy.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/eqBy.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");



/**
 * Takes a function and two values in its domain and returns `true` if the
 * values map to the same value in the codomain; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Relation
 * @sig (a -> b) -> a -> a -> Boolean
 * @param {Function} f
 * @param {*} x
 * @param {*} y
 * @return {Boolean}
 * @example
 *
 *      R.eqBy(Math.abs, 5, -5); //=> true
 */
var eqBy = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function eqBy(f, x, y) {
  return Object(_equals__WEBPACK_IMPORTED_MODULE_1__["default"])(f(x), f(y));
});
/* harmony default export */ __webpack_exports__["default"] = (eqBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/eqProps.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/eqProps.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");



/**
 * Reports whether two objects have the same value, in [`R.equals`](#equals)
 * terms, for the specified property. Useful as a curried predicate.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig k -> {k: v} -> {k: v} -> Boolean
 * @param {String} prop The name of the property to compare
 * @param {Object} obj1
 * @param {Object} obj2
 * @return {Boolean}
 *
 * @example
 *
 *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
 *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
 *      R.eqProps('a', o1, o2); //=> false
 *      R.eqProps('c', o1, o2); //=> true
 */
var eqProps = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function eqProps(prop, obj1, obj2) {
  return Object(_equals__WEBPACK_IMPORTED_MODULE_1__["default"])(obj1[prop], obj2[prop]);
});
/* harmony default export */ __webpack_exports__["default"] = (eqProps);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_equals.js");



/**
 * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
 * cyclical data structures.
 *
 * Dispatches symmetrically to the `equals` methods of both arguments, if
 * present.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> b -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      R.equals(1, 1); //=> true
 *      R.equals(1, '1'); //=> false
 *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
 *
 *      var a = {}; a.v = a;
 *      var b = {}; b.v = b;
 *      R.equals(a, b); //=> true
 */
var equals = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function equals(a, b) {
  return Object(_internal_equals__WEBPACK_IMPORTED_MODULE_1__["default"])(a, b, [], []);
});
/* harmony default export */ __webpack_exports__["default"] = (equals);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/evolve.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/evolve.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Creates a new object by recursively evolving a shallow copy of `object`,
 * according to the `transformation` functions. All non-primitive properties
 * are copied by reference.
 *
 * A `transformation` function will not be invoked if its corresponding key
 * does not exist in the evolved object.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig {k: (v -> v)} -> {k: v} -> {k: v}
 * @param {Object} transformations The object specifying transformation functions to apply
 *        to the object.
 * @param {Object} object The object to be transformed.
 * @return {Object} The transformed object.
 * @example
 *
 *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
 *      var transformations = {
 *        firstName: R.trim,
 *        lastName: R.trim, // Will not get invoked.
 *        data: {elapsed: R.add(1), remaining: R.add(-1)}
 *      };
 *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
 */
var evolve = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function evolve(transformations, object) {
  var result = {};
  var transformation, key, type;
  for (key in object) {
    transformation = transformations[key];
    type = typeof transformation;
    result[key] = type === 'function' ? transformation(object[key]) : transformation && type === 'object' ? evolve(transformation, object[key]) : object[key];
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (evolve);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/filter.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/filter.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_filter */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_filter.js");
/* harmony import */ var _internal_isObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_isObject */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isObject.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _internal_xfilter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./internal/_xfilter */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfilter.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");








/**
 * Takes a predicate and a `Filterable`, and returns a new filterable of the
 * same type containing the members of the given filterable which satisfy the
 * given predicate. Filterable objects include plain objects or any object
 * that has a filter method such as `Array`.
 *
 * Dispatches to the `filter` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array} Filterable
 * @see R.reject, R.transduce, R.addIndex
 * @example
 *
 *      var isEven = n => n % 2 === 0;
 *
 *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */
var filter = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['filter'], _internal_xfilter__WEBPACK_IMPORTED_MODULE_5__["default"], function (pred, filterable) {
  return Object(_internal_isObject__WEBPACK_IMPORTED_MODULE_3__["default"])(filterable) ? Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_4__["default"])(function (acc, key) {
    if (pred(filterable[key])) {
      acc[key] = filterable[key];
    }
    return acc;
  }, {}, Object(_keys__WEBPACK_IMPORTED_MODULE_6__["default"])(filterable)) :
  // else
  Object(_internal_filter__WEBPACK_IMPORTED_MODULE_2__["default"])(pred, filterable);
}));
/* harmony default export */ __webpack_exports__["default"] = (filter);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/find.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/find.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xfind__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xfind */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfind.js");




/**
 * Returns the first element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Dispatches to the `find` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> a | undefined
 * @param {Function} fn The predicate function used to determine if the element is the
 *        desired one.
 * @param {Array} list The array to consider.
 * @return {Object} The element found, or `undefined`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
 *      R.find(R.propEq('a', 4))(xs); //=> undefined
 */
var find = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['find'], _internal_xfind__WEBPACK_IMPORTED_MODULE_2__["default"], function find(fn, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    if (fn(list[idx])) {
      return list[idx];
    }
    idx += 1;
  }
}));
/* harmony default export */ __webpack_exports__["default"] = (find);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findIndex.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findIndex.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xfindIndex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xfindIndex */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindIndex.js");




/**
 * Returns the index of the first element of the list which matches the
 * predicate, or `-1` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> Number
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Number} The index of the element found, or `-1`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
 *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
 */
var findIndex = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xfindIndex__WEBPACK_IMPORTED_MODULE_2__["default"], function findIndex(fn, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    if (fn(list[idx])) {
      return idx;
    }
    idx += 1;
  }
  return -1;
}));
/* harmony default export */ __webpack_exports__["default"] = (findIndex);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findLast.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findLast.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xfindLast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xfindLast */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindLast.js");




/**
 * Returns the last element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> a | undefined
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Object} The element found, or `undefined`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
 *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
 *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
 */
var findLast = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xfindLast__WEBPACK_IMPORTED_MODULE_2__["default"], function findLast(fn, list) {
  var idx = list.length - 1;
  while (idx >= 0) {
    if (fn(list[idx])) {
      return list[idx];
    }
    idx -= 1;
  }
}));
/* harmony default export */ __webpack_exports__["default"] = (findLast);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findLastIndex.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findLastIndex.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xfindLastIndex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xfindLastIndex */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindLastIndex.js");




/**
 * Returns the index of the last element of the list which matches the
 * predicate, or `-1` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> Number
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Number} The index of the element found, or `-1`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
 *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
 *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
 */
var findLastIndex = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xfindLastIndex__WEBPACK_IMPORTED_MODULE_2__["default"], function findLastIndex(fn, list) {
  var idx = list.length - 1;
  while (idx >= 0) {
    if (fn(list[idx])) {
      return idx;
    }
    idx -= 1;
  }
  return -1;
}));
/* harmony default export */ __webpack_exports__["default"] = (findLastIndex);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flatten.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flatten.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_makeFlat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_makeFlat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_makeFlat.js");



/**
 * Returns a new list by pulling every item out of it (and all its sub-arrays)
 * and putting them in a new array, depth-first.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [b]
 * @param {Array} list The array to consider.
 * @return {Array} The flattened list.
 * @see R.unnest
 * @example
 *
 *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
 *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
 */
var flatten = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_makeFlat__WEBPACK_IMPORTED_MODULE_1__["default"])(true));
/* harmony default export */ __webpack_exports__["default"] = (flatten);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flip.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flip.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");



/**
 * Returns a new function much like the supplied one, except that the first two
 * arguments' order is reversed.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((a, b, c, ...) -> z) -> (b -> a -> c -> ... -> z)
 * @param {Function} fn The function to invoke with its first two parameters reversed.
 * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
 * @example
 *
 *      var mergeThree = (a, b, c) => [].concat(a, b, c);
 *
 *      mergeThree(1, 2, 3); //=> [1, 2, 3]
 *
 *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
 * @symb R.flip(f)(a, b, c) = f(b, a, c)
 */
var flip = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function flip(fn) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(fn.length, function (a, b) {
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = b;
    args[1] = a;
    return fn.apply(this, args);
  });
});
/* harmony default export */ __webpack_exports__["default"] = (flip);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/forEach.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/forEach.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_checkForMethod */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_checkForMethod.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Iterate over an input `list`, calling a provided function `fn` for each
 * element in the list.
 *
 * `fn` receives one argument: *(value)*.
 *
 * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.forEach` method. For more
 * details on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
 *
 * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
 * the original array. In some libraries this function is named `each`.
 *
 * Dispatches to the `forEach` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> *) -> [a] -> [a]
 * @param {Function} fn The function to invoke. Receives one argument, `value`.
 * @param {Array} list The list to iterate over.
 * @return {Array} The original list.
 * @see R.addIndex
 * @example
 *
 *      var printXPlusFive = x => console.log(x + 5);
 *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
 *      // logs 6
 *      // logs 7
 *      // logs 8
 * @symb R.forEach(f, [a, b, c]) = [a, b, c]
 */
var forEach = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__["default"])('forEach', function forEach(fn, list) {
  var len = list.length;
  var idx = 0;
  while (idx < len) {
    fn(list[idx]);
    idx += 1;
  }
  return list;
}));
/* harmony default export */ __webpack_exports__["default"] = (forEach);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/forEachObjIndexed.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/forEachObjIndexed.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");



/**
 * Iterate over an input `object`, calling a provided function `fn` for each
 * key and value in the object.
 *
 * `fn` receives three argument: *(value, key, obj)*.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Object
 * @sig ((a, String, StrMap a) -> Any) -> StrMap a -> StrMap a
 * @param {Function} fn The function to invoke. Receives three argument, `value`, `key`, `obj`.
 * @param {Object} obj The object to iterate over.
 * @return {Object} The original object.
 * @example
 *
 *      var printKeyConcatValue = (value, key) => console.log(key + ':' + value);
 *      R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=> {x: 1, y: 2}
 *      // logs x:1
 *      // logs y:2
 * @symb R.forEachObjIndexed(f, {x: a, y: b}) = {x: a, y: b}
 */
var forEachObjIndexed = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function forEachObjIndexed(fn, obj) {
  var keyList = Object(_keys__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
  var idx = 0;
  while (idx < keyList.length) {
    var key = keyList[idx];
    fn(obj[key], key, obj);
    idx += 1;
  }
  return obj;
});
/* harmony default export */ __webpack_exports__["default"] = (forEachObjIndexed);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/fromPairs.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/fromPairs.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Creates a new object from a list key-value pairs. If a key appears in
 * multiple pairs, the rightmost pair is included in the object.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig [[k,v]] -> {k: v}
 * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
 * @return {Object} The object made by pairing up `keys` and `values`.
 * @see R.toPairs, R.pair
 * @example
 *
 *      R.fromPairs([['a', 1], ['b', 2], ['c', 3]]); //=> {a: 1, b: 2, c: 3}
 */
var fromPairs = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function fromPairs(pairs) {
  var result = {};
  var idx = 0;
  while (idx < pairs.length) {
    result[pairs[idx][0]] = pairs[idx][1];
    idx += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (fromPairs);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/groupBy.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/groupBy.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_checkForMethod */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_checkForMethod.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduceBy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reduceBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceBy.js");




/**
 * Splits a list into sub-lists stored in an object, based on the result of
 * calling a String-returning function on each element, and grouping the
 * results according to values returned.
 *
 * Dispatches to the `groupBy` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> String) -> [a] -> {String: [a]}
 * @param {Function} fn Function :: a -> String
 * @param {Array} list The array to group
 * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
 *         that produced that key when passed to `fn`.
 * @see R.transduce
 * @example
 *
 *      var byGrade = R.groupBy(function(student) {
 *        var score = student.score;
 *        return score < 65 ? 'F' :
 *               score < 70 ? 'D' :
 *               score < 80 ? 'C' :
 *               score < 90 ? 'B' : 'A';
 *      });
 *      var students = [{name: 'Abby', score: 84},
 *                      {name: 'Eddy', score: 58},
 *                      // ...
 *                      {name: 'Jack', score: 69}];
 *      byGrade(students);
 *      // {
 *      //   'A': [{name: 'Dianne', score: 99}],
 *      //   'B': [{name: 'Abby', score: 84}]
 *      //   // ...,
 *      //   'F': [{name: 'Eddy', score: 58}]
 *      // }
 */
var groupBy = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__["default"])('groupBy', /*#__PURE__*/Object(_reduceBy__WEBPACK_IMPORTED_MODULE_2__["default"])(function (acc, item) {
  if (acc == null) {
    acc = [];
  }
  acc.push(item);
  return acc;
}, null)));
/* harmony default export */ __webpack_exports__["default"] = (groupBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/groupWith.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/groupWith.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Takes a list and returns a list of lists where each sublist's elements are
 * all satisfied pairwise comparison according to the provided function.
 * Only adjacent elements are passed to the comparison function.
 *
 * @func
 * @memberOf R
 * @since v0.21.0
 * @category List
 * @sig ((a, a) â Boolean) â [a] â [[a]]
 * @param {Function} fn Function for determining whether two given (adjacent)
 *        elements should be in the same group
 * @param {Array} list The array to group. Also accepts a string, which will be
 *        treated as a list of characters.
 * @return {List} A list that contains sublists of elements,
 *         whose concatenations are equal to the original list.
 * @example
 *
 * R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
 * //=> [[0], [1, 1], [2], [3], [5], [8], [13], [21]]
 *
 * R.groupWith((a, b) => a + 1 === b, [0, 1, 1, 2, 3, 5, 8, 13, 21])
 * //=> [[0, 1], [1, 2, 3], [5], [8], [13], [21]]
 *
 * R.groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
 * //=> [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
 *
 * R.groupWith(R.eqBy(isVowel), 'aestiou')
 * //=> ['ae', 'st', 'iou']
 */
var groupWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function (fn, list) {
  var res = [];
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    var nextidx = idx + 1;
    while (nextidx < len && fn(list[nextidx - 1], list[nextidx])) {
      nextidx += 1;
    }
    res.push(list.slice(idx, nextidx));
    idx = nextidx;
  }
  return res;
});
/* harmony default export */ __webpack_exports__["default"] = (groupWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/gt.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/gt.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns `true` if the first argument is greater than the second; `false`
 * otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @see R.lt
 * @example
 *
 *      R.gt(2, 1); //=> true
 *      R.gt(2, 2); //=> false
 *      R.gt(2, 3); //=> false
 *      R.gt('a', 'z'); //=> false
 *      R.gt('z', 'a'); //=> true
 */
var gt = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function gt(a, b) {
  return a > b;
});
/* harmony default export */ __webpack_exports__["default"] = (gt);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/gte.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/gte.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns `true` if the first argument is greater than or equal to the second;
 * `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {Number} a
 * @param {Number} b
 * @return {Boolean}
 * @see R.lte
 * @example
 *
 *      R.gte(2, 1); //=> true
 *      R.gte(2, 2); //=> true
 *      R.gte(2, 3); //=> false
 *      R.gte('a', 'z'); //=> false
 *      R.gte('z', 'a'); //=> true
 */
var gte = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function gte(a, b) {
  return a >= b;
});
/* harmony default export */ __webpack_exports__["default"] = (gte);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/has.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/has.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");



/**
 * Returns whether or not an object has an own property with the specified name
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Object
 * @sig s -> {s: x} -> Boolean
 * @param {String} prop The name of the property to check for.
 * @param {Object} obj The object to query.
 * @return {Boolean} Whether the property exists.
 * @example
 *
 *      var hasName = R.has('name');
 *      hasName({name: 'alice'});   //=> true
 *      hasName({name: 'bob'});     //=> true
 *      hasName({});                //=> false
 *
 *      var point = {x: 0, y: 0};
 *      var pointHas = R.has(R.__, point);
 *      pointHas('x');  //=> true
 *      pointHas('y');  //=> true
 *      pointHas('z');  //=> false
 */
var has = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (has);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/hasIn.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/hasIn.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns whether or not an object or its prototype chain has a property with
 * the specified name
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Object
 * @sig s -> {s: x} -> Boolean
 * @param {String} prop The name of the property to check for.
 * @param {Object} obj The object to query.
 * @return {Boolean} Whether the property exists.
 * @example
 *
 *      function Rectangle(width, height) {
 *        this.width = width;
 *        this.height = height;
 *      }
 *      Rectangle.prototype.area = function() {
 *        return this.width * this.height;
 *      };
 *
 *      var square = new Rectangle(2, 2);
 *      R.hasIn('width', square);  //=> true
 *      R.hasIn('area', square);  //=> true
 */
var hasIn = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function hasIn(prop, obj) {
  return prop in obj;
});
/* harmony default export */ __webpack_exports__["default"] = (hasIn);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/head.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/head.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nth */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nth.js");


/**
 * Returns the first element of the given list or string. In some libraries
 * this function is named `first`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> a | Undefined
 * @sig String -> String
 * @param {Array|String} list
 * @return {*}
 * @see R.tail, R.init, R.last
 * @example
 *
 *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
 *      R.head([]); //=> undefined
 *
 *      R.head('abc'); //=> 'a'
 *      R.head(''); //=> ''
 */
var head = /*#__PURE__*/Object(_nth__WEBPACK_IMPORTED_MODULE_0__["default"])(0);
/* harmony default export */ __webpack_exports__["default"] = (head);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identical.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identical.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns true if its arguments are identical, false otherwise. Values are
 * identical if they reference the same memory. `NaN` is identical to `NaN`;
 * `0` and `-0` are not identical.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      var o = {};
 *      R.identical(o, o); //=> true
 *      R.identical(1, 1); //=> true
 *      R.identical(1, '1'); //=> false
 *      R.identical([], []); //=> false
 *      R.identical(0, -0); //=> false
 *      R.identical(NaN, NaN); //=> true
 */
var identical = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function identical(a, b) {
  // SameValue algorithm
  if (a === b) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return a !== 0 || 1 / a === 1 / b;
  } else {
    // Step 6.a: NaN == NaN
    return a !== a && b !== b;
  }
});
/* harmony default export */ __webpack_exports__["default"] = (identical);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identity.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identity.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_identity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_identity.js");



/**
 * A function that does nothing but return the parameter supplied to it. Good
 * as a default or placeholder function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig a -> a
 * @param {*} x The value to return.
 * @return {*} The input value, `x`.
 * @example
 *
 *      R.identity(1); //=> 1
 *
 *      var obj = {};
 *      R.identity(obj) === obj; //=> true
 * @symb R.identity(a) = a
 */
var identity = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(_internal_identity__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (identity);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ifElse.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ifElse.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");



/**
 * Creates a function that will process either the `onTrue` or the `onFalse`
 * function depending upon the result of the `condition` predicate.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
 * @param {Function} condition A predicate function
 * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
 * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
 * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
 *                    function depending upon the result of the `condition` predicate.
 * @see R.unless, R.when
 * @example
 *
 *      var incCount = R.ifElse(
 *        R.has('count'),
 *        R.over(R.lensProp('count'), R.inc),
 *        R.assoc('count', 1)
 *      );
 *      incCount({});           //=> { count: 1 }
 *      incCount({ count: 1 }); //=> { count: 2 }
 */
var ifElse = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function ifElse(condition, onTrue, onFalse) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
    return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
  });
});
/* harmony default export */ __webpack_exports__["default"] = (ifElse);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/inc.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/inc.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _add__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/add.js");


/**
 * Increments its argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Math
 * @sig Number -> Number
 * @param {Number} n
 * @return {Number} n + 1
 * @see R.dec
 * @example
 *
 *      R.inc(42); //=> 43
 */
var inc = /*#__PURE__*/Object(_add__WEBPACK_IMPORTED_MODULE_0__["default"])(1);
/* harmony default export */ __webpack_exports__["default"] = (inc);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js ***!
  \**************************************************************************************/
/*! exports provided: F, T, __, add, addIndex, adjust, all, allPass, always, and, any, anyPass, ap, aperture, append, apply, applySpec, applyTo, ascend, assoc, assocPath, binary, bind, both, call, chain, clamp, clone, comparator, complement, compose, composeK, composeP, concat, cond, construct, constructN, contains, converge, countBy, curry, curryN, dec, defaultTo, descend, difference, differenceWith, dissoc, dissocPath, divide, drop, dropLast, dropLastWhile, dropRepeats, dropRepeatsWith, dropWhile, either, empty, endsWith, eqBy, eqProps, equals, evolve, filter, find, findIndex, findLast, findLastIndex, flatten, flip, forEach, forEachObjIndexed, fromPairs, groupBy, groupWith, gt, gte, has, hasIn, head, identical, identity, ifElse, inc, indexBy, indexOf, init, innerJoin, insert, insertAll, intersection, intersperse, into, invert, invertObj, invoker, is, isEmpty, isNil, join, juxt, keys, keysIn, last, lastIndexOf, length, lens, lensIndex, lensPath, lensProp, lift, liftN, lt, lte, map, mapAccum, mapAccumRight, mapObjIndexed, match, mathMod, max, maxBy, mean, median, memoize, memoizeWith, merge, mergeAll, mergeDeepLeft, mergeDeepRight, mergeDeepWith, mergeDeepWithKey, mergeWith, mergeWithKey, min, minBy, modulo, multiply, nAry, negate, none, not, nth, nthArg, o, objOf, of, omit, once, or, over, pair, partial, partialRight, partition, path, pathEq, pathOr, pathSatisfies, pick, pickAll, pickBy, pipe, pipeK, pipeP, pluck, prepend, product, project, prop, propEq, propIs, propOr, propSatisfies, props, range, reduce, reduceBy, reduceRight, reduceWhile, reduced, reject, remove, repeat, replace, reverse, scan, sequence, set, slice, sort, sortBy, sortWith, split, splitAt, splitEvery, splitWhen, startsWith, subtract, sum, symmetricDifference, symmetricDifferenceWith, tail, take, takeLast, takeLastWhile, takeWhile, tap, test, times, toLower, toPairs, toPairsIn, toString, toUpper, transduce, transpose, traverse, trim, tryCatch, type, unapply, unary, uncurryN, unfold, union, unionWith, uniq, uniqBy, uniqWith, unless, unnest, until, update, useWith, values, valuesIn, view, when, where, whereEq, without, xprod, zip, zipObj, zipWith */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _F__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./F */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/F.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "F", function() { return _F__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _T__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./T */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/T.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "T", function() { return _T__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./__ */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/__.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "__", function() { return ___WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _add__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./add */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/add.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "add", function() { return _add__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _addIndex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./addIndex */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/addIndex.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addIndex", function() { return _addIndex__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _adjust__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./adjust */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/adjust.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "adjust", function() { return _adjust__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _all__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./all */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/all.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "all", function() { return _all__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _allPass__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./allPass */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/allPass.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allPass", function() { return _allPass__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _always__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./always */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "always", function() { return _always__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _and__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./and */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/and.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "and", function() { return _and__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _any__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./any */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/any.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "any", function() { return _any__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _anyPass__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./anyPass */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/anyPass.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "anyPass", function() { return _anyPass__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _ap__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ap", function() { return _ap__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _aperture__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./aperture */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/aperture.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "aperture", function() { return _aperture__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _append__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./append */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/append.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "append", function() { return _append__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _apply__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./apply */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/apply.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "apply", function() { return _apply__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _applySpec__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./applySpec */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/applySpec.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applySpec", function() { return _applySpec__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _applyTo__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./applyTo */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/applyTo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyTo", function() { return _applyTo__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _ascend__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./ascend */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ascend.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ascend", function() { return _ascend__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _assoc__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./assoc */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assoc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assoc", function() { return _assoc__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _assocPath__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./assocPath */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assocPath.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assocPath", function() { return _assocPath__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _binary__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./binary */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/binary.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "binary", function() { return _binary__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _bind__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./bind */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/bind.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bind", function() { return _bind__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _both__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./both */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/both.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "both", function() { return _both__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _call__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./call */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/call.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "call", function() { return _call__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _chain__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./chain */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/chain.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chain", function() { return _chain__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _clamp__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./clamp */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/clamp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return _clamp__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _clone__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./clone */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/clone.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _clone__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony import */ var _comparator__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./comparator */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/comparator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "comparator", function() { return _comparator__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony import */ var _complement__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./complement */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/complement.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "complement", function() { return _complement__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./compose */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/compose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return _compose__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony import */ var _composeK__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./composeK */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/composeK.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "composeK", function() { return _composeK__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _composeP__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./composeP */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/composeP.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "composeP", function() { return _composeP__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony import */ var _concat__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/concat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return _concat__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony import */ var _cond__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./cond */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/cond.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cond", function() { return _cond__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony import */ var _construct__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./construct */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/construct.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "construct", function() { return _construct__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony import */ var _constructN__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./constructN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/constructN.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "constructN", function() { return _constructN__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony import */ var _contains__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./contains */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/contains.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "contains", function() { return _contains__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony import */ var _converge__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./converge */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/converge.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "converge", function() { return _converge__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony import */ var _countBy__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./countBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/countBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "countBy", function() { return _countBy__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony import */ var _curry__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./curry */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curry", function() { return _curry__WEBPACK_IMPORTED_MODULE_40__["default"]; });

/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curryN", function() { return _curryN__WEBPACK_IMPORTED_MODULE_41__["default"]; });

/* harmony import */ var _dec__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./dec */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dec.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dec", function() { return _dec__WEBPACK_IMPORTED_MODULE_42__["default"]; });

/* harmony import */ var _defaultTo__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./defaultTo */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/defaultTo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultTo", function() { return _defaultTo__WEBPACK_IMPORTED_MODULE_43__["default"]; });

/* harmony import */ var _descend__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./descend */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/descend.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "descend", function() { return _descend__WEBPACK_IMPORTED_MODULE_44__["default"]; });

/* harmony import */ var _difference__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./difference */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/difference.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "difference", function() { return _difference__WEBPACK_IMPORTED_MODULE_45__["default"]; });

/* harmony import */ var _differenceWith__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./differenceWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/differenceWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "differenceWith", function() { return _differenceWith__WEBPACK_IMPORTED_MODULE_46__["default"]; });

/* harmony import */ var _dissoc__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./dissoc */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dissoc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dissoc", function() { return _dissoc__WEBPACK_IMPORTED_MODULE_47__["default"]; });

/* harmony import */ var _dissocPath__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./dissocPath */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dissocPath.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dissocPath", function() { return _dissocPath__WEBPACK_IMPORTED_MODULE_48__["default"]; });

/* harmony import */ var _divide__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./divide */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/divide.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return _divide__WEBPACK_IMPORTED_MODULE_49__["default"]; });

/* harmony import */ var _drop__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./drop */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/drop.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drop", function() { return _drop__WEBPACK_IMPORTED_MODULE_50__["default"]; });

/* harmony import */ var _dropLast__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./dropLast */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropLast.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dropLast", function() { return _dropLast__WEBPACK_IMPORTED_MODULE_51__["default"]; });

/* harmony import */ var _dropLastWhile__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./dropLastWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropLastWhile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dropLastWhile", function() { return _dropLastWhile__WEBPACK_IMPORTED_MODULE_52__["default"]; });

/* harmony import */ var _dropRepeats__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./dropRepeats */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropRepeats.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dropRepeats", function() { return _dropRepeats__WEBPACK_IMPORTED_MODULE_53__["default"]; });

/* harmony import */ var _dropRepeatsWith__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./dropRepeatsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropRepeatsWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dropRepeatsWith", function() { return _dropRepeatsWith__WEBPACK_IMPORTED_MODULE_54__["default"]; });

/* harmony import */ var _dropWhile__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./dropWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/dropWhile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dropWhile", function() { return _dropWhile__WEBPACK_IMPORTED_MODULE_55__["default"]; });

/* harmony import */ var _either__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./either */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/either.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "either", function() { return _either__WEBPACK_IMPORTED_MODULE_56__["default"]; });

/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./empty */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/empty.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "empty", function() { return _empty__WEBPACK_IMPORTED_MODULE_57__["default"]; });

/* harmony import */ var _endsWith__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./endsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/endsWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "endsWith", function() { return _endsWith__WEBPACK_IMPORTED_MODULE_58__["default"]; });

/* harmony import */ var _eqBy__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./eqBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/eqBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eqBy", function() { return _eqBy__WEBPACK_IMPORTED_MODULE_59__["default"]; });

/* harmony import */ var _eqProps__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./eqProps */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/eqProps.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eqProps", function() { return _eqProps__WEBPACK_IMPORTED_MODULE_60__["default"]; });

/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return _equals__WEBPACK_IMPORTED_MODULE_61__["default"]; });

/* harmony import */ var _evolve__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./evolve */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/evolve.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "evolve", function() { return _evolve__WEBPACK_IMPORTED_MODULE_62__["default"]; });

/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./filter */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/filter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return _filter__WEBPACK_IMPORTED_MODULE_63__["default"]; });

/* harmony import */ var _find__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./find */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/find.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "find", function() { return _find__WEBPACK_IMPORTED_MODULE_64__["default"]; });

/* harmony import */ var _findIndex__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./findIndex */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findIndex.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return _findIndex__WEBPACK_IMPORTED_MODULE_65__["default"]; });

/* harmony import */ var _findLast__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./findLast */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findLast.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findLast", function() { return _findLast__WEBPACK_IMPORTED_MODULE_66__["default"]; });

/* harmony import */ var _findLastIndex__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./findLastIndex */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/findLastIndex.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findLastIndex", function() { return _findLastIndex__WEBPACK_IMPORTED_MODULE_67__["default"]; });

/* harmony import */ var _flatten__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./flatten */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flatten.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return _flatten__WEBPACK_IMPORTED_MODULE_68__["default"]; });

/* harmony import */ var _flip__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./flip */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flip", function() { return _flip__WEBPACK_IMPORTED_MODULE_69__["default"]; });

/* harmony import */ var _forEach__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./forEach */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/forEach.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return _forEach__WEBPACK_IMPORTED_MODULE_70__["default"]; });

/* harmony import */ var _forEachObjIndexed__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./forEachObjIndexed */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/forEachObjIndexed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEachObjIndexed", function() { return _forEachObjIndexed__WEBPACK_IMPORTED_MODULE_71__["default"]; });

/* harmony import */ var _fromPairs__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./fromPairs */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/fromPairs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fromPairs", function() { return _fromPairs__WEBPACK_IMPORTED_MODULE_72__["default"]; });

/* harmony import */ var _groupBy__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./groupBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/groupBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "groupBy", function() { return _groupBy__WEBPACK_IMPORTED_MODULE_73__["default"]; });

/* harmony import */ var _groupWith__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./groupWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/groupWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "groupWith", function() { return _groupWith__WEBPACK_IMPORTED_MODULE_74__["default"]; });

/* harmony import */ var _gt__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./gt */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/gt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gt", function() { return _gt__WEBPACK_IMPORTED_MODULE_75__["default"]; });

/* harmony import */ var _gte__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./gte */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/gte.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gte", function() { return _gte__WEBPACK_IMPORTED_MODULE_76__["default"]; });

/* harmony import */ var _has__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/has.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "has", function() { return _has__WEBPACK_IMPORTED_MODULE_77__["default"]; });

/* harmony import */ var _hasIn__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./hasIn */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/hasIn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasIn", function() { return _hasIn__WEBPACK_IMPORTED_MODULE_78__["default"]; });

/* harmony import */ var _head__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./head */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/head.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "head", function() { return _head__WEBPACK_IMPORTED_MODULE_79__["default"]; });

/* harmony import */ var _identical__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./identical */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identical.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "identical", function() { return _identical__WEBPACK_IMPORTED_MODULE_80__["default"]; });

/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./identity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identity.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return _identity__WEBPACK_IMPORTED_MODULE_81__["default"]; });

/* harmony import */ var _ifElse__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./ifElse */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ifElse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ifElse", function() { return _ifElse__WEBPACK_IMPORTED_MODULE_82__["default"]; });

/* harmony import */ var _inc__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./inc */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/inc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inc", function() { return _inc__WEBPACK_IMPORTED_MODULE_83__["default"]; });

/* harmony import */ var _indexBy__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./indexBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/indexBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "indexBy", function() { return _indexBy__WEBPACK_IMPORTED_MODULE_84__["default"]; });

/* harmony import */ var _indexOf__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./indexOf */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/indexOf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "indexOf", function() { return _indexOf__WEBPACK_IMPORTED_MODULE_85__["default"]; });

/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./init */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/init.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "init", function() { return _init__WEBPACK_IMPORTED_MODULE_86__["default"]; });

/* harmony import */ var _innerJoin__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./innerJoin */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/innerJoin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "innerJoin", function() { return _innerJoin__WEBPACK_IMPORTED_MODULE_87__["default"]; });

/* harmony import */ var _insert__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./insert */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/insert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "insert", function() { return _insert__WEBPACK_IMPORTED_MODULE_88__["default"]; });

/* harmony import */ var _insertAll__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./insertAll */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/insertAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "insertAll", function() { return _insertAll__WEBPACK_IMPORTED_MODULE_89__["default"]; });

/* harmony import */ var _intersection__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./intersection */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/intersection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "intersection", function() { return _intersection__WEBPACK_IMPORTED_MODULE_90__["default"]; });

/* harmony import */ var _intersperse__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./intersperse */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/intersperse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "intersperse", function() { return _intersperse__WEBPACK_IMPORTED_MODULE_91__["default"]; });

/* harmony import */ var _into__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./into */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/into.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "into", function() { return _into__WEBPACK_IMPORTED_MODULE_92__["default"]; });

/* harmony import */ var _invert__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./invert */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return _invert__WEBPACK_IMPORTED_MODULE_93__["default"]; });

/* harmony import */ var _invertObj__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./invertObj */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invertObj.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invertObj", function() { return _invertObj__WEBPACK_IMPORTED_MODULE_94__["default"]; });

/* harmony import */ var _invoker__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./invoker */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invoker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invoker", function() { return _invoker__WEBPACK_IMPORTED_MODULE_95__["default"]; });

/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./is */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/is.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "is", function() { return _is__WEBPACK_IMPORTED_MODULE_96__["default"]; });

/* harmony import */ var _isEmpty__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./isEmpty */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/isEmpty.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return _isEmpty__WEBPACK_IMPORTED_MODULE_97__["default"]; });

/* harmony import */ var _isNil__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./isNil */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/isNil.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNil", function() { return _isNil__WEBPACK_IMPORTED_MODULE_98__["default"]; });

/* harmony import */ var _join__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./join */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/join.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "join", function() { return _join__WEBPACK_IMPORTED_MODULE_99__["default"]; });

/* harmony import */ var _juxt__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./juxt */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/juxt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "juxt", function() { return _juxt__WEBPACK_IMPORTED_MODULE_100__["default"]; });

/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return _keys__WEBPACK_IMPORTED_MODULE_101__["default"]; });

/* harmony import */ var _keysIn__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./keysIn */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keysIn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keysIn", function() { return _keysIn__WEBPACK_IMPORTED_MODULE_102__["default"]; });

/* harmony import */ var _last__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./last */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/last.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "last", function() { return _last__WEBPACK_IMPORTED_MODULE_103__["default"]; });

/* harmony import */ var _lastIndexOf__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./lastIndexOf */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lastIndexOf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lastIndexOf", function() { return _lastIndexOf__WEBPACK_IMPORTED_MODULE_104__["default"]; });

/* harmony import */ var _length__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./length */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/length.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "length", function() { return _length__WEBPACK_IMPORTED_MODULE_105__["default"]; });

/* harmony import */ var _lens__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./lens */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lens.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lens", function() { return _lens__WEBPACK_IMPORTED_MODULE_106__["default"]; });

/* harmony import */ var _lensIndex__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./lensIndex */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensIndex.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lensIndex", function() { return _lensIndex__WEBPACK_IMPORTED_MODULE_107__["default"]; });

/* harmony import */ var _lensPath__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./lensPath */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensPath.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lensPath", function() { return _lensPath__WEBPACK_IMPORTED_MODULE_108__["default"]; });

/* harmony import */ var _lensProp__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./lensProp */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensProp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lensProp", function() { return _lensProp__WEBPACK_IMPORTED_MODULE_109__["default"]; });

/* harmony import */ var _lift__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./lift */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lift.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lift", function() { return _lift__WEBPACK_IMPORTED_MODULE_110__["default"]; });

/* harmony import */ var _liftN__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./liftN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/liftN.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "liftN", function() { return _liftN__WEBPACK_IMPORTED_MODULE_111__["default"]; });

/* harmony import */ var _lt__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./lt */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lt", function() { return _lt__WEBPACK_IMPORTED_MODULE_112__["default"]; });

/* harmony import */ var _lte__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./lte */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lte.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lte", function() { return _lte__WEBPACK_IMPORTED_MODULE_113__["default"]; });

/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _map__WEBPACK_IMPORTED_MODULE_114__["default"]; });

/* harmony import */ var _mapAccum__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./mapAccum */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapAccum.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mapAccum", function() { return _mapAccum__WEBPACK_IMPORTED_MODULE_115__["default"]; });

/* harmony import */ var _mapAccumRight__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./mapAccumRight */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapAccumRight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mapAccumRight", function() { return _mapAccumRight__WEBPACK_IMPORTED_MODULE_116__["default"]; });

/* harmony import */ var _mapObjIndexed__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./mapObjIndexed */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapObjIndexed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mapObjIndexed", function() { return _mapObjIndexed__WEBPACK_IMPORTED_MODULE_117__["default"]; });

/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_118__ = __webpack_require__(/*! ./match */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/match.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "match", function() { return _match__WEBPACK_IMPORTED_MODULE_118__["default"]; });

/* harmony import */ var _mathMod__WEBPACK_IMPORTED_MODULE_119__ = __webpack_require__(/*! ./mathMod */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mathMod.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mathMod", function() { return _mathMod__WEBPACK_IMPORTED_MODULE_119__["default"]; });

/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_120__ = __webpack_require__(/*! ./max */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _max__WEBPACK_IMPORTED_MODULE_120__["default"]; });

/* harmony import */ var _maxBy__WEBPACK_IMPORTED_MODULE_121__ = __webpack_require__(/*! ./maxBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/maxBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maxBy", function() { return _maxBy__WEBPACK_IMPORTED_MODULE_121__["default"]; });

/* harmony import */ var _mean__WEBPACK_IMPORTED_MODULE_122__ = __webpack_require__(/*! ./mean */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mean.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return _mean__WEBPACK_IMPORTED_MODULE_122__["default"]; });

/* harmony import */ var _median__WEBPACK_IMPORTED_MODULE_123__ = __webpack_require__(/*! ./median */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/median.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "median", function() { return _median__WEBPACK_IMPORTED_MODULE_123__["default"]; });

/* harmony import */ var _memoize__WEBPACK_IMPORTED_MODULE_124__ = __webpack_require__(/*! ./memoize */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/memoize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "memoize", function() { return _memoize__WEBPACK_IMPORTED_MODULE_124__["default"]; });

/* harmony import */ var _memoizeWith__WEBPACK_IMPORTED_MODULE_125__ = __webpack_require__(/*! ./memoizeWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/memoizeWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "memoizeWith", function() { return _memoizeWith__WEBPACK_IMPORTED_MODULE_125__["default"]; });

/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_126__ = __webpack_require__(/*! ./merge */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/merge.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _merge__WEBPACK_IMPORTED_MODULE_126__["default"]; });

/* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_127__ = __webpack_require__(/*! ./mergeAll */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeAll", function() { return _mergeAll__WEBPACK_IMPORTED_MODULE_127__["default"]; });

/* harmony import */ var _mergeDeepLeft__WEBPACK_IMPORTED_MODULE_128__ = __webpack_require__(/*! ./mergeDeepLeft */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepLeft.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeDeepLeft", function() { return _mergeDeepLeft__WEBPACK_IMPORTED_MODULE_128__["default"]; });

/* harmony import */ var _mergeDeepRight__WEBPACK_IMPORTED_MODULE_129__ = __webpack_require__(/*! ./mergeDeepRight */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepRight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeDeepRight", function() { return _mergeDeepRight__WEBPACK_IMPORTED_MODULE_129__["default"]; });

/* harmony import */ var _mergeDeepWith__WEBPACK_IMPORTED_MODULE_130__ = __webpack_require__(/*! ./mergeDeepWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeDeepWith", function() { return _mergeDeepWith__WEBPACK_IMPORTED_MODULE_130__["default"]; });

/* harmony import */ var _mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_131__ = __webpack_require__(/*! ./mergeDeepWithKey */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWithKey.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeDeepWithKey", function() { return _mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_131__["default"]; });

/* harmony import */ var _mergeWith__WEBPACK_IMPORTED_MODULE_132__ = __webpack_require__(/*! ./mergeWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeWith", function() { return _mergeWith__WEBPACK_IMPORTED_MODULE_132__["default"]; });

/* harmony import */ var _mergeWithKey__WEBPACK_IMPORTED_MODULE_133__ = __webpack_require__(/*! ./mergeWithKey */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWithKey.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeWithKey", function() { return _mergeWithKey__WEBPACK_IMPORTED_MODULE_133__["default"]; });

/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_134__ = __webpack_require__(/*! ./min */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/min.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _min__WEBPACK_IMPORTED_MODULE_134__["default"]; });

/* harmony import */ var _minBy__WEBPACK_IMPORTED_MODULE_135__ = __webpack_require__(/*! ./minBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/minBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "minBy", function() { return _minBy__WEBPACK_IMPORTED_MODULE_135__["default"]; });

/* harmony import */ var _modulo__WEBPACK_IMPORTED_MODULE_136__ = __webpack_require__(/*! ./modulo */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/modulo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "modulo", function() { return _modulo__WEBPACK_IMPORTED_MODULE_136__["default"]; });

/* harmony import */ var _multiply__WEBPACK_IMPORTED_MODULE_137__ = __webpack_require__(/*! ./multiply */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/multiply.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return _multiply__WEBPACK_IMPORTED_MODULE_137__["default"]; });

/* harmony import */ var _nAry__WEBPACK_IMPORTED_MODULE_138__ = __webpack_require__(/*! ./nAry */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nAry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nAry", function() { return _nAry__WEBPACK_IMPORTED_MODULE_138__["default"]; });

/* harmony import */ var _negate__WEBPACK_IMPORTED_MODULE_139__ = __webpack_require__(/*! ./negate */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/negate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return _negate__WEBPACK_IMPORTED_MODULE_139__["default"]; });

/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_140__ = __webpack_require__(/*! ./none */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/none.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "none", function() { return _none__WEBPACK_IMPORTED_MODULE_140__["default"]; });

/* harmony import */ var _not__WEBPACK_IMPORTED_MODULE_141__ = __webpack_require__(/*! ./not */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/not.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "not", function() { return _not__WEBPACK_IMPORTED_MODULE_141__["default"]; });

/* harmony import */ var _nth__WEBPACK_IMPORTED_MODULE_142__ = __webpack_require__(/*! ./nth */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nth.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nth", function() { return _nth__WEBPACK_IMPORTED_MODULE_142__["default"]; });

/* harmony import */ var _nthArg__WEBPACK_IMPORTED_MODULE_143__ = __webpack_require__(/*! ./nthArg */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nthArg.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nthArg", function() { return _nthArg__WEBPACK_IMPORTED_MODULE_143__["default"]; });

/* harmony import */ var _o__WEBPACK_IMPORTED_MODULE_144__ = __webpack_require__(/*! ./o */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/o.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "o", function() { return _o__WEBPACK_IMPORTED_MODULE_144__["default"]; });

/* harmony import */ var _objOf__WEBPACK_IMPORTED_MODULE_145__ = __webpack_require__(/*! ./objOf */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/objOf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "objOf", function() { return _objOf__WEBPACK_IMPORTED_MODULE_145__["default"]; });

/* harmony import */ var _of__WEBPACK_IMPORTED_MODULE_146__ = __webpack_require__(/*! ./of */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/of.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "of", function() { return _of__WEBPACK_IMPORTED_MODULE_146__["default"]; });

/* harmony import */ var _omit__WEBPACK_IMPORTED_MODULE_147__ = __webpack_require__(/*! ./omit */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/omit.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "omit", function() { return _omit__WEBPACK_IMPORTED_MODULE_147__["default"]; });

/* harmony import */ var _once__WEBPACK_IMPORTED_MODULE_148__ = __webpack_require__(/*! ./once */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/once.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "once", function() { return _once__WEBPACK_IMPORTED_MODULE_148__["default"]; });

/* harmony import */ var _or__WEBPACK_IMPORTED_MODULE_149__ = __webpack_require__(/*! ./or */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/or.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "or", function() { return _or__WEBPACK_IMPORTED_MODULE_149__["default"]; });

/* harmony import */ var _over__WEBPACK_IMPORTED_MODULE_150__ = __webpack_require__(/*! ./over */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/over.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "over", function() { return _over__WEBPACK_IMPORTED_MODULE_150__["default"]; });

/* harmony import */ var _pair__WEBPACK_IMPORTED_MODULE_151__ = __webpack_require__(/*! ./pair */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pair.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pair", function() { return _pair__WEBPACK_IMPORTED_MODULE_151__["default"]; });

/* harmony import */ var _partial__WEBPACK_IMPORTED_MODULE_152__ = __webpack_require__(/*! ./partial */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partial", function() { return _partial__WEBPACK_IMPORTED_MODULE_152__["default"]; });

/* harmony import */ var _partialRight__WEBPACK_IMPORTED_MODULE_153__ = __webpack_require__(/*! ./partialRight */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partialRight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partialRight", function() { return _partialRight__WEBPACK_IMPORTED_MODULE_153__["default"]; });

/* harmony import */ var _partition__WEBPACK_IMPORTED_MODULE_154__ = __webpack_require__(/*! ./partition */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partition.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return _partition__WEBPACK_IMPORTED_MODULE_154__["default"]; });

/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_155__ = __webpack_require__(/*! ./path */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "path", function() { return _path__WEBPACK_IMPORTED_MODULE_155__["default"]; });

/* harmony import */ var _pathEq__WEBPACK_IMPORTED_MODULE_156__ = __webpack_require__(/*! ./pathEq */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathEq.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pathEq", function() { return _pathEq__WEBPACK_IMPORTED_MODULE_156__["default"]; });

/* harmony import */ var _pathOr__WEBPACK_IMPORTED_MODULE_157__ = __webpack_require__(/*! ./pathOr */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathOr.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pathOr", function() { return _pathOr__WEBPACK_IMPORTED_MODULE_157__["default"]; });

/* harmony import */ var _pathSatisfies__WEBPACK_IMPORTED_MODULE_158__ = __webpack_require__(/*! ./pathSatisfies */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathSatisfies.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pathSatisfies", function() { return _pathSatisfies__WEBPACK_IMPORTED_MODULE_158__["default"]; });

/* harmony import */ var _pick__WEBPACK_IMPORTED_MODULE_159__ = __webpack_require__(/*! ./pick */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pick.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pick", function() { return _pick__WEBPACK_IMPORTED_MODULE_159__["default"]; });

/* harmony import */ var _pickAll__WEBPACK_IMPORTED_MODULE_160__ = __webpack_require__(/*! ./pickAll */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pickAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pickAll", function() { return _pickAll__WEBPACK_IMPORTED_MODULE_160__["default"]; });

/* harmony import */ var _pickBy__WEBPACK_IMPORTED_MODULE_161__ = __webpack_require__(/*! ./pickBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pickBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pickBy", function() { return _pickBy__WEBPACK_IMPORTED_MODULE_161__["default"]; });

/* harmony import */ var _pipe__WEBPACK_IMPORTED_MODULE_162__ = __webpack_require__(/*! ./pipe */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipe.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pipe", function() { return _pipe__WEBPACK_IMPORTED_MODULE_162__["default"]; });

/* harmony import */ var _pipeK__WEBPACK_IMPORTED_MODULE_163__ = __webpack_require__(/*! ./pipeK */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipeK.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pipeK", function() { return _pipeK__WEBPACK_IMPORTED_MODULE_163__["default"]; });

/* harmony import */ var _pipeP__WEBPACK_IMPORTED_MODULE_164__ = __webpack_require__(/*! ./pipeP */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipeP.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pipeP", function() { return _pipeP__WEBPACK_IMPORTED_MODULE_164__["default"]; });

/* harmony import */ var _pluck__WEBPACK_IMPORTED_MODULE_165__ = __webpack_require__(/*! ./pluck */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pluck.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pluck", function() { return _pluck__WEBPACK_IMPORTED_MODULE_165__["default"]; });

/* harmony import */ var _prepend__WEBPACK_IMPORTED_MODULE_166__ = __webpack_require__(/*! ./prepend */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prepend.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "prepend", function() { return _prepend__WEBPACK_IMPORTED_MODULE_166__["default"]; });

/* harmony import */ var _product__WEBPACK_IMPORTED_MODULE_167__ = __webpack_require__(/*! ./product */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/product.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "product", function() { return _product__WEBPACK_IMPORTED_MODULE_167__["default"]; });

/* harmony import */ var _project__WEBPACK_IMPORTED_MODULE_168__ = __webpack_require__(/*! ./project */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/project.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "project", function() { return _project__WEBPACK_IMPORTED_MODULE_168__["default"]; });

/* harmony import */ var _prop__WEBPACK_IMPORTED_MODULE_169__ = __webpack_require__(/*! ./prop */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prop.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "prop", function() { return _prop__WEBPACK_IMPORTED_MODULE_169__["default"]; });

/* harmony import */ var _propEq__WEBPACK_IMPORTED_MODULE_170__ = __webpack_require__(/*! ./propEq */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propEq.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "propEq", function() { return _propEq__WEBPACK_IMPORTED_MODULE_170__["default"]; });

/* harmony import */ var _propIs__WEBPACK_IMPORTED_MODULE_171__ = __webpack_require__(/*! ./propIs */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propIs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "propIs", function() { return _propIs__WEBPACK_IMPORTED_MODULE_171__["default"]; });

/* harmony import */ var _propOr__WEBPACK_IMPORTED_MODULE_172__ = __webpack_require__(/*! ./propOr */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propOr.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "propOr", function() { return _propOr__WEBPACK_IMPORTED_MODULE_172__["default"]; });

/* harmony import */ var _propSatisfies__WEBPACK_IMPORTED_MODULE_173__ = __webpack_require__(/*! ./propSatisfies */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propSatisfies.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "propSatisfies", function() { return _propSatisfies__WEBPACK_IMPORTED_MODULE_173__["default"]; });

/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_174__ = __webpack_require__(/*! ./props */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/props.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "props", function() { return _props__WEBPACK_IMPORTED_MODULE_174__["default"]; });

/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_175__ = __webpack_require__(/*! ./range */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/range.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _range__WEBPACK_IMPORTED_MODULE_175__["default"]; });

/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_176__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduce", function() { return _reduce__WEBPACK_IMPORTED_MODULE_176__["default"]; });

/* harmony import */ var _reduceBy__WEBPACK_IMPORTED_MODULE_177__ = __webpack_require__(/*! ./reduceBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduceBy", function() { return _reduceBy__WEBPACK_IMPORTED_MODULE_177__["default"]; });

/* harmony import */ var _reduceRight__WEBPACK_IMPORTED_MODULE_178__ = __webpack_require__(/*! ./reduceRight */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceRight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduceRight", function() { return _reduceRight__WEBPACK_IMPORTED_MODULE_178__["default"]; });

/* harmony import */ var _reduceWhile__WEBPACK_IMPORTED_MODULE_179__ = __webpack_require__(/*! ./reduceWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceWhile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduceWhile", function() { return _reduceWhile__WEBPACK_IMPORTED_MODULE_179__["default"]; });

/* harmony import */ var _reduced__WEBPACK_IMPORTED_MODULE_180__ = __webpack_require__(/*! ./reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduced.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduced", function() { return _reduced__WEBPACK_IMPORTED_MODULE_180__["default"]; });

/* harmony import */ var _reject__WEBPACK_IMPORTED_MODULE_181__ = __webpack_require__(/*! ./reject */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reject.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reject", function() { return _reject__WEBPACK_IMPORTED_MODULE_181__["default"]; });

/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_182__ = __webpack_require__(/*! ./remove */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/remove.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return _remove__WEBPACK_IMPORTED_MODULE_182__["default"]; });

/* harmony import */ var _repeat__WEBPACK_IMPORTED_MODULE_183__ = __webpack_require__(/*! ./repeat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/repeat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "repeat", function() { return _repeat__WEBPACK_IMPORTED_MODULE_183__["default"]; });

/* harmony import */ var _replace__WEBPACK_IMPORTED_MODULE_184__ = __webpack_require__(/*! ./replace */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/replace.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "replace", function() { return _replace__WEBPACK_IMPORTED_MODULE_184__["default"]; });

/* harmony import */ var _reverse__WEBPACK_IMPORTED_MODULE_185__ = __webpack_require__(/*! ./reverse */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reverse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return _reverse__WEBPACK_IMPORTED_MODULE_185__["default"]; });

/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_186__ = __webpack_require__(/*! ./scan */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/scan.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scan", function() { return _scan__WEBPACK_IMPORTED_MODULE_186__["default"]; });

/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_187__ = __webpack_require__(/*! ./sequence */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sequence.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sequence", function() { return _sequence__WEBPACK_IMPORTED_MODULE_187__["default"]; });

/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_188__ = __webpack_require__(/*! ./set */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/set.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "set", function() { return _set__WEBPACK_IMPORTED_MODULE_188__["default"]; });

/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_189__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return _slice__WEBPACK_IMPORTED_MODULE_189__["default"]; });

/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_190__ = __webpack_require__(/*! ./sort */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sort.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sort", function() { return _sort__WEBPACK_IMPORTED_MODULE_190__["default"]; });

/* harmony import */ var _sortBy__WEBPACK_IMPORTED_MODULE_191__ = __webpack_require__(/*! ./sortBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sortBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sortBy", function() { return _sortBy__WEBPACK_IMPORTED_MODULE_191__["default"]; });

/* harmony import */ var _sortWith__WEBPACK_IMPORTED_MODULE_192__ = __webpack_require__(/*! ./sortWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sortWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sortWith", function() { return _sortWith__WEBPACK_IMPORTED_MODULE_192__["default"]; });

/* harmony import */ var _split__WEBPACK_IMPORTED_MODULE_193__ = __webpack_require__(/*! ./split */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/split.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "split", function() { return _split__WEBPACK_IMPORTED_MODULE_193__["default"]; });

/* harmony import */ var _splitAt__WEBPACK_IMPORTED_MODULE_194__ = __webpack_require__(/*! ./splitAt */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitAt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "splitAt", function() { return _splitAt__WEBPACK_IMPORTED_MODULE_194__["default"]; });

/* harmony import */ var _splitEvery__WEBPACK_IMPORTED_MODULE_195__ = __webpack_require__(/*! ./splitEvery */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitEvery.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "splitEvery", function() { return _splitEvery__WEBPACK_IMPORTED_MODULE_195__["default"]; });

/* harmony import */ var _splitWhen__WEBPACK_IMPORTED_MODULE_196__ = __webpack_require__(/*! ./splitWhen */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitWhen.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "splitWhen", function() { return _splitWhen__WEBPACK_IMPORTED_MODULE_196__["default"]; });

/* harmony import */ var _startsWith__WEBPACK_IMPORTED_MODULE_197__ = __webpack_require__(/*! ./startsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/startsWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "startsWith", function() { return _startsWith__WEBPACK_IMPORTED_MODULE_197__["default"]; });

/* harmony import */ var _subtract__WEBPACK_IMPORTED_MODULE_198__ = __webpack_require__(/*! ./subtract */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/subtract.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return _subtract__WEBPACK_IMPORTED_MODULE_198__["default"]; });

/* harmony import */ var _sum__WEBPACK_IMPORTED_MODULE_199__ = __webpack_require__(/*! ./sum */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sum.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return _sum__WEBPACK_IMPORTED_MODULE_199__["default"]; });

/* harmony import */ var _symmetricDifference__WEBPACK_IMPORTED_MODULE_200__ = __webpack_require__(/*! ./symmetricDifference */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/symmetricDifference.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symmetricDifference", function() { return _symmetricDifference__WEBPACK_IMPORTED_MODULE_200__["default"]; });

/* harmony import */ var _symmetricDifferenceWith__WEBPACK_IMPORTED_MODULE_201__ = __webpack_require__(/*! ./symmetricDifferenceWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/symmetricDifferenceWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symmetricDifferenceWith", function() { return _symmetricDifferenceWith__WEBPACK_IMPORTED_MODULE_201__["default"]; });

/* harmony import */ var _tail__WEBPACK_IMPORTED_MODULE_202__ = __webpack_require__(/*! ./tail */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tail.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tail", function() { return _tail__WEBPACK_IMPORTED_MODULE_202__["default"]; });

/* harmony import */ var _take__WEBPACK_IMPORTED_MODULE_203__ = __webpack_require__(/*! ./take */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/take.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "take", function() { return _take__WEBPACK_IMPORTED_MODULE_203__["default"]; });

/* harmony import */ var _takeLast__WEBPACK_IMPORTED_MODULE_204__ = __webpack_require__(/*! ./takeLast */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeLast.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "takeLast", function() { return _takeLast__WEBPACK_IMPORTED_MODULE_204__["default"]; });

/* harmony import */ var _takeLastWhile__WEBPACK_IMPORTED_MODULE_205__ = __webpack_require__(/*! ./takeLastWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeLastWhile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "takeLastWhile", function() { return _takeLastWhile__WEBPACK_IMPORTED_MODULE_205__["default"]; });

/* harmony import */ var _takeWhile__WEBPACK_IMPORTED_MODULE_206__ = __webpack_require__(/*! ./takeWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeWhile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "takeWhile", function() { return _takeWhile__WEBPACK_IMPORTED_MODULE_206__["default"]; });

/* harmony import */ var _tap__WEBPACK_IMPORTED_MODULE_207__ = __webpack_require__(/*! ./tap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tap", function() { return _tap__WEBPACK_IMPORTED_MODULE_207__["default"]; });

/* harmony import */ var _test__WEBPACK_IMPORTED_MODULE_208__ = __webpack_require__(/*! ./test */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/test.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "test", function() { return _test__WEBPACK_IMPORTED_MODULE_208__["default"]; });

/* harmony import */ var _times__WEBPACK_IMPORTED_MODULE_209__ = __webpack_require__(/*! ./times */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/times.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "times", function() { return _times__WEBPACK_IMPORTED_MODULE_209__["default"]; });

/* harmony import */ var _toLower__WEBPACK_IMPORTED_MODULE_210__ = __webpack_require__(/*! ./toLower */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toLower.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toLower", function() { return _toLower__WEBPACK_IMPORTED_MODULE_210__["default"]; });

/* harmony import */ var _toPairs__WEBPACK_IMPORTED_MODULE_211__ = __webpack_require__(/*! ./toPairs */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toPairs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toPairs", function() { return _toPairs__WEBPACK_IMPORTED_MODULE_211__["default"]; });

/* harmony import */ var _toPairsIn__WEBPACK_IMPORTED_MODULE_212__ = __webpack_require__(/*! ./toPairsIn */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toPairsIn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toPairsIn", function() { return _toPairsIn__WEBPACK_IMPORTED_MODULE_212__["default"]; });

/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_213__ = __webpack_require__(/*! ./toString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toString.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toString", function() { return _toString__WEBPACK_IMPORTED_MODULE_213__["default"]; });

/* harmony import */ var _toUpper__WEBPACK_IMPORTED_MODULE_214__ = __webpack_require__(/*! ./toUpper */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toUpper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toUpper", function() { return _toUpper__WEBPACK_IMPORTED_MODULE_214__["default"]; });

/* harmony import */ var _transduce__WEBPACK_IMPORTED_MODULE_215__ = __webpack_require__(/*! ./transduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/transduce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transduce", function() { return _transduce__WEBPACK_IMPORTED_MODULE_215__["default"]; });

/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_216__ = __webpack_require__(/*! ./transpose */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/transpose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return _transpose__WEBPACK_IMPORTED_MODULE_216__["default"]; });

/* harmony import */ var _traverse__WEBPACK_IMPORTED_MODULE_217__ = __webpack_require__(/*! ./traverse */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/traverse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "traverse", function() { return _traverse__WEBPACK_IMPORTED_MODULE_217__["default"]; });

/* harmony import */ var _trim__WEBPACK_IMPORTED_MODULE_218__ = __webpack_require__(/*! ./trim */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/trim.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "trim", function() { return _trim__WEBPACK_IMPORTED_MODULE_218__["default"]; });

/* harmony import */ var _tryCatch__WEBPACK_IMPORTED_MODULE_219__ = __webpack_require__(/*! ./tryCatch */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tryCatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tryCatch", function() { return _tryCatch__WEBPACK_IMPORTED_MODULE_219__["default"]; });

/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_220__ = __webpack_require__(/*! ./type */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "type", function() { return _type__WEBPACK_IMPORTED_MODULE_220__["default"]; });

/* harmony import */ var _unapply__WEBPACK_IMPORTED_MODULE_221__ = __webpack_require__(/*! ./unapply */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unapply.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unapply", function() { return _unapply__WEBPACK_IMPORTED_MODULE_221__["default"]; });

/* harmony import */ var _unary__WEBPACK_IMPORTED_MODULE_222__ = __webpack_require__(/*! ./unary */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unary.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unary", function() { return _unary__WEBPACK_IMPORTED_MODULE_222__["default"]; });

/* harmony import */ var _uncurryN__WEBPACK_IMPORTED_MODULE_223__ = __webpack_require__(/*! ./uncurryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uncurryN.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uncurryN", function() { return _uncurryN__WEBPACK_IMPORTED_MODULE_223__["default"]; });

/* harmony import */ var _unfold__WEBPACK_IMPORTED_MODULE_224__ = __webpack_require__(/*! ./unfold */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unfold.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unfold", function() { return _unfold__WEBPACK_IMPORTED_MODULE_224__["default"]; });

/* harmony import */ var _union__WEBPACK_IMPORTED_MODULE_225__ = __webpack_require__(/*! ./union */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/union.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "union", function() { return _union__WEBPACK_IMPORTED_MODULE_225__["default"]; });

/* harmony import */ var _unionWith__WEBPACK_IMPORTED_MODULE_226__ = __webpack_require__(/*! ./unionWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unionWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unionWith", function() { return _unionWith__WEBPACK_IMPORTED_MODULE_226__["default"]; });

/* harmony import */ var _uniq__WEBPACK_IMPORTED_MODULE_227__ = __webpack_require__(/*! ./uniq */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniq.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uniq", function() { return _uniq__WEBPACK_IMPORTED_MODULE_227__["default"]; });

/* harmony import */ var _uniqBy__WEBPACK_IMPORTED_MODULE_228__ = __webpack_require__(/*! ./uniqBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uniqBy", function() { return _uniqBy__WEBPACK_IMPORTED_MODULE_228__["default"]; });

/* harmony import */ var _uniqWith__WEBPACK_IMPORTED_MODULE_229__ = __webpack_require__(/*! ./uniqWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uniqWith", function() { return _uniqWith__WEBPACK_IMPORTED_MODULE_229__["default"]; });

/* harmony import */ var _unless__WEBPACK_IMPORTED_MODULE_230__ = __webpack_require__(/*! ./unless */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unless.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unless", function() { return _unless__WEBPACK_IMPORTED_MODULE_230__["default"]; });

/* harmony import */ var _unnest__WEBPACK_IMPORTED_MODULE_231__ = __webpack_require__(/*! ./unnest */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unnest.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unnest", function() { return _unnest__WEBPACK_IMPORTED_MODULE_231__["default"]; });

/* harmony import */ var _until__WEBPACK_IMPORTED_MODULE_232__ = __webpack_require__(/*! ./until */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/until.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "until", function() { return _until__WEBPACK_IMPORTED_MODULE_232__["default"]; });

/* harmony import */ var _update__WEBPACK_IMPORTED_MODULE_233__ = __webpack_require__(/*! ./update */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/update.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "update", function() { return _update__WEBPACK_IMPORTED_MODULE_233__["default"]; });

/* harmony import */ var _useWith__WEBPACK_IMPORTED_MODULE_234__ = __webpack_require__(/*! ./useWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/useWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useWith", function() { return _useWith__WEBPACK_IMPORTED_MODULE_234__["default"]; });

/* harmony import */ var _values__WEBPACK_IMPORTED_MODULE_235__ = __webpack_require__(/*! ./values */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/values.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "values", function() { return _values__WEBPACK_IMPORTED_MODULE_235__["default"]; });

/* harmony import */ var _valuesIn__WEBPACK_IMPORTED_MODULE_236__ = __webpack_require__(/*! ./valuesIn */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/valuesIn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valuesIn", function() { return _valuesIn__WEBPACK_IMPORTED_MODULE_236__["default"]; });

/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_237__ = __webpack_require__(/*! ./view */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/view.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "view", function() { return _view__WEBPACK_IMPORTED_MODULE_237__["default"]; });

/* harmony import */ var _when__WEBPACK_IMPORTED_MODULE_238__ = __webpack_require__(/*! ./when */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/when.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "when", function() { return _when__WEBPACK_IMPORTED_MODULE_238__["default"]; });

/* harmony import */ var _where__WEBPACK_IMPORTED_MODULE_239__ = __webpack_require__(/*! ./where */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/where.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "where", function() { return _where__WEBPACK_IMPORTED_MODULE_239__["default"]; });

/* harmony import */ var _whereEq__WEBPACK_IMPORTED_MODULE_240__ = __webpack_require__(/*! ./whereEq */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/whereEq.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "whereEq", function() { return _whereEq__WEBPACK_IMPORTED_MODULE_240__["default"]; });

/* harmony import */ var _without__WEBPACK_IMPORTED_MODULE_241__ = __webpack_require__(/*! ./without */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/without.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "without", function() { return _without__WEBPACK_IMPORTED_MODULE_241__["default"]; });

/* harmony import */ var _xprod__WEBPACK_IMPORTED_MODULE_242__ = __webpack_require__(/*! ./xprod */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/xprod.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "xprod", function() { return _xprod__WEBPACK_IMPORTED_MODULE_242__["default"]; });

/* harmony import */ var _zip__WEBPACK_IMPORTED_MODULE_243__ = __webpack_require__(/*! ./zip */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return _zip__WEBPACK_IMPORTED_MODULE_243__["default"]; });

/* harmony import */ var _zipObj__WEBPACK_IMPORTED_MODULE_244__ = __webpack_require__(/*! ./zipObj */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zipObj.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zipObj", function() { return _zipObj__WEBPACK_IMPORTED_MODULE_244__["default"]; });

/* harmony import */ var _zipWith__WEBPACK_IMPORTED_MODULE_245__ = __webpack_require__(/*! ./zipWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zipWith.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zipWith", function() { return _zipWith__WEBPACK_IMPORTED_MODULE_245__["default"]; });
























































































































































































































































/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/indexBy.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/indexBy.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reduceBy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reduceBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceBy.js");


/**
 * Given a function that generates a key, turns a list of objects into an
 * object indexing the objects by the given key. Note that if multiple
 * objects generate the same value for the indexing key only the last value
 * will be included in the generated object.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
 * @param {Function} fn Function :: a -> String
 * @param {Array} array The array of objects to index
 * @return {Object} An object indexing each array element by the given property.
 * @example
 *
 *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
 *      R.indexBy(R.prop('id'), list);
 *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
 */
var indexBy = /*#__PURE__*/Object(_reduceBy__WEBPACK_IMPORTED_MODULE_0__["default"])(function (acc, elem) {
  return elem;
}, null);
/* harmony default export */ __webpack_exports__["default"] = (indexBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/indexOf.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/indexOf.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_indexOf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_indexOf */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_indexOf.js");
/* harmony import */ var _internal_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");




/**
 * Returns the position of the first occurrence of an item in an array, or -1
 * if the item is not included in the array. [`R.equals`](#equals) is used to
 * determine equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> Number
 * @param {*} target The item to find.
 * @param {Array} xs The array to search in.
 * @return {Number} the index of the target, or -1 if the target is not found.
 * @see R.lastIndexOf
 * @example
 *
 *      R.indexOf(3, [1,2,3,4]); //=> 2
 *      R.indexOf(10, [1,2,3,4]); //=> -1
 */
var indexOf = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function indexOf(target, xs) {
  return typeof xs.indexOf === 'function' && !Object(_internal_isArray__WEBPACK_IMPORTED_MODULE_2__["default"])(xs) ? xs.indexOf(target) : Object(_internal_indexOf__WEBPACK_IMPORTED_MODULE_1__["default"])(xs, target, 0);
});
/* harmony default export */ __webpack_exports__["default"] = (indexOf);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/init.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/init.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");


/**
 * Returns all but the last element of the given list or string.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.last, R.head, R.tail
 * @example
 *
 *      R.init([1, 2, 3]);  //=> [1, 2]
 *      R.init([1, 2]);     //=> [1]
 *      R.init([1]);        //=> []
 *      R.init([]);         //=> []
 *
 *      R.init('abc');  //=> 'ab'
 *      R.init('ab');   //=> 'a'
 *      R.init('a');    //=> ''
 *      R.init('');     //=> ''
 */
var init = /*#__PURE__*/Object(_slice__WEBPACK_IMPORTED_MODULE_0__["default"])(0, -1);
/* harmony default export */ __webpack_exports__["default"] = (init);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/innerJoin.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/innerJoin.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_containsWith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_containsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_containsWith.js");
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _internal_filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_filter */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_filter.js");




/**
 * Takes a predicate `pred`, a list `xs`, and a list `ys`, and returns a list
 * `xs'` comprising each of the elements of `xs` which is equal to one or more
 * elements of `ys` according to `pred`.
 *
 * `pred` must be a binary function expecting an element from each list.
 *
 * `xs`, `ys`, and `xs'` are treated as sets, semantically, so ordering should
 * not be significant, but since `xs'` is ordered the implementation guarantees
 * that its values are in the same order as they appear in `xs`. Duplicates are
 * not removed, so `xs'` may contain duplicates if `xs` contains duplicates.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Relation
 * @sig ((a, b) -> Boolean) -> [a] -> [b] -> [a]
 * @param {Function} pred
 * @param {Array} xs
 * @param {Array} ys
 * @return {Array}
 * @see R.intersection
 * @example
 *
 *      R.innerJoin(
 *        (record, id) => record.id === id,
 *        [{id: 824, name: 'Richie Furay'},
 *         {id: 956, name: 'Dewey Martin'},
 *         {id: 313, name: 'Bruce Palmer'},
 *         {id: 456, name: 'Stephen Stills'},
 *         {id: 177, name: 'Neil Young'}],
 *        [177, 456, 999]
 *      );
 *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
 */
var innerJoin = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_1__["default"])(function innerJoin(pred, xs, ys) {
  return Object(_internal_filter__WEBPACK_IMPORTED_MODULE_2__["default"])(function (x) {
    return Object(_internal_containsWith__WEBPACK_IMPORTED_MODULE_0__["default"])(pred, x, ys);
  }, xs);
});
/* harmony default export */ __webpack_exports__["default"] = (innerJoin);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/insert.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/insert.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Inserts the supplied element into the list, at the specified `index`. _Note that

 * this is not destructive_: it returns a copy of the list with the changes.
 * <small>No lists have been harmed in the application of this function.</small>
 *
 * @func
 * @memberOf R
 * @since v0.2.2
 * @category List
 * @sig Number -> a -> [a] -> [a]
 * @param {Number} index The position to insert the element
 * @param {*} elt The element to insert into the Array
 * @param {Array} list The list to insert into
 * @return {Array} A new Array with `elt` inserted at `index`.
 * @example
 *
 *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
 */
var insert = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function insert(idx, elt, list) {
  idx = idx < list.length && idx >= 0 ? idx : list.length;
  var result = Array.prototype.slice.call(list, 0);
  result.splice(idx, 0, elt);
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (insert);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/insertAll.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/insertAll.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Inserts the sub-list into the list, at the specified `index`. _Note that this is not
 * destructive_: it returns a copy of the list with the changes.
 * <small>No lists have been harmed in the application of this function.</small>
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category List
 * @sig Number -> [a] -> [a] -> [a]
 * @param {Number} index The position to insert the sub-list
 * @param {Array} elts The sub-list to insert into the Array
 * @param {Array} list The list to insert the sub-list into
 * @return {Array} A new Array with `elts` inserted starting at `index`.
 * @example
 *
 *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
 */
var insertAll = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function insertAll(idx, elts, list) {
  idx = idx < list.length && idx >= 0 ? idx : list.length;
  return [].concat(Array.prototype.slice.call(list, 0, idx), elts, Array.prototype.slice.call(list, idx));
});
/* harmony default export */ __webpack_exports__["default"] = (insertAll);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_Set.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_Set.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _contains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_contains */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js");


var _Set = /*#__PURE__*/function () {
  function _Set() {
    /* globals Set */
    this._nativeSet = typeof Set === 'function' ? new Set() : null;
    this._items = {};
  }

  // until we figure out why jsdoc chokes on this
  // @param item The item to add to the Set
  // @returns {boolean} true if the item did not exist prior, otherwise false
  //
  _Set.prototype.add = function (item) {
    return !hasOrAdd(item, true, this);
  };

  //
  // @param item The item to check for existence in the Set
  // @returns {boolean} true if the item exists in the Set, otherwise false
  //
  _Set.prototype.has = function (item) {
    return hasOrAdd(item, false, this);
  };

  //
  // Combines the logic for checking whether an item is a member of the set and
  // for adding a new item to the set.
  //
  // @param item       The item to check or add to the Set instance.
  // @param shouldAdd  If true, the item will be added to the set if it doesn't
  //                   already exist.
  // @param set        The set instance to check or add to.
  // @return {boolean} true if the item already existed, otherwise false.
  //
  return _Set;
}();

function hasOrAdd(item, shouldAdd, set) {
  var type = typeof item;
  var prevSize, newSize;
  switch (type) {
    case 'string':
    case 'number':
      // distinguish between +0 and -0
      if (item === 0 && 1 / item === -Infinity) {
        if (set._items['-0']) {
          return true;
        } else {
          if (shouldAdd) {
            set._items['-0'] = true;
          }
          return false;
        }
      }
      // these types can all utilise the native Set
      if (set._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set._nativeSet.size;
          set._nativeSet.add(item);
          newSize = set._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set._nativeSet.has(item);
        }
      } else {
        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = {};
            set._items[type][item] = true;
          }
          return false;
        } else if (item in set._items[type]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type][item] = true;
          }
          return false;
        }
      }

    case 'boolean':
      // set._items['boolean'] holds a two element array
      // representing [ falseExists, trueExists ]
      if (type in set._items) {
        var bIdx = item ? 1 : 0;
        if (set._items[type][bIdx]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type][bIdx] = true;
          }
          return false;
        }
      } else {
        if (shouldAdd) {
          set._items[type] = item ? [false, true] : [true, false];
        }
        return false;
      }

    case 'function':
      // compare functions for reference equality
      if (set._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set._nativeSet.size;
          set._nativeSet.add(item);
          newSize = set._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set._nativeSet.has(item);
        }
      } else {
        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = [item];
          }
          return false;
        }
        if (!Object(_contains__WEBPACK_IMPORTED_MODULE_0__["default"])(item, set._items[type])) {
          if (shouldAdd) {
            set._items[type].push(item);
          }
          return false;
        }
        return true;
      }

    case 'undefined':
      if (set._items[type]) {
        return true;
      } else {
        if (shouldAdd) {
          set._items[type] = true;
        }
        return false;
      }

    case 'object':
      if (item === null) {
        if (!set._items['null']) {
          if (shouldAdd) {
            set._items['null'] = true;
          }
          return false;
        }
        return true;
      }
    /* falls through */
    default:
      // reduce the search size of heterogeneous sets by creating buckets
      // for each type.
      type = Object.prototype.toString.call(item);
      if (!(type in set._items)) {
        if (shouldAdd) {
          set._items[type] = [item];
        }
        return false;
      }
      // scan through all previously applied items
      if (!Object(_contains__WEBPACK_IMPORTED_MODULE_0__["default"])(item, set._items[type])) {
        if (shouldAdd) {
          set._items[type].push(item);
        }
        return false;
      }
      return true;
  }
}

// A simple Set type that honours R.equals semantics
/* harmony default export */ __webpack_exports__["default"] = (_Set);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_aperture.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_aperture.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _aperture; });
function _aperture(n, list) {
  var idx = 0;
  var limit = list.length - (n - 1);
  var acc = new Array(limit >= 0 ? limit : 0);
  while (idx < limit) {
    acc[idx] = Array.prototype.slice.call(list, idx, idx + n);
    idx += 1;
  }
  return acc;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arity; });
function _arity(n, fn) {
  /* eslint-disable no-unused-vars */
  switch (n) {
    case 0:
      return function () {
        return fn.apply(this, arguments);
      };
    case 1:
      return function (a0) {
        return fn.apply(this, arguments);
      };
    case 2:
      return function (a0, a1) {
        return fn.apply(this, arguments);
      };
    case 3:
      return function (a0, a1, a2) {
        return fn.apply(this, arguments);
      };
    case 4:
      return function (a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };
    case 5:
      return function (a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };
    case 6:
      return function (a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };
    case 7:
      return function (a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };
    case 8:
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };
    case 9:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };
    case 10:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };
    default:
      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arrayFromIterator.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arrayFromIterator.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayFromIterator; });
function _arrayFromIterator(iter) {
  var list = [];
  var next;
  while (!(next = iter.next()).done) {
    list.push(next.value);
  }
  return list;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_assign.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_assign.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _objectAssign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_objectAssign */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_objectAssign.js");


/* harmony default export */ __webpack_exports__["default"] = (typeof Object.assign === 'function' ? Object.assign : _objectAssign__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_checkForMethod.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_checkForMethod.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _checkForMethod; });
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");


/**
 * This checks whether a function has a [methodname] function. If it isn't an
 * array it will execute that function otherwise it will default to the ramda
 * implementation.
 *
 * @private
 * @param {Function} fn ramda implemtation
 * @param {String} methodname property to check for a custom implementation
 * @return {Object} Whatever the return value of the method is.
 */
function _checkForMethod(methodname, fn) {
  return function () {
    var length = arguments.length;
    if (length === 0) {
      return fn();
    }
    var obj = arguments[length - 1];
    return Object(_isArray__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_clone.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_clone.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _clone; });
/* harmony import */ var _cloneRegExp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cloneRegExp */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_cloneRegExp.js");
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../type */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/type.js");



/**
 * Copies an object.
 *
 * @private
 * @param {*} value The value to be copied
 * @param {Array} refFrom Array containing the source references
 * @param {Array} refTo Array containing the copied source references
 * @param {Boolean} deep Whether or not to perform deep cloning.
 * @return {*} The copied value.
 */
function _clone(value, refFrom, refTo, deep) {
  var copy = function copy(copiedValue) {
    var len = refFrom.length;
    var idx = 0;
    while (idx < len) {
      if (value === refFrom[idx]) {
        return refTo[idx];
      }
      idx += 1;
    }
    refFrom[idx + 1] = value;
    refTo[idx + 1] = copiedValue;
    for (var key in value) {
      copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
    }
    return copiedValue;
  };
  switch (Object(_type__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
    case 'Object':
      return copy({});
    case 'Array':
      return copy([]);
    case 'Date':
      return new Date(value.valueOf());
    case 'RegExp':
      return Object(_cloneRegExp__WEBPACK_IMPORTED_MODULE_0__["default"])(value);
    default:
      return value;
  }
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_cloneRegExp.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_cloneRegExp.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _cloneRegExp; });
function _cloneRegExp(pattern) {
                                  return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_complement.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_complement.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _complement; });
function _complement(f) {
  return function () {
    return !f.apply(this, arguments);
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _concat; });
/**
 * Private `concat` function to merge two array-like objects.
 *
 * @private
 * @param {Array|Arguments} [set1=[]] An array-like object.
 * @param {Array|Arguments} [set2=[]] An array-like object.
 * @return {Array} A new, merged array.
 * @example
 *
 *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
 */
function _concat(set1, set2) {
  set1 = set1 || [];
  set2 = set2 || [];
  var idx;
  var len1 = set1.length;
  var len2 = set2.length;
  var result = [];

  idx = 0;
  while (idx < len1) {
    result[result.length] = set1[idx];
    idx += 1;
  }
  idx = 0;
  while (idx < len2) {
    result[result.length] = set2[idx];
    idx += 1;
  }
  return result;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _contains; });
/* harmony import */ var _indexOf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_indexOf */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_indexOf.js");


function _contains(a, list) {
  return Object(_indexOf__WEBPACK_IMPORTED_MODULE_0__["default"])(list, a, 0) >= 0;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_containsWith.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_containsWith.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _containsWith; });
function _containsWith(pred, x, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    if (pred(x, list[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_createPartialApplicator.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_createPartialApplicator.js ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _createPartialApplicator; });
/* harmony import */ var _arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



function _createPartialApplicator(concat) {
  return Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (fn, args) {
    return Object(_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.max(0, fn.length - args.length), function () {
      return fn.apply(this, concat(args, arguments));
    });
  });
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _curry1; });
/* harmony import */ var _isPlaceholder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isPlaceholder */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isPlaceholder.js");


/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_0__["default"])(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _curry2; });
/* harmony import */ var _curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _isPlaceholder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isPlaceholder */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isPlaceholder.js");



/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_1__["default"])(a) ? f2 : Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function (_b) {
          return fn(a, _b);
        });
      default:
        return Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_1__["default"])(a) && Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_1__["default"])(b) ? f2 : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_1__["default"])(a) ? Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function (_a) {
          return fn(_a, b);
        }) : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_1__["default"])(b) ? Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function (_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _curry3; });
/* harmony import */ var _curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _isPlaceholder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_isPlaceholder */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isPlaceholder.js");




/**
 * Optimized internal three-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
function _curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;
      case 1:
        return Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(a) ? f3 : Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (_b, _c) {
          return fn(a, _b, _c);
        });
      case 2:
        return Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(a) && Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(b) ? f3 : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(a) ? Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (_a, _c) {
          return fn(_a, b, _c);
        }) : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(b) ? Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (_b, _c) {
          return fn(a, _b, _c);
        }) : Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function (_c) {
          return fn(a, b, _c);
        });
      default:
        return Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(a) && Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(b) && Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(c) ? f3 : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(a) && Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(b) ? Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (_a, _b) {
          return fn(_a, _b, c);
        }) : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(a) && Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(c) ? Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (_a, _c) {
          return fn(_a, b, _c);
        }) : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(b) && Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(c) ? Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (_b, _c) {
          return fn(a, _b, _c);
        }) : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(a) ? Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function (_a) {
          return fn(_a, b, c);
        }) : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(b) ? Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function (_b) {
          return fn(a, _b, c);
        }) : Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_2__["default"])(c) ? Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function (_c) {
          return fn(a, b, _c);
        }) : fn(a, b, c);
    }
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curryN.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curryN.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _curryN; });
/* harmony import */ var _arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _isPlaceholder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isPlaceholder */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isPlaceholder.js");



/**
 * Internal curryN function.
 *
 * @private
 * @category Function
 * @param {Number} length The arity of the curried function.
 * @param {Array} received An array of arguments received thus far.
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
function _curryN(length, received, fn) {
  return function () {
    var combined = [];
    var argsIdx = 0;
    var left = length;
    var combinedIdx = 0;
    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;
      if (combinedIdx < received.length && (!Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_1__["default"])(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }
      combined[combinedIdx] = result;
      if (!Object(_isPlaceholder__WEBPACK_IMPORTED_MODULE_1__["default"])(result)) {
        left -= 1;
      }
      combinedIdx += 1;
    }
    return left <= 0 ? fn.apply(this, combined) : Object(_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(left, _curryN(length, combined, fn));
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _dispatchable; });
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");
/* harmony import */ var _isTransformer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isTransformer */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isTransformer.js");



/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a function with one of the given method names, it will
 * execute that function (functor case). Otherwise, if it is a transformer,
 * uses transducer [xf] to return a new transformer (transducer case).
 * Otherwise, it will default to executing [fn].
 *
 * @private
 * @param {Array} methodNames properties to check for a custom implementation
 * @param {Function} xf transducer to initialize if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */
function _dispatchable(methodNames, xf, fn) {
  return function () {
    if (arguments.length === 0) {
      return fn();
    }
    var args = Array.prototype.slice.call(arguments, 0);
    var obj = args.pop();
    if (!Object(_isArray__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) {
      var idx = 0;
      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === 'function') {
          return obj[methodNames[idx]].apply(obj, args);
        }
        idx += 1;
      }
      if (Object(_isTransformer__WEBPACK_IMPORTED_MODULE_1__["default"])(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }
    return fn.apply(this, arguments);
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dropLast.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dropLast.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return dropLast; });
/* harmony import */ var _take__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../take */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/take.js");


function dropLast(n, xs) {
  return Object(_take__WEBPACK_IMPORTED_MODULE_0__["default"])(n < xs.length ? xs.length - n : 0, xs);
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dropLastWhile.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dropLastWhile.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return dropLastWhile; });
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");


function dropLastWhile(pred, xs) {
  var idx = xs.length - 1;
  while (idx >= 0 && pred(xs[idx])) {
    idx -= 1;
  }
  return Object(_slice__WEBPACK_IMPORTED_MODULE_0__["default"])(0, idx + 1, xs);
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_equals.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_equals.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _equals; });
/* harmony import */ var _arrayFromIterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayFromIterator */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arrayFromIterator.js");
/* harmony import */ var _containsWith__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_containsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_containsWith.js");
/* harmony import */ var _functionName__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_functionName */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_functionName.js");
/* harmony import */ var _has__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");
/* harmony import */ var _identical__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../identical */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identical.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../type */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/type.js");








/**
 * private _uniqContentEquals function.
 * That function is checking equality of 2 iterator contents with 2 assumptions
 * - iterators lengths are the same
 * - iterators values are unique
 *
 * false-positive result will be returned for comparision of, e.g.
 * - [1,2,3] and [1,2,3,4]
 * - [1,1,1] and [1,2,3]
 * */

function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
  var a = Object(_arrayFromIterator__WEBPACK_IMPORTED_MODULE_0__["default"])(aIterator);
  var b = Object(_arrayFromIterator__WEBPACK_IMPORTED_MODULE_0__["default"])(bIterator);

  function eq(_a, _b) {
    return _equals(_a, _b, stackA.slice(), stackB.slice());
  }

  // if *a* array contains any element that is not included in *b*
  return !Object(_containsWith__WEBPACK_IMPORTED_MODULE_1__["default"])(function (b, aItem) {
    return !Object(_containsWith__WEBPACK_IMPORTED_MODULE_1__["default"])(eq, aItem, b);
  }, b, a);
}

function _equals(a, b, stackA, stackB) {
  if (Object(_identical__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b)) {
    return true;
  }

  var typeA = Object(_type__WEBPACK_IMPORTED_MODULE_6__["default"])(a);

  if (typeA !== Object(_type__WEBPACK_IMPORTED_MODULE_6__["default"])(b)) {
    return false;
  }

  if (a == null || b == null) {
    return false;
  }

  if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
    return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
  }

  if (typeof a.equals === 'function' || typeof b.equals === 'function') {
    return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
  }

  switch (typeA) {
    case 'Arguments':
    case 'Array':
    case 'Object':
      if (typeof a.constructor === 'function' && Object(_functionName__WEBPACK_IMPORTED_MODULE_2__["default"])(a.constructor) === 'Promise') {
        return a === b;
      }
      break;
    case 'Boolean':
    case 'Number':
    case 'String':
      if (!(typeof a === typeof b && Object(_identical__WEBPACK_IMPORTED_MODULE_4__["default"])(a.valueOf(), b.valueOf()))) {
        return false;
      }
      break;
    case 'Date':
      if (!Object(_identical__WEBPACK_IMPORTED_MODULE_4__["default"])(a.valueOf(), b.valueOf())) {
        return false;
      }
      break;
    case 'Error':
      return a.name === b.name && a.message === b.message;
    case 'RegExp':
      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
        return false;
      }
      break;
  }

  var idx = stackA.length - 1;
  while (idx >= 0) {
    if (stackA[idx] === a) {
      return stackB[idx] === b;
    }
    idx -= 1;
  }

  switch (typeA) {
    case 'Map':
      if (a.size !== b.size) {
        return false;
      }

      return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
    case 'Set':
      if (a.size !== b.size) {
        return false;
      }

      return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
    case 'Arguments':
    case 'Array':
    case 'Object':
    case 'Boolean':
    case 'Number':
    case 'String':
    case 'Date':
    case 'Error':
    case 'RegExp':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'ArrayBuffer':
      break;
    default:
      // Values of other types are only equal if identical.
      return false;
  }

  var keysA = Object(_keys__WEBPACK_IMPORTED_MODULE_5__["default"])(a);
  if (keysA.length !== Object(_keys__WEBPACK_IMPORTED_MODULE_5__["default"])(b).length) {
    return false;
  }

  var extendedStackA = stackA.concat([a]);
  var extendedStackB = stackB.concat([b]);

  idx = keysA.length - 1;
  while (idx >= 0) {
    var key = keysA[idx];
    if (!(Object(_has__WEBPACK_IMPORTED_MODULE_3__["default"])(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
      return false;
    }
    idx -= 1;
  }
  return true;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_filter.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_filter.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _filter; });
function _filter(fn, list) {
  var idx = 0;
  var len = list.length;
  var result = [];

  while (idx < len) {
    if (fn(list[idx])) {
      result[result.length] = list[idx];
    }
    idx += 1;
  }
  return result;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_flatCat.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_flatCat.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _forceReduced__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_forceReduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_forceReduced.js");
/* harmony import */ var _isArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArrayLike.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");





var preservingReduced = function (xf) {
  return {
    '@@transducer/init': _xfBase__WEBPACK_IMPORTED_MODULE_3__["default"].init,
    '@@transducer/result': function (result) {
      return xf['@@transducer/result'](result);
    },
    '@@transducer/step': function (result, input) {
      var ret = xf['@@transducer/step'](result, input);
      return ret['@@transducer/reduced'] ? Object(_forceReduced__WEBPACK_IMPORTED_MODULE_0__["default"])(ret) : ret;
    }
  };
};

var _flatCat = function _xcat(xf) {
  var rxf = preservingReduced(xf);
  return {
    '@@transducer/init': _xfBase__WEBPACK_IMPORTED_MODULE_3__["default"].init,
    '@@transducer/result': function (result) {
      return rxf['@@transducer/result'](result);
    },
    '@@transducer/step': function (result, input) {
      return !Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"])(input) ? Object(_reduce__WEBPACK_IMPORTED_MODULE_2__["default"])(rxf, result, [input]) : Object(_reduce__WEBPACK_IMPORTED_MODULE_2__["default"])(rxf, result, input);
    }
  };
};

/* harmony default export */ __webpack_exports__["default"] = (_flatCat);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_forceReduced.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_forceReduced.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _forceReduced; });
function _forceReduced(x) {
  return {
    '@@transducer/value': x,
    '@@transducer/reduced': true
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_functionName.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_functionName.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _functionName; });
function _functionName(f) {
  // String(x => x) evaluates to "x => x", so the pattern may not match.
  var match = String(f).match(/^function (\w*)/);
  return match == null ? '' : match[1];
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _has; });
function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_identity.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_identity.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _identity; });
function _identity(x) {
  return x;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_indexOf.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_indexOf.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _indexOf; });
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");


function _indexOf(list, a, idx) {
  var inf, item;
  // Array.prototype.indexOf doesn't exist below IE9
  if (typeof list.indexOf === 'function') {
    switch (typeof a) {
      case 'number':
        if (a === 0) {
          // manually crawl the list to distinguish between +0 and -0
          inf = 1 / a;
          while (idx < list.length) {
            item = list[idx];
            if (item === 0 && 1 / item === inf) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        } else if (a !== a) {
          // NaN
          while (idx < list.length) {
            item = list[idx];
            if (typeof item === 'number' && item !== item) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        }
        // non-zero numbers can utilise Set
        return list.indexOf(a, idx);

      // all these types can utilise Set
      case 'string':
      case 'boolean':
      case 'function':
      case 'undefined':
        return list.indexOf(a, idx);

      case 'object':
        if (a === null) {
          // null can utilise Set
          return list.indexOf(a, idx);
        }
    }
  }
  // anything else not covered above, defer to R.equals
  while (idx < list.length) {
    if (Object(_equals__WEBPACK_IMPORTED_MODULE_0__["default"])(list[idx], a)) {
      return idx;
    }
    idx += 1;
  }
  return -1;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArguments.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArguments.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _has__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");


var toString = Object.prototype.toString;
var _isArguments = function () {
  return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
    return toString.call(x) === '[object Arguments]';
  } : function _isArguments(x) {
    return Object(_has__WEBPACK_IMPORTED_MODULE_0__["default"])('callee', x);
  };
};

/* harmony default export */ __webpack_exports__["default"] = (_isArguments);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
/* harmony default export */ __webpack_exports__["default"] = (Array.isArray || function _isArray(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
});

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArrayLike.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArrayLike.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");
/* harmony import */ var _isString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_isString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isString.js");




/**
 * Tests whether or not an object is similar to an array.
 *
 * @private
 * @category Type
 * @category List
 * @sig * -> Boolean
 * @param {*} x The object to test.
 * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
 * @example
 *
 *      _isArrayLike([]); //=> true
 *      _isArrayLike(true); //=> false
 *      _isArrayLike({}); //=> false
 *      _isArrayLike({length: 10}); //=> false
 *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
 */
var _isArrayLike = /*#__PURE__*/Object(_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function isArrayLike(x) {
  if (Object(_isArray__WEBPACK_IMPORTED_MODULE_1__["default"])(x)) {
    return true;
  }
  if (!x) {
    return false;
  }
  if (typeof x !== 'object') {
    return false;
  }
  if (Object(_isString__WEBPACK_IMPORTED_MODULE_2__["default"])(x)) {
    return false;
  }
  if (x.nodeType === 1) {
    return !!x.length;
  }
  if (x.length === 0) {
    return true;
  }
  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }
  return false;
});
/* harmony default export */ __webpack_exports__["default"] = (_isArrayLike);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isFunction.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isFunction.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isFunction; });
function _isFunction(x) {
  return Object.prototype.toString.call(x) === '[object Function]';
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isInteger.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isInteger.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Determine if the passed argument is an integer.
 *
 * @private
 * @param {*} n
 * @category Type
 * @return {Boolean}
 */
/* harmony default export */ __webpack_exports__["default"] = (Number.isInteger || function _isInteger(n) {
  return n << 0 === n;
});

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isNumber.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isNumber.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isNumber; });
function _isNumber(x) {
  return Object.prototype.toString.call(x) === '[object Number]';
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isObject.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isObject.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isObject; });
function _isObject(x) {
  return Object.prototype.toString.call(x) === '[object Object]';
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isPlaceholder.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isPlaceholder.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isPlaceholder; });
function _isPlaceholder(a) {
       return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isRegExp.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isRegExp.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isRegExp; });
function _isRegExp(x) {
  return Object.prototype.toString.call(x) === '[object RegExp]';
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isString.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isString.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isString; });
function _isString(x) {
  return Object.prototype.toString.call(x) === '[object String]';
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isTransformer.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isTransformer.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isTransformer; });
function _isTransformer(obj) {
  return typeof obj['@@transducer/step'] === 'function';
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_makeFlat.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_makeFlat.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _makeFlat; });
/* harmony import */ var _isArrayLike__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArrayLike.js");


/**
 * `_makeFlat` is a helper function that returns a one-level or fully recursive
 * function based on the flag passed in.
 *
 * @private
 */
function _makeFlat(recursive) {
  return function flatt(list) {
    var value, jlen, j;
    var result = [];
    var idx = 0;
    var ilen = list.length;

    while (idx < ilen) {
      if (Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_0__["default"])(list[idx])) {
        value = recursive ? flatt(list[idx]) : list[idx];
        j = 0;
        jlen = value.length;
        while (j < jlen) {
          result[result.length] = value[j];
          j += 1;
        }
      } else {
        result[result.length] = list[idx];
      }
      idx += 1;
    }
    return result;
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_map.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_map.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _map; });
function _map(fn, functor) {
  var idx = 0;
  var len = functor.length;
  var result = Array(len);
  while (idx < len) {
    result[idx] = fn(functor[idx]);
    idx += 1;
  }
  return result;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_objectAssign.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_objectAssign.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectAssign; });
/* harmony import */ var _has__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");


// Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
function _objectAssign(target) {
  if (target == null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);
  var idx = 1;
  var length = arguments.length;
  while (idx < length) {
    var source = arguments[idx];
    if (source != null) {
      for (var nextKey in source) {
        if (Object(_has__WEBPACK_IMPORTED_MODULE_0__["default"])(nextKey, source)) {
          output[nextKey] = source[nextKey];
        }
      }
    }
    idx += 1;
  }
  return output;
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_of.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_of.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _of; });
function _of(x) {
  return [x];
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_pipe.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_pipe.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _pipe; });
function _pipe(f, g) {
  return function () {
    return g.call(this, f.apply(this, arguments));
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_pipeP.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_pipeP.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _pipeP; });
function _pipeP(f, g) {
  return function () {
    var ctx = this;
    return f.apply(ctx, arguments).then(function (x) {
      return g.call(ctx, x);
    });
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_quote.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_quote.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _quote; });
function _quote(s) {
  var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b') // \b matches word boundary; [\b] matches backspace
  .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');

  return '"' + escaped.replace(/"/g, '\\"') + '"';
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _reduce; });
/* harmony import */ var _isArrayLike__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArrayLike.js");
/* harmony import */ var _xwrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xwrap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xwrap.js");
/* harmony import */ var _bind__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../bind */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/bind.js");




function _arrayReduce(xf, acc, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    acc = xf['@@transducer/step'](acc, list[idx]);
    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }
    idx += 1;
  }
  return xf['@@transducer/result'](acc);
}

function _iterableReduce(xf, acc, iter) {
  var step = iter.next();
  while (!step.done) {
    acc = xf['@@transducer/step'](acc, step.value);
    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }
    step = iter.next();
  }
  return xf['@@transducer/result'](acc);
}

function _methodReduce(xf, acc, obj, methodName) {
  return xf['@@transducer/result'](obj[methodName](Object(_bind__WEBPACK_IMPORTED_MODULE_2__["default"])(xf['@@transducer/step'], xf), acc));
}

var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';

function _reduce(fn, acc, list) {
  if (typeof fn === 'function') {
    fn = Object(_xwrap__WEBPACK_IMPORTED_MODULE_1__["default"])(fn);
  }
  if (Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_0__["default"])(list)) {
    return _arrayReduce(fn, acc, list);
  }
  if (typeof list['fantasy-land/reduce'] === 'function') {
    return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
  }
  if (list[symIterator] != null) {
    return _iterableReduce(fn, acc, list[symIterator]());
  }
  if (typeof list.next === 'function') {
    return _iterableReduce(fn, acc, list);
  }
  if (typeof list.reduce === 'function') {
    return _methodReduce(fn, acc, list, 'reduce');
  }

  throw new TypeError('reduce: list must be array or iterable');
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _reduced; });
function _reduced(x) {
  return x && x['@@transducer/reduced'] ? x : {
    '@@transducer/value': x,
    '@@transducer/reduced': true
  };
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_stepCat.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_stepCat.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _stepCat; });
/* harmony import */ var _assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assign */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_assign.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_identity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_identity.js");
/* harmony import */ var _isArrayLike__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_isArrayLike */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArrayLike.js");
/* harmony import */ var _isTransformer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isTransformer */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isTransformer.js");
/* harmony import */ var _objOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../objOf */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/objOf.js");






var _stepCatArray = {
  '@@transducer/init': Array,
  '@@transducer/step': function (xs, x) {
    xs.push(x);
    return xs;
  },
  '@@transducer/result': _identity__WEBPACK_IMPORTED_MODULE_1__["default"]
};
var _stepCatString = {
  '@@transducer/init': String,
  '@@transducer/step': function (a, b) {
    return a + b;
  },
  '@@transducer/result': _identity__WEBPACK_IMPORTED_MODULE_1__["default"]
};
var _stepCatObject = {
  '@@transducer/init': Object,
  '@@transducer/step': function (result, input) {
    return Object(_assign__WEBPACK_IMPORTED_MODULE_0__["default"])(result, Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_2__["default"])(input) ? Object(_objOf__WEBPACK_IMPORTED_MODULE_4__["default"])(input[0], input[1]) : input);
  },
  '@@transducer/result': _identity__WEBPACK_IMPORTED_MODULE_1__["default"]
};

function _stepCat(obj) {
  if (Object(_isTransformer__WEBPACK_IMPORTED_MODULE_3__["default"])(obj)) {
    return obj;
  }
  if (Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_2__["default"])(obj)) {
    return _stepCatArray;
  }
  if (typeof obj === 'string') {
    return _stepCatString;
  }
  if (typeof obj === 'object') {
    return _stepCatObject;
  }
  throw new Error('Cannot create transformer for ' + obj);
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_toISOString.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_toISOString.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
 */
var pad = function pad(n) {
  return (n < 10 ? '0' : '') + n;
};

var _toISOString = typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
  return d.toISOString();
} : function _toISOString(d) {
  return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
};

/* harmony default export */ __webpack_exports__["default"] = (_toISOString);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_toString.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_toString.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _toString; });
/* harmony import */ var _contains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_contains */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_map.js");
/* harmony import */ var _quote__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_quote */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_quote.js");
/* harmony import */ var _toISOString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_toISOString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_toISOString.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");
/* harmony import */ var _reject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../reject */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reject.js");







function _toString(x, seen) {
  var recur = function recur(y) {
    var xs = seen.concat([x]);
    return Object(_contains__WEBPACK_IMPORTED_MODULE_0__["default"])(y, xs) ? '<Circular>' : _toString(y, xs);
  };

  //  mapPairs :: (Object, [String]) -> [String]
  var mapPairs = function (obj, keys) {
    return Object(_map__WEBPACK_IMPORTED_MODULE_1__["default"])(function (k) {
      return Object(_quote__WEBPACK_IMPORTED_MODULE_2__["default"])(k) + ': ' + recur(obj[k]);
    }, keys.slice().sort());
  };

  switch (Object.prototype.toString.call(x)) {
    case '[object Arguments]':
      return '(function() { return arguments; }(' + Object(_map__WEBPACK_IMPORTED_MODULE_1__["default"])(recur, x).join(', ') + '))';
    case '[object Array]':
      return '[' + Object(_map__WEBPACK_IMPORTED_MODULE_1__["default"])(recur, x).concat(mapPairs(x, Object(_reject__WEBPACK_IMPORTED_MODULE_5__["default"])(function (k) {
        return (/^\d+$/.test(k)
        );
      }, Object(_keys__WEBPACK_IMPORTED_MODULE_4__["default"])(x)))).join(', ') + ']';
    case '[object Boolean]':
      return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
    case '[object Date]':
      return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : Object(_quote__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_toISOString__WEBPACK_IMPORTED_MODULE_3__["default"])(x))) + ')';
    case '[object Null]':
      return 'null';
    case '[object Number]':
      return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
    case '[object String]':
      return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : Object(_quote__WEBPACK_IMPORTED_MODULE_2__["default"])(x);
    case '[object Undefined]':
      return 'undefined';
    default:
      if (typeof x.toString === 'function') {
        var repr = x.toString();
        if (repr !== '[object Object]') {
          return repr;
        }
      }
      return '{' + mapPairs(x, Object(_keys__WEBPACK_IMPORTED_MODULE_4__["default"])(x)).join(', ') + '}';
  }
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xall.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xall.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XAll = /*#__PURE__*/function () {
  function XAll(f, xf) {
    this.xf = xf;
    this.f = f;
    this.all = true;
  }
  XAll.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XAll.prototype['@@transducer/result'] = function (result) {
    if (this.all) {
      result = this.xf['@@transducer/step'](result, true);
    }
    return this.xf['@@transducer/result'](result);
  };
  XAll.prototype['@@transducer/step'] = function (result, input) {
    if (!this.f(input)) {
      this.all = false;
      result = Object(_reduced__WEBPACK_IMPORTED_MODULE_1__["default"])(this.xf['@@transducer/step'](result, false));
    }
    return result;
  };

  return XAll;
}();

var _xall = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xall(f, xf) {
  return new XAll(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xall);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xany.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xany.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XAny = /*#__PURE__*/function () {
  function XAny(f, xf) {
    this.xf = xf;
    this.f = f;
    this.any = false;
  }
  XAny.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XAny.prototype['@@transducer/result'] = function (result) {
    if (!this.any) {
      result = this.xf['@@transducer/step'](result, false);
    }
    return this.xf['@@transducer/result'](result);
  };
  XAny.prototype['@@transducer/step'] = function (result, input) {
    if (this.f(input)) {
      this.any = true;
      result = Object(_reduced__WEBPACK_IMPORTED_MODULE_1__["default"])(this.xf['@@transducer/step'](result, true));
    }
    return result;
  };

  return XAny;
}();

var _xany = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xany(f, xf) {
  return new XAny(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xany);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xaperture.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xaperture.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XAperture = /*#__PURE__*/function () {
  function XAperture(n, xf) {
    this.xf = xf;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n);
  }
  XAperture.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XAperture.prototype['@@transducer/result'] = function (result) {
    this.acc = null;
    return this.xf['@@transducer/result'](result);
  };
  XAperture.prototype['@@transducer/step'] = function (result, input) {
    this.store(input);
    return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
  };
  XAperture.prototype.store = function (input) {
    this.acc[this.pos] = input;
    this.pos += 1;
    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };
  XAperture.prototype.getCopy = function () {
    return Object(_concat__WEBPACK_IMPORTED_MODULE_0__["default"])(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
  };

  return XAperture;
}();

var _xaperture = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function _xaperture(n, xf) {
  return new XAperture(n, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xaperture);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xchain.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xchain.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _flatCat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_flatCat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_flatCat.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");




var _xchain = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xchain(f, xf) {
  return Object(_map__WEBPACK_IMPORTED_MODULE_2__["default"])(f, Object(_flatCat__WEBPACK_IMPORTED_MODULE_1__["default"])(xf));
});
/* harmony default export */ __webpack_exports__["default"] = (_xchain);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdrop.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdrop.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XDrop = /*#__PURE__*/function () {
  function XDrop(n, xf) {
    this.xf = xf;
    this.n = n;
  }
  XDrop.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XDrop.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].result;
  XDrop.prototype['@@transducer/step'] = function (result, input) {
    if (this.n > 0) {
      this.n -= 1;
      return result;
    }
    return this.xf['@@transducer/step'](result, input);
  };

  return XDrop;
}();

var _xdrop = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xdrop(n, xf) {
  return new XDrop(n, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xdrop);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropLast.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropLast.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XDropLast = /*#__PURE__*/function () {
  function XDropLast(n, xf) {
    this.xf = xf;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n);
  }
  XDropLast.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XDropLast.prototype['@@transducer/result'] = function (result) {
    this.acc = null;
    return this.xf['@@transducer/result'](result);
  };
  XDropLast.prototype['@@transducer/step'] = function (result, input) {
    if (this.full) {
      result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
    }
    this.store(input);
    return result;
  };
  XDropLast.prototype.store = function (input) {
    this.acc[this.pos] = input;
    this.pos += 1;
    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };

  return XDropLast;
}();

var _xdropLast = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xdropLast(n, xf) {
  return new XDropLast(n, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xdropLast);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropLastWhile.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropLastWhile.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XDropLastWhile = /*#__PURE__*/function () {
  function XDropLastWhile(fn, xf) {
    this.f = fn;
    this.retained = [];
    this.xf = xf;
  }
  XDropLastWhile.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XDropLastWhile.prototype['@@transducer/result'] = function (result) {
    this.retained = null;
    return this.xf['@@transducer/result'](result);
  };
  XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.retain(result, input) : this.flush(result, input);
  };
  XDropLastWhile.prototype.flush = function (result, input) {
    result = Object(_reduce__WEBPACK_IMPORTED_MODULE_1__["default"])(this.xf['@@transducer/step'], result, this.retained);
    this.retained = [];
    return this.xf['@@transducer/step'](result, input);
  };
  XDropLastWhile.prototype.retain = function (result, input) {
    this.retained.push(input);
    return result;
  };

  return XDropLastWhile;
}();

var _xdropLastWhile = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xdropLastWhile(fn, xf) {
  return new XDropLastWhile(fn, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xdropLastWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropRepeatsWith.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropRepeatsWith.js ***!
  \***********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XDropRepeatsWith = /*#__PURE__*/function () {
  function XDropRepeatsWith(pred, xf) {
    this.xf = xf;
    this.pred = pred;
    this.lastValue = undefined;
    this.seenFirstValue = false;
  }

  XDropRepeatsWith.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XDropRepeatsWith.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].result;
  XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
    var sameAsLast = false;
    if (!this.seenFirstValue) {
      this.seenFirstValue = true;
    } else if (this.pred(this.lastValue, input)) {
      sameAsLast = true;
    }
    this.lastValue = input;
    return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
  };

  return XDropRepeatsWith;
}();

var _xdropRepeatsWith = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xdropRepeatsWith(pred, xf) {
  return new XDropRepeatsWith(pred, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xdropRepeatsWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropWhile.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xdropWhile.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XDropWhile = /*#__PURE__*/function () {
  function XDropWhile(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XDropWhile.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XDropWhile.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].result;
  XDropWhile.prototype['@@transducer/step'] = function (result, input) {
    if (this.f) {
      if (this.f(input)) {
        return result;
      }
      this.f = null;
    }
    return this.xf['@@transducer/step'](result, input);
  };

  return XDropWhile;
}();

var _xdropWhile = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xdropWhile(f, xf) {
  return new XDropWhile(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xdropWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  init: function () {
    return this.xf['@@transducer/init']();
  },
  result: function (result) {
    return this.xf['@@transducer/result'](result);
  }
});

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfilter.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfilter.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XFilter = /*#__PURE__*/function () {
  function XFilter(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XFilter.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XFilter.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].result;
  XFilter.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
  };

  return XFilter;
}();

var _xfilter = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xfilter(f, xf) {
  return new XFilter(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xfilter);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfind.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfind.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XFind = /*#__PURE__*/function () {
  function XFind(f, xf) {
    this.xf = xf;
    this.f = f;
    this.found = false;
  }
  XFind.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XFind.prototype['@@transducer/result'] = function (result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, void 0);
    }
    return this.xf['@@transducer/result'](result);
  };
  XFind.prototype['@@transducer/step'] = function (result, input) {
    if (this.f(input)) {
      this.found = true;
      result = Object(_reduced__WEBPACK_IMPORTED_MODULE_1__["default"])(this.xf['@@transducer/step'](result, input));
    }
    return result;
  };

  return XFind;
}();

var _xfind = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xfind(f, xf) {
  return new XFind(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xfind);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindIndex.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindIndex.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XFindIndex = /*#__PURE__*/function () {
  function XFindIndex(f, xf) {
    this.xf = xf;
    this.f = f;
    this.idx = -1;
    this.found = false;
  }
  XFindIndex.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XFindIndex.prototype['@@transducer/result'] = function (result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, -1);
    }
    return this.xf['@@transducer/result'](result);
  };
  XFindIndex.prototype['@@transducer/step'] = function (result, input) {
    this.idx += 1;
    if (this.f(input)) {
      this.found = true;
      result = Object(_reduced__WEBPACK_IMPORTED_MODULE_1__["default"])(this.xf['@@transducer/step'](result, this.idx));
    }
    return result;
  };

  return XFindIndex;
}();

var _xfindIndex = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xfindIndex(f, xf) {
  return new XFindIndex(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xfindIndex);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindLast.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindLast.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XFindLast = /*#__PURE__*/function () {
  function XFindLast(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XFindLast.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XFindLast.prototype['@@transducer/result'] = function (result) {
    return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
  };
  XFindLast.prototype['@@transducer/step'] = function (result, input) {
    if (this.f(input)) {
      this.last = input;
    }
    return result;
  };

  return XFindLast;
}();

var _xfindLast = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xfindLast(f, xf) {
  return new XFindLast(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xfindLast);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindLastIndex.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfindLastIndex.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XFindLastIndex = /*#__PURE__*/function () {
  function XFindLastIndex(f, xf) {
    this.xf = xf;
    this.f = f;
    this.idx = -1;
    this.lastIdx = -1;
  }
  XFindLastIndex.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XFindLastIndex.prototype['@@transducer/result'] = function (result) {
    return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
  };
  XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
    this.idx += 1;
    if (this.f(input)) {
      this.lastIdx = this.idx;
    }
    return result;
  };

  return XFindLastIndex;
}();

var _xfindLastIndex = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xfindLastIndex(f, xf) {
  return new XFindLastIndex(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xfindLastIndex);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xmap.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xmap.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XMap = /*#__PURE__*/function () {
  function XMap(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XMap.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XMap.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].result;
  XMap.prototype['@@transducer/step'] = function (result, input) {
    return this.xf['@@transducer/step'](result, this.f(input));
  };

  return XMap;
}();

var _xmap = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xmap(f, xf) {
  return new XMap(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xmap);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xreduceBy.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xreduceBy.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curryN.js");
/* harmony import */ var _has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XReduceBy = /*#__PURE__*/function () {
  function XReduceBy(valueFn, valueAcc, keyFn, xf) {
    this.valueFn = valueFn;
    this.valueAcc = valueAcc;
    this.keyFn = keyFn;
    this.xf = xf;
    this.inputs = {};
  }
  XReduceBy.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XReduceBy.prototype['@@transducer/result'] = function (result) {
    var key;
    for (key in this.inputs) {
      if (Object(_has__WEBPACK_IMPORTED_MODULE_1__["default"])(key, this.inputs)) {
        result = this.xf['@@transducer/step'](result, this.inputs[key]);
        if (result['@@transducer/reduced']) {
          result = result['@@transducer/value'];
          break;
        }
      }
    }
    this.inputs = null;
    return this.xf['@@transducer/result'](result);
  };
  XReduceBy.prototype['@@transducer/step'] = function (result, input) {
    var key = this.keyFn(input);
    this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
    this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
    return result;
  };

  return XReduceBy;
}();

var _xreduceBy = /*#__PURE__*/Object(_curryN__WEBPACK_IMPORTED_MODULE_0__["default"])(4, [], function _xreduceBy(valueFn, valueAcc, keyFn, xf) {
  return new XReduceBy(valueFn, valueAcc, keyFn, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xreduceBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtake.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtake.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XTake = /*#__PURE__*/function () {
  function XTake(n, xf) {
    this.xf = xf;
    this.n = n;
    this.i = 0;
  }
  XTake.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XTake.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].result;
  XTake.prototype['@@transducer/step'] = function (result, input) {
    this.i += 1;
    var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
    return this.n >= 0 && this.i >= this.n ? Object(_reduced__WEBPACK_IMPORTED_MODULE_1__["default"])(ret) : ret;
  };

  return XTake;
}();

var _xtake = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xtake(n, xf) {
  return new XTake(n, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xtake);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtakeWhile.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtakeWhile.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _reduced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");




var XTakeWhile = /*#__PURE__*/function () {
  function XTakeWhile(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XTakeWhile.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].init;
  XTakeWhile.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_2__["default"].result;
  XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.xf['@@transducer/step'](result, input) : Object(_reduced__WEBPACK_IMPORTED_MODULE_1__["default"])(result);
  };

  return XTakeWhile;
}();

var _xtakeWhile = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xtakeWhile(f, xf) {
  return new XTakeWhile(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xtakeWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtap.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtap.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _xfBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_xfBase */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xfBase.js");



var XTap = /*#__PURE__*/function () {
  function XTap(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XTap.prototype['@@transducer/init'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].init;
  XTap.prototype['@@transducer/result'] = _xfBase__WEBPACK_IMPORTED_MODULE_1__["default"].result;
  XTap.prototype['@@transducer/step'] = function (result, input) {
    this.f(input);
    return this.xf['@@transducer/step'](result, input);
  };

  return XTap;
}();

var _xtap = /*#__PURE__*/Object(_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function _xtap(f, xf) {
  return new XTap(f, xf);
});
/* harmony default export */ __webpack_exports__["default"] = (_xtap);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xwrap.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xwrap.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _xwrap; });
var XWrap = /*#__PURE__*/function () {
  function XWrap(fn) {
    this.f = fn;
  }
  XWrap.prototype['@@transducer/init'] = function () {
    throw new Error('init not implemented on XWrap');
  };
  XWrap.prototype['@@transducer/result'] = function (acc) {
    return acc;
  };
  XWrap.prototype['@@transducer/step'] = function (acc, x) {
    return this.f(acc, x);
  };

  return XWrap;
}();

function _xwrap(fn) {
  return new XWrap(fn);
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/intersection.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/intersection.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_contains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_contains */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_filter */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_filter.js");
/* harmony import */ var _flip__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flip */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flip.js");
/* harmony import */ var _uniq__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./uniq */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniq.js");






/**
 * Combines two lists into a set (i.e. no duplicates) composed of those
 * elements common to both lists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The list of elements found in both `list1` and `list2`.
 * @see R.innerJoin
 * @example
 *
 *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
 */
var intersection = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function intersection(list1, list2) {
  var lookupList, filteredList;
  if (list1.length > list2.length) {
    lookupList = list1;
    filteredList = list2;
  } else {
    lookupList = list2;
    filteredList = list1;
  }
  return Object(_uniq__WEBPACK_IMPORTED_MODULE_4__["default"])(Object(_internal_filter__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_flip__WEBPACK_IMPORTED_MODULE_3__["default"])(_internal_contains__WEBPACK_IMPORTED_MODULE_0__["default"])(lookupList), filteredList));
});
/* harmony default export */ __webpack_exports__["default"] = (intersection);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/intersperse.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/intersperse.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_checkForMethod */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_checkForMethod.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Creates a new list with the separator interposed between elements.
 *
 * Dispatches to the `intersperse` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig a -> [a] -> [a]
 * @param {*} separator The element to add to the list.
 * @param {Array} list The list to be interposed.
 * @return {Array} The new list.
 * @example
 *
 *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
 */
var intersperse = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__["default"])('intersperse', function intersperse(separator, list) {
  var out = [];
  var idx = 0;
  var length = list.length;
  while (idx < length) {
    if (idx === length - 1) {
      out.push(list[idx]);
    } else {
      out.push(list[idx], separator);
    }
    idx += 1;
  }
  return out;
}));
/* harmony default export */ __webpack_exports__["default"] = (intersperse);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/into.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/into.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_clone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_clone */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_clone.js");
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _internal_isTransformer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_isTransformer */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isTransformer.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _internal_stepCat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/_stepCat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_stepCat.js");






/**
 * Transforms the items of the list with the transducer and appends the
 * transformed items to the accumulator using an appropriate iterator function
 * based on the accumulator type.
 *
 * The accumulator can be an array, string, object or a transformer. Iterated
 * items will be appended to arrays and concatenated to strings. Objects will
 * be merged directly or 2-item arrays will be merged as key, value pairs.
 *
 * The accumulator can also be a transformer object that provides a 2-arity
 * reducing iterator function, step, 0-arity initial value function, init, and
 * 1-arity result extraction function result. The step function is used as the
 * iterator function in reduce. The result function is used to convert the
 * final accumulator into the return type and in most cases is R.identity. The
 * init function is used to provide the initial accumulator.
 *
 * The iteration is performed with [`R.reduce`](#reduce) after initializing the
 * transducer.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig a -> (b -> b) -> [c] -> a
 * @param {*} acc The initial accumulator value.
 * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @example
 *
 *      var numbers = [1, 2, 3, 4];
 *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
 *
 *      R.into([], transducer, numbers); //=> [2, 3]
 *
 *      var intoArray = R.into([]);
 *      intoArray(transducer, numbers); //=> [2, 3]
 */
var into = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_1__["default"])(function into(acc, xf, list) {
  return Object(_internal_isTransformer__WEBPACK_IMPORTED_MODULE_2__["default"])(acc) ? Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_3__["default"])(xf(acc), acc['@@transducer/init'](), list) : Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_3__["default"])(xf(Object(_internal_stepCat__WEBPACK_IMPORTED_MODULE_4__["default"])(acc)), Object(_internal_clone__WEBPACK_IMPORTED_MODULE_0__["default"])(acc, [], [], false), list);
});
/* harmony default export */ __webpack_exports__["default"] = (into);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invert.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invert.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");




/**
 * Same as [`R.invertObj`](#invertObj), however this accounts for objects with
 * duplicate values by putting the values into an array.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig {s: x} -> {x: [ s, ... ]}
 * @param {Object} obj The object or array to invert
 * @return {Object} out A new object with keys in an array.
 * @see R.invertObj
 * @example
 *
 *      var raceResultsByFirstName = {
 *        first: 'alice',
 *        second: 'jake',
 *        third: 'alice',
 *      };
 *      R.invert(raceResultsByFirstName);
 *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
 */
var invert = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function invert(obj) {
  var props = Object(_keys__WEBPACK_IMPORTED_MODULE_2__["default"])(obj);
  var len = props.length;
  var idx = 0;
  var out = {};

  while (idx < len) {
    var key = props[idx];
    var val = obj[key];
    var list = Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(val, out) ? out[val] : out[val] = [];
    list[list.length] = key;
    idx += 1;
  }
  return out;
});
/* harmony default export */ __webpack_exports__["default"] = (invert);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invertObj.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invertObj.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");



/**
 * Returns a new object with the keys of the given object as values, and the
 * values of the given object, which are coerced to strings, as keys. Note
 * that the last key found is preferred when handling the same value.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig {s: x} -> {x: s}
 * @param {Object} obj The object or array to invert
 * @return {Object} out A new object
 * @see R.invert
 * @example
 *
 *      var raceResults = {
 *        first: 'alice',
 *        second: 'jake'
 *      };
 *      R.invertObj(raceResults);
 *      //=> { 'alice': 'first', 'jake':'second' }
 *
 *      // Alternatively:
 *      var raceResults = ['alice', 'jake'];
 *      R.invertObj(raceResults);
 *      //=> { 'alice': '0', 'jake':'1' }
 */
var invertObj = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function invertObj(obj) {
  var props = Object(_keys__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
  var len = props.length;
  var idx = 0;
  var out = {};

  while (idx < len) {
    var key = props[idx];
    out[obj[key]] = key;
    idx += 1;
  }
  return out;
});
/* harmony default export */ __webpack_exports__["default"] = (invertObj);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invoker.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invoker.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isFunction */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isFunction.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toString.js");





/**
 * Turns a named method with a specified arity into a function that can be
 * called directly supplied with arguments and a target object.
 *
 * The returned function is curried and accepts `arity + 1` parameters where
 * the final parameter is the target object.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
 * @param {Number} arity Number of arguments the returned function should take
 *        before the target object.
 * @param {String} method Name of the method to call.
 * @return {Function} A new curried function.
 * @see R.construct
 * @example
 *
 *      var sliceFrom = R.invoker(1, 'slice');
 *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
 *      var sliceFrom6 = R.invoker(2, 'slice')(6);
 *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
 * @symb R.invoker(0, 'method')(o) = o['method']()
 * @symb R.invoker(1, 'method')(a, o) = o['method'](a)
 * @symb R.invoker(2, 'method')(a, b, o) = o['method'](a, b)
 */
var invoker = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function invoker(arity, method) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_2__["default"])(arity + 1, function () {
    var target = arguments[arity];
    if (target != null && Object(_internal_isFunction__WEBPACK_IMPORTED_MODULE_1__["default"])(target[method])) {
      return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
    }
    throw new TypeError(Object(_toString__WEBPACK_IMPORTED_MODULE_3__["default"])(target) + ' does not have a method named "' + method + '"');
  });
});
/* harmony default export */ __webpack_exports__["default"] = (invoker);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/is.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/is.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * See if an object (`val`) is an instance of the supplied constructor. This
 * function will check up the inheritance chain, if any.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Type
 * @sig (* -> {*}) -> a -> Boolean
 * @param {Object} ctor A constructor
 * @param {*} val The value to test
 * @return {Boolean}
 * @example
 *
 *      R.is(Object, {}); //=> true
 *      R.is(Number, 1); //=> true
 *      R.is(Object, 1); //=> false
 *      R.is(String, 's'); //=> true
 *      R.is(String, new String('')); //=> true
 *      R.is(Object, new String('')); //=> true
 *      R.is(Object, 's'); //=> false
 *      R.is(Number, {}); //=> false
 */
var is = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function is(Ctor, val) {
  return val != null && val.constructor === Ctor || val instanceof Ctor;
});
/* harmony default export */ __webpack_exports__["default"] = (is);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/isEmpty.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/isEmpty.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./empty */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/empty.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");




/**
 * Returns `true` if the given value is its type's empty value; `false`
 * otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig a -> Boolean
 * @param {*} x
 * @return {Boolean}
 * @see R.empty
 * @example
 *
 *      R.isEmpty([1, 2, 3]);   //=> false
 *      R.isEmpty([]);          //=> true
 *      R.isEmpty('');          //=> true
 *      R.isEmpty(null);        //=> false
 *      R.isEmpty({});          //=> true
 *      R.isEmpty({length: 0}); //=> false
 */
var isEmpty = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function isEmpty(x) {
  return x != null && Object(_equals__WEBPACK_IMPORTED_MODULE_2__["default"])(x, Object(_empty__WEBPACK_IMPORTED_MODULE_1__["default"])(x));
});
/* harmony default export */ __webpack_exports__["default"] = (isEmpty);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/isNil.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/isNil.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Checks if the input value is `null` or `undefined`.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Type
 * @sig * -> Boolean
 * @param {*} x The value to test.
 * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
 * @example
 *
 *      R.isNil(null); //=> true
 *      R.isNil(undefined); //=> true
 *      R.isNil(0); //=> false
 *      R.isNil([]); //=> false
 */
var isNil = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function isNil(x) {
  return x == null;
});
/* harmony default export */ __webpack_exports__["default"] = (isNil);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/join.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/join.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _invoker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invoker */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invoker.js");


/**
 * Returns a string made by inserting the `separator` between each element and
 * concatenating all the elements into a single string.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig String -> [a] -> String
 * @param {Number|String} separator The string used to separate the elements.
 * @param {Array} xs The elements to join into a string.
 * @return {String} str The string made by concatenating `xs` with `separator`.
 * @see R.split
 * @example
 *
 *      var spacer = R.join(' ');
 *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
 *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
 */
var join = /*#__PURE__*/Object(_invoker__WEBPACK_IMPORTED_MODULE_0__["default"])(1, 'join');
/* harmony default export */ __webpack_exports__["default"] = (join);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/juxt.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/juxt.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _converge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./converge */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/converge.js");



/**
 * juxt applies a list of functions to a list of values.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Function
 * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
 * @param {Array} fns An array of functions
 * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
 * @see R.applySpec
 * @example
 *
 *      var getRange = R.juxt([Math.min, Math.max]);
 *      getRange(3, 4, 9, -3); //=> [-3, 9]
 * @symb R.juxt([f, g, h])(a, b) = [f(a, b), g(a, b), h(a, b)]
 */
var juxt = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function juxt(fns) {
  return Object(_converge__WEBPACK_IMPORTED_MODULE_1__["default"])(function () {
    return Array.prototype.slice.call(arguments, 0);
  }, fns);
});
/* harmony default export */ __webpack_exports__["default"] = (juxt);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");
/* harmony import */ var _internal_isArguments__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_isArguments */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArguments.js");




// cover IE < 9 keys issues
var hasEnumBug = ! /*#__PURE__*/{ toString: null }.propertyIsEnumerable('toString');
var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
// Safari bug
var hasArgsEnumBug = /*#__PURE__*/function () {
  'use strict';

  return arguments.propertyIsEnumerable('length');
}();

var contains = function contains(list, item) {
  var idx = 0;
  while (idx < list.length) {
    if (list[idx] === item) {
      return true;
    }
    idx += 1;
  }
  return false;
};

/**
 * Returns a list containing the names of all the enumerable own properties of
 * the supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own properties.
 * @see R.keysIn, R.values
 * @example
 *
 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
 */
var _keys = typeof Object.keys === 'function' && !hasArgsEnumBug ? function keys(obj) {
  return Object(obj) !== obj ? [] : Object.keys(obj);
} : function keys(obj) {
  if (Object(obj) !== obj) {
    return [];
  }
  var prop, nIdx;
  var ks = [];
  var checkArgsLength = hasArgsEnumBug && Object(_internal_isArguments__WEBPACK_IMPORTED_MODULE_2__["default"])(obj);
  for (prop in obj) {
    if (Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(prop, obj) && (!checkArgsLength || prop !== 'length')) {
      ks[ks.length] = prop;
    }
  }
  if (hasEnumBug) {
    nIdx = nonEnumerableProps.length - 1;
    while (nIdx >= 0) {
      prop = nonEnumerableProps[nIdx];
      if (Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(prop, obj) && !contains(ks, prop)) {
        ks[ks.length] = prop;
      }
      nIdx -= 1;
    }
  }
  return ks;
};
var keys = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(_keys);
/* harmony default export */ __webpack_exports__["default"] = (keys);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keysIn.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keysIn.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Returns a list containing the names of all the properties of the supplied
 * object, including prototype properties.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own and prototype properties.
 * @see R.keys, R.valuesIn
 * @example
 *
 *      var F = function() { this.x = 'X'; };
 *      F.prototype.y = 'Y';
 *      var f = new F();
 *      R.keysIn(f); //=> ['x', 'y']
 */
var keysIn = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function keysIn(obj) {
  var prop;
  var ks = [];
  for (prop in obj) {
    ks[ks.length] = prop;
  }
  return ks;
});
/* harmony default export */ __webpack_exports__["default"] = (keysIn);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/last.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/last.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nth */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nth.js");


/**
 * Returns the last element of the given list or string.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig [a] -> a | Undefined
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.init, R.head, R.tail
 * @example
 *
 *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
 *      R.last([]); //=> undefined
 *
 *      R.last('abc'); //=> 'c'
 *      R.last(''); //=> ''
 */
var last = /*#__PURE__*/Object(_nth__WEBPACK_IMPORTED_MODULE_0__["default"])(-1);
/* harmony default export */ __webpack_exports__["default"] = (last);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lastIndexOf.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lastIndexOf.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isArray */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isArray.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");




/**
 * Returns the position of the last occurrence of an item in an array, or -1 if
 * the item is not included in the array. [`R.equals`](#equals) is used to
 * determine equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> Number
 * @param {*} target The item to find.
 * @param {Array} xs The array to search in.
 * @return {Number} the index of the target, or -1 if the target is not found.
 * @see R.indexOf
 * @example
 *
 *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
 *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
 */
var lastIndexOf = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function lastIndexOf(target, xs) {
  if (typeof xs.lastIndexOf === 'function' && !Object(_internal_isArray__WEBPACK_IMPORTED_MODULE_1__["default"])(xs)) {
    return xs.lastIndexOf(target);
  } else {
    var idx = xs.length - 1;
    while (idx >= 0) {
      if (Object(_equals__WEBPACK_IMPORTED_MODULE_2__["default"])(xs[idx], target)) {
        return idx;
      }
      idx -= 1;
    }
    return -1;
  }
});
/* harmony default export */ __webpack_exports__["default"] = (lastIndexOf);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/length.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/length.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_isNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isNumber */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isNumber.js");



/**
 * Returns the number of elements in the array by returning `list.length`.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig [a] -> Number
 * @param {Array} list The array to inspect.
 * @return {Number} The length of the array.
 * @example
 *
 *      R.length([]); //=> 0
 *      R.length([1, 2, 3]); //=> 3
 */
var length = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function length(list) {
  return list != null && Object(_internal_isNumber__WEBPACK_IMPORTED_MODULE_1__["default"])(list.length) ? list.length : NaN;
});
/* harmony default export */ __webpack_exports__["default"] = (length);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lens.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lens.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");



/**
 * Returns a lens for the given getter and setter functions. The getter "gets"
 * the value of the focus; the setter "sets" the value of the focus. The setter
 * should not mutate the data structure.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
 * @param {Function} getter
 * @param {Function} setter
 * @return {Lens}
 * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
 * @example
 *
 *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
 *
 *      R.view(xLens, {x: 1, y: 2});            //=> 1
 *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
 *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
 */
var lens = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function lens(getter, setter) {
  return function (toFunctorFn) {
    return function (target) {
      return Object(_map__WEBPACK_IMPORTED_MODULE_1__["default"])(function (focus) {
        return setter(focus, target);
      }, toFunctorFn(getter(target)));
    };
  };
});
/* harmony default export */ __webpack_exports__["default"] = (lens);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensIndex.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensIndex.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _lens__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lens */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lens.js");
/* harmony import */ var _nth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nth */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nth.js");
/* harmony import */ var _update__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./update */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/update.js");





/**
 * Returns a lens whose focus is the specified index.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Number -> Lens s a
 * @param {Number} n
 * @return {Lens}
 * @see R.view, R.set, R.over
 * @example
 *
 *      var headLens = R.lensIndex(0);
 *
 *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
 *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
 *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
 */
var lensIndex = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function lensIndex(n) {
  return Object(_lens__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_nth__WEBPACK_IMPORTED_MODULE_2__["default"])(n), Object(_update__WEBPACK_IMPORTED_MODULE_3__["default"])(n));
});
/* harmony default export */ __webpack_exports__["default"] = (lensIndex);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensPath.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensPath.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _assocPath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assocPath */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assocPath.js");
/* harmony import */ var _lens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lens */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lens.js");
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./path */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js");





/**
 * Returns a lens whose focus is the specified path.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Object
 * @typedefn Idx = String | Int
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig [Idx] -> Lens s a
 * @param {Array} path The path to use.
 * @return {Lens}
 * @see R.view, R.set, R.over
 * @example
 *
 *      var xHeadYLens = R.lensPath(['x', 0, 'y']);
 *
 *      R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
 *      //=> 2
 *      R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
 *      //=> {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
 *      R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
 *      //=> {x: [{y: -2, z: 3}, {y: 4, z: 5}]}
 */
var lensPath = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function lensPath(p) {
  return Object(_lens__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_path__WEBPACK_IMPORTED_MODULE_3__["default"])(p), Object(_assocPath__WEBPACK_IMPORTED_MODULE_1__["default"])(p));
});
/* harmony default export */ __webpack_exports__["default"] = (lensPath);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensProp.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lensProp.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _assoc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assoc */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/assoc.js");
/* harmony import */ var _lens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lens */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lens.js");
/* harmony import */ var _prop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./prop */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prop.js");





/**
 * Returns a lens whose focus is the specified property.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig String -> Lens s a
 * @param {String} k
 * @return {Lens}
 * @see R.view, R.set, R.over
 * @example
 *
 *      var xLens = R.lensProp('x');
 *
 *      R.view(xLens, {x: 1, y: 2});            //=> 1
 *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
 *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
 */
var lensProp = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function lensProp(k) {
  return Object(_lens__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_prop__WEBPACK_IMPORTED_MODULE_3__["default"])(k), Object(_assoc__WEBPACK_IMPORTED_MODULE_1__["default"])(k));
});
/* harmony default export */ __webpack_exports__["default"] = (lensProp);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lift.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lift.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _liftN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./liftN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/liftN.js");



/**
 * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other
 * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Function
 * @sig (*... -> *) -> ([*]... -> [*])
 * @param {Function} fn The function to lift into higher context
 * @return {Function} The lifted function.
 * @see R.liftN
 * @example
 *
 *      var madd3 = R.lift((a, b, c) => a + b + c);
 *
 *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
 *
 *      var madd5 = R.lift((a, b, c, d, e) => a + b + c + d + e);
 *
 *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
 */
var lift = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function lift(fn) {
  return Object(_liftN__WEBPACK_IMPORTED_MODULE_1__["default"])(fn.length, fn);
});
/* harmony default export */ __webpack_exports__["default"] = (lift);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/liftN.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/liftN.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _ap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ap.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");






/**
 * "lifts" a function to be the specified arity, so that it may "map over" that
 * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Function
 * @sig Number -> (*... -> *) -> ([*]... -> [*])
 * @param {Function} fn The function to lift into higher context
 * @return {Function} The lifted function.
 * @see R.lift, R.ap
 * @example
 *
 *      var madd3 = R.liftN(3, (...args) => R.sum(args));
 *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
 */
var liftN = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function liftN(arity, fn) {
  var lifted = Object(_curryN__WEBPACK_IMPORTED_MODULE_3__["default"])(arity, fn);
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_3__["default"])(arity, function () {
    return Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_1__["default"])(_ap__WEBPACK_IMPORTED_MODULE_2__["default"], Object(_map__WEBPACK_IMPORTED_MODULE_4__["default"])(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
  });
});
/* harmony default export */ __webpack_exports__["default"] = (liftN);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lt.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lt.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns `true` if the first argument is less than the second; `false`
 * otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @see R.gt
 * @example
 *
 *      R.lt(2, 1); //=> false
 *      R.lt(2, 2); //=> false
 *      R.lt(2, 3); //=> true
 *      R.lt('a', 'z'); //=> true
 *      R.lt('z', 'a'); //=> false
 */
var lt = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function lt(a, b) {
  return a < b;
});
/* harmony default export */ __webpack_exports__["default"] = (lt);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lte.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/lte.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns `true` if the first argument is less than or equal to the second;
 * `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {Number} a
 * @param {Number} b
 * @return {Boolean}
 * @see R.gte
 * @example
 *
 *      R.lte(2, 1); //=> false
 *      R.lte(2, 2); //=> true
 *      R.lte(2, 3); //=> true
 *      R.lte('a', 'z'); //=> true
 *      R.lte('z', 'a'); //=> false
 */
var lte = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function lte(a, b) {
  return a <= b;
});
/* harmony default export */ __webpack_exports__["default"] = (lte);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_map.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _internal_xmap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/_xmap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xmap.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");








/**
 * Takes a function and
 * a [functor](https://github.com/fantasyland/fantasy-land#functor),
 * applies the function to each of the functor's values, and returns
 * a functor of the same shape.
 *
 * Ramda provides suitable `map` implementations for `Array` and `Object`,
 * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
 *
 * Dispatches to the `map` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * Also treats functions as functors and will compose them together.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Functor f => (a -> b) -> f a -> f b
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {Array} list The list to be iterated over.
 * @return {Array} The new list.
 * @see R.transduce, R.addIndex
 * @example
 *
 *      var double = x => x * 2;
 *
 *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
 *
 *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
 * @symb R.map(f, [a, b]) = [f(a), f(b)]
 * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
 * @symb R.map(f, functor_o) = functor_o.map(f)
 */
var map = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['fantasy-land/map', 'map'], _internal_xmap__WEBPACK_IMPORTED_MODULE_4__["default"], function map(fn, functor) {
  switch (Object.prototype.toString.call(functor)) {
    case '[object Function]':
      return Object(_curryN__WEBPACK_IMPORTED_MODULE_5__["default"])(functor.length, function () {
        return fn.call(this, functor.apply(this, arguments));
      });
    case '[object Object]':
      return Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_3__["default"])(function (acc, key) {
        acc[key] = fn(functor[key]);
        return acc;
      }, {}, Object(_keys__WEBPACK_IMPORTED_MODULE_6__["default"])(functor));
    default:
      return Object(_internal_map__WEBPACK_IMPORTED_MODULE_2__["default"])(fn, functor);
  }
}));
/* harmony default export */ __webpack_exports__["default"] = (map);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapAccum.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapAccum.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * The `mapAccum` function behaves like a combination of map and reduce; it
 * applies a function to each element of a list, passing an accumulating
 * parameter from left to right, and returning a final value of this
 * accumulator together with the new list.
 *
 * The iterator function receives two arguments, *acc* and *value*, and should
 * return a tuple *[acc, value]*.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig ((acc, x) -> (acc, y)) -> acc -> [x] -> (acc, [y])
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.addIndex, R.mapAccumRight
 * @example
 *
 *      var digits = ['1', '2', '3', '4'];
 *      var appender = (a, b) => [a + b, a + b];
 *
 *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
 * @symb R.mapAccum(f, a, [b, c, d]) = [
 *   f(f(f(a, b)[0], c)[0], d)[0],
 *   [
 *     f(a, b)[1],
 *     f(f(a, b)[0], c)[1],
 *     f(f(f(a, b)[0], c)[0], d)[1]
 *   ]
 * ]
 */
var mapAccum = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function mapAccum(fn, acc, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  var tuple = [acc];
  while (idx < len) {
    tuple = fn(tuple[0], list[idx]);
    result[idx] = tuple[1];
    idx += 1;
  }
  return [tuple[0], result];
});
/* harmony default export */ __webpack_exports__["default"] = (mapAccum);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapAccumRight.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapAccumRight.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * The `mapAccumRight` function behaves like a combination of map and reduce; it
 * applies a function to each element of a list, passing an accumulating
 * parameter from right to left, and returning a final value of this
 * accumulator together with the new list.
 *
 * Similar to [`mapAccum`](#mapAccum), except moves through the input list from
 * the right to the left.
 *
 * The iterator function receives two arguments, *value* and *acc*, and should
 * return a tuple *[value, acc]*.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig ((x, acc) -> (y, acc)) -> acc -> [x] -> ([y], acc)
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.addIndex, R.mapAccum
 * @example
 *
 *      var digits = ['1', '2', '3', '4'];
 *      var append = (a, b) => [a + b, a + b];
 *
 *      R.mapAccumRight(append, 5, digits); //=> [['12345', '2345', '345', '45'], '12345']
 * @symb R.mapAccumRight(f, a, [b, c, d]) = [
 *   [
 *     f(b, f(c, f(d, a)[0])[0])[1],
 *     f(c, f(d, a)[0])[1],
 *     f(d, a)[1],
 *   ]
 *   f(b, f(c, f(d, a)[0])[0])[0],
 * ]
 */
var mapAccumRight = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function mapAccumRight(fn, acc, list) {
  var idx = list.length - 1;
  var result = [];
  var tuple = [acc];
  while (idx >= 0) {
    tuple = fn(list[idx], tuple[0]);
    result[idx] = tuple[1];
    idx -= 1;
  }
  return [result, tuple[0]];
});
/* harmony default export */ __webpack_exports__["default"] = (mapAccumRight);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapObjIndexed.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mapObjIndexed.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");




/**
 * An Object-specific version of [`map`](#map). The function is applied to three
 * arguments: *(value, key, obj)*. If only the value is significant, use
 * [`map`](#map) instead.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig ((*, String, Object) -> *) -> Object -> Object
 * @param {Function} fn
 * @param {Object} obj
 * @return {Object}
 * @see R.map
 * @example
 *
 *      var values = { x: 1, y: 2, z: 3 };
 *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
 *
 *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
 */
var mapObjIndexed = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function mapObjIndexed(fn, obj) {
  return Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_1__["default"])(function (acc, key) {
    acc[key] = fn(obj[key], key, obj);
    return acc;
  }, {}, Object(_keys__WEBPACK_IMPORTED_MODULE_2__["default"])(obj));
});
/* harmony default export */ __webpack_exports__["default"] = (mapObjIndexed);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/match.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/match.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Tests a regular expression against a String. Note that this function will
 * return an empty array when there are no matches. This differs from
 * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
 * which returns `null` when there are no matches.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category String
 * @sig RegExp -> String -> [String | Undefined]
 * @param {RegExp} rx A regular expression.
 * @param {String} str The string to match against
 * @return {Array} The list of matches or empty array.
 * @see R.test
 * @example
 *
 *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
 *      R.match(/a/, 'b'); //=> []
 *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
 */
var match = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function match(rx, str) {
  return str.match(rx) || [];
});
/* harmony default export */ __webpack_exports__["default"] = (match);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mathMod.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mathMod.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isInteger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isInteger */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isInteger.js");



/**
 * `mathMod` behaves like the modulo operator should mathematically, unlike the
 * `%` operator (and by extension, [`R.modulo`](#modulo)). So while
 * `-17 % 5` is `-2`, `mathMod(-17, 5)` is `3`. `mathMod` requires Integer
 * arguments, and returns NaN when the modulus is zero or negative.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} m The dividend.
 * @param {Number} p the modulus.
 * @return {Number} The result of `b mod a`.
 * @see R.modulo
 * @example
 *
 *      R.mathMod(-17, 5);  //=> 3
 *      R.mathMod(17, 5);   //=> 2
 *      R.mathMod(17, -5);  //=> NaN
 *      R.mathMod(17, 0);   //=> NaN
 *      R.mathMod(17.2, 5); //=> NaN
 *      R.mathMod(17, 5.3); //=> NaN
 *
 *      var clock = R.mathMod(R.__, 12);
 *      clock(15); //=> 3
 *      clock(24); //=> 0
 *
 *      var seventeenMod = R.mathMod(17);
 *      seventeenMod(3);  //=> 2
 *      seventeenMod(4);  //=> 1
 *      seventeenMod(10); //=> 7
 */
var mathMod = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function mathMod(m, p) {
  if (!Object(_internal_isInteger__WEBPACK_IMPORTED_MODULE_1__["default"])(m)) {
    return NaN;
  }
  if (!Object(_internal_isInteger__WEBPACK_IMPORTED_MODULE_1__["default"])(p) || p < 1) {
    return NaN;
  }
  return (m % p + p) % p;
});
/* harmony default export */ __webpack_exports__["default"] = (mathMod);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/max.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns the larger of its two arguments.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> a
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.maxBy, R.min
 * @example
 *
 *      R.max(789, 123); //=> 789
 *      R.max('a', 'b'); //=> 'b'
 */
var max = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function max(a, b) {
  return b > a ? b : a;
});
/* harmony default export */ __webpack_exports__["default"] = (max);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/maxBy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/maxBy.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Takes a function and two values, and returns whichever value produces the
 * larger result when passed to the provided function.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Relation
 * @sig Ord b => (a -> b) -> a -> a -> a
 * @param {Function} f
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.max, R.minBy
 * @example
 *
 *      //  square :: Number -> Number
 *      var square = n => n * n;
 *
 *      R.maxBy(square, -3, 2); //=> -3
 *
 *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
 *      R.reduce(R.maxBy(square), 0, []); //=> 0
 */
var maxBy = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function maxBy(f, a, b) {
  return f(b) > f(a) ? b : a;
});
/* harmony default export */ __webpack_exports__["default"] = (maxBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mean.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mean.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _sum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sum */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sum.js");



/**
 * Returns the mean of the given list of numbers.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list
 * @return {Number}
 * @see R.median
 * @example
 *
 *      R.mean([2, 7, 9]); //=> 6
 *      R.mean([]); //=> NaN
 */
var mean = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function mean(list) {
  return Object(_sum__WEBPACK_IMPORTED_MODULE_1__["default"])(list) / list.length;
});
/* harmony default export */ __webpack_exports__["default"] = (mean);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/median.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/median.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _mean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mean */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mean.js");



/**
 * Returns the median of the given list of numbers.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list
 * @return {Number}
 * @see R.mean
 * @example
 *
 *      R.median([2, 9, 7]); //=> 7
 *      R.median([7, 2, 10, 9]); //=> 8
 *      R.median([]); //=> NaN
 */
var median = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function median(list) {
  var len = list.length;
  if (len === 0) {
    return NaN;
  }
  var width = 2 - len % 2;
  var idx = (len - width) / 2;
  return Object(_mean__WEBPACK_IMPORTED_MODULE_1__["default"])(Array.prototype.slice.call(list, 0).sort(function (a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }).slice(idx, idx + width));
});
/* harmony default export */ __webpack_exports__["default"] = (median);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/memoize.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/memoize.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _memoizeWith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memoizeWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/memoizeWith.js");
/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toString.js");



/**
 * Creates a new function that, when invoked, caches the result of calling `fn`
 * for a given argument set and returns the result. Subsequent calls to the
 * memoized `fn` with the same argument set will not result in an additional
 * call to `fn`; instead, the cached result for that set of arguments will be
 * returned.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (*... -> a) -> (*... -> a)
 * @param {Function} fn The function to memoize.
 * @return {Function} Memoized version of `fn`.
 * @see R.memoizeWith
 * @deprecated since v0.25.0
 * @example
 *
 *      let count = 0;
 *      const factorial = R.memoize(n => {
 *        count += 1;
 *        return R.product(R.range(1, n + 1));
 *      });
 *      factorial(5); //=> 120
 *      factorial(5); //=> 120
 *      factorial(5); //=> 120
 *      count; //=> 1
 */
var memoize = /*#__PURE__*/Object(_memoizeWith__WEBPACK_IMPORTED_MODULE_0__["default"])(function () {
  return Object(_toString__WEBPACK_IMPORTED_MODULE_1__["default"])(arguments);
});
/* harmony default export */ __webpack_exports__["default"] = (memoize);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/memoizeWith.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/memoizeWith.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");




/**
 * A customisable version of [`R.memoize`](#memoize). `memoizeWith` takes an
 * additional function that will be applied to a given argument set and used to
 * create the cache key under which the results of the function to be memoized
 * will be stored. Care must be taken when implementing key generation to avoid
 * clashes that may overwrite previous entries erroneously.
 *
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Function
 * @sig (*... -> String) -> (*... -> a) -> (*... -> a)
 * @param {Function} fn The function to generate the cache key.
 * @param {Function} fn The function to memoize.
 * @return {Function} Memoized version of `fn`.
 * @see R.memoize
 * @example
 *
 *      let count = 0;
 *      const factorial = R.memoizeWith(R.identity, n => {
 *        count += 1;
 *        return R.product(R.range(1, n + 1));
 *      });
 *      factorial(5); //=> 120
 *      factorial(5); //=> 120
 *      factorial(5); //=> 120
 *      count; //=> 1
 */
var memoizeWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function memoizeWith(mFn, fn) {
  var cache = {};
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(fn.length, function () {
    var key = mFn.apply(this, arguments);
    if (!Object(_internal_has__WEBPACK_IMPORTED_MODULE_2__["default"])(key, cache)) {
      cache[key] = fn.apply(this, arguments);
    }
    return cache[key];
  });
});
/* harmony default export */ __webpack_exports__["default"] = (memoizeWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/merge.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/merge.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_assign */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_assign.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Create a new object with the own properties of the first object merged with
 * the own properties of the second object. If a key exists in both objects,
 * the value from the second object will be used.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> {k: v} -> {k: v}
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.mergeDeepRight, R.mergeWith, R.mergeWithKey
 * @example
 *
 *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
 *      //=> { 'name': 'fred', 'age': 40 }
 *
 *      var resetToDefault = R.merge(R.__, {x: 0});
 *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
 * @symb R.merge({ x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: 5, z: 3 }
 */
var merge = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function merge(l, r) {
  return Object(_internal_assign__WEBPACK_IMPORTED_MODULE_0__["default"])({}, l, r);
});
/* harmony default export */ __webpack_exports__["default"] = (merge);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeAll.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeAll.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_assign */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_assign.js");
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");



/**
 * Merges a list of objects together into one object.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig [{k: v}] -> {k: v}
 * @param {Array} list An array of objects
 * @return {Object} A merged object.
 * @see R.reduce
 * @example
 *
 *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
 *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
 * @symb R.mergeAll([{ x: 1 }, { y: 2 }, { z: 3 }]) = { x: 1, y: 2, z: 3 }
 */
var mergeAll = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_1__["default"])(function mergeAll(list) {
  return _internal_assign__WEBPACK_IMPORTED_MODULE_0__["default"].apply(null, [{}].concat(list));
});
/* harmony default export */ __webpack_exports__["default"] = (mergeAll);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepLeft.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepLeft.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeDeepWithKey */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWithKey.js");



/**
 * Creates a new object with the own properties of the first object merged with
 * the own properties of the second object. If a key exists in both objects:
 * - and both values are objects, the two values will be recursively merged
 * - otherwise the value from the first object will be used.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Object
 * @sig {a} -> {a} -> {a}
 * @param {Object} lObj
 * @param {Object} rObj
 * @return {Object}
 * @see R.merge, R.mergeDeepRight, R.mergeDeepWith, R.mergeDeepWithKey
 * @example
 *
 *      R.mergeDeepLeft({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
 *                      { age: 40, contact: { email: 'baa@example.com' }});
 *      //=> { name: 'fred', age: 10, contact: { email: 'moo@example.com' }}
 */
var mergeDeepLeft = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function mergeDeepLeft(lObj, rObj) {
  return Object(_mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_1__["default"])(function (k, lVal, rVal) {
    return lVal;
  }, lObj, rObj);
});
/* harmony default export */ __webpack_exports__["default"] = (mergeDeepLeft);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepRight.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepRight.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeDeepWithKey */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWithKey.js");



/**
 * Creates a new object with the own properties of the first object merged with
 * the own properties of the second object. If a key exists in both objects:
 * - and both values are objects, the two values will be recursively merged
 * - otherwise the value from the second object will be used.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Object
 * @sig {a} -> {a} -> {a}
 * @param {Object} lObj
 * @param {Object} rObj
 * @return {Object}
 * @see R.merge, R.mergeDeepLeft, R.mergeDeepWith, R.mergeDeepWithKey
 * @example
 *
 *      R.mergeDeepRight({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
 *                       { age: 40, contact: { email: 'baa@example.com' }});
 *      //=> { name: 'fred', age: 40, contact: { email: 'baa@example.com' }}
 */
var mergeDeepRight = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function mergeDeepRight(lObj, rObj) {
  return Object(_mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_1__["default"])(function (k, lVal, rVal) {
    return rVal;
  }, lObj, rObj);
});
/* harmony default export */ __webpack_exports__["default"] = (mergeDeepRight);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWith.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWith.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeDeepWithKey */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWithKey.js");



/**
 * Creates a new object with the own properties of the two provided objects.
 * If a key exists in both objects:
 * - and both associated values are also objects then the values will be
 *   recursively merged.
 * - otherwise the provided function is applied to associated values using the
 *   resulting value as the new value associated with the key.
 * If a key only exists in one object, the value will be associated with the key
 * of the resulting object.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Object
 * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} lObj
 * @param {Object} rObj
 * @return {Object}
 * @see R.mergeWith, R.mergeDeep, R.mergeDeepWithKey
 * @example
 *
 *      R.mergeDeepWith(R.concat,
 *                      { a: true, c: { values: [10, 20] }},
 *                      { b: true, c: { values: [15, 35] }});
 *      //=> { a: true, b: true, c: { values: [10, 20, 15, 35] }}
 */
var mergeDeepWith = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function mergeDeepWith(fn, lObj, rObj) {
  return Object(_mergeDeepWithKey__WEBPACK_IMPORTED_MODULE_1__["default"])(function (k, lVal, rVal) {
    return fn(lVal, rVal);
  }, lObj, rObj);
});
/* harmony default export */ __webpack_exports__["default"] = (mergeDeepWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWithKey.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeDeepWithKey.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _internal_isObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isObject */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isObject.js");
/* harmony import */ var _mergeWithKey__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mergeWithKey */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWithKey.js");




/**
 * Creates a new object with the own properties of the two provided objects.
 * If a key exists in both objects:
 * - and both associated values are also objects then the values will be
 *   recursively merged.
 * - otherwise the provided function is applied to the key and associated values
 *   using the resulting value as the new value associated with the key.
 * If a key only exists in one object, the value will be associated with the key
 * of the resulting object.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Object
 * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} lObj
 * @param {Object} rObj
 * @return {Object}
 * @see R.mergeWithKey, R.mergeDeep, R.mergeDeepWith
 * @example
 *
 *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
 *      R.mergeDeepWithKey(concatValues,
 *                         { a: true, c: { thing: 'foo', values: [10, 20] }},
 *                         { b: true, c: { thing: 'bar', values: [15, 35] }});
 *      //=> { a: true, b: true, c: { thing: 'bar', values: [10, 20, 15, 35] }}
 */
var mergeDeepWithKey = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function mergeDeepWithKey(fn, lObj, rObj) {
  return Object(_mergeWithKey__WEBPACK_IMPORTED_MODULE_2__["default"])(function (k, lVal, rVal) {
    if (Object(_internal_isObject__WEBPACK_IMPORTED_MODULE_1__["default"])(lVal) && Object(_internal_isObject__WEBPACK_IMPORTED_MODULE_1__["default"])(rVal)) {
      return mergeDeepWithKey(fn, lVal, rVal);
    } else {
      return fn(k, lVal, rVal);
    }
  }, lObj, rObj);
});
/* harmony default export */ __webpack_exports__["default"] = (mergeDeepWithKey);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWith.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWith.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _mergeWithKey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeWithKey */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWithKey.js");



/**
 * Creates a new object with the own properties of the two provided objects. If
 * a key exists in both objects, the provided function is applied to the values
 * associated with the key in each object, with the result being used as the
 * value associated with the key in the returned object.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Object
 * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.mergeDeepWith, R.merge, R.mergeWithKey
 * @example
 *
 *      R.mergeWith(R.concat,
 *                  { a: true, values: [10, 20] },
 *                  { b: true, values: [15, 35] });
 *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
 */
var mergeWith = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function mergeWith(fn, l, r) {
  return Object(_mergeWithKey__WEBPACK_IMPORTED_MODULE_1__["default"])(function (_, _l, _r) {
    return fn(_l, _r);
  }, l, r);
});
/* harmony default export */ __webpack_exports__["default"] = (mergeWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWithKey.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/mergeWithKey.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");



/**
 * Creates a new object with the own properties of the two provided objects. If
 * a key exists in both objects, the provided function is applied to the key
 * and the values associated with the key in each object, with the result being
 * used as the value associated with the key in the returned object.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Object
 * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.mergeDeepWithKey, R.merge, R.mergeWith
 * @example
 *
 *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
 *      R.mergeWithKey(concatValues,
 *                     { a: true, thing: 'foo', values: [10, 20] },
 *                     { b: true, thing: 'bar', values: [15, 35] });
 *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
 * @symb R.mergeWithKey(f, { x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: f('y', 2, 5), z: 3 }
 */
var mergeWithKey = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function mergeWithKey(fn, l, r) {
  var result = {};
  var k;

  for (k in l) {
    if (Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(k, l)) {
      result[k] = Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(k, r) ? fn(k, l[k], r[k]) : l[k];
    }
  }

  for (k in r) {
    if (Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(k, r) && !Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(k, result)) {
      result[k] = r[k];
    }
  }

  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (mergeWithKey);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/min.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/min.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns the smaller of its two arguments.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> a
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.minBy, R.max
 * @example
 *
 *      R.min(789, 123); //=> 123
 *      R.min('a', 'b'); //=> 'a'
 */
var min = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function min(a, b) {
  return b < a ? b : a;
});
/* harmony default export */ __webpack_exports__["default"] = (min);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/minBy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/minBy.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Takes a function and two values, and returns whichever value produces the
 * smaller result when passed to the provided function.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Relation
 * @sig Ord b => (a -> b) -> a -> a -> a
 * @param {Function} f
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.min, R.maxBy
 * @example
 *
 *      //  square :: Number -> Number
 *      var square = n => n * n;
 *
 *      R.minBy(square, -3, 2); //=> 2
 *
 *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
 *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
 */
var minBy = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function minBy(f, a, b) {
  return f(b) < f(a) ? b : a;
});
/* harmony default export */ __webpack_exports__["default"] = (minBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/modulo.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/modulo.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Divides the first parameter by the second and returns the remainder. Note
 * that this function preserves the JavaScript-style behavior for modulo. For
 * mathematical modulo see [`mathMod`](#mathMod).
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The value to the divide.
 * @param {Number} b The pseudo-modulus
 * @return {Number} The result of `b % a`.
 * @see R.mathMod
 * @example
 *
 *      R.modulo(17, 3); //=> 2
 *      // JS behavior:
 *      R.modulo(-17, 3); //=> -2
 *      R.modulo(17, -3); //=> 2
 *
 *      var isOdd = R.modulo(R.__, 2);
 *      isOdd(42); //=> 0
 *      isOdd(21); //=> 1
 */
var modulo = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function modulo(a, b) {
  return a % b;
});
/* harmony default export */ __webpack_exports__["default"] = (modulo);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/multiply.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/multiply.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Multiplies two numbers. Equivalent to `a * b` but curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The first value.
 * @param {Number} b The second value.
 * @return {Number} The result of `a * b`.
 * @see R.divide
 * @example
 *
 *      var double = R.multiply(2);
 *      var triple = R.multiply(3);
 *      double(3);       //=>  6
 *      triple(4);       //=> 12
 *      R.multiply(2, 5);  //=> 10
 */
var multiply = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function multiply(a, b) {
  return a * b;
});
/* harmony default export */ __webpack_exports__["default"] = (multiply);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nAry.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nAry.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Wraps a function of any arity (including nullary) in a function that accepts
 * exactly `n` parameters. Any extraneous parameters will not be passed to the
 * supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} n The desired arity of the new function.
 * @param {Function} fn The function to wrap.
 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
 *         arity `n`.
 * @see R.binary, R.unary
 * @example
 *
 *      var takesTwoArgs = (a, b) => [a, b];
 *
 *      takesTwoArgs.length; //=> 2
 *      takesTwoArgs(1, 2); //=> [1, 2]
 *
 *      var takesOneArg = R.nAry(1, takesTwoArgs);
 *      takesOneArg.length; //=> 1
 *      // Only `n` arguments are passed to the wrapped function
 *      takesOneArg(1, 2); //=> [1, undefined]
 * @symb R.nAry(0, f)(a, b) = f()
 * @symb R.nAry(1, f)(a, b) = f(a)
 * @symb R.nAry(2, f)(a, b) = f(a, b)
 */
var nAry = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function nAry(n, fn) {
  switch (n) {
    case 0:
      return function () {
        return fn.call(this);
      };
    case 1:
      return function (a0) {
        return fn.call(this, a0);
      };
    case 2:
      return function (a0, a1) {
        return fn.call(this, a0, a1);
      };
    case 3:
      return function (a0, a1, a2) {
        return fn.call(this, a0, a1, a2);
      };
    case 4:
      return function (a0, a1, a2, a3) {
        return fn.call(this, a0, a1, a2, a3);
      };
    case 5:
      return function (a0, a1, a2, a3, a4) {
        return fn.call(this, a0, a1, a2, a3, a4);
      };
    case 6:
      return function (a0, a1, a2, a3, a4, a5) {
        return fn.call(this, a0, a1, a2, a3, a4, a5);
      };
    case 7:
      return function (a0, a1, a2, a3, a4, a5, a6) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
      };
    case 8:
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
      };
    case 9:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
      };
    case 10:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
      };
    default:
      throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
  }
});
/* harmony default export */ __webpack_exports__["default"] = (nAry);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/negate.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/negate.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Negates its argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Math
 * @sig Number -> Number
 * @param {Number} n
 * @return {Number}
 * @example
 *
 *      R.negate(42); //=> -42
 */
var negate = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function negate(n) {
  return -n;
});
/* harmony default export */ __webpack_exports__["default"] = (negate);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/none.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/none.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_complement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_complement */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_complement.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xany__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_xany */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xany.js");
/* harmony import */ var _any__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./any */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/any.js");






/**
 * Returns `true` if no elements of the list match the predicate, `false`
 * otherwise.
 *
 * Dispatches to the `any` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
 * @see R.all, R.any
 * @example
 *
 *      var isEven = n => n % 2 === 0;
 *      var isOdd = n => n % 2 === 1;
 *
 *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
 *      R.none(isOdd, [1, 3, 5, 7, 8, 11]); //=> false
 */
var none = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_internal_complement__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_2__["default"])(['any'], _internal_xany__WEBPACK_IMPORTED_MODULE_3__["default"], _any__WEBPACK_IMPORTED_MODULE_4__["default"])));
/* harmony default export */ __webpack_exports__["default"] = (none);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/not.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/not.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * A function that returns the `!` of its argument. It will return `true` when
 * passed false-y value, and `false` when passed a truth-y one.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig * -> Boolean
 * @param {*} a any value
 * @return {Boolean} the logical inverse of passed argument.
 * @see R.complement
 * @example
 *
 *      R.not(true); //=> false
 *      R.not(false); //=> true
 *      R.not(0); //=> true
 *      R.not(1); //=> false
 */
var not = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function not(a) {
  return !a;
});
/* harmony default export */ __webpack_exports__["default"] = (not);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nth.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nth.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isString.js");



/**
 * Returns the nth element of the given list or string. If n is negative the
 * element at index length + n is returned.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> a | Undefined
 * @sig Number -> String -> String
 * @param {Number} offset
 * @param {*} list
 * @return {*}
 * @example
 *
 *      var list = ['foo', 'bar', 'baz', 'quux'];
 *      R.nth(1, list); //=> 'bar'
 *      R.nth(-1, list); //=> 'quux'
 *      R.nth(-99, list); //=> undefined
 *
 *      R.nth(2, 'abc'); //=> 'c'
 *      R.nth(3, 'abc'); //=> ''
 * @symb R.nth(-1, [a, b, c]) = c
 * @symb R.nth(0, [a, b, c]) = a
 * @symb R.nth(1, [a, b, c]) = b
 */
var nth = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function nth(offset, list) {
  var idx = offset < 0 ? list.length + offset : offset;
  return Object(_internal_isString__WEBPACK_IMPORTED_MODULE_1__["default"])(list) ? list.charAt(idx) : list[idx];
});
/* harmony default export */ __webpack_exports__["default"] = (nth);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nthArg.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nthArg.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");
/* harmony import */ var _nth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nth */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nth.js");




/**
 * Returns a function which returns its nth argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig Number -> *... -> *
 * @param {Number} n
 * @return {Function}
 * @example
 *
 *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
 *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
 * @symb R.nthArg(-1)(a, b, c) = c
 * @symb R.nthArg(0)(a, b, c) = a
 * @symb R.nthArg(1)(a, b, c) = b
 */
var nthArg = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function nthArg(n) {
  var arity = n < 0 ? 1 : n + 1;
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(arity, function () {
    return Object(_nth__WEBPACK_IMPORTED_MODULE_2__["default"])(n, arguments);
  });
});
/* harmony default export */ __webpack_exports__["default"] = (nthArg);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/o.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/o.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * `o` is a curried composition function that returns a unary function.
 * Like [`compose`](#compose), `o` performs right-to-left function composition.
 * Unlike [`compose`](#compose), the rightmost function passed to `o` will be
 * invoked with only one argument.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Function
 * @sig (b -> c) -> (a -> b) -> a -> c
 * @param {Function} f
 * @param {Function} g
 * @return {Function}
 * @see R.compose, R.pipe
 * @example
 *
 *      var classyGreeting = name => "The name's " + name.last + ", " + name.first + " " + name.last
 *      var yellGreeting = R.o(R.toUpper, classyGreeting);
 *      yellGreeting({first: 'James', last: 'Bond'}); //=> "THE NAME'S BOND, JAMES BOND"
 *
 *      R.o(R.multiply(10), R.add(10))(-4) //=> 60
 *
 * @symb R.o(f, g, x) = f(g(x))
 */
var o = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function o(f, g, x) {
  return f(g(x));
});
/* harmony default export */ __webpack_exports__["default"] = (o);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/objOf.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/objOf.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Creates an object containing a single key:value pair.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Object
 * @sig String -> a -> {String:a}
 * @param {String} key
 * @param {*} val
 * @return {Object}
 * @see R.pair
 * @example
 *
 *      var matchPhrases = R.compose(
 *        R.objOf('must'),
 *        R.map(R.objOf('match_phrase'))
 *      );
 *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
 */
var objOf = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function objOf(key, val) {
  var obj = {};
  obj[key] = val;
  return obj;
});
/* harmony default export */ __webpack_exports__["default"] = (objOf);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/of.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/of.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_of */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_of.js");



/**
 * Returns a singleton array containing the value provided.
 *
 * Note this `of` is different from the ES6 `of`; See
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Function
 * @sig a -> [a]
 * @param {*} x any value
 * @return {Array} An array wrapping `x`.
 * @example
 *
 *      R.of(null); //=> [null]
 *      R.of([42]); //=> [[42]]
 */
var of = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(_internal_of__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (of);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/omit.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/omit.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns a partial copy of an object omitting the keys specified.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [String] -> {String: *} -> {String: *}
 * @param {Array} names an array of String property names to omit from the new object
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with properties from `names` not on it.
 * @see R.pick
 * @example
 *
 *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
 */
var omit = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function omit(names, obj) {
  var result = {};
  var index = {};
  var idx = 0;
  var len = names.length;

  while (idx < len) {
    index[names[idx]] = 1;
    idx += 1;
  }

  for (var prop in obj) {
    if (!index.hasOwnProperty(prop)) {
      result[prop] = obj[prop];
    }
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (omit);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/once.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/once.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");



/**
 * Accepts a function `fn` and returns a function that guards invocation of
 * `fn` such that `fn` can only ever be called once, no matter how many times
 * the returned function is invoked. The first value calculated is returned in
 * subsequent invocations.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (a... -> b) -> (a... -> b)
 * @param {Function} fn The function to wrap in a call-only-once wrapper.
 * @return {Function} The wrapped function.
 * @example
 *
 *      var addOneOnce = R.once(x => x + 1);
 *      addOneOnce(10); //=> 11
 *      addOneOnce(addOneOnce(50)); //=> 11
 */
var once = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_1__["default"])(function once(fn) {
  var called = false;
  var result;
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(fn.length, function () {
    if (called) {
      return result;
    }
    called = true;
    result = fn.apply(this, arguments);
    return result;
  });
});
/* harmony default export */ __webpack_exports__["default"] = (once);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/or.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/or.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns `true` if one or both of its arguments are `true`. Returns `false`
 * if both arguments are `false`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig a -> b -> a | b
 * @param {Any} a
 * @param {Any} b
 * @return {Any} the first argument if truthy, otherwise the second argument.
 * @see R.either
 * @example
 *
 *      R.or(true, true); //=> true
 *      R.or(true, false); //=> true
 *      R.or(false, true); //=> true
 *      R.or(false, false); //=> false
 */
var or = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function or(a, b) {
  return a || b;
});
/* harmony default export */ __webpack_exports__["default"] = (or);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/over.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/over.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


// `Identity` is a functor that holds a single value, where `map` simply
// transforms the held value with the provided function.
var Identity = function (x) {
  return { value: x, map: function (f) {
      return Identity(f(x));
    } };
};

/**
 * Returns the result of "setting" the portion of the given data structure
 * focused by the given lens to the result of applying the given function to
 * the focused value.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Lens s a -> (a -> a) -> s -> s
 * @param {Lens} lens
 * @param {*} v
 * @param {*} x
 * @return {*}
 * @see R.prop, R.lensIndex, R.lensProp
 * @example
 *
 *      var headLens = R.lensIndex(0);
 *
 *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
 */
var over = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function over(lens, f, x) {
  // The value returned by the getter function is first transformed with `f`,
  // then set as the value of an `Identity`. This is then mapped over with the
  // setter function of the lens.
  return lens(function (y) {
    return Identity(f(y));
  })(x).value;
});
/* harmony default export */ __webpack_exports__["default"] = (over);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pair.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pair.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category List
 * @sig a -> b -> (a,b)
 * @param {*} fst
 * @param {*} snd
 * @return {Array}
 * @see R.objOf, R.of
 * @example
 *
 *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
 */
var pair = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function pair(fst, snd) {
  return [fst, snd];
});
/* harmony default export */ __webpack_exports__["default"] = (pair);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partial.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partial.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_createPartialApplicator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_createPartialApplicator */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_createPartialApplicator.js");



/**
 * Takes a function `f` and a list of arguments, and returns a function `g`.
 * When applied, `g` returns the result of applying `f` to the arguments
 * provided initially followed by the arguments provided to `g`.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
 * @param {Function} f
 * @param {Array} args
 * @return {Function}
 * @see R.partialRight
 * @example
 *
 *      var multiply2 = (a, b) => a * b;
 *      var double = R.partial(multiply2, [2]);
 *      double(2); //=> 4
 *
 *      var greet = (salutation, title, firstName, lastName) =>
 *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
 *
 *      var sayHello = R.partial(greet, ['Hello']);
 *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
 *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
 * @symb R.partial(f, [a, b])(c, d) = f(a, b, c, d)
 */
var partial = /*#__PURE__*/Object(_internal_createPartialApplicator__WEBPACK_IMPORTED_MODULE_1__["default"])(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (partial);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partialRight.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partialRight.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_createPartialApplicator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_createPartialApplicator */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_createPartialApplicator.js");
/* harmony import */ var _flip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flip */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flip.js");




/**
 * Takes a function `f` and a list of arguments, and returns a function `g`.
 * When applied, `g` returns the result of applying `f` to the arguments
 * provided to `g` followed by the arguments provided initially.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
 * @param {Function} f
 * @param {Array} args
 * @return {Function}
 * @see R.partial
 * @example
 *
 *      var greet = (salutation, title, firstName, lastName) =>
 *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
 *
 *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
 *
 *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
 * @symb R.partialRight(f, [a, b])(c, d) = f(c, d, a, b)
 */
var partialRight = /*#__PURE__*/Object(_internal_createPartialApplicator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_flip__WEBPACK_IMPORTED_MODULE_2__["default"])(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (partialRight);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partition.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/partition.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/filter.js");
/* harmony import */ var _juxt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./juxt */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/juxt.js");
/* harmony import */ var _reject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reject */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reject.js");




/**
 * Takes a predicate and a list or other `Filterable` object and returns the
 * pair of filterable objects of the same type of elements which do and do not
 * satisfy, the predicate, respectively. Filterable objects include plain objects or any object
 * that has a filter method such as `Array`.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
 * @param {Function} pred A predicate to determine which side the element belongs to.
 * @param {Array} filterable the list (or other filterable) to partition.
 * @return {Array} An array, containing first the subset of elements that satisfy the
 *         predicate, and second the subset of elements that do not satisfy.
 * @see R.filter, R.reject
 * @example
 *
 *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
 *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
 *
 *      R.partition(R.contains('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
 *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
 */
var partition = /*#__PURE__*/Object(_juxt__WEBPACK_IMPORTED_MODULE_1__["default"])([_filter__WEBPACK_IMPORTED_MODULE_0__["default"], _reject__WEBPACK_IMPORTED_MODULE_2__["default"]]);
/* harmony default export */ __webpack_exports__["default"] = (partition);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Retrieve the value at a given path.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig [Idx] -> {a} -> a | Undefined
 * @param {Array} path The path to use.
 * @param {Object} obj The object to retrieve the nested property from.
 * @return {*} The data at `path`.
 * @see R.prop
 * @example
 *
 *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
 *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
 */
var path = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function path(paths, obj) {
  var val = obj;
  var idx = 0;
  while (idx < paths.length) {
    if (val == null) {
      return;
    }
    val = val[paths[idx]];
    idx += 1;
  }
  return val;
});
/* harmony default export */ __webpack_exports__["default"] = (path);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathEq.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathEq.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js");




/**
 * Determines whether a nested path on an object has a specific value, in
 * [`R.equals`](#equals) terms. Most likely used to filter a list.
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Relation
 * @typedefn Idx = String | Int
 * @sig [Idx] -> a -> {a} -> Boolean
 * @param {Array} path The path of the nested property to use
 * @param {*} val The value to compare the nested property with
 * @param {Object} obj The object to check the nested property in
 * @return {Boolean} `true` if the value equals the nested object property,
 *         `false` otherwise.
 * @example
 *
 *      var user1 = { address: { zipCode: 90210 } };
 *      var user2 = { address: { zipCode: 55555 } };
 *      var user3 = { name: 'Bob' };
 *      var users = [ user1, user2, user3 ];
 *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
 *      R.filter(isFamous, users); //=> [ user1 ]
 */
var pathEq = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function pathEq(_path, val, obj) {
  return Object(_equals__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_path__WEBPACK_IMPORTED_MODULE_2__["default"])(_path, obj), val);
});
/* harmony default export */ __webpack_exports__["default"] = (pathEq);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathOr.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathOr.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _defaultTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultTo */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/defaultTo.js");
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js");




/**
 * If the given, non-null object has a value at the given path, returns the
 * value at that path. Otherwise returns the provided default value.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig a -> [Idx] -> {a} -> a
 * @param {*} d The default value.
 * @param {Array} p The path to use.
 * @param {Object} obj The object to retrieve the nested property from.
 * @return {*} The data at `path` of the supplied object or the default value.
 * @example
 *
 *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
 *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
 */
var pathOr = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function pathOr(d, p, obj) {
  return Object(_defaultTo__WEBPACK_IMPORTED_MODULE_1__["default"])(d, Object(_path__WEBPACK_IMPORTED_MODULE_2__["default"])(p, obj));
});
/* harmony default export */ __webpack_exports__["default"] = (pathOr);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathSatisfies.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pathSatisfies.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js");



/**
 * Returns `true` if the specified object property at given path satisfies the
 * given predicate; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Logic
 * @typedefn Idx = String | Int
 * @sig (a -> Boolean) -> [Idx] -> {a} -> Boolean
 * @param {Function} pred
 * @param {Array} propPath
 * @param {*} obj
 * @return {Boolean}
 * @see R.propSatisfies, R.path
 * @example
 *
 *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
 */
var pathSatisfies = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function pathSatisfies(pred, propPath, obj) {
  return propPath.length > 0 && pred(Object(_path__WEBPACK_IMPORTED_MODULE_1__["default"])(propPath, obj));
});
/* harmony default export */ __webpack_exports__["default"] = (pathSatisfies);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pick.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pick.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns a partial copy of an object containing only the keys specified. If
 * the key does not exist, the property is ignored.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [k] -> {k: v} -> {k: v}
 * @param {Array} names an array of String property names to copy onto a new object
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with only properties from `names` on it.
 * @see R.omit, R.props
 * @example
 *
 *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
 *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
 */
var pick = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function pick(names, obj) {
  var result = {};
  var idx = 0;
  while (idx < names.length) {
    if (names[idx] in obj) {
      result[names[idx]] = obj[names[idx]];
    }
    idx += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (pick);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pickAll.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pickAll.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Similar to `pick` except that this one includes a `key: undefined` pair for
 * properties that don't exist.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [k] -> {k: v} -> {k: v}
 * @param {Array} names an array of String property names to copy onto a new object
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with only properties from `names` on it.
 * @see R.pick
 * @example
 *
 *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
 *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
 */
var pickAll = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function pickAll(names, obj) {
  var result = {};
  var idx = 0;
  var len = names.length;
  while (idx < len) {
    var name = names[idx];
    result[name] = obj[name];
    idx += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (pickAll);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pickBy.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pickBy.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns a partial copy of an object containing only the keys that satisfy
 * the supplied predicate.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @sig ((v, k) -> Boolean) -> {k: v} -> {k: v}
 * @param {Function} pred A predicate to determine whether or not a key
 *        should be included on the output object.
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with only properties that satisfy `pred`
 *         on it.
 * @see R.pick, R.filter
 * @example
 *
 *      var isUpperCase = (val, key) => key.toUpperCase() === key;
 *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
 */
var pickBy = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function pickBy(test, obj) {
  var result = {};
  for (var prop in obj) {
    if (test(obj[prop], prop, obj)) {
      result[prop] = obj[prop];
    }
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (pickBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipe.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipe.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pipe; });
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_pipe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_pipe */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_pipe.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");
/* harmony import */ var _tail__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tail */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tail.js");





/**
 * Performs left-to-right function composition. The leftmost function may have
 * any arity; the remaining functions must be unary.
 *
 * In some libraries this function is named `sequence`.
 *
 * **Note:** The result of pipe is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
 * @param {...Function} functions
 * @return {Function}
 * @see R.compose
 * @example
 *
 *      var f = R.pipe(Math.pow, R.negate, R.inc);
 *
 *      f(3, 4); // -(3^4) + 1
 * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
 */
function pipe() {
  if (arguments.length === 0) {
    throw new Error('pipe requires at least one argument');
  }
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(arguments[0].length, Object(_reduce__WEBPACK_IMPORTED_MODULE_2__["default"])(_internal_pipe__WEBPACK_IMPORTED_MODULE_1__["default"], arguments[0], Object(_tail__WEBPACK_IMPORTED_MODULE_3__["default"])(arguments)));
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipeK.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipeK.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pipeK; });
/* harmony import */ var _composeK__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./composeK */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/composeK.js");
/* harmony import */ var _reverse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reverse */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reverse.js");



/**
 * Returns the left-to-right Kleisli composition of the provided functions,
 * each of which must return a value of a type supported by [`chain`](#chain).
 *
 * `R.pipeK(f, g, h)` is equivalent to `R.pipe(f, R.chain(g), R.chain(h))`.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Function
 * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (a -> m z)
 * @param {...Function}
 * @return {Function}
 * @see R.composeK
 * @example
 *
 *      //  parseJson :: String -> Maybe *
 *      //  get :: String -> Object -> Maybe *
 *
 *      //  getStateCode :: Maybe String -> Maybe String
 *      var getStateCode = R.pipeK(
 *        parseJson,
 *        get('user'),
 *        get('address'),
 *        get('state'),
 *        R.compose(Maybe.of, R.toUpper)
 *      );
 *
 *      getStateCode('{"user":{"address":{"state":"ny"}}}');
 *      //=> Just('NY')
 *      getStateCode('[Invalid JSON]');
 *      //=> Nothing()
 * @symb R.pipeK(f, g, h)(a) = R.chain(h, R.chain(g, f(a)))
 */
function pipeK() {
  if (arguments.length === 0) {
    throw new Error('pipeK requires at least one argument');
  }
  return _composeK__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, Object(_reverse__WEBPACK_IMPORTED_MODULE_1__["default"])(arguments));
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipeP.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pipeP.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pipeP; });
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_pipeP__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_pipeP */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_pipeP.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");
/* harmony import */ var _tail__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tail */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tail.js");





/**
 * Performs left-to-right composition of one or more Promise-returning
 * functions. The leftmost function may have any arity; the remaining functions
 * must be unary.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
 * @param {...Function} functions
 * @return {Function}
 * @see R.composeP
 * @example
 *
 *      //  followersForUser :: String -> Promise [User]
 *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
 */
function pipeP() {
  if (arguments.length === 0) {
    throw new Error('pipeP requires at least one argument');
  }
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(arguments[0].length, Object(_reduce__WEBPACK_IMPORTED_MODULE_2__["default"])(_internal_pipeP__WEBPACK_IMPORTED_MODULE_1__["default"], arguments[0], Object(_tail__WEBPACK_IMPORTED_MODULE_3__["default"])(arguments)));
}

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pluck.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pluck.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");
/* harmony import */ var _prop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./prop */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prop.js");




/**
 * Returns a new list by plucking the same named property off all objects in
 * the list supplied.
 *
 * `pluck` will work on
 * any [functor](https://github.com/fantasyland/fantasy-land#functor) in
 * addition to arrays, as it is equivalent to `R.map(R.prop(k), f)`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Functor f => k -> f {k: v} -> f v
 * @param {Number|String} key The key name to pluck off of each object.
 * @param {Array} f The array or functor to consider.
 * @return {Array} The list of values for the given key.
 * @see R.props
 * @example
 *
 *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
 *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
 *      R.pluck('val', {a: {val: 3}, b: {val: 5}}); //=> {a: 3, b: 5}
 * @symb R.pluck('x', [{x: 1, y: 2}, {x: 3, y: 4}, {x: 5, y: 6}]) = [1, 3, 5]
 * @symb R.pluck(0, [[1, 2], [3, 4], [5, 6]]) = [1, 3, 5]
 */
var pluck = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function pluck(p, list) {
  return Object(_map__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_prop__WEBPACK_IMPORTED_MODULE_2__["default"])(p), list);
});
/* harmony default export */ __webpack_exports__["default"] = (pluck);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prepend.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prepend.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Returns a new list with the given element at the front, followed by the
 * contents of the list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> [a]
 * @param {*} el The item to add to the head of the output list.
 * @param {Array} list The array to add to the tail of the output list.
 * @return {Array} A new array.
 * @see R.append
 * @example
 *
 *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
 */
var prepend = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function prepend(el, list) {
  return Object(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"])([el], list);
});
/* harmony default export */ __webpack_exports__["default"] = (prepend);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/product.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/product.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _multiply__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./multiply */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/multiply.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");



/**
 * Multiplies together all the elements of a list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list An array of numbers
 * @return {Number} The product of all the numbers in the list.
 * @see R.reduce
 * @example
 *
 *      R.product([2,4,6,8,100,1]); //=> 38400
 */
var product = /*#__PURE__*/Object(_reduce__WEBPACK_IMPORTED_MODULE_1__["default"])(_multiply__WEBPACK_IMPORTED_MODULE_0__["default"], 1);
/* harmony default export */ __webpack_exports__["default"] = (product);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/project.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/project.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_map.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./identity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identity.js");
/* harmony import */ var _pickAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pickAll */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/pickAll.js");
/* harmony import */ var _useWith__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/useWith.js");





/**
 * Reasonable analog to SQL `select` statement.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @category Relation
 * @sig [k] -> [{k: v}] -> [{k: v}]
 * @param {Array} props The property names to project
 * @param {Array} objs The objects to query
 * @return {Array} An array of objects with just the `props` properties.
 * @example
 *
 *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
 *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
 *      var kids = [abby, fred];
 *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
 */
var project = /*#__PURE__*/Object(_useWith__WEBPACK_IMPORTED_MODULE_3__["default"])(_internal_map__WEBPACK_IMPORTED_MODULE_0__["default"], [_pickAll__WEBPACK_IMPORTED_MODULE_2__["default"], _identity__WEBPACK_IMPORTED_MODULE_1__["default"]]); // passing `identity` gives correct arity
/* harmony default export */ __webpack_exports__["default"] = (project);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prop.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prop.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/path.js");



/**
 * Returns a function that when supplied an object returns the indicated
 * property of that object, if it exists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig s -> {s: a} -> a | Undefined
 * @param {String} p The property name
 * @param {Object} obj The object to query
 * @return {*} The value at `obj.p`.
 * @see R.path
 * @example
 *
 *      R.prop('x', {x: 100}); //=> 100
 *      R.prop('x', {}); //=> undefined
 */

var prop = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function prop(p, obj) {
  return Object(_path__WEBPACK_IMPORTED_MODULE_1__["default"])([p], obj);
});
/* harmony default export */ __webpack_exports__["default"] = (prop);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propEq.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propEq.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");



/**
 * Returns `true` if the specified object property is equal, in
 * [`R.equals`](#equals) terms, to the given value; `false` otherwise.
 * You can test multiple properties with [`R.where`](#where).
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig String -> a -> Object -> Boolean
 * @param {String} name
 * @param {*} val
 * @param {*} obj
 * @return {Boolean}
 * @see R.whereEq, R.propSatisfies, R.equals
 * @example
 *
 *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
 *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
 *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
 *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
 *      var kids = [abby, fred, rusty, alois];
 *      var hasBrownHair = R.propEq('hair', 'brown');
 *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
 */
var propEq = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function propEq(name, val, obj) {
  return Object(_equals__WEBPACK_IMPORTED_MODULE_1__["default"])(val, obj[name]);
});
/* harmony default export */ __webpack_exports__["default"] = (propEq);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propIs.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propIs.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/is.js");



/**
 * Returns `true` if the specified object property is of the given type;
 * `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Type
 * @sig Type -> String -> Object -> Boolean
 * @param {Function} type
 * @param {String} name
 * @param {*} obj
 * @return {Boolean}
 * @see R.is, R.propSatisfies
 * @example
 *
 *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
 *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
 *      R.propIs(Number, 'x', {});            //=> false
 */
var propIs = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function propIs(type, name, obj) {
  return Object(_is__WEBPACK_IMPORTED_MODULE_1__["default"])(type, obj[name]);
});
/* harmony default export */ __webpack_exports__["default"] = (propIs);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propOr.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propOr.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");



/**
 * If the given, non-null object has an own property with the specified name,
 * returns the value of that property. Otherwise returns the provided default
 * value.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Object
 * @sig a -> String -> Object -> a
 * @param {*} val The default value.
 * @param {String} p The name of the property to return.
 * @param {Object} obj The object to query.
 * @return {*} The value of given property of the supplied object or the default value.
 * @example
 *
 *      var alice = {
 *        name: 'ALICE',
 *        age: 101
 *      };
 *      var favorite = R.prop('favoriteLibrary');
 *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
 *
 *      favorite(alice);  //=> undefined
 *      favoriteWithDefault(alice);  //=> 'Ramda'
 */
var propOr = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function propOr(val, p, obj) {
  return obj != null && Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(p, obj) ? obj[p] : val;
});
/* harmony default export */ __webpack_exports__["default"] = (propOr);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propSatisfies.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/propSatisfies.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Returns `true` if the specified object property satisfies the given
 * predicate; `false` otherwise. You can test multiple properties with
 * [`R.where`](#where).
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Logic
 * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
 * @param {Function} pred
 * @param {String} name
 * @param {*} obj
 * @return {Boolean}
 * @see R.where, R.propEq, R.propIs
 * @example
 *
 *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
 */
var propSatisfies = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function propSatisfies(pred, name, obj) {
  return pred(obj[name]);
});
/* harmony default export */ __webpack_exports__["default"] = (propSatisfies);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/props.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/props.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Acts as multiple `prop`: array of keys in, array of values out. Preserves
 * order.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [k] -> {k: v} -> [v]
 * @param {Array} ps The property names to fetch
 * @param {Object} obj The object to query
 * @return {Array} The corresponding values or partially applied function.
 * @example
 *
 *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
 *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
 *
 *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
 *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
 */
var props = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function props(ps, obj) {
  var len = ps.length;
  var out = [];
  var idx = 0;

  while (idx < len) {
    out[idx] = obj[ps[idx]];
    idx += 1;
  }

  return out;
});
/* harmony default export */ __webpack_exports__["default"] = (props);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/range.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/range.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isNumber */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isNumber.js");



/**
 * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> Number -> [Number]
 * @param {Number} from The first number in the list.
 * @param {Number} to One more than the last number in the list.
 * @return {Array} The list of numbers in tthe set `[a, b)`.
 * @example
 *
 *      R.range(1, 5);    //=> [1, 2, 3, 4]
 *      R.range(50, 53);  //=> [50, 51, 52]
 */
var range = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function range(from, to) {
  if (!(Object(_internal_isNumber__WEBPACK_IMPORTED_MODULE_1__["default"])(from) && Object(_internal_isNumber__WEBPACK_IMPORTED_MODULE_1__["default"])(to))) {
    throw new TypeError('Both arguments to range must be numbers');
  }
  var result = [];
  var n = from;
  while (n < to) {
    result.push(n);
    n += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (range);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");



/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It may use
 * [`R.reduced`](#reduced) to shortcut the iteration.
 *
 * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
 * is *(value, acc)*.
 *
 * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduce` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
 *
 * Dispatches to the `reduce` method of the third argument, if present. When
 * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
 * shortcuting, as this is not implemented by `reduce`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduced, R.addIndex, R.reduceRight
 * @example
 *
 *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
 *      //          -               -10
 *      //         / \              / \
 *      //        -   4           -6   4
 *      //       / \              / \
 *      //      -   3   ==>     -3   3
 *      //     / \              / \
 *      //    -   2           -1   2
 *      //   / \              / \
 *      //  0   1            0   1
 *
 * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
 */
var reduce = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(_internal_reduce__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (reduce);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceBy.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceBy.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curryN__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curryN.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _internal_xreduceBy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/_xreduceBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xreduceBy.js");






/**
 * Groups the elements of the list according to the result of calling
 * the String-returning function `keyFn` on each element and reduces the elements
 * of each group to a single value via the reducer function `valueFn`.
 *
 * This function is basically a more general [`groupBy`](#groupBy) function.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category List
 * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
 * @param {Function} valueFn The function that reduces the elements of each group to a single
 *        value. Receives two values, accumulator for a particular group and the current element.
 * @param {*} acc The (initial) accumulator value for each group.
 * @param {Function} keyFn The function that maps the list's element into a key.
 * @param {Array} list The array to group.
 * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
 *         `valueFn` for elements which produced that key when passed to `keyFn`.
 * @see R.groupBy, R.reduce
 * @example
 *
 *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);
 *      var namesByGrade = reduceToNamesBy(function(student) {
 *        var score = student.score;
 *        return score < 65 ? 'F' :
 *               score < 70 ? 'D' :
 *               score < 80 ? 'C' :
 *               score < 90 ? 'B' : 'A';
 *      });
 *      var students = [{name: 'Lucy', score: 92},
 *                      {name: 'Drew', score: 85},
 *                      // ...
 *                      {name: 'Bart', score: 62}];
 *      namesByGrade(students);
 *      // {
 *      //   'A': ['Lucy'],
 *      //   'B': ['Drew']
 *      //   // ...,
 *      //   'F': ['Bart']
 *      // }
 */
var reduceBy = /*#__PURE__*/Object(_internal_curryN__WEBPACK_IMPORTED_MODULE_0__["default"])(4, [], /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xreduceBy__WEBPACK_IMPORTED_MODULE_4__["default"], function reduceBy(valueFn, valueAcc, keyFn, list) {
  return Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_3__["default"])(function (acc, elt) {
    var key = keyFn(elt);
    acc[key] = valueFn(Object(_internal_has__WEBPACK_IMPORTED_MODULE_2__["default"])(key, acc) ? acc[key] : valueAcc, elt);
    return acc;
  }, {}, list);
}));
/* harmony default export */ __webpack_exports__["default"] = (reduceBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceRight.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceRight.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * Similar to [`reduce`](#reduce), except moves through the input list from the
 * right to the left.
 *
 * The iterator function receives two values: *(value, acc)*, while the arguments'
 * order of `reduce`'s iterator function is *(acc, value)*.
 *
 * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduceRight` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> b) -> b -> [a] -> b
 * @param {Function} fn The iterator function. Receives two values, the current element from the array
 *        and the accumulator.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduce, R.addIndex
 * @example
 *
 *      R.reduceRight(R.subtract, 0, [1, 2, 3, 4]) // => (1 - (2 - (3 - (4 - 0)))) = -2
 *      //    -               -2
 *      //   / \              / \
 *      //  1   -            1   3
 *      //     / \              / \
 *      //    2   -     ==>    2  -1
 *      //       / \              / \
 *      //      3   -            3   4
 *      //         / \              / \
 *      //        4   0            4   0
 *
 * @symb R.reduceRight(f, a, [b, c, d]) = f(b, f(c, f(d, a)))
 */
var reduceRight = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function reduceRight(fn, acc, list) {
  var idx = list.length - 1;
  while (idx >= 0) {
    acc = fn(list[idx], acc);
    idx -= 1;
  }
  return acc;
});
/* harmony default export */ __webpack_exports__["default"] = (reduceRight);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceWhile.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceWhile.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curryN__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curryN.js");
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _internal_reduced__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");




/**
 * Like [`reduce`](#reduce), `reduceWhile` returns a single item by iterating
 * through the list, successively calling the iterator function. `reduceWhile`
 * also takes a predicate that is evaluated before each step. If the predicate
 * returns `false`, it "short-circuits" the iteration and returns the current
 * value of the accumulator.
 *
 * @func
 * @memberOf R
 * @since v0.22.0
 * @category List
 * @sig ((a, b) -> Boolean) -> ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} pred The predicate. It is passed the accumulator and the
 *        current element.
 * @param {Function} fn The iterator function. Receives two values, the
 *        accumulator and the current element.
 * @param {*} a The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduce, R.reduced
 * @example
 *
 *      var isOdd = (acc, x) => x % 2 === 1;
 *      var xs = [1, 3, 5, 60, 777, 800];
 *      R.reduceWhile(isOdd, R.add, 0, xs); //=> 9
 *
 *      var ys = [2, 4, 6]
 *      R.reduceWhile(isOdd, R.add, 111, ys); //=> 111
 */
var reduceWhile = /*#__PURE__*/Object(_internal_curryN__WEBPACK_IMPORTED_MODULE_0__["default"])(4, [], function _reduceWhile(pred, fn, a, list) {
  return Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_1__["default"])(function (acc, x) {
    return pred(acc, x) ? fn(acc, x) : Object(_internal_reduced__WEBPACK_IMPORTED_MODULE_2__["default"])(acc);
  }, a, list);
});
/* harmony default export */ __webpack_exports__["default"] = (reduceWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduced.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduced.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_reduced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_reduced */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduced.js");



/**
 * Returns a value wrapped to indicate that it is the final value of the reduce
 * and transduce functions. The returned value should be considered a black
 * box: the internal structure is not guaranteed to be stable.
 *
 * Note: this optimization is unavailable to functions not explicitly listed
 * above. For instance, it is not currently supported by
 * [`reduceRight`](#reduceRight).
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category List
 * @sig a -> *
 * @param {*} x The final value of the reduce.
 * @return {*} The wrapped value.
 * @see R.reduce, R.transduce
 * @example
 *
 *     R.reduce(
 *       (acc, item) => item > 3 ? R.reduced(acc) : acc.concat(item),
 *       [],
 *       [1, 2, 3, 4, 5]) // [1, 2, 3]
 */
var reduced = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(_internal_reduced__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (reduced);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reject.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reject.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_complement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_complement */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_complement.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/filter.js");




/**
 * The complement of [`filter`](#filter).
 *
 * Acts as a transducer if a transformer is given in list position. Filterable
 * objects include plain objects or any object that has a filter method such
 * as `Array`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array}
 * @see R.filter, R.transduce, R.addIndex
 * @example
 *
 *      var isOdd = (n) => n % 2 === 1;
 *
 *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */
var reject = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function reject(pred, filterable) {
  return Object(_filter__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_internal_complement__WEBPACK_IMPORTED_MODULE_0__["default"])(pred), filterable);
});
/* harmony default export */ __webpack_exports__["default"] = (reject);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/remove.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/remove.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Removes the sub-list of `list` starting at index `start` and containing
 * `count` elements. _Note that this is not destructive_: it returns a copy of
 * the list with the changes.
 * <small>No lists have been harmed in the application of this function.</small>
 *
 * @func
 * @memberOf R
 * @since v0.2.2
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @param {Number} start The position to start removing elements
 * @param {Number} count The number of elements to remove
 * @param {Array} list The list to remove from
 * @return {Array} A new Array with `count` elements from `start` removed.
 * @example
 *
 *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
 */
var remove = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function remove(start, count, list) {
  var result = Array.prototype.slice.call(list, 0);
  result.splice(start, count);
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (remove);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/repeat.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/repeat.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _always__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./always */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js");
/* harmony import */ var _times__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./times */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/times.js");




/**
 * Returns a fixed list of size `n` containing a specified identical value.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig a -> n -> [a]
 * @param {*} value The value to repeat.
 * @param {Number} n The desired size of the output list.
 * @return {Array} A new array containing `n` `value`s.
 * @see R.times
 * @example
 *
 *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
 *
 *      var obj = {};
 *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
 *      repeatedObjs[0] === repeatedObjs[1]; //=> true
 * @symb R.repeat(a, 0) = []
 * @symb R.repeat(a, 1) = [a]
 * @symb R.repeat(a, 2) = [a, a]
 */
var repeat = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function repeat(value, n) {
  return Object(_times__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_always__WEBPACK_IMPORTED_MODULE_1__["default"])(value), n);
});
/* harmony default export */ __webpack_exports__["default"] = (repeat);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/replace.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/replace.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Replace a substring or regex match in a string with a replacement.
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category String
 * @sig RegExp|String -> String -> String -> String
 * @param {RegExp|String} pattern A regular expression or a substring to match.
 * @param {String} replacement The string to replace the matches with.
 * @param {String} str The String to do the search and replacement in.
 * @return {String} The result.
 * @example
 *
 *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
 *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
 *
 *      // Use the "g" (global) flag to replace all occurrences:
 *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
 */
var replace = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function replace(regex, replacement, str) {
  return str.replace(regex, replacement);
});
/* harmony default export */ __webpack_exports__["default"] = (replace);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reverse.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reverse.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_isString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_isString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isString.js");



/**
 * Returns a new list or string with the elements or characters in reverse
 * order.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {Array|String} list
 * @return {Array|String}
 * @example
 *
 *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
 *      R.reverse([1, 2]);     //=> [2, 1]
 *      R.reverse([1]);        //=> [1]
 *      R.reverse([]);         //=> []
 *
 *      R.reverse('abc');      //=> 'cba'
 *      R.reverse('ab');       //=> 'ba'
 *      R.reverse('a');        //=> 'a'
 *      R.reverse('');         //=> ''
 */
var reverse = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function reverse(list) {
  return Object(_internal_isString__WEBPACK_IMPORTED_MODULE_1__["default"])(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();
});
/* harmony default export */ __webpack_exports__["default"] = (reverse);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/scan.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/scan.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Scan is similar to [`reduce`](#reduce), but returns a list of successively
 * reduced values from the left
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig ((a, b) -> a) -> a -> [b] -> [a]
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {Array} A list of all intermediately reduced values.
 * @see R.reduce
 * @example
 *
 *      var numbers = [1, 2, 3, 4];
 *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
 * @symb R.scan(f, a, [b, c]) = [a, f(a, b), f(f(a, b), c)]
 */
var scan = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function scan(fn, acc, list) {
  var idx = 0;
  var len = list.length;
  var result = [acc];
  while (idx < len) {
    acc = fn(acc, list[idx]);
    result[idx + 1] = acc;
    idx += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (scan);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sequence.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sequence.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _ap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/ap.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");
/* harmony import */ var _prepend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./prepend */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/prepend.js");
/* harmony import */ var _reduceRight__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reduceRight */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduceRight.js");






/**
 * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
 * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
 * Applicative of Traversable.
 *
 * Dispatches to the `sequence` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
 * @param {Function} of
 * @param {*} traversable
 * @return {*}
 * @see R.traverse
 * @example
 *
 *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
 *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
 *
 *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
 *      R.sequence(R.of, Nothing());       //=> [Nothing()]
 */
var sequence = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function sequence(of, traversable) {
  return typeof traversable.sequence === 'function' ? traversable.sequence(of) : Object(_reduceRight__WEBPACK_IMPORTED_MODULE_4__["default"])(function (x, acc) {
    return Object(_ap__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_map__WEBPACK_IMPORTED_MODULE_2__["default"])(_prepend__WEBPACK_IMPORTED_MODULE_3__["default"], x), acc);
  }, of([]), traversable);
});
/* harmony default export */ __webpack_exports__["default"] = (sequence);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/set.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/set.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _always__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./always */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js");
/* harmony import */ var _over__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./over */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/over.js");




/**
 * Returns the result of "setting" the portion of the given data structure
 * focused by the given lens to the given value.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Lens s a -> a -> s -> s
 * @param {Lens} lens
 * @param {*} v
 * @param {*} x
 * @return {*}
 * @see R.prop, R.lensIndex, R.lensProp
 * @example
 *
 *      var xLens = R.lensProp('x');
 *
 *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
 *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
 */
var set = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function set(lens, v, x) {
  return Object(_over__WEBPACK_IMPORTED_MODULE_2__["default"])(lens, Object(_always__WEBPACK_IMPORTED_MODULE_1__["default"])(v), x);
});
/* harmony default export */ __webpack_exports__["default"] = (set);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_checkForMethod */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_checkForMethod.js");
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");



/**
 * Returns the elements of the given list or string (or object with a `slice`
 * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
 *
 * Dispatches to the `slice` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @sig Number -> Number -> String -> String
 * @param {Number} fromIndex The start index (inclusive).
 * @param {Number} toIndex The end index (exclusive).
 * @param {*} list
 * @return {*}
 * @example
 *
 *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
 *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
 *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
 *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
 *      R.slice(0, 3, 'ramda');                     //=> 'ram'
 */
var slice = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__["default"])('slice', function slice(fromIndex, toIndex, list) {
  return Array.prototype.slice.call(list, fromIndex, toIndex);
}));
/* harmony default export */ __webpack_exports__["default"] = (slice);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sort.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sort.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Returns a copy of the list, sorted according to the comparator function,
 * which should accept two values at a time and return a negative number if the
 * first value is smaller, a positive number if it's larger, and zero if they
 * are equal. Please note that this is a **copy** of the list. It does not
 * modify the original.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, a) -> Number) -> [a] -> [a]
 * @param {Function} comparator A sorting function :: a -> b -> Int
 * @param {Array} list The list to sort
 * @return {Array} a new array with its elements sorted by the comparator function.
 * @example
 *
 *      var diff = function(a, b) { return a - b; };
 *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
 */
var sort = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function sort(comparator, list) {
  return Array.prototype.slice.call(list, 0).sort(comparator);
});
/* harmony default export */ __webpack_exports__["default"] = (sort);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sortBy.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sortBy.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Sorts the list according to the supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord b => (a -> b) -> [a] -> [a]
 * @param {Function} fn
 * @param {Array} list The list to sort.
 * @return {Array} A new list sorted by the keys generated by `fn`.
 * @example
 *
 *      var sortByFirstItem = R.sortBy(R.prop(0));
 *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
 *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
 *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
 *      var alice = {
 *        name: 'ALICE',
 *        age: 101
 *      };
 *      var bob = {
 *        name: 'Bob',
 *        age: -10
 *      };
 *      var clara = {
 *        name: 'clara',
 *        age: 314.159
 *      };
 *      var people = [clara, bob, alice];
 *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
 */
var sortBy = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function sortBy(fn, list) {
  return Array.prototype.slice.call(list, 0).sort(function (a, b) {
    var aa = fn(a);
    var bb = fn(b);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });
});
/* harmony default export */ __webpack_exports__["default"] = (sortBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sortWith.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sortWith.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Sorts a list according to a list of comparators.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Relation
 * @sig [(a, a) -> Number] -> [a] -> [a]
 * @param {Array} functions A list of comparator functions.
 * @param {Array} list The list to sort.
 * @return {Array} A new list sorted according to the comarator functions.
 * @example
 *
 *      var alice = {
 *        name: 'alice',
 *        age: 40
 *      };
 *      var bob = {
 *        name: 'bob',
 *        age: 30
 *      };
 *      var clara = {
 *        name: 'clara',
 *        age: 40
 *      };
 *      var people = [clara, bob, alice];
 *      var ageNameSort = R.sortWith([
 *        R.descend(R.prop('age')),
 *        R.ascend(R.prop('name'))
 *      ]);
 *      ageNameSort(people); //=> [alice, clara, bob]
 */
var sortWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function sortWith(fns, list) {
  return Array.prototype.slice.call(list, 0).sort(function (a, b) {
    var result = 0;
    var i = 0;
    while (result === 0 && i < fns.length) {
      result = fns[i](a, b);
      i += 1;
    }
    return result;
  });
});
/* harmony default export */ __webpack_exports__["default"] = (sortWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/split.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/split.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _invoker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invoker */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invoker.js");


/**
 * Splits a string into an array of strings based on the given
 * separator.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category String
 * @sig (String | RegExp) -> String -> [String]
 * @param {String|RegExp} sep The pattern.
 * @param {String} str The string to separate into an array.
 * @return {Array} The array of strings from `str` separated by `str`.
 * @see R.join
 * @example
 *
 *      var pathComponents = R.split('/');
 *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
 *
 *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
 */
var split = /*#__PURE__*/Object(_invoker__WEBPACK_IMPORTED_MODULE_0__["default"])(1, 'split');
/* harmony default export */ __webpack_exports__["default"] = (split);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitAt.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitAt.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _length__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./length */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/length.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");




/**
 * Splits a given list or string at a given index.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig Number -> [a] -> [[a], [a]]
 * @sig Number -> String -> [String, String]
 * @param {Number} index The index where the array/string is split.
 * @param {Array|String} array The array/string to be split.
 * @return {Array}
 * @example
 *
 *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
 *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
 *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
 */
var splitAt = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function splitAt(index, array) {
  return [Object(_slice__WEBPACK_IMPORTED_MODULE_2__["default"])(0, index, array), Object(_slice__WEBPACK_IMPORTED_MODULE_2__["default"])(index, Object(_length__WEBPACK_IMPORTED_MODULE_1__["default"])(array), array)];
});
/* harmony default export */ __webpack_exports__["default"] = (splitAt);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitEvery.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitEvery.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");



/**
 * Splits a collection into slices of the specified length.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [[a]]
 * @sig Number -> String -> [String]
 * @param {Number} n
 * @param {Array} list
 * @return {Array}
 * @example
 *
 *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
 *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
 */
var splitEvery = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function splitEvery(n, list) {
  if (n <= 0) {
    throw new Error('First argument to splitEvery must be a positive integer');
  }
  var result = [];
  var idx = 0;
  while (idx < list.length) {
    result.push(Object(_slice__WEBPACK_IMPORTED_MODULE_1__["default"])(idx, idx += n, list));
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (splitEvery);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitWhen.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/splitWhen.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Takes a list and a predicate and returns a pair of lists with the following properties:
 *
 *  - the result of concatenating the two output lists is equivalent to the input list;
 *  - none of the elements of the first output list satisfies the predicate; and
 *  - if the second output list is non-empty, its first element satisfies the predicate.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [[a], [a]]
 * @param {Function} pred The predicate that determines where the array is split.
 * @param {Array} list The array to be split.
 * @return {Array}
 * @example
 *
 *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
 */
var splitWhen = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function splitWhen(pred, list) {
  var idx = 0;
  var len = list.length;
  var prefix = [];

  while (idx < len && !pred(list[idx])) {
    prefix.push(list[idx]);
    idx += 1;
  }

  return [prefix, Array.prototype.slice.call(list, idx)];
});
/* harmony default export */ __webpack_exports__["default"] = (splitWhen);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/startsWith.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/startsWith.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");
/* harmony import */ var _take__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./take */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/take.js");




/**
 * Checks if a list starts with the provided values
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category List
 * @sig [a] -> Boolean
 * @sig String -> Boolean
 * @param {*} prefix
 * @param {*} list
 * @return {Boolean}
 * @example
 *
 *      R.startsWith('a', 'abc')                //=> true
 *      R.startsWith('b', 'abc')                //=> false
 *      R.startsWith(['a'], ['a', 'b', 'c'])    //=> true
 *      R.startsWith(['b'], ['a', 'b', 'c'])    //=> false
 */
var startsWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function (prefix, list) {
  return Object(_equals__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_take__WEBPACK_IMPORTED_MODULE_2__["default"])(prefix.length, list), prefix);
});
/* harmony default export */ __webpack_exports__["default"] = (startsWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/subtract.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/subtract.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Subtracts its second argument from its first argument.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The first value.
 * @param {Number} b The second value.
 * @return {Number} The result of `a - b`.
 * @see R.add
 * @example
 *
 *      R.subtract(10, 8); //=> 2
 *
 *      var minus5 = R.subtract(R.__, 5);
 *      minus5(17); //=> 12
 *
 *      var complementaryAngle = R.subtract(90);
 *      complementaryAngle(30); //=> 60
 *      complementaryAngle(72); //=> 18
 */
var subtract = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function subtract(a, b) {
  return Number(a) - Number(b);
});
/* harmony default export */ __webpack_exports__["default"] = (subtract);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sum.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sum.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _add__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/add.js");
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reduce.js");



/**
 * Adds together all the elements of a list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list An array of numbers
 * @return {Number} The sum of all the numbers in the list.
 * @see R.reduce
 * @example
 *
 *      R.sum([2,4,6,8,100,1]); //=> 121
 */
var sum = /*#__PURE__*/Object(_reduce__WEBPACK_IMPORTED_MODULE_1__["default"])(_add__WEBPACK_IMPORTED_MODULE_0__["default"], 0);
/* harmony default export */ __webpack_exports__["default"] = (sum);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/symmetricDifference.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/symmetricDifference.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _concat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/concat.js");
/* harmony import */ var _difference__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./difference */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/difference.js");




/**
 * Finds the set (i.e. no duplicates) of all elements contained in the first or
 * second list, but not both.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` or `list2`, but not both.
 * @see R.symmetricDifferenceWith, R.difference, R.differenceWith
 * @example
 *
 *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
 *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
 */
var symmetricDifference = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function symmetricDifference(list1, list2) {
  return Object(_concat__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_difference__WEBPACK_IMPORTED_MODULE_2__["default"])(list1, list2), Object(_difference__WEBPACK_IMPORTED_MODULE_2__["default"])(list2, list1));
});
/* harmony default export */ __webpack_exports__["default"] = (symmetricDifference);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/symmetricDifferenceWith.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/symmetricDifferenceWith.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _concat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/concat.js");
/* harmony import */ var _differenceWith__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./differenceWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/differenceWith.js");




/**
 * Finds the set (i.e. no duplicates) of all elements contained in the first or
 * second list, but not both. Duplication is determined according to the value
 * returned by applying the supplied predicate to two list elements.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Relation
 * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` or `list2`, but not both.
 * @see R.symmetricDifference, R.difference, R.differenceWith
 * @example
 *
 *      var eqA = R.eqBy(R.prop('a'));
 *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
 *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
 *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
 */
var symmetricDifferenceWith = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function symmetricDifferenceWith(pred, list1, list2) {
  return Object(_concat__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_differenceWith__WEBPACK_IMPORTED_MODULE_2__["default"])(pred, list1, list2), Object(_differenceWith__WEBPACK_IMPORTED_MODULE_2__["default"])(pred, list2, list1));
});
/* harmony default export */ __webpack_exports__["default"] = (symmetricDifferenceWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tail.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tail.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_checkForMethod */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_checkForMethod.js");
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");




/**
 * Returns all but the first element of the given list or string (or object
 * with a `tail` method).
 *
 * Dispatches to the `slice` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.head, R.init, R.last
 * @example
 *
 *      R.tail([1, 2, 3]);  //=> [2, 3]
 *      R.tail([1, 2]);     //=> [2]
 *      R.tail([1]);        //=> []
 *      R.tail([]);         //=> []
 *
 *      R.tail('abc');  //=> 'bc'
 *      R.tail('ab');   //=> 'b'
 *      R.tail('a');    //=> ''
 *      R.tail('');     //=> ''
 */
var tail = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_internal_checkForMethod__WEBPACK_IMPORTED_MODULE_0__["default"])('tail', /*#__PURE__*/Object(_slice__WEBPACK_IMPORTED_MODULE_2__["default"])(1, Infinity)));
/* harmony default export */ __webpack_exports__["default"] = (tail);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/take.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/take.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xtake__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xtake */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtake.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");





/**
 * Returns the first `n` elements of the given list, string, or
 * transducer/transformer (or object with a `take` method).
 *
 * Dispatches to the `take` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n
 * @param {*} list
 * @return {*}
 * @see R.drop
 * @example
 *
 *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
 *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
 *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.take(3, 'ramda');               //=> 'ram'
 *
 *      var personnel = [
 *        'Dave Brubeck',
 *        'Paul Desmond',
 *        'Eugene Wright',
 *        'Joe Morello',
 *        'Gerry Mulligan',
 *        'Bob Bates',
 *        'Joe Dodge',
 *        'Ron Crotty'
 *      ];
 *
 *      var takeFive = R.take(5);
 *      takeFive(personnel);
 *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
 * @symb R.take(-1, [a, b]) = [a, b]
 * @symb R.take(0, [a, b]) = []
 * @symb R.take(1, [a, b]) = [a]
 * @symb R.take(2, [a, b]) = [a, b]
 */
var take = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['take'], _internal_xtake__WEBPACK_IMPORTED_MODULE_2__["default"], function take(n, xs) {
  return Object(_slice__WEBPACK_IMPORTED_MODULE_3__["default"])(0, n < 0 ? Infinity : n, xs);
}));
/* harmony default export */ __webpack_exports__["default"] = (take);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeLast.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeLast.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _drop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drop */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/drop.js");



/**
 * Returns a new list containing the last `n` elements of the given list.
 * If `n > list.length`, returns a list of `list.length` elements.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n The number of elements to return.
 * @param {Array} xs The collection to consider.
 * @return {Array}
 * @see R.dropLast
 * @example
 *
 *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
 *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
 *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.takeLast(3, 'ramda');               //=> 'mda'
 */
var takeLast = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function takeLast(n, xs) {
  return Object(_drop__WEBPACK_IMPORTED_MODULE_1__["default"])(n >= 0 ? xs.length - n : 0, xs);
});
/* harmony default export */ __webpack_exports__["default"] = (takeLast);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeLastWhile.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeLastWhile.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");



/**
 * Returns a new list containing the last `n` elements of a given list, passing
 * each value to the supplied predicate function, and terminating when the
 * predicate function returns `false`. Excludes the element that caused the
 * predicate function to fail. The predicate function is passed one argument:
 * *(value)*.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @sig (a -> Boolean) -> String -> String
 * @param {Function} fn The function called per iteration.
 * @param {Array} xs The collection to iterate over.
 * @return {Array} A new array.
 * @see R.dropLastWhile, R.addIndex
 * @example
 *
 *      var isNotOne = x => x !== 1;
 *
 *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
 *
 *      R.takeLastWhile(x => x !== 'R' , 'Ramda'); //=> 'amda'
 */
var takeLastWhile = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function takeLastWhile(fn, xs) {
  var idx = xs.length - 1;
  while (idx >= 0 && fn(xs[idx])) {
    idx -= 1;
  }
  return Object(_slice__WEBPACK_IMPORTED_MODULE_1__["default"])(idx + 1, Infinity, xs);
});
/* harmony default export */ __webpack_exports__["default"] = (takeLastWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeWhile.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/takeWhile.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xtakeWhile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xtakeWhile */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtakeWhile.js");
/* harmony import */ var _slice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./slice */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/slice.js");





/**
 * Returns a new list containing the first `n` elements of a given list,
 * passing each value to the supplied predicate function, and terminating when
 * the predicate function returns `false`. Excludes the element that caused the
 * predicate function to fail. The predicate function is passed one argument:
 * *(value)*.
 *
 * Dispatches to the `takeWhile` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @sig (a -> Boolean) -> String -> String
 * @param {Function} fn The function called per iteration.
 * @param {Array} xs The collection to iterate over.
 * @return {Array} A new array.
 * @see R.dropWhile, R.transduce, R.addIndex
 * @example
 *
 *      var isNotFour = x => x !== 4;
 *
 *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
 *
 *      R.takeWhile(x => x !== 'd' , 'Ramda'); //=> 'Ram'
 */
var takeWhile = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])(['takeWhile'], _internal_xtakeWhile__WEBPACK_IMPORTED_MODULE_2__["default"], function takeWhile(fn, xs) {
  var idx = 0;
  var len = xs.length;
  while (idx < len && fn(xs[idx])) {
    idx += 1;
  }
  return Object(_slice__WEBPACK_IMPORTED_MODULE_3__["default"])(0, idx, xs);
}));
/* harmony default export */ __webpack_exports__["default"] = (takeWhile);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tap.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tap.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_dispatchable.js");
/* harmony import */ var _internal_xtap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_xtap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xtap.js");




/**
 * Runs the given function with the supplied object, then returns the object.
 *
 * Acts as a transducer if a transformer is given as second parameter.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (a -> *) -> a -> a
 * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
 * @param {*} x
 * @return {*} `x`.
 * @example
 *
 *      var sayX = x => console.log('x is ' + x);
 *      R.tap(sayX, 100); //=> 100
 *      // logs 'x is 100'
 * @symb R.tap(f, a) = a
 */
var tap = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/Object(_internal_dispatchable__WEBPACK_IMPORTED_MODULE_1__["default"])([], _internal_xtap__WEBPACK_IMPORTED_MODULE_2__["default"], function tap(fn, x) {
  fn(x);
  return x;
}));
/* harmony default export */ __webpack_exports__["default"] = (tap);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/test.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/test.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_cloneRegExp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_cloneRegExp */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_cloneRegExp.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_isRegExp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_isRegExp */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_isRegExp.js");
/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toString.js");





/**
 * Determines whether a given string matches a given regular expression.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category String
 * @sig RegExp -> String -> Boolean
 * @param {RegExp} pattern
 * @param {String} str
 * @return {Boolean}
 * @see R.match
 * @example
 *
 *      R.test(/^x/, 'xyz'); //=> true
 *      R.test(/^y/, 'xyz'); //=> false
 */
var test = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function test(pattern, str) {
  if (!Object(_internal_isRegExp__WEBPACK_IMPORTED_MODULE_2__["default"])(pattern)) {
    throw new TypeError('âtestâ requires a value of type RegExp as its first argument; received ' + Object(_toString__WEBPACK_IMPORTED_MODULE_3__["default"])(pattern));
  }
  return Object(_internal_cloneRegExp__WEBPACK_IMPORTED_MODULE_0__["default"])(pattern).test(str);
});
/* harmony default export */ __webpack_exports__["default"] = (test);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/times.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/times.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Calls an input function `n` times, returning an array containing the results
 * of those function calls.
 *
 * `fn` is passed one argument: The current value of `n`, which begins at `0`
 * and is gradually incremented to `n - 1`.
 *
 * @func
 * @memberOf R
 * @since v0.2.3
 * @category List
 * @sig (Number -> a) -> Number -> [a]
 * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
 * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
 * @return {Array} An array containing the return values of all calls to `fn`.
 * @see R.repeat
 * @example
 *
 *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
 * @symb R.times(f, 0) = []
 * @symb R.times(f, 1) = [f(0)]
 * @symb R.times(f, 2) = [f(0), f(1)]
 */
var times = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function times(fn, n) {
  var len = Number(n);
  var idx = 0;
  var list;

  if (len < 0 || isNaN(len)) {
    throw new RangeError('n must be a non-negative number');
  }
  list = new Array(len);
  while (idx < len) {
    list[idx] = fn(idx);
    idx += 1;
  }
  return list;
});
/* harmony default export */ __webpack_exports__["default"] = (times);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toLower.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toLower.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _invoker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invoker */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invoker.js");


/**
 * The lower case version of a string.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category String
 * @sig String -> String
 * @param {String} str The string to lower case.
 * @return {String} The lower case version of `str`.
 * @see R.toUpper
 * @example
 *
 *      R.toLower('XYZ'); //=> 'xyz'
 */
var toLower = /*#__PURE__*/Object(_invoker__WEBPACK_IMPORTED_MODULE_0__["default"])(0, 'toLowerCase');
/* harmony default export */ __webpack_exports__["default"] = (toLower);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toPairs.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toPairs.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");



/**
 * Converts an object into an array of key, value arrays. Only the object's
 * own properties are used.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.4.0
 * @category Object
 * @sig {String: *} -> [[String,*]]
 * @param {Object} obj The object to extract from
 * @return {Array} An array of key, value arrays from the object's own properties.
 * @see R.fromPairs
 * @example
 *
 *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
 */
var toPairs = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function toPairs(obj) {
  var pairs = [];
  for (var prop in obj) {
    if (Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(prop, obj)) {
      pairs[pairs.length] = [prop, obj[prop]];
    }
  }
  return pairs;
});
/* harmony default export */ __webpack_exports__["default"] = (toPairs);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toPairsIn.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toPairsIn.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Converts an object into an array of key, value arrays. The object's own
 * properties and prototype properties are used. Note that the order of the
 * output array is not guaranteed to be consistent across different JS
 * platforms.
 *
 * @func
 * @memberOf R
 * @since v0.4.0
 * @category Object
 * @sig {String: *} -> [[String,*]]
 * @param {Object} obj The object to extract from
 * @return {Array} An array of key, value arrays from the object's own
 *         and prototype properties.
 * @example
 *
 *      var F = function() { this.x = 'X'; };
 *      F.prototype.y = 'Y';
 *      var f = new F();
 *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
 */
var toPairsIn = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function toPairsIn(obj) {
  var pairs = [];
  for (var prop in obj) {
    pairs[pairs.length] = [prop, obj[prop]];
  }
  return pairs;
});
/* harmony default export */ __webpack_exports__["default"] = (toPairsIn);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toString.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toString.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _internal_toString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_toString */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_toString.js");



/**
 * Returns the string representation of the given value. `eval`'ing the output
 * should result in a value equivalent to the input value. Many of the built-in
 * `toString` methods do not satisfy this requirement.
 *
 * If the given value is an `[object Object]` with a `toString` method other
 * than `Object.prototype.toString`, this method is invoked with no arguments
 * to produce the return value. This means user-defined constructor functions
 * can provide a suitable `toString` method. For example:
 *
 *     function Point(x, y) {
 *       this.x = x;
 *       this.y = y;
 *     }
 *
 *     Point.prototype.toString = function() {
 *       return 'new Point(' + this.x + ', ' + this.y + ')';
 *     };
 *
 *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category String
 * @sig * -> String
 * @param {*} val
 * @return {String}
 * @example
 *
 *      R.toString(42); //=> '42'
 *      R.toString('abc'); //=> '"abc"'
 *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
 *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
 *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
 */
var toString = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function toString(val) {
  return Object(_internal_toString__WEBPACK_IMPORTED_MODULE_1__["default"])(val, []);
});
/* harmony default export */ __webpack_exports__["default"] = (toString);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toUpper.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/toUpper.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _invoker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invoker */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/invoker.js");


/**
 * The upper case version of a string.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category String
 * @sig String -> String
 * @param {String} str The string to upper case.
 * @return {String} The upper case version of `str`.
 * @see R.toLower
 * @example
 *
 *      R.toUpper('abc'); //=> 'ABC'
 */
var toUpper = /*#__PURE__*/Object(_invoker__WEBPACK_IMPORTED_MODULE_0__["default"])(0, 'toUpperCase');
/* harmony default export */ __webpack_exports__["default"] = (toUpper);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/transduce.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/transduce.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_reduce */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_reduce.js");
/* harmony import */ var _internal_xwrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_xwrap */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_xwrap.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");




/**
 * Initializes a transducer using supplied iterator function. Returns a single
 * item by iterating through the list, successively calling the transformed
 * iterator function and passing it an accumulator value and the current value
 * from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It will be
 * wrapped as a transformer to initialize the transducer. A transformer can be
 * passed directly in place of an iterator function. In both cases, iteration
 * may be stopped early with the [`R.reduced`](#reduced) function.
 *
 * A transducer is a function that accepts a transformer and returns a
 * transformer and can be composed directly.
 *
 * A transformer is an an object that provides a 2-arity reducing iterator
 * function, step, 0-arity initial value function, init, and 1-arity result
 * extraction function, result. The step function is used as the iterator
 * function in reduce. The result function is used to convert the final
 * accumulator into the return type and in most cases is
 * [`R.identity`](#identity). The init function can be used to provide an
 * initial accumulator, but is ignored by transduce.
 *
 * The iteration is performed with [`R.reduce`](#reduce) after initializing the transducer.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig (c -> c) -> ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array. Wrapped as transformer, if necessary, and used to
 *        initialize the transducer
 * @param {*} acc The initial accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduce, R.reduced, R.into
 * @example
 *
 *      var numbers = [1, 2, 3, 4];
 *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
 *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
 *
 *      var isOdd = (x) => x % 2 === 1;
 *      var firstOddTransducer = R.compose(R.filter(isOdd), R.take(1));
 *      R.transduce(firstOddTransducer, R.flip(R.append), [], R.range(0, 100)); //=> [1]
 */
var transduce = /*#__PURE__*/Object(_curryN__WEBPACK_IMPORTED_MODULE_2__["default"])(4, function transduce(xf, fn, acc, list) {
  return Object(_internal_reduce__WEBPACK_IMPORTED_MODULE_0__["default"])(xf(typeof fn === 'function' ? Object(_internal_xwrap__WEBPACK_IMPORTED_MODULE_1__["default"])(fn) : fn), acc, list);
});
/* harmony default export */ __webpack_exports__["default"] = (transduce);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/transpose.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/transpose.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Transposes the rows and columns of a 2D list.
 * When passed a list of `n` lists of length `x`,
 * returns a list of `x` lists of length `n`.
 *
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig [[a]] -> [[a]]
 * @param {Array} list A 2D list
 * @return {Array} A 2D list
 * @example
 *
 *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
 *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
 *
 *      // If some of the rows are shorter than the following rows, their elements are skipped:
 *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
 * @symb R.transpose([[a], [b], [c]]) = [a, b, c]
 * @symb R.transpose([[a, b], [c, d]]) = [[a, c], [b, d]]
 * @symb R.transpose([[a, b], [c]]) = [[a, c], [b]]
 */
var transpose = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function transpose(outerlist) {
  var i = 0;
  var result = [];
  while (i < outerlist.length) {
    var innerlist = outerlist[i];
    var j = 0;
    while (j < innerlist.length) {
      if (typeof result[j] === 'undefined') {
        result[j] = [];
      }
      result[j].push(innerlist[j]);
      j += 1;
    }
    i += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (transpose);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/traverse.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/traverse.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");
/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sequence */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/sequence.js");




/**
 * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
 * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
 * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
 * into an Applicative of Traversable.
 *
 * Dispatches to the `traverse` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
 * @param {Function} of
 * @param {Function} f
 * @param {*} traversable
 * @return {*}
 * @see R.sequence
 * @example
 *
 *      // Returns `Nothing` if the given divisor is `0`
 *      safeDiv = n => d => d === 0 ? Nothing() : Just(n / d)
 *
 *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Just([5, 2.5, 2])
 *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing
 */
var traverse = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function traverse(of, f, traversable) {
  return typeof traversable['fantasy-land/traverse'] === 'function' ? traversable['fantasy-land/traverse'](f, of) : Object(_sequence__WEBPACK_IMPORTED_MODULE_2__["default"])(of, Object(_map__WEBPACK_IMPORTED_MODULE_1__["default"])(f, traversable));
});
/* harmony default export */ __webpack_exports__["default"] = (traverse);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/trim.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/trim.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
var zeroWidth = '\u200b';
var hasProtoTrim = typeof String.prototype.trim === 'function';
/**
 * Removes (strips) whitespace from both ends of the string.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category String
 * @sig String -> String
 * @param {String} str The string to trim.
 * @return {String} Trimmed version of `str`.
 * @example
 *
 *      R.trim('   xyz  '); //=> 'xyz'
 *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
 */
var _trim = !hasProtoTrim || /*#__PURE__*/ws.trim() || ! /*#__PURE__*/zeroWidth.trim() ? function trim(str) {
  var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
  var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
  return str.replace(beginRx, '').replace(endRx, '');
} : function trim(str) {
  return str.trim();
};
var trim = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(_trim);
/* harmony default export */ __webpack_exports__["default"] = (trim);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tryCatch.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/tryCatch.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_arity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_arity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_arity.js");
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");




/**
 * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
 * function evaluates the `tryer`; if it does not throw, it simply returns the
 * result. If the `tryer` *does* throw, the returned function evaluates the
 * `catcher` function and returns its result. Note that for effective
 * composition with this function, both the `tryer` and `catcher` functions
 * must return the same type of results.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Function
 * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
 * @param {Function} tryer The function that may throw.
 * @param {Function} catcher The function that will be evaluated if `tryer` throws.
 * @return {Function} A new function that will catch exceptions and send then to the catcher.
 * @example
 *
 *      R.tryCatch(R.prop('x'), R.F)({x: true}); //=> true
 *      R.tryCatch(R.prop('x'), R.F)(null);      //=> false
 */
var tryCatch = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_2__["default"])(function _tryCatch(tryer, catcher) {
  return Object(_internal_arity__WEBPACK_IMPORTED_MODULE_0__["default"])(tryer.length, function () {
    try {
      return tryer.apply(this, arguments);
    } catch (e) {
      return catcher.apply(this, Object(_internal_concat__WEBPACK_IMPORTED_MODULE_1__["default"])([e], arguments));
    }
  });
});
/* harmony default export */ __webpack_exports__["default"] = (tryCatch);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/type.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/type.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Gives a single-word string description of the (native) type of a value,
 * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
 * attempt to distinguish user Object types any further, reporting them all as
 * 'Object'.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Type
 * @sig (* -> {*}) -> String
 * @param {*} val The value to test
 * @return {String}
 * @example
 *
 *      R.type({}); //=> "Object"
 *      R.type(1); //=> "Number"
 *      R.type(false); //=> "Boolean"
 *      R.type('s'); //=> "String"
 *      R.type(null); //=> "Null"
 *      R.type([]); //=> "Array"
 *      R.type(/[A-z]/); //=> "RegExp"
 *      R.type(() => {}); //=> "Function"
 *      R.type(undefined); //=> "Undefined"
 */
var type = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function type(val) {
  return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
});
/* harmony default export */ __webpack_exports__["default"] = (type);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unapply.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unapply.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Takes a function `fn`, which takes a single array argument, and returns a
 * function which:
 *
 *   - takes any number of positional arguments;
 *   - passes these arguments to `fn` as an array; and
 *   - returns the result.
 *
 * In other words, `R.unapply` derives a variadic function from a function which
 * takes an array. `R.unapply` is the inverse of [`R.apply`](#apply).
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Function
 * @sig ([*...] -> a) -> (*... -> a)
 * @param {Function} fn
 * @return {Function}
 * @see R.apply
 * @example
 *
 *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
 * @symb R.unapply(f)(a, b) = f([a, b])
 */
var unapply = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function unapply(fn) {
  return function () {
    return fn(Array.prototype.slice.call(arguments, 0));
  };
});
/* harmony default export */ __webpack_exports__["default"] = (unapply);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unary.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unary.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _nAry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nAry */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/nAry.js");



/**
 * Wraps a function of any arity (including nullary) in a function that accepts
 * exactly 1 parameter. Any extraneous parameters will not be passed to the
 * supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Function
 * @sig (* -> b) -> (a -> b)
 * @param {Function} fn The function to wrap.
 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
 *         arity 1.
 * @see R.binary, R.nAry
 * @example
 *
 *      var takesTwoArgs = function(a, b) {
 *        return [a, b];
 *      };
 *      takesTwoArgs.length; //=> 2
 *      takesTwoArgs(1, 2); //=> [1, 2]
 *
 *      var takesOneArg = R.unary(takesTwoArgs);
 *      takesOneArg.length; //=> 1
 *      // Only 1 argument is passed to the wrapped function
 *      takesOneArg(1, 2); //=> [1, undefined]
 * @symb R.unary(f)(a, b, c) = f(a)
 */
var unary = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function unary(fn) {
  return Object(_nAry__WEBPACK_IMPORTED_MODULE_1__["default"])(1, fn);
});
/* harmony default export */ __webpack_exports__["default"] = (unary);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uncurryN.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uncurryN.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");



/**
 * Returns a function of arity `n` from a (manually) curried function.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Function
 * @sig Number -> (a -> b) -> (a -> c)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to uncurry.
 * @return {Function} A new function.
 * @see R.curry
 * @example
 *
 *      var addFour = a => b => c => d => a + b + c + d;
 *
 *      var uncurriedAddFour = R.uncurryN(4, addFour);
 *      uncurriedAddFour(1, 2, 3, 4); //=> 10
 */
var uncurryN = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function uncurryN(depth, fn) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(depth, function () {
    var currentDepth = 1;
    var value = fn;
    var idx = 0;
    var endIdx;
    while (currentDepth <= depth && typeof value === 'function') {
      endIdx = currentDepth === depth ? arguments.length : idx + value.length;
      value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
      currentDepth += 1;
      idx = endIdx;
    }
    return value;
  });
});
/* harmony default export */ __webpack_exports__["default"] = (uncurryN);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unfold.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unfold.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Builds a list from a seed value. Accepts an iterator function, which returns
 * either false to stop iteration or an array of length 2 containing the value
 * to add to the resulting list and the seed to be used in the next call to the
 * iterator function.
 *
 * The iterator function receives one argument: *(seed)*.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig (a -> [b]) -> * -> [b]
 * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
 *        either false to quit iteration or an array of length two to proceed. The element
 *        at index 0 of this array will be added to the resulting array, and the element
 *        at index 1 will be passed to the next call to `fn`.
 * @param {*} seed The seed value.
 * @return {Array} The final list.
 * @example
 *
 *      var f = n => n > 50 ? false : [-n, n + 10];
 *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
 * @symb R.unfold(f, x) = [f(x)[0], f(f(x)[1])[0], f(f(f(x)[1])[1])[0], ...]
 */
var unfold = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function unfold(fn, seed) {
  var pair = fn(seed);
  var result = [];
  while (pair && pair.length) {
    result[result.length] = pair[0];
    pair = fn(pair[1]);
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (unfold);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/union.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/union.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compose */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/compose.js");
/* harmony import */ var _uniq__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./uniq */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniq.js");





/**
 * Combines two lists into a set (i.e. no duplicates) composed of the elements
 * of each list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} as The first list.
 * @param {Array} bs The second list.
 * @return {Array} The first and second lists concatenated, with
 *         duplicates removed.
 * @example
 *
 *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
 */
var union = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/Object(_compose__WEBPACK_IMPORTED_MODULE_2__["default"])(_uniq__WEBPACK_IMPORTED_MODULE_3__["default"], _internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (union);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unionWith.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unionWith.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_concat */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_concat.js");
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _uniqWith__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./uniqWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqWith.js");




/**
 * Combines two lists into a set (i.e. no duplicates) composed of the elements
 * of each list. Duplication is determined according to the value returned by
 * applying the supplied predicate to two list elements.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig ((a, a) -> Boolean) -> [*] -> [*] -> [*]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The first and second lists concatenated, with
 *         duplicates removed.
 * @see R.union
 * @example
 *
 *      var l1 = [{a: 1}, {a: 2}];
 *      var l2 = [{a: 1}, {a: 4}];
 *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
 */
var unionWith = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_1__["default"])(function unionWith(pred, list1, list2) {
  return Object(_uniqWith__WEBPACK_IMPORTED_MODULE_2__["default"])(pred, Object(_internal_concat__WEBPACK_IMPORTED_MODULE_0__["default"])(list1, list2));
});
/* harmony default export */ __webpack_exports__["default"] = (unionWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniq.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniq.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/identity.js");
/* harmony import */ var _uniqBy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uniqBy */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqBy.js");



/**
 * Returns a new list containing only one copy of each element in the original
 * list. [`R.equals`](#equals) is used to determine equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
 *      R.uniq([1, '1']);     //=> [1, '1']
 *      R.uniq([[42], [42]]); //=> [[42]]
 */
var uniq = /*#__PURE__*/Object(_uniqBy__WEBPACK_IMPORTED_MODULE_1__["default"])(_identity__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (uniq);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqBy.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqBy.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_Set__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_Set */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_Set.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Returns a new list containing only one copy of each element in the original
 * list, based upon the value returned by applying the supplied function to
 * each list element. Prefers the first item if the supplied function produces
 * the same value on two items. [`R.equals`](#equals) is used for comparison.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> b) -> [a] -> [a]
 * @param {Function} fn A function used to produce a value to use during comparisons.
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
 */
var uniqBy = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function uniqBy(fn, list) {
  var set = new _internal_Set__WEBPACK_IMPORTED_MODULE_0__["default"]();
  var result = [];
  var idx = 0;
  var appliedItem, item;

  while (idx < list.length) {
    item = list[idx];
    appliedItem = fn(item);
    if (set.add(appliedItem)) {
      result.push(item);
    }
    idx += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (uniqBy);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqWith.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/uniqWith.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_containsWith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_containsWith */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_containsWith.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");



/**
 * Returns a new list containing only one copy of each element in the original
 * list, based upon the value returned by applying the supplied predicate to
 * two list elements. Prefers the first item if two items compare equal based
 * on the predicate.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category List
 * @sig ((a, a) -> Boolean) -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      var strEq = R.eqBy(String);
 *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
 *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
 *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
 *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
 */
var uniqWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function uniqWith(pred, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  var item;
  while (idx < len) {
    item = list[idx];
    if (!Object(_internal_containsWith__WEBPACK_IMPORTED_MODULE_0__["default"])(pred, item, result)) {
      result[result.length] = item;
    }
    idx += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (uniqWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unless.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unless.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Tests the final argument by passing it to the given predicate function. If
 * the predicate is not satisfied, the function will return the result of
 * calling the `whenFalseFn` function with the same argument. If the predicate
 * is satisfied, the argument is returned as is.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Logic
 * @sig (a -> Boolean) -> (a -> a) -> a -> a
 * @param {Function} pred        A predicate function
 * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
 *                               to a falsy value.
 * @param {*}        x           An object to test with the `pred` function and
 *                               pass to `whenFalseFn` if necessary.
 * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
 * @see R.ifElse, R.when
 * @example
 *
 *      let safeInc = R.unless(R.isNil, R.inc);
 *      safeInc(null); //=> null
 *      safeInc(1); //=> 2
 */
var unless = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function unless(pred, whenFalseFn, x) {
  return pred(x) ? x : whenFalseFn(x);
});
/* harmony default export */ __webpack_exports__["default"] = (unless);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unnest.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/unnest.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_identity */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_identity.js");
/* harmony import */ var _chain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chain */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/chain.js");



/**
 * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
 * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig Chain c => c (c a) -> c a
 * @param {*} list
 * @return {*}
 * @see R.flatten, R.chain
 * @example
 *
 *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
 *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
 */
var unnest = /*#__PURE__*/Object(_chain__WEBPACK_IMPORTED_MODULE_1__["default"])(_internal_identity__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (unnest);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/until.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/until.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Takes a predicate, a transformation function, and an initial value,
 * and returns a value of the same type as the initial value.
 * It does so by applying the transformation until the predicate is satisfied,
 * at which point it returns the satisfactory value.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Logic
 * @sig (a -> Boolean) -> (a -> a) -> a -> a
 * @param {Function} pred A predicate function
 * @param {Function} fn The iterator function
 * @param {*} init Initial value
 * @return {*} Final value that satisfies predicate
 * @example
 *
 *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
 */
var until = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function until(pred, fn, init) {
  var val = init;
  while (!pred(val)) {
    val = fn(val);
  }
  return val;
});
/* harmony default export */ __webpack_exports__["default"] = (until);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/update.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/update.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");
/* harmony import */ var _adjust__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adjust */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/adjust.js");
/* harmony import */ var _always__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./always */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/always.js");




/**
 * Returns a new copy of the array with the element at the provided index
 * replaced with the given value.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig Number -> a -> [a] -> [a]
 * @param {Number} idx The index to update.
 * @param {*} x The value to exist at the given index of the returned array.
 * @param {Array|Arguments} list The source array-like object to be updated.
 * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
 * @see R.adjust
 * @example
 *
 *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
 *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
 * @symb R.update(-1, a, [b, c]) = [b, a]
 * @symb R.update(0, a, [b, c]) = [a, c]
 * @symb R.update(1, a, [b, c]) = [b, a]
 */
var update = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function update(idx, x, list) {
  return Object(_adjust__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_always__WEBPACK_IMPORTED_MODULE_2__["default"])(x), idx, list);
});
/* harmony default export */ __webpack_exports__["default"] = (update);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/useWith.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/useWith.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _curryN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curryN */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/curryN.js");



/**
 * Accepts a function `fn` and a list of transformer functions and returns a
 * new curried function. When the new function is invoked, it calls the
 * function `fn` with parameters consisting of the result of calling each
 * supplied handler on successive arguments to the new function.
 *
 * If more arguments are passed to the returned function than transformer
 * functions, those arguments are passed directly to `fn` as additional
 * parameters. If you expect additional arguments that don't need to be
 * transformed, although you can ignore them, it's best to pass an identity
 * function so that the new function reports the correct arity.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((x1, x2, ...) -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
 * @param {Function} fn The function to wrap.
 * @param {Array} transformers A list of transformer functions
 * @return {Function} The wrapped function.
 * @see R.converge
 * @example
 *
 *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
 *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
 *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
 *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
 * @symb R.useWith(f, [g, h])(a, b) = f(g(a), h(b))
 */
var useWith = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function useWith(fn, transformers) {
  return Object(_curryN__WEBPACK_IMPORTED_MODULE_1__["default"])(transformers.length, function () {
    var args = [];
    var idx = 0;
    while (idx < transformers.length) {
      args.push(transformers[idx].call(this, arguments[idx]));
      idx += 1;
    }
    return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
  });
});
/* harmony default export */ __webpack_exports__["default"] = (useWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/values.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/values.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");
/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/keys.js");



/**
 * Returns a list of all the enumerable own properties of the supplied object.
 * Note that the order of the output array is not guaranteed across different
 * JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [v]
 * @param {Object} obj The object to extract values from
 * @return {Array} An array of the values of the object's own properties.
 * @see R.valuesIn, R.keys
 * @example
 *
 *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
 */
var values = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function values(obj) {
  var props = Object(_keys__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
  var len = props.length;
  var vals = [];
  var idx = 0;
  while (idx < len) {
    vals[idx] = obj[props[idx]];
    idx += 1;
  }
  return vals;
});
/* harmony default export */ __webpack_exports__["default"] = (values);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/valuesIn.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/valuesIn.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry1 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry1.js");


/**
 * Returns a list of all the properties, including prototype properties, of the
 * supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @sig {k: v} -> [v]
 * @param {Object} obj The object to extract values from
 * @return {Array} An array of the values of the object's own and prototype properties.
 * @see R.values, R.keysIn
 * @example
 *
 *      var F = function() { this.x = 'X'; };
 *      F.prototype.y = 'Y';
 *      var f = new F();
 *      R.valuesIn(f); //=> ['X', 'Y']
 */
var valuesIn = /*#__PURE__*/Object(_internal_curry1__WEBPACK_IMPORTED_MODULE_0__["default"])(function valuesIn(obj) {
  var prop;
  var vs = [];
  for (prop in obj) {
    vs[vs.length] = obj[prop];
  }
  return vs;
});
/* harmony default export */ __webpack_exports__["default"] = (valuesIn);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/view.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/view.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


// `Const` is a functor that effectively ignores the function given to `map`.
var Const = function (x) {
  return { value: x, 'fantasy-land/map': function () {
      return this;
    } };
};

/**
 * Returns a "view" of the given data structure, determined by the given lens.
 * The lens's focus determines which portion of the data structure is visible.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Lens s a -> s -> a
 * @param {Lens} lens
 * @param {*} x
 * @return {*}
 * @see R.prop, R.lensIndex, R.lensProp
 * @example
 *
 *      var xLens = R.lensProp('x');
 *
 *      R.view(xLens, {x: 1, y: 2});  //=> 1
 *      R.view(xLens, {x: 4, y: 2});  //=> 4
 */
var view = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function view(lens, x) {
  // Using `Const` effectively ignores the setter function of the `lens`,
  // leaving the value returned by the getter function unmodified.
  return lens(Const)(x).value;
});
/* harmony default export */ __webpack_exports__["default"] = (view);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/when.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/when.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Tests the final argument by passing it to the given predicate function. If
 * the predicate is satisfied, the function will return the result of calling
 * the `whenTrueFn` function with the same argument. If the predicate is not
 * satisfied, the argument is returned as is.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Logic
 * @sig (a -> Boolean) -> (a -> a) -> a -> a
 * @param {Function} pred       A predicate function
 * @param {Function} whenTrueFn A function to invoke when the `condition`
 *                              evaluates to a truthy value.
 * @param {*}        x          An object to test with the `pred` function and
 *                              pass to `whenTrueFn` if necessary.
 * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
 * @see R.ifElse, R.unless
 * @example
 *
 *      // truncate :: String -> String
 *      var truncate = R.when(
 *        R.propSatisfies(R.gt(R.__, 10), 'length'),
 *        R.pipe(R.take(10), R.append('â¦'), R.join(''))
 *      );
 *      truncate('12345');         //=> '12345'
 *      truncate('0123456789ABC'); //=> '0123456789â¦'
 */
var when = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function when(pred, whenTrueFn, x) {
  return pred(x) ? whenTrueFn(x) : x;
});
/* harmony default export */ __webpack_exports__["default"] = (when);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/where.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/where.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _internal_has__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_has */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_has.js");



/**
 * Takes a spec object and a test object; returns true if the test satisfies
 * the spec. Each of the spec's own properties must be a predicate function.
 * Each predicate is applied to the value of the corresponding property of the
 * test object. `where` returns true if all the predicates return true, false
 * otherwise.
 *
 * `where` is well suited to declaratively expressing constraints for other
 * functions such as [`filter`](#filter) and [`find`](#find).
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category Object
 * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
 * @param {Object} spec
 * @param {Object} testObj
 * @return {Boolean}
 * @see R.propSatisfies, R.whereEq
 * @example
 *
 *      // pred :: Object -> Boolean
 *      var pred = R.where({
 *        a: R.equals('foo'),
 *        b: R.complement(R.equals('bar')),
 *        x: R.gt(R.__, 10),
 *        y: R.lt(R.__, 20)
 *      });
 *
 *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
 *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
 *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
 *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
 *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
 */
var where = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function where(spec, testObj) {
  for (var prop in spec) {
    if (Object(_internal_has__WEBPACK_IMPORTED_MODULE_1__["default"])(prop, spec) && !spec[prop](testObj[prop])) {
      return false;
    }
  }
  return true;
});
/* harmony default export */ __webpack_exports__["default"] = (where);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/whereEq.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/whereEq.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _equals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equals */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/equals.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/map.js");
/* harmony import */ var _where__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./where */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/where.js");





/**
 * Takes a spec object and a test object; returns true if the test satisfies
 * the spec, false otherwise. An object satisfies the spec if, for each of the
 * spec's own properties, accessing that property of the object gives the same
 * value (in [`R.equals`](#equals) terms) as accessing that property of the
 * spec.
 *
 * `whereEq` is a specialization of [`where`](#where).
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Object
 * @sig {String: *} -> {String: *} -> Boolean
 * @param {Object} spec
 * @param {Object} testObj
 * @return {Boolean}
 * @see R.propEq, R.where
 * @example
 *
 *      // pred :: Object -> Boolean
 *      var pred = R.whereEq({a: 1, b: 2});
 *
 *      pred({a: 1});              //=> false
 *      pred({a: 1, b: 2});        //=> true
 *      pred({a: 1, b: 2, c: 3});  //=> true
 *      pred({a: 1, b: 1});        //=> false
 */
var whereEq = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function whereEq(spec, testObj) {
  return Object(_where__WEBPACK_IMPORTED_MODULE_3__["default"])(Object(_map__WEBPACK_IMPORTED_MODULE_2__["default"])(_equals__WEBPACK_IMPORTED_MODULE_1__["default"], spec), testObj);
});
/* harmony default export */ __webpack_exports__["default"] = (whereEq);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/without.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/without.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_contains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_contains */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_contains.js");
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");
/* harmony import */ var _flip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flip */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/flip.js");
/* harmony import */ var _reject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reject */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/reject.js");





/**
 * Returns a new list without values in the first argument.
 * [`R.equals`](#equals) is used to determine equality.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig [a] -> [a] -> [a]
 * @param {Array} list1 The values to be removed from `list2`.
 * @param {Array} list2 The array to remove values from.
 * @return {Array} The new array without values in `list1`.
 * @see R.transduce, R.difference
 * @example
 *
 *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
 */
var without = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_1__["default"])(function (xs, list) {
  return Object(_reject__WEBPACK_IMPORTED_MODULE_3__["default"])(Object(_flip__WEBPACK_IMPORTED_MODULE_2__["default"])(_internal_contains__WEBPACK_IMPORTED_MODULE_0__["default"])(xs), list);
});
/* harmony default export */ __webpack_exports__["default"] = (without);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/xprod.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/xprod.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Creates a new list out of the two supplied by creating each possible pair
 * from the lists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [b] -> [[a,b]]
 * @param {Array} as The first list.
 * @param {Array} bs The second list.
 * @return {Array} The list made by combining each possible pair from
 *         `as` and `bs` into pairs (`[a, b]`).
 * @example
 *
 *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
 * @symb R.xprod([a, b], [c, d]) = [[a, c], [a, d], [b, c], [b, d]]
 */
var xprod = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function xprod(a, b) {
  // = xprodWith(prepend); (takes about 3 times as long...)
  var idx = 0;
  var ilen = a.length;
  var j;
  var jlen = b.length;
  var result = [];
  while (idx < ilen) {
    j = 0;
    while (j < jlen) {
      result[result.length] = [a[idx], b[j]];
      j += 1;
    }
    idx += 1;
  }
  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (xprod);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zip.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zip.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Creates a new list out of the two supplied by pairing up equally-positioned
 * items from both lists. The returned list is truncated to the length of the
 * shorter of the two input lists.
 * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [b] -> [[a,b]]
 * @param {Array} list1 The first array to consider.
 * @param {Array} list2 The second array to consider.
 * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
 * @example
 *
 *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
 * @symb R.zip([a, b, c], [d, e, f]) = [[a, d], [b, e], [c, f]]
 */
var zip = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function zip(a, b) {
  var rv = [];
  var idx = 0;
  var len = Math.min(a.length, b.length);
  while (idx < len) {
    rv[idx] = [a[idx], b[idx]];
    idx += 1;
  }
  return rv;
});
/* harmony default export */ __webpack_exports__["default"] = (zip);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zipObj.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zipObj.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry2 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry2.js");


/**
 * Creates a new object out of a list of keys and a list of values.
 * Key/value pairing is truncated to the length of the shorter of the two lists.
 * Note: `zipObj` is equivalent to `pipe(zip, fromPairs)`.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig [String] -> [*] -> {String: *}
 * @param {Array} keys The array that will be properties on the output object.
 * @param {Array} values The list of values on the output object.
 * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
 * @example
 *
 *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
 */
var zipObj = /*#__PURE__*/Object(_internal_curry2__WEBPACK_IMPORTED_MODULE_0__["default"])(function zipObj(keys, values) {
  var idx = 0;
  var len = Math.min(keys.length, values.length);
  var out = {};
  while (idx < len) {
    out[keys[idx]] = values[idx];
    idx += 1;
  }
  return out;
});
/* harmony default export */ __webpack_exports__["default"] = (zipObj);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zipWith.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/zipWith.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_curry3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/_curry3 */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/internal/_curry3.js");


/**
 * Creates a new list out of the two supplied by applying the function to each
 * equally-positioned pair in the lists. The returned list is truncated to the
 * length of the shorter of the two input lists.
 *
 * @function
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> c) -> [a] -> [b] -> [c]
 * @param {Function} fn The function used to combine the two elements into one value.
 * @param {Array} list1 The first array to consider.
 * @param {Array} list2 The second array to consider.
 * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
 *         using `fn`.
 * @example
 *
 *      var f = (x, y) => {
 *        // ...
 *      };
 *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
 *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
 * @symb R.zipWith(fn, [a, b, c], [d, e, f]) = [fn(a, d), fn(b, e), fn(c, f)]
 */
var zipWith = /*#__PURE__*/Object(_internal_curry3__WEBPACK_IMPORTED_MODULE_0__["default"])(function zipWith(fn, a, b) {
  var rv = [];
  var idx = 0;
  var len = Math.min(a.length, b.length);
  while (idx < len) {
    rv[idx] = fn(a[idx], b[idx]);
    idx += 1;
  }
  return rv;
});
/* harmony default export */ __webpack_exports__["default"] = (zipWith);

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/index.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./lib/ */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/index.js");


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/entities.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/entities.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid entities
//
// Generate with ./support/entities.js script
//


/*eslint quotes:0*/
module.exports = {
  "Aacute":"\u00C1",
  "aacute":"\u00E1",
  "Abreve":"\u0102",
  "abreve":"\u0103",
  "ac":"\u223E",
  "acd":"\u223F",
  "acE":"\u223E\u0333",
  "Acirc":"\u00C2",
  "acirc":"\u00E2",
  "acute":"\u00B4",
  "Acy":"\u0410",
  "acy":"\u0430",
  "AElig":"\u00C6",
  "aelig":"\u00E6",
  "af":"\u2061",
  "Afr":"\uD835\uDD04",
  "afr":"\uD835\uDD1E",
  "Agrave":"\u00C0",
  "agrave":"\u00E0",
  "alefsym":"\u2135",
  "aleph":"\u2135",
  "Alpha":"\u0391",
  "alpha":"\u03B1",
  "Amacr":"\u0100",
  "amacr":"\u0101",
  "amalg":"\u2A3F",
  "AMP":"\u0026",
  "amp":"\u0026",
  "And":"\u2A53",
  "and":"\u2227",
  "andand":"\u2A55",
  "andd":"\u2A5C",
  "andslope":"\u2A58",
  "andv":"\u2A5A",
  "ang":"\u2220",
  "ange":"\u29A4",
  "angle":"\u2220",
  "angmsd":"\u2221",
  "angmsdaa":"\u29A8",
  "angmsdab":"\u29A9",
  "angmsdac":"\u29AA",
  "angmsdad":"\u29AB",
  "angmsdae":"\u29AC",
  "angmsdaf":"\u29AD",
  "angmsdag":"\u29AE",
  "angmsdah":"\u29AF",
  "angrt":"\u221F",
  "angrtvb":"\u22BE",
  "angrtvbd":"\u299D",
  "angsph":"\u2222",
  "angst":"\u00C5",
  "angzarr":"\u237C",
  "Aogon":"\u0104",
  "aogon":"\u0105",
  "Aopf":"\uD835\uDD38",
  "aopf":"\uD835\uDD52",
  "ap":"\u2248",
  "apacir":"\u2A6F",
  "apE":"\u2A70",
  "ape":"\u224A",
  "apid":"\u224B",
  "apos":"\u0027",
  "ApplyFunction":"\u2061",
  "approx":"\u2248",
  "approxeq":"\u224A",
  "Aring":"\u00C5",
  "aring":"\u00E5",
  "Ascr":"\uD835\uDC9C",
  "ascr":"\uD835\uDCB6",
  "Assign":"\u2254",
  "ast":"\u002A",
  "asymp":"\u2248",
  "asympeq":"\u224D",
  "Atilde":"\u00C3",
  "atilde":"\u00E3",
  "Auml":"\u00C4",
  "auml":"\u00E4",
  "awconint":"\u2233",
  "awint":"\u2A11",
  "backcong":"\u224C",
  "backepsilon":"\u03F6",
  "backprime":"\u2035",
  "backsim":"\u223D",
  "backsimeq":"\u22CD",
  "Backslash":"\u2216",
  "Barv":"\u2AE7",
  "barvee":"\u22BD",
  "Barwed":"\u2306",
  "barwed":"\u2305",
  "barwedge":"\u2305",
  "bbrk":"\u23B5",
  "bbrktbrk":"\u23B6",
  "bcong":"\u224C",
  "Bcy":"\u0411",
  "bcy":"\u0431",
  "bdquo":"\u201E",
  "becaus":"\u2235",
  "Because":"\u2235",
  "because":"\u2235",
  "bemptyv":"\u29B0",
  "bepsi":"\u03F6",
  "bernou":"\u212C",
  "Bernoullis":"\u212C",
  "Beta":"\u0392",
  "beta":"\u03B2",
  "beth":"\u2136",
  "between":"\u226C",
  "Bfr":"\uD835\uDD05",
  "bfr":"\uD835\uDD1F",
  "bigcap":"\u22C2",
  "bigcirc":"\u25EF",
  "bigcup":"\u22C3",
  "bigodot":"\u2A00",
  "bigoplus":"\u2A01",
  "bigotimes":"\u2A02",
  "bigsqcup":"\u2A06",
  "bigstar":"\u2605",
  "bigtriangledown":"\u25BD",
  "bigtriangleup":"\u25B3",
  "biguplus":"\u2A04",
  "bigvee":"\u22C1",
  "bigwedge":"\u22C0",
  "bkarow":"\u290D",
  "blacklozenge":"\u29EB",
  "blacksquare":"\u25AA",
  "blacktriangle":"\u25B4",
  "blacktriangledown":"\u25BE",
  "blacktriangleleft":"\u25C2",
  "blacktriangleright":"\u25B8",
  "blank":"\u2423",
  "blk12":"\u2592",
  "blk14":"\u2591",
  "blk34":"\u2593",
  "block":"\u2588",
  "bne":"\u003D\u20E5",
  "bnequiv":"\u2261\u20E5",
  "bNot":"\u2AED",
  "bnot":"\u2310",
  "Bopf":"\uD835\uDD39",
  "bopf":"\uD835\uDD53",
  "bot":"\u22A5",
  "bottom":"\u22A5",
  "bowtie":"\u22C8",
  "boxbox":"\u29C9",
  "boxDL":"\u2557",
  "boxDl":"\u2556",
  "boxdL":"\u2555",
  "boxdl":"\u2510",
  "boxDR":"\u2554",
  "boxDr":"\u2553",
  "boxdR":"\u2552",
  "boxdr":"\u250C",
  "boxH":"\u2550",
  "boxh":"\u2500",
  "boxHD":"\u2566",
  "boxHd":"\u2564",
  "boxhD":"\u2565",
  "boxhd":"\u252C",
  "boxHU":"\u2569",
  "boxHu":"\u2567",
  "boxhU":"\u2568",
  "boxhu":"\u2534",
  "boxminus":"\u229F",
  "boxplus":"\u229E",
  "boxtimes":"\u22A0",
  "boxUL":"\u255D",
  "boxUl":"\u255C",
  "boxuL":"\u255B",
  "boxul":"\u2518",
  "boxUR":"\u255A",
  "boxUr":"\u2559",
  "boxuR":"\u2558",
  "boxur":"\u2514",
  "boxV":"\u2551",
  "boxv":"\u2502",
  "boxVH":"\u256C",
  "boxVh":"\u256B",
  "boxvH":"\u256A",
  "boxvh":"\u253C",
  "boxVL":"\u2563",
  "boxVl":"\u2562",
  "boxvL":"\u2561",
  "boxvl":"\u2524",
  "boxVR":"\u2560",
  "boxVr":"\u255F",
  "boxvR":"\u255E",
  "boxvr":"\u251C",
  "bprime":"\u2035",
  "Breve":"\u02D8",
  "breve":"\u02D8",
  "brvbar":"\u00A6",
  "Bscr":"\u212C",
  "bscr":"\uD835\uDCB7",
  "bsemi":"\u204F",
  "bsim":"\u223D",
  "bsime":"\u22CD",
  "bsol":"\u005C",
  "bsolb":"\u29C5",
  "bsolhsub":"\u27C8",
  "bull":"\u2022",
  "bullet":"\u2022",
  "bump":"\u224E",
  "bumpE":"\u2AAE",
  "bumpe":"\u224F",
  "Bumpeq":"\u224E",
  "bumpeq":"\u224F",
  "Cacute":"\u0106",
  "cacute":"\u0107",
  "Cap":"\u22D2",
  "cap":"\u2229",
  "capand":"\u2A44",
  "capbrcup":"\u2A49",
  "capcap":"\u2A4B",
  "capcup":"\u2A47",
  "capdot":"\u2A40",
  "CapitalDifferentialD":"\u2145",
  "caps":"\u2229\uFE00",
  "caret":"\u2041",
  "caron":"\u02C7",
  "Cayleys":"\u212D",
  "ccaps":"\u2A4D",
  "Ccaron":"\u010C",
  "ccaron":"\u010D",
  "Ccedil":"\u00C7",
  "ccedil":"\u00E7",
  "Ccirc":"\u0108",
  "ccirc":"\u0109",
  "Cconint":"\u2230",
  "ccups":"\u2A4C",
  "ccupssm":"\u2A50",
  "Cdot":"\u010A",
  "cdot":"\u010B",
  "cedil":"\u00B8",
  "Cedilla":"\u00B8",
  "cemptyv":"\u29B2",
  "cent":"\u00A2",
  "CenterDot":"\u00B7",
  "centerdot":"\u00B7",
  "Cfr":"\u212D",
  "cfr":"\uD835\uDD20",
  "CHcy":"\u0427",
  "chcy":"\u0447",
  "check":"\u2713",
  "checkmark":"\u2713",
  "Chi":"\u03A7",
  "chi":"\u03C7",
  "cir":"\u25CB",
  "circ":"\u02C6",
  "circeq":"\u2257",
  "circlearrowleft":"\u21BA",
  "circlearrowright":"\u21BB",
  "circledast":"\u229B",
  "circledcirc":"\u229A",
  "circleddash":"\u229D",
  "CircleDot":"\u2299",
  "circledR":"\u00AE",
  "circledS":"\u24C8",
  "CircleMinus":"\u2296",
  "CirclePlus":"\u2295",
  "CircleTimes":"\u2297",
  "cirE":"\u29C3",
  "cire":"\u2257",
  "cirfnint":"\u2A10",
  "cirmid":"\u2AEF",
  "cirscir":"\u29C2",
  "ClockwiseContourIntegral":"\u2232",
  "CloseCurlyDoubleQuote":"\u201D",
  "CloseCurlyQuote":"\u2019",
  "clubs":"\u2663",
  "clubsuit":"\u2663",
  "Colon":"\u2237",
  "colon":"\u003A",
  "Colone":"\u2A74",
  "colone":"\u2254",
  "coloneq":"\u2254",
  "comma":"\u002C",
  "commat":"\u0040",
  "comp":"\u2201",
  "compfn":"\u2218",
  "complement":"\u2201",
  "complexes":"\u2102",
  "cong":"\u2245",
  "congdot":"\u2A6D",
  "Congruent":"\u2261",
  "Conint":"\u222F",
  "conint":"\u222E",
  "ContourIntegral":"\u222E",
  "Copf":"\u2102",
  "copf":"\uD835\uDD54",
  "coprod":"\u2210",
  "Coproduct":"\u2210",
  "COPY":"\u00A9",
  "copy":"\u00A9",
  "copysr":"\u2117",
  "CounterClockwiseContourIntegral":"\u2233",
  "crarr":"\u21B5",
  "Cross":"\u2A2F",
  "cross":"\u2717",
  "Cscr":"\uD835\uDC9E",
  "cscr":"\uD835\uDCB8",
  "csub":"\u2ACF",
  "csube":"\u2AD1",
  "csup":"\u2AD0",
  "csupe":"\u2AD2",
  "ctdot":"\u22EF",
  "cudarrl":"\u2938",
  "cudarrr":"\u2935",
  "cuepr":"\u22DE",
  "cuesc":"\u22DF",
  "cularr":"\u21B6",
  "cularrp":"\u293D",
  "Cup":"\u22D3",
  "cup":"\u222A",
  "cupbrcap":"\u2A48",
  "CupCap":"\u224D",
  "cupcap":"\u2A46",
  "cupcup":"\u2A4A",
  "cupdot":"\u228D",
  "cupor":"\u2A45",
  "cups":"\u222A\uFE00",
  "curarr":"\u21B7",
  "curarrm":"\u293C",
  "curlyeqprec":"\u22DE",
  "curlyeqsucc":"\u22DF",
  "curlyvee":"\u22CE",
  "curlywedge":"\u22CF",
  "curren":"\u00A4",
  "curvearrowleft":"\u21B6",
  "curvearrowright":"\u21B7",
  "cuvee":"\u22CE",
  "cuwed":"\u22CF",
  "cwconint":"\u2232",
  "cwint":"\u2231",
  "cylcty":"\u232D",
  "Dagger":"\u2021",
  "dagger":"\u2020",
  "daleth":"\u2138",
  "Darr":"\u21A1",
  "dArr":"\u21D3",
  "darr":"\u2193",
  "dash":"\u2010",
  "Dashv":"\u2AE4",
  "dashv":"\u22A3",
  "dbkarow":"\u290F",
  "dblac":"\u02DD",
  "Dcaron":"\u010E",
  "dcaron":"\u010F",
  "Dcy":"\u0414",
  "dcy":"\u0434",
  "DD":"\u2145",
  "dd":"\u2146",
  "ddagger":"\u2021",
  "ddarr":"\u21CA",
  "DDotrahd":"\u2911",
  "ddotseq":"\u2A77",
  "deg":"\u00B0",
  "Del":"\u2207",
  "Delta":"\u0394",
  "delta":"\u03B4",
  "demptyv":"\u29B1",
  "dfisht":"\u297F",
  "Dfr":"\uD835\uDD07",
  "dfr":"\uD835\uDD21",
  "dHar":"\u2965",
  "dharl":"\u21C3",
  "dharr":"\u21C2",
  "DiacriticalAcute":"\u00B4",
  "DiacriticalDot":"\u02D9",
  "DiacriticalDoubleAcute":"\u02DD",
  "DiacriticalGrave":"\u0060",
  "DiacriticalTilde":"\u02DC",
  "diam":"\u22C4",
  "Diamond":"\u22C4",
  "diamond":"\u22C4",
  "diamondsuit":"\u2666",
  "diams":"\u2666",
  "die":"\u00A8",
  "DifferentialD":"\u2146",
  "digamma":"\u03DD",
  "disin":"\u22F2",
  "div":"\u00F7",
  "divide":"\u00F7",
  "divideontimes":"\u22C7",
  "divonx":"\u22C7",
  "DJcy":"\u0402",
  "djcy":"\u0452",
  "dlcorn":"\u231E",
  "dlcrop":"\u230D",
  "dollar":"\u0024",
  "Dopf":"\uD835\uDD3B",
  "dopf":"\uD835\uDD55",
  "Dot":"\u00A8",
  "dot":"\u02D9",
  "DotDot":"\u20DC",
  "doteq":"\u2250",
  "doteqdot":"\u2251",
  "DotEqual":"\u2250",
  "dotminus":"\u2238",
  "dotplus":"\u2214",
  "dotsquare":"\u22A1",
  "doublebarwedge":"\u2306",
  "DoubleContourIntegral":"\u222F",
  "DoubleDot":"\u00A8",
  "DoubleDownArrow":"\u21D3",
  "DoubleLeftArrow":"\u21D0",
  "DoubleLeftRightArrow":"\u21D4",
  "DoubleLeftTee":"\u2AE4",
  "DoubleLongLeftArrow":"\u27F8",
  "DoubleLongLeftRightArrow":"\u27FA",
  "DoubleLongRightArrow":"\u27F9",
  "DoubleRightArrow":"\u21D2",
  "DoubleRightTee":"\u22A8",
  "DoubleUpArrow":"\u21D1",
  "DoubleUpDownArrow":"\u21D5",
  "DoubleVerticalBar":"\u2225",
  "DownArrow":"\u2193",
  "Downarrow":"\u21D3",
  "downarrow":"\u2193",
  "DownArrowBar":"\u2913",
  "DownArrowUpArrow":"\u21F5",
  "DownBreve":"\u0311",
  "downdownarrows":"\u21CA",
  "downharpoonleft":"\u21C3",
  "downharpoonright":"\u21C2",
  "DownLeftRightVector":"\u2950",
  "DownLeftTeeVector":"\u295E",
  "DownLeftVector":"\u21BD",
  "DownLeftVectorBar":"\u2956",
  "DownRightTeeVector":"\u295F",
  "DownRightVector":"\u21C1",
  "DownRightVectorBar":"\u2957",
  "DownTee":"\u22A4",
  "DownTeeArrow":"\u21A7",
  "drbkarow":"\u2910",
  "drcorn":"\u231F",
  "drcrop":"\u230C",
  "Dscr":"\uD835\uDC9F",
  "dscr":"\uD835\uDCB9",
  "DScy":"\u0405",
  "dscy":"\u0455",
  "dsol":"\u29F6",
  "Dstrok":"\u0110",
  "dstrok":"\u0111",
  "dtdot":"\u22F1",
  "dtri":"\u25BF",
  "dtrif":"\u25BE",
  "duarr":"\u21F5",
  "duhar":"\u296F",
  "dwangle":"\u29A6",
  "DZcy":"\u040F",
  "dzcy":"\u045F",
  "dzigrarr":"\u27FF",
  "Eacute":"\u00C9",
  "eacute":"\u00E9",
  "easter":"\u2A6E",
  "Ecaron":"\u011A",
  "ecaron":"\u011B",
  "ecir":"\u2256",
  "Ecirc":"\u00CA",
  "ecirc":"\u00EA",
  "ecolon":"\u2255",
  "Ecy":"\u042D",
  "ecy":"\u044D",
  "eDDot":"\u2A77",
  "Edot":"\u0116",
  "eDot":"\u2251",
  "edot":"\u0117",
  "ee":"\u2147",
  "efDot":"\u2252",
  "Efr":"\uD835\uDD08",
  "efr":"\uD835\uDD22",
  "eg":"\u2A9A",
  "Egrave":"\u00C8",
  "egrave":"\u00E8",
  "egs":"\u2A96",
  "egsdot":"\u2A98",
  "el":"\u2A99",
  "Element":"\u2208",
  "elinters":"\u23E7",
  "ell":"\u2113",
  "els":"\u2A95",
  "elsdot":"\u2A97",
  "Emacr":"\u0112",
  "emacr":"\u0113",
  "empty":"\u2205",
  "emptyset":"\u2205",
  "EmptySmallSquare":"\u25FB",
  "emptyv":"\u2205",
  "EmptyVerySmallSquare":"\u25AB",
  "emsp":"\u2003",
  "emsp13":"\u2004",
  "emsp14":"\u2005",
  "ENG":"\u014A",
  "eng":"\u014B",
  "ensp":"\u2002",
  "Eogon":"\u0118",
  "eogon":"\u0119",
  "Eopf":"\uD835\uDD3C",
  "eopf":"\uD835\uDD56",
  "epar":"\u22D5",
  "eparsl":"\u29E3",
  "eplus":"\u2A71",
  "epsi":"\u03B5",
  "Epsilon":"\u0395",
  "epsilon":"\u03B5",
  "epsiv":"\u03F5",
  "eqcirc":"\u2256",
  "eqcolon":"\u2255",
  "eqsim":"\u2242",
  "eqslantgtr":"\u2A96",
  "eqslantless":"\u2A95",
  "Equal":"\u2A75",
  "equals":"\u003D",
  "EqualTilde":"\u2242",
  "equest":"\u225F",
  "Equilibrium":"\u21CC",
  "equiv":"\u2261",
  "equivDD":"\u2A78",
  "eqvparsl":"\u29E5",
  "erarr":"\u2971",
  "erDot":"\u2253",
  "Escr":"\u2130",
  "escr":"\u212F",
  "esdot":"\u2250",
  "Esim":"\u2A73",
  "esim":"\u2242",
  "Eta":"\u0397",
  "eta":"\u03B7",
  "ETH":"\u00D0",
  "eth":"\u00F0",
  "Euml":"\u00CB",
  "euml":"\u00EB",
  "euro":"\u20AC",
  "excl":"\u0021",
  "exist":"\u2203",
  "Exists":"\u2203",
  "expectation":"\u2130",
  "ExponentialE":"\u2147",
  "exponentiale":"\u2147",
  "fallingdotseq":"\u2252",
  "Fcy":"\u0424",
  "fcy":"\u0444",
  "female":"\u2640",
  "ffilig":"\uFB03",
  "fflig":"\uFB00",
  "ffllig":"\uFB04",
  "Ffr":"\uD835\uDD09",
  "ffr":"\uD835\uDD23",
  "filig":"\uFB01",
  "FilledSmallSquare":"\u25FC",
  "FilledVerySmallSquare":"\u25AA",
  "fjlig":"\u0066\u006A",
  "flat":"\u266D",
  "fllig":"\uFB02",
  "fltns":"\u25B1",
  "fnof":"\u0192",
  "Fopf":"\uD835\uDD3D",
  "fopf":"\uD835\uDD57",
  "ForAll":"\u2200",
  "forall":"\u2200",
  "fork":"\u22D4",
  "forkv":"\u2AD9",
  "Fouriertrf":"\u2131",
  "fpartint":"\u2A0D",
  "frac12":"\u00BD",
  "frac13":"\u2153",
  "frac14":"\u00BC",
  "frac15":"\u2155",
  "frac16":"\u2159",
  "frac18":"\u215B",
  "frac23":"\u2154",
  "frac25":"\u2156",
  "frac34":"\u00BE",
  "frac35":"\u2157",
  "frac38":"\u215C",
  "frac45":"\u2158",
  "frac56":"\u215A",
  "frac58":"\u215D",
  "frac78":"\u215E",
  "frasl":"\u2044",
  "frown":"\u2322",
  "Fscr":"\u2131",
  "fscr":"\uD835\uDCBB",
  "gacute":"\u01F5",
  "Gamma":"\u0393",
  "gamma":"\u03B3",
  "Gammad":"\u03DC",
  "gammad":"\u03DD",
  "gap":"\u2A86",
  "Gbreve":"\u011E",
  "gbreve":"\u011F",
  "Gcedil":"\u0122",
  "Gcirc":"\u011C",
  "gcirc":"\u011D",
  "Gcy":"\u0413",
  "gcy":"\u0433",
  "Gdot":"\u0120",
  "gdot":"\u0121",
  "gE":"\u2267",
  "ge":"\u2265",
  "gEl":"\u2A8C",
  "gel":"\u22DB",
  "geq":"\u2265",
  "geqq":"\u2267",
  "geqslant":"\u2A7E",
  "ges":"\u2A7E",
  "gescc":"\u2AA9",
  "gesdot":"\u2A80",
  "gesdoto":"\u2A82",
  "gesdotol":"\u2A84",
  "gesl":"\u22DB\uFE00",
  "gesles":"\u2A94",
  "Gfr":"\uD835\uDD0A",
  "gfr":"\uD835\uDD24",
  "Gg":"\u22D9",
  "gg":"\u226B",
  "ggg":"\u22D9",
  "gimel":"\u2137",
  "GJcy":"\u0403",
  "gjcy":"\u0453",
  "gl":"\u2277",
  "gla":"\u2AA5",
  "glE":"\u2A92",
  "glj":"\u2AA4",
  "gnap":"\u2A8A",
  "gnapprox":"\u2A8A",
  "gnE":"\u2269",
  "gne":"\u2A88",
  "gneq":"\u2A88",
  "gneqq":"\u2269",
  "gnsim":"\u22E7",
  "Gopf":"\uD835\uDD3E",
  "gopf":"\uD835\uDD58",
  "grave":"\u0060",
  "GreaterEqual":"\u2265",
  "GreaterEqualLess":"\u22DB",
  "GreaterFullEqual":"\u2267",
  "GreaterGreater":"\u2AA2",
  "GreaterLess":"\u2277",
  "GreaterSlantEqual":"\u2A7E",
  "GreaterTilde":"\u2273",
  "Gscr":"\uD835\uDCA2",
  "gscr":"\u210A",
  "gsim":"\u2273",
  "gsime":"\u2A8E",
  "gsiml":"\u2A90",
  "GT":"\u003E",
  "Gt":"\u226B",
  "gt":"\u003E",
  "gtcc":"\u2AA7",
  "gtcir":"\u2A7A",
  "gtdot":"\u22D7",
  "gtlPar":"\u2995",
  "gtquest":"\u2A7C",
  "gtrapprox":"\u2A86",
  "gtrarr":"\u2978",
  "gtrdot":"\u22D7",
  "gtreqless":"\u22DB",
  "gtreqqless":"\u2A8C",
  "gtrless":"\u2277",
  "gtrsim":"\u2273",
  "gvertneqq":"\u2269\uFE00",
  "gvnE":"\u2269\uFE00",
  "Hacek":"\u02C7",
  "hairsp":"\u200A",
  "half":"\u00BD",
  "hamilt":"\u210B",
  "HARDcy":"\u042A",
  "hardcy":"\u044A",
  "hArr":"\u21D4",
  "harr":"\u2194",
  "harrcir":"\u2948",
  "harrw":"\u21AD",
  "Hat":"\u005E",
  "hbar":"\u210F",
  "Hcirc":"\u0124",
  "hcirc":"\u0125",
  "hearts":"\u2665",
  "heartsuit":"\u2665",
  "hellip":"\u2026",
  "hercon":"\u22B9",
  "Hfr":"\u210C",
  "hfr":"\uD835\uDD25",
  "HilbertSpace":"\u210B",
  "hksearow":"\u2925",
  "hkswarow":"\u2926",
  "hoarr":"\u21FF",
  "homtht":"\u223B",
  "hookleftarrow":"\u21A9",
  "hookrightarrow":"\u21AA",
  "Hopf":"\u210D",
  "hopf":"\uD835\uDD59",
  "horbar":"\u2015",
  "HorizontalLine":"\u2500",
  "Hscr":"\u210B",
  "hscr":"\uD835\uDCBD",
  "hslash":"\u210F",
  "Hstrok":"\u0126",
  "hstrok":"\u0127",
  "HumpDownHump":"\u224E",
  "HumpEqual":"\u224F",
  "hybull":"\u2043",
  "hyphen":"\u2010",
  "Iacute":"\u00CD",
  "iacute":"\u00ED",
  "ic":"\u2063",
  "Icirc":"\u00CE",
  "icirc":"\u00EE",
  "Icy":"\u0418",
  "icy":"\u0438",
  "Idot":"\u0130",
  "IEcy":"\u0415",
  "iecy":"\u0435",
  "iexcl":"\u00A1",
  "iff":"\u21D4",
  "Ifr":"\u2111",
  "ifr":"\uD835\uDD26",
  "Igrave":"\u00CC",
  "igrave":"\u00EC",
  "ii":"\u2148",
  "iiiint":"\u2A0C",
  "iiint":"\u222D",
  "iinfin":"\u29DC",
  "iiota":"\u2129",
  "IJlig":"\u0132",
  "ijlig":"\u0133",
  "Im":"\u2111",
  "Imacr":"\u012A",
  "imacr":"\u012B",
  "image":"\u2111",
  "ImaginaryI":"\u2148",
  "imagline":"\u2110",
  "imagpart":"\u2111",
  "imath":"\u0131",
  "imof":"\u22B7",
  "imped":"\u01B5",
  "Implies":"\u21D2",
  "in":"\u2208",
  "incare":"\u2105",
  "infin":"\u221E",
  "infintie":"\u29DD",
  "inodot":"\u0131",
  "Int":"\u222C",
  "int":"\u222B",
  "intcal":"\u22BA",
  "integers":"\u2124",
  "Integral":"\u222B",
  "intercal":"\u22BA",
  "Intersection":"\u22C2",
  "intlarhk":"\u2A17",
  "intprod":"\u2A3C",
  "InvisibleComma":"\u2063",
  "InvisibleTimes":"\u2062",
  "IOcy":"\u0401",
  "iocy":"\u0451",
  "Iogon":"\u012E",
  "iogon":"\u012F",
  "Iopf":"\uD835\uDD40",
  "iopf":"\uD835\uDD5A",
  "Iota":"\u0399",
  "iota":"\u03B9",
  "iprod":"\u2A3C",
  "iquest":"\u00BF",
  "Iscr":"\u2110",
  "iscr":"\uD835\uDCBE",
  "isin":"\u2208",
  "isindot":"\u22F5",
  "isinE":"\u22F9",
  "isins":"\u22F4",
  "isinsv":"\u22F3",
  "isinv":"\u2208",
  "it":"\u2062",
  "Itilde":"\u0128",
  "itilde":"\u0129",
  "Iukcy":"\u0406",
  "iukcy":"\u0456",
  "Iuml":"\u00CF",
  "iuml":"\u00EF",
  "Jcirc":"\u0134",
  "jcirc":"\u0135",
  "Jcy":"\u0419",
  "jcy":"\u0439",
  "Jfr":"\uD835\uDD0D",
  "jfr":"\uD835\uDD27",
  "jmath":"\u0237",
  "Jopf":"\uD835\uDD41",
  "jopf":"\uD835\uDD5B",
  "Jscr":"\uD835\uDCA5",
  "jscr":"\uD835\uDCBF",
  "Jsercy":"\u0408",
  "jsercy":"\u0458",
  "Jukcy":"\u0404",
  "jukcy":"\u0454",
  "Kappa":"\u039A",
  "kappa":"\u03BA",
  "kappav":"\u03F0",
  "Kcedil":"\u0136",
  "kcedil":"\u0137",
  "Kcy":"\u041A",
  "kcy":"\u043A",
  "Kfr":"\uD835\uDD0E",
  "kfr":"\uD835\uDD28",
  "kgreen":"\u0138",
  "KHcy":"\u0425",
  "khcy":"\u0445",
  "KJcy":"\u040C",
  "kjcy":"\u045C",
  "Kopf":"\uD835\uDD42",
  "kopf":"\uD835\uDD5C",
  "Kscr":"\uD835\uDCA6",
  "kscr":"\uD835\uDCC0",
  "lAarr":"\u21DA",
  "Lacute":"\u0139",
  "lacute":"\u013A",
  "laemptyv":"\u29B4",
  "lagran":"\u2112",
  "Lambda":"\u039B",
  "lambda":"\u03BB",
  "Lang":"\u27EA",
  "lang":"\u27E8",
  "langd":"\u2991",
  "langle":"\u27E8",
  "lap":"\u2A85",
  "Laplacetrf":"\u2112",
  "laquo":"\u00AB",
  "Larr":"\u219E",
  "lArr":"\u21D0",
  "larr":"\u2190",
  "larrb":"\u21E4",
  "larrbfs":"\u291F",
  "larrfs":"\u291D",
  "larrhk":"\u21A9",
  "larrlp":"\u21AB",
  "larrpl":"\u2939",
  "larrsim":"\u2973",
  "larrtl":"\u21A2",
  "lat":"\u2AAB",
  "lAtail":"\u291B",
  "latail":"\u2919",
  "late":"\u2AAD",
  "lates":"\u2AAD\uFE00",
  "lBarr":"\u290E",
  "lbarr":"\u290C",
  "lbbrk":"\u2772",
  "lbrace":"\u007B",
  "lbrack":"\u005B",
  "lbrke":"\u298B",
  "lbrksld":"\u298F",
  "lbrkslu":"\u298D",
  "Lcaron":"\u013D",
  "lcaron":"\u013E",
  "Lcedil":"\u013B",
  "lcedil":"\u013C",
  "lceil":"\u2308",
  "lcub":"\u007B",
  "Lcy":"\u041B",
  "lcy":"\u043B",
  "ldca":"\u2936",
  "ldquo":"\u201C",
  "ldquor":"\u201E",
  "ldrdhar":"\u2967",
  "ldrushar":"\u294B",
  "ldsh":"\u21B2",
  "lE":"\u2266",
  "le":"\u2264",
  "LeftAngleBracket":"\u27E8",
  "LeftArrow":"\u2190",
  "Leftarrow":"\u21D0",
  "leftarrow":"\u2190",
  "LeftArrowBar":"\u21E4",
  "LeftArrowRightArrow":"\u21C6",
  "leftarrowtail":"\u21A2",
  "LeftCeiling":"\u2308",
  "LeftDoubleBracket":"\u27E6",
  "LeftDownTeeVector":"\u2961",
  "LeftDownVector":"\u21C3",
  "LeftDownVectorBar":"\u2959",
  "LeftFloor":"\u230A",
  "leftharpoondown":"\u21BD",
  "leftharpoonup":"\u21BC",
  "leftleftarrows":"\u21C7",
  "LeftRightArrow":"\u2194",
  "Leftrightarrow":"\u21D4",
  "leftrightarrow":"\u2194",
  "leftrightarrows":"\u21C6",
  "leftrightharpoons":"\u21CB",
  "leftrightsquigarrow":"\u21AD",
  "LeftRightVector":"\u294E",
  "LeftTee":"\u22A3",
  "LeftTeeArrow":"\u21A4",
  "LeftTeeVector":"\u295A",
  "leftthreetimes":"\u22CB",
  "LeftTriangle":"\u22B2",
  "LeftTriangleBar":"\u29CF",
  "LeftTriangleEqual":"\u22B4",
  "LeftUpDownVector":"\u2951",
  "LeftUpTeeVector":"\u2960",
  "LeftUpVector":"\u21BF",
  "LeftUpVectorBar":"\u2958",
  "LeftVector":"\u21BC",
  "LeftVectorBar":"\u2952",
  "lEg":"\u2A8B",
  "leg":"\u22DA",
  "leq":"\u2264",
  "leqq":"\u2266",
  "leqslant":"\u2A7D",
  "les":"\u2A7D",
  "lescc":"\u2AA8",
  "lesdot":"\u2A7F",
  "lesdoto":"\u2A81",
  "lesdotor":"\u2A83",
  "lesg":"\u22DA\uFE00",
  "lesges":"\u2A93",
  "lessapprox":"\u2A85",
  "lessdot":"\u22D6",
  "lesseqgtr":"\u22DA",
  "lesseqqgtr":"\u2A8B",
  "LessEqualGreater":"\u22DA",
  "LessFullEqual":"\u2266",
  "LessGreater":"\u2276",
  "lessgtr":"\u2276",
  "LessLess":"\u2AA1",
  "lesssim":"\u2272",
  "LessSlantEqual":"\u2A7D",
  "LessTilde":"\u2272",
  "lfisht":"\u297C",
  "lfloor":"\u230A",
  "Lfr":"\uD835\uDD0F",
  "lfr":"\uD835\uDD29",
  "lg":"\u2276",
  "lgE":"\u2A91",
  "lHar":"\u2962",
  "lhard":"\u21BD",
  "lharu":"\u21BC",
  "lharul":"\u296A",
  "lhblk":"\u2584",
  "LJcy":"\u0409",
  "ljcy":"\u0459",
  "Ll":"\u22D8",
  "ll":"\u226A",
  "llarr":"\u21C7",
  "llcorner":"\u231E",
  "Lleftarrow":"\u21DA",
  "llhard":"\u296B",
  "lltri":"\u25FA",
  "Lmidot":"\u013F",
  "lmidot":"\u0140",
  "lmoust":"\u23B0",
  "lmoustache":"\u23B0",
  "lnap":"\u2A89",
  "lnapprox":"\u2A89",
  "lnE":"\u2268",
  "lne":"\u2A87",
  "lneq":"\u2A87",
  "lneqq":"\u2268",
  "lnsim":"\u22E6",
  "loang":"\u27EC",
  "loarr":"\u21FD",
  "lobrk":"\u27E6",
  "LongLeftArrow":"\u27F5",
  "Longleftarrow":"\u27F8",
  "longleftarrow":"\u27F5",
  "LongLeftRightArrow":"\u27F7",
  "Longleftrightarrow":"\u27FA",
  "longleftrightarrow":"\u27F7",
  "longmapsto":"\u27FC",
  "LongRightArrow":"\u27F6",
  "Longrightarrow":"\u27F9",
  "longrightarrow":"\u27F6",
  "looparrowleft":"\u21AB",
  "looparrowright":"\u21AC",
  "lopar":"\u2985",
  "Lopf":"\uD835\uDD43",
  "lopf":"\uD835\uDD5D",
  "loplus":"\u2A2D",
  "lotimes":"\u2A34",
  "lowast":"\u2217",
  "lowbar":"\u005F",
  "LowerLeftArrow":"\u2199",
  "LowerRightArrow":"\u2198",
  "loz":"\u25CA",
  "lozenge":"\u25CA",
  "lozf":"\u29EB",
  "lpar":"\u0028",
  "lparlt":"\u2993",
  "lrarr":"\u21C6",
  "lrcorner":"\u231F",
  "lrhar":"\u21CB",
  "lrhard":"\u296D",
  "lrm":"\u200E",
  "lrtri":"\u22BF",
  "lsaquo":"\u2039",
  "Lscr":"\u2112",
  "lscr":"\uD835\uDCC1",
  "Lsh":"\u21B0",
  "lsh":"\u21B0",
  "lsim":"\u2272",
  "lsime":"\u2A8D",
  "lsimg":"\u2A8F",
  "lsqb":"\u005B",
  "lsquo":"\u2018",
  "lsquor":"\u201A",
  "Lstrok":"\u0141",
  "lstrok":"\u0142",
  "LT":"\u003C",
  "Lt":"\u226A",
  "lt":"\u003C",
  "ltcc":"\u2AA6",
  "ltcir":"\u2A79",
  "ltdot":"\u22D6",
  "lthree":"\u22CB",
  "ltimes":"\u22C9",
  "ltlarr":"\u2976",
  "ltquest":"\u2A7B",
  "ltri":"\u25C3",
  "ltrie":"\u22B4",
  "ltrif":"\u25C2",
  "ltrPar":"\u2996",
  "lurdshar":"\u294A",
  "luruhar":"\u2966",
  "lvertneqq":"\u2268\uFE00",
  "lvnE":"\u2268\uFE00",
  "macr":"\u00AF",
  "male":"\u2642",
  "malt":"\u2720",
  "maltese":"\u2720",
  "Map":"\u2905",
  "map":"\u21A6",
  "mapsto":"\u21A6",
  "mapstodown":"\u21A7",
  "mapstoleft":"\u21A4",
  "mapstoup":"\u21A5",
  "marker":"\u25AE",
  "mcomma":"\u2A29",
  "Mcy":"\u041C",
  "mcy":"\u043C",
  "mdash":"\u2014",
  "mDDot":"\u223A",
  "measuredangle":"\u2221",
  "MediumSpace":"\u205F",
  "Mellintrf":"\u2133",
  "Mfr":"\uD835\uDD10",
  "mfr":"\uD835\uDD2A",
  "mho":"\u2127",
  "micro":"\u00B5",
  "mid":"\u2223",
  "midast":"\u002A",
  "midcir":"\u2AF0",
  "middot":"\u00B7",
  "minus":"\u2212",
  "minusb":"\u229F",
  "minusd":"\u2238",
  "minusdu":"\u2A2A",
  "MinusPlus":"\u2213",
  "mlcp":"\u2ADB",
  "mldr":"\u2026",
  "mnplus":"\u2213",
  "models":"\u22A7",
  "Mopf":"\uD835\uDD44",
  "mopf":"\uD835\uDD5E",
  "mp":"\u2213",
  "Mscr":"\u2133",
  "mscr":"\uD835\uDCC2",
  "mstpos":"\u223E",
  "Mu":"\u039C",
  "mu":"\u03BC",
  "multimap":"\u22B8",
  "mumap":"\u22B8",
  "nabla":"\u2207",
  "Nacute":"\u0143",
  "nacute":"\u0144",
  "nang":"\u2220\u20D2",
  "nap":"\u2249",
  "napE":"\u2A70\u0338",
  "napid":"\u224B\u0338",
  "napos":"\u0149",
  "napprox":"\u2249",
  "natur":"\u266E",
  "natural":"\u266E",
  "naturals":"\u2115",
  "nbsp":"\u00A0",
  "nbump":"\u224E\u0338",
  "nbumpe":"\u224F\u0338",
  "ncap":"\u2A43",
  "Ncaron":"\u0147",
  "ncaron":"\u0148",
  "Ncedil":"\u0145",
  "ncedil":"\u0146",
  "ncong":"\u2247",
  "ncongdot":"\u2A6D\u0338",
  "ncup":"\u2A42",
  "Ncy":"\u041D",
  "ncy":"\u043D",
  "ndash":"\u2013",
  "ne":"\u2260",
  "nearhk":"\u2924",
  "neArr":"\u21D7",
  "nearr":"\u2197",
  "nearrow":"\u2197",
  "nedot":"\u2250\u0338",
  "NegativeMediumSpace":"\u200B",
  "NegativeThickSpace":"\u200B",
  "NegativeThinSpace":"\u200B",
  "NegativeVeryThinSpace":"\u200B",
  "nequiv":"\u2262",
  "nesear":"\u2928",
  "nesim":"\u2242\u0338",
  "NestedGreaterGreater":"\u226B",
  "NestedLessLess":"\u226A",
  "NewLine":"\u000A",
  "nexist":"\u2204",
  "nexists":"\u2204",
  "Nfr":"\uD835\uDD11",
  "nfr":"\uD835\uDD2B",
  "ngE":"\u2267\u0338",
  "nge":"\u2271",
  "ngeq":"\u2271",
  "ngeqq":"\u2267\u0338",
  "ngeqslant":"\u2A7E\u0338",
  "nges":"\u2A7E\u0338",
  "nGg":"\u22D9\u0338",
  "ngsim":"\u2275",
  "nGt":"\u226B\u20D2",
  "ngt":"\u226F",
  "ngtr":"\u226F",
  "nGtv":"\u226B\u0338",
  "nhArr":"\u21CE",
  "nharr":"\u21AE",
  "nhpar":"\u2AF2",
  "ni":"\u220B",
  "nis":"\u22FC",
  "nisd":"\u22FA",
  "niv":"\u220B",
  "NJcy":"\u040A",
  "njcy":"\u045A",
  "nlArr":"\u21CD",
  "nlarr":"\u219A",
  "nldr":"\u2025",
  "nlE":"\u2266\u0338",
  "nle":"\u2270",
  "nLeftarrow":"\u21CD",
  "nleftarrow":"\u219A",
  "nLeftrightarrow":"\u21CE",
  "nleftrightarrow":"\u21AE",
  "nleq":"\u2270",
  "nleqq":"\u2266\u0338",
  "nleqslant":"\u2A7D\u0338",
  "nles":"\u2A7D\u0338",
  "nless":"\u226E",
  "nLl":"\u22D8\u0338",
  "nlsim":"\u2274",
  "nLt":"\u226A\u20D2",
  "nlt":"\u226E",
  "nltri":"\u22EA",
  "nltrie":"\u22EC",
  "nLtv":"\u226A\u0338",
  "nmid":"\u2224",
  "NoBreak":"\u2060",
  "NonBreakingSpace":"\u00A0",
  "Nopf":"\u2115",
  "nopf":"\uD835\uDD5F",
  "Not":"\u2AEC",
  "not":"\u00AC",
  "NotCongruent":"\u2262",
  "NotCupCap":"\u226D",
  "NotDoubleVerticalBar":"\u2226",
  "NotElement":"\u2209",
  "NotEqual":"\u2260",
  "NotEqualTilde":"\u2242\u0338",
  "NotExists":"\u2204",
  "NotGreater":"\u226F",
  "NotGreaterEqual":"\u2271",
  "NotGreaterFullEqual":"\u2267\u0338",
  "NotGreaterGreater":"\u226B\u0338",
  "NotGreaterLess":"\u2279",
  "NotGreaterSlantEqual":"\u2A7E\u0338",
  "NotGreaterTilde":"\u2275",
  "NotHumpDownHump":"\u224E\u0338",
  "NotHumpEqual":"\u224F\u0338",
  "notin":"\u2209",
  "notindot":"\u22F5\u0338",
  "notinE":"\u22F9\u0338",
  "notinva":"\u2209",
  "notinvb":"\u22F7",
  "notinvc":"\u22F6",
  "NotLeftTriangle":"\u22EA",
  "NotLeftTriangleBar":"\u29CF\u0338",
  "NotLeftTriangleEqual":"\u22EC",
  "NotLess":"\u226E",
  "NotLessEqual":"\u2270",
  "NotLessGreater":"\u2278",
  "NotLessLess":"\u226A\u0338",
  "NotLessSlantEqual":"\u2A7D\u0338",
  "NotLessTilde":"\u2274",
  "NotNestedGreaterGreater":"\u2AA2\u0338",
  "NotNestedLessLess":"\u2AA1\u0338",
  "notni":"\u220C",
  "notniva":"\u220C",
  "notnivb":"\u22FE",
  "notnivc":"\u22FD",
  "NotPrecedes":"\u2280",
  "NotPrecedesEqual":"\u2AAF\u0338",
  "NotPrecedesSlantEqual":"\u22E0",
  "NotReverseElement":"\u220C",
  "NotRightTriangle":"\u22EB",
  "NotRightTriangleBar":"\u29D0\u0338",
  "NotRightTriangleEqual":"\u22ED",
  "NotSquareSubset":"\u228F\u0338",
  "NotSquareSubsetEqual":"\u22E2",
  "NotSquareSuperset":"\u2290\u0338",
  "NotSquareSupersetEqual":"\u22E3",
  "NotSubset":"\u2282\u20D2",
  "NotSubsetEqual":"\u2288",
  "NotSucceeds":"\u2281",
  "NotSucceedsEqual":"\u2AB0\u0338",
  "NotSucceedsSlantEqual":"\u22E1",
  "NotSucceedsTilde":"\u227F\u0338",
  "NotSuperset":"\u2283\u20D2",
  "NotSupersetEqual":"\u2289",
  "NotTilde":"\u2241",
  "NotTildeEqual":"\u2244",
  "NotTildeFullEqual":"\u2247",
  "NotTildeTilde":"\u2249",
  "NotVerticalBar":"\u2224",
  "npar":"\u2226",
  "nparallel":"\u2226",
  "nparsl":"\u2AFD\u20E5",
  "npart":"\u2202\u0338",
  "npolint":"\u2A14",
  "npr":"\u2280",
  "nprcue":"\u22E0",
  "npre":"\u2AAF\u0338",
  "nprec":"\u2280",
  "npreceq":"\u2AAF\u0338",
  "nrArr":"\u21CF",
  "nrarr":"\u219B",
  "nrarrc":"\u2933\u0338",
  "nrarrw":"\u219D\u0338",
  "nRightarrow":"\u21CF",
  "nrightarrow":"\u219B",
  "nrtri":"\u22EB",
  "nrtrie":"\u22ED",
  "nsc":"\u2281",
  "nsccue":"\u22E1",
  "nsce":"\u2AB0\u0338",
  "Nscr":"\uD835\uDCA9",
  "nscr":"\uD835\uDCC3",
  "nshortmid":"\u2224",
  "nshortparallel":"\u2226",
  "nsim":"\u2241",
  "nsime":"\u2244",
  "nsimeq":"\u2244",
  "nsmid":"\u2224",
  "nspar":"\u2226",
  "nsqsube":"\u22E2",
  "nsqsupe":"\u22E3",
  "nsub":"\u2284",
  "nsubE":"\u2AC5\u0338",
  "nsube":"\u2288",
  "nsubset":"\u2282\u20D2",
  "nsubseteq":"\u2288",
  "nsubseteqq":"\u2AC5\u0338",
  "nsucc":"\u2281",
  "nsucceq":"\u2AB0\u0338",
  "nsup":"\u2285",
  "nsupE":"\u2AC6\u0338",
  "nsupe":"\u2289",
  "nsupset":"\u2283\u20D2",
  "nsupseteq":"\u2289",
  "nsupseteqq":"\u2AC6\u0338",
  "ntgl":"\u2279",
  "Ntilde":"\u00D1",
  "ntilde":"\u00F1",
  "ntlg":"\u2278",
  "ntriangleleft":"\u22EA",
  "ntrianglelefteq":"\u22EC",
  "ntriangleright":"\u22EB",
  "ntrianglerighteq":"\u22ED",
  "Nu":"\u039D",
  "nu":"\u03BD",
  "num":"\u0023",
  "numero":"\u2116",
  "numsp":"\u2007",
  "nvap":"\u224D\u20D2",
  "nVDash":"\u22AF",
  "nVdash":"\u22AE",
  "nvDash":"\u22AD",
  "nvdash":"\u22AC",
  "nvge":"\u2265\u20D2",
  "nvgt":"\u003E\u20D2",
  "nvHarr":"\u2904",
  "nvinfin":"\u29DE",
  "nvlArr":"\u2902",
  "nvle":"\u2264\u20D2",
  "nvlt":"\u003C\u20D2",
  "nvltrie":"\u22B4\u20D2",
  "nvrArr":"\u2903",
  "nvrtrie":"\u22B5\u20D2",
  "nvsim":"\u223C\u20D2",
  "nwarhk":"\u2923",
  "nwArr":"\u21D6",
  "nwarr":"\u2196",
  "nwarrow":"\u2196",
  "nwnear":"\u2927",
  "Oacute":"\u00D3",
  "oacute":"\u00F3",
  "oast":"\u229B",
  "ocir":"\u229A",
  "Ocirc":"\u00D4",
  "ocirc":"\u00F4",
  "Ocy":"\u041E",
  "ocy":"\u043E",
  "odash":"\u229D",
  "Odblac":"\u0150",
  "odblac":"\u0151",
  "odiv":"\u2A38",
  "odot":"\u2299",
  "odsold":"\u29BC",
  "OElig":"\u0152",
  "oelig":"\u0153",
  "ofcir":"\u29BF",
  "Ofr":"\uD835\uDD12",
  "ofr":"\uD835\uDD2C",
  "ogon":"\u02DB",
  "Ograve":"\u00D2",
  "ograve":"\u00F2",
  "ogt":"\u29C1",
  "ohbar":"\u29B5",
  "ohm":"\u03A9",
  "oint":"\u222E",
  "olarr":"\u21BA",
  "olcir":"\u29BE",
  "olcross":"\u29BB",
  "oline":"\u203E",
  "olt":"\u29C0",
  "Omacr":"\u014C",
  "omacr":"\u014D",
  "Omega":"\u03A9",
  "omega":"\u03C9",
  "Omicron":"\u039F",
  "omicron":"\u03BF",
  "omid":"\u29B6",
  "ominus":"\u2296",
  "Oopf":"\uD835\uDD46",
  "oopf":"\uD835\uDD60",
  "opar":"\u29B7",
  "OpenCurlyDoubleQuote":"\u201C",
  "OpenCurlyQuote":"\u2018",
  "operp":"\u29B9",
  "oplus":"\u2295",
  "Or":"\u2A54",
  "or":"\u2228",
  "orarr":"\u21BB",
  "ord":"\u2A5D",
  "order":"\u2134",
  "orderof":"\u2134",
  "ordf":"\u00AA",
  "ordm":"\u00BA",
  "origof":"\u22B6",
  "oror":"\u2A56",
  "orslope":"\u2A57",
  "orv":"\u2A5B",
  "oS":"\u24C8",
  "Oscr":"\uD835\uDCAA",
  "oscr":"\u2134",
  "Oslash":"\u00D8",
  "oslash":"\u00F8",
  "osol":"\u2298",
  "Otilde":"\u00D5",
  "otilde":"\u00F5",
  "Otimes":"\u2A37",
  "otimes":"\u2297",
  "otimesas":"\u2A36",
  "Ouml":"\u00D6",
  "ouml":"\u00F6",
  "ovbar":"\u233D",
  "OverBar":"\u203E",
  "OverBrace":"\u23DE",
  "OverBracket":"\u23B4",
  "OverParenthesis":"\u23DC",
  "par":"\u2225",
  "para":"\u00B6",
  "parallel":"\u2225",
  "parsim":"\u2AF3",
  "parsl":"\u2AFD",
  "part":"\u2202",
  "PartialD":"\u2202",
  "Pcy":"\u041F",
  "pcy":"\u043F",
  "percnt":"\u0025",
  "period":"\u002E",
  "permil":"\u2030",
  "perp":"\u22A5",
  "pertenk":"\u2031",
  "Pfr":"\uD835\uDD13",
  "pfr":"\uD835\uDD2D",
  "Phi":"\u03A6",
  "phi":"\u03C6",
  "phiv":"\u03D5",
  "phmmat":"\u2133",
  "phone":"\u260E",
  "Pi":"\u03A0",
  "pi":"\u03C0",
  "pitchfork":"\u22D4",
  "piv":"\u03D6",
  "planck":"\u210F",
  "planckh":"\u210E",
  "plankv":"\u210F",
  "plus":"\u002B",
  "plusacir":"\u2A23",
  "plusb":"\u229E",
  "pluscir":"\u2A22",
  "plusdo":"\u2214",
  "plusdu":"\u2A25",
  "pluse":"\u2A72",
  "PlusMinus":"\u00B1",
  "plusmn":"\u00B1",
  "plussim":"\u2A26",
  "plustwo":"\u2A27",
  "pm":"\u00B1",
  "Poincareplane":"\u210C",
  "pointint":"\u2A15",
  "Popf":"\u2119",
  "popf":"\uD835\uDD61",
  "pound":"\u00A3",
  "Pr":"\u2ABB",
  "pr":"\u227A",
  "prap":"\u2AB7",
  "prcue":"\u227C",
  "prE":"\u2AB3",
  "pre":"\u2AAF",
  "prec":"\u227A",
  "precapprox":"\u2AB7",
  "preccurlyeq":"\u227C",
  "Precedes":"\u227A",
  "PrecedesEqual":"\u2AAF",
  "PrecedesSlantEqual":"\u227C",
  "PrecedesTilde":"\u227E",
  "preceq":"\u2AAF",
  "precnapprox":"\u2AB9",
  "precneqq":"\u2AB5",
  "precnsim":"\u22E8",
  "precsim":"\u227E",
  "Prime":"\u2033",
  "prime":"\u2032",
  "primes":"\u2119",
  "prnap":"\u2AB9",
  "prnE":"\u2AB5",
  "prnsim":"\u22E8",
  "prod":"\u220F",
  "Product":"\u220F",
  "profalar":"\u232E",
  "profline":"\u2312",
  "profsurf":"\u2313",
  "prop":"\u221D",
  "Proportion":"\u2237",
  "Proportional":"\u221D",
  "propto":"\u221D",
  "prsim":"\u227E",
  "prurel":"\u22B0",
  "Pscr":"\uD835\uDCAB",
  "pscr":"\uD835\uDCC5",
  "Psi":"\u03A8",
  "psi":"\u03C8",
  "puncsp":"\u2008",
  "Qfr":"\uD835\uDD14",
  "qfr":"\uD835\uDD2E",
  "qint":"\u2A0C",
  "Qopf":"\u211A",
  "qopf":"\uD835\uDD62",
  "qprime":"\u2057",
  "Qscr":"\uD835\uDCAC",
  "qscr":"\uD835\uDCC6",
  "quaternions":"\u210D",
  "quatint":"\u2A16",
  "quest":"\u003F",
  "questeq":"\u225F",
  "QUOT":"\u0022",
  "quot":"\u0022",
  "rAarr":"\u21DB",
  "race":"\u223D\u0331",
  "Racute":"\u0154",
  "racute":"\u0155",
  "radic":"\u221A",
  "raemptyv":"\u29B3",
  "Rang":"\u27EB",
  "rang":"\u27E9",
  "rangd":"\u2992",
  "range":"\u29A5",
  "rangle":"\u27E9",
  "raquo":"\u00BB",
  "Rarr":"\u21A0",
  "rArr":"\u21D2",
  "rarr":"\u2192",
  "rarrap":"\u2975",
  "rarrb":"\u21E5",
  "rarrbfs":"\u2920",
  "rarrc":"\u2933",
  "rarrfs":"\u291E",
  "rarrhk":"\u21AA",
  "rarrlp":"\u21AC",
  "rarrpl":"\u2945",
  "rarrsim":"\u2974",
  "Rarrtl":"\u2916",
  "rarrtl":"\u21A3",
  "rarrw":"\u219D",
  "rAtail":"\u291C",
  "ratail":"\u291A",
  "ratio":"\u2236",
  "rationals":"\u211A",
  "RBarr":"\u2910",
  "rBarr":"\u290F",
  "rbarr":"\u290D",
  "rbbrk":"\u2773",
  "rbrace":"\u007D",
  "rbrack":"\u005D",
  "rbrke":"\u298C",
  "rbrksld":"\u298E",
  "rbrkslu":"\u2990",
  "Rcaron":"\u0158",
  "rcaron":"\u0159",
  "Rcedil":"\u0156",
  "rcedil":"\u0157",
  "rceil":"\u2309",
  "rcub":"\u007D",
  "Rcy":"\u0420",
  "rcy":"\u0440",
  "rdca":"\u2937",
  "rdldhar":"\u2969",
  "rdquo":"\u201D",
  "rdquor":"\u201D",
  "rdsh":"\u21B3",
  "Re":"\u211C",
  "real":"\u211C",
  "realine":"\u211B",
  "realpart":"\u211C",
  "reals":"\u211D",
  "rect":"\u25AD",
  "REG":"\u00AE",
  "reg":"\u00AE",
  "ReverseElement":"\u220B",
  "ReverseEquilibrium":"\u21CB",
  "ReverseUpEquilibrium":"\u296F",
  "rfisht":"\u297D",
  "rfloor":"\u230B",
  "Rfr":"\u211C",
  "rfr":"\uD835\uDD2F",
  "rHar":"\u2964",
  "rhard":"\u21C1",
  "rharu":"\u21C0",
  "rharul":"\u296C",
  "Rho":"\u03A1",
  "rho":"\u03C1",
  "rhov":"\u03F1",
  "RightAngleBracket":"\u27E9",
  "RightArrow":"\u2192",
  "Rightarrow":"\u21D2",
  "rightarrow":"\u2192",
  "RightArrowBar":"\u21E5",
  "RightArrowLeftArrow":"\u21C4",
  "rightarrowtail":"\u21A3",
  "RightCeiling":"\u2309",
  "RightDoubleBracket":"\u27E7",
  "RightDownTeeVector":"\u295D",
  "RightDownVector":"\u21C2",
  "RightDownVectorBar":"\u2955",
  "RightFloor":"\u230B",
  "rightharpoondown":"\u21C1",
  "rightharpoonup":"\u21C0",
  "rightleftarrows":"\u21C4",
  "rightleftharpoons":"\u21CC",
  "rightrightarrows":"\u21C9",
  "rightsquigarrow":"\u219D",
  "RightTee":"\u22A2",
  "RightTeeArrow":"\u21A6",
  "RightTeeVector":"\u295B",
  "rightthreetimes":"\u22CC",
  "RightTriangle":"\u22B3",
  "RightTriangleBar":"\u29D0",
  "RightTriangleEqual":"\u22B5",
  "RightUpDownVector":"\u294F",
  "RightUpTeeVector":"\u295C",
  "RightUpVector":"\u21BE",
  "RightUpVectorBar":"\u2954",
  "RightVector":"\u21C0",
  "RightVectorBar":"\u2953",
  "ring":"\u02DA",
  "risingdotseq":"\u2253",
  "rlarr":"\u21C4",
  "rlhar":"\u21CC",
  "rlm":"\u200F",
  "rmoust":"\u23B1",
  "rmoustache":"\u23B1",
  "rnmid":"\u2AEE",
  "roang":"\u27ED",
  "roarr":"\u21FE",
  "robrk":"\u27E7",
  "ropar":"\u2986",
  "Ropf":"\u211D",
  "ropf":"\uD835\uDD63",
  "roplus":"\u2A2E",
  "rotimes":"\u2A35",
  "RoundImplies":"\u2970",
  "rpar":"\u0029",
  "rpargt":"\u2994",
  "rppolint":"\u2A12",
  "rrarr":"\u21C9",
  "Rrightarrow":"\u21DB",
  "rsaquo":"\u203A",
  "Rscr":"\u211B",
  "rscr":"\uD835\uDCC7",
  "Rsh":"\u21B1",
  "rsh":"\u21B1",
  "rsqb":"\u005D",
  "rsquo":"\u2019",
  "rsquor":"\u2019",
  "rthree":"\u22CC",
  "rtimes":"\u22CA",
  "rtri":"\u25B9",
  "rtrie":"\u22B5",
  "rtrif":"\u25B8",
  "rtriltri":"\u29CE",
  "RuleDelayed":"\u29F4",
  "ruluhar":"\u2968",
  "rx":"\u211E",
  "Sacute":"\u015A",
  "sacute":"\u015B",
  "sbquo":"\u201A",
  "Sc":"\u2ABC",
  "sc":"\u227B",
  "scap":"\u2AB8",
  "Scaron":"\u0160",
  "scaron":"\u0161",
  "sccue":"\u227D",
  "scE":"\u2AB4",
  "sce":"\u2AB0",
  "Scedil":"\u015E",
  "scedil":"\u015F",
  "Scirc":"\u015C",
  "scirc":"\u015D",
  "scnap":"\u2ABA",
  "scnE":"\u2AB6",
  "scnsim":"\u22E9",
  "scpolint":"\u2A13",
  "scsim":"\u227F",
  "Scy":"\u0421",
  "scy":"\u0441",
  "sdot":"\u22C5",
  "sdotb":"\u22A1",
  "sdote":"\u2A66",
  "searhk":"\u2925",
  "seArr":"\u21D8",
  "searr":"\u2198",
  "searrow":"\u2198",
  "sect":"\u00A7",
  "semi":"\u003B",
  "seswar":"\u2929",
  "setminus":"\u2216",
  "setmn":"\u2216",
  "sext":"\u2736",
  "Sfr":"\uD835\uDD16",
  "sfr":"\uD835\uDD30",
  "sfrown":"\u2322",
  "sharp":"\u266F",
  "SHCHcy":"\u0429",
  "shchcy":"\u0449",
  "SHcy":"\u0428",
  "shcy":"\u0448",
  "ShortDownArrow":"\u2193",
  "ShortLeftArrow":"\u2190",
  "shortmid":"\u2223",
  "shortparallel":"\u2225",
  "ShortRightArrow":"\u2192",
  "ShortUpArrow":"\u2191",
  "shy":"\u00AD",
  "Sigma":"\u03A3",
  "sigma":"\u03C3",
  "sigmaf":"\u03C2",
  "sigmav":"\u03C2",
  "sim":"\u223C",
  "simdot":"\u2A6A",
  "sime":"\u2243",
  "simeq":"\u2243",
  "simg":"\u2A9E",
  "simgE":"\u2AA0",
  "siml":"\u2A9D",
  "simlE":"\u2A9F",
  "simne":"\u2246",
  "simplus":"\u2A24",
  "simrarr":"\u2972",
  "slarr":"\u2190",
  "SmallCircle":"\u2218",
  "smallsetminus":"\u2216",
  "smashp":"\u2A33",
  "smeparsl":"\u29E4",
  "smid":"\u2223",
  "smile":"\u2323",
  "smt":"\u2AAA",
  "smte":"\u2AAC",
  "smtes":"\u2AAC\uFE00",
  "SOFTcy":"\u042C",
  "softcy":"\u044C",
  "sol":"\u002F",
  "solb":"\u29C4",
  "solbar":"\u233F",
  "Sopf":"\uD835\uDD4A",
  "sopf":"\uD835\uDD64",
  "spades":"\u2660",
  "spadesuit":"\u2660",
  "spar":"\u2225",
  "sqcap":"\u2293",
  "sqcaps":"\u2293\uFE00",
  "sqcup":"\u2294",
  "sqcups":"\u2294\uFE00",
  "Sqrt":"\u221A",
  "sqsub":"\u228F",
  "sqsube":"\u2291",
  "sqsubset":"\u228F",
  "sqsubseteq":"\u2291",
  "sqsup":"\u2290",
  "sqsupe":"\u2292",
  "sqsupset":"\u2290",
  "sqsupseteq":"\u2292",
  "squ":"\u25A1",
  "Square":"\u25A1",
  "square":"\u25A1",
  "SquareIntersection":"\u2293",
  "SquareSubset":"\u228F",
  "SquareSubsetEqual":"\u2291",
  "SquareSuperset":"\u2290",
  "SquareSupersetEqual":"\u2292",
  "SquareUnion":"\u2294",
  "squarf":"\u25AA",
  "squf":"\u25AA",
  "srarr":"\u2192",
  "Sscr":"\uD835\uDCAE",
  "sscr":"\uD835\uDCC8",
  "ssetmn":"\u2216",
  "ssmile":"\u2323",
  "sstarf":"\u22C6",
  "Star":"\u22C6",
  "star":"\u2606",
  "starf":"\u2605",
  "straightepsilon":"\u03F5",
  "straightphi":"\u03D5",
  "strns":"\u00AF",
  "Sub":"\u22D0",
  "sub":"\u2282",
  "subdot":"\u2ABD",
  "subE":"\u2AC5",
  "sube":"\u2286",
  "subedot":"\u2AC3",
  "submult":"\u2AC1",
  "subnE":"\u2ACB",
  "subne":"\u228A",
  "subplus":"\u2ABF",
  "subrarr":"\u2979",
  "Subset":"\u22D0",
  "subset":"\u2282",
  "subseteq":"\u2286",
  "subseteqq":"\u2AC5",
  "SubsetEqual":"\u2286",
  "subsetneq":"\u228A",
  "subsetneqq":"\u2ACB",
  "subsim":"\u2AC7",
  "subsub":"\u2AD5",
  "subsup":"\u2AD3",
  "succ":"\u227B",
  "succapprox":"\u2AB8",
  "succcurlyeq":"\u227D",
  "Succeeds":"\u227B",
  "SucceedsEqual":"\u2AB0",
  "SucceedsSlantEqual":"\u227D",
  "SucceedsTilde":"\u227F",
  "succeq":"\u2AB0",
  "succnapprox":"\u2ABA",
  "succneqq":"\u2AB6",
  "succnsim":"\u22E9",
  "succsim":"\u227F",
  "SuchThat":"\u220B",
  "Sum":"\u2211",
  "sum":"\u2211",
  "sung":"\u266A",
  "Sup":"\u22D1",
  "sup":"\u2283",
  "sup1":"\u00B9",
  "sup2":"\u00B2",
  "sup3":"\u00B3",
  "supdot":"\u2ABE",
  "supdsub":"\u2AD8",
  "supE":"\u2AC6",
  "supe":"\u2287",
  "supedot":"\u2AC4",
  "Superset":"\u2283",
  "SupersetEqual":"\u2287",
  "suphsol":"\u27C9",
  "suphsub":"\u2AD7",
  "suplarr":"\u297B",
  "supmult":"\u2AC2",
  "supnE":"\u2ACC",
  "supne":"\u228B",
  "supplus":"\u2AC0",
  "Supset":"\u22D1",
  "supset":"\u2283",
  "supseteq":"\u2287",
  "supseteqq":"\u2AC6",
  "supsetneq":"\u228B",
  "supsetneqq":"\u2ACC",
  "supsim":"\u2AC8",
  "supsub":"\u2AD4",
  "supsup":"\u2AD6",
  "swarhk":"\u2926",
  "swArr":"\u21D9",
  "swarr":"\u2199",
  "swarrow":"\u2199",
  "swnwar":"\u292A",
  "szlig":"\u00DF",
  "Tab":"\u0009",
  "target":"\u2316",
  "Tau":"\u03A4",
  "tau":"\u03C4",
  "tbrk":"\u23B4",
  "Tcaron":"\u0164",
  "tcaron":"\u0165",
  "Tcedil":"\u0162",
  "tcedil":"\u0163",
  "Tcy":"\u0422",
  "tcy":"\u0442",
  "tdot":"\u20DB",
  "telrec":"\u2315",
  "Tfr":"\uD835\uDD17",
  "tfr":"\uD835\uDD31",
  "there4":"\u2234",
  "Therefore":"\u2234",
  "therefore":"\u2234",
  "Theta":"\u0398",
  "theta":"\u03B8",
  "thetasym":"\u03D1",
  "thetav":"\u03D1",
  "thickapprox":"\u2248",
  "thicksim":"\u223C",
  "ThickSpace":"\u205F\u200A",
  "thinsp":"\u2009",
  "ThinSpace":"\u2009",
  "thkap":"\u2248",
  "thksim":"\u223C",
  "THORN":"\u00DE",
  "thorn":"\u00FE",
  "Tilde":"\u223C",
  "tilde":"\u02DC",
  "TildeEqual":"\u2243",
  "TildeFullEqual":"\u2245",
  "TildeTilde":"\u2248",
  "times":"\u00D7",
  "timesb":"\u22A0",
  "timesbar":"\u2A31",
  "timesd":"\u2A30",
  "tint":"\u222D",
  "toea":"\u2928",
  "top":"\u22A4",
  "topbot":"\u2336",
  "topcir":"\u2AF1",
  "Topf":"\uD835\uDD4B",
  "topf":"\uD835\uDD65",
  "topfork":"\u2ADA",
  "tosa":"\u2929",
  "tprime":"\u2034",
  "TRADE":"\u2122",
  "trade":"\u2122",
  "triangle":"\u25B5",
  "triangledown":"\u25BF",
  "triangleleft":"\u25C3",
  "trianglelefteq":"\u22B4",
  "triangleq":"\u225C",
  "triangleright":"\u25B9",
  "trianglerighteq":"\u22B5",
  "tridot":"\u25EC",
  "trie":"\u225C",
  "triminus":"\u2A3A",
  "TripleDot":"\u20DB",
  "triplus":"\u2A39",
  "trisb":"\u29CD",
  "tritime":"\u2A3B",
  "trpezium":"\u23E2",
  "Tscr":"\uD835\uDCAF",
  "tscr":"\uD835\uDCC9",
  "TScy":"\u0426",
  "tscy":"\u0446",
  "TSHcy":"\u040B",
  "tshcy":"\u045B",
  "Tstrok":"\u0166",
  "tstrok":"\u0167",
  "twixt":"\u226C",
  "twoheadleftarrow":"\u219E",
  "twoheadrightarrow":"\u21A0",
  "Uacute":"\u00DA",
  "uacute":"\u00FA",
  "Uarr":"\u219F",
  "uArr":"\u21D1",
  "uarr":"\u2191",
  "Uarrocir":"\u2949",
  "Ubrcy":"\u040E",
  "ubrcy":"\u045E",
  "Ubreve":"\u016C",
  "ubreve":"\u016D",
  "Ucirc":"\u00DB",
  "ucirc":"\u00FB",
  "Ucy":"\u0423",
  "ucy":"\u0443",
  "udarr":"\u21C5",
  "Udblac":"\u0170",
  "udblac":"\u0171",
  "udhar":"\u296E",
  "ufisht":"\u297E",
  "Ufr":"\uD835\uDD18",
  "ufr":"\uD835\uDD32",
  "Ugrave":"\u00D9",
  "ugrave":"\u00F9",
  "uHar":"\u2963",
  "uharl":"\u21BF",
  "uharr":"\u21BE",
  "uhblk":"\u2580",
  "ulcorn":"\u231C",
  "ulcorner":"\u231C",
  "ulcrop":"\u230F",
  "ultri":"\u25F8",
  "Umacr":"\u016A",
  "umacr":"\u016B",
  "uml":"\u00A8",
  "UnderBar":"\u005F",
  "UnderBrace":"\u23DF",
  "UnderBracket":"\u23B5",
  "UnderParenthesis":"\u23DD",
  "Union":"\u22C3",
  "UnionPlus":"\u228E",
  "Uogon":"\u0172",
  "uogon":"\u0173",
  "Uopf":"\uD835\uDD4C",
  "uopf":"\uD835\uDD66",
  "UpArrow":"\u2191",
  "Uparrow":"\u21D1",
  "uparrow":"\u2191",
  "UpArrowBar":"\u2912",
  "UpArrowDownArrow":"\u21C5",
  "UpDownArrow":"\u2195",
  "Updownarrow":"\u21D5",
  "updownarrow":"\u2195",
  "UpEquilibrium":"\u296E",
  "upharpoonleft":"\u21BF",
  "upharpoonright":"\u21BE",
  "uplus":"\u228E",
  "UpperLeftArrow":"\u2196",
  "UpperRightArrow":"\u2197",
  "Upsi":"\u03D2",
  "upsi":"\u03C5",
  "upsih":"\u03D2",
  "Upsilon":"\u03A5",
  "upsilon":"\u03C5",
  "UpTee":"\u22A5",
  "UpTeeArrow":"\u21A5",
  "upuparrows":"\u21C8",
  "urcorn":"\u231D",
  "urcorner":"\u231D",
  "urcrop":"\u230E",
  "Uring":"\u016E",
  "uring":"\u016F",
  "urtri":"\u25F9",
  "Uscr":"\uD835\uDCB0",
  "uscr":"\uD835\uDCCA",
  "utdot":"\u22F0",
  "Utilde":"\u0168",
  "utilde":"\u0169",
  "utri":"\u25B5",
  "utrif":"\u25B4",
  "uuarr":"\u21C8",
  "Uuml":"\u00DC",
  "uuml":"\u00FC",
  "uwangle":"\u29A7",
  "vangrt":"\u299C",
  "varepsilon":"\u03F5",
  "varkappa":"\u03F0",
  "varnothing":"\u2205",
  "varphi":"\u03D5",
  "varpi":"\u03D6",
  "varpropto":"\u221D",
  "vArr":"\u21D5",
  "varr":"\u2195",
  "varrho":"\u03F1",
  "varsigma":"\u03C2",
  "varsubsetneq":"\u228A\uFE00",
  "varsubsetneqq":"\u2ACB\uFE00",
  "varsupsetneq":"\u228B\uFE00",
  "varsupsetneqq":"\u2ACC\uFE00",
  "vartheta":"\u03D1",
  "vartriangleleft":"\u22B2",
  "vartriangleright":"\u22B3",
  "Vbar":"\u2AEB",
  "vBar":"\u2AE8",
  "vBarv":"\u2AE9",
  "Vcy":"\u0412",
  "vcy":"\u0432",
  "VDash":"\u22AB",
  "Vdash":"\u22A9",
  "vDash":"\u22A8",
  "vdash":"\u22A2",
  "Vdashl":"\u2AE6",
  "Vee":"\u22C1",
  "vee":"\u2228",
  "veebar":"\u22BB",
  "veeeq":"\u225A",
  "vellip":"\u22EE",
  "Verbar":"\u2016",
  "verbar":"\u007C",
  "Vert":"\u2016",
  "vert":"\u007C",
  "VerticalBar":"\u2223",
  "VerticalLine":"\u007C",
  "VerticalSeparator":"\u2758",
  "VerticalTilde":"\u2240",
  "VeryThinSpace":"\u200A",
  "Vfr":"\uD835\uDD19",
  "vfr":"\uD835\uDD33",
  "vltri":"\u22B2",
  "vnsub":"\u2282\u20D2",
  "vnsup":"\u2283\u20D2",
  "Vopf":"\uD835\uDD4D",
  "vopf":"\uD835\uDD67",
  "vprop":"\u221D",
  "vrtri":"\u22B3",
  "Vscr":"\uD835\uDCB1",
  "vscr":"\uD835\uDCCB",
  "vsubnE":"\u2ACB\uFE00",
  "vsubne":"\u228A\uFE00",
  "vsupnE":"\u2ACC\uFE00",
  "vsupne":"\u228B\uFE00",
  "Vvdash":"\u22AA",
  "vzigzag":"\u299A",
  "Wcirc":"\u0174",
  "wcirc":"\u0175",
  "wedbar":"\u2A5F",
  "Wedge":"\u22C0",
  "wedge":"\u2227",
  "wedgeq":"\u2259",
  "weierp":"\u2118",
  "Wfr":"\uD835\uDD1A",
  "wfr":"\uD835\uDD34",
  "Wopf":"\uD835\uDD4E",
  "wopf":"\uD835\uDD68",
  "wp":"\u2118",
  "wr":"\u2240",
  "wreath":"\u2240",
  "Wscr":"\uD835\uDCB2",
  "wscr":"\uD835\uDCCC",
  "xcap":"\u22C2",
  "xcirc":"\u25EF",
  "xcup":"\u22C3",
  "xdtri":"\u25BD",
  "Xfr":"\uD835\uDD1B",
  "xfr":"\uD835\uDD35",
  "xhArr":"\u27FA",
  "xharr":"\u27F7",
  "Xi":"\u039E",
  "xi":"\u03BE",
  "xlArr":"\u27F8",
  "xlarr":"\u27F5",
  "xmap":"\u27FC",
  "xnis":"\u22FB",
  "xodot":"\u2A00",
  "Xopf":"\uD835\uDD4F",
  "xopf":"\uD835\uDD69",
  "xoplus":"\u2A01",
  "xotime":"\u2A02",
  "xrArr":"\u27F9",
  "xrarr":"\u27F6",
  "Xscr":"\uD835\uDCB3",
  "xscr":"\uD835\uDCCD",
  "xsqcup":"\u2A06",
  "xuplus":"\u2A04",
  "xutri":"\u25B3",
  "xvee":"\u22C1",
  "xwedge":"\u22C0",
  "Yacute":"\u00DD",
  "yacute":"\u00FD",
  "YAcy":"\u042F",
  "yacy":"\u044F",
  "Ycirc":"\u0176",
  "ycirc":"\u0177",
  "Ycy":"\u042B",
  "ycy":"\u044B",
  "yen":"\u00A5",
  "Yfr":"\uD835\uDD1C",
  "yfr":"\uD835\uDD36",
  "YIcy":"\u0407",
  "yicy":"\u0457",
  "Yopf":"\uD835\uDD50",
  "yopf":"\uD835\uDD6A",
  "Yscr":"\uD835\uDCB4",
  "yscr":"\uD835\uDCCE",
  "YUcy":"\u042E",
  "yucy":"\u044E",
  "Yuml":"\u0178",
  "yuml":"\u00FF",
  "Zacute":"\u0179",
  "zacute":"\u017A",
  "Zcaron":"\u017D",
  "zcaron":"\u017E",
  "Zcy":"\u0417",
  "zcy":"\u0437",
  "Zdot":"\u017B",
  "zdot":"\u017C",
  "zeetrf":"\u2128",
  "ZeroWidthSpace":"\u200B",
  "Zeta":"\u0396",
  "zeta":"\u03B6",
  "Zfr":"\u2128",
  "zfr":"\uD835\uDD37",
  "ZHcy":"\u0416",
  "zhcy":"\u0436",
  "zigrarr":"\u21DD",
  "Zopf":"\u2124",
  "zopf":"\uD835\uDD6B",
  "Zscr":"\uD835\uDCB5",
  "zscr":"\uD835\uDCCF",
  "zwj":"\u200D",
  "zwnj":"\u200C"
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/html_blocks.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/html_blocks.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid html blocks names, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#html-blocks



var html_blocks = {};

[
  'article',
  'aside',
  'button',
  'blockquote',
  'body',
  'canvas',
  'caption',
  'col',
  'colgroup',
  'dd',
  'div',
  'dl',
  'dt',
  'embed',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'header',
  'hgroup',
  'hr',
  'iframe',
  'li',
  'map',
  'object',
  'ol',
  'output',
  'p',
  'pre',
  'progress',
  'script',
  'section',
  'style',
  'table',
  'tbody',
  'td',
  'textarea',
  'tfoot',
  'th',
  'tr',
  'thead',
  'ul',
  'video'
].forEach(function (name) { html_blocks[name] = true; });


module.exports = html_blocks;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/html_re.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/html_re.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Regexps to match html elements




function replace(regex, options) {
  regex = regex.source;
  options = options || '';

  return function self(name, val) {
    if (!name) {
      return new RegExp(regex, options);
    }
    val = val.source || val;
    regex = regex.replace(name, val);
    return self;
  };
}


var attr_name     = /[a-zA-Z_:][a-zA-Z0-9:._-]*/;

var unquoted      = /[^"'=<>`\x00-\x20]+/;
var single_quoted = /'[^']*'/;
var double_quoted = /"[^"]*"/;

/*eslint no-spaced-func:0*/
var attr_value  = replace(/(?:unquoted|single_quoted|double_quoted)/)
                    ('unquoted', unquoted)
                    ('single_quoted', single_quoted)
                    ('double_quoted', double_quoted)
                    ();

var attribute   = replace(/(?:\s+attr_name(?:\s*=\s*attr_value)?)/)
                    ('attr_name', attr_name)
                    ('attr_value', attr_value)
                    ();

var open_tag    = replace(/<[A-Za-z][A-Za-z0-9]*attribute*\s*\/?>/)
                    ('attribute', attribute)
                    ();

var close_tag   = /<\/[A-Za-z][A-Za-z0-9]*\s*>/;
var comment     = /<!--([^-]+|[-][^-]+)*-->/;
var processing  = /<[?].*?[?]>/;
var declaration = /<![A-Z]+\s+[^>]*>/;
var cdata       = /<!\[CDATA\[([^\]]+|\][^\]]|\]\][^>])*\]\]>/;

var HTML_TAG_RE = replace(/^(?:open_tag|close_tag|comment|processing|declaration|cdata)/)
  ('open_tag', open_tag)
  ('close_tag', close_tag)
  ('comment', comment)
  ('processing', processing)
  ('declaration', declaration)
  ('cdata', cdata)
  ();


module.exports.HTML_TAG_RE = HTML_TAG_RE;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/url_schemas.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/url_schemas.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid url schemas, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#autolinks




module.exports = [
  'coap',
  'doi',
  'javascript',
  'aaa',
  'aaas',
  'about',
  'acap',
  'cap',
  'cid',
  'crid',
  'data',
  'dav',
  'dict',
  'dns',
  'file',
  'ftp',
  'geo',
  'go',
  'gopher',
  'h323',
  'http',
  'https',
  'iax',
  'icap',
  'im',
  'imap',
  'info',
  'ipp',
  'iris',
  'iris.beep',
  'iris.xpc',
  'iris.xpcs',
  'iris.lwz',
  'ldap',
  'mailto',
  'mid',
  'msrp',
  'msrps',
  'mtqp',
  'mupdate',
  'news',
  'nfs',
  'ni',
  'nih',
  'nntp',
  'opaquelocktoken',
  'pop',
  'pres',
  'rtsp',
  'service',
  'session',
  'shttp',
  'sieve',
  'sip',
  'sips',
  'sms',
  'snmp',
  'soap.beep',
  'soap.beeps',
  'tag',
  'tel',
  'telnet',
  'tftp',
  'thismessage',
  'tn3270',
  'tip',
  'tv',
  'urn',
  'vemmi',
  'ws',
  'wss',
  'xcon',
  'xcon-userid',
  'xmlrpc.beep',
  'xmlrpc.beeps',
  'xmpp',
  'z39.50r',
  'z39.50s',
  'adiumxtra',
  'afp',
  'afs',
  'aim',
  'apt',
  'attachment',
  'aw',
  'beshare',
  'bitcoin',
  'bolo',
  'callto',
  'chrome',
  'chrome-extension',
  'com-eventbrite-attendee',
  'content',
  'cvs',
  'dlna-playsingle',
  'dlna-playcontainer',
  'dtn',
  'dvb',
  'ed2k',
  'facetime',
  'feed',
  'finger',
  'fish',
  'gg',
  'git',
  'gizmoproject',
  'gtalk',
  'hcp',
  'icon',
  'ipn',
  'irc',
  'irc6',
  'ircs',
  'itms',
  'jar',
  'jms',
  'keyparc',
  'lastfm',
  'ldaps',
  'magnet',
  'maps',
  'market',
  'message',
  'mms',
  'ms-help',
  'msnim',
  'mumble',
  'mvn',
  'notes',
  'oid',
  'palm',
  'paparazzi',
  'platform',
  'proxy',
  'psyc',
  'query',
  'res',
  'resource',
  'rmi',
  'rsync',
  'rtmp',
  'secondlife',
  'sftp',
  'sgn',
  'skype',
  'smb',
  'soldat',
  'spotify',
  'ssh',
  'steam',
  'svn',
  'teamspeak',
  'things',
  'udp',
  'unreal',
  'ut2004',
  'ventrilo',
  'view-source',
  'webcal',
  'wtai',
  'wyciwyg',
  'xfire',
  'xri',
  'ymsgr'
];


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Utility functions
 */

function typeOf(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return typeOf(obj) === '[object String]';
}

var hasOwn = Object.prototype.hasOwnProperty;

function has(object, key) {
  return object
    ? hasOwn.call(object, key)
    : false;
}

// Extend objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = [].slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) { return; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

////////////////////////////////////////////////////////////////////////////////

var UNESCAPE_MD_RE = /\\([\\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) { return str; }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) { return false; }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }
  // control codes
  if (c >= 0x00 && c <= 0x08) { return false; }
  if (c === 0x0B) { return false; }
  if (c >= 0x0E && c <= 0x1F) { return false; }
  if (c >= 0x7F && c <= 0x9F) { return false; }
  // out of range
  if (c > 0x10FFFF) { return false; }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var NAMED_ENTITY_RE   = /&([a-z#][a-z0-9]{1,31});/gi;
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
var entities = __webpack_require__(/*! ./entities */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/entities.js");

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  } else if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ?
      parseInt(name.slice(2), 16)
    :
      parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }
  return match;
}

function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(NAMED_ENTITY_RE, replaceEntityPattern);
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

exports.assign            = assign;
exports.isString          = isString;
exports.has               = has;
exports.unescapeMd        = unescapeMd;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint     = fromCodePoint;
exports.replaceEntities   = replaceEntities;
exports.escapeHtml        = escapeHtml;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/commonmark.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/commonmark.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Commonmark default options




module.exports = {
  options: {
    html:         true,         // Enable HTML tags in source
    xhtmlOut:     true,         // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links
    linkTarget:   '',           // set target to open link in

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to 'Â«Â»' for Russian, 'ââ' for German.
    quotes: 'ââââ',

    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'block',
        'inline',
        'references',
        'abbr2'
      ]
    },

    block: {
      rules: [
        'blockquote',
        'code',
        'fences',
        'heading',
        'hr',
        'htmlblock',
        'lheading',
        'list',
        'paragraph'
      ]
    },

    inline: {
      rules: [
        'autolink',
        'backticks',
        'emphasis',
        'entity',
        'escape',
        'htmltag',
        'links',
        'newline',
        'text'
      ]
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/default.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/default.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Remarkable default options




module.exports = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links
    linkTarget:   '',           // set target to open link in

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to 'Â«Â»' for Russian, 'ââ' for German.
    quotes: 'ââââ',

    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'block',
        'inline',
        'references',
        'replacements',
        'linkify',
        'smartquotes',
        'references',
        'abbr2',
        'footnote_tail'
      ]
    },

    block: {
      rules: [
        'blockquote',
        'code',
        'fences',
        'footnote',
        'heading',
        'hr',
        'htmlblock',
        'lheading',
        'list',
        'paragraph',
        'table'
      ]
    },

    inline: {
      rules: [
        'autolink',
        'backticks',
        'del',
        'emphasis',
        'entity',
        'escape',
        'footnote_ref',
        'htmltag',
        'links',
        'newline',
        'text'
      ]
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/full.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/full.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Remarkable default options




module.exports = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links
    linkTarget:   '',           // set target to open link in

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to 'Â«Â»' for Russian, 'ââ' for German.
    quotes:       'ââââ',

    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight:     null,

    maxNesting:    20            // Internal protection, recursion limit
  },

  components: {
    // Don't restrict core/block/inline rules
    core: {},
    block: {},
    inline: {}
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_link.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_link.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replaceEntities = __webpack_require__(/*! ../common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").replaceEntities;

module.exports = function normalizeLink(url) {
  var normalized = replaceEntities(url);
  // We shouldn't care about the result of malformed URIs,
  // and should not throw an exception.
  try {
    normalized = decodeURI(normalized);
  } catch (err) {}
  return encodeURI(normalized);
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_reference.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_reference.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_destination.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_destination.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var normalizeLink = __webpack_require__(/*! ./normalize_link */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_link.js");
var unescapeMd    = __webpack_require__(/*! ../common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").unescapeMd;

/**
 * Parse link destination
 *
 *   - on success it returns a string and updates state.pos;
 *   - on failure it returns null
 *
 * @param  {Object} state
 * @param  {Number} pos
 * @api private
 */

module.exports = function parseLinkDestination(state, pos) {
  var code, level, link,
      start = pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) === 0x3C /* < */) {
    pos++;
    while (pos < max) {
      code = state.src.charCodeAt(pos);
      if (code === 0x0A /* \n */) { return false; }
      if (code === 0x3E /* > */) {
        link = normalizeLink(unescapeMd(state.src.slice(start + 1, pos)));
        if (!state.parser.validateLink(link)) { return false; }
        state.pos = pos + 1;
        state.linkContent = link;
        return true;
      }
      if (code === 0x5C /* \ */ && pos + 1 < max) {
        pos += 2;
        continue;
      }

      pos++;
    }

    // no closing '>'
    return false;
  }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = state.src.charCodeAt(pos);

    if (code === 0x20) { break; }

    if (code > 0x08 && code < 0x0e) { break; }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
      level++;
      if (level > 1) { break; }
    }

    if (code === 0x29 /* ) */) {
      level--;
      if (level < 0) { break; }
    }

    pos++;
  }

  if (start === pos) { return false; }

  link = unescapeMd(state.src.slice(start, pos));
  if (!state.parser.validateLink(link)) { return false; }

  state.linkContent = link;
  state.pos = pos;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_label.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_label.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Parse link labels
 *
 * This function assumes that first character (`[`) already matches;
 * returns the end of the label.
 *
 * @param  {Object} state
 * @param  {Number} start
 * @api private
 */

module.exports = function parseLinkLabel(state, start) {
  var level, found, marker,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos,
      oldFlag = state.isInLabel;

  if (state.isInLabel) { return -1; }

  if (state.labelUnmatchedScopes) {
    state.labelUnmatchedScopes--;
    return -1;
  }

  state.pos = start + 1;
  state.isInLabel = true;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5B /* [ */) {
      level++;
    } else if (marker === 0x5D /* ] */) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }

    state.parser.skipToken(state);
  }

  if (found) {
    labelEnd = state.pos;
    state.labelUnmatchedScopes = 0;
  } else {
    state.labelUnmatchedScopes = level - 1;
  }

  // restore old state
  state.pos = oldPos;
  state.isInLabel = oldFlag;

  return labelEnd;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_title.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_title.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var unescapeMd = __webpack_require__(/*! ../common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").unescapeMd;

/**
 * Parse link title
 *
 *   - on success it returns a string and updates state.pos;
 *   - on failure it returns null
 *
 * @param  {Object} state
 * @param  {Number} pos
 * @api private
 */

module.exports = function parseLinkTitle(state, pos) {
  var code,
      start = pos,
      max = state.posMax,
      marker = state.src.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return false; }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) { marker = 0x29; }

  while (pos < max) {
    code = state.src.charCodeAt(pos);
    if (code === marker) {
      state.pos = pos + 1;
      state.linkContent = unescapeMd(state.src.slice(start + 1, pos));
      return true;
    }
    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    pos++;
  }

  return false;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/index.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var assign       = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").assign;
var Renderer     = __webpack_require__(/*! ./renderer */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/renderer.js");
var ParserCore   = __webpack_require__(/*! ./parser_core */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_core.js");
var ParserBlock  = __webpack_require__(/*! ./parser_block */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_block.js");
var ParserInline = __webpack_require__(/*! ./parser_inline */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_inline.js");
var Ruler        = __webpack_require__(/*! ./ruler */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/ruler.js");

/**
 * Preset configs
 */

var config = {
  'default':    __webpack_require__(/*! ./configs/default */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/default.js"),
  'full':       __webpack_require__(/*! ./configs/full */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/full.js"),
  'commonmark': __webpack_require__(/*! ./configs/commonmark */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/configs/commonmark.js")
};

/**
 * The `StateCore` class manages state.
 *
 * @param {Object} `instance` Remarkable instance
 * @param {String} `str` Markdown string
 * @param {Object} `env`
 */

function StateCore(instance, str, env) {
  this.src = str;
  this.env = env;
  this.options = instance.options;
  this.tokens = [];
  this.inlineMode = false;

  this.inline = instance.inline;
  this.block = instance.block;
  this.renderer = instance.renderer;
  this.typographer = instance.typographer;
}

/**
 * The main `Remarkable` class. Create an instance of
 * `Remarkable` with a `preset` and/or `options`.
 *
 * @param {String} `preset` If no preset is given, `default` is used.
 * @param {Object} `options`
 */

function Remarkable(preset, options) {
  if (typeof preset !== 'string') {
    options = preset;
    preset = 'default';
  }

  this.inline   = new ParserInline();
  this.block    = new ParserBlock();
  this.core     = new ParserCore();
  this.renderer = new Renderer();
  this.ruler    = new Ruler();

  this.options  = {};
  this.configure(config[preset]);
  this.set(options || {});
}

/**
 * Set options as an alternative to passing them
 * to the constructor.
 *
 * ```js
 * md.set({typographer: true});
 * ```
 * @param {Object} `options`
 * @api public
 */

Remarkable.prototype.set = function (options) {
  assign(this.options, options);
};

/**
 * Batch loader for components rules states, and options
 *
 * @param  {Object} `presets`
 */

Remarkable.prototype.configure = function (presets) {
  var self = this;

  if (!presets) { throw new Error('Wrong `remarkable` preset, check name/content'); }
  if (presets.options) { self.set(presets.options); }
  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enable(presets.components[name].rules, true);
      }
    });
  }
};

/**
 * Use a plugin.
 *
 * ```js
 * var md = new Remarkable();
 *
 * md.use(plugin1)
 *   .use(plugin2, opts)
 *   .use(plugin3);
 * ```
 *
 * @param  {Function} `plugin`
 * @param  {Object} `options`
 * @return {Object} `Remarkable` for chaining
 */

Remarkable.prototype.use = function (plugin, options) {
  plugin(this, options);
  return this;
};


/**
 * Parse the input `string` and return a tokens array.
 * Modifies `env` with definitions data.
 *
 * @param  {String} `string`
 * @param  {Object} `env`
 * @return {Array} Array of tokens
 */

Remarkable.prototype.parse = function (str, env) {
  var state = new StateCore(this, str, env);
  this.core.process(state);
  return state.tokens;
};

/**
 * The main `.render()` method that does all the magic :)
 *
 * @param  {String} `string`
 * @param  {Object} `env`
 * @return {String} Rendered HTML.
 */

Remarkable.prototype.render = function (str, env) {
  env = env || {};
  return this.renderer.render(this.parse(str, env), this.options, env);
};

/**
 * Parse the given content `string` as a single string.
 *
 * @param  {String} `string`
 * @param  {Object} `env`
 * @return {Array} Array of tokens
 */

Remarkable.prototype.parseInline = function (str, env) {
  var state = new StateCore(this, str, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};

/**
 * Render a single content `string`, without wrapping it
 * to paragraphs
 *
 * @param  {String} `str`
 * @param  {Object} `env`
 * @return {String}
 */

Remarkable.prototype.renderInline = function (str, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(str, env), this.options, env);
};

/**
 * Expose `Remarkable`
 */

module.exports = Remarkable;

/**
 * Expose `utils`, Useful helper functions for custom
 * rendering.
 */

module.exports.utils = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js");


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_block.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_block.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var Ruler      = __webpack_require__(/*! ./ruler */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/ruler.js");
var StateBlock = __webpack_require__(/*! ./rules_block/state_block */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/state_block.js");

/**
 * Parser rules
 */

var _rules = [
  [ 'code',       __webpack_require__(/*! ./rules_block/code */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/code.js") ],
  [ 'fences',     __webpack_require__(/*! ./rules_block/fences */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/fences.js"),     [ 'paragraph', 'blockquote', 'list' ] ],
  [ 'blockquote', __webpack_require__(/*! ./rules_block/blockquote */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/blockquote.js"), [ 'paragraph', 'blockquote', 'list' ] ],
  [ 'hr',         __webpack_require__(/*! ./rules_block/hr */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/hr.js"),         [ 'paragraph', 'blockquote', 'list' ] ],
  [ 'list',       __webpack_require__(/*! ./rules_block/list */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/list.js"),       [ 'paragraph', 'blockquote' ] ],
  [ 'footnote',   __webpack_require__(/*! ./rules_block/footnote */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/footnote.js"),   [ 'paragraph' ] ],
  [ 'heading',    __webpack_require__(/*! ./rules_block/heading */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/heading.js"),    [ 'paragraph', 'blockquote' ] ],
  [ 'lheading',   __webpack_require__(/*! ./rules_block/lheading */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/lheading.js") ],
  [ 'htmlblock',  __webpack_require__(/*! ./rules_block/htmlblock */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/htmlblock.js"),  [ 'paragraph', 'blockquote' ] ],
  [ 'table',      __webpack_require__(/*! ./rules_block/table */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/table.js"),      [ 'paragraph' ] ],
  [ 'deflist',    __webpack_require__(/*! ./rules_block/deflist */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/deflist.js"),    [ 'paragraph' ] ],
  [ 'paragraph',  __webpack_require__(/*! ./rules_block/paragraph */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/paragraph.js") ]
];

/**
 * Block Parser class
 *
 * @api private
 */

function ParserBlock() {
  this.ruler = new Ruler();
  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], {
      alt: (_rules[i][2] || []).slice()
    });
  }
}

/**
 * Generate tokens for the given input range.
 *
 * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc
 * @param  {Number} `startLine`
 * @param  {Number} `endLine`
 * @api private
 */

ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var rules = this.ruler.getRules('');
  var len = rules.length;
  var line = startLine;
  var hasEmptyLines = false;
  var ok, i;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.tShift[line] < state.blkIndent) {
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight iff we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;

      // two empty lines should stop the parser in list mode
      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) { break; }
      state.line = line;
    }
  }
};

var TABS_SCAN_RE = /[\n\t]/g;
var NEWLINES_RE  = /\r[\n\u0085]|[\u2424\u2028\u0085]/g;
var SPACES_RE    = /\u00a0/g;

/**
 * Tokenize the given `str`.
 *
 * @param  {String} `str` Source string
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @param  {Array} `outTokens`
 * @api private
 */

ParserBlock.prototype.parse = function (str, options, env, outTokens) {
  var state, lineStart = 0, lastTabPos = 0;
  if (!str) { return []; }

  // Normalize spaces
  str = str.replace(SPACES_RE, ' ');

  // Normalize newlines
  str = str.replace(NEWLINES_RE, '\n');

  // Replace tabs with proper number of spaces (1..4)
  if (str.indexOf('\t') >= 0) {
    str = str.replace(TABS_SCAN_RE, function (match, offset) {
      var result;
      if (str.charCodeAt(offset) === 0x0A) {
        lineStart = offset + 1;
        lastTabPos = 0;
        return match;
      }
      result = '    '.slice((offset - lineStart - lastTabPos) % 4);
      lastTabPos = offset - lineStart + 1;
      return result;
    });
  }

  state = new StateBlock(str, this, options, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};

/**
 * Expose `ParserBlock`
 */

module.exports = ParserBlock;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_core.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_core.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var Ruler = __webpack_require__(/*! ./ruler */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/ruler.js");

/**
 * Core parser `rules`
 */

var _rules = [
  [ 'block',          __webpack_require__(/*! ./rules_core/block */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/block.js")          ],
  [ 'abbr',           __webpack_require__(/*! ./rules_core/abbr */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/abbr.js")           ],
  [ 'references',     __webpack_require__(/*! ./rules_core/references */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/references.js")     ],
  [ 'inline',         __webpack_require__(/*! ./rules_core/inline */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/inline.js")         ],
  [ 'footnote_tail',  __webpack_require__(/*! ./rules_core/footnote_tail */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/footnote_tail.js")  ],
  [ 'abbr2',          __webpack_require__(/*! ./rules_core/abbr2 */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/abbr2.js")          ],
  [ 'replacements',   __webpack_require__(/*! ./rules_core/replacements */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/replacements.js")   ],
  [ 'smartquotes',    __webpack_require__(/*! ./rules_core/smartquotes */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/smartquotes.js")    ],
  [ 'linkify',        __webpack_require__(/*! ./rules_core/linkify */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/linkify.js")        ]
];

/**
 * Class for top level (`core`) parser rules
 *
 * @api private
 */

function Core() {
  this.options = {};
  this.ruler = new Ruler();
  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Process rules with the given `state`
 *
 * @param  {Object} `state`
 * @api private
 */

Core.prototype.process = function (state) {
  var i, l, rules;
  rules = this.ruler.getRules('');
  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

/**
 * Expose `Core`
 */

module.exports = Core;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_inline.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/parser_inline.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var Ruler       = __webpack_require__(/*! ./ruler */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/ruler.js");
var StateInline = __webpack_require__(/*! ./rules_inline/state_inline */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/state_inline.js");
var utils       = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js");

/**
 * Inline Parser `rules`
 */

var _rules = [
  [ 'text',            __webpack_require__(/*! ./rules_inline/text */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/text.js") ],
  [ 'newline',         __webpack_require__(/*! ./rules_inline/newline */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/newline.js") ],
  [ 'escape',          __webpack_require__(/*! ./rules_inline/escape */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/escape.js") ],
  [ 'backticks',       __webpack_require__(/*! ./rules_inline/backticks */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/backticks.js") ],
  [ 'del',             __webpack_require__(/*! ./rules_inline/del */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/del.js") ],
  [ 'ins',             __webpack_require__(/*! ./rules_inline/ins */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/ins.js") ],
  [ 'mark',            __webpack_require__(/*! ./rules_inline/mark */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/mark.js") ],
  [ 'emphasis',        __webpack_require__(/*! ./rules_inline/emphasis */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/emphasis.js") ],
  [ 'sub',             __webpack_require__(/*! ./rules_inline/sub */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/sub.js") ],
  [ 'sup',             __webpack_require__(/*! ./rules_inline/sup */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/sup.js") ],
  [ 'links',           __webpack_require__(/*! ./rules_inline/links */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/links.js") ],
  [ 'footnote_inline', __webpack_require__(/*! ./rules_inline/footnote_inline */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/footnote_inline.js") ],
  [ 'footnote_ref',    __webpack_require__(/*! ./rules_inline/footnote_ref */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/footnote_ref.js") ],
  [ 'autolink',        __webpack_require__(/*! ./rules_inline/autolink */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/autolink.js") ],
  [ 'htmltag',         __webpack_require__(/*! ./rules_inline/htmltag */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/htmltag.js") ],
  [ 'entity',          __webpack_require__(/*! ./rules_inline/entity */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/entity.js") ]
];

/**
 * Inline Parser class. Note that link validation is stricter
 * in Remarkable than what is specified by CommonMark. If you
 * want to change this you can use a custom validator.
 *
 * @api private
 */

function ParserInline() {
  this.ruler = new Ruler();
  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  // Can be overridden with a custom validator
  this.validateLink = validateLink;
}

/**
 * Skip a single token by running all rules in validation mode.
 * Returns `true` if any rule reports success.
 *
 * @param  {Object} `state`
 * @api privage
 */

ParserInline.prototype.skipToken = function (state) {
  var rules = this.ruler.getRules('');
  var len = rules.length;
  var pos = state.pos;
  var i, cached_pos;

  if ((cached_pos = state.cacheGet(pos)) > 0) {
    state.pos = cached_pos;
    return;
  }

  for (i = 0; i < len; i++) {
    if (rules[i](state, true)) {
      state.cacheSet(pos, state.pos);
      return;
    }
  }

  state.pos++;
  state.cacheSet(pos, state.pos);
};

/**
 * Generate tokens for the given input range.
 *
 * @param  {Object} `state`
 * @api private
 */

ParserInline.prototype.tokenize = function (state) {
  var rules = this.ruler.getRules('');
  var len = rules.length;
  var end = state.posMax;
  var ok, i;

  while (state.pos < end) {

    // Try all possible rules.
    // On success, the rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true
    for (i = 0; i < len; i++) {
      ok = rules[i](state, false);

      if (ok) {
        break;
      }
    }

    if (ok) {
      if (state.pos >= end) { break; }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * Parse the given input string.
 *
 * @param  {String} `str`
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @param  {Array} `outTokens`
 * @api private
 */

ParserInline.prototype.parse = function (str, options, env, outTokens) {
  var state = new StateInline(str, this, options, env, outTokens);
  this.tokenize(state);
};

/**
 * Validate the given `url` by checking for bad protocols.
 *
 * @param  {String} `url`
 * @return {Boolean}
 */

function validateLink(url) {
  var BAD_PROTOCOLS = [ 'vbscript', 'javascript', 'file', 'data' ];
  var str = url.trim().toLowerCase();
  // Care about digital entities "javascript&#x3A;alert(1)"
  str = utils.replaceEntities(str);
  if (str.indexOf(':') !== -1 && BAD_PROTOCOLS.indexOf(str.split(':')[0]) !== -1) {
    return false;
  }
  return true;
}

/**
 * Expose `ParserInline`
 */

module.exports = ParserInline;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/renderer.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/renderer.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var utils = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js");
var rules = __webpack_require__(/*! ./rules */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules.js");

/**
 * Expose `Renderer`
 */

module.exports = Renderer;

/**
 * Renderer class. Renders HTML and exposes `rules` to allow
 * local modifications.
 */

function Renderer() {
  this.rules = utils.assign({}, rules);

  // exported helper, for custom rules only
  this.getBreak = rules.getBreak;
}

/**
 * Render a string of inline HTML with the given `tokens` and
 * `options`.
 *
 * @param  {Array} `tokens`
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @return {String}
 * @api public
 */

Renderer.prototype.renderInline = function (tokens, options, env) {
  var _rules = this.rules;
  var len = tokens.length, i = 0;
  var result = '';

  while (len--) {
    result += _rules[tokens[i].type](tokens, i++, options, env, this);
  }

  return result;
};

/**
 * Render a string of HTML with the given `tokens` and
 * `options`.
 *
 * @param  {Array} `tokens`
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @return {String}
 * @api public
 */

Renderer.prototype.render = function (tokens, options, env) {
  var _rules = this.rules;
  var len = tokens.length, i = -1;
  var result = '';

  while (++i < len) {
    if (tokens[i].type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else {
      result += _rules[tokens[i].type](tokens, i, options, env, this);
    }
  }
  return result;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/ruler.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/ruler.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Ruler is a helper class for building responsibility chains from
 * parse rules. It allows:
 *
 *   - easy stack rules chains
 *   - getting main chain and named chains content (as arrays of functions)
 *
 * Helper methods, should not be used directly.
 * @api private
 */

function Ruler() {
  // List of added rules. Each element is:
  //
  // { name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ] }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - digital anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

/**
 * Find the index of a rule by `name`.
 *
 * @param  {String} `name`
 * @return {Number} Index of the given `name`
 * @api private
 */

Ruler.prototype.__find__ = function (name) {
  var len = this.__rules__.length;
  var i = -1;

  while (len--) {
    if (this.__rules__[++i].name === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Build the rules lookup cache
 *
 * @api private
 */

Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [ '' ];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler public methods
 * ------------------------------------------------
 */

/**
 * Replace rule function
 *
 * @param  {String} `name` Rule name
 * @param  {Function `fn`
 * @param  {Object} `options`
 * @api private
 */

Ruler.prototype.at = function (name, fn, options) {
  var idx = this.__find__(name);
  var opt = options || {};

  if (idx === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[idx].fn = fn;
  this.__rules__[idx].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Add a rule to the chain before given the `ruleName`.
 *
 * @param  {String}   `beforeName`
 * @param  {String}   `ruleName`
 * @param  {Function} `fn`
 * @param  {Object}   `options`
 * @api private
 */

Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var idx = this.__find__(beforeName);
  var opt = options || {};

  if (idx === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(idx, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Add a rule to the chain after the given `ruleName`.
 *
 * @param  {String}   `afterName`
 * @param  {String}   `ruleName`
 * @param  {Function} `fn`
 * @param  {Object}   `options`
 * @api private
 */

Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var idx = this.__find__(afterName);
  var opt = options || {};

  if (idx === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(idx + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Add a rule to the end of chain.
 *
 * @param  {String}   `ruleName`
 * @param  {Function} `fn`
 * @param  {Object}   `options`
 * @return {String}
 */

Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Enable a rule or list of rules.
 *
 * @param  {String|Array} `list` Name or array of rule names to enable
 * @param  {Boolean} `strict` If `true`, all non listed rules will be disabled.
 * @api private
 */

Ruler.prototype.enable = function (list, strict) {
  list = !Array.isArray(list)
    ? [ list ]
    : list;

  // In strict mode disable all existing rules first
  if (strict) {
    this.__rules__.forEach(function (rule) {
      rule.enabled = false;
    });
  }

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);
    if (idx < 0) {
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
  }, this);

  this.__cache__ = null;
};


/**
 * Disable a rule or list of rules.
 *
 * @param  {String|Array} `list` Name or array of rule names to disable
 * @api private
 */

Ruler.prototype.disable = function (list) {
  list = !Array.isArray(list)
    ? [ list ]
    : list;

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);
    if (idx < 0) {
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
  }, this);

  this.__cache__ = null;
};

/**
 * Get a rules list as an array of functions.
 *
 * @param  {String} `chainName`
 * @return {Object}
 * @api private
 */

Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};

/**
 * Expose `Ruler`
 */

module.exports = Ruler;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var has             = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").has;
var unescapeMd      = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").unescapeMd;
var replaceEntities = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").replaceEntities;
var escapeHtml      = __webpack_require__(/*! ./common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").escapeHtml;

/**
 * Renderer rules cache
 */

var rules = {};

/**
 * Blockquotes
 */

rules.blockquote_open = function(/* tokens, idx, options, env */) {
  return '<blockquote>\n';
};

rules.blockquote_close = function(tokens, idx /*, options, env */) {
  return '</blockquote>' + getBreak(tokens, idx);
};

/**
 * Code
 */

rules.code = function(tokens, idx /*, options, env */) {
  if (tokens[idx].block) {
    return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>' + getBreak(tokens, idx);
  }
  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';
};

/**
 * Fenced code blocks
 */

rules.fence = function(tokens, idx, options, env, instance) {
  var token = tokens[idx];
  var langClass = '';
  var langPrefix = options.langPrefix;
  var langName = '', fences, fenceName;
  var highlighted;

  if (token.params) {

    //
    // ```foo bar
    //
    // Try custom renderer "foo" first. That will simplify overwrite
    // for diagrams, latex, and any other fenced block with custom look
    //

    fences = token.params.split(/\s+/g);
    fenceName = fences.join(' ');

    if (has(instance.rules.fence_custom, fences[0])) {
      return instance.rules.fence_custom[fences[0]](tokens, idx, options, env, instance);
    }

    langName = escapeHtml(replaceEntities(unescapeMd(fenceName)));
    langClass = ' class="' + langPrefix + langName + '"';
  }

  if (options.highlight) {
    highlighted = options.highlight.apply(options.highlight, [ token.content ].concat(fences))
      || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  return '<pre><code' + langClass + '>'
        + highlighted
        + '</code></pre>'
        + getBreak(tokens, idx);
};

rules.fence_custom = {};

/**
 * Headings
 */

rules.heading_open = function(tokens, idx /*, options, env */) {
  return '<h' + tokens[idx].hLevel + '>';
};
rules.heading_close = function(tokens, idx /*, options, env */) {
  return '</h' + tokens[idx].hLevel + '>\n';
};

/**
 * Horizontal rules
 */

rules.hr = function(tokens, idx, options /*, env */) {
  return (options.xhtmlOut ? '<hr />' : '<hr>') + getBreak(tokens, idx);
};

/**
 * Bullets
 */

rules.bullet_list_open = function(/* tokens, idx, options, env */) {
  return '<ul>\n';
};
rules.bullet_list_close = function(tokens, idx /*, options, env */) {
  return '</ul>' + getBreak(tokens, idx);
};

/**
 * List items
 */

rules.list_item_open = function(/* tokens, idx, options, env */) {
  return '<li>';
};
rules.list_item_close = function(/* tokens, idx, options, env */) {
  return '</li>\n';
};

/**
 * Ordered list items
 */

rules.ordered_list_open = function(tokens, idx /*, options, env */) {
  var token = tokens[idx];
  var order = token.order > 1 ? ' start="' + token.order + '"' : '';
  return '<ol' + order + '>\n';
};
rules.ordered_list_close = function(tokens, idx /*, options, env */) {
  return '</ol>' + getBreak(tokens, idx);
};

/**
 * Paragraphs
 */

rules.paragraph_open = function(tokens, idx /*, options, env */) {
  return tokens[idx].tight ? '' : '<p>';
};
rules.paragraph_close = function(tokens, idx /*, options, env */) {
  var addBreak = !(tokens[idx].tight && idx && tokens[idx - 1].type === 'inline' && !tokens[idx - 1].content);
  return (tokens[idx].tight ? '' : '</p>') + (addBreak ? getBreak(tokens, idx) : '');
};

/**
 * Links
 */

rules.link_open = function(tokens, idx, options /* env */) {
  var title = tokens[idx].title ? (' title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '"') : '';
  var target = options.linkTarget ? (' target="' + options.linkTarget + '"') : '';
  return '<a href="' + escapeHtml(tokens[idx].href) + '"' + title + target + '>';
};
rules.link_close = function(/* tokens, idx, options, env */) {
  return '</a>';
};

/**
 * Images
 */

rules.image = function(tokens, idx, options /*, env */) {
  var src = ' src="' + escapeHtml(tokens[idx].src) + '"';
  var title = tokens[idx].title ? (' title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '"') : '';
  var alt = ' alt="' + (tokens[idx].alt ? escapeHtml(replaceEntities(unescapeMd(tokens[idx].alt))) : '') + '"';
  var suffix = options.xhtmlOut ? ' /' : '';
  return '<img' + src + alt + title + suffix + '>';
};

/**
 * Tables
 */

rules.table_open = function(/* tokens, idx, options, env */) {
  return '<table>\n';
};
rules.table_close = function(/* tokens, idx, options, env */) {
  return '</table>\n';
};
rules.thead_open = function(/* tokens, idx, options, env */) {
  return '<thead>\n';
};
rules.thead_close = function(/* tokens, idx, options, env */) {
  return '</thead>\n';
};
rules.tbody_open = function(/* tokens, idx, options, env */) {
  return '<tbody>\n';
};
rules.tbody_close = function(/* tokens, idx, options, env */) {
  return '</tbody>\n';
};
rules.tr_open = function(/* tokens, idx, options, env */) {
  return '<tr>';
};
rules.tr_close = function(/* tokens, idx, options, env */) {
  return '</tr>\n';
};
rules.th_open = function(tokens, idx /*, options, env */) {
  var token = tokens[idx];
  return '<th'
    + (token.align ? ' style="text-align:' + token.align + '"' : '')
    + '>';
};
rules.th_close = function(/* tokens, idx, options, env */) {
  return '</th>';
};
rules.td_open = function(tokens, idx /*, options, env */) {
  var token = tokens[idx];
  return '<td'
    + (token.align ? ' style="text-align:' + token.align + '"' : '')
    + '>';
};
rules.td_close = function(/* tokens, idx, options, env */) {
  return '</td>';
};

/**
 * Bold
 */

rules.strong_open = function(/* tokens, idx, options, env */) {
  return '<strong>';
};
rules.strong_close = function(/* tokens, idx, options, env */) {
  return '</strong>';
};

/**
 * Italicize
 */

rules.em_open = function(/* tokens, idx, options, env */) {
  return '<em>';
};
rules.em_close = function(/* tokens, idx, options, env */) {
  return '</em>';
};

/**
 * Strikethrough
 */

rules.del_open = function(/* tokens, idx, options, env */) {
  return '<del>';
};
rules.del_close = function(/* tokens, idx, options, env */) {
  return '</del>';
};

/**
 * Insert
 */

rules.ins_open = function(/* tokens, idx, options, env */) {
  return '<ins>';
};
rules.ins_close = function(/* tokens, idx, options, env */) {
  return '</ins>';
};

/**
 * Highlight
 */

rules.mark_open = function(/* tokens, idx, options, env */) {
  return '<mark>';
};
rules.mark_close = function(/* tokens, idx, options, env */) {
  return '</mark>';
};

/**
 * Super- and sub-script
 */

rules.sub = function(tokens, idx /*, options, env */) {
  return '<sub>' + escapeHtml(tokens[idx].content) + '</sub>';
};
rules.sup = function(tokens, idx /*, options, env */) {
  return '<sup>' + escapeHtml(tokens[idx].content) + '</sup>';
};

/**
 * Breaks
 */

rules.hardbreak = function(tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
rules.softbreak = function(tokens, idx, options /*, env */) {
  return options.breaks ? (options.xhtmlOut ? '<br />\n' : '<br>\n') : '\n';
};

/**
 * Text
 */

rules.text = function(tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

/**
 * Content
 */

rules.htmlblock = function(tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
rules.htmltag = function(tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * Abbreviations, initialism
 */

rules.abbr_open = function(tokens, idx /*, options, env */) {
  return '<abbr title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '">';
};
rules.abbr_close = function(/* tokens, idx, options, env */) {
  return '</abbr>';
};

/**
 * Footnotes
 */

rules.footnote_ref = function(tokens, idx) {
  var n = Number(tokens[idx].id + 1).toString();
  var id = 'fnref' + n;
  if (tokens[idx].subId > 0) {
    id += ':' + tokens[idx].subId;
  }
  return '<sup class="footnote-ref"><a href="#fn' + n + '" id="' + id + '">[' + n + ']</a></sup>';
};
rules.footnote_block_open = function(tokens, idx, options) {
  var hr = options.xhtmlOut
    ? '<hr class="footnotes-sep" />\n'
    : '<hr class="footnotes-sep">\n';
  return hr + '<section class="footnotes">\n<ol class="footnotes-list">\n';
};
rules.footnote_block_close = function() {
  return '</ol>\n</section>\n';
};
rules.footnote_open = function(tokens, idx) {
  var id = Number(tokens[idx].id + 1).toString();
  return '<li id="fn' + id + '"  class="footnote-item">';
};
rules.footnote_close = function() {
  return '</li>\n';
};
rules.footnote_anchor = function(tokens, idx) {
  var n = Number(tokens[idx].id + 1).toString();
  var id = 'fnref' + n;
  if (tokens[idx].subId > 0) {
    id += ':' + tokens[idx].subId;
  }
  return ' <a href="#' + id + '" class="footnote-backref">â©</a>';
};

/**
 * Definition lists
 */

rules.dl_open = function() {
  return '<dl>\n';
};
rules.dt_open = function() {
  return '<dt>';
};
rules.dd_open = function() {
  return '<dd>';
};
rules.dl_close = function() {
  return '</dl>\n';
};
rules.dt_close = function() {
  return '</dt>\n';
};
rules.dd_close = function() {
  return '</dd>\n';
};

/**
 * Helper functions
 */

function nextToken(tokens, idx) {
  if (++idx >= tokens.length - 2) {
    return idx;
  }
  if ((tokens[idx].type === 'paragraph_open' && tokens[idx].tight) &&
      (tokens[idx + 1].type === 'inline' && tokens[idx + 1].content.length === 0) &&
      (tokens[idx + 2].type === 'paragraph_close' && tokens[idx + 2].tight)) {
    return nextToken(tokens, idx + 2);
  }
  return idx;
}

/**
 * Check to see if `\n` is needed before the next token.
 *
 * @param  {Array} `tokens`
 * @param  {Number} `idx`
 * @return {String} Empty string or newline
 * @api private
 */

var getBreak = rules.getBreak = function getBreak(tokens, idx) {
  idx = nextToken(tokens, idx);
  if (idx < tokens.length && tokens[idx].type === 'list_item_close') {
    return '';
  }
  return '\n';
};

/**
 * Expose `rules`
 */

module.exports = rules;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/blockquote.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/blockquote.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Block quotes




module.exports = function blockquote(state, startLine, endLine, silent) {
  var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines,
      terminatorRules,
      i, l, terminate,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos > max) { return false; }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }

  if (state.level >= state.options.maxNesting) { return false; }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) { return true; }

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20) { pos++; }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  oldBMarks = [ state.bMarks[startLine] ];
  state.bMarks[startLine] = pos;

  // check if we have an empty blockquote
  pos = pos < max ? state.skipSpaces(pos) : pos;
  lastLineEmpty = pos >= max;

  oldTShift = [ state.tShift[startLine] ];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.parser.ruler.getRules('blockquote');

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E/* > */) {
      // This line is inside the blockquote.

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20) { pos++; }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      pos = pos < max ? state.skipSpaces(pos) : pos;
      lastLineEmpty = pos >= max;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) { break; }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }

    oldBMarks.push(state.bMarks[nextLine]);
    oldTShift.push(state.tShift[nextLine]);

    // A negative number means that this is a paragraph continuation;
    //
    // Any negative number will do the job here, but it's better for it
    // to be large enough to make any bugs obvious.
    state.tShift[nextLine] = -1337;
  }

  oldParentType = state.parentType;
  state.parentType = 'blockquote';
  state.tokens.push({
    type: 'blockquote_open',
    lines: lines = [ startLine, 0 ],
    level: state.level++
  });
  state.parser.tokenize(state, startLine, nextLine);
  state.tokens.push({
    type: 'blockquote_close',
    level: --state.level
  });
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
  }
  state.blkIndent = oldIndent;

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/code.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/code.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Code block (4 spaces padded)




module.exports = function code(state, startLine, endLine/*, silent*/) {
  var nextLine, last;

  if (state.tShift[startLine] - state.blkIndent < 4) { return false; }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.tShift[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = nextLine;
  state.tokens.push({
    type: 'code',
    content: state.getLines(startLine, last, 4 + state.blkIndent, true),
    block: true,
    lines: [ startLine, state.line ],
    level: state.level
  });

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/deflist.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/deflist.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Definition lists




// Search `[:~][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipMarker(state, line) {
  var pos, marker,
      start = state.bMarks[line] + state.tShift[line],
      max = state.eMarks[line];

  if (start >= max) { return -1; }

  // Check bullet
  marker = state.src.charCodeAt(start++);
  if (marker !== 0x7E/* ~ */ && marker !== 0x3A/* : */) { return -1; }

  pos = state.skipSpaces(start);

  // require space after ":"
  if (start === pos) { return -1; }

  // no empty definitions, e.g. "  : "
  if (pos >= max) { return -1; }

  return pos;
}

function markTightParagraphs(state, idx) {
  var i, l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].tight = true;
      state.tokens[i].tight = true;
      i += 2;
    }
  }
}

module.exports = function deflist(state, startLine, endLine, silent) {
  var contentStart,
      ddLine,
      dtLine,
      itemLines,
      listLines,
      listTokIdx,
      nextLine,
      oldIndent,
      oldDDIndent,
      oldParentType,
      oldTShift,
      oldTight,
      prevEmptyEnd,
      tight;

  if (silent) {
    // quirk: validation mode validates a dd block only, not a whole deflist
    if (state.ddIndent < 0) { return false; }
    return skipMarker(state, startLine) >= 0;
  }

  nextLine = startLine + 1;
  if (state.isEmpty(nextLine)) {
    if (++nextLine > endLine) { return false; }
  }

  if (state.tShift[nextLine] < state.blkIndent) { return false; }
  contentStart = skipMarker(state, nextLine);
  if (contentStart < 0) { return false; }

  if (state.level >= state.options.maxNesting) { return false; }

  // Start list
  listTokIdx = state.tokens.length;

  state.tokens.push({
    type: 'dl_open',
    lines: listLines = [ startLine, 0 ],
    level: state.level++
  });

  //
  // Iterate list items
  //

  dtLine = startLine;
  ddLine = nextLine;

  // One definition list can contain multiple DTs,
  // and one DT can be followed by multiple DDs.
  //
  // Thus, there is two loops here, and label is
  // needed to break out of the second one
  //
  /*eslint no-labels:0,block-scoped-var:0*/
  OUTER:
  for (;;) {
    tight = true;
    prevEmptyEnd = false;

    state.tokens.push({
      type: 'dt_open',
      lines: [ dtLine, dtLine ],
      level: state.level++
    });
    state.tokens.push({
      type: 'inline',
      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),
      level: state.level + 1,
      lines: [ dtLine, dtLine ],
      children: []
    });
    state.tokens.push({
      type: 'dt_close',
      level: --state.level
    });

    for (;;) {
      state.tokens.push({
        type: 'dd_open',
        lines: itemLines = [ nextLine, 0 ],
        level: state.level++
      });

      oldTight = state.tight;
      oldDDIndent = state.ddIndent;
      oldIndent = state.blkIndent;
      oldTShift = state.tShift[ddLine];
      oldParentType = state.parentType;
      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;
      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];
      state.tight = true;
      state.parentType = 'deflist';

      state.parser.tokenize(state, ddLine, endLine, true);

      // If any of list item is tight, mark list as tight
      if (!state.tight || prevEmptyEnd) {
        tight = false;
      }
      // Item become loose if finish with empty line,
      // but we should filter last element, because it means list finish
      prevEmptyEnd = (state.line - ddLine) > 1 && state.isEmpty(state.line - 1);

      state.tShift[ddLine] = oldTShift;
      state.tight = oldTight;
      state.parentType = oldParentType;
      state.blkIndent = oldIndent;
      state.ddIndent = oldDDIndent;

      state.tokens.push({
        type: 'dd_close',
        level: --state.level
      });

      itemLines[1] = nextLine = state.line;

      if (nextLine >= endLine) { break OUTER; }

      if (state.tShift[nextLine] < state.blkIndent) { break OUTER; }
      contentStart = skipMarker(state, nextLine);
      if (contentStart < 0) { break; }

      ddLine = nextLine;

      // go to the next loop iteration:
      // insert DD tag and repeat checking
    }

    if (nextLine >= endLine) { break; }
    dtLine = nextLine;

    if (state.isEmpty(dtLine)) { break; }
    if (state.tShift[dtLine] < state.blkIndent) { break; }

    ddLine = dtLine + 1;
    if (ddLine >= endLine) { break; }
    if (state.isEmpty(ddLine)) { ddLine++; }
    if (ddLine >= endLine) { break; }

    if (state.tShift[ddLine] < state.blkIndent) { break; }
    contentStart = skipMarker(state, ddLine);
    if (contentStart < 0) { break; }

    // go to the next loop iteration:
    // insert DT and DD tags and repeat checking
  }

  // Finilize list
  state.tokens.push({
    type: 'dl_close',
    level: --state.level
  });
  listLines[1] = nextLine;

  state.line = nextLine;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/fences.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/fences.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// fences (``` lang, ~~~ lang)




module.exports = function fences(state, startLine, endLine, silent) {
  var marker, len, params, nextLine, mem,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos + 3 > max) { return false; }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {
    return false;
  }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) { return false; }

  params = state.src.slice(pos, max).trim();

  if (params.indexOf('`') >= 0) { return false; }

  // Since start is found, we can report success here in validation mode
  if (silent) { return true; }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.tShift[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) { continue; }

    if (state.tShift[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) { continue; }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) { continue; }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.tShift[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);
  state.tokens.push({
    type: 'fence',
    params: params,
    content: state.getLines(startLine + 1, nextLine, len, true),
    lines: [ startLine, state.line ],
    level: state.level
  });

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/footnote.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/footnote.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process footnote reference list




module.exports = function footnote(state, startLine, endLine, silent) {
  var oldBMark, oldTShift, oldParentType, pos, label,
      start = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // line should be at least 5 chars - "[^x]:"
  if (start + 4 > max) { return false; }

  if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  for (pos = start + 2; pos < max; pos++) {
    if (state.src.charCodeAt(pos) === 0x20) { return false; }
    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {
      break;
    }
  }

  if (pos === start + 2) { return false; } // no empty footnote labels
  if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A /* : */) { return false; }
  if (silent) { return true; }
  pos++;

  if (!state.env.footnotes) { state.env.footnotes = {}; }
  if (!state.env.footnotes.refs) { state.env.footnotes.refs = {}; }
  label = state.src.slice(start + 2, pos - 2);
  state.env.footnotes.refs[':' + label] = -1;

  state.tokens.push({
    type: 'footnote_reference_open',
    label: label,
    level: state.level++
  });

  oldBMark = state.bMarks[startLine];
  oldTShift = state.tShift[startLine];
  oldParentType = state.parentType;
  state.tShift[startLine] = state.skipSpaces(pos) - pos;
  state.bMarks[startLine] = pos;
  state.blkIndent += 4;
  state.parentType = 'footnote';

  if (state.tShift[startLine] < state.blkIndent) {
    state.tShift[startLine] += state.blkIndent;
    state.bMarks[startLine] -= state.blkIndent;
  }

  state.parser.tokenize(state, startLine, endLine, true);

  state.parentType = oldParentType;
  state.blkIndent -= 4;
  state.tShift[startLine] = oldTShift;
  state.bMarks[startLine] = oldBMark;

  state.tokens.push({
    type: 'footnote_reference_close',
    level: --state.level
  });

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/heading.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/heading.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// heading (#, ##, ...)




module.exports = function heading(state, startLine, endLine, silent) {
  var ch, level, tmp,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos >= max) { return false; }

  ch  = state.src.charCodeAt(pos);

  if (ch !== 0x23/* # */ || pos >= max) { return false; }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23/* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || (pos < max && ch !== 0x20/* space */)) { return false; }

  if (silent) { return true; }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipCharsBack(max, 0x20, pos); // space
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && state.src.charCodeAt(tmp - 1) === 0x20/* space */) {
    max = tmp;
  }

  state.line = startLine + 1;

  state.tokens.push({ type: 'heading_open',
    hLevel: level,
    lines: [ startLine, state.line ],
    level: state.level
  });

  // only if header is not empty
  if (pos < max) {
    state.tokens.push({
      type: 'inline',
      content: state.src.slice(pos, max).trim(),
      level: state.level + 1,
      lines: [ startLine, state.line ],
      children: []
    });
  }
  state.tokens.push({ type: 'heading_close', hLevel: level, level: state.level });

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/hr.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/hr.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Horizontal rule




module.exports = function hr(state, startLine, endLine, silent) {
  var marker, cnt, ch,
      pos = state.bMarks[startLine],
      max = state.eMarks[startLine];

  pos += state.tShift[startLine];

  if (pos > max) { return false; }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x5F/* _ */) {
    return false;
  }

  // markers can be mixed with spaces, but there should be at least 3 one

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && ch !== 0x20/* space */) { return false; }
    if (ch === marker) { cnt++; }
  }

  if (cnt < 3) { return false; }

  if (silent) { return true; }

  state.line = startLine + 1;
  state.tokens.push({
    type: 'hr',
    lines: [ startLine, state.line ],
    level: state.level
  });

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/htmlblock.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/htmlblock.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML block




var block_names = __webpack_require__(/*! ../common/html_blocks */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/html_blocks.js");


var HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\s\/>]/;
var HTML_TAG_CLOSE_RE = /^<\/([a-zA-Z]{1,15})[\s>]/;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
}

module.exports = function htmlblock(state, startLine, endLine, silent) {
  var ch, match, nextLine,
      pos = state.bMarks[startLine],
      max = state.eMarks[startLine],
      shift = state.tShift[startLine];

  pos += shift;

  if (!state.options.html) { return false; }

  if (shift > 3 || pos + 2 >= max) { return false; }

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  ch = state.src.charCodeAt(pos + 1);

  if (ch === 0x21/* ! */ || ch === 0x3F/* ? */) {
    // Directive start / comment start / processing instruction start
    if (silent) { return true; }

  } else if (ch === 0x2F/* / */ || isLetter(ch)) {

    // Probably start or end of tag
    if (ch === 0x2F/* \ */) {
      // closing tag
      match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);
      if (!match) { return false; }
    } else {
      // opening tag
      match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);
      if (!match) { return false; }
    }
    // Make sure tag name is valid
    if (block_names[match[1].toLowerCase()] !== true) { return false; }
    if (silent) { return true; }

  } else {
    return false;
  }

  // If we are here - we detected HTML block.
  // Let's roll down till empty line (block end).
  nextLine = startLine + 1;
  while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {
    nextLine++;
  }

  state.line = nextLine;
  state.tokens.push({
    type: 'htmlblock',
    level: state.level,
    lines: [ startLine, state.line ],
    content: state.getLines(startLine, nextLine, 0, true)
  });

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/lheading.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/lheading.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// lheading (---, ===)




module.exports = function lheading(state, startLine, endLine/*, silent*/) {
  var marker, pos, max,
      next = startLine + 1;

  if (next >= endLine) { return false; }
  if (state.tShift[next] < state.blkIndent) { return false; }

  // Scan next line

  if (state.tShift[next] - state.blkIndent > 3) { return false; }

  pos = state.bMarks[next] + state.tShift[next];
  max = state.eMarks[next];

  if (pos >= max) { return false; }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x2D/* - */ && marker !== 0x3D/* = */) { return false; }

  pos = state.skipChars(pos, marker);

  pos = state.skipSpaces(pos);

  if (pos < max) { return false; }

  pos = state.bMarks[startLine] + state.tShift[startLine];

  state.line = next + 1;
  state.tokens.push({
    type: 'heading_open',
    hLevel: marker === 0x3D/* = */ ? 1 : 2,
    lines: [ startLine, state.line ],
    level: state.level
  });
  state.tokens.push({
    type: 'inline',
    content: state.src.slice(pos, state.eMarks[startLine]).trim(),
    level: state.level + 1,
    lines: [ startLine, state.line - 1 ],
    children: []
  });
  state.tokens.push({
    type: 'heading_close',
    hLevel: marker === 0x3D/* = */ ? 1 : 2,
    level: state.level
  });

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/list.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/list.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Lists




// Search `[-+*][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  if (pos >= max) { return -1; }

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x2B/* + */) {
    return -1;
  }

  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {
    // " 1.test " - is not a list item
    return -1;
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos + 1 >= max) { return -1; }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }

  for (;;) {
    // EOL -> fail
    if (pos >= max) { return -1; }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {
      continue;
    }

    // found valid marker
    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {
      break;
    }

    return -1;
  }


  if (pos < max && state.src.charCodeAt(pos) !== 0x20/* space */) {
    // " 1.test " - is not a list item
    return -1;
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i, l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].tight = true;
      state.tokens[i].tight = true;
      i += 2;
    }
  }
}


module.exports = function list(state, startLine, endLine, silent) {
  var nextLine,
      indent,
      oldTShift,
      oldIndent,
      oldTight,
      oldParentType,
      start,
      posAfterMarker,
      max,
      indentAfterMarker,
      markerValue,
      markerCharCode,
      isOrdered,
      contentStart,
      listTokIdx,
      prevEmptyEnd,
      listLines,
      itemLines,
      tight = true,
      terminatorRules,
      i, l, terminate;

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  if (state.level >= state.options.maxNesting) { return false; }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) { return true; }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    state.tokens.push({
      type: 'ordered_list_open',
      order: markerValue,
      lines: listLines = [ startLine, 0 ],
      level: state.level++
    });

  } else {
    state.tokens.push({
      type: 'bullet_list_open',
      lines: listLines = [ startLine, 0 ],
      level: state.level++
    });
  }

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.parser.ruler.getRules('list');

  while (nextLine < endLine) {
    contentStart = state.skipSpaces(posAfterMarker);
    max = state.eMarks[nextLine];

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = contentStart - posAfterMarker;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) { indentAfterMarker = 1; }

    // If indent is less than 1, assume that it's one, example:
    //  "-\n  test"
    if (indentAfterMarker < 1) { indentAfterMarker = 1; }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = (posAfterMarker - state.bMarks[nextLine]) + indentAfterMarker;

    // Run subparser & write tokens
    state.tokens.push({
      type: 'list_item_open',
      lines: itemLines = [ startLine, 0 ],
      level: state.level++
    });

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldParentType = state.parentType;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.parentType = 'list';

    state.parser.tokenize(state, startLine, endLine, true);

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.tight = oldTight;
    state.parentType = oldParentType;

    state.tokens.push({
      type: 'list_item_close',
      level: --state.level
    });

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) { break; }

    if (state.isEmpty(nextLine)) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.tShift[nextLine] < state.blkIndent) { break; }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }
  }

  // Finilize list
  state.tokens.push({
    type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',
    level: --state.level
  });
  listLines[1] = nextLine;

  state.line = nextLine;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/paragraph.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/paragraph.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Paragraph




module.exports = function paragraph(state, startLine/*, endLine*/) {
  var endLine, content, terminate, i, l,
      nextLine = startLine + 1,
      terminatorRules;

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  if (nextLine < endLine && !state.isEmpty(nextLine)) {
    terminatorRules = state.parser.ruler.getRules('paragraph');

    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      // this would be a code block normally, but after paragraph
      // it's considered a lazy continuation regardless of what's there
      if (state.tShift[nextLine] - state.blkIndent > 3) { continue; }

      // Some tags can terminate paragraph without empty line.
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) { break; }
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;
  if (content.length) {
    state.tokens.push({
      type: 'paragraph_open',
      tight: false,
      lines: [ startLine, state.line ],
      level: state.level
    });
    state.tokens.push({
      type: 'inline',
      content: content,
      level: state.level + 1,
      lines: [ startLine, state.line ],
      children: []
    });
    state.tokens.push({
      type: 'paragraph_close',
      tight: false,
      level: state.level
    });
  }

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/state_block.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/state_block.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parser state class




function StateBlock(src, parser, options, env, tokens) {
  var ch, s, start, pos, len, indent, indent_found;

  this.src = src;

  // Shortcuts to simplify nested calls
  this.parser = parser;

  this.options = options;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = [];  // line begin offsets for fast jumps
  this.eMarks = [];  // line end offsets for fast jumps
  this.tShift = [];  // indent for each line

  // block parser variables
  this.blkIndent  = 0; // required block content indent
                       // (for example, if we are in list)
  this.line       = 0; // line index in src
  this.lineMax    = 0; // lines count
  this.tight      = false;  // loose/tight mode for lists
  this.parentType = 'root'; // if `list`, block parser stops on two newlines
  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent = 0;
  indent_found = false;

  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (ch === 0x20/* space */) {
        indent++;
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) { pos++; }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);

      indent_found = false;
      indent = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== 0x20/* space */) { break; }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) { break; }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) { return pos; }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i, first, last, queue, shift,
      line = begin;

  if (begin >= end) {
    return '';
  }

  // Opt: don't use push queue for single line;
  if (line + 1 === end) {
    first = this.bMarks[line] + Math.min(this.tShift[line], indent);
    last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];
    return this.src.slice(first, last);
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    shift = this.tShift[line];
    if (shift > indent) { shift = indent; }
    if (shift < 0) { shift = 0; }

    first = this.bMarks[line] + shift;

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    queue[i] = this.src.slice(first, last);
  }

  return queue.join('');
};


module.exports = StateBlock;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/table.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_block/table.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GFM table, non-standard




function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, rows, cell,
      aligns, t, tableLines, tbodyLines;

  // should have at least three lines
  if (startLine + 2 > endLine) { return false; }

  nextLine = startLine + 1;

  if (state.tShift[nextLine] < state.blkIndent) { return false; }

  // first character of the second line should be '|' or '-'

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) { return false; }

  ch = state.src.charCodeAt(pos);
  if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }

  lineText = getLine(state, startLine + 1);
  if (!/^[-:| ]+$/.test(lineText)) { return false; }

  rows = lineText.split('|');
  if (rows <= 2) { return false; }
  aligns = [];
  for (i = 0; i < rows.length; i++) {
    t = rows[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === rows.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) { return false; }
    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {
      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');
    } else if (t.charCodeAt(0) === 0x3A/* : */) {
      aligns.push('left');
    } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) { return false; }
  rows = lineText.replace(/^\||\|$/g, '').split('|');
  if (aligns.length !== rows.length) { return false; }
  if (silent) { return true; }

  state.tokens.push({
    type: 'table_open',
    lines: tableLines = [ startLine, 0 ],
    level: state.level++
  });
  state.tokens.push({
    type: 'thead_open',
    lines: [ startLine, startLine + 1 ],
    level: state.level++
  });

  state.tokens.push({
    type: 'tr_open',
    lines: [ startLine, startLine + 1 ],
    level: state.level++
  });
  for (i = 0; i < rows.length; i++) {
    state.tokens.push({
      type: 'th_open',
      align: aligns[i],
      lines: [ startLine, startLine + 1 ],
      level: state.level++
    });
    state.tokens.push({
      type: 'inline',
      content: rows[i].trim(),
      lines: [ startLine, startLine + 1 ],
      level: state.level,
      children: []
    });
    state.tokens.push({ type: 'th_close', level: --state.level });
  }
  state.tokens.push({ type: 'tr_close', level: --state.level });
  state.tokens.push({ type: 'thead_close', level: --state.level });

  state.tokens.push({
    type: 'tbody_open',
    lines: tbodyLines = [ startLine + 2, 0 ],
    level: state.level++
  });

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.tShift[nextLine] < state.blkIndent) { break; }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) { break; }
    rows = lineText.replace(/^\||\|$/g, '').split('|');

    state.tokens.push({ type: 'tr_open', level: state.level++ });
    for (i = 0; i < rows.length; i++) {
      state.tokens.push({ type: 'td_open', align: aligns[i], level: state.level++ });
      // 0x7c === '|'
      cell = rows[i].substring(
          rows[i].charCodeAt(0) === 0x7c ? 1 : 0,
          rows[i].charCodeAt(rows[i].length - 1) === 0x7c ? rows[i].length - 1 : rows[i].length
      ).trim();
      state.tokens.push({
        type: 'inline',
        content: cell,
        level: state.level,
        children: []
      });
      state.tokens.push({ type: 'td_close', level: --state.level });
    }
    state.tokens.push({ type: 'tr_close', level: --state.level });
  }
  state.tokens.push({ type: 'tbody_close', level: --state.level });
  state.tokens.push({ type: 'table_close', level: --state.level });

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/abbr.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/abbr.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse abbreviation definitions, i.e. `*[abbr]: description`
//




var StateInline    = __webpack_require__(/*! ../rules_inline/state_inline */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/state_inline.js");
var parseLinkLabel = __webpack_require__(/*! ../helpers/parse_link_label */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_label.js");


function parseAbbr(str, parserInline, options, env) {
  var state, labelEnd, pos, max, label, title;

  if (str.charCodeAt(0) !== 0x2A/* * */) { return -1; }
  if (str.charCodeAt(1) !== 0x5B/* [ */) { return -1; }

  if (str.indexOf(']:') === -1) { return -1; }

  state = new StateInline(str, parserInline, options, env, []);
  labelEnd = parseLinkLabel(state, 1);

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }

  max = state.posMax;

  // abbr title is always one line, so looking for ending "\n" here
  for (pos = labelEnd + 2; pos < max; pos++) {
    if (state.src.charCodeAt(pos) === 0x0A) { break; }
  }

  label = str.slice(2, labelEnd);
  title = str.slice(labelEnd + 2, pos).trim();
  if (title.length === 0) { return -1; }
  if (!env.abbreviations) { env.abbreviations = {}; }
  // prepend ':' to avoid conflict with Object.prototype members
  if (typeof env.abbreviations[':' + label] === 'undefined') {
    env.abbreviations[':' + label] = title;
  }

  return pos;
}

module.exports = function abbr(state) {
  var tokens = state.tokens, i, l, content, pos;

  if (state.inlineMode) {
    return;
  }

  // Parse inlines
  for (i = 1, l = tokens.length - 1; i < l; i++) {
    if (tokens[i - 1].type === 'paragraph_open' &&
        tokens[i].type === 'inline' &&
        tokens[i + 1].type === 'paragraph_close') {

      content = tokens[i].content;
      while (content.length) {
        pos = parseAbbr(content, state.inline, state.options, state.env);
        if (pos < 0) { break; }
        content = content.slice(pos).trim();
      }

      tokens[i].content = content;
      if (!content.length) {
        tokens[i - 1].tight = true;
        tokens[i + 1].tight = true;
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/abbr2.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/abbr2.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Enclose abbreviations in <abbr> tags
//



var PUNCT_CHARS = ' \n()[]\'".,!?-';


// from Google closure library
// http://closure-library.googlecode.com/git-history/docs/local_closure_goog_string_string.js.source.html#line1021
function regEscape(s) {
  return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1');
}


module.exports = function abbr2(state) {
  var i, j, l, tokens, token, text, nodes, pos, level, reg, m, regText,
      blockTokens = state.tokens;

  if (!state.env.abbreviations) { return; }
  if (!state.env.abbrRegExp) {
    regText = '(^|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])'
            + '(' + Object.keys(state.env.abbreviations).map(function (x) {
                      return x.substr(1);
                    }).sort(function (a, b) {
                      return b.length - a.length;
                    }).map(regEscape).join('|') + ')'
            + '($|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])';
    state.env.abbrRegExp = new RegExp(regText, 'g');
  }
  reg = state.env.abbrRegExp;

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline') { continue; }
    tokens = blockTokens[j].children;

    // We scan from the end, to keep position when new tags added.
    for (i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i];
      if (token.type !== 'text') { continue; }

      pos = 0;
      text = token.content;
      reg.lastIndex = 0;
      level = token.level;
      nodes = [];

      while ((m = reg.exec(text))) {
        if (reg.lastIndex > pos) {
          nodes.push({
            type: 'text',
            content: text.slice(pos, m.index + m[1].length),
            level: level
          });
        }

        nodes.push({
          type: 'abbr_open',
          title: state.env.abbreviations[':' + m[2]],
          level: level++
        });
        nodes.push({
          type: 'text',
          content: m[2],
          level: level
        });
        nodes.push({
          type: 'abbr_close',
          level: --level
        });
        pos = reg.lastIndex - m[3].length;
      }

      if (!nodes.length) { continue; }

      if (pos < text.length) {
        nodes.push({
          type: 'text',
          content: text.slice(pos),
          level: level
        });
      }

      // replace current node
      blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/block.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/block.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function block(state) {

  if (state.inlineMode) {
    state.tokens.push({
      type: 'inline',
      content: state.src.replace(/\n/g, ' ').trim(),
      level: 0,
      lines: [ 0, 1 ],
      children: []
    });

  } else {
    state.block.parse(state.src, state.options, state.env, state.tokens);
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/footnote_tail.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/footnote_tail.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



module.exports = function footnote_block(state) {
  var i, l, j, t, lastParagraph, list, tokens, current, currentLabel,
      level = 0,
      insideRef = false,
      refTokens = {};

  if (!state.env.footnotes) { return; }

  state.tokens = state.tokens.filter(function(tok) {
    if (tok.type === 'footnote_reference_open') {
      insideRef = true;
      current = [];
      currentLabel = tok.label;
      return false;
    }
    if (tok.type === 'footnote_reference_close') {
      insideRef = false;
      // prepend ':' to avoid conflict with Object.prototype members
      refTokens[':' + currentLabel] = current;
      return false;
    }
    if (insideRef) { current.push(tok); }
    return !insideRef;
  });

  if (!state.env.footnotes.list) { return; }
  list = state.env.footnotes.list;

  state.tokens.push({
    type: 'footnote_block_open',
    level: level++
  });
  for (i = 0, l = list.length; i < l; i++) {
    state.tokens.push({
      type: 'footnote_open',
      id: i,
      level: level++
    });

    if (list[i].tokens) {
      tokens = [];
      tokens.push({
        type: 'paragraph_open',
        tight: false,
        level: level++
      });
      tokens.push({
        type: 'inline',
        content: '',
        level: level,
        children: list[i].tokens
      });
      tokens.push({
        type: 'paragraph_close',
        tight: false,
        level: --level
      });
    } else if (list[i].label) {
      tokens = refTokens[':' + list[i].label];
    }

    state.tokens = state.tokens.concat(tokens);
    if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {
      lastParagraph = state.tokens.pop();
    } else {
      lastParagraph = null;
    }

    t = list[i].count > 0 ? list[i].count : 1;
    for (j = 0; j < t; j++) {
      state.tokens.push({
        type: 'footnote_anchor',
        id: i,
        subId: j,
        level: level
      });
    }

    if (lastParagraph) {
      state.tokens.push(lastParagraph);
    }

    state.tokens.push({
      type: 'footnote_close',
      level: --level
    });
  }
  state.tokens.push({
    type: 'footnote_block_close',
    level: --level
  });
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/inline.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/inline.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function inline(state) {
  var tokens = state.tokens, tok, i, l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.inline.parse(tok.content, state.options, state.env, tok.children);
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/linkify.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/linkify.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Replace link-like texts with link nodes.
//
// Currently restricted by `inline.validateLink()` to http/https/ftp
//



var Autolinker = __webpack_require__(/*! autolinker */ "./node_modules/.registry.npmjs.org/autolinker/0.15.3/node_modules/autolinker/dist/Autolinker.js");


var LINK_SCAN_RE = /www|@|\:\/\//;


function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}

// Stupid fabric to avoid singletons, for thread safety.
// Required for engines like Nashorn.
//
function createLinkifier() {
  var links = [];
  var autolinker = new Autolinker({
    stripPrefix: false,
    url: true,
    email: true,
    twitter: false,
    replaceFn: function (linker, match) {
      // Only collect matched strings but don't change anything.
      switch (match.getType()) {
        /*eslint default-case:0*/
        case 'url':
          links.push({
            text: match.matchedText,
            url: match.getUrl()
          });
          break;
        case 'email':
          links.push({
            text: match.matchedText,
            // normalize email protocol
            url: 'mailto:' + match.getEmail().replace(/^mailto:/i, '')
          });
          break;
      }
      return false;
    }
  });

  return {
    links: links,
    autolinker: autolinker
  };
}


module.exports = function linkify(state) {
  var i, j, l, tokens, token, text, nodes, ln, pos, level, htmlLinkLevel,
      blockTokens = state.tokens,
      linkifier = null, links, autolinker;

  if (!state.options.linkify) { return; }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline') { continue; }
    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i];

      // Skip content of markdown links
      if (token.type === 'link_close') {
        i--;
        while (tokens[i].level !== token.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (token.type === 'htmltag') {
        if (isLinkOpen(token.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(token.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) { continue; }

      if (token.type === 'text' && LINK_SCAN_RE.test(token.content)) {

        // Init linkifier in lazy manner, only if required.
        if (!linkifier) {
          linkifier = createLinkifier();
          links = linkifier.links;
          autolinker = linkifier.autolinker;
        }

        text = token.content;
        links.length = 0;
        autolinker.link(text);

        if (!links.length) { continue; }

        // Now split string to nodes
        nodes = [];
        level = token.level;

        for (ln = 0; ln < links.length; ln++) {

          if (!state.inline.validateLink(links[ln].url)) { continue; }

          pos = text.indexOf(links[ln].text);

          if (pos) {
            level = level;
            nodes.push({
              type: 'text',
              content: text.slice(0, pos),
              level: level
            });
          }
          nodes.push({
            type: 'link_open',
            href: links[ln].url,
            title: '',
            level: level++
          });
          nodes.push({
            type: 'text',
            content: links[ln].text,
            level: level
          });
          nodes.push({
            type: 'link_close',
            level: --level
          });
          text = text.slice(pos + links[ln].text.length);
        }
        if (text.length) {
          nodes.push({
            type: 'text',
            content: text,
            level: level
          });
        }

        // replace current node
        blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/references.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/references.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var StateInline          = __webpack_require__(/*! ../rules_inline/state_inline */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/state_inline.js");
var parseLinkLabel       = __webpack_require__(/*! ../helpers/parse_link_label */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_label.js");
var parseLinkDestination = __webpack_require__(/*! ../helpers/parse_link_destination */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_destination.js");
var parseLinkTitle       = __webpack_require__(/*! ../helpers/parse_link_title */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_title.js");
var normalizeReference   = __webpack_require__(/*! ../helpers/normalize_reference */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_reference.js");


function parseReference(str, parser, options, env) {
  var state, labelEnd, pos, max, code, start, href, title, label;

  if (str.charCodeAt(0) !== 0x5B/* [ */) { return -1; }

  if (str.indexOf(']:') === -1) { return -1; }

  state = new StateInline(str, parser, options, env, []);
  labelEnd = parseLinkLabel(state, 0);

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }

  max = state.posMax;

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    code = state.src.charCodeAt(pos);
    if (code !== 0x20 && code !== 0x0A) { break; }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  if (!parseLinkDestination(state, pos)) { return -1; }
  href = state.linkContent;
  pos = state.pos;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (pos = pos + 1; pos < max; pos++) {
    code = state.src.charCodeAt(pos);
    if (code !== 0x20 && code !== 0x0A) { break; }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  if (pos < max && start !== pos && parseLinkTitle(state, pos)) {
    title = state.linkContent;
    pos = state.pos;
  } else {
    title = '';
    pos = start;
  }

  // ensure that the end of the line is empty
  while (pos < max && state.src.charCodeAt(pos) === 0x20/* space */) { pos++; }
  if (pos < max && state.src.charCodeAt(pos) !== 0x0A) { return -1; }

  label = normalizeReference(str.slice(1, labelEnd));
  if (typeof env.references[label] === 'undefined') {
    env.references[label] = { title: title, href: href };
  }

  return pos;
}


module.exports = function references(state) {
  var tokens = state.tokens, i, l, content, pos;

  state.env.references = state.env.references || {};

  if (state.inlineMode) {
    return;
  }

  // Scan definitions in paragraph inlines
  for (i = 1, l = tokens.length - 1; i < l; i++) {
    if (tokens[i].type === 'inline' &&
        tokens[i - 1].type === 'paragraph_open' &&
        tokens[i + 1].type === 'paragraph_close') {

      content = tokens[i].content;
      while (content.length) {
        pos = parseReference(content, state.inline, state.options, state.env);
        if (pos < 0) { break; }
        content = content.slice(pos).trim();
      }

      tokens[i].content = content;
      if (!content.length) {
        tokens[i - 1].tight = true;
        tokens[i + 1].tight = true;
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/replacements.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/replacements.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Simple typographical replacements
//


// TODO:
// - fractionals 1/2, 1/4, 3/4 -> Â½, Â¼, Â¾
// - miltiplication 2 x 4 -> 2 Ã 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  'c': 'Â©',
  'r': 'Â®',
  'p': 'Â§',
  'tm': 'â¢'
};

function replaceScopedAbbr(str) {
  if (str.indexOf('(') < 0) { return str; }

  return str.replace(SCOPED_ABBR_RE, function(match, name) {
    return SCOPED_ABBR[name.toLowerCase()];
  });
}


module.exports = function replace(state) {
  var i, token, text, inlineTokens, blkIdx;

  if (!state.options.typographer) { return; }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') { continue; }

    inlineTokens = state.tokens[blkIdx].children;

    for (i = inlineTokens.length - 1; i >= 0; i--) {
      token = inlineTokens[i];
      if (token.type === 'text') {
        text = token.content;

        text = replaceScopedAbbr(text);

        if (RARE_RE.test(text)) {
          text = text
            .replace(/\+-/g, 'Â±')
            // .., ..., ....... -> â¦
            // but ?..... & !..... -> ?.. & !..
            .replace(/\.{2,}/g, 'â¦').replace(/([?!])â¦/g, '$1..')
            .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
            // em-dash
            .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
            // en-dash
            .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2')
            .replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
        }

        token.content = text;
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/smartquotes.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_core/smartquotes.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Convert straight quotation marks to typographic ones
//



var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var PUNCT_RE = /[-\s()\[\]]/;
var APOSTROPHE = 'â';

// This function returns true if the character at `pos`
// could be inside a word.
function isLetter(str, pos) {
  if (pos < 0 || pos >= str.length) { return false; }
  return !PUNCT_RE.test(str[pos]);
}


function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}


module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var i, token, text, t, pos, max, thisLevel, lastSpace, nextSpace, item,
      canOpen, canClose, j, isSingle, blkIdx, tokens,
      stack;

  if (!state.options.typographer) { return; }

  stack = [];

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') { continue; }

    tokens = state.tokens[blkIdx].children;
    stack.length = 0;

    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];

      if (token.type !== 'text' || QUOTE_TEST_RE.test(token.text)) { continue; }

      thisLevel = tokens[i].level;

      for (j = stack.length - 1; j >= 0; j--) {
        if (stack[j].level <= thisLevel) { break; }
      }
      stack.length = j + 1;

      text = token.content;
      pos = 0;
      max = text.length;

      /*eslint no-labels:0,block-scoped-var:0*/
      OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        t = QUOTE_RE.exec(text);
        if (!t) { break; }

        lastSpace = !isLetter(text, t.index - 1);
        pos = t.index + 1;
        isSingle = (t[0] === "'");
        nextSpace = !isLetter(text, pos);

        if (!nextSpace && !lastSpace) {
          // middle of word
          if (isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }
          continue;
        }

        canOpen = !nextSpace;
        canClose = !lastSpace;

        if (canClose) {
          // this could be a closing quote, rewind the stack to get a match
          for (j = stack.length - 1; j >= 0; j--) {
            item = stack[j];
            if (stack[j].level < thisLevel) { break; }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              if (isSingle) {
                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[2]);
                token.content = replaceAt(token.content, t.index, state.options.quotes[3]);
              } else {
                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[0]);
                token.content = replaceAt(token.content, t.index, state.options.quotes[1]);
              }
              stack.length = j;
              continue OUTER;
            }
          }
        }

        if (canOpen) {
          stack.push({
            token: i,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/autolink.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/autolink.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process autolinks '<protocol:...>'



var url_schemas   = __webpack_require__(/*! ../common/url_schemas */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/url_schemas.js");
var normalizeLink = __webpack_require__(/*! ../helpers/normalize_link */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_link.js");


/*eslint max-len:0*/
var EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z.\-]{1,25}):([^<>\x00-\x20]*)>/;


module.exports = function autolink(state, silent) {
  var tail, linkMatch, emailMatch, url, fullUrl, pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) { return false; }

  linkMatch = tail.match(AUTOLINK_RE);

  if (linkMatch) {
    if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) { return false; }

    url = linkMatch[0].slice(1, -1);
    fullUrl = normalizeLink(url);
    if (!state.parser.validateLink(url)) { return false; }

    if (!silent) {
      state.push({
        type: 'link_open',
        href: fullUrl,
        level: state.level
      });
      state.push({
        type: 'text',
        content: url,
        level: state.level + 1
      });
      state.push({ type: 'link_close', level: state.level });
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  emailMatch = tail.match(EMAIL_RE);

  if (emailMatch) {

    url = emailMatch[0].slice(1, -1);

    fullUrl = normalizeLink('mailto:' + url);
    if (!state.parser.validateLink(fullUrl)) { return false; }

    if (!silent) {
      state.push({
        type: 'link_open',
        href: fullUrl,
        level: state.level
      });
      state.push({
        type: 'text',
        content: url,
        level: state.level + 1
      });
      state.push({ type: 'link_close', level: state.level });
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/backticks.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/backticks.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse backticks



module.exports = function backticks(state, silent) {
  var start, max, marker, matchStart, matchEnd,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60/* ` */) { return false; }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        state.push({
          type: 'code',
          content: state.src.slice(pos, matchStart)
                              .replace(/[ \n]+/g, ' ')
                              .trim(),
          block: false,
          level: state.level
        });
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) { state.pending += marker; }
  state.pos += marker.length;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/del.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/del.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ~~deleted text~~



module.exports = function del(state, silent) {
  var found,
      pos,
      stack,
      max = state.posMax,
      start = state.pos,
      lastChar,
      nextChar;

  if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 4 >= max) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x7E/* ~ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
  nextChar = state.src.charCodeAt(start + 2);

  if (lastChar === 0x7E/* ~ */) { return false; }
  if (nextChar === 0x7E/* ~ */) { return false; }
  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }

  pos = start + 2;
  while (pos < max && state.src.charCodeAt(pos) === 0x7E/* ~ */) { pos++; }
  if (pos > start + 3) {
    // sequence of 4+ markers taking as literal, same as in a emphasis
    state.pos += pos - start;
    if (!silent) { state.pending += state.src.slice(start, pos); }
    return true;
  }

  state.pos = start + 2;
  stack = 1;

  while (state.pos + 1 < max) {
    if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {
      if (state.src.charCodeAt(state.pos + 1) === 0x7E/* ~ */) {
        lastChar = state.src.charCodeAt(state.pos - 1);
        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;
        if (nextChar !== 0x7E/* ~ */ && lastChar !== 0x7E/* ~ */) {
          if (lastChar !== 0x20 && lastChar !== 0x0A) {
            // closing '~~'
            stack--;
          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {
            // opening '~~'
            stack++;
          } // else {
            //  // standalone ' ~~ ' indented with spaces
            // }
          if (stack <= 0) {
            found = true;
            break;
          }
        }
      }
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 2;

  if (!silent) {
    state.push({ type: 'del_open', level: state.level++ });
    state.parser.tokenize(state);
    state.push({ type: 'del_close', level: --state.level });
  }

  state.pos = state.posMax + 2;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/emphasis.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/emphasis.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process *this* and _that_




function isAlphaNum(code) {
  return (code >= 0x30 /* 0 */ && code <= 0x39 /* 9 */) ||
         (code >= 0x41 /* A */ && code <= 0x5A /* Z */) ||
         (code >= 0x61 /* a */ && code <= 0x7A /* z */);
}

// parse sequence of emphasis markers,
// "start" should point at a valid marker
function scanDelims(state, start) {
  var pos = start, lastChar, nextChar, count,
      can_open = true,
      can_close = true,
      max = state.posMax,
      marker = state.src.charCodeAt(start);

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;

  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }
  if (pos >= max) { can_open = false; }
  count = pos - start;

  if (count >= 4) {
    // sequence of four or more unescaped markers can't start/end an emphasis
    can_open = can_close = false;
  } else {
    nextChar = pos < max ? state.src.charCodeAt(pos) : -1;

    // check whitespace conditions
    if (nextChar === 0x20 || nextChar === 0x0A) { can_open = false; }
    if (lastChar === 0x20 || lastChar === 0x0A) { can_close = false; }

    if (marker === 0x5F /* _ */) {
      // check if we aren't inside the word
      if (isAlphaNum(lastChar)) { can_open = false; }
      if (isAlphaNum(nextChar)) { can_close = false; }
    }
  }

  return {
    can_open: can_open,
    can_close: can_close,
    delims: count
  };
}

module.exports = function emphasis(state, silent) {
  var startCount,
      count,
      found,
      oldCount,
      newCount,
      stack,
      res,
      max = state.posMax,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (marker !== 0x5F/* _ */ && marker !== 0x2A /* * */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode

  res = scanDelims(state, start);
  startCount = res.delims;
  if (!res.can_open) {
    state.pos += startCount;
    if (!silent) { state.pending += state.src.slice(start, state.pos); }
    return true;
  }

  if (state.level >= state.options.maxNesting) { return false; }

  state.pos = start + startCount;
  stack = [ startCount ];

  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === marker) {
      res = scanDelims(state, state.pos);
      count = res.delims;
      if (res.can_close) {
        oldCount = stack.pop();
        newCount = count;

        while (oldCount !== newCount) {
          if (newCount < oldCount) {
            stack.push(oldCount - newCount);
            break;
          }

          // assert(newCount > oldCount)
          newCount -= oldCount;

          if (stack.length === 0) { break; }
          state.pos += oldCount;
          oldCount = stack.pop();
        }

        if (stack.length === 0) {
          startCount = oldCount;
          found = true;
          break;
        }
        state.pos += count;
        continue;
      }

      if (res.can_open) { stack.push(count); }
      state.pos += count;
      continue;
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + startCount;

  if (!silent) {
    if (startCount === 2 || startCount === 3) {
      state.push({ type: 'strong_open', level: state.level++ });
    }
    if (startCount === 1 || startCount === 3) {
      state.push({ type: 'em_open', level: state.level++ });
    }

    state.parser.tokenize(state);

    if (startCount === 1 || startCount === 3) {
      state.push({ type: 'em_close', level: --state.level });
    }
    if (startCount === 2 || startCount === 3) {
      state.push({ type: 'strong_close', level: --state.level });
    }
  }

  state.pos = state.posMax + startCount;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/entity.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/entity.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html entity - &#123;, &#xAF;, &quot;, ...



var entities          = __webpack_require__(/*! ../common/entities */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/entities.js");
var has               = __webpack_require__(/*! ../common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").has;
var isValidEntityCode = __webpack_require__(/*! ../common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").isValidEntityCode;
var fromCodePoint     = __webpack_require__(/*! ../common/utils */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/utils.js").fromCodePoint;


var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;


module.exports = function entity(state, silent) {
  var ch, code, match, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
      match = state.src.slice(pos).match(DIGITAL_RE);
      if (match) {
        if (!silent) {
          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
        }
        state.pos += match[0].length;
        return true;
      }
    } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) { state.pending += entities[match[1]]; }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) { state.pending += '&'; }
  state.pos++;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/escape.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/escape.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess escaped chars and hardbreaks



var ESCAPED = [];

for (var i = 0; i < 256; i++) { ESCAPED.push(0); }

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'
  .split('').forEach(function(ch) { ESCAPED[ch.charCodeAt(0)] = 1; });


module.exports = function escape(state, silent) {
  var ch, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C/* \ */) { return false; }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) { state.pending += state.src[pos]; }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push({
          type: 'hardbreak',
          level: state.level
        });
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) { state.pending += '\\'; }
  state.pos++;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/footnote_inline.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/footnote_inline.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process inline footnotes (^[...])



var parseLinkLabel = __webpack_require__(/*! ../helpers/parse_link_label */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_label.js");


module.exports = function footnote_inline(state, silent) {
  var labelStart,
      labelEnd,
      footnoteId,
      oldLength,
      max = state.posMax,
      start = state.pos;

  if (start + 2 >= max) { return false; }
  if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x5B/* [ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  labelStart = start + 2;
  labelEnd = parseLinkLabel(state, start + 1);

  // parser failed to find ']', so it's not a valid note
  if (labelEnd < 0) { return false; }

  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    if (!state.env.footnotes) { state.env.footnotes = {}; }
    if (!state.env.footnotes.list) { state.env.footnotes.list = []; }
    footnoteId = state.env.footnotes.list.length;

    state.pos = labelStart;
    state.posMax = labelEnd;

    state.push({
      type: 'footnote_ref',
      id: footnoteId,
      level: state.level
    });
    state.linkLevel++;
    oldLength = state.tokens.length;
    state.parser.tokenize(state);
    state.env.footnotes.list[footnoteId] = { tokens: state.tokens.splice(oldLength) };
    state.linkLevel--;
  }

  state.pos = labelEnd + 1;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/footnote_ref.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/footnote_ref.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process footnote references ([^...])




module.exports = function footnote_ref(state, silent) {
  var label,
      pos,
      footnoteId,
      footnoteSubId,
      max = state.posMax,
      start = state.pos;

  // should be at least 4 chars - "[^x]"
  if (start + 3 > max) { return false; }

  if (!state.env.footnotes || !state.env.footnotes.refs) { return false; }
  if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  for (pos = start + 2; pos < max; pos++) {
    if (state.src.charCodeAt(pos) === 0x20) { return false; }
    if (state.src.charCodeAt(pos) === 0x0A) { return false; }
    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {
      break;
    }
  }

  if (pos === start + 2) { return false; } // no empty footnote labels
  if (pos >= max) { return false; }
  pos++;

  label = state.src.slice(start + 2, pos - 1);
  if (typeof state.env.footnotes.refs[':' + label] === 'undefined') { return false; }

  if (!silent) {
    if (!state.env.footnotes.list) { state.env.footnotes.list = []; }

    if (state.env.footnotes.refs[':' + label] < 0) {
      footnoteId = state.env.footnotes.list.length;
      state.env.footnotes.list[footnoteId] = { label: label, count: 0 };
      state.env.footnotes.refs[':' + label] = footnoteId;
    } else {
      footnoteId = state.env.footnotes.refs[':' + label];
    }

    footnoteSubId = state.env.footnotes.list[footnoteId].count;
    state.env.footnotes.list[footnoteId].count++;

    state.push({
      type: 'footnote_ref',
      id: footnoteId,
      subId: footnoteSubId,
      level: state.level
    });
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/htmltag.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/htmltag.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html tags




var HTML_TAG_RE = __webpack_require__(/*! ../common/html_re */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/common/html_re.js").HTML_TAG_RE;


function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
}


module.exports = function htmltag(state, silent) {
  var ch, match, max, pos = state.pos;

  if (!state.options.html) { return false; }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||
      pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21/* ! */ &&
      ch !== 0x3F/* ? */ &&
      ch !== 0x2F/* / */ &&
      !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) { return false; }

  if (!silent) {
    state.push({
      type: 'htmltag',
      content: state.src.slice(pos, pos + match[0].length),
      level: state.level
    });
  }
  state.pos += match[0].length;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/ins.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/ins.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ++inserted text++



module.exports = function ins(state, silent) {
  var found,
      pos,
      stack,
      max = state.posMax,
      start = state.pos,
      lastChar,
      nextChar;

  if (state.src.charCodeAt(start) !== 0x2B/* + */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 4 >= max) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x2B/* + */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
  nextChar = state.src.charCodeAt(start + 2);

  if (lastChar === 0x2B/* + */) { return false; }
  if (nextChar === 0x2B/* + */) { return false; }
  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }

  pos = start + 2;
  while (pos < max && state.src.charCodeAt(pos) === 0x2B/* + */) { pos++; }
  if (pos !== start + 2) {
    // sequence of 3+ markers taking as literal, same as in a emphasis
    state.pos += pos - start;
    if (!silent) { state.pending += state.src.slice(start, pos); }
    return true;
  }

  state.pos = start + 2;
  stack = 1;

  while (state.pos + 1 < max) {
    if (state.src.charCodeAt(state.pos) === 0x2B/* + */) {
      if (state.src.charCodeAt(state.pos + 1) === 0x2B/* + */) {
        lastChar = state.src.charCodeAt(state.pos - 1);
        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;
        if (nextChar !== 0x2B/* + */ && lastChar !== 0x2B/* + */) {
          if (lastChar !== 0x20 && lastChar !== 0x0A) {
            // closing '++'
            stack--;
          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {
            // opening '++'
            stack++;
          } // else {
            //  // standalone ' ++ ' indented with spaces
            // }
          if (stack <= 0) {
            found = true;
            break;
          }
        }
      }
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 2;

  if (!silent) {
    state.push({ type: 'ins_open', level: state.level++ });
    state.parser.tokenize(state);
    state.push({ type: 'ins_close', level: --state.level });
  }

  state.pos = state.posMax + 2;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/links.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/links.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process [links](<to> "stuff")



var parseLinkLabel       = __webpack_require__(/*! ../helpers/parse_link_label */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_label.js");
var parseLinkDestination = __webpack_require__(/*! ../helpers/parse_link_destination */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_destination.js");
var parseLinkTitle       = __webpack_require__(/*! ../helpers/parse_link_title */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/parse_link_title.js");
var normalizeReference   = __webpack_require__(/*! ../helpers/normalize_reference */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/helpers/normalize_reference.js");


module.exports = function links(state, silent) {
  var labelStart,
      labelEnd,
      label,
      href,
      title,
      pos,
      ref,
      code,
      isImage = false,
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (marker === 0x21/* ! */) {
    isImage = true;
    marker = state.src.charCodeAt(++start);
  }

  if (marker !== 0x5B/* [ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  labelStart = start + 1;
  labelEnd = parseLinkLabel(state, start);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) { return false; }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
    //
    // Inline link
    //

    // [link](  <href>  "title"  )
    //        ^^ skipping these spaces
    pos++;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (code !== 0x20 && code !== 0x0A) { break; }
    }
    if (pos >= max) { return false; }

    // [link](  <href>  "title"  )
    //          ^^^^^^ parsing link destination
    start = pos;
    if (parseLinkDestination(state, pos)) {
      href = state.linkContent;
      pos = state.pos;
    } else {
      href = '';
    }

    // [link](  <href>  "title"  )
    //                ^^ skipping these spaces
    start = pos;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (code !== 0x20 && code !== 0x0A) { break; }
    }

    // [link](  <href>  "title"  )
    //                  ^^^^^^^ parsing link title
    if (pos < max && start !== pos && parseLinkTitle(state, pos)) {
      title = state.linkContent;
      pos = state.pos;

      // [link](  <href>  "title"  )
      //                         ^^ skipping these spaces
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (code !== 0x20 && code !== 0x0A) { break; }
      }
    } else {
      title = '';
    }

    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    //
    // Link reference
    //

    // do not allow nested reference links
    if (state.linkLevel > 0) { return false; }

    // [foo]  [bar]
    //      ^^ optional whitespace (can include newlines)
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (code !== 0x20 && code !== 0x0A) { break; }
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
      start = pos + 1;
      pos = parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = start - 1;
      }
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      if (typeof label === 'undefined') {
        pos = labelEnd + 1;
      }
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    if (isImage) {
      state.push({
        type: 'image',
        src: href,
        title: title,
        alt: state.src.substr(labelStart, labelEnd - labelStart),
        level: state.level
      });
    } else {
      state.push({
        type: 'link_open',
        href: href,
        title: title,
        level: state.level++
      });
      state.linkLevel++;
      state.parser.tokenize(state);
      state.linkLevel--;
      state.push({ type: 'link_close', level: --state.level });
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/mark.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/mark.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ==highlighted text==



module.exports = function del(state, silent) {
  var found,
      pos,
      stack,
      max = state.posMax,
      start = state.pos,
      lastChar,
      nextChar;

  if (state.src.charCodeAt(start) !== 0x3D/* = */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 4 >= max) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x3D/* = */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
  nextChar = state.src.charCodeAt(start + 2);

  if (lastChar === 0x3D/* = */) { return false; }
  if (nextChar === 0x3D/* = */) { return false; }
  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }

  pos = start + 2;
  while (pos < max && state.src.charCodeAt(pos) === 0x3D/* = */) { pos++; }
  if (pos !== start + 2) {
    // sequence of 3+ markers taking as literal, same as in a emphasis
    state.pos += pos - start;
    if (!silent) { state.pending += state.src.slice(start, pos); }
    return true;
  }

  state.pos = start + 2;
  stack = 1;

  while (state.pos + 1 < max) {
    if (state.src.charCodeAt(state.pos) === 0x3D/* = */) {
      if (state.src.charCodeAt(state.pos + 1) === 0x3D/* = */) {
        lastChar = state.src.charCodeAt(state.pos - 1);
        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;
        if (nextChar !== 0x3D/* = */ && lastChar !== 0x3D/* = */) {
          if (lastChar !== 0x20 && lastChar !== 0x0A) {
            // closing '=='
            stack--;
          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {
            // opening '=='
            stack++;
          } // else {
            //  // standalone ' == ' indented with spaces
            // }
          if (stack <= 0) {
            found = true;
            break;
          }
        }
      }
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 2;

  if (!silent) {
    state.push({ type: 'mark_open', level: state.level++ });
    state.parser.tokenize(state);
    state.push({ type: 'mark_close', level: --state.level });
  }

  state.pos = state.posMax + 2;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/newline.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/newline.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess '\n'



module.exports = function newline(state, silent) {
  var pmax, max, pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A/* \n */) { return false; }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        // Strip out all trailing spaces on this line.
        for (var i = pmax - 2; i >= 0; i--) {
          if (state.pending.charCodeAt(i) !== 0x20) {
            state.pending = state.pending.substring(0, i + 1);
            break;
          }
        }
        state.push({
          type: 'hardbreak',
          level: state.level
        });
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push({
          type: 'softbreak',
          level: state.level
        });
      }

    } else {
      state.push({
        type: 'softbreak',
        level: state.level
      });
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }

  state.pos = pos;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/state_inline.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/state_inline.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Inline parser state



function StateInline(src, parserInline, options, env, outTokens) {
  this.src = src;
  this.env = env;
  this.options = options;
  this.parser = parserInline;
  this.tokens = outTokens;
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = [];        // Stores { start: end } pairs. Useful for backtrack
                          // optimization of pairs parse (emphasis, strikes).

  // Link parser state vars

  this.isInLabel = false; // Set true when seek link label - we should disable
                          // "paired" rules (emphasis, strikes) to not skip
                          // tailing `]`

  this.linkLevel = 0;     // Increment for each nesting link. Used to prevent
                          // nesting in definitions

  this.linkContent = '';  // Temporary storage for link url

  this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels
                                 // (backtrack optimization)
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  this.tokens.push({
    type: 'text',
    content: this.pending,
    level: this.pendingLevel
  });
  this.pending = '';
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (token) {
  if (this.pending) {
    this.pushPending();
  }

  this.tokens.push(token);
  this.pendingLevel = this.level;
};

// Store value to cache.
// !!! Implementation has parser-specific optimizations
// !!! keys MUST be integer, >= 0; values MUST be integer, > 0
//
StateInline.prototype.cacheSet = function (key, val) {
  for (var i = this.cache.length; i <= key; i++) {
    this.cache.push(0);
  }

  this.cache[key] = val;
};

// Get cache value
//
StateInline.prototype.cacheGet = function (key) {
  return key < this.cache.length ? this.cache[key] : 0;
};

module.exports = StateInline;


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/sub.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/sub.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ~subscript~



// same as UNESCAPE_MD_RE plus a space
var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;

module.exports = function sub(state, silent) {
  var found,
      content,
      max = state.posMax,
      start = state.pos;

  if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 2 >= max) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  state.pos = start + 1;

  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {
      found = true;
      break;
    }

    state.parser.skipToken(state);
  }

  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }

  content = state.src.slice(start + 1, state.pos);

  // don't allow unescaped spaces/newlines inside
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 1;

  if (!silent) {
    state.push({
      type: 'sub',
      level: state.level,
      content: content.replace(UNESCAPE_RE, '$1')
    });
  }

  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/sup.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/sup.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ^superscript^



// same as UNESCAPE_MD_RE plus a space
var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;

module.exports = function sup(state, silent) {
  var found,
      content,
      max = state.posMax,
      start = state.pos;

  if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 2 >= max) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  state.pos = start + 1;

  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 0x5E/* ^ */) {
      found = true;
      break;
    }

    state.parser.skipToken(state);
  }

  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }

  content = state.src.slice(start + 1, state.pos);

  // don't allow unescaped spaces/newlines inside
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 1;

  if (!silent) {
    state.push({
      type: 'sup',
      level: state.level,
      content: content.replace(UNESCAPE_RE, '$1')
    });
  }

  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/text.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/lib/rules_inline/text.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Skip text characters for text token, place those to pending buffer
// and increment current pos



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A/* \n */:
    case 0x5C/* \ */:
    case 0x60/* ` */:
    case 0x2A/* * */:
    case 0x5F/* _ */:
    case 0x5E/* ^ */:
    case 0x5B/* [ */:
    case 0x5D/* ] */:
    case 0x21/* ! */:
    case 0x26/* & */:
    case 0x3C/* < */:
    case 0x3E/* > */:
    case 0x7B/* { */:
    case 0x7D/* } */:
    case 0x24/* $ */:
    case 0x25/* % */:
    case 0x40/* @ */:
    case 0x7E/* ~ */:
    case 0x2B/* + */:
    case 0x3D/* = */:
    case 0x3A/* : */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) { return false; }

  if (!silent) { state.pending += state.src.slice(state.pos, pos); }

  state.pos = pos;

  return true;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/setimmediate/1.0.5/node_modules/setimmediate/setImmediate.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/setimmediate/1.0.5/node_modules/setimmediate/setImmediate.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6â8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/4.35.3_webpack@4.35.3/node_modules/webpack/buildin/global.js */ "./node_modules/.registry.npmjs.org/webpack/4.35.3_webpack@4.35.3/node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../process/0.11.10/node_modules/process/browser.js */ "./node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/style-loader/0.20.3/node_modules/style-loader/lib/addStyles.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/style-loader/0.20.3/node_modules/style-loader/lib/addStyles.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target) {
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/.registry.npmjs.org/style-loader/0.20.3/node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/style-loader/0.20.3/node_modules/style-loader/lib/urls.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/style-loader/0.20.3/node_modules/style-loader/lib/urls.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/.registry.npmjs.org/timers-browserify/2.0.10/node_modules/timers-browserify/main.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.registry.npmjs.org/timers-browserify/2.0.10/node_modules/timers-browserify/main.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/.registry.npmjs.org/setimmediate/1.0.5/node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/4.35.3_webpack@4.35.3/node_modules/webpack/buildin/global.js */ "./node_modules/.registry.npmjs.org/webpack/4.35.3_webpack@4.35.3/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/.registry.npmjs.org/webpack/4.35.3_webpack@4.35.3/node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./secret.js":
/*!*******************!*\
  !*** ./secret.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var onlineUrl = exports.onlineUrl = "https://eu1.prisma.sh/boaz-blake-8951e1/mithril-presenter/dev";

/***/ }),

/***/ "./src/App.js":
/*!********************!*\
  !*** ./src/App.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.App = undefined;

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _mithrilStream = __webpack_require__(/*! mithril-stream */ "./node_modules/.registry.npmjs.org/mithril-stream/1.1.0/node_modules/mithril-stream/stream.js");

var _mithrilStream2 = _interopRequireDefault(_mithrilStream);

var _component = __webpack_require__(/*! ./presentations/component.js */ "./src/presentations/component.js");

var _component2 = _interopRequireDefault(_component);

var _component3 = __webpack_require__(/*! ./slides/component.js */ "./src/slides/component.js");

var _component4 = _interopRequireDefault(_component3);

var _component5 = __webpack_require__(/*! ./editor/component.js */ "./src/editor/component.js");

var _component6 = _interopRequireDefault(_component5);

var _component7 = __webpack_require__(/*! ./layout/component.js */ "./src/layout/component.js");

var _component8 = _interopRequireDefault(_component7);

var _component9 = __webpack_require__(/*! ./slideshow/component.js */ "./src/slideshow/component.js");

var _component10 = _interopRequireDefault(_component9);

var _model = __webpack_require__(/*! ./presentations/model.js */ "./src/presentations/model.js");

var _index = __webpack_require__(/*! ./services/index.js */ "./src/services/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var makeRoutes = function makeRoutes(mdl) {
  var model = (0, _mithrilStream2.default)(mdl);
  return {
    '/presentations': {
      view: function view() {
        return (0, _mithril2.default)(_component8.default, model(), (0, _mithril2.default)(_component2.default, model()));
      }
    },
    '/presentation/:id/slides': {
      view: function view() {
        return (0, _mithril2.default)(_component8.default, model(), (0, _mithril2.default)(_component4.default, model()));
      }
    },
    '/edit/:pid/slide/:id': {
      view: function view() {
        return (0, _mithril2.default)(_component8.default, model(), (0, _mithril2.default)(_component6.default, model()));
      }
    },
    '/slideshow/:id': {
      view: function view() {
        return (0, _mithril2.default)(_component8.default, model(), (0, _mithril2.default)(_component10.default, model()));
      }
    }
  };
};

var App = exports.App = function App(_ref) {
  var model = _ref.attrs;

  var state = {
    errors: ''
  };

  var onError = function onError(error) {
    (0, _index.log)('error')(error);
    state.error = error;
  };

  var onSuccess = function onSuccess(Models) {
    return function (dto) {
      return Models.Presentations = dto;
    };
  };

  var findPresentations = function findPresentations(_ref2) {
    var Models = _ref2.attrs.Models;
    return (0, _model.getPresentations)().fork(onError, onSuccess(Models));
  };

  return {
    oninit: findPresentations,
    oncreate: function oncreate(_ref3) {
      var dom = _ref3.dom;

      var main = dom.querySelector('.main');

      _mithril2.default.route(main, '/presentations', makeRoutes(model));
    },
    view: function view(_ref4) {
      var children = _ref4.children;

      return (0, _mithril2.default)('.app', [(0, _mithril2.default)('.main', children)]);
    }
  };
};

exports.default = App;

/***/ }),

/***/ "./src/Models.js":
/*!***********************!*\
  !*** ./src/Models.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithrilStream = __webpack_require__(/*! mithril-stream */ "./node_modules/.registry.npmjs.org/mithril-stream/1.1.0/node_modules/mithril-stream/stream.js");

var _mithrilStream2 = _interopRequireDefault(_mithrilStream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SlideModel = {
  title: '',
  contents: '',
  order: 0,
  presentation_id: ''
};

var Slides = [];

var Presentations = [];

var SlideShowStruct = {
  keys: new Set(),
  values: {},
  items: (0, _mithrilStream2.default)([])
};

var CurrentPresentation = {
  title: '',
  id: '',
  slideShow: (0, _mithrilStream2.default)([]),
  Slides: Slides
};

var getProfile = function getProfile(w) {
  if (w < 668) return 'phone';
  if (w < 920) return 'tablet';
  return 'desktop';
};

var Models = {
  profile: getProfile(window.innerWidth),
  SlideShowStruct: SlideShowStruct,
  Presentations: Presentations,
  CurrentPresentation: CurrentPresentation,
  SlideModel: SlideModel,
  toggleModal: false
};

exports.default = Models;

/***/ }),

/***/ "./src/Toolbar/component.js":
/*!**********************************!*\
  !*** ./src/Toolbar/component.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var toggleModal = function toggleModal(model) {
  return [(0, _mithril2.default)("a.toolbar-item", {
    onclick: function onclick() {
      return model.toggleModal = !model.toggleModal;
    }
  }, "Add New")];
};
var toPresentations = [(0, _mithril2.default)("a.toolbar-item", {
  oncreate: _mithril2.default.route.link,
  href: "/presentations"
}, "Presentations")];

var toSlides = function toSlides(model) {
  return [(0, _mithril2.default)("a.toolbar-item", {
    oncreate: _mithril2.default.route.link,
    href: "/presentation/" + model.CurrentPresentation.id + "/slides"
  }, "slides")];
};

var toSlideShow = function toSlideShow(model) {
  return [(0, _mithril2.default)("a.toolbar-item", {
    disabled: (0, _ramda.isEmpty)((0, _ramda.length)(model.CurrentPresentation.slideShow)) ? true : false,
    oncreate: _mithril2.default.route.link,
    href: "/slideshow/" + model.CurrentPresentation.id
  }, "Slide Show")];
};

var navView = function navView(model) {
  return function (page) {
    switch (page) {
      case "presentation":
        return [toPresentations, toSlideShow(model)];
        break;

      case "slideshow":
        return [toPresentations, toSlides(model)];
        break;

      case "slides":
        return [toPresentations, toSlideShow(model)];
        break;

      case "edit":
        return [toPresentations, toSlides(model), toSlideShow(model)];
        break;
      default:
    }
  };
};

var actionView = function actionView(model) {
  return function (page) {
    switch (page) {
      case "presentations":
        return [toggleModal(model)];
        break;
      case "presentation":
        return [toggleModal(model)];
        break;
      default:
    }
  };
};

var Toolbar = function Toolbar(_ref) {
  var Models = _ref.attrs.Models;

  var currentPage = (0, _ramda.view)((0, _ramda.lensProp)(1), (0, _ramda.split)("/", _mithril2.default.route.get()));
  return {
    view: function view(_ref2) {
      var Models = _ref2.attrs.Models;
      return (0, _mithril2.default)(".toolbar", [(0, _mithril2.default)(".toolbar-left", [navView(Models)(currentPage)]), (0, _mithril2.default)(".toolbar-right", [actionView(Models)(currentPage)])]);
    }
  };
};

exports.default = Toolbar;

/***/ }),

/***/ "./src/editor/component.js":
/*!*********************************!*\
  !*** ./src/editor/component.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _model = __webpack_require__(/*! ./model.js */ "./src/editor/model.js");

var _remarkable = __webpack_require__(/*! remarkable */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/index.js");

var _remarkable2 = _interopRequireDefault(_remarkable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var md = new _remarkable2.default("full", {
  baseUrl: null,
  breaks: false,
  gfm: true,
  headerIds: true,
  headerPrefix: "",
  highlight: null,
  langPrefix: "lan-",
  mangle: true,
  pedantic: false,
  sanitize: false,
  sanitizer: null,
  silent: true,
  smartLists: true,
  smartypants: true,
  tables: true,
  xhtml: true,
  html: true,
  linkify: true,
  linkTarget: "",
  typographer: true,
  quotes: "ââââ"
});

var Editor = function Editor() {
  var state = { presentationId: "", slide: { title: "", content: "", id: "" } };

  var toSlides = function toSlides(_) {
    return _mithril2.default.route.set("/presentation/" + state.presentationId + "/slides");
  };

  var onError = function onError(error) {
    return log("error")(error);
  };

  var onSuccess = function onSuccess(slide) {
    state.slide = slide;
  };

  var getSlide = function getSlide() {
    state.slide.id = _mithril2.default.route.param("id");
    state.presentationId = _mithril2.default.route.param("pid");
    return (0, _model.loadSlide)(state.slide.id).fork(onError, onSuccess);
  };

  var updateInput = function updateInput(input) {
    return function (e) {
      return state.slide[input] = e.target.value;
    };
  };

  var save = function save(e) {
    e.preventDefault();

    (0, _model.editSlide)(state.slide).fork(onError, function () {
      return toSlides();
    });
  };

  return {
    oncreate: getSlide,
    view: function view(_ref) {
      var Models = _ref.attrs.Models;
      return (0, _mithril2.default)(".container", [(0, _mithril2.default)(".editor-left.card", [(0, _mithril2.default)(".card-header", [(0, _mithril2.default)("input.editor-input", {
        type: "text",
        placeholder: "Slide Title",
        oninput: updateInput("title"),
        value: state.slide.title
      })]), (0, _mithril2.default)("textarea.editor-text", {
        oninput: updateInput("content"),
        value: state.slide.content
      }), (0, _mithril2.default)(".card-footer", [(0, _mithril2.default)("button.card-btn", {
        onclick: save
      }, "Save"), (0, _mithril2.default)("button.card-btn", {
        onclick: toSlides
      }, "Cancel")])]), (0, _mithril2.default)(".editor-right", _mithril2.default.trust(md.render(state.slide.content || "")))]);
    }
  };
};

exports.default = Editor;

/***/ }),

/***/ "./src/editor/model.js":
/*!*****************************!*\
  !*** ./src/editor/model.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.editSlide = exports.loadSlide = undefined;

var _requests = __webpack_require__(/*! ../services/requests.js */ "./src/services/requests.js");

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var loadSlide = exports.loadSlide = function loadSlide(id) {
  var q = '{ slide(where:{id:' + JSON.stringify(id) + '}){\n              id content title\n            }\n          }';
  return (0, _requests.getQlTask)(q).map((0, _ramda.path)(['data', 'slide']));
};

var editSlide = exports.editSlide = function editSlide(_ref) {
  var id = _ref.id,
      title = _ref.title,
      content = _ref.content;

  var q = 'mutation {\n            updateSlide(\n              data: {\n                title: ' + JSON.stringify(title) + '\n                content: ' + JSON.stringify(content) + '\n              }\n              where: {\n                id: ' + JSON.stringify(id) + '\n              }) {\n                id\n                title\n              }\n        }';

  return (0, _requests.getQlTask)(q).map((0, _ramda.path)(['data', 'updatePresentation', 'Slides']));
};

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

__webpack_require__(/*! ./styles/index.css */ "./src/styles/index.css");

var _Models = __webpack_require__(/*! ./Models.js */ "./src/Models.js");

var _Models2 = _interopRequireDefault(_Models);

var _App = __webpack_require__(/*! ./App.js */ "./src/App.js");

var _App2 = _interopRequireDefault(_App);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var root = document.body; // index.jsx

_mithril2.default.render(root, (0, _mithril2.default)(_App2.default, { Models: _Models2.default }));

/***/ }),

/***/ "./src/layout/component.js":
/*!*********************************!*\
  !*** ./src/layout/component.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _component = __webpack_require__(/*! ../Toolbar/component.js */ "./src/Toolbar/component.js");

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Layout = {
  view: function view(_ref) {
    var children = _ref.children,
        Models = _ref.attrs;
    return [(0, _mithril2.default)(_component2.default, Models), children];
  }
};

exports.default = Layout;

/***/ }),

/***/ "./src/presentations/Presentation/component.js":
/*!*****************************************************!*\
  !*** ./src/presentations/Presentation/component.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _index = __webpack_require__(/*! ../../services/index.js */ "./src/services/index.js");

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _model = __webpack_require__(/*! ../model.js */ "./src/presentations/model.js");

var _data = __webpack_require__(/*! data.task */ "./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/index.js");

var _data2 = _interopRequireDefault(_data);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Presentation = function Presentation(_ref) {
  var _ref$attrs = _ref.attrs,
      title = _ref$attrs.title,
      id = _ref$attrs.id,
      Models = _ref$attrs.Models;

  var onError = function onError(task) {
    return function (error) {
      return (0, _index.log)("error with " + task)(error);
    };
  };
  var onSuccess = function onSuccess(models) {
    return function (deleted) {
      return Models.Presentations = (0, _ramda.without)([deleted], Models.Presentations);
    };
  };

  var authDeleteTask = function authDeleteTask(id) {
    return window.confirm("Are you sure you want to delete?") ? _data2.default.of(id) : _data2.default.rejected(id);
  };

  var removePresTask = function removePresTask(pId) {
    return authDeleteTask(pId).chain(_model.deletePresentationsTask).fork(onError("deleting"), onSuccess(Models));
  };

  return {
    view: function view(_ref2) {
      var _ref2$attrs = _ref2.attrs,
          title = _ref2$attrs.title,
          id = _ref2$attrs.id,
          Models = _ref2$attrs.Models;
      return (0, _mithril2.default)(".card", [(0, _mithril2.default)("div.card-header", [(0, _mithril2.default)(".card-btn.full-width", {
        onclick: function onclick() {
          return _mithril2.default.route.set("/presentation/" + id + "/slides");
        }
      }, title), (0, _mithril2.default)("button.card-delete", {
        onclick: function onclick() {
          return removePresTask(id);
        }
      })]), (0, _mithril2.default)("div.card-body", []), (0, _mithril2.default)("div.card-footer", [])]);
    }
  };
};

exports.default = Presentation;

/***/ }),

/***/ "./src/presentations/component.js":
/*!****************************************!*\
  !*** ./src/presentations/component.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _animations = __webpack_require__(/*! ../services/animations.js */ "./src/services/animations.js");

var _presentationModal = __webpack_require__(/*! ./presentationModal.js */ "./src/presentations/presentationModal.js");

var _presentationModal2 = _interopRequireDefault(_presentationModal);

var _component = __webpack_require__(/*! ./Presentation/component.js */ "./src/presentations/Presentation/component.js");

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Presentations = function Presentations(_ref) {
  var Models = _ref.attrs.Models;

  var state = {
    errors: [],
    title: ''
  };

  return {
    view: function view(_ref2) {
      var Models = _ref2.attrs.Models;
      return [Models.toggleModal ? (0, _mithril2.default)(_presentationModal2.default, {
        Models: Models,
        state: state,
        toggleModal: function toggleModal() {
          return Models.toggleModal = !Models.toggleModal;
        },
        presentations: Models.Presentations,
        presentationModel: (0, _ramda.clone)(Models.PresentationModel)
      }) : '', (0, _mithril2.default)('.container.presentations', {
        oncreate: function oncreate(_ref3) {
          var dom = _ref3.dom;
          return (0, _animations.animateFadeIn)({ dom: dom });
        },
        onBeforeRemove: function onBeforeRemove(vnode, done) {
          vnode.dom.addEventListener('animationend', done);
          vnode.dom.style.animation = 'fadeOut 1s';
        }
      }, [Models.Presentations && Models.Presentations.map(function (_ref4) {
        var title = _ref4.title,
            id = _ref4.id;
        return (0, _mithril2.default)(_component2.default, {
          key: id,
          id: id,
          title: title,
          Models: Models
        });
      })])];
    }
  };
};

exports.default = Presentations;

/***/ }),

/***/ "./src/presentations/model.js":
/*!************************************!*\
  !*** ./src/presentations/model.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deletePresentationsTask = exports.savePresentationTask = exports.getPresentations = undefined;

var _requests = __webpack_require__(/*! ../services/requests.js */ "./src/services/requests.js");

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _index = __webpack_require__(/*! ../services/index.js */ "./src/services/index.js");

var toViewModel = function toViewModel(_ref) {
  var data = _ref.data,
      errors = _ref.errors;

  console.log('errors', errors);
  console.log('data', data);
  return { data: data, errors: errors };
};

var getPresentations = exports.getPresentations = function getPresentations() {
  return (0, _requests.getQlTask)('query {\n  presentations{ id, title}\n}').map((0, _ramda.path)(['data', 'presentations']));
};

var savePresentationTask = exports.savePresentationTask = function savePresentationTask(state) {
  var q = 'mutation {\n    createPresentation(data: {title: ' + JSON.stringify(state.title) + '})\n    { title id}\n  }';
  return (0, _requests.getQlTask)(q).map((0, _ramda.path)(['data', 'createPresentation']));
};

var deletePresentationsTask = exports.deletePresentationsTask = function deletePresentationsTask(id) {
  var q = 'mutation {\n    deletePresentation(where: {id: ' + JSON.stringify(id) + '})\n    { title id}\n  }';
  return (0, _requests.getQlTask)(q).map((0, _ramda.path)(['data', 'deletePresentation']));
};

/***/ }),

/***/ "./src/presentations/presentationModal.js":
/*!************************************************!*\
  !*** ./src/presentations/presentationModal.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _model = __webpack_require__(/*! ./model.js */ "./src/presentations/model.js");

var _index = __webpack_require__(/*! ../services/index.js */ "./src/services/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PresentationModal = function PresentationModal(_ref) {
  var attrs = _ref.attrs;

  var onError = function onError(errors) {
    (0, _index.log)("error")(errors);
    attrs.state.errors = errors;
    attrs.toggleModal();
  };
  var onSuccess = function onSuccess(p) {
    attrs.state.title = "";
    attrs.state.errors = [];
    attrs.presentations.push(p);
    attrs.toggleModal();
  };

  var save = function save(e) {
    e.preventDefault();
    (0, _model.savePresentationTask)(attrs.state).fork(onError, onSuccess);
  };

  return {
    view: function view() {
      return (0, _mithril2.default)("article.modal-container", [(0, _mithril2.default)(".card", [(0, _mithril2.default)(".card-header", (0, _mithril2.default)("button.card-delete", {
        onclick: function onclick() {
          return attrs.toggleModal();
        },
        "aria-label": "close"
      })), (0, _mithril2.default)(".card-body", [(0, _mithril2.default)("fieldset", [(0, _mithril2.default)("label.modal-label", "Presentation Name"), (0, _mithril2.default)("input.modal-input", {
        autofocus: true,
        type: "text",
        onchange: function onchange(e) {
          return attrs.state.title = e.target.value;
        }
      })])]), (0, _mithril2.default)(".card-footer", (0, _mithril2.default)("button.card-btn", { onclick: save }, "save presentation"))])]);
    }
  };
};

exports.default = PresentationModal;

/***/ }),

/***/ "./src/services/Tasks.js":
/*!*******************************!*\
  !*** ./src/services/Tasks.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.postQl = undefined;

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _data = __webpack_require__(/*! data.task */ "./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/index.js");

var _data2 = _interopRequireDefault(_data);

var _index = __webpack_require__(/*! ./index.js */ "./src/services/index.js");

var _secret = __webpack_require__(/*! ../../secret.js */ "./secret.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var postQl = exports.postQl = function postQl(query) {
  return new _data2.default(function (rej, res) {
    return _mithril2.default.request({
      method: "POST",
      url: "" + _secret.onlineUrl,
      withCredentials: false,
      body: (0, _index.makeQuery)(query)
    }).then(res, rej);
  });
};

var postTask = function postTask(url) {
  return function (_ref) {
    var dto = _ref.dto;
    return new _data2.default(function (rej, res) {
      return _mithril2.default.request({
        method: "POST",
        url: _secret.onlineUrl + "/" + url,
        body: dto,
        withCredentials: false
      }).then(res, rej);
    });
  };
};

var putTask = function putTask(url) {
  return function (_ref2) {
    var dto = _ref2.dto;
    return new _data2.default(function (rej, res) {
      return _mithril2.default.request({
        method: "PUT",
        url: _secret.onlineUrl + "/" + url,
        body: dto,
        withCredentials: false
      }).then(res, rej);
    });
  };
};

var getTask = function getTask(url) {
  return new _data2.default(function (rej, res) {
    return _mithril2.default.request({
      method: "GET",
      url: _secret.onlineUrl + "/" + url,
      withCredentials: false
    }).then(res, rej);
  });
};

var deleteTask = function deleteTask(url) {
  return function (id) {
    return new _data2.default(function (rej, res) {
      return _mithril2.default.request({
        method: "DELETE",
        url: _secret.onlineUrl + "/" + url + "/" + id,
        withCredentials: false
      }).then(res, rej);
    });
  };
};

exports.default = { postTask: postTask, putTask: putTask, getTask: getTask, deleteTask: deleteTask, postQl: postQl };

/***/ }),

/***/ "./src/services/animations.js":
/*!************************************!*\
  !*** ./src/services/animations.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bounceEntrance = exports.animeEntrance = exports.animateFadeOut = exports.animateFadeIn = exports.animateExit = exports.animateChildEntrance = exports.animateEntranceRight = exports.animateSlideEntrance = undefined;

var _animejs = __webpack_require__(/*! animejs */ "./node_modules/.registry.npmjs.org/animejs/3.0.1/node_modules/animejs/lib/anime.es.js");

var _animejs2 = _interopRequireDefault(_animejs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var animateSlideEntrance = exports.animateSlideEntrance = function animateSlideEntrance(_ref) {
  var dom = _ref.dom;

  return dom.animate([{ transform: "translate3d(20%,0,0)", opacity: 0 }, { transform: "none", opacity: 1 }], {
    duration: 650
  });
};

var animateEntranceRight = exports.animateEntranceRight = function animateEntranceRight(_ref2) {
  var dom = _ref2.dom;

  return dom.animate([{
    animation: "",
    transform: "translate3d(100%,0,0)",
    scale: 2,
    opacity: 0
  }, {
    animation: "stretchRight 1s ease-in-out both",
    transform: "none",
    opacity: 1,
    scale: 1
  }], {
    duration: 350
  });
};

var animateChildEntrance = exports.animateChildEntrance = function animateChildEntrance(_ref3) {
  var dom = _ref3.dom;

  console.log("wtf", dom);
  var children = [].concat(_toConsumableArray(dom.children));

  return children.map(function (child, index) {
    setTimeout(function () {
      child.animate([{ transform: "translate3d(0,-100%,0)", opacity: 0 }, { transform: "none", opacity: 1 }], {
        duration: 850
      });
    }, (index + 1) * 200);
  });
};

var animateExit = exports.animateExit = function animateExit(dom) {
  var children = [].concat(_toConsumableArray(dom.children));

  var anim = animate([{ transform: "none", opacity: 1 }, { transform: "translate3d(25%,100%,0)", opacity: 0 }]);

  var waapi = children.map(function (child) {
    return child.animate(anim, {
      duration: 850
    });
  });

  return new Promise(function (resolve) {
    waapi.onfinish = function (e) {
      resolve();
    };
  });
};

var animateFadeIn = exports.animateFadeIn = function animateFadeIn(_ref4) {
  var dom = _ref4.dom;

  var children = [].concat(_toConsumableArray(dom.children));
  children.map(function (child, index) {
    child.style.opacity = 0;
    child.style.transition = "opacity .4s ease-in-out";

    return setTimeout(function () {
      child.style.opacity = 1;
    }, (index + 1) * 200);
  });
};

var animateFadeOut = exports.animateFadeOut = function animateFadeOut(_ref5) {
  var dom = _ref5.dom;

  var anim = [{ transition: "opacity .4s ease-in-out" }, { transform: "none", opacity: 1 }, { transform: "translate3d(25%,100%,0)", opacity: 0 }];
  var waapi = dom.animate(anim, {
    duration: 850
  });

  return new Promise(function (resolve) {
    waapi.onfinish = function (e) {
      resolve();
    };
  });
};

var animeEntrance = exports.animeEntrance = function animeEntrance(_ref6) {
  var dom = _ref6.dom;

  var children = [].concat(_toConsumableArray(dom.children));
  console.log(children);
  var res = children.map(function (el) {
    return (0, _animejs2.default)({
      target: el,
      easing: "easeInQuad",
      translateX: 250,
      offset: 0
    });
  });

  console.log("anim", res);
  return res;
};

var bounceEntrance = exports.bounceEntrance = function bounceEntrance(_ref7) {
  var dom = _ref7.dom;

  return dom.animate({
    animation: "animation 1000ms linear both",
    keyframes: {
      "0%": {
        transform: "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "3.4%": {
        transform: "matrix3d(1.316, 0, 0, 0, 0, 1.407, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "4.7%": {
        transform: "matrix3d(1.45, 0, 0, 0, 0, 1.599, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "6.81%": {
        transform: "matrix3d(1.659, 0, 0, 0, 0, 1.893, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "9.41%": {
        transform: "matrix3d(1.883, 0, 0, 0, 0, 2.168, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "10.21%": {
        transform: "matrix3d(1.942, 0, 0, 0, 0, 2.226, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "13.61%": {
        transform: "matrix3d(2.123, 0, 0, 0, 0, 2.332, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "14.11%": {
        transform: "matrix3d(2.141, 0, 0, 0, 0, 2.331, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "17.52%": {
        transform: "matrix3d(2.208, 0, 0, 0, 0, 2.239, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "18.72%": {
        transform: "matrix3d(2.212, 0, 0, 0, 0, 2.187, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "21.32%": {
        transform: "matrix3d(2.196, 0, 0, 0, 0, 2.069, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "24.32%": {
        transform: "matrix3d(2.151, 0, 0, 0, 0, 1.96, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "25.23%": {
        transform: "matrix3d(2.134, 0, 0, 0, 0, 1.938, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "29.03%": {
        transform: "matrix3d(2.063, 0, 0, 0, 0, 1.897, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "29.93%": {
        transform: "matrix3d(2.048, 0, 0, 0, 0, 1.899, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "35.54%": {
        transform: "matrix3d(1.979, 0, 0, 0, 0, 1.962, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "36.74%": {
        transform: "matrix3d(1.972, 0, 0, 0, 0, 1.979, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "41.04%": {
        transform: "matrix3d(1.961, 0, 0, 0, 0, 2.022, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "44.44%": {
        transform: "matrix3d(1.966, 0, 0, 0, 0, 2.032, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "52.15%": {
        transform: "matrix3d(1.991, 0, 0, 0, 0, 2.006, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "59.86%": {
        transform: "matrix3d(2.006, 0, 0, 0, 0, 1.99, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "63.26%": {
        transform: "matrix3d(2.007, 0, 0, 0, 0, 1.992, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "75.28%": {
        transform: "matrix3d(2.001, 0, 0, 0, 0, 2.003, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "85.49%": {
        transform: "matrix3d(1.999, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "90.69%": {
        transform: "matrix3d(1.999, 0, 0, 0, 0, 1.999, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      },
      "100%": {
        transform: "matrix3d(2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
      }
    }
  });
};

/***/ }),

/***/ "./src/services/index.js":
/*!*******************************!*\
  !*** ./src/services/index.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeQuery = exports.wait = exports.repeat = exports.log = exports.viewModelMap = undefined;

var _mithrilStream = __webpack_require__(/*! mithril-stream */ "./node_modules/.registry.npmjs.org/mithril-stream/1.1.0/node_modules/mithril-stream/stream.js");

var _mithrilStream2 = _interopRequireDefault(_mithrilStream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var makeQuery = function makeQuery(string) {
  return JSON.parse(JSON.stringify(string));
};

var repeat = function repeat(n) {
  return function (f) {
    return function (x) {
      var m = n;
      while (true) {
        if (m === 0) return x;else m = m - 1, x = f(x);
      }
    };
  };
};

var wait = function wait(n) {
  return function (f) {
    return function (x) {
      var m = n;
      while (true) {
        if (m === 0) return x;else m = m - 1, x = f(x);
      }
    };
  };
};

var log = function log(m) {
  return function (v) {
    console.log(m, v);
    return v;
  };
};

var viewModelMap = function viewModelMap(signature) {
  var _map = {};
  return function (key) {
    if (!_map[key]) {
      _map[key] = {};
      for (var prop in signature) {
        _map[key][prop] = (0, _mithrilStream2.default)(signature[prop]());
      }
    }
    return _map[key];
  };
};
exports.viewModelMap = viewModelMap;
exports.log = log;
exports.repeat = repeat;
exports.wait = wait;
exports.makeQuery = makeQuery;

/***/ }),

/***/ "./src/services/requests.js":
/*!**********************************!*\
  !*** ./src/services/requests.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadSlideTask = exports.deleteSlideTask = exports.updateSlideTask = exports.saveSlideTask = exports.findSlidesTask = exports.deletePresentationsTask = exports.savePresentationTask = exports.getQlTask = exports.findPresentationsTask = undefined;

var _Tasks = __webpack_require__(/*! ./Tasks.js */ "./src/services/Tasks.js");

var _Tasks2 = _interopRequireDefault(_Tasks);

var _data = __webpack_require__(/*! data.task */ "./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/index.js");

var _data2 = _interopRequireDefault(_data);

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _index = __webpack_require__(/*! ./index.js */ "./src/services/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var findPresentationsTask = exports.findPresentationsTask = function findPresentationsTask() {
  return _Tasks2.default.getTask('presentations');
};

var getQlTask = exports.getQlTask = function getQlTask(query) {
  return _Tasks2.default.postQl({ query: query });
};

var savePresentationTask = exports.savePresentationTask = function savePresentationTask(dto) {
  return _Tasks2.default.postTask('presentations')({
    dto: dto
  });
};

var deletePresentationsTask = exports.deletePresentationsTask = function deletePresentationsTask(id) {
  return _Tasks2.default.deleteTask('presentations')(id);
};

var findSlidesTask = exports.findSlidesTask = function findSlidesTask(id) {
  return _Tasks2.default.getTask('presentations/' + id + '/slides');
};

var saveSlideTask = exports.saveSlideTask = function saveSlideTask(dto) {
  return _Tasks2.default.postTask('slides')({ dto: dto });
};

var updateSlideTask = exports.updateSlideTask = function updateSlideTask(id) {
  return function (dto) {
    return _Tasks2.default.putTask('slides/' + id)({ dto: dto });
  };
};

var deleteSlideTask = exports.deleteSlideTask = function deleteSlideTask(id) {
  return _Tasks2.default.deleteTask('slides')(id);
};

var loadSlideTask = exports.loadSlideTask = function loadSlideTask(id) {
  return _Tasks2.default.getTask('slides/' + id);
};

/***/ }),

/***/ "./src/slides/Preview/component.js":
/*!*****************************************!*\
  !*** ./src/slides/Preview/component.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _index = __webpack_require__(/*! ../../services/index.js */ "./src/services/index.js");

var _animations = __webpack_require__(/*! ../../services/animations.js */ "./src/services/animations.js");

var _model = __webpack_require__(/*! ../model.js */ "./src/slides/model.js");

var _remarkable = __webpack_require__(/*! remarkable */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/index.js");

var _remarkable2 = _interopRequireDefault(_remarkable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var md = new _remarkable2.default("full", {
  baseUrl: null,
  breaks: false,
  gfm: true,
  headerIds: true,
  headerPrefix: "",
  highlight: null,
  langPrefix: "lan-",
  mangle: true,
  pedantic: false,
  sanitize: false,
  sanitizer: null,
  silent: true,
  smartLists: true,
  smartypants: true,
  tables: true,
  xhtml: true,
  html: true,
  linkify: true,
  linkTarget: "",
  typographer: true,
  quotes: "ââââ"
});

var Preview = function Preview(_ref) {
  var _ref$attrs = _ref.attrs,
      getSlides = _ref$attrs.getSlides,
      Models = _ref$attrs.Models,
      s = _ref$attrs.s,
      key = _ref$attrs.key,
      state = _ref$attrs.state;

  var onError = function onError(task) {
    return function (error) {
      return (0, _index.log)("error with " + task)(error);
    };
  };
  var onSuccess = function onSuccess(_) {
    return getSlides({ attrs: { Models: Models } });
  };

  var updateAndSaveSlideTask = function updateAndSaveSlideTask(slides) {
    return (0, _model.updateSlideTask)(Models.CurrentPresentation.id)(slides).fork(onError("updating"), onSuccess);
  };

  var removeSlideTask = function removeSlideTask(s) {
    var tail = (0, _ramda.compose)((0, _ramda.map)(_model.reduceOrder), (0, _ramda.filter)((0, _model.forGreater)(s)))(state.right());
    var removeSlide = (0, _model.updateRemoveSlide)(s);

    var updateList = (0, _ramda.concat)(removeSlide, tail);

    updateAndSaveSlideTask(updateList);
  };

  var handleDragStart = function handleDragStart(ev) {
    ev.target.style.opacity = "0.4";
    ev.dataTransfer.effectAllowed = "move";
    ev.dataTransfer.setData("text/plain", "preview");
    state.previewDrag.drag = (0, _ramda.head)((0, _ramda.filter)((0, _ramda.propEq)("id", s.id), state.right()));
  };

  var handleDragOver = function handleDragOver(ev) {
    ev.preventDefault();

    if (state.previewDrag.drag) state.previewDrag.drop = s;
  };

  var handleDragLeave = function handleDragLeave(ev) {
    ev.preventDefault();
    state.previewDrag.drop = null;
  };

  var handleDrop = function handleDrop(ev) {
    return ev.preventDefault();
  };

  var handleDragEnd = function handleDragEnd(ev) {
    ev.target.style.opacity = "1";
    state.slideDrag.dragging = false;
    if (state.previewDrag.drop) {
      var start = state.previewDrag.drag.order;
      var end = state.previewDrag.drop.order;

      var dragged = state.previewDrag.drag;
      var dropped = state.previewDrag.drop;

      state.previewDrag.drag = Models.SlideModel;
      state.previewDrag.drop = Models.SlideModel;

      if (!(0, _ramda.eqProps)("id", dragged, dropped)) {
        dragged.order = end;
        dropped.order = start;

        updateAndSaveSlideTask([dragged, dropped]);
      }
    }
  };

  return {
    oncreate: function oncreate(_ref2) {
      var dom = _ref2.dom;
      return (0, _animations.animateFadeIn)({ dom: dom });
    },
    view: function view(_ref3) {
      var _ref3$attrs = _ref3.attrs,
          s = _ref3$attrs.s,
          state = _ref3$attrs.state;
      return (0, _mithril2.default)(".card.preview", {
        draggable: true,
        ondragstart: handleDragStart,
        ondragend: handleDragEnd,
        ondragover: handleDragOver,
        ondrop: handleDrop,
        ondragleave: handleDragLeave,
        style: {
          opacity: state.previewDrag.drop && state.previewDrag.drop.id == s.id ? 0.4 : 1
        }
      }, [(0, _mithril2.default)(".card-header", [(0, _mithril2.default)("span.slidePosition", s.order), (0, _mithril2.default)("a.preview-delete.card-delete", {
        onclick: function onclick() {
          return removeSlideTask(s);
        }
      })]), (0, _mithril2.default)(".card-body", _mithril2.default.trust(md.render(s.content)))]);
    }
  };
};

exports.default = Preview;

/***/ }),

/***/ "./src/slides/Slide/component.js":
/*!***************************************!*\
  !*** ./src/slides/Slide/component.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _data = __webpack_require__(/*! data.task */ "./node_modules/.registry.npmjs.org/data.task/3.1.2/node_modules/data.task/lib/index.js");

var _data2 = _interopRequireDefault(_data);

var _index = __webpack_require__(/*! ../../services/index.js */ "./src/services/index.js");

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _model = __webpack_require__(/*! ../model.js */ "./src/slides/model.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Slide = function Slide(_ref) {
  var _ref$attrs = _ref.attrs,
      getSlides = _ref$attrs.getSlides,
      Models = _ref$attrs.Models,
      s = _ref$attrs.s,
      key = _ref$attrs.key,
      state = _ref$attrs.state;

  var onError = function onError(task) {
    return function (error) {
      return (0, _index.log)('error with ' + task)(error);
    };
  };
  var onSuccess = function onSuccess(_) {
    return getSlides({ attrs: { Models: Models } });
  };

  var authDeleteTask = function authDeleteTask(id) {
    return window.confirm('Are you sure you want to delete?') ? _data2.default.of(id) : _data2.default.rejected(id);
  };

  var removeSlideTask = function removeSlideTask(id) {
    return authDeleteTask(id).chain((0, _model.deleteSlideTask)(state.presentationId)).fork(onError('deleting'), onSuccess);
  };

  var addSlideToShow = function addSlideToShow(s) {
    (0, _model.updateSlideTask)(state.presentationId)([s]).fork(onError('updating'), function (_) {
      state.slideDrag = {
        dragId: '',
        dragging: false,
        droppable: false
      };
      onSuccess();
    });
  };

  var handleDragStart = function handleDragStart(ev) {
    ev.target.style.opacity = '0.4';
    ev.dataTransfer.effectAllowed = 'move';
    ev.dataTransfer.setData('text/plain', 'slide');
    state.slideDrag = (0, _model.updateSlideDragStart)(s)(state.slideDrag);
  };

  var handleDragEnd = function handleDragEnd(ev) {
    ev.target.style.opacity = '1';
    if (state.slideDrag.droppable) {
      var _slide = (0, _model.updateSlideDragEnd)(state.right().length)(s);

      (0, _model.updateStateDragEnd)(state.slideDrag);
      return addSlideToShow(_slide);
    }
  };

  return {
    view: function view(_ref2) {
      var _ref2$attrs = _ref2.attrs,
          s = _ref2$attrs.s,
          state = _ref2$attrs.state;
      return (0, _mithril2.default)('.card', {
        id: s.id,
        draggable: true,
        ondragstart: handleDragStart,
        ondragend: handleDragEnd
      }, [(0, _mithril2.default)('div.card-header', [(0, _mithril2.default)('h1.title', (0, _mithril2.default)('span', (0, _ramda.take)(15, s.title))), (0, _mithril2.default)('button.card-delete', {
        onclick: function onclick() {
          return removeSlideTask(s.id);
        }
      })]), (0, _mithril2.default)('.card-footer', (0, _mithril2.default)('a.card-btn', {
        onclick: function onclick() {
          return _mithril2.default.route.set('/edit/' + state.presentationId + '/slide/' + s.id);
        }
      }, (0, _mithril2.default)('i.fas fa-edit')))]);
    }
  };
};

exports.default = Slide;

/***/ }),

/***/ "./src/slides/component.js":
/*!*********************************!*\
  !*** ./src/slides/component.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _mithrilStream = __webpack_require__(/*! mithril-stream */ "./node_modules/.registry.npmjs.org/mithril-stream/1.1.0/node_modules/mithril-stream/stream.js");

var _mithrilStream2 = _interopRequireDefault(_mithrilStream);

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _slidesModal = __webpack_require__(/*! ./slidesModal.js */ "./src/slides/slidesModal.js");

var _slidesModal2 = _interopRequireDefault(_slidesModal);

var _component = __webpack_require__(/*! ./Slide/component.js */ "./src/slides/Slide/component.js");

var _component2 = _interopRequireDefault(_component);

var _component3 = __webpack_require__(/*! ./Preview/component.js */ "./src/slides/Preview/component.js");

var _component4 = _interopRequireDefault(_component3);

var _model = __webpack_require__(/*! ./model.js */ "./src/slides/model.js");

var _index = __webpack_require__(/*! ../services/index.js */ "./src/services/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Slides = function Slides(_ref) {
  var Models = _ref.attrs.Models;

  var state = {
    left: (0, _mithrilStream2.default)([]),
    right: (0, _mithrilStream2.default)([]),
    slideDrag: {
      dragId: "",
      dragging: false,
      droppable: false
    },
    previewDrag: {
      drag: null,
      drop: null
    },
    presentationId: ""
  };

  var onError = (0, _index.log)("error");

  var onSuccess = function onSuccess(presentation) {
    var slides = Models.CurrentPresentation.Slides;

    state.left((0, _ramda.filter)((0, _ramda.propEq)("order", 0), slides));

    state.right((0, _ramda.sortBy)((0, _ramda.prop)("order"), (0, _ramda.without)(state.left(), slides)));

    Models.CurrentPresentation.slideShow = (0, _mithrilStream2.default)(state.right());
  };

  var getSlides = function getSlides(_ref2) {
    var Models = _ref2.attrs.Models;

    state.presentationId = _mithril2.default.route.param("id");
    return (0, _model.loadSlides)(state.presentationId)(Models).fork(onError, onSuccess);
  };

  var handleDragEnter = function handleDragEnter(ev) {
    ev.preventDefault();
    state.bColor = true;
  };

  var handleDragLeave = function handleDragLeave(ev) {
    ev.preventDefault();
    state.slideDrag.dragging = false;
    state.slideDrag.droppable = false;
    state.bColor = false;
  };

  var handleDrop = function handleDrop(ev) {
    ev.preventDefault();
    var type = ev.dataTransfer.getData("text/plain");
    if (state.slideDrag.dragging) {
      if (type == "slide") {
        var item = (0, _ramda.head)((0, _ramda.filter)((0, _ramda.propEq)("id", state.slideDrag.dragId), state.left()));
        state.slideDrag.droppable = true;
        item.order = state.right().length + 1;
        state.left((0, _ramda.without)([item], state.left()));
        state.right((0, _ramda.concat)(state.right(), [item]));
      } else {
        var _item = (0, _ramda.head)((0, _ramda.filter)((0, _ramda.propEq)("id", state.slideDrag.dragId), state.right()));
      }
    }
  };

  var handleDragOver = function handleDragOver(ev) {
    ev.preventDefault();
    var type = ev.dataTransfer.getData("text/plain");
    state.slideDrag.dragging = true;
    ev.dataTransfer.dropEffect = "move";
  };

  return {
    oninit: getSlides,
    view: function view(_ref3) {
      var Models = _ref3.attrs.Models;
      return [Models.toggleModal ? (0, _mithril2.default)(_slidesModal2.default, {
        toggleModal: function toggleModal() {
          return Models.toggleModal = !Models.toggleModal;
        },
        left: state.left,
        slide: (0, _ramda.clone)(Models.SlideModel),
        getSlides: getSlides,
        Models: Models,
        pId: state.presentationId
      }) : "", (0, _mithril2.default)(".container.slides", [(0, _mithril2.default)("aside.left-drag " + (state.left().length == 0 ? ".isDragging" : ""), {
        onBeforeRemove: function onBeforeRemove(vnode, done) {
          vnode.dom.addEventListener("animationend", done);
          vnode.dom.style.animation = "fadeOut 1s";
        }
      }, [state.left().map(function (s) {
        return (0, _mithril2.default)(_component2.default, {
          key: s.id,
          Models: Models,
          getSlides: getSlides,
          s: s,
          state: state
        });
      })]), (0, _mithril2.default)("section.right-drag" + (state.slideDrag.dragging ? ".isDragging" : ""), {
        onBeforeRemove: function onBeforeRemove(vnode, done) {
          vnode.dom.addEventListener("animationend", done);
          vnode.dom.style.animation = "fadeOut 1s";
        },
        ondragleave: handleDragLeave,
        ondrop: handleDrop,
        ondragover: handleDragOver,
        ondragenter: handleDragEnter
      }, state.right().map(function (s) {
        return (0, _mithril2.default)(_component4.default, {
          key: s.id,
          Models: Models,
          getSlides: getSlides,
          s: s,
          state: state
        });
      }))])];
    }
  };
};

exports.default = Slides;

/***/ }),

/***/ "./src/slides/model.js":
/*!*****************************!*\
  !*** ./src/slides/model.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateSlideTask = exports.deleteSlideTask = exports.saveSlideTask = exports.loadSlides = exports.updateStateDragEnd = exports.updateSlideDragEnd = exports.updateSlideDragStart = exports.updateRemoveSlide = exports.getId = exports.reduceOrder = exports.forLess = exports.forGreater = exports.toStruct = undefined;

var _requests = __webpack_require__(/*! ../services/requests.js */ "./src/services/requests.js");

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var toViewModel = function toViewModel(model) {
  return function (presentations) {
    return model.CurrentPresentation = presentations;
  };
};

var toStruct = exports.toStruct = function toStruct(acc, item) {
  if (item.order > 0 && !acc.keys.has(item.id)) {
    item.order = acc.keys.size + 1;
    acc.keys.add(item.id);
    acc.values[item.order] = item;
    acc.items(Object.keys(acc.values));
    return acc;
  }
  return acc;
};

var orderOf = function orderOf(slide) {
  return (0, _ramda.prop)('order', slide);
};

var forGreater = exports.forGreater = function forGreater(removeSlide) {
  return function (checkSlide) {
    return (0, _ramda.lt)(orderOf(removeSlide), orderOf(checkSlide));
  };
};

var forLess = exports.forLess = function forLess(removeSlide) {
  return function (checkSlide) {
    return (0, _ramda.gt)(orderOf(removeSlide), orderOf(checkSlide));
  };
};

var reduceOrder = exports.reduceOrder = function reduceOrder(slide) {
  return (0, _ramda.set)((0, _ramda.lensProp)('order', slide), (0, _ramda.subtract)(orderOf(slide), 1), slide);
};

var getId = exports.getId = function getId(item) {
  return (0, _ramda.prop)('id', item);
};

var resetOrder = function resetOrder(slide) {
  return (0, _ramda.set)((0, _ramda.lensProp)('order', slide), 0, slide);
};

var updateRemoveSlide = exports.updateRemoveSlide = (0, _ramda.compose)(Array.of, resetOrder);

var updateId = function updateId(slide) {
  return function (slideDrag) {
    return (0, _ramda.set)((0, _ramda.lensProp)('dragId', slideDrag), (0, _ramda.prop)('id', slide), slideDrag);
  };
};

var updateSlideDragStart = exports.updateSlideDragStart = function updateSlideDragStart(slide) {
  return (0, _ramda.compose)(updateId(slide), updateDrag);
};

var updateOrder = function updateOrder(length) {
  return function (slide) {
    return (0, _ramda.set)((0, _ramda.lensProp)('order'), length, slide);
  };
};

var updateSlideDragEnd = exports.updateSlideDragEnd = function updateSlideDragEnd(length) {
  return (0, _ramda.compose)(updateOrder(length));
};

var updateDrag = function updateDrag(state) {
  return (0, _ramda.set)((0, _ramda.lensProp)('dragging', false, state));
};

var updateDrop = function updateDrop(state) {
  return (0, _ramda.set)((0, _ramda.lensProp)('droppable', false, state));
};

var updateStateDragEnd = exports.updateStateDragEnd = (0, _ramda.compose)(updateDrop, updateDrag);

var loadSlides = exports.loadSlides = function loadSlides(id) {
  return function (model) {
    return (0, _requests.getQlTask)('{ presentation(where:{id:' + JSON.stringify(id) + '}){\n      id, title, Slides { id title content order }\n    } }').map((0, _ramda.path)(['data', 'presentation'])).map(toViewModel(model));
  };
};

var saveSlideTask = exports.saveSlideTask = function saveSlideTask(_ref) {
  var title = _ref.title,
      order = _ref.order,
      presentation_id = _ref.presentation_id;

  var q = 'mutation {\n            updatePresentation(\n              where: {\n                id: ' + JSON.stringify(presentation_id) + '\n              }\n              data: {\n                  Slides:{\n                    create : {\n                      title: ' + JSON.stringify(title) + '\n                      content: ""\n                      order: ' + JSON.stringify(order) + '\n                    }\n                  } \n          }){\n    id title Slides { id title content order }\n  } }';

  return (0, _requests.getQlTask)(q).map((0, _ramda.path)(['data', 'updatePresentation', 'Slides']));
};

var deleteSlideTask = exports.deleteSlideTask = function deleteSlideTask(presentation_id) {
  return function (id) {
    var q = 'mutation {\n            updatePresentation(\n              where: {\n                id: ' + JSON.stringify(presentation_id) + '\n              }\n              data: {\n                  Slides:{\n                    delete : [{\n                      id: ' + JSON.stringify(id) + '\n                    }]\n                  } \n          }){\n    id title Slides { id title content order}\n  } }';

    return (0, _requests.getQlTask)(q).map((0, _ramda.path)(['data', 'updatePresentation', 'Slides']));
  };
};

var updateSlideTask = exports.updateSlideTask = function updateSlideTask(presentation_id) {
  return function (slides) {
    var qlSlides = slides.map(function (slide) {
      return '{\n      where: {\n        id: ' + JSON.stringify(slide.id) + '\n      }\n      data: {\n        order: ' + JSON.stringify(slide.order) + '\n      }\n    }';
    });

    var q = 'mutation {\n            updatePresentation(\n              where: {\n                id: ' + JSON.stringify(presentation_id) + '\n              }\n              data: {\n                Slides:{\n                  update : [' + qlSlides + ']\n                }\n              }\n            )\n          { id title Slides { id title content order } } \n        }';

    return (0, _requests.getQlTask)(q).map((0, _ramda.path)(['data', 'updatePresentation', 'Slides']));
  };
};

/***/ }),

/***/ "./src/slides/slidesModal.js":
/*!***********************************!*\
  !*** ./src/slides/slidesModal.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _model = __webpack_require__(/*! ./model.js */ "./src/slides/model.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SlidesModal = function SlidesModal(_ref) {
  var _ref$attrs = _ref.attrs,
      left = _ref$attrs.left,
      pId = _ref$attrs.pId,
      slide = _ref$attrs.slide,
      toggleModal = _ref$attrs.toggleModal,
      getSlides = _ref$attrs.getSlides,
      Models = _ref$attrs.Models;

  var state = {
    errors: "",
    title: ""
  };

  var onError = function onError(errors) {
    log("error")(errors);
    state.errors = errors;
  };

  var onSuccess = function onSuccess(slides) {
    getSlides({ attrs: { Models: Models } });
    return toggleModal();
  };

  var save = function save(e) {
    e.preventDefault();
    var dto = (0, _ramda.assoc)("presentation_id", pId, (0, _ramda.assoc)("title", state.title, slide));
    (0, _model.saveSlideTask)(dto).fork(onError, onSuccess);
  };

  return {
    view: function view() {
      return (0, _mithril2.default)("article.modal-container", [(0, _mithril2.default)(".card", [(0, _mithril2.default)(".card-header", (0, _mithril2.default)("button.card-delete", {
        onclick: function onclick() {
          return toggleModal();
        },
        "aria-label": "close"
      })), (0, _mithril2.default)(".card-body", [(0, _mithril2.default)("fieldset", [(0, _mithril2.default)("label.modal-label", "Slide Title"), (0, _mithril2.default)("input.modal-input", {
        autofocus: true,
        type: "text",
        onchange: function onchange(e) {
          return state.title = e.target.value;
        }
      })])]), (0, _mithril2.default)(".card-footer", (0, _mithril2.default)("button.card-btn", { onclick: save }, "save slide"))])]);
    }
  };
};

exports.default = SlidesModal;

/***/ }),

/***/ "./src/slideshow/component.js":
/*!************************************!*\
  !*** ./src/slideshow/component.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mithril = __webpack_require__(/*! mithril */ "./node_modules/.registry.npmjs.org/mithril/2.0.0-rc.7/node_modules/mithril/index.js");

var _mithril2 = _interopRequireDefault(_mithril);

var _ramda = __webpack_require__(/*! ramda */ "./node_modules/.registry.npmjs.org/ramda/0.25.0/node_modules/ramda/es/index.js");

var _animations = __webpack_require__(/*! ../services/animations.js */ "./src/services/animations.js");

var _remarkable = __webpack_require__(/*! remarkable */ "./node_modules/.registry.npmjs.org/remarkable/1.7.1/node_modules/remarkable/index.js");

var _remarkable2 = _interopRequireDefault(_remarkable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var md = new _remarkable2.default("full", {
  baseUrl: null,
  breaks: false,
  gfm: true,
  headerIds: true,
  headerPrefix: "",
  highlight: null,
  langPrefix: "lan-",
  mangle: true,
  pedantic: false,
  sanitize: false,
  sanitizer: null,
  silent: true,
  smartLists: true,
  smartypants: true,
  tables: true,
  xhtml: true,
  html: true,
  linkify: true,
  linkTarget: "",
  typographer: true,
  quotes: "ââââ"
});

var SlideShow = function SlideShow(_ref) {
  var Models = _ref.attrs.Models;

  var state = {
    cursor: 0,
    isFullscreenWidth: "vh",
    isFullscreenHeight: "%",
    clicks: 0,
    size: Models.CurrentPresentation.slideShow().length,
    contents: (0, _ramda.pluck)("content", Models.CurrentPresentation.slideShow())
  };

  var nextSlide = function nextSlide(dom) {
    dom.children[0].children[0].scrollIntoView({ behaviour: "smooth" });
    state.cursor == state.size - 1 ? state.cursor : state.cursor++;
  };

  var prevSlide = function prevSlide(dom) {
    dom.children[0].children[0].scrollIntoView({ behaviour: "smooth" });
    state.cursor == 0 ? state.cursor : state.cursor--;
  };

  var changeSlide = function changeSlide(key, target) {
    switch (key) {
      case "ArrowLeft":
        prevSlide(target);
        break;
      case "ArrowRight":
        nextSlide(target);
        break;
    }
  };

  return {
    oninit: state.slide = state.contents[state.cursor],
    view: function view(_ref2) {
      var Models = _ref2.attrs.Models;

      return (0, _mithril2.default)(".slideshow", {
        tabindex: 0,
        onkeyup: function onkeyup(_ref3) {
          var key = _ref3.key,
              target = _ref3.target;

          changeSlide(key, target);
        }
      }, (0, _mithril2.default)(".slidecard", {
        onupdate: function onupdate(_ref4) {
          var dom = _ref4.dom;
          return (0, _animations.animateEntranceRight)({ dom: dom });
        }
      }, _mithril2.default.trust(md.render(state.contents[state.cursor]) || "~ FIN ~")));
    }
  };
};

exports.default = SlideShow;

/***/ }),

/***/ "./src/styles/index.css":
/*!******************************!*\
  !*** ./src/styles/index.css ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader!./index.css */ "./node_modules/.registry.npmjs.org/css-loader/0.28.11/node_modules/css-loader/index.js!./src/styles/index.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/.registry.npmjs.org/style-loader/0.20.3/node_modules/style-loader/lib/addStyles.js */ "./node_modules/.registry.npmjs.org/style-loader/0.20.3/node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvYW5pbWVqcy8zLjAuMS9ub2RlX21vZHVsZXMvYW5pbWVqcy9saWIvYW5pbWUuZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvYXV0b2xpbmtlci8wLjE1LjMvbm9kZV9tb2R1bGVzL2F1dG9saW5rZXIvZGlzdC9BdXRvbGlua2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMvYW5pbWF0aW9ucy5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy9lZGl0b3IuY3NzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMvaW5kZXguY3NzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMvbW9kYWwuY3NzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMvcHJlc2VudGF0aW9ucy5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy9wcmV2aWV3LmNzcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL3NsaWRlcy5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy9zbGlkZXNob3cuY3NzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMvdG9vbGJhci5jc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9kYXRhLnRhc2svMy4xLjIvbm9kZV9tb2R1bGVzL2RhdGEudGFzay9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvZGF0YS50YXNrLzMuMS4yL25vZGVfbW9kdWxlcy9kYXRhLnRhc2svbGliL3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC1zdHJlYW0vMS4xLjAvbm9kZV9tb2R1bGVzL21pdGhyaWwtc3RyZWFtL3N0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9taXRocmlsLzIuMC4wLXJjLjcvbm9kZV9tb2R1bGVzL21pdGhyaWwvYXBpL21vdW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9hcGkvcmVkcmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9hcGkvcm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9oeXBlcnNjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9taXRocmlsLzIuMC4wLXJjLjcvbm9kZV9tb2R1bGVzL21pdGhyaWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL21vdW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9wYXRobmFtZS9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL3BhdGhuYW1lL2J1aWxkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9wYXRobmFtZS9jb21waWxlVGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL3BhdGhuYW1lL3BhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9wcm9taXNlL3BvbHlmaWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9wcm9taXNlL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL3F1ZXJ5c3RyaW5nL2J1aWxkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9xdWVyeXN0cmluZy9wYXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9taXRocmlsLzIuMC4wLXJjLjcvbm9kZV9tb2R1bGVzL21pdGhyaWwvcmVkcmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9yZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL3JlbmRlci9mcmFnbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9taXRocmlsLzIuMC4wLXJjLjcvbm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyL2h5cGVyc2NyaXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9yZW5kZXIvaHlwZXJzY3JpcHRWbm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9taXRocmlsLzIuMC4wLXJjLjcvbm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyL3JlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9taXRocmlsLzIuMC4wLXJjLjcvbm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyL3RydXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL21pdGhyaWwvMi4wLjAtcmMuNy9ub2RlX21vZHVsZXMvbWl0aHJpbC9yZW5kZXIvdm5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL3JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL3JlcXVlc3QvcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9taXRocmlsLzIuMC4wLXJjLjcvbm9kZV9tb2R1bGVzL21pdGhyaWwvcm91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvbWl0aHJpbC8yLjAuMC1yYy43L25vZGVfbW9kdWxlcy9taXRocmlsL3JvdXRlci9yb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcHJvY2Vzcy8wLjExLjEwL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9GLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvVC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL19fLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYWRkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYWRkSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hZGp1c3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hbGxQYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYWx3YXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYW55LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYW55UGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2FwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYXBlcnR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hcHBlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hcHBseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2FwcGx5U3BlYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2FwcGx5VG8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hc2NlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hc3NvYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Fzc29jUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2JpbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2JpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9ib3RoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2NoYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY2xhbXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2NvbXBhcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jb21wbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29tcG9zZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2NvbXBvc2VLLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29tcG9zZVAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jb25jYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jb25kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29uc3RydWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29uc3RydWN0Ti5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2NvbnRhaW5zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29udmVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jb3VudEJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY3VycnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jdXJyeU4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9kZWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9kZWZhdWx0VG8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9kZXNjZW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZGlmZmVyZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2RpZmZlcmVuY2VXaXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZGlzc29jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZGlzc29jUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2RpdmlkZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Ryb3AuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9kcm9wTGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Ryb3BMYXN0V2hpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9kcm9wUmVwZWF0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Ryb3BSZXBlYXRzV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Ryb3BXaGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2VpdGhlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2VtcHR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZW5kc1dpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9lcUJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZXFQcm9wcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2V2b2x2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9maW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9maW5kTGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ZpbmRMYXN0SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9mbGF0dGVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZmxpcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ZvckVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9mb3JFYWNoT2JqSW5kZXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Zyb21QYWlycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2dyb3VwQnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9ncm91cFdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9ndC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2d0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2hhc0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaGVhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2lkZW50aWNhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2lkZW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaWZFbHNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbmRleEJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW5kZXhPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2luaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbm5lckpvaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnNlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnNlcnRBbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2FwZXJ0dXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2FyaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2FycmF5RnJvbUl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jaGVja0Zvck1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jbG9uZVJlZ0V4cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jb21wbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2NvbmNhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jb250YWlucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jb250YWluc1dpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fY3VycnkxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2N1cnJ5Mi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jdXJyeTMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fY3VycnlOLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19kcm9wTGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19kcm9wTGFzdFdoaWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fZmxhdENhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19mb3JjZVJlZHVjZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fZnVuY3Rpb25OYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pbmRleE9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pc0ludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNOdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNQbGFjZWhvbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pc1JlZ0V4cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pc1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pc1RyYW5zZm9ybWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX21ha2VGbGF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX21hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19vYmplY3RBc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fcGlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19waXBlUC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19xdW90ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fcmVkdWNlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19zdGVwQ2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3RvSVNPU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3RvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feGFueS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194YXBlcnR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feGNoYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hkcm9wLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hkcm9wTGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194ZHJvcExhc3RXaGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194ZHJvcFJlcGVhdHNXaXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hkcm9wV2hpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feGZCYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hmaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feGZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feGZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194ZmluZExhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feGZpbmRMYXN0SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feG1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194cmVkdWNlQnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feHRha2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feHRha2VXaGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194dGFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3h3cmFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJzZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJzcGVyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW52ZXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW52ZXJ0T2JqLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW52b2tlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2lzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaXNFbXB0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2lzTmlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvam9pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2p1eHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMva2V5c0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2xhc3RJbmRleE9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGVucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2xlbnNJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2xlbnNQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGVuc1Byb3AuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9saWZ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGlmdE4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9sdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2x0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21hcEFjY3VtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbWFwQWNjdW1SaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21hcE9iakluZGV4ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21hdGhNb2QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tYXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tYXhCeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21lYW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZWRpYW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZW1vaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbWVtb2l6ZVdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZXJnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21lcmdlQWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbWVyZ2VEZWVwTGVmdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21lcmdlRGVlcFJpZ2h0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbWVyZ2VEZWVwV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21lcmdlRGVlcFdpdGhLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZXJnZVdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZXJnZVdpdGhLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9taW5CeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21vZHVsby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL211bHRpcGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbkFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL25lZ2F0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL25vbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9ub3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9udGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9udGhBcmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9vLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvb2JqT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL29taXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9vbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9vdmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGFpci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3BhcnRpYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wYXJ0aWFsUmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wYXJ0aXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGF0aEVxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGF0aE9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGF0aFNhdGlzZmllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3BpY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9waWNrQWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGlja0J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3BpcGVLLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGlwZVAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wbHVjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3ByZXBlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wcm9kdWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcHJvamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3Byb3AuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wcm9wRXEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wcm9wSXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wcm9wT3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wcm9wU2F0aXNmaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcHJvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9yYW5nZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3JlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3JlZHVjZUJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcmVkdWNlUmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9yZWR1Y2VXaGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3JlZHVjZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9yZWplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9yZXBsYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcmV2ZXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NjYW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9zZXF1ZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NsaWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NvcnRCeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NvcnRXaXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvc3BsaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9zcGxpdEF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvc3BsaXRFdmVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NwbGl0V2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3N0YXJ0c1dpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9zdWJ0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3N1bS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3N5bW1ldHJpY0RpZmZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9zeW1tZXRyaWNEaWZmZXJlbmNlV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3RhaWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90YWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdGFrZUxhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90YWtlTGFzdFdoaWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdGFrZVdoaWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdGFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdGVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3RpbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdG9Mb3dlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3RvUGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90b1BhaXJzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90b1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3RvVXBwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90cmFuc2R1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90cmFuc3Bvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90cmF2ZXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3RyaW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90cnlDYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy91bmFwcGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy91bmN1cnJ5Ti5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3VuZm9sZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3VuaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW5pb25XaXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW5pcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3VuaXFCeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3VuaXFXaXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW5sZXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW5uZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW50aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy91cGRhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy91c2VXaXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdmFsdWVzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy92aWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvd2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3doZXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JhbWRhLzAuMjUuMC9ub2RlX21vZHVsZXMvcmFtZGEvZXMvd2hlcmVFcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3dpdGhvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmFtZGEvMC4yNS4wL25vZGVfbW9kdWxlcy9yYW1kYS9lcy94cHJvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3ppcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3ppcE9iai5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yYW1kYS8wLjI1LjAvbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3ppcFdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9jb21tb24vZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvY29tbW9uL2h0bWxfYmxvY2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL2NvbW1vbi9odG1sX3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL2NvbW1vbi91cmxfc2NoZW1hcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9jb21tb24vdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvY29uZmlncy9jb21tb25tYXJrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL2NvbmZpZ3MvZGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9jb25maWdzL2Z1bGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvaGVscGVycy9ub3JtYWxpemVfbGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9oZWxwZXJzL25vcm1hbGl6ZV9yZWZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvaGVscGVycy9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcGFyc2VyX2Jsb2NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3BhcnNlcl9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3BhcnNlcl9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfYmxvY2svYmxvY2txdW90ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19ibG9jay9jb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2Jsb2NrL2RlZmxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfYmxvY2svZmVuY2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2Jsb2NrL2Zvb3Rub3RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfYmxvY2svaHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfYmxvY2svaHRtbGJsb2NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2Jsb2NrL2xoZWFkaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2Jsb2NrL2xpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfYmxvY2svcGFyYWdyYXBoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2Jsb2NrL3RhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2NvcmUvYWJici5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19jb3JlL2FiYnIyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2NvcmUvYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfY29yZS9mb290bm90ZV90YWlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2NvcmUvaW5saW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19jb3JlL3JlZmVyZW5jZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfY29yZS9zbWFydHF1b3Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19pbmxpbmUvYXV0b2xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfaW5saW5lL2JhY2t0aWNrcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19pbmxpbmUvZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS9lbXBoYXNpcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19pbmxpbmUvZW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfaW5saW5lL2Zvb3Rub3RlX2lubGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19pbmxpbmUvZm9vdG5vdGVfcmVmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS9odG1sdGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS9pbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfaW5saW5lL2xpbmtzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS9tYXJrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS9uZXdsaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvcmVtYXJrYWJsZS8xLjcuMS9ub2RlX21vZHVsZXMvcmVtYXJrYWJsZS9saWIvcnVsZXNfaW5saW5lL3N1Yi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9yZW1hcmthYmxlLzEuNy4xL25vZGVfbW9kdWxlcy9yZW1hcmthYmxlL2xpYi9ydWxlc19pbmxpbmUvc3VwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3JlbWFya2FibGUvMS43LjEvbm9kZV9tb2R1bGVzL3JlbWFya2FibGUvbGliL3J1bGVzX2lubGluZS90ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3NldGltbWVkaWF0ZS8xLjAuNS9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9zdHlsZS1sb2FkZXIvMC4yMC4zL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9zdHlsZS1sb2FkZXIvMC4yMC4zL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvdGltZXJzLWJyb3dzZXJpZnkvMi4wLjEwL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc2VjcmV0LmpzIiwid2VicGFjazovLy8uL3NyYy9BcHAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL01vZGVscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvVG9vbGJhci9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VkaXRvci9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VkaXRvci9tb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xheW91dC9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ByZXNlbnRhdGlvbnMvUHJlc2VudGF0aW9uL2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcHJlc2VudGF0aW9ucy9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ByZXNlbnRhdGlvbnMvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ByZXNlbnRhdGlvbnMvcHJlc2VudGF0aW9uTW9kYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlcnZpY2VzL1Rhc2tzLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXJ2aWNlcy9hbmltYXRpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXJ2aWNlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2VydmljZXMvcmVxdWVzdHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NsaWRlcy9QcmV2aWV3L2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2xpZGVzL1NsaWRlL2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2xpZGVzL2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2xpZGVzL21vZGVsLmpzIiwid2VicGFjazovLy8uL3NyYy9zbGlkZXMvc2xpZGVzTW9kYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NsaWRlc2hvdy9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy9pbmRleC5jc3M/OWJlNCJdLCJuYW1lcyI6WyJvbmxpbmVVcmwiLCJtYWtlUm91dGVzIiwibW9kZWwiLCJtZGwiLCJ2aWV3IiwiTGF5b3V0IiwiUHJlc2VudGF0aW9ucyIsIlNsaWRlcyIsIkVkaXRvciIsIlNsaWRlU2hvdyIsIkFwcCIsImF0dHJzIiwic3RhdGUiLCJlcnJvcnMiLCJvbkVycm9yIiwiZXJyb3IiLCJvblN1Y2Nlc3MiLCJNb2RlbHMiLCJkdG8iLCJmaW5kUHJlc2VudGF0aW9ucyIsImZvcmsiLCJvbmluaXQiLCJvbmNyZWF0ZSIsImRvbSIsIm1haW4iLCJxdWVyeVNlbGVjdG9yIiwibSIsInJvdXRlIiwiY2hpbGRyZW4iLCJTbGlkZU1vZGVsIiwidGl0bGUiLCJjb250ZW50cyIsIm9yZGVyIiwicHJlc2VudGF0aW9uX2lkIiwiU2xpZGVTaG93U3RydWN0Iiwia2V5cyIsIlNldCIsInZhbHVlcyIsIml0ZW1zIiwiQ3VycmVudFByZXNlbnRhdGlvbiIsImlkIiwic2xpZGVTaG93IiwiZ2V0UHJvZmlsZSIsInciLCJwcm9maWxlIiwid2luZG93IiwiaW5uZXJXaWR0aCIsInRvZ2dsZU1vZGFsIiwib25jbGljayIsInRvUHJlc2VudGF0aW9ucyIsImxpbmsiLCJocmVmIiwidG9TbGlkZXMiLCJ0b1NsaWRlU2hvdyIsImRpc2FibGVkIiwibmF2VmlldyIsInBhZ2UiLCJhY3Rpb25WaWV3IiwiVG9vbGJhciIsImN1cnJlbnRQYWdlIiwiZ2V0IiwibWQiLCJyZW1hcmthYmxlIiwiYmFzZVVybCIsImJyZWFrcyIsImdmbSIsImhlYWRlcklkcyIsImhlYWRlclByZWZpeCIsImhpZ2hsaWdodCIsImxhbmdQcmVmaXgiLCJtYW5nbGUiLCJwZWRhbnRpYyIsInNhbml0aXplIiwic2FuaXRpemVyIiwic2lsZW50Iiwic21hcnRMaXN0cyIsInNtYXJ0eXBhbnRzIiwidGFibGVzIiwieGh0bWwiLCJodG1sIiwibGlua2lmeSIsImxpbmtUYXJnZXQiLCJ0eXBvZ3JhcGhlciIsInF1b3RlcyIsInByZXNlbnRhdGlvbklkIiwic2xpZGUiLCJjb250ZW50Iiwic2V0IiwibG9nIiwiZ2V0U2xpZGUiLCJwYXJhbSIsInVwZGF0ZUlucHV0IiwiaW5wdXQiLCJlIiwidGFyZ2V0IiwidmFsdWUiLCJzYXZlIiwicHJldmVudERlZmF1bHQiLCJ0eXBlIiwicGxhY2Vob2xkZXIiLCJvbmlucHV0IiwidHJ1c3QiLCJyZW5kZXIiLCJsb2FkU2xpZGUiLCJxIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1hcCIsImVkaXRTbGlkZSIsInJvb3QiLCJkb2N1bWVudCIsImJvZHkiLCJQcmVzZW50YXRpb24iLCJ0YXNrIiwiZGVsZXRlZCIsImF1dGhEZWxldGVUYXNrIiwiY29uZmlybSIsIlRhc2siLCJvZiIsInJlamVjdGVkIiwicmVtb3ZlUHJlc1Rhc2siLCJwSWQiLCJjaGFpbiIsImRlbGV0ZVByZXNlbnRhdGlvbnNUYXNrIiwiUHJlc2VudGF0aW9uTW9kYWwiLCJwcmVzZW50YXRpb25zIiwicHJlc2VudGF0aW9uTW9kZWwiLCJQcmVzZW50YXRpb25Nb2RlbCIsIm9uQmVmb3JlUmVtb3ZlIiwidm5vZGUiLCJkb25lIiwiYWRkRXZlbnRMaXN0ZW5lciIsInN0eWxlIiwiYW5pbWF0aW9uIiwia2V5IiwidG9WaWV3TW9kZWwiLCJkYXRhIiwiY29uc29sZSIsImdldFByZXNlbnRhdGlvbnMiLCJzYXZlUHJlc2VudGF0aW9uVGFzayIsInB1c2giLCJwIiwiYXV0b2ZvY3VzIiwib25jaGFuZ2UiLCJwb3N0UWwiLCJyZWoiLCJyZXMiLCJyZXF1ZXN0IiwibWV0aG9kIiwidXJsIiwid2l0aENyZWRlbnRpYWxzIiwicXVlcnkiLCJ0aGVuIiwicG9zdFRhc2siLCJwdXRUYXNrIiwiZ2V0VGFzayIsImRlbGV0ZVRhc2siLCJhbmltYXRlU2xpZGVFbnRyYW5jZSIsImFuaW1hdGUiLCJ0cmFuc2Zvcm0iLCJvcGFjaXR5IiwiZHVyYXRpb24iLCJhbmltYXRlRW50cmFuY2VSaWdodCIsInNjYWxlIiwiYW5pbWF0ZUNoaWxkRW50cmFuY2UiLCJjaGlsZCIsImluZGV4Iiwic2V0VGltZW91dCIsImFuaW1hdGVFeGl0IiwiYW5pbSIsIndhYXBpIiwiUHJvbWlzZSIsInJlc29sdmUiLCJvbmZpbmlzaCIsImFuaW1hdGVGYWRlSW4iLCJ0cmFuc2l0aW9uIiwiYW5pbWF0ZUZhZGVPdXQiLCJhbmltZUVudHJhbmNlIiwiZWwiLCJlYXNpbmciLCJ0cmFuc2xhdGVYIiwib2Zmc2V0IiwiYm91bmNlRW50cmFuY2UiLCJrZXlmcmFtZXMiLCJtYWtlUXVlcnkiLCJwYXJzZSIsInN0cmluZyIsInJlcGVhdCIsIm4iLCJ4IiwiZiIsIndhaXQiLCJ2Iiwidmlld01vZGVsTWFwIiwiX21hcCIsInByb3AiLCJzaWduYXR1cmUiLCJmaW5kUHJlc2VudGF0aW9uc1Rhc2siLCJodHRwVGFza3MiLCJnZXRRbFRhc2siLCJmaW5kU2xpZGVzVGFzayIsInNhdmVTbGlkZVRhc2siLCJ1cGRhdGVTbGlkZVRhc2siLCJkZWxldGVTbGlkZVRhc2siLCJsb2FkU2xpZGVUYXNrIiwiUHJldmlldyIsImdldFNsaWRlcyIsInMiLCJ1cGRhdGVBbmRTYXZlU2xpZGVUYXNrIiwic2xpZGVzIiwicmVtb3ZlU2xpZGVUYXNrIiwidGFpbCIsInJlZHVjZU9yZGVyIiwicmlnaHQiLCJyZW1vdmVTbGlkZSIsInVwZGF0ZUxpc3QiLCJoYW5kbGVEcmFnU3RhcnQiLCJldiIsImRhdGFUcmFuc2ZlciIsImVmZmVjdEFsbG93ZWQiLCJzZXREYXRhIiwicHJldmlld0RyYWciLCJkcmFnIiwiaGFuZGxlRHJhZ092ZXIiLCJkcm9wIiwiaGFuZGxlRHJhZ0xlYXZlIiwiaGFuZGxlRHJvcCIsImhhbmRsZURyYWdFbmQiLCJzbGlkZURyYWciLCJkcmFnZ2luZyIsInN0YXJ0IiwiZW5kIiwiZHJhZ2dlZCIsImRyb3BwZWQiLCJkcmFnZ2FibGUiLCJvbmRyYWdzdGFydCIsIm9uZHJhZ2VuZCIsIm9uZHJhZ292ZXIiLCJvbmRyb3AiLCJvbmRyYWdsZWF2ZSIsIlNsaWRlIiwiYWRkU2xpZGVUb1Nob3ciLCJkcmFnSWQiLCJkcm9wcGFibGUiLCJfc2xpZGUiLCJsZW5ndGgiLCJsZWZ0IiwicHJlc2VudGF0aW9uIiwiaGFuZGxlRHJhZ0VudGVyIiwiYkNvbG9yIiwiZ2V0RGF0YSIsIml0ZW0iLCJkcm9wRWZmZWN0IiwiU2xpZGVzTW9kYWwiLCJvbmRyYWdlbnRlciIsInRvU3RydWN0IiwiYWNjIiwiaGFzIiwic2l6ZSIsImFkZCIsIk9iamVjdCIsIm9yZGVyT2YiLCJmb3JHcmVhdGVyIiwiY2hlY2tTbGlkZSIsImZvckxlc3MiLCJnZXRJZCIsInJlc2V0T3JkZXIiLCJ1cGRhdGVSZW1vdmVTbGlkZSIsIkFycmF5IiwidXBkYXRlSWQiLCJ1cGRhdGVTbGlkZURyYWdTdGFydCIsInVwZGF0ZURyYWciLCJ1cGRhdGVPcmRlciIsInVwZGF0ZVNsaWRlRHJhZ0VuZCIsInVwZGF0ZURyb3AiLCJ1cGRhdGVTdGF0ZURyYWdFbmQiLCJsb2FkU2xpZGVzIiwicWxTbGlkZXMiLCJjdXJzb3IiLCJpc0Z1bGxzY3JlZW5XaWR0aCIsImlzRnVsbHNjcmVlbkhlaWdodCIsImNsaWNrcyIsIm5leHRTbGlkZSIsInNjcm9sbEludG9WaWV3IiwiYmVoYXZpb3VyIiwicHJldlNsaWRlIiwiY2hhbmdlU2xpZGUiLCJ0YWJpbmRleCIsIm9ua2V5dXAiLCJvbnVwZGF0ZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQTBDLGdDQUFnQztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUF3RCxrQkFBa0I7QUFDMUU7QUFDQSx5REFBaUQsY0FBYztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQXlDLGlDQUFpQztBQUMxRSx3SEFBZ0gsbUJBQW1CLEVBQUU7QUFDckk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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OztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLHdCQUF3QjtBQUNyRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCLFlBQVksZUFBZTtBQUMzQjtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLFdBQVc7QUFDdkIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QywrREFBK0Q7QUFDL0QsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxhQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7Ozs7Ozs7O0FDdkx0QztBQUFBO0FBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFtQztBQUNBO0FBQ0U7QUFDRTtBQUNVO0FBQ0o7QUFDTjtBQUNRO0FBQ0Y7QUFDTjtBQUNBO0FBQ1E7QUFDVjtBQUNZO0FBQ0o7QUFDRjtBQUNRO0FBQ0o7QUFDRjtBQUNGO0FBQ1E7QUFDTjtBQUNKO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNVO0FBQ0E7QUFDTjtBQUNFO0FBQ0E7QUFDSjtBQUNKO0FBQ1U7QUFDRTtBQUNKO0FBQ0E7QUFDRjtBQUNKO0FBQ0U7QUFDTjtBQUNZO0FBQ0o7QUFDTTtBQUNRO0FBQ2hCO0FBQ1E7QUFDUjtBQUNKO0FBQ1E7QUFDVTtBQUNKO0FBQ1E7QUFDWjtBQUNOO0FBQ0Y7QUFDTTtBQUNSO0FBQ007QUFDRjtBQUNBO0FBQ0E7QUFDSjtBQUNVO0FBQ0Y7QUFDVTtBQUNaO0FBQ047QUFDTTtBQUNvQjtBQUNoQjtBQUNKO0FBQ0k7QUFDZDtBQUNFO0FBQ0E7QUFDSTtBQUNGO0FBQ1U7QUFDRjtBQUNKO0FBQ047QUFDUTtBQUNBO0FBQ047QUFDVTtBQUNOO0FBQ007QUFDTTtBQUNGO0FBQ2Q7QUFDSTtBQUNNO0FBQ0o7QUFDVjtBQUNVO0FBQ0o7QUFDRjtBQUNBO0FBQ0E7QUFDSTtBQUNKO0FBQ2M7QUFDVjtBQUNKO0FBQ1U7QUFDRjtBQUNBO0FBQ1I7QUFDRTtBQUNOO0FBQ0U7QUFDQTtBQUNVO0FBQ1U7QUFDQTtBQUNoQjtBQUNJO0FBQ1I7QUFDSTtBQUNGO0FBQ0k7QUFDRTtBQUNRO0FBQ1o7QUFDTTtBQUNVO0FBQ0U7QUFDRjtBQUNNO0FBQ2Q7QUFDTTtBQUNsQjtBQUNJO0FBQ0U7QUFDSTtBQUNSO0FBQ0k7QUFDSjtBQUNGO0FBQ0E7QUFDTTtBQUNWO0FBQ1E7QUFDTjtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFDTTtBQUNVO0FBQ047QUFDVjtBQUNJO0FBQ0E7QUFDYztBQUNsQjtBQUNNO0FBQ0Y7QUFDSjtBQUNFO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNOO0FBQ0k7QUFDQTtBQUNBO0FBQ2M7QUFDaEI7QUFDQTtBQUNFO0FBQ0k7QUFDTTtBQUNBO0FBQ1I7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ047QUFDUTtBQUNWO0FBQ0k7QUFDRjtBQUNJO0FBQ0k7QUFDTjtBQUNJO0FBQ007QUFDRjtBQUNFO0FBQ0o7QUFDVjtBQUNnQztBQUNRO0FBQ3RDO0FBQ0E7QUFDUTtBQUNVO0FBQ1I7QUFDWjtBQUNFO0FBQ0U7QUFDSTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNybEVBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFOzs7QUFHdkQ7Ozs7Ozs7Ozs7Ozs7QUM3REE7O0FBRWE7OztBQUdiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7QUMxREE7QUFDQTs7QUFFYTs7O0FBR2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEsNkJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxFQUFFO0FBQ3JELHdDQUF3QyxXQUFXLEVBQUU7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDO0FBQ3RDLEdBQUc7QUFDSDtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsbUJBQU8sQ0FBQyxxSEFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5REE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVB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QXFCO0FBQUEsY0FBbEIxSixHQUFrQixTQUFsQkEsR0FBa0I7QUFBQSxjQUFieEMsTUFBYSxTQUFiQSxNQUFhOztBQUM1QmdNLHNCQUFZeEosR0FBWixFQUFpQnhDLE1BQWpCO0FBQ0Q7QUFKSCxPQUZLLEVBUUwsdUJBQ0UsWUFERixFQUVFO0FBQ0VtTSxrQkFBVTtBQUFBLGNBQUcxUSxHQUFILFNBQUdBLEdBQUg7QUFBQSxpQkFBYSxzQ0FBcUIsRUFBRUEsUUFBRixFQUFyQixDQUFiO0FBQUE7QUFEWixPQUZGLEVBS0VHLGtCQUFFMkUsS0FBRixDQUFReEMsR0FBR3lDLE1BQUgsQ0FBVTFGLE1BQU1tQixRQUFOLENBQWVuQixNQUFNMFEsTUFBckIsQ0FBVixLQUEyQyxTQUFuRCxDQUxGLENBUkssQ0FBUDtBQWdCRDtBQW5CSSxHQUFQO0FBcUJELENBcEREOztrQkFzRGU3USxTOzs7Ozs7Ozs7Ozs7QUNsRmYsY0FBYyxtQkFBTyxDQUFDLHFOQUEwRzs7QUFFaEksNENBQTRDLFFBQVM7O0FBRXJEO0FBQ0E7Ozs7QUFJQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLGdOQUF3Rzs7QUFFN0g7O0FBRUEsR0FBRyxLQUFVLEVBQUUsRSIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcbiIsIi8qXG4gKiBhbmltZS5qcyB2My4wLjFcbiAqIChjKSAyMDE5IEp1bGlhbiBHYXJuaWVyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGFuaW1lanMuY29tXG4gKi9cblxuLy8gRGVmYXVsdHNcblxudmFyIGRlZmF1bHRJbnN0YW5jZVNldHRpbmdzID0ge1xuICB1cGRhdGU6IG51bGwsXG4gIGJlZ2luOiBudWxsLFxuICBsb29wQmVnaW46IG51bGwsXG4gIGNoYW5nZUJlZ2luOiBudWxsLFxuICBjaGFuZ2U6IG51bGwsXG4gIGNoYW5nZUNvbXBsZXRlOiBudWxsLFxuICBsb29wQ29tcGxldGU6IG51bGwsXG4gIGNvbXBsZXRlOiBudWxsLFxuICBsb29wOiAxLFxuICBkaXJlY3Rpb246ICdub3JtYWwnLFxuICBhdXRvcGxheTogdHJ1ZSxcbiAgdGltZWxpbmVPZmZzZXQ6IDBcbn07XG5cbnZhciBkZWZhdWx0VHdlZW5TZXR0aW5ncyA9IHtcbiAgZHVyYXRpb246IDEwMDAsXG4gIGRlbGF5OiAwLFxuICBlbmREZWxheTogMCxcbiAgZWFzaW5nOiAnZWFzZU91dEVsYXN0aWMoMSwgLjUpJyxcbiAgcm91bmQ6IDBcbn07XG5cbnZhciB2YWxpZFRyYW5zZm9ybXMgPSBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICd0cmFuc2xhdGVaJywgJ3JvdGF0ZScsICdyb3RhdGVYJywgJ3JvdGF0ZVknLCAncm90YXRlWicsICdzY2FsZScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ3NjYWxlWicsICdza2V3JywgJ3NrZXdYJywgJ3NrZXdZJywgJ3BlcnNwZWN0aXZlJ107XG5cbi8vIENhY2hpbmdcblxudmFyIGNhY2hlID0ge1xuICBDU1M6IHt9LFxuICBzcHJpbmdzOiB7fVxufTtcblxuLy8gVXRpbHNcblxuZnVuY3Rpb24gbWluTWF4KHZhbCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nQ29udGFpbnMoc3RyLCB0ZXh0KSB7XG4gIHJldHVybiBzdHIuaW5kZXhPZih0ZXh0KSA+IC0xO1xufVxuXG5mdW5jdGlvbiBhcHBseUFyZ3VtZW50cyhmdW5jLCBhcmdzKSB7XG4gIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG52YXIgaXMgPSB7XG4gIGFycjogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkoYSk7IH0sXG4gIG9iajogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHN0cmluZ0NvbnRhaW5zKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSwgJ09iamVjdCcpOyB9LFxuICBwdGg6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBpcy5vYmooYSkgJiYgYS5oYXNPd25Qcm9wZXJ0eSgndG90YWxMZW5ndGgnKTsgfSxcbiAgc3ZnOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7IH0sXG4gIGlucDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50OyB9LFxuICBkb206IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5vZGVUeXBlIHx8IGlzLnN2ZyhhKTsgfSxcbiAgc3RyOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdHlwZW9mIGEgPT09ICdzdHJpbmcnOyB9LFxuICBmbmM6IGZ1bmN0aW9uIChhKSB7IHJldHVybiB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJzsgfSxcbiAgdW5kOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnOyB9LFxuICBoZXg6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAvKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpL2kudGVzdChhKTsgfSxcbiAgcmdiOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gL15yZ2IvLnRlc3QoYSk7IH0sXG4gIGhzbDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIC9eaHNsLy50ZXN0KGEpOyB9LFxuICBjb2w6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAoaXMuaGV4KGEpIHx8IGlzLnJnYihhKSB8fCBpcy5oc2woYSkpOyB9LFxuICBrZXk6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAhZGVmYXVsdEluc3RhbmNlU2V0dGluZ3MuaGFzT3duUHJvcGVydHkoYSkgJiYgIWRlZmF1bHRUd2VlblNldHRpbmdzLmhhc093blByb3BlcnR5KGEpICYmIGEgIT09ICd0YXJnZXRzJyAmJiBhICE9PSAna2V5ZnJhbWVzJzsgfVxufTtcblxuLy8gRWFzaW5nc1xuXG5mdW5jdGlvbiBwYXJzZUVhc2luZ1BhcmFtZXRlcnMoc3RyaW5nKSB7XG4gIHZhciBtYXRjaCA9IC9cXCgoW14pXSspXFwpLy5leGVjKHN0cmluZyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwYXJzZUZsb2F0KHApOyB9KSA6IFtdO1xufVxuXG4vLyBTcHJpbmcgc29sdmVyIGluc3BpcmVkIGJ5IFdlYmtpdCBDb3B5cmlnaHQgwqkgMjAxNiBBcHBsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIGh0dHBzOi8vd2Via2l0Lm9yZy9kZW1vcy9zcHJpbmcvc3ByaW5nLmpzXG5cbmZ1bmN0aW9uIHNwcmluZyhzdHJpbmcsIGR1cmF0aW9uKSB7XG5cbiAgdmFyIHBhcmFtcyA9IHBhcnNlRWFzaW5nUGFyYW1ldGVycyhzdHJpbmcpO1xuICB2YXIgbWFzcyA9IG1pbk1heChpcy51bmQocGFyYW1zWzBdKSA/IDEgOiBwYXJhbXNbMF0sIC4xLCAxMDApO1xuICB2YXIgc3RpZmZuZXNzID0gbWluTWF4KGlzLnVuZChwYXJhbXNbMV0pID8gMTAwIDogcGFyYW1zWzFdLCAuMSwgMTAwKTtcbiAgdmFyIGRhbXBpbmcgPSBtaW5NYXgoaXMudW5kKHBhcmFtc1syXSkgPyAxMCA6IHBhcmFtc1syXSwgLjEsIDEwMCk7XG4gIHZhciB2ZWxvY2l0eSA9ICBtaW5NYXgoaXMudW5kKHBhcmFtc1szXSkgPyAwIDogcGFyYW1zWzNdLCAuMSwgMTAwKTtcbiAgdmFyIHcwID0gTWF0aC5zcXJ0KHN0aWZmbmVzcyAvIG1hc3MpO1xuICB2YXIgemV0YSA9IGRhbXBpbmcgLyAoMiAqIE1hdGguc3FydChzdGlmZm5lc3MgKiBtYXNzKSk7XG4gIHZhciB3ZCA9IHpldGEgPCAxID8gdzAgKiBNYXRoLnNxcnQoMSAtIHpldGEgKiB6ZXRhKSA6IDA7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSB6ZXRhIDwgMSA/ICh6ZXRhICogdzAgKyAtdmVsb2NpdHkpIC8gd2QgOiAtdmVsb2NpdHkgKyB3MDtcblxuICBmdW5jdGlvbiBzb2x2ZXIodCkge1xuICAgIHZhciBwcm9ncmVzcyA9IGR1cmF0aW9uID8gKGR1cmF0aW9uICogdCkgLyAxMDAwIDogdDtcbiAgICBpZiAoemV0YSA8IDEpIHtcbiAgICAgIHByb2dyZXNzID0gTWF0aC5leHAoLXByb2dyZXNzICogemV0YSAqIHcwKSAqIChhICogTWF0aC5jb3Mod2QgKiBwcm9ncmVzcykgKyBiICogTWF0aC5zaW4od2QgKiBwcm9ncmVzcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9ncmVzcyA9IChhICsgYiAqIHByb2dyZXNzKSAqIE1hdGguZXhwKC1wcm9ncmVzcyAqIHcwKTtcbiAgICB9XG4gICAgaWYgKHQgPT09IDAgfHwgdCA9PT0gMSkgeyByZXR1cm4gdDsgfVxuICAgIHJldHVybiAxIC0gcHJvZ3Jlc3M7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREdXJhdGlvbigpIHtcbiAgICB2YXIgY2FjaGVkID0gY2FjaGUuc3ByaW5nc1tzdHJpbmddO1xuICAgIGlmIChjYWNoZWQpIHsgcmV0dXJuIGNhY2hlZDsgfVxuICAgIHZhciBmcmFtZSA9IDEvNjtcbiAgICB2YXIgZWxhcHNlZCA9IDA7XG4gICAgdmFyIHJlc3QgPSAwO1xuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIGVsYXBzZWQgKz0gZnJhbWU7XG4gICAgICBpZiAoc29sdmVyKGVsYXBzZWQpID09PSAxKSB7XG4gICAgICAgIHJlc3QrKztcbiAgICAgICAgaWYgKHJlc3QgPj0gMTYpIHsgYnJlYWs7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3QgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZHVyYXRpb24gPSBlbGFwc2VkICogZnJhbWUgKiAxMDAwO1xuICAgIGNhY2hlLnNwcmluZ3Nbc3RyaW5nXSA9IGR1cmF0aW9uO1xuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxuXG4gIHJldHVybiBkdXJhdGlvbiA/IHNvbHZlciA6IGdldER1cmF0aW9uO1xuXG59XG5cbi8vIEVsYXN0aWMgZWFzaW5nIGFkYXB0ZWQgZnJvbSBqUXVlcnlVSSBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9lYXNpbmdzL1xuXG5mdW5jdGlvbiBlbGFzdGljKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gIGlmICggYW1wbGl0dWRlID09PSB2b2lkIDAgKSBhbXBsaXR1ZGUgPSAxO1xuICBpZiAoIHBlcmlvZCA9PT0gdm9pZCAwICkgcGVyaW9kID0gLjU7XG5cbiAgdmFyIGEgPSBtaW5NYXgoYW1wbGl0dWRlLCAxLCAxMCk7XG4gIHZhciBwID0gbWluTWF4KHBlcmlvZCwgLjEsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gKHQgPT09IDAgfHwgdCA9PT0gMSkgPyB0IDogXG4gICAgICAtYSAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSkgKiBNYXRoLnNpbigoKCh0IC0gMSkgLSAocCAvIChNYXRoLlBJICogMikgKiBNYXRoLmFzaW4oMSAvIGEpKSkgKiAoTWF0aC5QSSAqIDIpKSAvIHApO1xuICB9XG59XG5cbi8vIEJhc2ljIHN0ZXBzIGVhc2luZyBpbXBsZW1lbnRhdGlvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9mci9kb2NzL1dlYi9DU1MvdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cblxuZnVuY3Rpb24gc3RlcHMoc3RlcHMpIHtcbiAgaWYgKCBzdGVwcyA9PT0gdm9pZCAwICkgc3RlcHMgPSAxMDtcblxuICByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE1hdGgucm91bmQodCAqIHN0ZXBzKSAqICgxIC8gc3RlcHMpOyB9O1xufVxuXG4vLyBCZXppZXJFYXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2dyZS9iZXppZXItZWFzaW5nXG5cbnZhciBiZXppZXIgPSAoZnVuY3Rpb24gKCkge1xuXG4gIHZhciBrU3BsaW5lVGFibGVTaXplID0gMTE7XG4gIHZhciBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCk7XG5cbiAgZnVuY3Rpb24gQShhQTEsIGFBMikgeyByZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExIH1cbiAgZnVuY3Rpb24gQihhQTEsIGFBMikgeyByZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExIH1cbiAgZnVuY3Rpb24gQyhhQTEpICAgICAgeyByZXR1cm4gMy4wICogYUExIH1cblxuICBmdW5jdGlvbiBjYWxjQmV6aWVyKGFULCBhQTEsIGFBMikgeyByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQgfVxuICBmdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHsgcmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSkgfVxuXG4gIGZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZShhWCwgYUEsIGFCLCBtWDEsIG1YMikge1xuICAgIHZhciBjdXJyZW50WCwgY3VycmVudFQsIGkgPSAwO1xuICAgIGRvIHtcbiAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG4gICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7IGFCID0gY3VycmVudFQ7IH0gZWxzZSB7IGFBID0gY3VycmVudFQ7IH1cbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiAwLjAwMDAwMDEgJiYgKytpIDwgMTApO1xuICAgIHJldHVybiBjdXJyZW50VDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7IHJldHVybiBhR3Vlc3NUOyB9XG4gICAgICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgICB9XG4gICAgcmV0dXJuIGFHdWVzc1Q7XG4gIH1cblxuICBmdW5jdGlvbiBiZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG5cbiAgICBpZiAoISgwIDw9IG1YMSAmJiBtWDEgPD0gMSAmJiAwIDw9IG1YMiAmJiBtWDIgPD0gMSkpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHNhbXBsZVZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG5cbiAgICBpZiAobVgxICE9PSBtWTEgfHwgbVgyICE9PSBtWTIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga1NwbGluZVRhYmxlU2l6ZTsgKytpKSB7XG4gICAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRGb3JYKGFYKSB7XG5cbiAgICAgIHZhciBpbnRlcnZhbFN0YXJ0ID0gMDtcbiAgICAgIHZhciBjdXJyZW50U2FtcGxlID0gMTtcbiAgICAgIHZhciBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG5cbiAgICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgICAgfVxuXG4gICAgICAtLWN1cnJlbnRTYW1wbGU7XG5cbiAgICAgIHZhciBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcbiAgICAgIHZhciBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgIHZhciBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcblxuICAgICAgaWYgKGluaXRpYWxTbG9wZSA+PSAwLjAwMSkge1xuICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHsgcmV0dXJuIHg7IH1cbiAgICAgIGlmICh4ID09PSAwIHx8IHggPT09IDEpIHsgcmV0dXJuIHg7IH1cbiAgICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKHgpLCBtWTEsIG1ZMik7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gYmV6aWVyO1xuXG59KSgpO1xuXG52YXIgcGVubmVyID0gKGZ1bmN0aW9uICgpIHtcblxuICB2YXIgbmFtZXMgPSBbJ1F1YWQnLCAnQ3ViaWMnLCAnUXVhcnQnLCAnUXVpbnQnLCAnU2luZScsICdFeHBvJywgJ0NpcmMnLCAnQmFjaycsICdFbGFzdGljJ107XG5cbiAgLy8gQXBwcm94aW1hdGVkIFBlbm5lciBlcXVhdGlvbnMgaHR0cDovL21hdHRoZXdsZWluLmNvbS9jZWFzZXIvXG5cbiAgdmFyIGN1cnZlcyA9IHtcbiAgICBJbjogW1xuICAgICAgWzAuNTUwLCAwLjA4NSwgMC42ODAsIDAuNTMwXSwgLyogaW5RdWFkICovXG4gICAgICBbMC41NTAsIDAuMDU1LCAwLjY3NSwgMC4xOTBdLCAvKiBpbkN1YmljICovXG4gICAgICBbMC44OTUsIDAuMDMwLCAwLjY4NSwgMC4yMjBdLCAvKiBpblF1YXJ0ICovXG4gICAgICBbMC43NTUsIDAuMDUwLCAwLjg1NSwgMC4wNjBdLCAvKiBpblF1aW50ICovXG4gICAgICBbMC40NzAsIDAuMDAwLCAwLjc0NSwgMC43MTVdLCAvKiBpblNpbmUgKi9cbiAgICAgIFswLjk1MCwgMC4wNTAsIDAuNzk1LCAwLjAzNV0sIC8qIGluRXhwbyAqL1xuICAgICAgWzAuNjAwLCAwLjA0MCwgMC45ODAsIDAuMzM1XSwgLyogaW5DaXJjICovXG4gICAgICBbMC42MDAsLTAuMjgwLCAwLjczNSwgMC4wNDVdLCAvKiBpbkJhY2sgKi9cbiAgICAgIGVsYXN0aWMgLyogaW5FbGFzdGljICovXG4gICAgXSxcbiAgICBPdXQ6IFtcbiAgICAgIFswLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MF0sIC8qIG91dFF1YWQgKi9cbiAgICAgIFswLjIxNSwgMC42MTAsIDAuMzU1LCAxLjAwMF0sIC8qIG91dEN1YmljICovXG4gICAgICBbMC4xNjUsIDAuODQwLCAwLjQ0MCwgMS4wMDBdLCAvKiBvdXRRdWFydCAqL1xuICAgICAgWzAuMjMwLCAxLjAwMCwgMC4zMjAsIDEuMDAwXSwgLyogb3V0UXVpbnQgKi9cbiAgICAgIFswLjM5MCwgMC41NzUsIDAuNTY1LCAxLjAwMF0sIC8qIG91dFNpbmUgKi9cbiAgICAgIFswLjE5MCwgMS4wMDAsIDAuMjIwLCAxLjAwMF0sIC8qIG91dEV4cG8gKi9cbiAgICAgIFswLjA3NSwgMC44MjAsIDAuMTY1LCAxLjAwMF0sIC8qIG91dENpcmMgKi9cbiAgICAgIFswLjE3NSwgMC44ODUsIDAuMzIwLCAxLjI3NV0sIC8qIG91dEJhY2sgKi9cbiAgICAgIGZ1bmN0aW9uIChhLCBwKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gMSAtIGVsYXN0aWMoYSwgcCkoMSAtIHQpOyB9OyB9IC8qIG91dEVsYXN0aWMgKi9cbiAgICBdLFxuICAgIEluT3V0OiBbXG4gICAgICBbMC40NTUsIDAuMDMwLCAwLjUxNSwgMC45NTVdLCAvKiBpbk91dFF1YWQgKi9cbiAgICAgIFswLjY0NSwgMC4wNDUsIDAuMzU1LCAxLjAwMF0sIC8qIGluT3V0Q3ViaWMgKi9cbiAgICAgIFswLjc3MCwgMC4wMDAsIDAuMTc1LCAxLjAwMF0sIC8qIGluT3V0UXVhcnQgKi9cbiAgICAgIFswLjg2MCwgMC4wMDAsIDAuMDcwLCAxLjAwMF0sIC8qIGluT3V0UXVpbnQgKi9cbiAgICAgIFswLjQ0NSwgMC4wNTAsIDAuNTUwLCAwLjk1MF0sIC8qIGluT3V0U2luZSAqL1xuICAgICAgWzEuMDAwLCAwLjAwMCwgMC4wMDAsIDEuMDAwXSwgLyogaW5PdXRFeHBvICovXG4gICAgICBbMC43ODUsIDAuMTM1LCAwLjE1MCwgMC44NjBdLCAvKiBpbk91dENpcmMgKi9cbiAgICAgIFswLjY4MCwtMC41NTAsIDAuMjY1LCAxLjU1MF0sIC8qIGluT3V0QmFjayAqL1xuICAgICAgZnVuY3Rpb24gKGEsIHApIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDwgLjUgPyBlbGFzdGljKGEsIHApKHQgKiAyKSAvIDIgOiAxIC0gZWxhc3RpYyhhLCBwKSh0ICogLTIgKyAyKSAvIDI7IH07IH0gLyogaW5PdXRFbGFzdGljICovXG4gICAgXVxuICB9O1xuXG4gIHZhciBlYXNlcyA9IHsgXG4gICAgbGluZWFyOiBbMC4yNTAsIDAuMjUwLCAwLjc1MCwgMC43NTBdXG4gIH07XG5cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGNvb3JkcyApIHtcbiAgICBjdXJ2ZXNbY29vcmRzXS5mb3JFYWNoKGZ1bmN0aW9uIChlYXNlLCBpKSB7XG4gICAgICBlYXNlc1snZWFzZScrY29vcmRzK25hbWVzW2ldXSA9IGVhc2U7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgY29vcmRzIGluIGN1cnZlcykgbG9vcCggY29vcmRzICk7XG5cbiAgcmV0dXJuIGVhc2VzO1xuXG59KSgpO1xuXG5mdW5jdGlvbiBwYXJzZUVhc2luZ3MoZWFzaW5nLCBkdXJhdGlvbikge1xuICBpZiAoaXMuZm5jKGVhc2luZykpIHsgcmV0dXJuIGVhc2luZzsgfVxuICB2YXIgbmFtZSA9IGVhc2luZy5zcGxpdCgnKCcpWzBdO1xuICB2YXIgZWFzZSA9IHBlbm5lcltuYW1lXTtcbiAgdmFyIGFyZ3MgPSBwYXJzZUVhc2luZ1BhcmFtZXRlcnMoZWFzaW5nKTtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnc3ByaW5nJyA6IHJldHVybiBzcHJpbmcoZWFzaW5nLCBkdXJhdGlvbik7XG4gICAgY2FzZSAnY3ViaWNCZXppZXInIDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKGJlemllciwgYXJncyk7XG4gICAgY2FzZSAnc3RlcHMnIDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKHN0ZXBzLCBhcmdzKTtcbiAgICBkZWZhdWx0IDogcmV0dXJuIGlzLmZuYyhlYXNlKSA/IGFwcGx5QXJndW1lbnRzKGVhc2UsIGFyZ3MpIDogYXBwbHlBcmd1bWVudHMoYmV6aWVyLCBlYXNlKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdzXG5cbmZ1bmN0aW9uIHNlbGVjdFN0cmluZyhzdHIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHN0cik7XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuLy8gQXJyYXlzXG5cbmZ1bmN0aW9uIGZpbHRlckFycmF5KGFyciwgY2FsbGJhY2spIHtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaSBpbiBhcnIpIHtcbiAgICAgIHZhciB2YWwgPSBhcnJbaV07XG4gICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWwsIGksIGFycikpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbkFycmF5KGFycikge1xuICByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jb25jYXQoaXMuYXJyKGIpID8gZmxhdHRlbkFycmF5KGIpIDogYik7IH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheShvKSB7XG4gIGlmIChpcy5hcnIobykpIHsgcmV0dXJuIG87IH1cbiAgaWYgKGlzLnN0cihvKSkgeyBvID0gc2VsZWN0U3RyaW5nKG8pIHx8IG87IH1cbiAgaWYgKG8gaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBvIGluc3RhbmNlb2YgSFRNTENvbGxlY3Rpb24pIHsgcmV0dXJuIFtdLnNsaWNlLmNhbGwobyk7IH1cbiAgcmV0dXJuIFtvXTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDb250YWlucyhhcnIsIHZhbCkge1xuICByZXR1cm4gYXJyLnNvbWUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgPT09IHZhbDsgfSk7XG59XG5cbi8vIE9iamVjdHNcblxuZnVuY3Rpb24gY2xvbmVPYmplY3Qobykge1xuICB2YXIgY2xvbmUgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBvKSB7IGNsb25lW3BdID0gb1twXTsgfVxuICByZXR1cm4gY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VPYmplY3RQcm9wcyhvMSwgbzIpIHtcbiAgdmFyIG8gPSBjbG9uZU9iamVjdChvMSk7XG4gIGZvciAodmFyIHAgaW4gbzEpIHsgb1twXSA9IG8yLmhhc093blByb3BlcnR5KHApID8gbzJbcF0gOiBvMVtwXTsgfVxuICByZXR1cm4gbztcbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG8xLCBvMikge1xuICB2YXIgbyA9IGNsb25lT2JqZWN0KG8xKTtcbiAgZm9yICh2YXIgcCBpbiBvMikgeyBvW3BdID0gaXMudW5kKG8xW3BdKSA/IG8yW3BdIDogbzFbcF07IH1cbiAgcmV0dXJuIG87XG59XG5cbi8vIENvbG9yc1xuXG5mdW5jdGlvbiByZ2JUb1JnYmEocmdiVmFsdWUpIHtcbiAgdmFyIHJnYiA9IC9yZ2JcXCgoXFxkKyxcXHMqW1xcZF0rLFxccypbXFxkXSspXFwpL2cuZXhlYyhyZ2JWYWx1ZSk7XG4gIHJldHVybiByZ2IgPyAoXCJyZ2JhKFwiICsgKHJnYlsxXSkgKyBcIiwxKVwiKSA6IHJnYlZhbHVlO1xufVxuXG5mdW5jdGlvbiBoZXhUb1JnYmEoaGV4VmFsdWUpIHtcbiAgdmFyIHJneCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG4gIHZhciBoZXggPSBoZXhWYWx1ZS5yZXBsYWNlKHJneCwgZnVuY3Rpb24gKG0sIHIsIGcsIGIpIHsgcmV0dXJuIHIgKyByICsgZyArIGcgKyBiICsgYjsgfSApO1xuICB2YXIgcmdiID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGhleCk7XG4gIHZhciByID0gcGFyc2VJbnQocmdiWzFdLCAxNik7XG4gIHZhciBnID0gcGFyc2VJbnQocmdiWzJdLCAxNik7XG4gIHZhciBiID0gcGFyc2VJbnQocmdiWzNdLCAxNik7XG4gIHJldHVybiAoXCJyZ2JhKFwiICsgciArIFwiLFwiICsgZyArIFwiLFwiICsgYiArIFwiLDEpXCIpO1xufVxuXG5mdW5jdGlvbiBoc2xUb1JnYmEoaHNsVmFsdWUpIHtcbiAgdmFyIGhzbCA9IC9oc2xcXCgoXFxkKyksXFxzKihbXFxkLl0rKSUsXFxzKihbXFxkLl0rKSVcXCkvZy5leGVjKGhzbFZhbHVlKSB8fCAvaHNsYVxcKChcXGQrKSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspXFwpL2cuZXhlYyhoc2xWYWx1ZSk7XG4gIHZhciBoID0gcGFyc2VJbnQoaHNsWzFdLCAxMCkgLyAzNjA7XG4gIHZhciBzID0gcGFyc2VJbnQoaHNsWzJdLCAxMCkgLyAxMDA7XG4gIHZhciBsID0gcGFyc2VJbnQoaHNsWzNdLCAxMCkgLyAxMDA7XG4gIHZhciBhID0gaHNsWzRdIHx8IDE7XG4gIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgIGlmICh0IDwgMCkgeyB0ICs9IDE7IH1cbiAgICBpZiAodCA+IDEpIHsgdCAtPSAxOyB9XG4gICAgaWYgKHQgPCAxLzYpIHsgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7IH1cbiAgICBpZiAodCA8IDEvMikgeyByZXR1cm4gcTsgfVxuICAgIGlmICh0IDwgMi8zKSB7IHJldHVybiBwICsgKHEgLSBwKSAqICgyLzMgLSB0KSAqIDY7IH1cbiAgICByZXR1cm4gcDtcbiAgfVxuICB2YXIgciwgZywgYjtcbiAgaWYgKHMgPT0gMCkge1xuICAgIHIgPSBnID0gYiA9IGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxLzMpO1xuICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxLzMpO1xuICB9XG4gIHJldHVybiAoXCJyZ2JhKFwiICsgKHIgKiAyNTUpICsgXCIsXCIgKyAoZyAqIDI1NSkgKyBcIixcIiArIChiICogMjU1KSArIFwiLFwiICsgYSArIFwiKVwiKTtcbn1cblxuZnVuY3Rpb24gY29sb3JUb1JnYih2YWwpIHtcbiAgaWYgKGlzLnJnYih2YWwpKSB7IHJldHVybiByZ2JUb1JnYmEodmFsKTsgfVxuICBpZiAoaXMuaGV4KHZhbCkpIHsgcmV0dXJuIGhleFRvUmdiYSh2YWwpOyB9XG4gIGlmIChpcy5oc2wodmFsKSkgeyByZXR1cm4gaHNsVG9SZ2JhKHZhbCk7IH1cbn1cblxuLy8gVW5pdHNcblxuZnVuY3Rpb24gZ2V0VW5pdCh2YWwpIHtcbiAgdmFyIHNwbGl0ID0gLyhbXFwrXFwtXT9bMC05I1xcLl0rKSglfHB4fHB0fGVtfHJlbXxpbnxjbXxtbXxleHxjaHxwY3x2d3x2aHx2bWlufHZtYXh8ZGVnfHJhZHx0dXJuKT8kLy5leGVjKHZhbCk7XG4gIGlmIChzcGxpdCkgeyByZXR1cm4gc3BsaXRbMl07IH1cbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtVW5pdChwcm9wTmFtZSkge1xuICBpZiAoc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICd0cmFuc2xhdGUnKSB8fCBwcm9wTmFtZSA9PT0gJ3BlcnNwZWN0aXZlJykgeyByZXR1cm4gJ3B4JzsgfVxuICBpZiAoc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICdyb3RhdGUnKSB8fCBzdHJpbmdDb250YWlucyhwcm9wTmFtZSwgJ3NrZXcnKSkgeyByZXR1cm4gJ2RlZyc7IH1cbn1cblxuLy8gVmFsdWVzXG5cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uVmFsdWUodmFsLCBhbmltYXRhYmxlKSB7XG4gIGlmICghaXMuZm5jKHZhbCkpIHsgcmV0dXJuIHZhbDsgfVxuICByZXR1cm4gdmFsKGFuaW1hdGFibGUudGFyZ2V0LCBhbmltYXRhYmxlLmlkLCBhbmltYXRhYmxlLnRvdGFsKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGVsLCBwcm9wKSB7XG4gIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUocHJvcCk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRQeFRvVW5pdChlbCwgdmFsdWUsIHVuaXQpIHtcbiAgdmFyIHZhbHVlVW5pdCA9IGdldFVuaXQodmFsdWUpO1xuICBpZiAoYXJyYXlDb250YWlucyhbdW5pdCwgJ2RlZycsICdyYWQnLCAndHVybiddLCB2YWx1ZVVuaXQpKSB7IHJldHVybiB2YWx1ZTsgfVxuICB2YXIgY2FjaGVkID0gY2FjaGUuQ1NTW3ZhbHVlICsgdW5pdF07XG4gIGlmICghaXMudW5kKGNhY2hlZCkpIHsgcmV0dXJuIGNhY2hlZDsgfVxuICB2YXIgYmFzZWxpbmUgPSAxMDA7XG4gIHZhciB0ZW1wRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsLnRhZ05hbWUpO1xuICB2YXIgcGFyZW50RWwgPSAoZWwucGFyZW50Tm9kZSAmJiAoZWwucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQpKSA/IGVsLnBhcmVudE5vZGUgOiBkb2N1bWVudC5ib2R5O1xuICBwYXJlbnRFbC5hcHBlbmRDaGlsZCh0ZW1wRWwpO1xuICB0ZW1wRWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICB0ZW1wRWwuc3R5bGUud2lkdGggPSBiYXNlbGluZSArIHVuaXQ7XG4gIHZhciBmYWN0b3IgPSBiYXNlbGluZSAvIHRlbXBFbC5vZmZzZXRXaWR0aDtcbiAgcGFyZW50RWwucmVtb3ZlQ2hpbGQodGVtcEVsKTtcbiAgdmFyIGNvbnZlcnRlZFVuaXQgPSBmYWN0b3IgKiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgY2FjaGUuQ1NTW3ZhbHVlICsgdW5pdF0gPSBjb252ZXJ0ZWRVbml0O1xuICByZXR1cm4gY29udmVydGVkVW5pdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q1NTVmFsdWUoZWwsIHByb3AsIHVuaXQpIHtcbiAgaWYgKHByb3AgaW4gZWwuc3R5bGUpIHtcbiAgICB2YXIgdXBwZXJjYXNlUHJvcE5hbWUgPSBwcm9wLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHZhbHVlID0gZWwuc3R5bGVbcHJvcF0gfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZSh1cHBlcmNhc2VQcm9wTmFtZSkgfHwgJzAnO1xuICAgIHJldHVybiB1bml0ID8gY29udmVydFB4VG9Vbml0KGVsLCB2YWx1ZSwgdW5pdCkgOiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRpb25UeXBlKGVsLCBwcm9wKSB7XG4gIGlmIChpcy5kb20oZWwpICYmICFpcy5pbnAoZWwpICYmIChnZXRBdHRyaWJ1dGUoZWwsIHByb3ApIHx8IChpcy5zdmcoZWwpICYmIGVsW3Byb3BdKSkpIHsgcmV0dXJuICdhdHRyaWJ1dGUnOyB9XG4gIGlmIChpcy5kb20oZWwpICYmIGFycmF5Q29udGFpbnModmFsaWRUcmFuc2Zvcm1zLCBwcm9wKSkgeyByZXR1cm4gJ3RyYW5zZm9ybSc7IH1cbiAgaWYgKGlzLmRvbShlbCkgJiYgKHByb3AgIT09ICd0cmFuc2Zvcm0nICYmIGdldENTU1ZhbHVlKGVsLCBwcm9wKSkpIHsgcmV0dXJuICdjc3MnOyB9XG4gIGlmIChlbFtwcm9wXSAhPSBudWxsKSB7IHJldHVybiAnb2JqZWN0JzsgfVxufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50VHJhbnNmb3JtcyhlbCkge1xuICBpZiAoIWlzLmRvbShlbCkpIHsgcmV0dXJuOyB9XG4gIHZhciBzdHIgPSBlbC5zdHlsZS50cmFuc2Zvcm0gfHwgJyc7XG4gIHZhciByZWcgID0gLyhcXHcrKVxcKChbXildKilcXCkvZztcbiAgdmFyIHRyYW5zZm9ybXMgPSBuZXcgTWFwKCk7XG4gIHZhciBtOyB3aGlsZSAobSA9IHJlZy5leGVjKHN0cikpIHsgdHJhbnNmb3Jtcy5zZXQobVsxXSwgbVsyXSk7IH1cbiAgcmV0dXJuIHRyYW5zZm9ybXM7XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybVZhbHVlKGVsLCBwcm9wTmFtZSwgYW5pbWF0YWJsZSwgdW5pdCkge1xuICB2YXIgZGVmYXVsdFZhbCA9IHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAnc2NhbGUnKSA/IDEgOiAwICsgZ2V0VHJhbnNmb3JtVW5pdChwcm9wTmFtZSk7XG4gIHZhciB2YWx1ZSA9IGdldEVsZW1lbnRUcmFuc2Zvcm1zKGVsKS5nZXQocHJvcE5hbWUpIHx8IGRlZmF1bHRWYWw7XG4gIGlmIChhbmltYXRhYmxlKSB7XG4gICAgYW5pbWF0YWJsZS50cmFuc2Zvcm1zLmxpc3Quc2V0KHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgYW5pbWF0YWJsZS50cmFuc2Zvcm1zWydsYXN0J10gPSBwcm9wTmFtZTtcbiAgfVxuICByZXR1cm4gdW5pdCA/IGNvbnZlcnRQeFRvVW5pdChlbCwgdmFsdWUsIHVuaXQpIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldE9yaWdpbmFsVGFyZ2V0VmFsdWUodGFyZ2V0LCBwcm9wTmFtZSwgdW5pdCwgYW5pbWF0YWJsZSkge1xuICBzd2l0Y2ggKGdldEFuaW1hdGlvblR5cGUodGFyZ2V0LCBwcm9wTmFtZSkpIHtcbiAgICBjYXNlICd0cmFuc2Zvcm0nOiByZXR1cm4gZ2V0VHJhbnNmb3JtVmFsdWUodGFyZ2V0LCBwcm9wTmFtZSwgYW5pbWF0YWJsZSwgdW5pdCk7XG4gICAgY2FzZSAnY3NzJzogcmV0dXJuIGdldENTU1ZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHVuaXQpO1xuICAgIGNhc2UgJ2F0dHJpYnV0ZSc6IHJldHVybiBnZXRBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wTmFtZSk7XG4gICAgZGVmYXVsdDogcmV0dXJuIHRhcmdldFtwcm9wTmFtZV0gfHwgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVZhbHVlKHRvLCBmcm9tKSB7XG4gIHZhciBvcGVyYXRvciA9IC9eKFxcKj18XFwrPXwtPSkvLmV4ZWModG8pO1xuICBpZiAoIW9wZXJhdG9yKSB7IHJldHVybiB0bzsgfVxuICB2YXIgdSA9IGdldFVuaXQodG8pIHx8IDA7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChmcm9tKTtcbiAgdmFyIHkgPSBwYXJzZUZsb2F0KHRvLnJlcGxhY2Uob3BlcmF0b3JbMF0sICcnKSk7XG4gIHN3aXRjaCAob3BlcmF0b3JbMF1bMF0pIHtcbiAgICBjYXNlICcrJzogcmV0dXJuIHggKyB5ICsgdTtcbiAgICBjYXNlICctJzogcmV0dXJuIHggLSB5ICsgdTtcbiAgICBjYXNlICcqJzogcmV0dXJuIHggKiB5ICsgdTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVZhbHVlKHZhbCwgdW5pdCkge1xuICBpZiAoaXMuY29sKHZhbCkpIHsgcmV0dXJuIGNvbG9yVG9SZ2IodmFsKTsgfVxuICB2YXIgb3JpZ2luYWxVbml0ID0gZ2V0VW5pdCh2YWwpO1xuICB2YXIgdW5pdExlc3MgPSBvcmlnaW5hbFVuaXQgPyB2YWwuc3Vic3RyKDAsIHZhbC5sZW5ndGggLSBvcmlnaW5hbFVuaXQubGVuZ3RoKSA6IHZhbDtcbiAgcmV0dXJuIHVuaXQgJiYgIS9cXHMvZy50ZXN0KHZhbCkgPyB1bml0TGVzcyArIHVuaXQgOiB1bml0TGVzcztcbn1cblxuLy8gZ2V0VG90YWxMZW5ndGgoKSBlcXVpdmFsZW50IGZvciBjaXJjbGUsIHJlY3QsIHBvbHlsaW5lLCBwb2x5Z29uIGFuZCBsaW5lIHNoYXBlc1xuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1NlYkxhbWJsYS8zZTA1NTBjNDk2YzIzNjcwOTc0NFxuXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwMi54IC0gcDEueCwgMikgKyBNYXRoLnBvdyhwMi55IC0gcDEueSwgMikpO1xufVxuXG5mdW5jdGlvbiBnZXRDaXJjbGVMZW5ndGgoZWwpIHtcbiAgcmV0dXJuIE1hdGguUEkgKiAyICogZ2V0QXR0cmlidXRlKGVsLCAncicpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0TGVuZ3RoKGVsKSB7XG4gIHJldHVybiAoZ2V0QXR0cmlidXRlKGVsLCAnd2lkdGgnKSAqIDIpICsgKGdldEF0dHJpYnV0ZShlbCwgJ2hlaWdodCcpICogMik7XG59XG5cbmZ1bmN0aW9uIGdldExpbmVMZW5ndGgoZWwpIHtcbiAgcmV0dXJuIGdldERpc3RhbmNlKFxuICAgIHt4OiBnZXRBdHRyaWJ1dGUoZWwsICd4MScpLCB5OiBnZXRBdHRyaWJ1dGUoZWwsICd5MScpfSwgXG4gICAge3g6IGdldEF0dHJpYnV0ZShlbCwgJ3gyJyksIHk6IGdldEF0dHJpYnV0ZShlbCwgJ3kyJyl9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFBvbHlsaW5lTGVuZ3RoKGVsKSB7XG4gIHZhciBwb2ludHMgPSBlbC5wb2ludHM7XG4gIHZhciB0b3RhbExlbmd0aCA9IDA7XG4gIHZhciBwcmV2aW91c1BvcztcbiAgZm9yICh2YXIgaSA9IDAgOyBpIDwgcG9pbnRzLm51bWJlck9mSXRlbXM7IGkrKykge1xuICAgIHZhciBjdXJyZW50UG9zID0gcG9pbnRzLmdldEl0ZW0oaSk7XG4gICAgaWYgKGkgPiAwKSB7IHRvdGFsTGVuZ3RoICs9IGdldERpc3RhbmNlKHByZXZpb3VzUG9zLCBjdXJyZW50UG9zKTsgfVxuICAgIHByZXZpb3VzUG9zID0gY3VycmVudFBvcztcbiAgfVxuICByZXR1cm4gdG90YWxMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGdldFBvbHlnb25MZW5ndGgoZWwpIHtcbiAgdmFyIHBvaW50cyA9IGVsLnBvaW50cztcbiAgcmV0dXJuIGdldFBvbHlsaW5lTGVuZ3RoKGVsKSArIGdldERpc3RhbmNlKHBvaW50cy5nZXRJdGVtKHBvaW50cy5udW1iZXJPZkl0ZW1zIC0gMSksIHBvaW50cy5nZXRJdGVtKDApKTtcbn1cblxuLy8gUGF0aCBhbmltYXRpb25cblxuZnVuY3Rpb24gZ2V0VG90YWxMZW5ndGgoZWwpIHtcbiAgaWYgKGVsLmdldFRvdGFsTGVuZ3RoKSB7IHJldHVybiBlbC5nZXRUb3RhbExlbmd0aCgpOyB9XG4gIHN3aXRjaChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdjaXJjbGUnOiByZXR1cm4gZ2V0Q2lyY2xlTGVuZ3RoKGVsKTtcbiAgICBjYXNlICdyZWN0JzogcmV0dXJuIGdldFJlY3RMZW5ndGgoZWwpO1xuICAgIGNhc2UgJ2xpbmUnOiByZXR1cm4gZ2V0TGluZUxlbmd0aChlbCk7XG4gICAgY2FzZSAncG9seWxpbmUnOiByZXR1cm4gZ2V0UG9seWxpbmVMZW5ndGgoZWwpO1xuICAgIGNhc2UgJ3BvbHlnb24nOiByZXR1cm4gZ2V0UG9seWdvbkxlbmd0aChlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0RGFzaG9mZnNldChlbCkge1xuICB2YXIgcGF0aExlbmd0aCA9IGdldFRvdGFsTGVuZ3RoKGVsKTtcbiAgZWwuc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5JywgcGF0aExlbmd0aCk7XG4gIHJldHVybiBwYXRoTGVuZ3RoO1xufVxuXG4vLyBNb3Rpb24gcGF0aFxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTdmdFbChlbCkge1xuICB2YXIgcGFyZW50RWwgPSBlbC5wYXJlbnROb2RlO1xuICB3aGlsZSAoaXMuc3ZnKHBhcmVudEVsKSkge1xuICAgIHBhcmVudEVsID0gcGFyZW50RWwucGFyZW50Tm9kZTtcbiAgICBpZiAoIWlzLnN2ZyhwYXJlbnRFbC5wYXJlbnROb2RlKSkgeyBicmVhazsgfVxuICB9XG4gIHJldHVybiBwYXJlbnRFbDtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50U3ZnKHBhdGhFbCwgc3ZnRGF0YSkge1xuICB2YXIgc3ZnID0gc3ZnRGF0YSB8fCB7fTtcbiAgdmFyIHBhcmVudFN2Z0VsID0gc3ZnLmVsIHx8IGdldFBhcmVudFN2Z0VsKHBhdGhFbCk7XG4gIHZhciByZWN0ID0gcGFyZW50U3ZnRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciB2aWV3Qm94QXR0ciA9IGdldEF0dHJpYnV0ZShwYXJlbnRTdmdFbCwgJ3ZpZXdCb3gnKTtcbiAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB2YXIgdmlld0JveCA9IHN2Zy52aWV3Qm94IHx8ICh2aWV3Qm94QXR0ciA/IHZpZXdCb3hBdHRyLnNwbGl0KCcgJykgOiBbMCwgMCwgd2lkdGgsIGhlaWdodF0pO1xuICByZXR1cm4ge1xuICAgIGVsOiBwYXJlbnRTdmdFbCxcbiAgICB2aWV3Qm94OiB2aWV3Qm94LFxuICAgIHg6IHZpZXdCb3hbMF0gLyAxLFxuICAgIHk6IHZpZXdCb3hbMV0gLyAxLFxuICAgIHc6IHdpZHRoIC8gdmlld0JveFsyXSxcbiAgICBoOiBoZWlnaHQgLyB2aWV3Qm94WzNdXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UGF0aChwYXRoLCBwZXJjZW50KSB7XG4gIHZhciBwYXRoRWwgPSBpcy5zdHIocGF0aCkgPyBzZWxlY3RTdHJpbmcocGF0aClbMF0gOiBwYXRoO1xuICB2YXIgcCA9IHBlcmNlbnQgfHwgMTAwO1xuICByZXR1cm4gZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxuICAgICAgZWw6IHBhdGhFbCxcbiAgICAgIHN2ZzogZ2V0UGFyZW50U3ZnKHBhdGhFbCksXG4gICAgICB0b3RhbExlbmd0aDogZ2V0VG90YWxMZW5ndGgocGF0aEVsKSAqIChwIC8gMTAwKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYXRoUHJvZ3Jlc3MocGF0aCwgcHJvZ3Jlc3MpIHtcbiAgZnVuY3Rpb24gcG9pbnQob2Zmc2V0KSB7XG4gICAgaWYgKCBvZmZzZXQgPT09IHZvaWQgMCApIG9mZnNldCA9IDA7XG5cbiAgICB2YXIgbCA9IHByb2dyZXNzICsgb2Zmc2V0ID49IDEgPyBwcm9ncmVzcyArIG9mZnNldCA6IDA7XG4gICAgcmV0dXJuIHBhdGguZWwuZ2V0UG9pbnRBdExlbmd0aChsKTtcbiAgfVxuICB2YXIgc3ZnID0gZ2V0UGFyZW50U3ZnKHBhdGguZWwsIHBhdGguc3ZnKTtcbiAgdmFyIHAgPSBwb2ludCgpO1xuICB2YXIgcDAgPSBwb2ludCgtMSk7XG4gIHZhciBwMSA9IHBvaW50KCsxKTtcbiAgc3dpdGNoIChwYXRoLnByb3BlcnR5KSB7XG4gICAgY2FzZSAneCc6IHJldHVybiAocC54IC0gc3ZnLngpICogc3ZnLnc7XG4gICAgY2FzZSAneSc6IHJldHVybiAocC55IC0gc3ZnLnkpICogc3ZnLmg7XG4gICAgY2FzZSAnYW5nbGUnOiByZXR1cm4gTWF0aC5hdGFuMihwMS55IC0gcDAueSwgcDEueCAtIHAwLngpICogMTgwIC8gTWF0aC5QSTtcbiAgfVxufVxuXG4vLyBEZWNvbXBvc2UgdmFsdWVcblxuZnVuY3Rpb24gZGVjb21wb3NlVmFsdWUodmFsLCB1bml0KSB7XG4gIHZhciByZ3ggPSAvLT9cXGQqXFwuP1xcZCsvZztcbiAgdmFyIHZhbHVlID0gdmFsaWRhdGVWYWx1ZSgoaXMucHRoKHZhbCkgPyB2YWwudG90YWxMZW5ndGggOiB2YWwpLCB1bml0KSArICcnO1xuICByZXR1cm4ge1xuICAgIG9yaWdpbmFsOiB2YWx1ZSxcbiAgICBudW1iZXJzOiB2YWx1ZS5tYXRjaChyZ3gpID8gdmFsdWUubWF0Y2gocmd4KS5tYXAoTnVtYmVyKSA6IFswXSxcbiAgICBzdHJpbmdzOiAoaXMuc3RyKHZhbCkgfHwgdW5pdCkgPyB2YWx1ZS5zcGxpdChyZ3gpIDogW11cbiAgfVxufVxuXG4vLyBBbmltYXRhYmxlc1xuXG5mdW5jdGlvbiBwYXJzZVRhcmdldHModGFyZ2V0cykge1xuICB2YXIgdGFyZ2V0c0FycmF5ID0gdGFyZ2V0cyA/IChmbGF0dGVuQXJyYXkoaXMuYXJyKHRhcmdldHMpID8gdGFyZ2V0cy5tYXAodG9BcnJheSkgOiB0b0FycmF5KHRhcmdldHMpKSkgOiBbXTtcbiAgcmV0dXJuIGZpbHRlckFycmF5KHRhcmdldHNBcnJheSwgZnVuY3Rpb24gKGl0ZW0sIHBvcywgc2VsZikgeyByZXR1cm4gc2VsZi5pbmRleE9mKGl0ZW0pID09PSBwb3M7IH0pO1xufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRhYmxlcyh0YXJnZXRzKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZVRhcmdldHModGFyZ2V0cyk7XG4gIHJldHVybiBwYXJzZWQubWFwKGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgcmV0dXJuIHt0YXJnZXQ6IHQsIGlkOiBpLCB0b3RhbDogcGFyc2VkLmxlbmd0aCwgdHJhbnNmb3JtczogeyBsaXN0OiBnZXRFbGVtZW50VHJhbnNmb3Jtcyh0KSB9IH07XG4gIH0pO1xufVxuXG4vLyBQcm9wZXJ0aWVzXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BlcnR5VHdlZW5zKHByb3AsIHR3ZWVuU2V0dGluZ3MpIHtcbiAgdmFyIHNldHRpbmdzID0gY2xvbmVPYmplY3QodHdlZW5TZXR0aW5ncyk7XG4gIC8vIE92ZXJyaWRlIGR1cmF0aW9uIGlmIGVhc2luZyBpcyBhIHNwcmluZ1xuICBpZiAoL15zcHJpbmcvLnRlc3Qoc2V0dGluZ3MuZWFzaW5nKSkgeyBzZXR0aW5ncy5kdXJhdGlvbiA9IHNwcmluZyhzZXR0aW5ncy5lYXNpbmcpOyB9XG4gIGlmIChpcy5hcnIocHJvcCkpIHtcbiAgICB2YXIgbCA9IHByb3AubGVuZ3RoO1xuICAgIHZhciBpc0Zyb21UbyA9IChsID09PSAyICYmICFpcy5vYmoocHJvcFswXSkpO1xuICAgIGlmICghaXNGcm9tVG8pIHtcbiAgICAgIC8vIER1cmF0aW9uIGRpdmlkZWQgYnkgdGhlIG51bWJlciBvZiB0d2VlbnNcbiAgICAgIGlmICghaXMuZm5jKHR3ZWVuU2V0dGluZ3MuZHVyYXRpb24pKSB7IHNldHRpbmdzLmR1cmF0aW9uID0gdHdlZW5TZXR0aW5ncy5kdXJhdGlvbiAvIGw7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJhbnNmb3JtIFtmcm9tLCB0b10gdmFsdWVzIHNob3J0aGFuZCB0byBhIHZhbGlkIHR3ZWVuIHZhbHVlXG4gICAgICBwcm9wID0ge3ZhbHVlOiBwcm9wfTtcbiAgICB9XG4gIH1cbiAgdmFyIHByb3BBcnJheSA9IGlzLmFycihwcm9wKSA/IHByb3AgOiBbcHJvcF07XG4gIHJldHVybiBwcm9wQXJyYXkubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgdmFyIG9iaiA9IChpcy5vYmoodikgJiYgIWlzLnB0aCh2KSkgPyB2IDoge3ZhbHVlOiB2fTtcbiAgICAvLyBEZWZhdWx0IGRlbGF5IHZhbHVlIHNob3VsZCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGZpcnN0IHR3ZWVuXG4gICAgaWYgKGlzLnVuZChvYmouZGVsYXkpKSB7IG9iai5kZWxheSA9ICFpID8gdHdlZW5TZXR0aW5ncy5kZWxheSA6IDA7IH1cbiAgICAvLyBEZWZhdWx0IGVuZERlbGF5IHZhbHVlIHNob3VsZCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGxhc3QgdHdlZW5cbiAgICBpZiAoaXMudW5kKG9iai5lbmREZWxheSkpIHsgb2JqLmVuZERlbGF5ID0gaSA9PT0gcHJvcEFycmF5Lmxlbmd0aCAtIDEgPyB0d2VlblNldHRpbmdzLmVuZERlbGF5IDogMDsgfVxuICAgIHJldHVybiBvYmo7XG4gIH0pLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gbWVyZ2VPYmplY3RzKGssIHNldHRpbmdzKTsgfSk7XG59XG5cblxuZnVuY3Rpb24gZmxhdHRlbktleWZyYW1lcyhrZXlmcmFtZXMpIHtcbiAgdmFyIHByb3BlcnR5TmFtZXMgPSBmaWx0ZXJBcnJheShmbGF0dGVuQXJyYXkoa2V5ZnJhbWVzLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBPYmplY3Qua2V5cyhrZXkpOyB9KSksIGZ1bmN0aW9uIChwKSB7IHJldHVybiBpcy5rZXkocCk7IH0pXG4gIC5yZWR1Y2UoZnVuY3Rpb24gKGEsYikgeyBpZiAoYS5pbmRleE9mKGIpIDwgMCkgeyBhLnB1c2goYik7IH0gcmV0dXJuIGE7IH0sIFtdKTtcbiAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlOYW1lc1tpXTtcbiAgICBwcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IGtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG5ld0tleSA9IHt9O1xuICAgICAgZm9yICh2YXIgcCBpbiBrZXkpIHtcbiAgICAgICAgaWYgKGlzLmtleShwKSkge1xuICAgICAgICAgIGlmIChwID09IHByb3BOYW1lKSB7IG5ld0tleS52YWx1ZSA9IGtleVtwXTsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0tleVtwXSA9IGtleVtwXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0tleTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5TmFtZXMubGVuZ3RoOyBpKyspIGxvb3AoIGkgKTtcbiAgcmV0dXJuIHByb3BlcnRpZXM7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnRpZXModHdlZW5TZXR0aW5ncywgcGFyYW1zKSB7XG4gIHZhciBwcm9wZXJ0aWVzID0gW107XG4gIHZhciBrZXlmcmFtZXMgPSBwYXJhbXMua2V5ZnJhbWVzO1xuICBpZiAoa2V5ZnJhbWVzKSB7IHBhcmFtcyA9IG1lcmdlT2JqZWN0cyhmbGF0dGVuS2V5ZnJhbWVzKGtleWZyYW1lcyksIHBhcmFtcyk7IH1cbiAgZm9yICh2YXIgcCBpbiBwYXJhbXMpIHtcbiAgICBpZiAoaXMua2V5KHApKSB7XG4gICAgICBwcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICBuYW1lOiBwLFxuICAgICAgICB0d2VlbnM6IG5vcm1hbGl6ZVByb3BlcnR5VHdlZW5zKHBhcmFtc1twXSwgdHdlZW5TZXR0aW5ncylcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcGVydGllcztcbn1cblxuLy8gVHdlZW5zXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVR3ZWVuVmFsdWVzKHR3ZWVuLCBhbmltYXRhYmxlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gdHdlZW4pIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRGdW5jdGlvblZhbHVlKHR3ZWVuW3BdLCBhbmltYXRhYmxlKTtcbiAgICBpZiAoaXMuYXJyKHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGdldEZ1bmN0aW9uVmFsdWUodiwgYW5pbWF0YWJsZSk7IH0pO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMSkgeyB2YWx1ZSA9IHZhbHVlWzBdOyB9XG4gICAgfVxuICAgIHRbcF0gPSB2YWx1ZTtcbiAgfVxuICB0LmR1cmF0aW9uID0gcGFyc2VGbG9hdCh0LmR1cmF0aW9uKTtcbiAgdC5kZWxheSA9IHBhcnNlRmxvYXQodC5kZWxheSk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVUd2VlbnMocHJvcCwgYW5pbWF0YWJsZSkge1xuICB2YXIgcHJldmlvdXNUd2VlbjtcbiAgcmV0dXJuIHByb3AudHdlZW5zLm1hcChmdW5jdGlvbiAodCkge1xuICAgIHZhciB0d2VlbiA9IG5vcm1hbGl6ZVR3ZWVuVmFsdWVzKHQsIGFuaW1hdGFibGUpO1xuICAgIHZhciB0d2VlblZhbHVlID0gdHdlZW4udmFsdWU7XG4gICAgdmFyIHRvID0gaXMuYXJyKHR3ZWVuVmFsdWUpID8gdHdlZW5WYWx1ZVsxXSA6IHR3ZWVuVmFsdWU7XG4gICAgdmFyIHRvVW5pdCA9IGdldFVuaXQodG8pO1xuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZShhbmltYXRhYmxlLnRhcmdldCwgcHJvcC5uYW1lLCB0b1VuaXQsIGFuaW1hdGFibGUpO1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gcHJldmlvdXNUd2VlbiA/IHByZXZpb3VzVHdlZW4udG8ub3JpZ2luYWwgOiBvcmlnaW5hbFZhbHVlO1xuICAgIHZhciBmcm9tID0gaXMuYXJyKHR3ZWVuVmFsdWUpID8gdHdlZW5WYWx1ZVswXSA6IHByZXZpb3VzVmFsdWU7XG4gICAgdmFyIGZyb21Vbml0ID0gZ2V0VW5pdChmcm9tKSB8fCBnZXRVbml0KG9yaWdpbmFsVmFsdWUpO1xuICAgIHZhciB1bml0ID0gdG9Vbml0IHx8IGZyb21Vbml0O1xuICAgIGlmIChpcy51bmQodG8pKSB7IHRvID0gcHJldmlvdXNWYWx1ZTsgfVxuICAgIHR3ZWVuLmZyb20gPSBkZWNvbXBvc2VWYWx1ZShmcm9tLCB1bml0KTtcbiAgICB0d2Vlbi50byA9IGRlY29tcG9zZVZhbHVlKGdldFJlbGF0aXZlVmFsdWUodG8sIGZyb20pLCB1bml0KTtcbiAgICB0d2Vlbi5zdGFydCA9IHByZXZpb3VzVHdlZW4gPyBwcmV2aW91c1R3ZWVuLmVuZCA6IDA7XG4gICAgdHdlZW4uZW5kID0gdHdlZW4uc3RhcnQgKyB0d2Vlbi5kZWxheSArIHR3ZWVuLmR1cmF0aW9uICsgdHdlZW4uZW5kRGVsYXk7XG4gICAgdHdlZW4uZWFzaW5nID0gcGFyc2VFYXNpbmdzKHR3ZWVuLmVhc2luZywgdHdlZW4uZHVyYXRpb24pO1xuICAgIHR3ZWVuLmlzUGF0aCA9IGlzLnB0aCh0d2VlblZhbHVlKTtcbiAgICB0d2Vlbi5pc0NvbG9yID0gaXMuY29sKHR3ZWVuLmZyb20ub3JpZ2luYWwpO1xuICAgIGlmICh0d2Vlbi5pc0NvbG9yKSB7IHR3ZWVuLnJvdW5kID0gMTsgfVxuICAgIHByZXZpb3VzVHdlZW4gPSB0d2VlbjtcbiAgICByZXR1cm4gdHdlZW47XG4gIH0pO1xufVxuXG4vLyBUd2VlbiBwcm9ncmVzc1xuXG52YXIgc2V0UHJvZ3Jlc3NWYWx1ZSA9IHtcbiAgY3NzOiBmdW5jdGlvbiAodCwgcCwgdikgeyByZXR1cm4gdC5zdHlsZVtwXSA9IHY7IH0sXG4gIGF0dHJpYnV0ZTogZnVuY3Rpb24gKHQsIHAsIHYpIHsgcmV0dXJuIHQuc2V0QXR0cmlidXRlKHAsIHYpOyB9LFxuICBvYmplY3Q6IGZ1bmN0aW9uICh0LCBwLCB2KSB7IHJldHVybiB0W3BdID0gdjsgfSxcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiAodCwgcCwgdiwgdHJhbnNmb3JtcywgbWFudWFsKSB7XG4gICAgdHJhbnNmb3Jtcy5saXN0LnNldChwLCB2KTtcbiAgICBpZiAocCA9PT0gdHJhbnNmb3Jtcy5sYXN0IHx8IG1hbnVhbCkge1xuICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgdHJhbnNmb3Jtcy5saXN0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBwcm9wKSB7IHN0ciArPSBwcm9wICsgXCIoXCIgKyB2YWx1ZSArIFwiKSBcIjsgfSk7XG4gICAgICB0LnN0eWxlLnRyYW5zZm9ybSA9IHN0cjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIFNldCBWYWx1ZSBoZWxwZXJcblxuZnVuY3Rpb24gc2V0VGFyZ2V0c1ZhbHVlKHRhcmdldHMsIHByb3BlcnRpZXMpIHtcbiAgdmFyIGFuaW1hdGFibGVzID0gZ2V0QW5pbWF0YWJsZXModGFyZ2V0cyk7XG4gIGFuaW1hdGFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGFibGUpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRGdW5jdGlvblZhbHVlKHByb3BlcnRpZXNbcHJvcGVydHldLCBhbmltYXRhYmxlKTtcbiAgICAgIHZhciB0YXJnZXQgPSBhbmltYXRhYmxlLnRhcmdldDtcbiAgICAgIHZhciB2YWx1ZVVuaXQgPSBnZXRVbml0KHZhbHVlKTtcbiAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZVVuaXQsIGFuaW1hdGFibGUpO1xuICAgICAgdmFyIHVuaXQgPSB2YWx1ZVVuaXQgfHwgZ2V0VW5pdChvcmlnaW5hbFZhbHVlKTtcbiAgICAgIHZhciB0byA9IGdldFJlbGF0aXZlVmFsdWUodmFsaWRhdGVWYWx1ZSh2YWx1ZSwgdW5pdCksIG9yaWdpbmFsVmFsdWUpO1xuICAgICAgdmFyIGFuaW1UeXBlID0gZ2V0QW5pbWF0aW9uVHlwZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIHNldFByb2dyZXNzVmFsdWVbYW5pbVR5cGVdKHRhcmdldCwgcHJvcGVydHksIHRvLCBhbmltYXRhYmxlLnRyYW5zZm9ybXMsIHRydWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIEFuaW1hdGlvbnNcblxuZnVuY3Rpb24gY3JlYXRlQW5pbWF0aW9uKGFuaW1hdGFibGUsIHByb3ApIHtcbiAgdmFyIGFuaW1UeXBlID0gZ2V0QW5pbWF0aW9uVHlwZShhbmltYXRhYmxlLnRhcmdldCwgcHJvcC5uYW1lKTtcbiAgaWYgKGFuaW1UeXBlKSB7XG4gICAgdmFyIHR3ZWVucyA9IG5vcm1hbGl6ZVR3ZWVucyhwcm9wLCBhbmltYXRhYmxlKTtcbiAgICB2YXIgbGFzdFR3ZWVuID0gdHdlZW5zW3R3ZWVucy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogYW5pbVR5cGUsXG4gICAgICBwcm9wZXJ0eTogcHJvcC5uYW1lLFxuICAgICAgYW5pbWF0YWJsZTogYW5pbWF0YWJsZSxcbiAgICAgIHR3ZWVuczogdHdlZW5zLFxuICAgICAgZHVyYXRpb246IGxhc3RUd2Vlbi5lbmQsXG4gICAgICBkZWxheTogdHdlZW5zWzBdLmRlbGF5LFxuICAgICAgZW5kRGVsYXk6IGxhc3RUd2Vlbi5lbmREZWxheVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRpb25zKGFuaW1hdGFibGVzLCBwcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBmaWx0ZXJBcnJheShmbGF0dGVuQXJyYXkoYW5pbWF0YWJsZXMubWFwKGZ1bmN0aW9uIChhbmltYXRhYmxlKSB7XG4gICAgcmV0dXJuIHByb3BlcnRpZXMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQW5pbWF0aW9uKGFuaW1hdGFibGUsIHByb3ApO1xuICAgIH0pO1xuICB9KSksIGZ1bmN0aW9uIChhKSB7IHJldHVybiAhaXMudW5kKGEpOyB9KTtcbn1cblxuLy8gQ3JlYXRlIEluc3RhbmNlXG5cbmZ1bmN0aW9uIGdldEluc3RhbmNlVGltaW5ncyhhbmltYXRpb25zLCB0d2VlblNldHRpbmdzKSB7XG4gIHZhciBhbmltTGVuZ3RoID0gYW5pbWF0aW9ucy5sZW5ndGg7XG4gIHZhciBnZXRUbE9mZnNldCA9IGZ1bmN0aW9uIChhbmltKSB7IHJldHVybiBhbmltLnRpbWVsaW5lT2Zmc2V0ID8gYW5pbS50aW1lbGluZU9mZnNldCA6IDA7IH07XG4gIHZhciB0aW1pbmdzID0ge307XG4gIHRpbWluZ3MuZHVyYXRpb24gPSBhbmltTGVuZ3RoID8gTWF0aC5tYXguYXBwbHkoTWF0aCwgYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGdldFRsT2Zmc2V0KGFuaW0pICsgYW5pbS5kdXJhdGlvbjsgfSkpIDogdHdlZW5TZXR0aW5ncy5kdXJhdGlvbjtcbiAgdGltaW5ncy5kZWxheSA9IGFuaW1MZW5ndGggPyBNYXRoLm1pbi5hcHBseShNYXRoLCBhbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gZ2V0VGxPZmZzZXQoYW5pbSkgKyBhbmltLmRlbGF5OyB9KSkgOiB0d2VlblNldHRpbmdzLmRlbGF5O1xuICB0aW1pbmdzLmVuZERlbGF5ID0gYW5pbUxlbmd0aCA/IHRpbWluZ3MuZHVyYXRpb24gLSBNYXRoLm1heC5hcHBseShNYXRoLCBhbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gZ2V0VGxPZmZzZXQoYW5pbSkgKyBhbmltLmR1cmF0aW9uIC0gYW5pbS5lbmREZWxheTsgfSkpIDogdHdlZW5TZXR0aW5ncy5lbmREZWxheTtcbiAgcmV0dXJuIHRpbWluZ3M7XG59XG5cbnZhciBpbnN0YW5jZUlEID0gMDtcblxuZnVuY3Rpb24gY3JlYXRlTmV3SW5zdGFuY2UocGFyYW1zKSB7XG4gIHZhciBpbnN0YW5jZVNldHRpbmdzID0gcmVwbGFjZU9iamVjdFByb3BzKGRlZmF1bHRJbnN0YW5jZVNldHRpbmdzLCBwYXJhbXMpO1xuICB2YXIgdHdlZW5TZXR0aW5ncyA9IHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0VHdlZW5TZXR0aW5ncywgcGFyYW1zKTtcbiAgdmFyIHByb3BlcnRpZXMgPSBnZXRQcm9wZXJ0aWVzKHR3ZWVuU2V0dGluZ3MsIHBhcmFtcyk7XG4gIHZhciBhbmltYXRhYmxlcyA9IGdldEFuaW1hdGFibGVzKHBhcmFtcy50YXJnZXRzKTtcbiAgdmFyIGFuaW1hdGlvbnMgPSBnZXRBbmltYXRpb25zKGFuaW1hdGFibGVzLCBwcm9wZXJ0aWVzKTtcbiAgdmFyIHRpbWluZ3MgPSBnZXRJbnN0YW5jZVRpbWluZ3MoYW5pbWF0aW9ucywgdHdlZW5TZXR0aW5ncyk7XG4gIHZhciBpZCA9IGluc3RhbmNlSUQ7XG4gIGluc3RhbmNlSUQrKztcbiAgcmV0dXJuIG1lcmdlT2JqZWN0cyhpbnN0YW5jZVNldHRpbmdzLCB7XG4gICAgaWQ6IGlkLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBhbmltYXRhYmxlczogYW5pbWF0YWJsZXMsXG4gICAgYW5pbWF0aW9uczogYW5pbWF0aW9ucyxcbiAgICBkdXJhdGlvbjogdGltaW5ncy5kdXJhdGlvbixcbiAgICBkZWxheTogdGltaW5ncy5kZWxheSxcbiAgICBlbmREZWxheTogdGltaW5ncy5lbmREZWxheVxuICB9KTtcbn1cblxuLy8gQ29yZVxuXG52YXIgYWN0aXZlSW5zdGFuY2VzID0gW107XG52YXIgcGF1c2VkSW5zdGFuY2VzID0gW107XG52YXIgcmFmO1xuXG52YXIgZW5naW5lID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gcGxheSgpIHsgXG4gICAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICB9XG4gIGZ1bmN0aW9uIHN0ZXAodCkge1xuICAgIHZhciBhY3RpdmVJbnN0YW5jZXNMZW5ndGggPSBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoO1xuICAgIGlmIChhY3RpdmVJbnN0YW5jZXNMZW5ndGgpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgYWN0aXZlSW5zdGFuY2VzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlc1tpXTtcbiAgICAgICAgaWYgKCFhY3RpdmVJbnN0YW5jZS5wYXVzZWQpIHtcbiAgICAgICAgICBhY3RpdmVJbnN0YW5jZS50aWNrKHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpbnN0YW5jZUluZGV4ID0gYWN0aXZlSW5zdGFuY2VzLmluZGV4T2YoYWN0aXZlSW5zdGFuY2UpO1xuICAgICAgICAgIGlmIChpbnN0YW5jZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGFjdGl2ZUluc3RhbmNlcy5zcGxpY2UoaW5zdGFuY2VJbmRleCwgMSk7XG4gICAgICAgICAgICBhY3RpdmVJbnN0YW5jZXNMZW5ndGggPSBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBwbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhZiA9IGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG4gICAgfVxuICB9XG4gIHJldHVybiBwbGF5O1xufSkoKTtcblxuZnVuY3Rpb24gaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgIGFjdGl2ZUluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnMpIHsgcmV0dXJuIGlucy5wYXVzZSgpOyB9KTtcbiAgICBwYXVzZWRJbnN0YW5jZXMgPSBhY3RpdmVJbnN0YW5jZXMuc2xpY2UoMCk7XG4gICAgYWN0aXZlSW5zdGFuY2VzID0gW107XG4gIH0gZWxzZSB7XG4gICAgcGF1c2VkSW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGlucykgeyByZXR1cm4gaW5zLnBsYXkoKTsgfSk7XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xufVxuXG4vLyBQdWJsaWMgSW5zdGFuY2VcblxuZnVuY3Rpb24gYW5pbWUocGFyYW1zKSB7XG4gIGlmICggcGFyYW1zID09PSB2b2lkIDAgKSBwYXJhbXMgPSB7fTtcblxuXG4gIHZhciBzdGFydFRpbWUgPSAwLCBsYXN0VGltZSA9IDAsIG5vdyA9IDA7XG4gIHZhciBjaGlsZHJlbiwgY2hpbGRyZW5MZW5ndGggPSAwO1xuICB2YXIgcmVzb2x2ZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbWFrZVByb21pc2UoaW5zdGFuY2UpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHdpbmRvdy5Qcm9taXNlICYmIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChfcmVzb2x2ZSkgeyByZXR1cm4gcmVzb2x2ZSA9IF9yZXNvbHZlOyB9KTtcbiAgICBpbnN0YW5jZS5maW5pc2hlZCA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVOZXdJbnN0YW5jZShwYXJhbXMpO1xuICB2YXIgcHJvbWlzZSA9IG1ha2VQcm9taXNlKGluc3RhbmNlKTtcblxuICBmdW5jdGlvbiB0b2dnbGVJbnN0YW5jZURpcmVjdGlvbigpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gaW5zdGFuY2UuZGlyZWN0aW9uO1xuICAgIGlmIChkaXJlY3Rpb24gIT09ICdhbHRlcm5hdGUnKSB7XG4gICAgICBpbnN0YW5jZS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24gIT09ICdub3JtYWwnID8gJ25vcm1hbCcgOiAncmV2ZXJzZSc7XG4gICAgfVxuICAgIGluc3RhbmNlLnJldmVyc2VkID0gIWluc3RhbmNlLnJldmVyc2VkO1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5yZXZlcnNlZCA9IGluc3RhbmNlLnJldmVyc2VkOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkanVzdFRpbWUodGltZSkge1xuICAgIHJldHVybiBpbnN0YW5jZS5yZXZlcnNlZCA/IGluc3RhbmNlLmR1cmF0aW9uIC0gdGltZSA6IHRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRpbWUoKSB7XG4gICAgc3RhcnRUaW1lID0gMDtcbiAgICBsYXN0VGltZSA9IGFkanVzdFRpbWUoaW5zdGFuY2UuY3VycmVudFRpbWUpICogKDEgLyBhbmltZS5zcGVlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWVrQ2lsZCh0aW1lLCBjaGlsZCkge1xuICAgIGlmIChjaGlsZCkgeyBjaGlsZC5zZWVrKHRpbWUgLSBjaGlsZC50aW1lbGluZU9mZnNldCk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN5bmNJbnN0YW5jZUNoaWxkcmVuKHRpbWUpIHtcbiAgICBpZiAoIWluc3RhbmNlLnJldmVyc2VQbGF5YmFjaykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7IHNlZWtDaWxkKHRpbWUsIGNoaWxkcmVuW2ldKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSBjaGlsZHJlbkxlbmd0aDsgaSQxLS07KSB7IHNlZWtDaWxkKHRpbWUsIGNoaWxkcmVuW2kkMV0pOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc1RpbWUpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFuaW1hdGlvbnMgPSBpbnN0YW5jZS5hbmltYXRpb25zO1xuICAgIHZhciBhbmltYXRpb25zTGVuZ3RoID0gYW5pbWF0aW9ucy5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBhbmltYXRpb25zTGVuZ3RoKSB7XG4gICAgICB2YXIgYW5pbSA9IGFuaW1hdGlvbnNbaV07XG4gICAgICB2YXIgYW5pbWF0YWJsZSA9IGFuaW0uYW5pbWF0YWJsZTtcbiAgICAgIHZhciB0d2VlbnMgPSBhbmltLnR3ZWVucztcbiAgICAgIHZhciB0d2Vlbkxlbmd0aCA9IHR3ZWVucy5sZW5ndGggLSAxO1xuICAgICAgdmFyIHR3ZWVuID0gdHdlZW5zW3R3ZWVuTGVuZ3RoXTtcbiAgICAgIC8vIE9ubHkgY2hlY2sgZm9yIGtleWZyYW1lcyBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHR3ZWVuXG4gICAgICBpZiAodHdlZW5MZW5ndGgpIHsgdHdlZW4gPSBmaWx0ZXJBcnJheSh0d2VlbnMsIGZ1bmN0aW9uICh0KSB7IHJldHVybiAoaW5zVGltZSA8IHQuZW5kKTsgfSlbMF0gfHwgdHdlZW47IH1cbiAgICAgIHZhciBlbGFwc2VkID0gbWluTWF4KGluc1RpbWUgLSB0d2Vlbi5zdGFydCAtIHR3ZWVuLmRlbGF5LCAwLCB0d2Vlbi5kdXJhdGlvbikgLyB0d2Vlbi5kdXJhdGlvbjtcbiAgICAgIHZhciBlYXNlZCA9IGlzTmFOKGVsYXBzZWQpID8gMSA6IHR3ZWVuLmVhc2luZyhlbGFwc2VkKTtcbiAgICAgIHZhciBzdHJpbmdzID0gdHdlZW4udG8uc3RyaW5ncztcbiAgICAgIHZhciByb3VuZCA9IHR3ZWVuLnJvdW5kO1xuICAgICAgdmFyIG51bWJlcnMgPSBbXTtcbiAgICAgIHZhciB0b051bWJlcnNMZW5ndGggPSB0d2Vlbi50by5udW1iZXJzLmxlbmd0aDtcbiAgICAgIHZhciBwcm9ncmVzcyA9ICh2b2lkIDApO1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0b051bWJlcnNMZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgdmFsdWUgPSAodm9pZCAwKTtcbiAgICAgICAgdmFyIHRvTnVtYmVyID0gdHdlZW4udG8ubnVtYmVyc1tuXTtcbiAgICAgICAgdmFyIGZyb21OdW1iZXIgPSB0d2Vlbi5mcm9tLm51bWJlcnNbbl0gfHwgMDtcbiAgICAgICAgaWYgKCF0d2Vlbi5pc1BhdGgpIHtcbiAgICAgICAgICB2YWx1ZSA9IGZyb21OdW1iZXIgKyAoZWFzZWQgKiAodG9OdW1iZXIgLSBmcm9tTnVtYmVyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBnZXRQYXRoUHJvZ3Jlc3ModHdlZW4udmFsdWUsIGVhc2VkICogdG9OdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3VuZCkge1xuICAgICAgICAgIGlmICghKHR3ZWVuLmlzQ29sb3IgJiYgbiA+IDIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiByb3VuZCkgLyByb3VuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbnVtYmVycy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIE1hbnVhbCBBcnJheS5yZWR1Y2UgZm9yIGJldHRlciBwZXJmb3JtYW5jZXNcbiAgICAgIHZhciBzdHJpbmdzTGVuZ3RoID0gc3RyaW5ncy5sZW5ndGg7XG4gICAgICBpZiAoIXN0cmluZ3NMZW5ndGgpIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSBudW1iZXJzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSBzdHJpbmdzWzBdO1xuICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHN0cmluZ3NMZW5ndGg7IHMrKykge1xuICAgICAgICAgIHZhciBhID0gc3RyaW5nc1tzXTtcbiAgICAgICAgICB2YXIgYiA9IHN0cmluZ3NbcyArIDFdO1xuICAgICAgICAgIHZhciBuJDEgPSBudW1iZXJzW3NdO1xuICAgICAgICAgIGlmICghaXNOYU4obiQxKSkge1xuICAgICAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAgIHByb2dyZXNzICs9IG4kMSArICcgJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByb2dyZXNzICs9IG4kMSArIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRQcm9ncmVzc1ZhbHVlW2FuaW0udHlwZV0oYW5pbWF0YWJsZS50YXJnZXQsIGFuaW0ucHJvcGVydHksIHByb2dyZXNzLCBhbmltYXRhYmxlLnRyYW5zZm9ybXMpO1xuICAgICAgYW5pbS5jdXJyZW50VmFsdWUgPSBwcm9ncmVzcztcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDYWxsYmFjayhjYikge1xuICAgIGlmIChpbnN0YW5jZVtjYl0gJiYgIWluc3RhbmNlLnBhc3NUaHJvdWdoKSB7IGluc3RhbmNlW2NiXShpbnN0YW5jZSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvdW50SXRlcmF0aW9uKCkge1xuICAgIGlmIChpbnN0YW5jZS5yZW1haW5pbmcgJiYgaW5zdGFuY2UucmVtYWluaW5nICE9PSB0cnVlKSB7XG4gICAgICBpbnN0YW5jZS5yZW1haW5pbmctLTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRJbnN0YW5jZVByb2dyZXNzKGVuZ2luZVRpbWUpIHtcbiAgICB2YXIgaW5zRHVyYXRpb24gPSBpbnN0YW5jZS5kdXJhdGlvbjtcbiAgICB2YXIgaW5zRGVsYXkgPSBpbnN0YW5jZS5kZWxheTtcbiAgICB2YXIgaW5zRW5kRGVsYXkgPSBpbnNEdXJhdGlvbiAtIGluc3RhbmNlLmVuZERlbGF5O1xuICAgIHZhciBpbnNUaW1lID0gYWRqdXN0VGltZShlbmdpbmVUaW1lKTtcbiAgICBpbnN0YW5jZS5wcm9ncmVzcyA9IG1pbk1heCgoaW5zVGltZSAvIGluc0R1cmF0aW9uKSAqIDEwMCwgMCwgMTAwKTtcbiAgICBpbnN0YW5jZS5yZXZlcnNlUGxheWJhY2sgPSBpbnNUaW1lIDwgaW5zdGFuY2UuY3VycmVudFRpbWU7XG4gICAgaWYgKGNoaWxkcmVuKSB7IHN5bmNJbnN0YW5jZUNoaWxkcmVuKGluc1RpbWUpOyB9XG4gICAgaWYgKCFpbnN0YW5jZS5iZWdhbiAmJiBpbnN0YW5jZS5jdXJyZW50VGltZSA+IDApIHtcbiAgICAgIGluc3RhbmNlLmJlZ2FuID0gdHJ1ZTtcbiAgICAgIHNldENhbGxiYWNrKCdiZWdpbicpO1xuICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BCZWdpbicpO1xuICAgIH1cbiAgICBpZiAoaW5zVGltZSA8PSBpbnNEZWxheSAmJiBpbnN0YW5jZS5jdXJyZW50VGltZSAhPT0gMCkge1xuICAgICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKDApO1xuICAgIH1cbiAgICBpZiAoKGluc1RpbWUgPj0gaW5zRW5kRGVsYXkgJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgIT09IGluc0R1cmF0aW9uKSB8fCAhaW5zRHVyYXRpb24pIHtcbiAgICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcyhpbnNEdXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChpbnNUaW1lID4gaW5zRGVsYXkgJiYgaW5zVGltZSA8IGluc0VuZERlbGF5KSB7XG4gICAgICBpZiAoIWluc3RhbmNlLmNoYW5nZUJlZ2FuKSB7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUJlZ2FuID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHNldENhbGxiYWNrKCdjaGFuZ2VCZWdpbicpO1xuICAgICAgfVxuICAgICAgc2V0Q2FsbGJhY2soJ2NoYW5nZScpO1xuICAgICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc1RpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5zdGFuY2UuY2hhbmdlQmVnYW4pIHtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQmVnYW4gPSBmYWxzZTtcbiAgICAgICAgc2V0Q2FsbGJhY2soJ2NoYW5nZUNvbXBsZXRlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLmN1cnJlbnRUaW1lID0gbWluTWF4KGluc1RpbWUsIDAsIGluc0R1cmF0aW9uKTtcbiAgICBpZiAoaW5zdGFuY2UuYmVnYW4pIHsgc2V0Q2FsbGJhY2soJ3VwZGF0ZScpOyB9XG4gICAgaWYgKGVuZ2luZVRpbWUgPj0gaW5zRHVyYXRpb24pIHtcbiAgICAgIGxhc3RUaW1lID0gMDtcbiAgICAgIGNvdW50SXRlcmF0aW9uKCk7XG4gICAgICBpZiAoaW5zdGFuY2UucmVtYWluaW5nKSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IG5vdztcbiAgICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BDb21wbGV0ZScpO1xuICAgICAgICBzZXRDYWxsYmFjaygnbG9vcEJlZ2luJyk7XG4gICAgICAgIGlmIChpbnN0YW5jZS5kaXJlY3Rpb24gPT09ICdhbHRlcm5hdGUnKSB7IHRvZ2dsZUluc3RhbmNlRGlyZWN0aW9uKCk7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLnBhdXNlZCA9IHRydWU7XG4gICAgICAgIGlmICghaW5zdGFuY2UuY29tcGxldGVkKSB7XG4gICAgICAgICAgaW5zdGFuY2UuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDYWxsYmFjaygnbG9vcENvbXBsZXRlJyk7XG4gICAgICAgICAgc2V0Q2FsbGJhY2soJ2NvbXBsZXRlJyk7XG4gICAgICAgICAgaWYgKCFpbnN0YW5jZS5wYXNzVGhyb3VnaCAmJiAnUHJvbWlzZScgaW4gd2luZG93KSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICBwcm9taXNlID0gbWFrZVByb21pc2UoaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluc3RhbmNlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGluc3RhbmNlLmRpcmVjdGlvbjtcbiAgICBpbnN0YW5jZS5wYXNzVGhyb3VnaCA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmN1cnJlbnRUaW1lID0gMDtcbiAgICBpbnN0YW5jZS5wcm9ncmVzcyA9IDA7XG4gICAgaW5zdGFuY2UucGF1c2VkID0gdHJ1ZTtcbiAgICBpbnN0YW5jZS5iZWdhbiA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmNoYW5nZUJlZ2FuID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY29tcGxldGVkID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gZmFsc2U7XG4gICAgaW5zdGFuY2UucmV2ZXJzZVBsYXliYWNrID0gZmFsc2U7XG4gICAgaW5zdGFuY2UucmV2ZXJzZWQgPSBkaXJlY3Rpb24gPT09ICdyZXZlcnNlJztcbiAgICBpbnN0YW5jZS5yZW1haW5pbmcgPSBpbnN0YW5jZS5sb29wO1xuICAgIGNoaWxkcmVuID0gaW5zdGFuY2UuY2hpbGRyZW47XG4gICAgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuTGVuZ3RoOyBpLS07KSB7IGluc3RhbmNlLmNoaWxkcmVuW2ldLnJlc2V0KCk7IH1cbiAgICBpZiAoaW5zdGFuY2UucmV2ZXJzZWQgJiYgaW5zdGFuY2UubG9vcCAhPT0gdHJ1ZSB8fCAoZGlyZWN0aW9uID09PSAnYWx0ZXJuYXRlJyAmJiBpbnN0YW5jZS5sb29wID09PSAxKSkgeyBpbnN0YW5jZS5yZW1haW5pbmcrKzsgfVxuICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcygwKTtcbiAgfTtcblxuICAvLyBTZXQgVmFsdWUgaGVscGVyXG5cbiAgaW5zdGFuY2Uuc2V0ID0gZnVuY3Rpb24odGFyZ2V0cywgcHJvcGVydGllcykge1xuICAgIHNldFRhcmdldHNWYWx1ZSh0YXJnZXRzLCBwcm9wZXJ0aWVzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgaW5zdGFuY2UudGljayA9IGZ1bmN0aW9uKHQpIHtcbiAgICBub3cgPSB0O1xuICAgIGlmICghc3RhcnRUaW1lKSB7IHN0YXJ0VGltZSA9IG5vdzsgfVxuICAgIHNldEluc3RhbmNlUHJvZ3Jlc3MoKG5vdyArIChsYXN0VGltZSAtIHN0YXJ0VGltZSkpICogYW5pbWUuc3BlZWQpO1xuICB9O1xuXG4gIGluc3RhbmNlLnNlZWsgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgc2V0SW5zdGFuY2VQcm9ncmVzcyhhZGp1c3RUaW1lKHRpbWUpKTtcbiAgfTtcblxuICBpbnN0YW5jZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIGluc3RhbmNlLnBhdXNlZCA9IHRydWU7XG4gICAgcmVzZXRUaW1lKCk7XG4gIH07XG5cbiAgaW5zdGFuY2UucGxheSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghaW5zdGFuY2UucGF1c2VkKSB7IHJldHVybjsgfVxuICAgIGlmIChpbnN0YW5jZS5jb21wbGV0ZWQpIHsgaW5zdGFuY2UucmVzZXQoKTsgfVxuICAgIGluc3RhbmNlLnBhdXNlZCA9IGZhbHNlO1xuICAgIGFjdGl2ZUluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcbiAgICByZXNldFRpbWUoKTtcbiAgICBpZiAoIXJhZikgeyBlbmdpbmUoKTsgfVxuICB9O1xuXG4gIGluc3RhbmNlLnJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgICB0b2dnbGVJbnN0YW5jZURpcmVjdGlvbigpO1xuICAgIHJlc2V0VGltZSgpO1xuICB9O1xuXG4gIGluc3RhbmNlLnJlc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpbnN0YW5jZS5yZXNldCgpO1xuICAgIGluc3RhbmNlLnBsYXkoKTtcbiAgfTtcblxuICBpbnN0YW5jZS5yZXNldCgpO1xuXG4gIGlmIChpbnN0YW5jZS5hdXRvcGxheSkgeyBpbnN0YW5jZS5wbGF5KCk7IH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG5cbn1cblxuLy8gUmVtb3ZlIHRhcmdldHMgZnJvbSBhbmltYXRpb25cblxuZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0c0Zyb21BbmltYXRpb25zKHRhcmdldHNBcnJheSwgYW5pbWF0aW9ucykge1xuICBmb3IgKHZhciBhID0gYW5pbWF0aW9ucy5sZW5ndGg7IGEtLTspIHtcbiAgICBpZiAoYXJyYXlDb250YWlucyh0YXJnZXRzQXJyYXksIGFuaW1hdGlvbnNbYV0uYW5pbWF0YWJsZS50YXJnZXQpKSB7XG4gICAgICBhbmltYXRpb25zLnNwbGljZShhLCAxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0cyh0YXJnZXRzKSB7XG4gIHZhciB0YXJnZXRzQXJyYXkgPSBwYXJzZVRhcmdldHModGFyZ2V0cyk7XG4gIGZvciAodmFyIGkgPSBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgdmFyIGluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2VzW2ldO1xuICAgIHZhciBhbmltYXRpb25zID0gaW5zdGFuY2UuYW5pbWF0aW9ucztcbiAgICB2YXIgY2hpbGRyZW4gPSBpbnN0YW5jZS5jaGlsZHJlbjtcbiAgICByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbnModGFyZ2V0c0FycmF5LCBhbmltYXRpb25zKTtcbiAgICBmb3IgKHZhciBjID0gY2hpbGRyZW4ubGVuZ3RoOyBjLS07KSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltjXTtcbiAgICAgIHZhciBjaGlsZEFuaW1hdGlvbnMgPSBjaGlsZC5hbmltYXRpb25zO1xuICAgICAgcmVtb3ZlVGFyZ2V0c0Zyb21BbmltYXRpb25zKHRhcmdldHNBcnJheSwgY2hpbGRBbmltYXRpb25zKTtcbiAgICAgIGlmICghY2hpbGRBbmltYXRpb25zLmxlbmd0aCAmJiAhY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7IGNoaWxkcmVuLnNwbGljZShjLCAxKTsgfVxuICAgIH1cbiAgICBpZiAoIWFuaW1hdGlvbnMubGVuZ3RoICYmICFjaGlsZHJlbi5sZW5ndGgpIHsgaW5zdGFuY2UucGF1c2UoKTsgfVxuICB9XG59XG5cbi8vIFN0YWdnZXIgaGVscGVyc1xuXG5mdW5jdGlvbiBzdGFnZ2VyKHZhbCwgcGFyYW1zKSB7XG4gIGlmICggcGFyYW1zID09PSB2b2lkIDAgKSBwYXJhbXMgPSB7fTtcblxuICB2YXIgZGlyZWN0aW9uID0gcGFyYW1zLmRpcmVjdGlvbiB8fCAnbm9ybWFsJztcbiAgdmFyIGVhc2luZyA9IHBhcmFtcy5lYXNpbmcgPyBwYXJzZUVhc2luZ3MocGFyYW1zLmVhc2luZykgOiBudWxsO1xuICB2YXIgZ3JpZCA9IHBhcmFtcy5ncmlkO1xuICB2YXIgYXhpcyA9IHBhcmFtcy5heGlzO1xuICB2YXIgZnJvbUluZGV4ID0gcGFyYW1zLmZyb20gfHwgMDtcbiAgdmFyIGZyb21GaXJzdCA9IGZyb21JbmRleCA9PT0gJ2ZpcnN0JztcbiAgdmFyIGZyb21DZW50ZXIgPSBmcm9tSW5kZXggPT09ICdjZW50ZXInO1xuICB2YXIgZnJvbUxhc3QgPSBmcm9tSW5kZXggPT09ICdsYXN0JztcbiAgdmFyIGlzUmFuZ2UgPSBpcy5hcnIodmFsKTtcbiAgdmFyIHZhbDEgPSBpc1JhbmdlID8gcGFyc2VGbG9hdCh2YWxbMF0pIDogcGFyc2VGbG9hdCh2YWwpO1xuICB2YXIgdmFsMiA9IGlzUmFuZ2UgPyBwYXJzZUZsb2F0KHZhbFsxXSkgOiAwO1xuICB2YXIgdW5pdCA9IGdldFVuaXQoaXNSYW5nZSA/IHZhbFsxXSA6IHZhbCkgfHwgMDtcbiAgdmFyIHN0YXJ0ID0gcGFyYW1zLnN0YXJ0IHx8IDAgKyAoaXNSYW5nZSA/IHZhbDEgOiAwKTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgbWF4VmFsdWUgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKGVsLCBpLCB0KSB7XG4gICAgaWYgKGZyb21GaXJzdCkgeyBmcm9tSW5kZXggPSAwOyB9XG4gICAgaWYgKGZyb21DZW50ZXIpIHsgZnJvbUluZGV4ID0gKHQgLSAxKSAvIDI7IH1cbiAgICBpZiAoZnJvbUxhc3QpIHsgZnJvbUluZGV4ID0gdCAtIDE7IH1cbiAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0OyBpbmRleCsrKSB7XG4gICAgICAgIGlmICghZ3JpZCkge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKE1hdGguYWJzKGZyb21JbmRleCAtIGluZGV4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZyb21YID0gIWZyb21DZW50ZXIgPyBmcm9tSW5kZXglZ3JpZFswXSA6IChncmlkWzBdLTEpLzI7XG4gICAgICAgICAgdmFyIGZyb21ZID0gIWZyb21DZW50ZXIgPyBNYXRoLmZsb29yKGZyb21JbmRleC9ncmlkWzBdKSA6IChncmlkWzFdLTEpLzI7XG4gICAgICAgICAgdmFyIHRvWCA9IGluZGV4JWdyaWRbMF07XG4gICAgICAgICAgdmFyIHRvWSA9IE1hdGguZmxvb3IoaW5kZXgvZ3JpZFswXSk7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlWCA9IGZyb21YIC0gdG9YO1xuICAgICAgICAgIHZhciBkaXN0YW5jZVkgPSBmcm9tWSAtIHRvWTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBNYXRoLnNxcnQoZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZKTtcbiAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnKSB7IHZhbHVlID0gLWRpc3RhbmNlWDsgfVxuICAgICAgICAgIGlmIChheGlzID09PSAneScpIHsgdmFsdWUgPSAtZGlzdGFuY2VZOyB9XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG1heFZhbHVlID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChlYXNpbmcpIHsgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBlYXNpbmcodmFsIC8gbWF4VmFsdWUpICogbWF4VmFsdWU7IH0pOyB9XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAncmV2ZXJzZScpIHsgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBheGlzID8gKHZhbCA8IDApID8gdmFsICogLTEgOiAtdmFsIDogTWF0aC5hYnMobWF4VmFsdWUgLSB2YWwpOyB9KTsgfVxuICAgIH1cbiAgICB2YXIgc3BhY2luZyA9IGlzUmFuZ2UgPyAodmFsMiAtIHZhbDEpIC8gbWF4VmFsdWUgOiB2YWwxO1xuICAgIHJldHVybiBzdGFydCArIChzcGFjaW5nICogKE1hdGgucm91bmQodmFsdWVzW2ldICogMTAwKSAvIDEwMCkpICsgdW5pdDtcbiAgfVxufVxuXG4vLyBUaW1lbGluZVxuXG5mdW5jdGlvbiB0aW1lbGluZShwYXJhbXMpIHtcbiAgaWYgKCBwYXJhbXMgPT09IHZvaWQgMCApIHBhcmFtcyA9IHt9O1xuXG4gIHZhciB0bCA9IGFuaW1lKHBhcmFtcyk7XG4gIHRsLmR1cmF0aW9uID0gMDtcbiAgdGwuYWRkID0gZnVuY3Rpb24oaW5zdGFuY2VQYXJhbXMsIHRpbWVsaW5lT2Zmc2V0KSB7XG4gICAgdmFyIHRsSW5kZXggPSBhY3RpdmVJbnN0YW5jZXMuaW5kZXhPZih0bCk7XG4gICAgdmFyIGNoaWxkcmVuID0gdGwuY2hpbGRyZW47XG4gICAgaWYgKHRsSW5kZXggPiAtMSkgeyBhY3RpdmVJbnN0YW5jZXMuc3BsaWNlKHRsSW5kZXgsIDEpOyB9XG4gICAgZnVuY3Rpb24gcGFzc1Rocm91Z2goaW5zKSB7IGlucy5wYXNzVGhyb3VnaCA9IHRydWU7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7IHBhc3NUaHJvdWdoKGNoaWxkcmVuW2ldKTsgfVxuICAgIHZhciBpbnNQYXJhbXMgPSBtZXJnZU9iamVjdHMoaW5zdGFuY2VQYXJhbXMsIHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0VHdlZW5TZXR0aW5ncywgcGFyYW1zKSk7XG4gICAgaW5zUGFyYW1zLnRhcmdldHMgPSBpbnNQYXJhbXMudGFyZ2V0cyB8fCBwYXJhbXMudGFyZ2V0cztcbiAgICB2YXIgdGxEdXJhdGlvbiA9IHRsLmR1cmF0aW9uO1xuICAgIGluc1BhcmFtcy5hdXRvcGxheSA9IGZhbHNlO1xuICAgIGluc1BhcmFtcy5kaXJlY3Rpb24gPSB0bC5kaXJlY3Rpb247XG4gICAgaW5zUGFyYW1zLnRpbWVsaW5lT2Zmc2V0ID0gaXMudW5kKHRpbWVsaW5lT2Zmc2V0KSA/IHRsRHVyYXRpb24gOiBnZXRSZWxhdGl2ZVZhbHVlKHRpbWVsaW5lT2Zmc2V0LCB0bER1cmF0aW9uKTtcbiAgICBwYXNzVGhyb3VnaCh0bCk7XG4gICAgdGwuc2VlayhpbnNQYXJhbXMudGltZWxpbmVPZmZzZXQpO1xuICAgIHZhciBpbnMgPSBhbmltZShpbnNQYXJhbXMpO1xuICAgIHBhc3NUaHJvdWdoKGlucyk7XG4gICAgY2hpbGRyZW4ucHVzaChpbnMpO1xuICAgIHZhciB0aW1pbmdzID0gZ2V0SW5zdGFuY2VUaW1pbmdzKGNoaWxkcmVuLCBwYXJhbXMpO1xuICAgIHRsLmRlbGF5ID0gdGltaW5ncy5kZWxheTtcbiAgICB0bC5lbmREZWxheSA9IHRpbWluZ3MuZW5kRGVsYXk7XG4gICAgdGwuZHVyYXRpb24gPSB0aW1pbmdzLmR1cmF0aW9uO1xuICAgIHRsLnNlZWsoMCk7XG4gICAgdGwucmVzZXQoKTtcbiAgICBpZiAodGwuYXV0b3BsYXkpIHsgdGwucGxheSgpOyB9XG4gICAgcmV0dXJuIHRsO1xuICB9O1xuICByZXR1cm4gdGw7XG59XG5cbmFuaW1lLnZlcnNpb24gPSAnMy4wLjEnO1xuYW5pbWUuc3BlZWQgPSAxO1xuYW5pbWUucnVubmluZyA9IGFjdGl2ZUluc3RhbmNlcztcbmFuaW1lLnJlbW92ZSA9IHJlbW92ZVRhcmdldHM7XG5hbmltZS5nZXQgPSBnZXRPcmlnaW5hbFRhcmdldFZhbHVlO1xuYW5pbWUuc2V0ID0gc2V0VGFyZ2V0c1ZhbHVlO1xuYW5pbWUuY29udmVydFB4ID0gY29udmVydFB4VG9Vbml0O1xuYW5pbWUucGF0aCA9IGdldFBhdGg7XG5hbmltZS5zZXREYXNob2Zmc2V0ID0gc2V0RGFzaG9mZnNldDtcbmFuaW1lLnN0YWdnZXIgPSBzdGFnZ2VyO1xuYW5pbWUudGltZWxpbmUgPSB0aW1lbGluZTtcbmFuaW1lLmVhc2luZyA9IHBhcnNlRWFzaW5ncztcbmFuaW1lLnBlbm5lciA9IHBlbm5lcjtcbmFuaW1lLnJhbmRvbSA9IGZ1bmN0aW9uIChtaW4sIG1heCkgeyByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjsgfTtcblxuZXhwb3J0IGRlZmF1bHQgYW5pbWU7XG4iLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSB1bmxlc3MgYW1kTW9kdWxlSWQgaXMgc2V0XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHJvb3RbJ0F1dG9saW5rZXInXSA9IGZhY3RvcnkoKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgLy8gbGlrZSBOb2RlLlxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHJvb3RbJ0F1dG9saW5rZXInXSA9IGZhY3RvcnkoKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbi8qIVxuICogQXV0b2xpbmtlci5qc1xuICogMC4xNS4zXG4gKlxuICogQ29weXJpZ2h0KGMpIDIwMTUgR3JlZ29yeSBKYWNvYnMgPGdyZWdAZ3JlZy1qYWNvYnMuY29tPlxuICogTUlUIExpY2Vuc2VkLiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVnamFjb2JzL0F1dG9saW5rZXIuanNcbiAqL1xuLyoqXG4gKiBAY2xhc3MgQXV0b2xpbmtlclxuICogQGV4dGVuZHMgT2JqZWN0XG4gKiBcbiAqIFV0aWxpdHkgY2xhc3MgdXNlZCB0byBwcm9jZXNzIGEgZ2l2ZW4gc3RyaW5nIG9mIHRleHQsIGFuZCB3cmFwIHRoZSBVUkxzLCBlbWFpbCBhZGRyZXNzZXMsIGFuZCBUd2l0dGVyIGhhbmRsZXMgaW4gXG4gKiB0aGUgYXBwcm9wcmlhdGUgYW5jaG9yICgmbHQ7YSZndDspIHRhZ3MgdG8gdHVybiB0aGVtIGludG8gbGlua3MuXG4gKiBcbiAqIEFueSBvZiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG1heSBiZSBwcm92aWRlZCBpbiBhbiBPYmplY3QgKG1hcCkgcHJvdmlkZWQgdG8gdGhlIEF1dG9saW5rZXIgY29uc3RydWN0b3IsIHdoaWNoXG4gKiB3aWxsIGNvbmZpZ3VyZSBob3cgdGhlIHtAbGluayAjbGluayBsaW5rKCl9IG1ldGhvZCB3aWxsIHByb2Nlc3MgdGhlIGxpbmtzLlxuICogXG4gKiBGb3IgZXhhbXBsZTpcbiAqIFxuICogICAgIHZhciBhdXRvbGlua2VyID0gbmV3IEF1dG9saW5rZXIoIHtcbiAqICAgICAgICAgbmV3V2luZG93IDogZmFsc2UsXG4gKiAgICAgICAgIHRydW5jYXRlICA6IDMwXG4gKiAgICAgfSApO1xuICogICAgIFxuICogICAgIHZhciBodG1sID0gYXV0b2xpbmtlci5saW5rKCBcIkpvZSB3ZW50IHRvIHd3dy55YWhvby5jb21cIiApO1xuICogICAgIC8vIHByb2R1Y2VzOiAnSm9lIHdlbnQgdG8gPGEgaHJlZj1cImh0dHA6Ly93d3cueWFob28uY29tXCI+eWFob28uY29tPC9hPidcbiAqIFxuICogXG4gKiBUaGUge0BsaW5rICNzdGF0aWMtbGluayBzdGF0aWMgbGluaygpfSBtZXRob2QgbWF5IGFsc28gYmUgdXNlZCB0byBpbmxpbmUgb3B0aW9ucyBpbnRvIGEgc2luZ2xlIGNhbGwsIHdoaWNoIG1heVxuICogYmUgbW9yZSBjb252ZW5pZW50IGZvciBvbmUtb2ZmIHVzZXMuIEZvciBleGFtcGxlOlxuICogXG4gKiAgICAgdmFyIGh0bWwgPSBBdXRvbGlua2VyLmxpbmsoIFwiSm9lIHdlbnQgdG8gd3d3LnlhaG9vLmNvbVwiLCB7XG4gKiAgICAgICAgIG5ld1dpbmRvdyA6IGZhbHNlLFxuICogICAgICAgICB0cnVuY2F0ZSAgOiAzMFxuICogICAgIH0gKTtcbiAqICAgICAvLyBwcm9kdWNlczogJ0pvZSB3ZW50IHRvIDxhIGhyZWY9XCJodHRwOi8vd3d3LnlhaG9vLmNvbVwiPnlhaG9vLmNvbTwvYT4nXG4gKiBcbiAqIFxuICogIyMgQ3VzdG9tIFJlcGxhY2VtZW50cyBvZiBMaW5rc1xuICogXG4gKiBJZiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGRvIG5vdCBwcm92aWRlIGVub3VnaCBmbGV4aWJpbGl0eSwgYSB7QGxpbmsgI3JlcGxhY2VGbn0gbWF5IGJlIHByb3ZpZGVkIHRvIGZ1bGx5IGN1c3RvbWl6ZVxuICogdGhlIG91dHB1dCBvZiBBdXRvbGlua2VyLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIGZvciBlYWNoIFVSTC9FbWFpbC9Ud2l0dGVyIGhhbmRsZSBtYXRjaCB0aGF0IGlzIGVuY291bnRlcmVkLlxuICogXG4gKiBGb3IgZXhhbXBsZTpcbiAqIFxuICogICAgIHZhciBpbnB1dCA9IFwiLi4uXCI7ICAvLyBzdHJpbmcgd2l0aCBVUkxzLCBFbWFpbCBBZGRyZXNzZXMsIGFuZCBUd2l0dGVyIEhhbmRsZXNcbiAqICAgICBcbiAqICAgICB2YXIgbGlua2VkVGV4dCA9IEF1dG9saW5rZXIubGluayggaW5wdXQsIHtcbiAqICAgICAgICAgcmVwbGFjZUZuIDogZnVuY3Rpb24oIGF1dG9saW5rZXIsIG1hdGNoICkge1xuICogICAgICAgICAgICAgY29uc29sZS5sb2coIFwiaHJlZiA9IFwiLCBtYXRjaC5nZXRBbmNob3JIcmVmKCkgKTtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcInRleHQgPSBcIiwgbWF0Y2guZ2V0QW5jaG9yVGV4dCgpICk7XG4gKiAgICAgICAgIFxuICogICAgICAgICAgICAgc3dpdGNoKCBtYXRjaC5nZXRUeXBlKCkgKSB7XG4gKiAgICAgICAgICAgICAgICAgY2FzZSAndXJsJyA6IFxuICogICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJ1cmw6IFwiLCBtYXRjaC5nZXRVcmwoKSApO1xuICogICAgICAgICAgICAgICAgICAgICBcbiAqICAgICAgICAgICAgICAgICAgICAgaWYoIG1hdGNoLmdldFVybCgpLmluZGV4T2YoICdteXNpdGUuY29tJyApID09PSAtMSApIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSBhdXRvbGlua2VyLmdldFRhZ0J1aWxkZXIoKS5idWlsZCggbWF0Y2ggKTsgIC8vIHJldHVybnMgYW4gYEF1dG9saW5rZXIuSHRtbFRhZ2AgaW5zdGFuY2UsIHdoaWNoIHByb3ZpZGVzIG11dGF0b3IgbWV0aG9kcyBmb3IgZWFzeSBjaGFuZ2VzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICB0YWcuc2V0QXR0ciggJ3JlbCcsICdub2ZvbGxvdycgKTtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHRhZy5hZGRDbGFzcyggJ2V4dGVybmFsLWxpbmsnICk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWc7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBcbiAqICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAgLy8gbGV0IEF1dG9saW5rZXIgcGVyZm9ybSBpdHMgbm9ybWFsIGFuY2hvciB0YWcgcmVwbGFjZW1lbnRcbiAqICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgICAgICBcbiAqICAgICAgICAgICAgICAgICBjYXNlICdlbWFpbCcgOlxuICogICAgICAgICAgICAgICAgICAgICB2YXIgZW1haWwgPSBtYXRjaC5nZXRFbWFpbCgpO1xuICogICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJlbWFpbDogXCIsIGVtYWlsICk7XG4gKiAgICAgICAgICAgICAgICAgICAgIFxuICogICAgICAgICAgICAgICAgICAgICBpZiggZW1haWwgPT09IFwibXlAb3duLmFkZHJlc3NcIiApIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgIC8vIGRvbid0IGF1dG8tbGluayB0aGlzIHBhcnRpY3VsYXIgZW1haWwgYWRkcmVzczsgbGVhdmUgYXMtaXNcbiAqICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgIC8vIG5vIHJldHVybiB2YWx1ZSB3aWxsIGhhdmUgQXV0b2xpbmtlciBwZXJmb3JtIGl0cyBub3JtYWwgYW5jaG9yIHRhZyByZXBsYWNlbWVudCAoc2FtZSBhcyByZXR1cm5pbmcgYHRydWVgKVxuICogICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgICAgICAgXG4gKiAgICAgICAgICAgICAgICAgY2FzZSAndHdpdHRlcicgOlxuICogICAgICAgICAgICAgICAgICAgICB2YXIgdHdpdHRlckhhbmRsZSA9IG1hdGNoLmdldFR3aXR0ZXJIYW5kbGUoKTtcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIHR3aXR0ZXJIYW5kbGUgKTtcbiAqICAgICAgICAgICAgICAgICAgICAgXG4gKiAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnPGEgaHJlZj1cImh0dHA6Ly9uZXdwbGFjZS50by5saW5rLnR3aXR0ZXIuaGFuZGxlcy50by9cIj4nICsgdHdpdHRlckhhbmRsZSArICc8L2E+JztcbiAqICAgICAgICAgICAgIH1cbiAqICAgICAgICAgfVxuICogICAgIH0gKTtcbiAqIFxuICogXG4gKiBUaGUgZnVuY3Rpb24gbWF5IHJldHVybiB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAqIFxuICogLSBgdHJ1ZWAgKEJvb2xlYW4pOiBBbGxvdyBBdXRvbGlua2VyIHRvIHJlcGxhY2UgdGhlIG1hdGNoIGFzIGl0IG5vcm1hbGx5IHdvdWxkLlxuICogLSBgZmFsc2VgIChCb29sZWFuKTogRG8gbm90IHJlcGxhY2UgdGhlIGN1cnJlbnQgbWF0Y2ggYXQgYWxsIC0gbGVhdmUgYXMtaXMuXG4gKiAtIEFueSBTdHJpbmc6IElmIGEgc3RyaW5nIGlzIHJldHVybmVkIGZyb20gdGhlIGZ1bmN0aW9uLCB0aGUgc3RyaW5nIHdpbGwgYmUgdXNlZCBkaXJlY3RseSBhcyB0aGUgcmVwbGFjZW1lbnQgSFRNTCBmb3JcbiAqICAgdGhlIG1hdGNoLlxuICogLSBBbiB7QGxpbmsgQXV0b2xpbmtlci5IdG1sVGFnfSBpbnN0YW5jZSwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gYnVpbGQvbW9kaWZ5IGFuIEhUTUwgdGFnIGJlZm9yZSB3cml0aW5nIG91dCBpdHMgSFRNTCB0ZXh0LlxuICogXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgQXV0b2xpbmtlciBpbnN0YW5jZSwgc3BlY2lmaWVkIGluIGFuIE9iamVjdCAobWFwKS5cbiAqL1xudmFyIEF1dG9saW5rZXIgPSBmdW5jdGlvbiggY2ZnICkge1xuXHRBdXRvbGlua2VyLlV0aWwuYXNzaWduKCB0aGlzLCBjZmcgKTsgIC8vIGFzc2lnbiB0aGUgcHJvcGVydGllcyBvZiBgY2ZnYCBvbnRvIHRoZSBBdXRvbGlua2VyIGluc3RhbmNlLiBQcm90b3R5cGUgcHJvcGVydGllcyB3aWxsIGJlIHVzZWQgZm9yIG1pc3NpbmcgY29uZmlncy5cbn07XG5cblxuQXV0b2xpbmtlci5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yIDogQXV0b2xpbmtlciwgIC8vIGZpeCBjb25zdHJ1Y3RvciBwcm9wZXJ0eVxuXHRcblx0LyoqXG5cdCAqIEBjZmcge0Jvb2xlYW59IHVybHNcblx0ICogXG5cdCAqIGB0cnVlYCBpZiBtaXNjZWxsYW5lb3VzIFVSTHMgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgbGlua2VkLCBgZmFsc2VgIGlmIHRoZXkgc2hvdWxkIG5vdCBiZS5cblx0ICovXG5cdHVybHMgOiB0cnVlLFxuXHRcblx0LyoqXG5cdCAqIEBjZmcge0Jvb2xlYW59IGVtYWlsXG5cdCAqIFxuXHQgKiBgdHJ1ZWAgaWYgZW1haWwgYWRkcmVzc2VzIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGxpbmtlZCwgYGZhbHNlYCBpZiB0aGV5IHNob3VsZCBub3QgYmUuXG5cdCAqL1xuXHRlbWFpbCA6IHRydWUsXG5cdFxuXHQvKipcblx0ICogQGNmZyB7Qm9vbGVhbn0gdHdpdHRlclxuXHQgKiBcblx0ICogYHRydWVgIGlmIFR3aXR0ZXIgaGFuZGxlcyAoXCJAZXhhbXBsZVwiKSBzaG91bGQgYmUgYXV0b21hdGljYWxseSBsaW5rZWQsIGBmYWxzZWAgaWYgdGhleSBzaG91bGQgbm90IGJlLlxuXHQgKi9cblx0dHdpdHRlciA6IHRydWUsXG5cdFxuXHQvKipcblx0ICogQGNmZyB7Qm9vbGVhbn0gbmV3V2luZG93XG5cdCAqIFxuXHQgKiBgdHJ1ZWAgaWYgdGhlIGxpbmtzIHNob3VsZCBvcGVuIGluIGEgbmV3IHdpbmRvdywgYGZhbHNlYCBvdGhlcndpc2UuXG5cdCAqL1xuXHRuZXdXaW5kb3cgOiB0cnVlLFxuXHRcblx0LyoqXG5cdCAqIEBjZmcge0Jvb2xlYW59IHN0cmlwUHJlZml4XG5cdCAqIFxuXHQgKiBgdHJ1ZWAgaWYgJ2h0dHA6Ly8nIG9yICdodHRwczovLycgYW5kL29yIHRoZSAnd3d3Licgc2hvdWxkIGJlIHN0cmlwcGVkIGZyb20gdGhlIGJlZ2lubmluZyBvZiBVUkwgbGlua3MnIHRleHQsIFxuXHQgKiBgZmFsc2VgIG90aGVyd2lzZS5cblx0ICovXG5cdHN0cmlwUHJlZml4IDogdHJ1ZSxcblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtOdW1iZXJ9IHRydW5jYXRlXG5cdCAqIFxuXHQgKiBBIG51bWJlciBmb3IgaG93IG1hbnkgY2hhcmFjdGVycyBsb25nIFVSTHMvZW1haWxzL3R3aXR0ZXIgaGFuZGxlcyBzaG91bGQgYmUgdHJ1bmNhdGVkIHRvIGluc2lkZSB0aGUgdGV4dCBvZiBcblx0ICogYSBsaW5rLiBJZiB0aGUgVVJML2VtYWlsL3R3aXR0ZXIgaXMgb3ZlciB0aGlzIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBpdCB3aWxsIGJlIHRydW5jYXRlZCB0byB0aGlzIGxlbmd0aCBieSBcblx0ICogYWRkaW5nIGEgdHdvIHBlcmlvZCBlbGxpcHNpcyAoJy4uJykgdG8gdGhlIGVuZCBvZiB0aGUgc3RyaW5nLlxuXHQgKiBcblx0ICogRm9yIGV4YW1wbGU6IEEgdXJsIGxpa2UgJ2h0dHA6Ly93d3cueWFob28uY29tL3NvbWUvbG9uZy9wYXRoL3RvL2EvZmlsZScgdHJ1bmNhdGVkIHRvIDI1IGNoYXJhY3RlcnMgbWlnaHQgbG9va1xuXHQgKiBzb21ldGhpbmcgbGlrZSB0aGlzOiAneWFob28uY29tL3NvbWUvbG9uZy9wYXQuLidcblx0ICovXG5cdHRydW5jYXRlIDogdW5kZWZpbmVkLFxuXHRcblx0LyoqXG5cdCAqIEBjZmcge1N0cmluZ30gY2xhc3NOYW1lXG5cdCAqIFxuXHQgKiBBIENTUyBjbGFzcyBuYW1lIHRvIGFkZCB0byB0aGUgZ2VuZXJhdGVkIGxpbmtzLiBUaGlzIGNsYXNzIHdpbGwgYmUgYWRkZWQgdG8gYWxsIGxpbmtzLCBhcyB3ZWxsIGFzIHRoaXMgY2xhc3Ncblx0ICogcGx1cyB1cmwvZW1haWwvdHdpdHRlciBzdWZmaXhlcyBmb3Igc3R5bGluZyB1cmwvZW1haWwvdHdpdHRlciBsaW5rcyBkaWZmZXJlbnRseS5cblx0ICogXG5cdCAqIEZvciBleGFtcGxlLCBpZiB0aGlzIGNvbmZpZyBpcyBwcm92aWRlZCBhcyBcIm15TGlua1wiLCB0aGVuOlxuXHQgKiBcblx0ICogLSBVUkwgbGlua3Mgd2lsbCBoYXZlIHRoZSBDU1MgY2xhc3NlczogXCJteUxpbmsgbXlMaW5rLXVybFwiXG5cdCAqIC0gRW1haWwgbGlua3Mgd2lsbCBoYXZlIHRoZSBDU1MgY2xhc3NlczogXCJteUxpbmsgbXlMaW5rLWVtYWlsXCIsIGFuZFxuXHQgKiAtIFR3aXR0ZXIgbGlua3Mgd2lsbCBoYXZlIHRoZSBDU1MgY2xhc3NlczogXCJteUxpbmsgbXlMaW5rLXR3aXR0ZXJcIlxuXHQgKi9cblx0Y2xhc3NOYW1lIDogXCJcIixcblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtGdW5jdGlvbn0gcmVwbGFjZUZuXG5cdCAqIFxuXHQgKiBBIGZ1bmN0aW9uIHRvIGluZGl2aWR1YWxseSBwcm9jZXNzIGVhY2ggVVJML0VtYWlsL1R3aXR0ZXIgbWF0Y2ggZm91bmQgaW4gdGhlIGlucHV0IHN0cmluZy5cblx0ICogXG5cdCAqIFNlZSB0aGUgY2xhc3MncyBkZXNjcmlwdGlvbiBmb3IgdXNhZ2UuXG5cdCAqIFxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcblx0ICogXG5cdCAqIEBjZmcge0F1dG9saW5rZXJ9IHJlcGxhY2VGbi5hdXRvbGlua2VyIFRoZSBBdXRvbGlua2VyIGluc3RhbmNlLCB3aGljaCBtYXkgYmUgdXNlZCB0byByZXRyaWV2ZSBjaGlsZCBvYmplY3RzIGZyb20gKHN1Y2hcblx0ICogICBhcyB0aGUgaW5zdGFuY2UncyB7QGxpbmsgI2dldFRhZ0J1aWxkZXIgdGFnIGJ1aWxkZXJ9KS5cblx0ICogQGNmZyB7QXV0b2xpbmtlci5tYXRjaC5NYXRjaH0gcmVwbGFjZUZuLm1hdGNoIFRoZSBNYXRjaCBpbnN0YW5jZSB3aGljaCBjYW4gYmUgdXNlZCB0byByZXRyaWV2ZSBpbmZvcm1hdGlvbiBhYm91dCB0aGVcblx0ICogICB7QGxpbmsgQXV0b2xpbmtlci5tYXRjaC5VcmwgVVJMfS97QGxpbmsgQXV0b2xpbmtlci5tYXRjaC5FbWFpbCBlbWFpbH0ve0BsaW5rIEF1dG9saW5rZXIubWF0Y2guVHdpdHRlciBUd2l0dGVyfVxuXHQgKiAgIG1hdGNoIHRoYXQgdGhlIGByZXBsYWNlRm5gIGlzIGN1cnJlbnRseSBwcm9jZXNzaW5nLlxuXHQgKi9cblx0XG5cdFxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHByb3BlcnR5IHtBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbFBhcnNlcn0gaHRtbFBhcnNlclxuXHQgKiBcblx0ICogVGhlIEh0bWxQYXJzZXIgaW5zdGFuY2UgdXNlZCB0byBza2lwIG92ZXIgSFRNTCB0YWdzLCB3aGlsZSBmaW5kaW5nIHRleHQgbm9kZXMgdG8gcHJvY2Vzcy4gVGhpcyBpcyBsYXppbHkgaW5zdGFudGlhdGVkXG5cdCAqIGluIHRoZSB7QGxpbmsgI2dldEh0bWxQYXJzZXJ9IG1ldGhvZC5cblx0ICovXG5cdGh0bWxQYXJzZXIgOiB1bmRlZmluZWQsXG5cdFxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHByb3BlcnR5IHtBdXRvbGlua2VyLm1hdGNoUGFyc2VyLk1hdGNoUGFyc2VyfSBtYXRjaFBhcnNlclxuXHQgKiBcblx0ICogVGhlIE1hdGNoUGFyc2VyIGluc3RhbmNlIHVzZWQgdG8gZmluZCBVUkwvZW1haWwvVHdpdHRlciBtYXRjaGVzIGluIHRoZSB0ZXh0IG5vZGVzIG9mIGFuIGlucHV0IHN0cmluZyBwYXNzZWQgdG9cblx0ICoge0BsaW5rICNsaW5rfS4gVGhpcyBpcyBsYXppbHkgaW5zdGFudGlhdGVkIGluIHRoZSB7QGxpbmsgI2dldE1hdGNoUGFyc2VyfSBtZXRob2QuXG5cdCAqL1xuXHRtYXRjaFBhcnNlciA6IHVuZGVmaW5lZCxcblx0XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcHJvcGVydHkge0F1dG9saW5rZXIuQW5jaG9yVGFnQnVpbGRlcn0gdGFnQnVpbGRlclxuXHQgKiBcblx0ICogVGhlIEFuY2hvclRhZ0J1aWxkZXIgaW5zdGFuY2UgdXNlZCB0byBidWlsZCB0aGUgVVJML2VtYWlsL1R3aXR0ZXIgcmVwbGFjZW1lbnQgYW5jaG9yIHRhZ3MuIFRoaXMgaXMgbGF6aWx5IGluc3RhbnRpYXRlZFxuXHQgKiBpbiB0aGUge0BsaW5rICNnZXRUYWdCdWlsZGVyfSBtZXRob2QuXG5cdCAqL1xuXHR0YWdCdWlsZGVyIDogdW5kZWZpbmVkLFxuXHRcblx0XG5cdC8qKlxuXHQgKiBBdXRvbWF0aWNhbGx5IGxpbmtzIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgaGFuZGxlcyBmb3VuZCBpbiB0aGUgZ2l2ZW4gY2h1bmsgb2YgSFRNTC4gXG5cdCAqIERvZXMgbm90IGxpbmsgVVJMcyBmb3VuZCB3aXRoaW4gSFRNTCB0YWdzLlxuXHQgKiBcblx0ICogRm9yIGluc3RhbmNlLCBpZiBnaXZlbiB0aGUgdGV4dDogYFlvdSBzaG91bGQgZ28gdG8gaHR0cDovL3d3dy55YWhvby5jb21gLCB0aGVuIHRoZSByZXN1bHRcblx0ICogd2lsbCBiZSBgWW91IHNob3VsZCBnbyB0byAmbHQ7YSBocmVmPVwiaHR0cDovL3d3dy55YWhvby5jb21cIiZndDtodHRwOi8vd3d3LnlhaG9vLmNvbSZsdDsvYSZndDtgXG5cdCAqIFxuXHQgKiBUaGlzIG1ldGhvZCBmaW5kcyB0aGUgdGV4dCBhcm91bmQgYW55IEhUTUwgZWxlbWVudHMgaW4gdGhlIGlucHV0IGB0ZXh0T3JIdG1sYCwgd2hpY2ggd2lsbCBiZSB0aGUgdGV4dCB0aGF0IGlzIHByb2Nlc3NlZC5cblx0ICogQW55IG9yaWdpbmFsIEhUTUwgZWxlbWVudHMgd2lsbCBiZSBsZWZ0IGFzLWlzLCBhcyB3ZWxsIGFzIHRoZSB0ZXh0IHRoYXQgaXMgYWxyZWFkeSB3cmFwcGVkIGluIGFuY2hvciAoJmx0O2EmZ3Q7KSB0YWdzLlxuXHQgKiBcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRPckh0bWwgVGhlIEhUTUwgb3IgdGV4dCB0byBsaW5rIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgaGFuZGxlcyB3aXRoaW4gKGRlcGVuZGluZyBvbiBpZlxuXHQgKiAgIHRoZSB7QGxpbmsgI3VybHN9LCB7QGxpbmsgI2VtYWlsfSwgYW5kIHtAbGluayAjdHdpdHRlcn0gb3B0aW9ucyBhcmUgZW5hYmxlZCkuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIEhUTUwsIHdpdGggVVJMcy9lbWFpbHMvVHdpdHRlciBoYW5kbGVzIGF1dG9tYXRpY2FsbHkgbGlua2VkLlxuXHQgKi9cblx0bGluayA6IGZ1bmN0aW9uKCB0ZXh0T3JIdG1sICkge1xuXHRcdHZhciBodG1sUGFyc2VyID0gdGhpcy5nZXRIdG1sUGFyc2VyKCksXG5cdFx0ICAgIGh0bWxOb2RlcyA9IGh0bWxQYXJzZXIucGFyc2UoIHRleHRPckh0bWwgKSxcblx0XHQgICAgYW5jaG9yVGFnU3RhY2tDb3VudCA9IDAsICAvLyB1c2VkIHRvIG9ubHkgcHJvY2VzcyB0ZXh0IGFyb3VuZCBhbmNob3IgdGFncywgYW5kIGFueSBpbm5lciB0ZXh0L2h0bWwgdGhleSBtYXkgaGF2ZVxuXHRcdCAgICByZXN1bHRIdG1sID0gW107XG5cdFx0XG5cdFx0Zm9yKCB2YXIgaSA9IDAsIGxlbiA9IGh0bWxOb2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdHZhciBub2RlID0gaHRtbE5vZGVzWyBpIF0sXG5cdFx0XHQgICAgbm9kZVR5cGUgPSBub2RlLmdldFR5cGUoKSxcblx0XHRcdCAgICBub2RlVGV4dCA9IG5vZGUuZ2V0VGV4dCgpO1xuXHRcdFx0XG5cdFx0XHRpZiggbm9kZVR5cGUgPT09ICdlbGVtZW50JyApIHtcblx0XHRcdFx0Ly8gUHJvY2VzcyBIVE1MIG5vZGVzIGluIHRoZSBpbnB1dCBgdGV4dE9ySHRtbGBcblx0XHRcdFx0aWYoIG5vZGUuZ2V0VGFnTmFtZSgpID09PSAnYScgKSB7XG5cdFx0XHRcdFx0aWYoICFub2RlLmlzQ2xvc2luZygpICkgeyAgLy8gaXQncyB0aGUgc3RhcnQgPGE+IHRhZ1xuXHRcdFx0XHRcdFx0YW5jaG9yVGFnU3RhY2tDb3VudCsrO1xuXHRcdFx0XHRcdH0gZWxzZSB7ICAgLy8gaXQncyB0aGUgZW5kIDwvYT4gdGFnXG5cdFx0XHRcdFx0XHRhbmNob3JUYWdTdGFja0NvdW50ID0gTWF0aC5tYXgoIGFuY2hvclRhZ1N0YWNrQ291bnQgLSAxLCAwICk7ICAvLyBhdHRlbXB0IHRvIGhhbmRsZSBleHRyYW5lb3VzIDwvYT4gdGFncyBieSBtYWtpbmcgc3VyZSB0aGUgc3RhY2sgY291bnQgbmV2ZXIgZ29lcyBiZWxvdyAwXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdEh0bWwucHVzaCggbm9kZVRleHQgKTsgIC8vIG5vdyBhZGQgdGhlIHRleHQgb2YgdGhlIHRhZyBpdHNlbGYgdmVyYmF0aW1cblx0XHRcdFx0XG5cdFx0XHR9IGVsc2UgaWYoIG5vZGVUeXBlID09PSAnZW50aXR5JyApIHtcblx0XHRcdFx0cmVzdWx0SHRtbC5wdXNoKCBub2RlVGV4dCApOyAgLy8gYXBwZW5kIEhUTUwgZW50aXR5IG5vZGVzIChzdWNoIGFzICcmbmJzcDsnKSB2ZXJiYXRpbVxuXHRcdFx0XHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFByb2Nlc3MgdGV4dCBub2RlcyBpbiB0aGUgaW5wdXQgYHRleHRPckh0bWxgXG5cdFx0XHRcdGlmKCBhbmNob3JUYWdTdGFja0NvdW50ID09PSAwICkge1xuXHRcdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCB3aXRoaW4gYW4gPGE+IHRhZywgcHJvY2VzcyB0aGUgdGV4dCBub2RlIHRvIGxpbmtpZnlcblx0XHRcdFx0XHR2YXIgbGlua2lmaWVkU3RyID0gdGhpcy5saW5raWZ5U3RyKCBub2RlVGV4dCApO1xuXHRcdFx0XHRcdHJlc3VsdEh0bWwucHVzaCggbGlua2lmaWVkU3RyICk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gYHRleHRgIGlzIHdpdGhpbiBhbiA8YT4gdGFnLCBzaW1wbHkgYXBwZW5kIHRoZSB0ZXh0IC0gd2UgZG8gbm90IHdhbnQgdG8gYXV0b2xpbmsgYW55dGhpbmcgXG5cdFx0XHRcdFx0Ly8gYWxyZWFkeSB3aXRoaW4gYW4gPGE+Li4uPC9hPiB0YWdcblx0XHRcdFx0XHRyZXN1bHRIdG1sLnB1c2goIG5vZGVUZXh0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHJlc3VsdEh0bWwuam9pbiggXCJcIiApO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBQcm9jZXNzIHRoZSB0ZXh0IHRoYXQgbGllcyBpbiBiZXR3ZWVuIEhUTUwgdGFncywgcGVyZm9ybWluZyB0aGUgYW5jaG9yIHRhZyByZXBsYWNlbWVudHMgZm9yIG1hdGNoZWQgXG5cdCAqIFVSTHMvZW1haWxzL1R3aXR0ZXIgaGFuZGxlcywgYW5kIHJldHVybnMgdGhlIHN0cmluZyB3aXRoIHRoZSByZXBsYWNlbWVudHMgbWFkZS4gXG5cdCAqIFxuXHQgKiBUaGlzIG1ldGhvZCBkb2VzIHRoZSBhY3R1YWwgd3JhcHBpbmcgb2YgVVJMcy9lbWFpbHMvVHdpdHRlciBoYW5kbGVzIHdpdGggYW5jaG9yIHRhZ3MuXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgb2YgdGV4dCB0byBhdXRvLWxpbmsuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHRleHQgd2l0aCBhbmNob3IgdGFncyBhdXRvLWZpbGxlZC5cblx0ICovXG5cdGxpbmtpZnlTdHIgOiBmdW5jdGlvbiggc3RyICkge1xuXHRcdHJldHVybiB0aGlzLmdldE1hdGNoUGFyc2VyKCkucmVwbGFjZSggc3RyLCB0aGlzLmNyZWF0ZU1hdGNoUmV0dXJuVmFsLCB0aGlzICk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZXMgdGhlIHJldHVybiBzdHJpbmcgdmFsdWUgZm9yIGEgZ2l2ZW4gbWF0Y2ggaW4gdGhlIGlucHV0IHN0cmluZywgZm9yIHRoZSB7QGxpbmsgI3Byb2Nlc3NUZXh0Tm9kZX0gbWV0aG9kLlxuXHQgKiBcblx0ICogVGhpcyBtZXRob2QgaGFuZGxlcyB0aGUge0BsaW5rICNyZXBsYWNlRm59LCBpZiBvbmUgd2FzIHByb3ZpZGVkLlxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBdXRvbGlua2VyLm1hdGNoLk1hdGNofSBtYXRjaCBUaGUgTWF0Y2ggb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgbWF0Y2guXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHN0cmluZyB0aGF0IHRoZSBgbWF0Y2hgIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoLiBUaGlzIGlzIHVzdWFsbHkgdGhlIGFuY2hvciB0YWcgc3RyaW5nLCBidXRcblx0ICogICBtYXkgYmUgdGhlIGBtYXRjaFN0cmAgaXRzZWxmIGlmIHRoZSBtYXRjaCBpcyBub3QgdG8gYmUgcmVwbGFjZWQuXG5cdCAqL1xuXHRjcmVhdGVNYXRjaFJldHVyblZhbCA6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHQvLyBIYW5kbGUgYSBjdXN0b20gYHJlcGxhY2VGbmAgYmVpbmcgcHJvdmlkZWRcblx0XHR2YXIgcmVwbGFjZUZuUmVzdWx0O1xuXHRcdGlmKCB0aGlzLnJlcGxhY2VGbiApIHtcblx0XHRcdHJlcGxhY2VGblJlc3VsdCA9IHRoaXMucmVwbGFjZUZuLmNhbGwoIHRoaXMsIHRoaXMsIG1hdGNoICk7ICAvLyBBdXRvbGlua2VyIGluc3RhbmNlIGlzIHRoZSBjb250ZXh0LCBhbmQgdGhlIGZpcnN0IGFyZ1xuXHRcdH1cblx0XHRcblx0XHRpZiggdHlwZW9mIHJlcGxhY2VGblJlc3VsdCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRyZXR1cm4gcmVwbGFjZUZuUmVzdWx0OyAgLy8gYHJlcGxhY2VGbmAgcmV0dXJuZWQgYSBzdHJpbmcsIHVzZSB0aGF0XG5cdFx0XHRcblx0XHR9IGVsc2UgaWYoIHJlcGxhY2VGblJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm4gbWF0Y2guZ2V0TWF0Y2hlZFRleHQoKTsgIC8vIG5vIHJlcGxhY2VtZW50IGZvciB0aGUgbWF0Y2hcblx0XHRcdFxuXHRcdH0gZWxzZSBpZiggcmVwbGFjZUZuUmVzdWx0IGluc3RhbmNlb2YgQXV0b2xpbmtlci5IdG1sVGFnICkge1xuXHRcdFx0cmV0dXJuIHJlcGxhY2VGblJlc3VsdC50b1N0cmluZygpO1xuXHRcdFxuXHRcdH0gZWxzZSB7ICAvLyByZXBsYWNlRm5SZXN1bHQgPT09IHRydWUsIG9yIG5vL3Vua25vd24gcmV0dXJuIHZhbHVlIGZyb20gZnVuY3Rpb25cblx0XHRcdC8vIFBlcmZvcm0gQXV0b2xpbmtlcidzIGRlZmF1bHQgYW5jaG9yIHRhZyBnZW5lcmF0aW9uXG5cdFx0XHR2YXIgdGFnQnVpbGRlciA9IHRoaXMuZ2V0VGFnQnVpbGRlcigpLFxuXHRcdFx0ICAgIGFuY2hvclRhZyA9IHRhZ0J1aWxkZXIuYnVpbGQoIG1hdGNoICk7ICAvLyByZXR1cm5zIGFuIEF1dG9saW5rZXIuSHRtbFRhZyBpbnN0YW5jZVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gYW5jaG9yVGFnLnRvU3RyaW5nKCk7XG5cdFx0fVxuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBMYXppbHkgaW5zdGFudGlhdGVzIGFuZCByZXR1cm5zIHRoZSB7QGxpbmsgI2h0bWxQYXJzZXJ9IGluc3RhbmNlIGZvciB0aGlzIEF1dG9saW5rZXIgaW5zdGFuY2UuXG5cdCAqIFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sUGFyc2VyfVxuXHQgKi9cblx0Z2V0SHRtbFBhcnNlciA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBodG1sUGFyc2VyID0gdGhpcy5odG1sUGFyc2VyO1xuXHRcdFxuXHRcdGlmKCAhaHRtbFBhcnNlciApIHtcblx0XHRcdGh0bWxQYXJzZXIgPSB0aGlzLmh0bWxQYXJzZXIgPSBuZXcgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxQYXJzZXIoKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGh0bWxQYXJzZXI7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIExhemlseSBpbnN0YW50aWF0ZXMgYW5kIHJldHVybnMgdGhlIHtAbGluayAjbWF0Y2hQYXJzZXJ9IGluc3RhbmNlIGZvciB0aGlzIEF1dG9saW5rZXIgaW5zdGFuY2UuXG5cdCAqIFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIubWF0Y2hQYXJzZXIuTWF0Y2hQYXJzZXJ9XG5cdCAqL1xuXHRnZXRNYXRjaFBhcnNlciA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXRjaFBhcnNlciA9IHRoaXMubWF0Y2hQYXJzZXI7XG5cdFx0XG5cdFx0aWYoICFtYXRjaFBhcnNlciApIHtcblx0XHRcdG1hdGNoUGFyc2VyID0gdGhpcy5tYXRjaFBhcnNlciA9IG5ldyBBdXRvbGlua2VyLm1hdGNoUGFyc2VyLk1hdGNoUGFyc2VyKCB7XG5cdFx0XHRcdHVybHMgOiB0aGlzLnVybHMsXG5cdFx0XHRcdGVtYWlsIDogdGhpcy5lbWFpbCxcblx0XHRcdFx0dHdpdHRlciA6IHRoaXMudHdpdHRlcixcblx0XHRcdFx0c3RyaXBQcmVmaXggOiB0aGlzLnN0cmlwUHJlZml4XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBtYXRjaFBhcnNlcjtcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUge0BsaW5rICN0YWdCdWlsZGVyfSBpbnN0YW5jZSBmb3IgdGhpcyBBdXRvbGlua2VyIGluc3RhbmNlLCBsYXppbHkgaW5zdGFudGlhdGluZyBpdFxuXHQgKiBpZiBpdCBkb2VzIG5vdCB5ZXQgZXhpc3QuXG5cdCAqIFxuXHQgKiBUaGlzIG1ldGhvZCBtYXkgYmUgdXNlZCBpbiBhIHtAbGluayAjcmVwbGFjZUZufSB0byBnZW5lcmF0ZSB0aGUge0BsaW5rIEF1dG9saW5rZXIuSHRtbFRhZyBIdG1sVGFnfSBpbnN0YW5jZSB0aGF0IFxuXHQgKiBBdXRvbGlua2VyIHdvdWxkIG5vcm1hbGx5IGdlbmVyYXRlLCBhbmQgdGhlbiBhbGxvdyBmb3IgbW9kaWZpY2F0aW9ucyBiZWZvcmUgcmV0dXJuaW5nIGl0LiBGb3IgZXhhbXBsZTpcblx0ICogXG5cdCAqICAgICB2YXIgaHRtbCA9IEF1dG9saW5rZXIubGluayggXCJUZXN0IGdvb2dsZS5jb21cIiwge1xuXHQgKiAgICAgICAgIHJlcGxhY2VGbiA6IGZ1bmN0aW9uKCBhdXRvbGlua2VyLCBtYXRjaCApIHtcblx0ICogICAgICAgICAgICAgdmFyIHRhZyA9IGF1dG9saW5rZXIuZ2V0VGFnQnVpbGRlcigpLmJ1aWxkKCBtYXRjaCApOyAgLy8gcmV0dXJucyBhbiB7QGxpbmsgQXV0b2xpbmtlci5IdG1sVGFnfSBpbnN0YW5jZVxuXHQgKiAgICAgICAgICAgICB0YWcuc2V0QXR0ciggJ3JlbCcsICdub2ZvbGxvdycgKTtcblx0ICogICAgICAgICAgICAgXG5cdCAqICAgICAgICAgICAgIHJldHVybiB0YWc7XG5cdCAqICAgICAgICAgfVxuXHQgKiAgICAgfSApO1xuXHQgKiAgICAgXG5cdCAqICAgICAvLyBnZW5lcmF0ZWQgaHRtbDpcblx0ICogICAgIC8vICAgVGVzdCA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub2ZvbGxvd1wiPmdvb2dsZS5jb208L2E+XG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkFuY2hvclRhZ0J1aWxkZXJ9XG5cdCAqL1xuXHRnZXRUYWdCdWlsZGVyIDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRhZ0J1aWxkZXIgPSB0aGlzLnRhZ0J1aWxkZXI7XG5cdFx0XG5cdFx0aWYoICF0YWdCdWlsZGVyICkge1xuXHRcdFx0dGFnQnVpbGRlciA9IHRoaXMudGFnQnVpbGRlciA9IG5ldyBBdXRvbGlua2VyLkFuY2hvclRhZ0J1aWxkZXIoIHtcblx0XHRcdFx0bmV3V2luZG93ICAgOiB0aGlzLm5ld1dpbmRvdyxcblx0XHRcdFx0dHJ1bmNhdGUgICAgOiB0aGlzLnRydW5jYXRlLFxuXHRcdFx0XHRjbGFzc05hbWUgICA6IHRoaXMuY2xhc3NOYW1lXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0YWdCdWlsZGVyO1xuXHR9XG5cbn07XG5cblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IGxpbmtzIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgaGFuZGxlcyBmb3VuZCBpbiB0aGUgZ2l2ZW4gY2h1bmsgb2YgSFRNTC4gXG4gKiBEb2VzIG5vdCBsaW5rIFVSTHMgZm91bmQgd2l0aGluIEhUTUwgdGFncy5cbiAqIFxuICogRm9yIGluc3RhbmNlLCBpZiBnaXZlbiB0aGUgdGV4dDogYFlvdSBzaG91bGQgZ28gdG8gaHR0cDovL3d3dy55YWhvby5jb21gLCB0aGVuIHRoZSByZXN1bHRcbiAqIHdpbGwgYmUgYFlvdSBzaG91bGQgZ28gdG8gJmx0O2EgaHJlZj1cImh0dHA6Ly93d3cueWFob28uY29tXCImZ3Q7aHR0cDovL3d3dy55YWhvby5jb20mbHQ7L2EmZ3Q7YFxuICogXG4gKiBFeGFtcGxlOlxuICogXG4gKiAgICAgdmFyIGxpbmtlZFRleHQgPSBBdXRvbGlua2VyLmxpbmsoIFwiR28gdG8gZ29vZ2xlLmNvbVwiLCB7IG5ld1dpbmRvdzogZmFsc2UgfSApO1xuICogICAgIC8vIFByb2R1Y2VzOiBcIkdvIHRvIDxhIGhyZWY9XCJodHRwOi8vZ29vZ2xlLmNvbVwiPmdvb2dsZS5jb208L2E+XCJcbiAqIFxuICogQHN0YXRpY1xuICogQHBhcmFtIHtTdHJpbmd9IHRleHRPckh0bWwgVGhlIEhUTUwgb3IgdGV4dCB0byBmaW5kIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgaGFuZGxlcyB3aXRoaW4gKGRlcGVuZGluZyBvbiBpZlxuICogICB0aGUge0BsaW5rICN1cmxzfSwge0BsaW5rICNlbWFpbH0sIGFuZCB7QGxpbmsgI3R3aXR0ZXJ9IG9wdGlvbnMgYXJlIGVuYWJsZWQpLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbnkgb2YgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIEF1dG9saW5rZXIgY2xhc3MsIHNwZWNpZmllZCBpbiBhbiBPYmplY3QgKG1hcCkuXG4gKiAgIFNlZSB0aGUgY2xhc3MgZGVzY3JpcHRpb24gZm9yIGFuIGV4YW1wbGUgY2FsbC5cbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIEhUTUwgdGV4dCwgd2l0aCBVUkxzIGF1dG9tYXRpY2FsbHkgbGlua2VkXG4gKi9cbkF1dG9saW5rZXIubGluayA9IGZ1bmN0aW9uKCB0ZXh0T3JIdG1sLCBvcHRpb25zICkge1xuXHR2YXIgYXV0b2xpbmtlciA9IG5ldyBBdXRvbGlua2VyKCBvcHRpb25zICk7XG5cdHJldHVybiBhdXRvbGlua2VyLmxpbmsoIHRleHRPckh0bWwgKTtcbn07XG5cblxuLy8gQXV0b2xpbmtlciBOYW1lc3BhY2VzXG5BdXRvbGlua2VyLm1hdGNoID0ge307XG5BdXRvbGlua2VyLmh0bWxQYXJzZXIgPSB7fTtcbkF1dG9saW5rZXIubWF0Y2hQYXJzZXIgPSB7fTtcbi8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cbi8qanNoaW50IGVxbnVsbDp0cnVlLCBib3NzOnRydWUgKi9cbi8qKlxuICogQGNsYXNzIEF1dG9saW5rZXIuVXRpbFxuICogQHNpbmdsZXRvblxuICogXG4gKiBBIGZldyB1dGlsaXR5IG1ldGhvZHMgZm9yIEF1dG9saW5rZXIuXG4gKi9cbkF1dG9saW5rZXIuVXRpbCA9IHtcblx0XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBhYnN0cmFjdE1ldGhvZFxuXHQgKiBcblx0ICogQSBmdW5jdGlvbiBvYmplY3Qgd2hpY2ggcmVwcmVzZW50cyBhbiBhYnN0cmFjdCBtZXRob2QuXG5cdCAqL1xuXHRhYnN0cmFjdE1ldGhvZCA6IGZ1bmN0aW9uKCkgeyB0aHJvdyBcImFic3RyYWN0XCI7IH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIEFzc2lnbnMgKHNoYWxsb3cgY29waWVzKSB0aGUgcHJvcGVydGllcyBvZiBgc3JjYCBvbnRvIGBkZXN0YC5cblx0ICogXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgVGhlIHNvdXJjZSBvYmplY3QuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlc3RpbmF0aW9uIG9iamVjdCAoYGRlc3RgKVxuXHQgKi9cblx0YXNzaWduIDogZnVuY3Rpb24oIGRlc3QsIHNyYyApIHtcblx0XHRmb3IoIHZhciBwcm9wIGluIHNyYyApIHtcblx0XHRcdGlmKCBzcmMuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcblx0XHRcdFx0ZGVzdFsgcHJvcCBdID0gc3JjWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBkZXN0O1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBFeHRlbmRzIGBzdXBlcmNsYXNzYCB0byBjcmVhdGUgYSBuZXcgc3ViY2xhc3MsIGFkZGluZyB0aGUgYHByb3RvUHJvcHNgIHRvIHRoZSBuZXcgc3ViY2xhc3MncyBwcm90b3R5cGUuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdXBlcmNsYXNzIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIHN1cGVyY2xhc3MuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1Byb3BzIFRoZSBtZXRob2RzL3Byb3BlcnRpZXMgdG8gYWRkIHRvIHRoZSBzdWJjbGFzcydzIHByb3RvdHlwZS4gVGhpcyBtYXkgY29udGFpbiB0aGVcblx0ICogICBzcGVjaWFsIHByb3BlcnR5IGBjb25zdHJ1Y3RvcmAsIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyB0aGUgbmV3IHN1YmNsYXNzJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgbmV3IHN1YmNsYXNzIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZXh0ZW5kIDogZnVuY3Rpb24oIHN1cGVyY2xhc3MsIHByb3RvUHJvcHMgKSB7XG5cdFx0dmFyIHN1cGVyY2xhc3NQcm90byA9IHN1cGVyY2xhc3MucHJvdG90eXBlO1xuXHRcdFxuXHRcdHZhciBGID0gZnVuY3Rpb24oKSB7fTtcblx0XHRGLnByb3RvdHlwZSA9IHN1cGVyY2xhc3NQcm90bztcblx0XHRcblx0XHR2YXIgc3ViY2xhc3M7XG5cdFx0aWYoIHByb3RvUHJvcHMuaGFzT3duUHJvcGVydHkoICdjb25zdHJ1Y3RvcicgKSApIHtcblx0XHRcdHN1YmNsYXNzID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3Rvcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3ViY2xhc3MgPSBmdW5jdGlvbigpIHsgc3VwZXJjbGFzc1Byb3RvLmNvbnN0cnVjdG9yLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTsgfTtcblx0XHR9XG5cdFx0XG5cdFx0dmFyIHN1YmNsYXNzUHJvdG8gPSBzdWJjbGFzcy5wcm90b3R5cGUgPSBuZXcgRigpOyAgLy8gc2V0IHVwIHByb3RvdHlwZSBjaGFpblxuXHRcdHN1YmNsYXNzUHJvdG8uY29uc3RydWN0b3IgPSBzdWJjbGFzczsgIC8vIGZpeCBjb25zdHJ1Y3RvciBwcm9wZXJ0eVxuXHRcdHN1YmNsYXNzUHJvdG8uc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3NQcm90bztcblx0XHRcblx0XHRkZWxldGUgcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjsgIC8vIGRvbid0IHJlLWFzc2lnbiBjb25zdHJ1Y3RvciBwcm9wZXJ0eSB0byB0aGUgcHJvdG90eXBlLCBzaW5jZSBhIG5ldyBmdW5jdGlvbiBtYXkgaGF2ZSBiZWVuIGNyZWF0ZWQgKGBzdWJjbGFzc2ApLCB3aGljaCBpcyBub3cgYWxyZWFkeSB0aGVyZVxuXHRcdEF1dG9saW5rZXIuVXRpbC5hc3NpZ24oIHN1YmNsYXNzUHJvdG8sIHByb3RvUHJvcHMgKTtcblx0XHRcblx0XHRyZXR1cm4gc3ViY2xhc3M7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFRydW5jYXRlcyB0aGUgYHN0cmAgYXQgYGxlbiAtIGVsbGlwc2lzQ2hhcnMubGVuZ3RoYCwgYW5kIGFkZHMgdGhlIGBlbGxpcHNpc0NoYXJzYCB0byB0aGVcblx0ICogZW5kIG9mIHRoZSBzdHJpbmcgKGJ5IGRlZmF1bHQsIHR3byBwZXJpb2RzOiAnLi4nKS4gSWYgdGhlIGBzdHJgIGxlbmd0aCBkb2VzIG5vdCBleGNlZWQgXG5cdCAqIGBsZW5gLCB0aGUgc3RyaW5nIHdpbGwgYmUgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuXHQgKiBcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHRydW5jYXRlIGFuZCBhZGQgYW4gZWxsaXBzaXMgdG8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0cnVuY2F0ZUxlbiBUaGUgbGVuZ3RoIHRvIHRydW5jYXRlIHRoZSBzdHJpbmcgYXQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbZWxsaXBzaXNDaGFycz0uLl0gVGhlIGVsbGlwc2lzIGNoYXJhY3RlcihzKSB0byBhZGQgdG8gdGhlIGVuZCBvZiBgc3RyYFxuXHQgKiAgIHdoZW4gdHJ1bmNhdGVkLiBEZWZhdWx0cyB0byAnLi4nXG5cdCAqL1xuXHRlbGxpcHNpcyA6IGZ1bmN0aW9uKCBzdHIsIHRydW5jYXRlTGVuLCBlbGxpcHNpc0NoYXJzICkge1xuXHRcdGlmKCBzdHIubGVuZ3RoID4gdHJ1bmNhdGVMZW4gKSB7XG5cdFx0XHRlbGxpcHNpc0NoYXJzID0gKCBlbGxpcHNpc0NoYXJzID09IG51bGwgKSA/ICcuLicgOiBlbGxpcHNpc0NoYXJzO1xuXHRcdFx0c3RyID0gc3RyLnN1YnN0cmluZyggMCwgdHJ1bmNhdGVMZW4gLSBlbGxpcHNpc0NoYXJzLmxlbmd0aCApICsgZWxsaXBzaXNDaGFycztcblx0XHR9XG5cdFx0cmV0dXJuIHN0cjtcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogU3VwcG9ydHMgYEFycmF5LnByb3RvdHlwZS5pbmRleE9mKClgIGZ1bmN0aW9uYWxpdHkgZm9yIG9sZCBJRSAoSUU4IGFuZCBiZWxvdykuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnIgVGhlIGFycmF5IHRvIGZpbmQgYW4gZWxlbWVudCBvZi5cblx0ICogQHBhcmFtIHsqfSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGZpbmQgaW4gdGhlIGFycmF5LCBhbmQgcmV0dXJuIHRoZSBpbmRleCBvZi5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGBlbGVtZW50YCwgb3IgLTEgaWYgaXQgd2FzIG5vdCBmb3VuZC5cblx0ICovXG5cdGluZGV4T2YgOiBmdW5jdGlvbiggYXJyLCBlbGVtZW50ICkge1xuXHRcdGlmKCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiApIHtcblx0XHRcdHJldHVybiBhcnIuaW5kZXhPZiggZWxlbWVudCApO1xuXHRcdFx0XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciggdmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGlmKCBhcnJbIGkgXSA9PT0gZWxlbWVudCApIHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH1cblx0fSxcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIFBlcmZvcm1zIHRoZSBmdW5jdGlvbmFsaXR5IG9mIHdoYXQgbW9kZXJuIGJyb3dzZXJzIGRvIHdoZW4gYFN0cmluZy5wcm90b3R5cGUuc3BsaXQoKWAgaXMgY2FsbGVkXG5cdCAqIHdpdGggYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBjb250YWlucyBjYXB0dXJpbmcgcGFyZW50aGVzaXMuXG5cdCAqIFxuXHQgKiBGb3IgZXhhbXBsZTpcblx0ICogXG5cdCAqICAgICAvLyBNb2Rlcm4gYnJvd3NlcnM6IFxuXHQgKiAgICAgXCJhLGIsY1wiLnNwbGl0KCAvKCwpLyApOyAgLy8gLS0+IFsgJ2EnLCAnLCcsICdiJywgJywnLCAnYycgXVxuXHQgKiAgICAgXG5cdCAqICAgICAvLyBPbGQgSUUgKGluY2x1ZGluZyBJRTgpOlxuXHQgKiAgICAgXCJhLGIsY1wiLnNwbGl0KCAvKCwpLyApOyAgLy8gLS0+IFsgJ2EnLCAnYicsICdjJyBdXG5cdCAqICAgICBcblx0ICogVGhpcyBtZXRob2QgZW11bGF0ZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgbW9kZXJuIGJyb3dzZXJzIGZvciB0aGUgb2xkIElFIGNhc2UuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gc3BsaXQuXG5cdCAqIEBwYXJhbSB7UmVnRXhwfSBzcGxpdFJlZ2V4IFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gc3BsaXQgdGhlIGlucHV0IGBzdHJgIG9uLiBUaGUgc3BsaXR0aW5nXG5cdCAqICAgY2hhcmFjdGVyKHMpIHdpbGwgYmUgc3BsaWNlZCBpbnRvIHRoZSBhcnJheSwgYXMgaW4gdGhlIFwibW9kZXJuIGJyb3dzZXJzXCIgZXhhbXBsZSBpbiB0aGUgXG5cdCAqICAgZGVzY3JpcHRpb24gb2YgdGhpcyBtZXRob2QuIFxuXHQgKiAgIE5vdGUgIzE6IHRoZSBzdXBwbGllZCByZWd1bGFyIGV4cHJlc3Npb24gKiptdXN0KiogaGF2ZSB0aGUgJ2cnIGZsYWcgc3BlY2lmaWVkLlxuXHQgKiAgIE5vdGUgIzI6IGZvciBzaW1wbGljaXR5J3Mgc2FrZSwgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBkb2VzIG5vdCBuZWVkIFxuXHQgKiAgIHRvIGNvbnRhaW4gY2FwdHVyaW5nIHBhcmVudGhlc2lzIC0gaXQgd2lsbCBiZSBhc3N1bWVkIHRoYXQgYW55IG1hdGNoIGhhcyB0aGVtLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmdbXX0gVGhlIHNwbGl0IGFycmF5IG9mIHN0cmluZ3MsIHdpdGggdGhlIHNwbGl0dGluZyBjaGFyYWN0ZXIocykgaW5jbHVkZWQuXG5cdCAqL1xuXHRzcGxpdEFuZENhcHR1cmUgOiBmdW5jdGlvbiggc3RyLCBzcGxpdFJlZ2V4ICkge1xuXHRcdGlmKCAhc3BsaXRSZWdleC5nbG9iYWwgKSB0aHJvdyBuZXcgRXJyb3IoIFwiYHNwbGl0UmVnZXhgIG11c3QgaGF2ZSB0aGUgJ2cnIGZsYWcgc2V0XCIgKTtcblx0XHRcblx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0ICAgIGxhc3RJZHggPSAwLFxuXHRcdCAgICBtYXRjaDtcblx0XHRcblx0XHR3aGlsZSggbWF0Y2ggPSBzcGxpdFJlZ2V4LmV4ZWMoIHN0ciApICkge1xuXHRcdFx0cmVzdWx0LnB1c2goIHN0ci5zdWJzdHJpbmcoIGxhc3RJZHgsIG1hdGNoLmluZGV4ICkgKTtcblx0XHRcdHJlc3VsdC5wdXNoKCBtYXRjaFsgMCBdICk7ICAvLyBwdXNoIHRoZSBzcGxpdHRpbmcgY2hhcihzKVxuXHRcdFx0XG5cdFx0XHRsYXN0SWR4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFsgMCBdLmxlbmd0aDtcblx0XHR9XG5cdFx0cmVzdWx0LnB1c2goIHN0ci5zdWJzdHJpbmcoIGxhc3RJZHggKSApO1xuXHRcdFxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblx0XG59O1xuLypnbG9iYWwgQXV0b2xpbmtlciAqL1xuLypqc2hpbnQgYm9zczp0cnVlICovXG4vKipcbiAqIEBjbGFzcyBBdXRvbGlua2VyLkh0bWxUYWdcbiAqIEBleHRlbmRzIE9iamVjdFxuICogXG4gKiBSZXByZXNlbnRzIGFuIEhUTUwgdGFnLCB3aGljaCBjYW4gYmUgdXNlZCB0byBlYXNpbHkgYnVpbGQvbW9kaWZ5IEhUTUwgdGFncyBwcm9ncmFtbWF0aWNhbGx5LlxuICogXG4gKiBBdXRvbGlua2VyIHVzZXMgdGhpcyBhYnN0cmFjdGlvbiB0byBjcmVhdGUgSFRNTCB0YWdzLCBhbmQgdGhlbiB3cml0ZSB0aGVtIG91dCBhcyBzdHJpbmdzLiBZb3UgbWF5IGFsc28gdXNlXG4gKiB0aGlzIGNsYXNzIGluIHlvdXIgY29kZSwgZXNwZWNpYWxseSB3aXRoaW4gYSB7QGxpbmsgQXV0b2xpbmtlciNyZXBsYWNlRm4gcmVwbGFjZUZufS5cbiAqIFxuICogIyMgRXhhbXBsZXNcbiAqIFxuICogRXhhbXBsZSBpbnN0YW50aWF0aW9uOlxuICogXG4gKiAgICAgdmFyIHRhZyA9IG5ldyBBdXRvbGlua2VyLkh0bWxUYWcoIHtcbiAqICAgICAgICAgdGFnTmFtZSA6ICdhJyxcbiAqICAgICAgICAgYXR0cnMgICA6IHsgJ2hyZWYnOiAnaHR0cDovL2dvb2dsZS5jb20nLCAnY2xhc3MnOiAnZXh0ZXJuYWwtbGluaycgfSxcbiAqICAgICAgICAgaW5uZXJIdG1sIDogJ0dvb2dsZSdcbiAqICAgICB9ICk7XG4gKiAgICAgXG4gKiAgICAgdGFnLnRvU3RyaW5nKCk7ICAvLyA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIiBjbGFzcz1cImV4dGVybmFsLWxpbmtcIj5Hb29nbGU8L2E+XG4gKiAgICAgXG4gKiAgICAgLy8gSW5kaXZpZHVhbCBhY2Nlc3NvciBtZXRob2RzXG4gKiAgICAgdGFnLmdldFRhZ05hbWUoKTsgICAgICAgICAgICAgICAgIC8vICdhJ1xuICogICAgIHRhZy5nZXRBdHRyKCAnaHJlZicgKTsgICAgICAgICAgICAvLyAnaHR0cDovL2dvb2dsZS5jb20nXG4gKiAgICAgdGFnLmhhc0NsYXNzKCAnZXh0ZXJuYWwtbGluaycgKTsgIC8vIHRydWVcbiAqIFxuICogXG4gKiBVc2luZyBtdXRhdG9yIG1ldGhvZHMgKHdoaWNoIG1heSBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggaW5zdGFudGlhdGlvbiBjb25maWcgcHJvcGVydGllcyk6XG4gKiBcbiAqICAgICB2YXIgdGFnID0gbmV3IEF1dG9saW5rZXIuSHRtbFRhZygpO1xuICogICAgIHRhZy5zZXRUYWdOYW1lKCAnYScgKTtcbiAqICAgICB0YWcuc2V0QXR0ciggJ2hyZWYnLCAnaHR0cDovL2dvb2dsZS5jb20nICk7XG4gKiAgICAgdGFnLmFkZENsYXNzKCAnZXh0ZXJuYWwtbGluaycgKTtcbiAqICAgICB0YWcuc2V0SW5uZXJIdG1sKCAnR29vZ2xlJyApO1xuICogICAgIFxuICogICAgIHRhZy5nZXRUYWdOYW1lKCk7ICAgICAgICAgICAgICAgICAvLyAnYSdcbiAqICAgICB0YWcuZ2V0QXR0ciggJ2hyZWYnICk7ICAgICAgICAgICAgLy8gJ2h0dHA6Ly9nb29nbGUuY29tJ1xuICogICAgIHRhZy5oYXNDbGFzcyggJ2V4dGVybmFsLWxpbmsnICk7ICAvLyB0cnVlXG4gKiAgICAgXG4gKiAgICAgdGFnLnRvU3RyaW5nKCk7ICAvLyA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIiBjbGFzcz1cImV4dGVybmFsLWxpbmtcIj5Hb29nbGU8L2E+XG4gKiAgICAgXG4gKiBcbiAqICMjIEV4YW1wbGUgdXNlIHdpdGhpbiBhIHtAbGluayBBdXRvbGlua2VyI3JlcGxhY2VGbiByZXBsYWNlRm59XG4gKiBcbiAqICAgICB2YXIgaHRtbCA9IEF1dG9saW5rZXIubGluayggXCJUZXN0IGdvb2dsZS5jb21cIiwge1xuICogICAgICAgICByZXBsYWNlRm4gOiBmdW5jdGlvbiggYXV0b2xpbmtlciwgbWF0Y2ggKSB7XG4gKiAgICAgICAgICAgICB2YXIgdGFnID0gYXV0b2xpbmtlci5nZXRUYWdCdWlsZGVyKCkuYnVpbGQoIG1hdGNoICk7ICAvLyByZXR1cm5zIGFuIHtAbGluayBBdXRvbGlua2VyLkh0bWxUYWd9IGluc3RhbmNlLCBjb25maWd1cmVkIHdpdGggdGhlIE1hdGNoJ3MgaHJlZiBhbmQgYW5jaG9yIHRleHRcbiAqICAgICAgICAgICAgIHRhZy5zZXRBdHRyKCAncmVsJywgJ25vZm9sbG93JyApO1xuICogICAgICAgICAgICAgXG4gKiAgICAgICAgICAgICByZXR1cm4gdGFnO1xuICogICAgICAgICB9XG4gKiAgICAgfSApO1xuICogICAgIFxuICogICAgIC8vIGdlbmVyYXRlZCBodG1sOlxuICogICAgIC8vICAgVGVzdCA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub2ZvbGxvd1wiPmdvb2dsZS5jb208L2E+XG4gKiAgICAgXG4gKiAgICAgXG4gKiAjIyBFeGFtcGxlIHVzZSB3aXRoIGEgbmV3IHRhZyBmb3IgdGhlIHJlcGxhY2VtZW50XG4gKiBcbiAqICAgICB2YXIgaHRtbCA9IEF1dG9saW5rZXIubGluayggXCJUZXN0IGdvb2dsZS5jb21cIiwge1xuICogICAgICAgICByZXBsYWNlRm4gOiBmdW5jdGlvbiggYXV0b2xpbmtlciwgbWF0Y2ggKSB7XG4gKiAgICAgICAgICAgICB2YXIgdGFnID0gbmV3IEF1dG9saW5rZXIuSHRtbFRhZygge1xuICogICAgICAgICAgICAgICAgIHRhZ05hbWUgOiAnYnV0dG9uJyxcbiAqICAgICAgICAgICAgICAgICBhdHRycyAgIDogeyAndGl0bGUnOiAnTG9hZCBVUkw6ICcgKyBtYXRjaC5nZXRBbmNob3JIcmVmKCkgfSxcbiAqICAgICAgICAgICAgICAgICBpbm5lckh0bWwgOiAnTG9hZCBVUkw6ICcgKyBtYXRjaC5nZXRBbmNob3JUZXh0KClcbiAqICAgICAgICAgICAgIH0gKTtcbiAqICAgICAgICAgICAgIFxuICogICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAqICAgICAgICAgfVxuICogICAgIH0gKTtcbiAqICAgICBcbiAqICAgICAvLyBnZW5lcmF0ZWQgaHRtbDpcbiAqICAgICAvLyAgIFRlc3QgPGJ1dHRvbiB0aXRsZT1cIkxvYWQgVVJMOiBodHRwOi8vZ29vZ2xlLmNvbVwiPkxvYWQgVVJMOiBnb29nbGUuY29tPC9idXR0b24+XG4gKi9cbkF1dG9saW5rZXIuSHRtbFRhZyA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge1N0cmluZ30gdGFnTmFtZVxuXHQgKiBcblx0ICogVGhlIHRhZyBuYW1lLiBFeDogJ2EnLCAnYnV0dG9uJywgZXRjLlxuXHQgKiBcblx0ICogTm90IHJlcXVpcmVkIGF0IGluc3RhbnRpYXRpb24gdGltZSwgYnV0IHNob3VsZCBiZSBzZXQgdXNpbmcge0BsaW5rICNzZXRUYWdOYW1lfSBiZWZvcmUge0BsaW5rICN0b1N0cmluZ31cblx0ICogaXMgZXhlY3V0ZWQuXG5cdCAqL1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBhdHRyc1xuXHQgKiBcblx0ICogQW4ga2V5L3ZhbHVlIE9iamVjdCAobWFwKSBvZiBhdHRyaWJ1dGVzIHRvIGNyZWF0ZSB0aGUgdGFnIHdpdGguIFRoZSBrZXlzIGFyZSB0aGUgYXR0cmlidXRlIG5hbWVzLCBhbmQgdGhlXG5cdCAqIHZhbHVlcyBhcmUgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMuXG5cdCAqL1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge1N0cmluZ30gaW5uZXJIdG1sXG5cdCAqIFxuXHQgKiBUaGUgaW5uZXIgSFRNTCBmb3IgdGhlIHRhZy4gXG5cdCAqIFxuXHQgKiBOb3RlIHRoZSBjYW1lbCBjYXNlIG5hbWUgb24gYGlubmVySHRtbGAuIEFjcm9ueW1zIGFyZSBjYW1lbENhc2VkIGluIHRoaXMgdXRpbGl0eSAoc3VjaCBhcyBub3QgdG8gcnVuIGludG8gdGhlIGFjcm9ueW0gXG5cdCAqIG5hbWluZyBpbmNvbnNpc3RlbmN5IHRoYXQgdGhlIERPTSBkZXZlbG9wZXJzIGNyZWF0ZWQgd2l0aCBgWE1MSHR0cFJlcXVlc3RgKS4gWW91IG1heSBhbHRlcm5hdGl2ZWx5IHVzZSB7QGxpbmsgI2lubmVySFRNTH1cblx0ICogaWYgeW91IHByZWZlciwgYnV0IHRoaXMgb25lIGlzIHJlY29tbWVuZGVkLlxuXHQgKi9cblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtTdHJpbmd9IGlubmVySFRNTFxuXHQgKiBcblx0ICogQWxpYXMgb2Yge0BsaW5rICNpbm5lckh0bWx9LCBhY2NlcHRlZCBmb3IgY29uc2lzdGVuY3kgd2l0aCB0aGUgYnJvd3NlciBET00gYXBpLCBidXQgcHJlZmVyIHRoZSBjYW1lbENhc2VkIHZlcnNpb25cblx0ICogZm9yIGFjcm9ueW0gbmFtZXMuXG5cdCAqL1xuXHRcblx0XG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSB3aGl0ZXNwYWNlUmVnZXhcblx0ICogXG5cdCAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIG1hdGNoIHdoaXRlc3BhY2UgaW4gYSBzdHJpbmcgb2YgQ1NTIGNsYXNzZXMuXG5cdCAqL1xuXHR3aGl0ZXNwYWNlUmVnZXggOiAvXFxzKy8sXG5cdFxuXHRcblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2NmZ10gVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBmb3IgdGhpcyBjbGFzcywgaW4gYW4gT2JqZWN0IChtYXApXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKCBjZmcgKSB7XG5cdFx0QXV0b2xpbmtlci5VdGlsLmFzc2lnbiggdGhpcywgY2ZnICk7XG5cdFx0XG5cdFx0dGhpcy5pbm5lckh0bWwgPSB0aGlzLmlubmVySHRtbCB8fCB0aGlzLmlubmVySFRNTDsgIC8vIGFjY2VwdCBlaXRoZXIgdGhlIGNhbWVsQ2FzZWQgZm9ybSBvciB0aGUgZnVsbHkgY2FwaXRhbGl6ZWQgYWNyb255bVxuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB0YWcgbmFtZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGFnIHdpdGguXG5cdCAqIFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGFnTmFtZVxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkh0bWxUYWd9IFRoaXMgSHRtbFRhZyBpbnN0YW5jZSwgc28gdGhhdCBtZXRob2QgY2FsbHMgbWF5IGJlIGNoYWluZWQuXG5cdCAqL1xuXHRzZXRUYWdOYW1lIDogZnVuY3Rpb24oIHRhZ05hbWUgKSB7XG5cdFx0dGhpcy50YWdOYW1lID0gdGFnTmFtZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogUmV0cmlldmVzIHRoZSB0YWcgbmFtZS5cblx0ICogXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldFRhZ05hbWUgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50YWdOYW1lIHx8IFwiXCI7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFNldHMgYW4gYXR0cmlidXRlIG9uIHRoZSBIdG1sVGFnLlxuXHQgKiBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGF0dHJOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyVmFsdWUgVGhlIGF0dHJpYnV0ZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhpcyBIdG1sVGFnIGluc3RhbmNlLCBzbyB0aGF0IG1ldGhvZCBjYWxscyBtYXkgYmUgY2hhaW5lZC5cblx0ICovXG5cdHNldEF0dHIgOiBmdW5jdGlvbiggYXR0ck5hbWUsIGF0dHJWYWx1ZSApIHtcblx0XHR2YXIgdGFnQXR0cnMgPSB0aGlzLmdldEF0dHJzKCk7XG5cdFx0dGFnQXR0cnNbIGF0dHJOYW1lIF0gPSBhdHRyVmFsdWU7XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHJpZXZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgSHRtbFRhZy4gSWYgdGhlIGF0dHJpYnV0ZSBkb2VzIG5vdCBleGlzdCwgcmV0dXJucyBgdW5kZWZpbmVkYC5cblx0ICogXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byByZXRyaWV2ZS5cblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgYXR0cmlidXRlJ3MgdmFsdWUsIG9yIGB1bmRlZmluZWRgIGlmIGl0IGRvZXMgbm90IGV4aXN0IG9uIHRoZSBIdG1sVGFnLlxuXHQgKi9cblx0Z2V0QXR0ciA6IGZ1bmN0aW9uKCBhdHRyTmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRBdHRycygpWyBhdHRyTmFtZSBdO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBTZXRzIG9uZSBvciBtb3JlIGF0dHJpYnV0ZXMgb24gdGhlIEh0bWxUYWcuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBhdHRycyBBIGtleS92YWx1ZSBPYmplY3QgKG1hcCkgb2YgdGhlIGF0dHJpYnV0ZXMgdG8gc2V0LlxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLkh0bWxUYWd9IFRoaXMgSHRtbFRhZyBpbnN0YW5jZSwgc28gdGhhdCBtZXRob2QgY2FsbHMgbWF5IGJlIGNoYWluZWQuXG5cdCAqL1xuXHRzZXRBdHRycyA6IGZ1bmN0aW9uKCBhdHRycyApIHtcblx0XHR2YXIgdGFnQXR0cnMgPSB0aGlzLmdldEF0dHJzKCk7XG5cdFx0QXV0b2xpbmtlci5VdGlsLmFzc2lnbiggdGFnQXR0cnMsIGF0dHJzICk7XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgYXR0cmlidXRlcyBPYmplY3QgKG1hcCkgZm9yIHRoZSBIdG1sVGFnLlxuXHQgKiBcblx0ICogQHJldHVybiB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IEEga2V5L3ZhbHVlIG9iamVjdCBvZiB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIEh0bWxUYWcuXG5cdCAqL1xuXHRnZXRBdHRycyA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmF0dHJzIHx8ICggdGhpcy5hdHRycyA9IHt9ICk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFNldHMgdGhlIHByb3ZpZGVkIGBjc3NDbGFzc2AsIG92ZXJ3cml0aW5nIGFueSBjdXJyZW50IENTUyBjbGFzc2VzIG9uIHRoZSBIdG1sVGFnLlxuXHQgKiBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNzc0NsYXNzIE9uZSBvciBtb3JlIHNwYWNlLXNlcGFyYXRlZCBDU1MgY2xhc3NlcyB0byBzZXQgKG92ZXJ3cml0ZSkuXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhpcyBIdG1sVGFnIGluc3RhbmNlLCBzbyB0aGF0IG1ldGhvZCBjYWxscyBtYXkgYmUgY2hhaW5lZC5cblx0ICovXG5cdHNldENsYXNzIDogZnVuY3Rpb24oIGNzc0NsYXNzICkge1xuXHRcdHJldHVybiB0aGlzLnNldEF0dHIoICdjbGFzcycsIGNzc0NsYXNzICk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhZGQgb25lIG9yIG1vcmUgQ1NTIGNsYXNzZXMgdG8gdGhlIEh0bWxUYWcuIFdpbGwgbm90IGFkZCBkdXBsaWNhdGUgQ1NTIGNsYXNzZXMuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY3NzQ2xhc3MgT25lIG9yIG1vcmUgc3BhY2Utc2VwYXJhdGVkIENTUyBjbGFzc2VzIHRvIGFkZC5cblx0ICogQHJldHVybiB7QXV0b2xpbmtlci5IdG1sVGFnfSBUaGlzIEh0bWxUYWcgaW5zdGFuY2UsIHNvIHRoYXQgbWV0aG9kIGNhbGxzIG1heSBiZSBjaGFpbmVkLlxuXHQgKi9cblx0YWRkQ2xhc3MgOiBmdW5jdGlvbiggY3NzQ2xhc3MgKSB7XG5cdFx0dmFyIGNsYXNzQXR0ciA9IHRoaXMuZ2V0Q2xhc3MoKSxcblx0XHQgICAgd2hpdGVzcGFjZVJlZ2V4ID0gdGhpcy53aGl0ZXNwYWNlUmVnZXgsXG5cdFx0ICAgIGluZGV4T2YgPSBBdXRvbGlua2VyLlV0aWwuaW5kZXhPZiwgIC8vIHRvIHN1cHBvcnQgSUU4IGFuZCBiZWxvd1xuXHRcdCAgICBjbGFzc2VzID0gKCAhY2xhc3NBdHRyICkgPyBbXSA6IGNsYXNzQXR0ci5zcGxpdCggd2hpdGVzcGFjZVJlZ2V4ICksXG5cdFx0ICAgIG5ld0NsYXNzZXMgPSBjc3NDbGFzcy5zcGxpdCggd2hpdGVzcGFjZVJlZ2V4ICksXG5cdFx0ICAgIG5ld0NsYXNzO1xuXHRcdFxuXHRcdHdoaWxlKCBuZXdDbGFzcyA9IG5ld0NsYXNzZXMuc2hpZnQoKSApIHtcblx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBuZXdDbGFzcyApID09PSAtMSApIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKCBuZXdDbGFzcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHR0aGlzLmdldEF0dHJzKClbICdjbGFzcycgXSA9IGNsYXNzZXMuam9pbiggXCIgXCIgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSBvbmUgb3IgbW9yZSBDU1MgY2xhc3NlcyBmcm9tIHRoZSBIdG1sVGFnLlxuXHQgKiBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNzc0NsYXNzIE9uZSBvciBtb3JlIHNwYWNlLXNlcGFyYXRlZCBDU1MgY2xhc3NlcyB0byByZW1vdmUuXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhpcyBIdG1sVGFnIGluc3RhbmNlLCBzbyB0aGF0IG1ldGhvZCBjYWxscyBtYXkgYmUgY2hhaW5lZC5cblx0ICovXG5cdHJlbW92ZUNsYXNzIDogZnVuY3Rpb24oIGNzc0NsYXNzICkge1xuXHRcdHZhciBjbGFzc0F0dHIgPSB0aGlzLmdldENsYXNzKCksXG5cdFx0ICAgIHdoaXRlc3BhY2VSZWdleCA9IHRoaXMud2hpdGVzcGFjZVJlZ2V4LFxuXHRcdCAgICBpbmRleE9mID0gQXV0b2xpbmtlci5VdGlsLmluZGV4T2YsICAvLyB0byBzdXBwb3J0IElFOCBhbmQgYmVsb3dcblx0XHQgICAgY2xhc3NlcyA9ICggIWNsYXNzQXR0ciApID8gW10gOiBjbGFzc0F0dHIuc3BsaXQoIHdoaXRlc3BhY2VSZWdleCApLFxuXHRcdCAgICByZW1vdmVDbGFzc2VzID0gY3NzQ2xhc3Muc3BsaXQoIHdoaXRlc3BhY2VSZWdleCApLFxuXHRcdCAgICByZW1vdmVDbGFzcztcblx0XHRcblx0XHR3aGlsZSggY2xhc3Nlcy5sZW5ndGggJiYgKCByZW1vdmVDbGFzcyA9IHJlbW92ZUNsYXNzZXMuc2hpZnQoKSApICkge1xuXHRcdFx0dmFyIGlkeCA9IGluZGV4T2YoIGNsYXNzZXMsIHJlbW92ZUNsYXNzICk7XG5cdFx0XHRpZiggaWR4ICE9PSAtMSApIHtcblx0XHRcdFx0Y2xhc3Nlcy5zcGxpY2UoIGlkeCwgMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHR0aGlzLmdldEF0dHJzKClbICdjbGFzcycgXSA9IGNsYXNzZXMuam9pbiggXCIgXCIgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHJpZXZlIHRoZSBDU1MgY2xhc3MoZXMpIGZvciB0aGUgSHRtbFRhZywgd2hpY2ggd2lsbCBlYWNoIGJlIHNlcGFyYXRlZCBieSBzcGFjZXMgd2hlblxuXHQgKiB0aGVyZSBhcmUgbXVsdGlwbGUuXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRDbGFzcyA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEF0dHJzKClbICdjbGFzcycgXSB8fCBcIlwiO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gY2hlY2sgaWYgdGhlIHRhZyBoYXMgYSBDU1MgY2xhc3Mgb3Igbm90LlxuXHQgKiBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNzc0NsYXNzIFRoZSBDU1MgY2xhc3MgdG8gY2hlY2sgZm9yLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIEh0bWxUYWcgaGFzIHRoZSBDU1MgY2xhc3MsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuXHQgKi9cblx0aGFzQ2xhc3MgOiBmdW5jdGlvbiggY3NzQ2xhc3MgKSB7XG5cdFx0cmV0dXJuICggJyAnICsgdGhpcy5nZXRDbGFzcygpICsgJyAnICkuaW5kZXhPZiggJyAnICsgY3NzQ2xhc3MgKyAnICcgKSAhPT0gLTE7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFNldHMgdGhlIGlubmVyIEhUTUwgZm9yIHRoZSB0YWcuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCBUaGUgaW5uZXIgSFRNTCB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhpcyBIdG1sVGFnIGluc3RhbmNlLCBzbyB0aGF0IG1ldGhvZCBjYWxscyBtYXkgYmUgY2hhaW5lZC5cblx0ICovXG5cdHNldElubmVySHRtbCA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHRoaXMuaW5uZXJIdG1sID0gaHRtbDtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogUmV0cmlldmVzIHRoZSBpbm5lciBIVE1MIGZvciB0aGUgdGFnLlxuXHQgKiBcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0SW5uZXJIdG1sIDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5uZXJIdG1sIHx8IFwiXCI7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIE92ZXJyaWRlIG9mIHN1cGVyY2xhc3MgbWV0aG9kIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIEhUTUwgc3RyaW5nIGZvciB0aGUgdGFnLlxuXHQgKiBcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcgOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGFnTmFtZSA9IHRoaXMuZ2V0VGFnTmFtZSgpLFxuXHRcdCAgICBhdHRyc1N0ciA9IHRoaXMuYnVpbGRBdHRyc1N0cigpO1xuXHRcdFxuXHRcdGF0dHJzU3RyID0gKCBhdHRyc1N0ciApID8gJyAnICsgYXR0cnNTdHIgOiAnJzsgIC8vIHByZXBlbmQgYSBzcGFjZSBpZiB0aGVyZSBhcmUgYWN0dWFsbHkgYXR0cmlidXRlc1xuXHRcdFxuXHRcdHJldHVybiBbICc8JywgdGFnTmFtZSwgYXR0cnNTdHIsICc+JywgdGhpcy5nZXRJbm5lckh0bWwoKSwgJzwvJywgdGFnTmFtZSwgJz4nIF0uam9pbiggXCJcIiApO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBTdXBwb3J0IG1ldGhvZCBmb3Ige0BsaW5rICN0b1N0cmluZ30sIHJldHVybnMgdGhlIHN0cmluZyBzcGFjZS1zZXBhcmF0ZWQga2V5PVwidmFsdWVcIiBwYWlycywgdXNlZCB0byBwb3B1bGF0ZSBcblx0ICogdGhlIHN0cmluZ2lmaWVkIEh0bWxUYWcuXG5cdCAqIFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gRXhhbXBsZSByZXR1cm46IGBhdHRyMT1cInZhbHVlMVwiIGF0dHIyPVwidmFsdWUyXCJgXG5cdCAqL1xuXHRidWlsZEF0dHJzU3RyIDogZnVuY3Rpb24oKSB7XG5cdFx0aWYoICF0aGlzLmF0dHJzICkgcmV0dXJuIFwiXCI7ICAvLyBubyBgYXR0cnNgIE9iamVjdCAobWFwKSBoYXMgYmVlbiBzZXQsIHJldHVybiBlbXB0eSBzdHJpbmdcblx0XHRcblx0XHR2YXIgYXR0cnMgPSB0aGlzLmdldEF0dHJzKCksXG5cdFx0ICAgIGF0dHJzQXJyID0gW107XG5cdFx0XG5cdFx0Zm9yKCB2YXIgcHJvcCBpbiBhdHRycyApIHtcblx0XHRcdGlmKCBhdHRycy5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkge1xuXHRcdFx0XHRhdHRyc0Fyci5wdXNoKCBwcm9wICsgJz1cIicgKyBhdHRyc1sgcHJvcCBdICsgJ1wiJyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYXR0cnNBcnIuam9pbiggXCIgXCIgKTtcblx0fVxuXHRcbn0gKTtcbi8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cbi8qanNoaW50IHN1Yjp0cnVlICovXG4vKipcbiAqIEBwcm90ZWN0ZWRcbiAqIEBjbGFzcyBBdXRvbGlua2VyLkFuY2hvclRhZ0J1aWxkZXJcbiAqIEBleHRlbmRzIE9iamVjdFxuICogXG4gKiBCdWlsZHMgYW5jaG9yICgmbHQ7YSZndDspIHRhZ3MgZm9yIHRoZSBBdXRvbGlua2VyIHV0aWxpdHkgd2hlbiBhIG1hdGNoIGlzIGZvdW5kLlxuICogXG4gKiBOb3JtYWxseSB0aGlzIGNsYXNzIGlzIGluc3RhbnRpYXRlZCwgY29uZmlndXJlZCwgYW5kIHVzZWQgaW50ZXJuYWxseSBieSBhbiB7QGxpbmsgQXV0b2xpbmtlcn0gaW5zdGFuY2UsIGJ1dCBtYXkgXG4gKiBhY3R1YWxseSBiZSByZXRyaWV2ZWQgaW4gYSB7QGxpbmsgQXV0b2xpbmtlciNyZXBsYWNlRm4gcmVwbGFjZUZufSB0byBjcmVhdGUge0BsaW5rIEF1dG9saW5rZXIuSHRtbFRhZyBIdG1sVGFnfSBpbnN0YW5jZXNcbiAqIHdoaWNoIG1heSBiZSBtb2RpZmllZCBiZWZvcmUgcmV0dXJuaW5nIGZyb20gdGhlIHtAbGluayBBdXRvbGlua2VyI3JlcGxhY2VGbiByZXBsYWNlRm59LiBGb3IgZXhhbXBsZTpcbiAqIFxuICogICAgIHZhciBodG1sID0gQXV0b2xpbmtlci5saW5rKCBcIlRlc3QgZ29vZ2xlLmNvbVwiLCB7XG4gKiAgICAgICAgIHJlcGxhY2VGbiA6IGZ1bmN0aW9uKCBhdXRvbGlua2VyLCBtYXRjaCApIHtcbiAqICAgICAgICAgICAgIHZhciB0YWcgPSBhdXRvbGlua2VyLmdldFRhZ0J1aWxkZXIoKS5idWlsZCggbWF0Y2ggKTsgIC8vIHJldHVybnMgYW4ge0BsaW5rIEF1dG9saW5rZXIuSHRtbFRhZ30gaW5zdGFuY2VcbiAqICAgICAgICAgICAgIHRhZy5zZXRBdHRyKCAncmVsJywgJ25vZm9sbG93JyApO1xuICogICAgICAgICAgICAgXG4gKiAgICAgICAgICAgICByZXR1cm4gdGFnO1xuICogICAgICAgICB9XG4gKiAgICAgfSApO1xuICogICAgIFxuICogICAgIC8vIGdlbmVyYXRlZCBodG1sOlxuICogICAgIC8vICAgVGVzdCA8YSBocmVmPVwiaHR0cDovL2dvb2dsZS5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub2ZvbGxvd1wiPmdvb2dsZS5jb208L2E+XG4gKi9cbkF1dG9saW5rZXIuQW5jaG9yVGFnQnVpbGRlciA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge0Jvb2xlYW59IG5ld1dpbmRvd1xuXHQgKiBAaW5oZXJpdGRvYyBBdXRvbGlua2VyI25ld1dpbmRvd1xuXHQgKi9cblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtOdW1iZXJ9IHRydW5jYXRlXG5cdCAqIEBpbmhlcml0ZG9jIEF1dG9saW5rZXIjdHJ1bmNhdGVcblx0ICovXG5cdFxuXHQvKipcblx0ICogQGNmZyB7U3RyaW5nfSBjbGFzc05hbWVcblx0ICogQGluaGVyaXRkb2MgQXV0b2xpbmtlciNjbGFzc05hbWVcblx0ICovXG5cdFxuXHRcblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2NmZ10gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIEFuY2hvclRhZ0J1aWxkZXIgaW5zdGFuY2UsIHNwZWNpZmllZCBpbiBhbiBPYmplY3QgKG1hcCkuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKCBjZmcgKSB7XG5cdFx0QXV0b2xpbmtlci5VdGlsLmFzc2lnbiggdGhpcywgY2ZnICk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIEdlbmVyYXRlcyB0aGUgYWN0dWFsIGFuY2hvciAoJmx0O2EmZ3Q7KSB0YWcgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBtYXRjaGVkIFVSTC9lbWFpbC9Ud2l0dGVyIHRleHQsXG5cdCAqIHZpYSBpdHMgYG1hdGNoYCBvYmplY3QuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge0F1dG9saW5rZXIubWF0Y2guTWF0Y2h9IG1hdGNoIFRoZSBNYXRjaCBpbnN0YW5jZSB0byBnZW5lcmF0ZSBhbiBhbmNob3IgdGFnIGZyb20uXG5cdCAqIEByZXR1cm4ge0F1dG9saW5rZXIuSHRtbFRhZ30gVGhlIEh0bWxUYWcgaW5zdGFuY2UgZm9yIHRoZSBhbmNob3IgdGFnLlxuXHQgKi9cblx0YnVpbGQgOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0dmFyIHRhZyA9IG5ldyBBdXRvbGlua2VyLkh0bWxUYWcoIHtcblx0XHRcdHRhZ05hbWUgICA6ICdhJyxcblx0XHRcdGF0dHJzICAgICA6IHRoaXMuY3JlYXRlQXR0cnMoIG1hdGNoLmdldFR5cGUoKSwgbWF0Y2guZ2V0QW5jaG9ySHJlZigpICksXG5cdFx0XHRpbm5lckh0bWwgOiB0aGlzLnByb2Nlc3NBbmNob3JUZXh0KCBtYXRjaC5nZXRBbmNob3JUZXh0KCkgKVxuXHRcdH0gKTtcblx0XHRcblx0XHRyZXR1cm4gdGFnO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBDcmVhdGVzIHRoZSBPYmplY3QgKG1hcCkgb2YgdGhlIEhUTUwgYXR0cmlidXRlcyBmb3IgdGhlIGFuY2hvciAoJmx0O2EmZ3Q7KSB0YWcgYmVpbmcgZ2VuZXJhdGVkLlxuXHQgKiBcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge1widXJsXCIvXCJlbWFpbFwiL1widHdpdHRlclwifSBtYXRjaFR5cGUgVGhlIHR5cGUgb2YgbWF0Y2ggdGhhdCBhbiBhbmNob3IgdGFnIGlzIGJlaW5nIGdlbmVyYXRlZCBmb3IuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBocmVmIFRoZSBocmVmIGZvciB0aGUgYW5jaG9yIHRhZy5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBIGtleS92YWx1ZSBPYmplY3QgKG1hcCkgb2YgdGhlIGFuY2hvciB0YWcncyBhdHRyaWJ1dGVzLiBcblx0ICovXG5cdGNyZWF0ZUF0dHJzIDogZnVuY3Rpb24oIG1hdGNoVHlwZSwgYW5jaG9ySHJlZiApIHtcblx0XHR2YXIgYXR0cnMgPSB7XG5cdFx0XHQnaHJlZicgOiBhbmNob3JIcmVmICAvLyB3ZSdsbCBhbHdheXMgaGF2ZSB0aGUgYGhyZWZgIGF0dHJpYnV0ZVxuXHRcdH07XG5cdFx0XG5cdFx0dmFyIGNzc0NsYXNzID0gdGhpcy5jcmVhdGVDc3NDbGFzcyggbWF0Y2hUeXBlICk7XG5cdFx0aWYoIGNzc0NsYXNzICkge1xuXHRcdFx0YXR0cnNbICdjbGFzcycgXSA9IGNzc0NsYXNzO1xuXHRcdH1cblx0XHRpZiggdGhpcy5uZXdXaW5kb3cgKSB7XG5cdFx0XHRhdHRyc1sgJ3RhcmdldCcgXSA9IFwiX2JsYW5rXCI7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBhdHRycztcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyB0aGUgQ1NTIGNsYXNzIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhIGdpdmVuIGFuY2hvciB0YWcsIGJhc2VkIG9uIHRoZSBgbWF0Y2hUeXBlYCBhbmQgdGhlIHtAbGluayAjY2xhc3NOYW1lfVxuXHQgKiBjb25maWcuXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1widXJsXCIvXCJlbWFpbFwiL1widHdpdHRlclwifSBtYXRjaFR5cGUgVGhlIHR5cGUgb2YgbWF0Y2ggdGhhdCBhbiBhbmNob3IgdGFnIGlzIGJlaW5nIGdlbmVyYXRlZCBmb3IuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIENTUyBjbGFzcyBzdHJpbmcgZm9yIHRoZSBsaW5rLiBFeGFtcGxlIHJldHVybjogXCJteUxpbmsgbXlMaW5rLXVybFwiLiBJZiBubyB7QGxpbmsgI2NsYXNzTmFtZX1cblx0ICogICB3YXMgY29uZmlndXJlZCwgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG5cdCAqL1xuXHRjcmVhdGVDc3NDbGFzcyA6IGZ1bmN0aW9uKCBtYXRjaFR5cGUgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuXHRcdFxuXHRcdGlmKCAhY2xhc3NOYW1lICkgXG5cdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc05hbWUgKyBcIi1cIiArIG1hdGNoVHlwZTsgIC8vIGV4OiBcIm15TGluayBteUxpbmstdXJsXCIsIFwibXlMaW5rIG15TGluay1lbWFpbFwiLCBvciBcIm15TGluayBteUxpbmstdHdpdHRlclwiXG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFByb2Nlc3NlcyB0aGUgYGFuY2hvclRleHRgIGJ5IHRydW5jYXRpbmcgdGhlIHRleHQgYWNjb3JkaW5nIHRvIHRoZSB7QGxpbmsgI3RydW5jYXRlfSBjb25maWcuXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYW5jaG9yVGV4dCBUaGUgYW5jaG9yIHRhZydzIHRleHQgKGkuZS4gd2hhdCB3aWxsIGJlIGRpc3BsYXllZCkuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHByb2Nlc3NlZCBgYW5jaG9yVGV4dGAuXG5cdCAqL1xuXHRwcm9jZXNzQW5jaG9yVGV4dCA6IGZ1bmN0aW9uKCBhbmNob3JUZXh0ICkge1xuXHRcdGFuY2hvclRleHQgPSB0aGlzLmRvVHJ1bmNhdGUoIGFuY2hvclRleHQgKTtcblx0XHRcblx0XHRyZXR1cm4gYW5jaG9yVGV4dDtcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogUGVyZm9ybXMgdGhlIHRydW5jYXRpb24gb2YgdGhlIGBhbmNob3JUZXh0YCwgaWYgdGhlIGBhbmNob3JUZXh0YCBpcyBsb25nZXIgdGhhbiB0aGUge0BsaW5rICN0cnVuY2F0ZX0gb3B0aW9uLlxuXHQgKiBUcnVuY2F0ZXMgdGhlIHRleHQgdG8gMiBjaGFyYWN0ZXJzIGZld2VyIHRoYW4gdGhlIHtAbGluayAjdHJ1bmNhdGV9IG9wdGlvbiwgYW5kIGFkZHMgXCIuLlwiIHRvIHRoZSBlbmQuXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgYW5jaG9yIHRhZydzIHRleHQgKGkuZS4gd2hhdCB3aWxsIGJlIGRpc3BsYXllZCkuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHRydW5jYXRlZCBhbmNob3IgdGV4dC5cblx0ICovXG5cdGRvVHJ1bmNhdGUgOiBmdW5jdGlvbiggYW5jaG9yVGV4dCApIHtcblx0XHRyZXR1cm4gQXV0b2xpbmtlci5VdGlsLmVsbGlwc2lzKCBhbmNob3JUZXh0LCB0aGlzLnRydW5jYXRlIHx8IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSApO1xuXHR9XG5cdFxufSApO1xuLypnbG9iYWwgQXV0b2xpbmtlciAqL1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGNsYXNzIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sUGFyc2VyXG4gKiBAZXh0ZW5kcyBPYmplY3RcbiAqIFxuICogQW4gSFRNTCBwYXJzZXIgaW1wbGVtZW50YXRpb24gd2hpY2ggc2ltcGx5IHdhbGtzIGFuIEhUTUwgc3RyaW5nIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIFxuICoge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZSBIdG1sTm9kZXN9IHRoYXQgcmVwcmVzZW50IHRoZSBiYXNpYyBIVE1MIHN0cnVjdHVyZSBvZiB0aGUgaW5wdXQgc3RyaW5nLlxuICogXG4gKiBBdXRvbGlua2VyIHVzZXMgdGhpcyB0byBvbmx5IGxpbmsgVVJMcy9lbWFpbHMvVHdpdHRlciBoYW5kbGVzIHdpdGhpbiB0ZXh0IG5vZGVzLCBlZmZlY3RpdmVseSBpZ25vcmluZyAvIFwid2Fsa2luZ1xuICogYXJvdW5kXCIgSFRNTCB0YWdzLlxuICovXG5BdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbFBhcnNlciA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xuXHRcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBodG1sUmVnZXhcblx0ICogXG5cdCAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBwdWxsIG91dCBIVE1MIHRhZ3MgZnJvbSBhIHN0cmluZy4gSGFuZGxlcyBuYW1lc3BhY2VkIEhUTUwgdGFncyBhbmRcblx0ICogYXR0cmlidXRlIG5hbWVzLCBhcyBzcGVjaWZpZWQgYnkgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1tYXJrdXAvc3ludGF4Lmh0bWwuXG5cdCAqIFxuXHQgKiBDYXB0dXJpbmcgZ3JvdXBzOlxuXHQgKiBcblx0ICogMS4gVGhlIFwiIURPQ1RZUEVcIiB0YWcgbmFtZSwgaWYgYSB0YWcgaXMgYSAmbHQ7IURPQ1RZUEUmZ3Q7IHRhZy5cblx0ICogMi4gSWYgaXQgaXMgYW4gZW5kIHRhZywgdGhpcyBncm91cCB3aWxsIGhhdmUgdGhlICcvJy5cblx0ICogMy4gVGhlIHRhZyBuYW1lIGZvciBhbGwgdGFncyAob3RoZXIgdGhhbiB0aGUgJmx0OyFET0NUWVBFJmd0OyB0YWcpXG5cdCAqL1xuXHRodG1sUmVnZXggOiAoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRhZ05hbWVSZWdleCA9IC9bMC05YS16QS1aXVswLTlhLXpBLVo6XSovLFxuXHRcdCAgICBhdHRyTmFtZVJlZ2V4ID0gL1teXFxzXFwwXCInPlxcLz1cXHgwMS1cXHgxRlxceDdGXSsvLCAgIC8vIHRoZSB1bmljb2RlIHJhbmdlIGFjY291bnRzIGZvciBleGNsdWRpbmcgY29udHJvbCBjaGFycywgYW5kIHRoZSBkZWxldGUgY2hhclxuXHRcdCAgICBhdHRyVmFsdWVSZWdleCA9IC8oPzpcIlteXCJdKj9cInwnW14nXSo/J3xbXidcIj08PmBcXHNdKykvLCAvLyBkb3VibGUgcXVvdGVkLCBzaW5nbGUgcXVvdGVkLCBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVzXG5cdFx0ICAgIG5hbWVFcXVhbHNWYWx1ZVJlZ2V4ID0gYXR0ck5hbWVSZWdleC5zb3VyY2UgKyAnKD86XFxcXHMqPVxcXFxzKicgKyBhdHRyVmFsdWVSZWdleC5zb3VyY2UgKyAnKT8nOyAgLy8gb3B0aW9uYWwgJz1bdmFsdWVdJ1xuXHRcdFxuXHRcdHJldHVybiBuZXcgUmVnRXhwKCBbXG5cdFx0XHQvLyBmb3IgPCFET0NUWVBFPiB0YWcuIEV4OiA8IURPQ1RZUEUgaHRtbCBQVUJMSUMgXCItLy9XM0MvL0RURCBYSFRNTCAxLjAgU3RyaWN0Ly9FTlwiIFwiaHR0cDovL3d3dy53My5vcmcvVFIveGh0bWwxL0RURC94aHRtbDEtc3RyaWN0LmR0ZFwiPikgXG5cdFx0XHQnKD86Jyxcblx0XHRcdFx0JzwoIURPQ1RZUEUpJywgIC8vICoqKiBDYXB0dXJpbmcgR3JvdXAgMSAtIElmIGl0J3MgYSBkb2N0eXBlIHRhZ1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFplcm8gb3IgbW9yZSBhdHRyaWJ1dGVzIGZvbGxvd2luZyB0aGUgdGFnIG5hbWVcblx0XHRcdFx0XHQnKD86Jyxcblx0XHRcdFx0XHRcdCdcXFxccysnLCAgLy8gb25lIG9yIG1vcmUgd2hpdGVzcGFjZSBjaGFycyBiZWZvcmUgYW4gYXR0cmlidXRlXG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIEVpdGhlcjpcblx0XHRcdFx0XHRcdC8vIEEuIGF0dHI9XCJ2YWx1ZVwiLCBvciBcblx0XHRcdFx0XHRcdC8vIEIuIFwidmFsdWVcIiBhbG9uZSAoVG8gY292ZXIgZXhhbXBsZSBkb2N0eXBlIHRhZzogPCFET0NUWVBFIGh0bWwgUFVCTElDIFwiLS8vVzNDLy9EVEQgWEhUTUwgMS4wIFN0cmljdC8vRU5cIiBcImh0dHA6Ly93d3cudzMub3JnL1RSL3hodG1sMS9EVEQveGh0bWwxLXN0cmljdC5kdGRcIj4pIFxuXHRcdFx0XHRcdFx0Jyg/OicsIG5hbWVFcXVhbHNWYWx1ZVJlZ2V4LCAnfCcsIGF0dHJWYWx1ZVJlZ2V4LnNvdXJjZSArICcpJyxcblx0XHRcdFx0XHQnKSonLFxuXHRcdFx0XHQnPicsXG5cdFx0XHQnKScsXG5cdFx0XHRcblx0XHRcdCd8Jyxcblx0XHRcdFxuXHRcdFx0Ly8gQWxsIG90aGVyIEhUTUwgdGFncyAoaS5lLiB0YWdzIHRoYXQgYXJlIG5vdCA8IURPQ1RZUEU+KVxuXHRcdFx0Jyg/OicsXG5cdFx0XHRcdCc8KC8pPycsICAvLyBCZWdpbm5pbmcgb2YgYSB0YWcuIEVpdGhlciAnPCcgZm9yIGEgc3RhcnQgdGFnLCBvciAnPC8nIGZvciBhbiBlbmQgdGFnLiBcblx0XHRcdFx0ICAgICAgICAgIC8vICoqKiBDYXB0dXJpbmcgR3JvdXAgMjogVGhlIHNsYXNoIG9yIGFuIGVtcHR5IHN0cmluZy4gU2xhc2ggKCcvJykgZm9yIGVuZCB0YWcsIGVtcHR5IHN0cmluZyBmb3Igc3RhcnQgb3Igc2VsZi1jbG9zaW5nIHRhZy5cblx0XHRcdFxuXHRcdFx0XHRcdC8vICoqKiBDYXB0dXJpbmcgR3JvdXAgMyAtIFRoZSB0YWcgbmFtZVxuXHRcdFx0XHRcdCcoJyArIHRhZ05hbWVSZWdleC5zb3VyY2UgKyAnKScsXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gWmVybyBvciBtb3JlIGF0dHJpYnV0ZXMgZm9sbG93aW5nIHRoZSB0YWcgbmFtZVxuXHRcdFx0XHRcdCcoPzonLFxuXHRcdFx0XHRcdFx0J1xcXFxzKycsICAgICAgICAgICAgICAgIC8vIG9uZSBvciBtb3JlIHdoaXRlc3BhY2UgY2hhcnMgYmVmb3JlIGFuIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdFx0bmFtZUVxdWFsc1ZhbHVlUmVnZXgsICAvLyBhdHRyPVwidmFsdWVcIiAod2l0aCBvcHRpb25hbCA9XCJ2YWx1ZVwiIHBhcnQpXG5cdFx0XHRcdFx0JykqJyxcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQnXFxcXHMqLz8nLCAgLy8gYW55IHRyYWlsaW5nIHNwYWNlcyBhbmQgb3B0aW9uYWwgJy8nIGJlZm9yZSB0aGUgY2xvc2luZyAnPidcblx0XHRcdFx0Jz4nLFxuXHRcdFx0JyknXG5cdFx0XS5qb2luKCBcIlwiICksICdnaScgKTtcblx0fSApKCksXG5cdFxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHByb3BlcnR5IHtSZWdFeHB9IGh0bWxDaGFyYWN0ZXJFbnRpdGllc1JlZ2V4XG5cdCAqXG5cdCAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGNvbW1vbiBIVE1MIGNoYXJhY3RlciBlbnRpdGllcy5cblx0ICogXG5cdCAqIElnbm9yaW5nICZhbXA7IGFzIGl0IGNvdWxkIGJlIHBhcnQgb2YgYSBxdWVyeSBzdHJpbmcgLS0gaGFuZGxpbmcgaXQgc2VwYXJhdGVseS5cblx0ICovXG5cdGh0bWxDaGFyYWN0ZXJFbnRpdGllc1JlZ2V4OiAvKCZuYnNwO3wmIzE2MDt8Jmx0O3wmIzYwO3wmZ3Q7fCYjNjI7fCZxdW90O3wmIzM0O3wmIzM5OykvZ2ksXG5cdFxuXHRcblx0LyoqXG5cdCAqIFBhcnNlcyBhbiBIVE1MIHN0cmluZyBhbmQgcmV0dXJucyBhIHNpbXBsZSBhcnJheSBvZiB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxOb2RlIEh0bWxOb2Rlc30gdG8gcmVwcmVzZW50XG5cdCAqIHRoZSBIVE1MIHN0cnVjdHVyZSBvZiB0aGUgaW5wdXQgc3RyaW5nLiBcblx0ICogXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIFRoZSBIVE1MIHRvIHBhcnNlLlxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGVbXX1cblx0ICovXG5cdHBhcnNlIDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxSZWdleCA9IHRoaXMuaHRtbFJlZ2V4LFxuXHRcdCAgICBjdXJyZW50UmVzdWx0LFxuXHRcdCAgICBsYXN0SW5kZXggPSAwLFxuXHRcdCAgICB0ZXh0QW5kRW50aXR5Tm9kZXMsXG5cdFx0ICAgIG5vZGVzID0gW107ICAvLyB3aWxsIGJlIHRoZSByZXN1bHQgb2YgdGhlIG1ldGhvZFxuXHRcdFxuXHRcdHdoaWxlKCAoIGN1cnJlbnRSZXN1bHQgPSBodG1sUmVnZXguZXhlYyggaHRtbCApICkgIT09IG51bGwgKSB7XG5cdFx0XHR2YXIgdGFnVGV4dCA9IGN1cnJlbnRSZXN1bHRbIDAgXSxcblx0XHRcdCAgICB0YWdOYW1lID0gY3VycmVudFJlc3VsdFsgMSBdIHx8IGN1cnJlbnRSZXN1bHRbIDMgXSwgIC8vIFRoZSA8IURPQ1RZUEU+IHRhZyAoZXg6IFwiIURPQ1RZUEVcIiksIG9yIGFub3RoZXIgdGFnIChleDogXCJhXCIgb3IgXCJpbWdcIikgXG5cdFx0XHQgICAgaXNDbG9zaW5nVGFnID0gISFjdXJyZW50UmVzdWx0WyAyIF0sXG5cdFx0XHQgICAgaW5CZXR3ZWVuVGFnc1RleHQgPSBodG1sLnN1YnN0cmluZyggbGFzdEluZGV4LCBjdXJyZW50UmVzdWx0LmluZGV4ICk7XG5cdFx0XHRcblx0XHRcdC8vIFB1c2ggVGV4dE5vZGVzIGFuZCBFbnRpdHlOb2RlcyBmb3IgYW55IHRleHQgZm91bmQgYmV0d2VlbiB0YWdzXG5cdFx0XHRpZiggaW5CZXR3ZWVuVGFnc1RleHQgKSB7XG5cdFx0XHRcdHRleHRBbmRFbnRpdHlOb2RlcyA9IHRoaXMucGFyc2VUZXh0QW5kRW50aXR5Tm9kZXMoIGluQmV0d2VlblRhZ3NUZXh0ICk7XG5cdFx0XHRcdG5vZGVzLnB1c2guYXBwbHkoIG5vZGVzLCB0ZXh0QW5kRW50aXR5Tm9kZXMgKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gUHVzaCB0aGUgRWxlbWVudE5vZGVcblx0XHRcdG5vZGVzLnB1c2goIHRoaXMuY3JlYXRlRWxlbWVudE5vZGUoIHRhZ1RleHQsIHRhZ05hbWUsIGlzQ2xvc2luZ1RhZyApICk7XG5cdFx0XHRcblx0XHRcdGxhc3RJbmRleCA9IGN1cnJlbnRSZXN1bHQuaW5kZXggKyB0YWdUZXh0Lmxlbmd0aDtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gUHJvY2VzcyBhbnkgcmVtYWluaW5nIHRleHQgYWZ0ZXIgdGhlIGxhc3QgSFRNTCBlbGVtZW50LiBXaWxsIHByb2Nlc3MgYWxsIG9mIHRoZSB0ZXh0IGlmIHRoZXJlIHdlcmUgbm8gSFRNTCBlbGVtZW50cy5cblx0XHRpZiggbGFzdEluZGV4IDwgaHRtbC5sZW5ndGggKSB7XG5cdFx0XHR2YXIgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKCBsYXN0SW5kZXggKTtcblx0XHRcdFxuXHRcdFx0Ly8gUHVzaCBUZXh0Tm9kZXMgYW5kIEVudGl0eU5vZGVzIGZvciBhbnkgdGV4dCBmb3VuZCBiZXR3ZWVuIHRhZ3Ncblx0XHRcdGlmKCB0ZXh0ICkge1xuXHRcdFx0XHR0ZXh0QW5kRW50aXR5Tm9kZXMgPSB0aGlzLnBhcnNlVGV4dEFuZEVudGl0eU5vZGVzKCB0ZXh0ICk7XG5cdFx0XHRcdG5vZGVzLnB1c2guYXBwbHkoIG5vZGVzLCB0ZXh0QW5kRW50aXR5Tm9kZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG5vZGVzO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBQYXJzZXMgdGV4dCBhbmQgSFRNTCBlbnRpdHkgbm9kZXMgZnJvbSBhIGdpdmVuIHN0cmluZy4gVGhlIGlucHV0IHN0cmluZyBzaG91bGQgbm90IGhhdmUgYW55IEhUTUwgdGFncyAoZWxlbWVudHMpXG5cdCAqIHdpdGhpbiBpdC5cblx0ICogXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHBhcnNlLlxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGVbXX0gQW4gYXJyYXkgb2YgSHRtbE5vZGVzIHRvIHJlcHJlc2VudCB0aGUgXG5cdCAqICAge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5UZXh0Tm9kZSBUZXh0Tm9kZXN9IGFuZCB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkVudGl0eU5vZGUgRW50aXR5Tm9kZXN9IGZvdW5kLlxuXHQgKi9cblx0cGFyc2VUZXh0QW5kRW50aXR5Tm9kZXMgOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHR2YXIgbm9kZXMgPSBbXSxcblx0XHQgICAgdGV4dEFuZEVudGl0eVRva2VucyA9IEF1dG9saW5rZXIuVXRpbC5zcGxpdEFuZENhcHR1cmUoIHRleHQsIHRoaXMuaHRtbENoYXJhY3RlckVudGl0aWVzUmVnZXggKTsgIC8vIHNwbGl0IGF0IEhUTUwgZW50aXRpZXMsIGJ1dCBpbmNsdWRlIHRoZSBIVE1MIGVudGl0aWVzIGluIHRoZSByZXN1bHRzIGFycmF5XG5cdFx0XG5cdFx0Ly8gRXZlcnkgZXZlbiBudW1iZXJlZCB0b2tlbiBpcyBhIFRleHROb2RlLCBhbmQgZXZlcnkgb2RkIG51bWJlcmVkIHRva2VuIGlzIGFuIEVudGl0eU5vZGVcblx0XHQvLyBGb3IgZXhhbXBsZTogYW4gaW5wdXQgYHRleHRgIG9mIFwiVGVzdCAmcXVvdDt0aGlzJnF1b3Q7IHRvZGF5XCIgd291bGQgdHVybiBpbnRvIHRoZSBcblx0XHQvLyAgIGB0ZXh0QW5kRW50aXR5VG9rZW5zYDogWyAnVGVzdCAnLCAnJnF1b3Q7JywgJ3RoaXMnLCAnJnF1b3Q7JywgJyB0b2RheScgXVxuXHRcdGZvciggdmFyIGkgPSAwLCBsZW4gPSB0ZXh0QW5kRW50aXR5VG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyICkge1xuXHRcdFx0dmFyIHRleHRUb2tlbiA9IHRleHRBbmRFbnRpdHlUb2tlbnNbIGkgXSxcblx0XHRcdCAgICBlbnRpdHlUb2tlbiA9IHRleHRBbmRFbnRpdHlUb2tlbnNbIGkgKyAxIF07XG5cdFx0XHRcblx0XHRcdGlmKCB0ZXh0VG9rZW4gKSBub2Rlcy5wdXNoKCB0aGlzLmNyZWF0ZVRleHROb2RlKCB0ZXh0VG9rZW4gKSApO1xuXHRcdFx0aWYoIGVudGl0eVRva2VuICkgbm9kZXMucHVzaCggdGhpcy5jcmVhdGVFbnRpdHlOb2RlKCBlbnRpdHlUb2tlbiApICk7XG5cdFx0fVxuXHRcdHJldHVybiBub2Rlcztcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGFuIHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRWxlbWVudE5vZGUgRWxlbWVudE5vZGV9LlxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRhZ1RleHQgVGhlIGZ1bGwgdGV4dCBvZiB0aGUgdGFnIChlbGVtZW50KSB0aGF0IHdhcyBtYXRjaGVkLCBpbmNsdWRpbmcgaXRzIGF0dHJpYnV0ZXMuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0YWdOYW1lIFRoZSBuYW1lIG9mIHRoZSB0YWcuIEV4OiBBbiAmbHQ7aW1nJmd0OyB0YWcgd291bGQgYmUgcGFzc2VkIHRvIHRoaXMgbWV0aG9kIGFzIFwiaW1nXCIuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNDbG9zaW5nVGFnIGB0cnVlYCBpZiBpdCdzIGEgY2xvc2luZyB0YWcsIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHJldHVybiB7QXV0b2xpbmtlci5odG1sUGFyc2VyLkVsZW1lbnROb2RlfVxuXHQgKi9cblx0Y3JlYXRlRWxlbWVudE5vZGUgOiBmdW5jdGlvbiggdGFnVGV4dCwgdGFnTmFtZSwgaXNDbG9zaW5nVGFnICkge1xuXHRcdHJldHVybiBuZXcgQXV0b2xpbmtlci5odG1sUGFyc2VyLkVsZW1lbnROb2RlKCB7XG5cdFx0XHR0ZXh0ICAgIDogdGFnVGV4dCxcblx0XHRcdHRhZ05hbWUgOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRjbG9zaW5nIDogaXNDbG9zaW5nVGFnXG5cdFx0fSApO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkVudGl0eU5vZGUgRW50aXR5Tm9kZX0uXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCB0aGF0IHdhcyBtYXRjaGVkIGZvciB0aGUgSFRNTCBlbnRpdHkgKHN1Y2ggYXMgJyZhbXA7bmJzcDsnKS5cblx0ICogQHJldHVybiB7QXV0b2xpbmtlci5odG1sUGFyc2VyLkVudGl0eU5vZGV9XG5cdCAqL1xuXHRjcmVhdGVFbnRpdHlOb2RlIDogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIG5ldyBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRW50aXR5Tm9kZSggeyB0ZXh0OiB0ZXh0IH0gKTtcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5UZXh0Tm9kZSBUZXh0Tm9kZX0uXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCB0aGF0IHdhcyBtYXRjaGVkLlxuXHQgKiBAcmV0dXJuIHtBdXRvbGlua2VyLmh0bWxQYXJzZXIuVGV4dE5vZGV9XG5cdCAqL1xuXHRjcmVhdGVUZXh0Tm9kZSA6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiBuZXcgQXV0b2xpbmtlci5odG1sUGFyc2VyLlRleHROb2RlKCB7IHRleHQ6IHRleHQgfSApO1xuXHR9XG5cdFxufSApO1xuLypnbG9iYWwgQXV0b2xpbmtlciAqL1xuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzcyBBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGVcbiAqIFxuICogUmVwcmVzZW50cyBhbiBIVE1MIG5vZGUgZm91bmQgaW4gYW4gaW5wdXQgc3RyaW5nLiBBbiBIVE1MIG5vZGUgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gKiBcbiAqIDEuIEFuIHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRWxlbWVudE5vZGUgRWxlbWVudE5vZGV9LCB3aGljaCByZXByZXNlbnRzIEhUTUwgdGFncy5cbiAqIDIuIEEge0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5UZXh0Tm9kZSBUZXh0Tm9kZX0sIHdoaWNoIHJlcHJlc2VudHMgdGV4dCBvdXRzaWRlIG9yIHdpdGhpbiBIVE1MIHRhZ3MuXG4gKiAzLiBBIHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRW50aXR5Tm9kZSBFbnRpdHlOb2RlfSwgd2hpY2ggcmVwcmVzZW50cyBvbmUgb2YgdGhlIGtub3duIEhUTUxcbiAqICAgIGVudGl0aWVzIHRoYXQgQXV0b2xpbmtlciBsb29rcyBmb3IuIFRoaXMgaW5jbHVkZXMgY29tbW9uIG9uZXMgc3VjaCBhcyAmYW1wO3F1b3Q7IGFuZCAmYW1wO25ic3A7XG4gKi9cbkF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZSA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge1N0cmluZ30gdGV4dCAocmVxdWlyZWQpXG5cdCAqIFxuXHQgKiBUaGUgb3JpZ2luYWwgdGV4dCB0aGF0IHdhcyBtYXRjaGVkIGZvciB0aGUgSHRtbE5vZGUuIFxuXHQgKiBcblx0ICogLSBJbiB0aGUgY2FzZSBvZiBhbiB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkVsZW1lbnROb2RlIEVsZW1lbnROb2RlfSwgdGhpcyB3aWxsIGJlIHRoZSB0YWcnc1xuXHQgKiAgIHRleHQuXG5cdCAqIC0gSW4gdGhlIGNhc2Ugb2YgYSB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLlRleHROb2RlIFRleHROb2RlfSwgdGhpcyB3aWxsIGJlIHRoZSB0ZXh0IGl0c2VsZi5cblx0ICogLSBJbiB0aGUgY2FzZSBvZiBhIHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRW50aXR5Tm9kZSBFbnRpdHlOb2RlfSwgdGhpcyB3aWxsIGJlIHRoZSB0ZXh0IG9mXG5cdCAqICAgdGhlIEhUTUwgZW50aXR5LlxuXHQgKi9cblx0dGV4dCA6IFwiXCIsXG5cdFxuXHRcblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gY2ZnIFRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgZm9yIHRoZSBNYXRjaCBpbnN0YW5jZSwgc3BlY2lmaWVkIGluIGFuIE9iamVjdCAobWFwKS5cblx0ICovXG5cdGNvbnN0cnVjdG9yIDogZnVuY3Rpb24oIGNmZyApIHtcblx0XHRBdXRvbGlua2VyLlV0aWwuYXNzaWduKCB0aGlzLCBjZmcgKTtcblx0fSxcblxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgbmFtZSBmb3IgdGhlIHR5cGUgb2Ygbm9kZSB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cblx0ICogXG5cdCAqIEBhYnN0cmFjdFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRUeXBlIDogQXV0b2xpbmtlci5VdGlsLmFic3RyYWN0TWV0aG9kLFxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIHtAbGluayAjdGV4dH0gZm9yIHRoZSBIdG1sTm9kZS5cblx0ICogXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldFRleHQgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50ZXh0O1xuXHR9XG5cbn0gKTtcbi8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cbi8qKlxuICogQGNsYXNzIEF1dG9saW5rZXIuaHRtbFBhcnNlci5FbGVtZW50Tm9kZVxuICogQGV4dGVuZHMgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxOb2RlXG4gKiBcbiAqIFJlcHJlc2VudHMgYW4gSFRNTCBlbGVtZW50IG5vZGUgdGhhdCBoYXMgYmVlbiBwYXJzZWQgYnkgdGhlIHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbFBhcnNlcn0uXG4gKiBcbiAqIFNlZSB0aGlzIGNsYXNzJ3Mgc3VwZXJjbGFzcyAoe0BsaW5rIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZX0pIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbkF1dG9saW5rZXIuaHRtbFBhcnNlci5FbGVtZW50Tm9kZSA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZSwge1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge1N0cmluZ30gdGFnTmFtZSAocmVxdWlyZWQpXG5cdCAqIFxuXHQgKiBUaGUgbmFtZSBvZiB0aGUgdGFnIHRoYXQgd2FzIG1hdGNoZWQuXG5cdCAqL1xuXHR0YWdOYW1lIDogJycsXG5cdFxuXHQvKipcblx0ICogQGNmZyB7Qm9vbGVhbn0gY2xvc2luZyAocmVxdWlyZWQpXG5cdCAqIFxuXHQgKiBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQgKHRhZykgaXMgYSBjbG9zaW5nIHRhZywgYGZhbHNlYCBpZiBpdHMgYW4gb3BlbmluZyB0YWcuXG5cdCAqL1xuXHRjbG9zaW5nIDogZmFsc2UsXG5cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlIG9mIG5vZGUgdGhhdCB0aGlzIGNsYXNzIHJlcHJlc2VudHMuXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRUeXBlIDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdlbGVtZW50Jztcblx0fSxcblx0XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCdzICh0YWcncykgbmFtZS4gRXg6IGZvciBhbiAmbHQ7aW1nJmd0OyB0YWcsIHJldHVybnMgXCJpbWdcIi5cblx0ICogXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldFRhZ05hbWUgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50YWdOYW1lO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBIVE1MIGVsZW1lbnQgKHRhZykgaXMgYSBjbG9zaW5nIHRhZy4gRXg6ICZsdDtkaXYmZ3Q7IHJldHVybnNcblx0ICogYGZhbHNlYCwgd2hpbGUgJmx0Oy9kaXYmZ3Q7IHJldHVybnMgYHRydWVgLlxuXHQgKiBcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGlzQ2xvc2luZyA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNsb3Npbmc7XG5cdH1cblx0XG59ICk7XG4vKmdsb2JhbCBBdXRvbGlua2VyICovXG4vKipcbiAqIEBjbGFzcyBBdXRvbGlua2VyLmh0bWxQYXJzZXIuRW50aXR5Tm9kZVxuICogQGV4dGVuZHMgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxOb2RlXG4gKiBcbiAqIFJlcHJlc2VudHMgYSBrbm93biBIVE1MIGVudGl0eSBub2RlIHRoYXQgaGFzIGJlZW4gcGFyc2VkIGJ5IHRoZSB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxQYXJzZXJ9LlxuICogRXg6ICcmYW1wO25ic3A7Jywgb3IgJyZhbXAjMTYwOycgKHdoaWNoIHdpbGwgYmUgcmV0cmlldmFibGUgZnJvbSB0aGUge0BsaW5rICNnZXRUZXh0fSBtZXRob2QuXG4gKiBcbiAqIE5vdGUgdGhhdCB0aGlzIGNsYXNzIHdpbGwgb25seSBiZSByZXR1cm5lZCBmcm9tIHRoZSBIdG1sUGFyc2VyIGZvciB0aGUgc2V0IG9mIGNoZWNrZWQgSFRNTCBlbnRpdHkgbm9kZXMgXG4gKiBkZWZpbmVkIGJ5IHRoZSB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxQYXJzZXIjaHRtbENoYXJhY3RlckVudGl0aWVzUmVnZXh9LlxuICogXG4gKiBTZWUgdGhpcyBjbGFzcydzIHN1cGVyY2xhc3MgKHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGV9KSBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG5BdXRvbGlua2VyLmh0bWxQYXJzZXIuRW50aXR5Tm9kZSA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZSwge1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgbmFtZSBmb3IgdGhlIHR5cGUgb2Ygbm9kZSB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cblx0ICogXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldFR5cGUgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ2VudGl0eSc7XG5cdH1cblx0XG59ICk7XG4vKmdsb2JhbCBBdXRvbGlua2VyICovXG4vKipcbiAqIEBjbGFzcyBBdXRvbGlua2VyLmh0bWxQYXJzZXIuVGV4dE5vZGVcbiAqIEBleHRlbmRzIEF1dG9saW5rZXIuaHRtbFBhcnNlci5IdG1sTm9kZVxuICogXG4gKiBSZXByZXNlbnRzIGEgdGV4dCBub2RlIHRoYXQgaGFzIGJlZW4gcGFyc2VkIGJ5IHRoZSB7QGxpbmsgQXV0b2xpbmtlci5odG1sUGFyc2VyLkh0bWxQYXJzZXJ9LlxuICogXG4gKiBTZWUgdGhpcyBjbGFzcydzIHN1cGVyY2xhc3MgKHtAbGluayBBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGV9KSBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG5BdXRvbGlua2VyLmh0bWxQYXJzZXIuVGV4dE5vZGUgPSBBdXRvbGlua2VyLlV0aWwuZXh0ZW5kKCBBdXRvbGlua2VyLmh0bWxQYXJzZXIuSHRtbE5vZGUsIHtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlIG9mIG5vZGUgdGhhdCB0aGlzIGNsYXNzIHJlcHJlc2VudHMuXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRUeXBlIDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICd0ZXh0Jztcblx0fVxuXHRcbn0gKTtcbi8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cbi8qKlxuICogQHByaXZhdGVcbiAqIEBjbGFzcyBBdXRvbGlua2VyLm1hdGNoUGFyc2VyLk1hdGNoUGFyc2VyXG4gKiBAZXh0ZW5kcyBPYmplY3RcbiAqIFxuICogVXNlZCBieSBBdXRvbGlua2VyIHRvIHBhcnNlIHtAbGluayAjdXJscyBVUkxzfSwge0BsaW5rICNlbWFpbHMgZW1haWwgYWRkcmVzc2VzfSwgYW5kIHtAbGluayAjdHdpdHRlciBUd2l0dGVyIGhhbmRsZXN9LCBcbiAqIGdpdmVuIGFuIGlucHV0IHN0cmluZyBvZiB0ZXh0LlxuICogXG4gKiBUaGUgTWF0Y2hQYXJzZXIgaXMgZmVkIGEgbm9uLUhUTUwgc3RyaW5nIGluIG9yZGVyIHRvIHNlYXJjaCBvdXQgVVJMcywgZW1haWwgYWRkcmVzc2VzIGFuZCBUd2l0dGVyIGhhbmRsZXMuIEF1dG9saW5rZXJcbiAqIGZpcnN0IHVzZXMgdGhlIHtAbGluayBIdG1sUGFyc2VyfSB0byBcIndhbGsgYXJvdW5kXCIgSFRNTCB0YWdzLCBhbmQgdGhlbiB0aGUgdGV4dCBhcm91bmQgdGhlIEhUTUwgdGFncyBpcyBwYXNzZWQgaW50b1xuICogdGhlIE1hdGNoUGFyc2VyIGluIG9yZGVyIHRvIGZpbmQgdGhlIGFjdHVhbCBtYXRjaGVzLlxuICovXG5BdXRvbGlua2VyLm1hdGNoUGFyc2VyLk1hdGNoUGFyc2VyID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggT2JqZWN0LCB7XG5cdFxuXHQvKipcblx0ICogQGNmZyB7Qm9vbGVhbn0gdXJsc1xuXHQgKiBcblx0ICogYHRydWVgIGlmIG1pc2NlbGxhbmVvdXMgVVJMcyBzaG91bGQgYmUgYXV0b21hdGljYWxseSBsaW5rZWQsIGBmYWxzZWAgaWYgdGhleSBzaG91bGQgbm90IGJlLlxuXHQgKi9cblx0dXJscyA6IHRydWUsXG5cdFxuXHQvKipcblx0ICogQGNmZyB7Qm9vbGVhbn0gZW1haWxcblx0ICogXG5cdCAqIGB0cnVlYCBpZiBlbWFpbCBhZGRyZXNzZXMgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgbGlua2VkLCBgZmFsc2VgIGlmIHRoZXkgc2hvdWxkIG5vdCBiZS5cblx0ICovXG5cdGVtYWlsIDogdHJ1ZSxcblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtCb29sZWFufSB0d2l0dGVyXG5cdCAqIFxuXHQgKiBgdHJ1ZWAgaWYgVHdpdHRlciBoYW5kbGVzIChcIkBleGFtcGxlXCIpIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGxpbmtlZCwgYGZhbHNlYCBpZiB0aGV5IHNob3VsZCBub3QgYmUuXG5cdCAqL1xuXHR0d2l0dGVyIDogdHJ1ZSxcblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtCb29sZWFufSBzdHJpcFByZWZpeFxuXHQgKiBcblx0ICogYHRydWVgIGlmICdodHRwOi8vJyBvciAnaHR0cHM6Ly8nIGFuZC9vciB0aGUgJ3d3dy4nIHNob3VsZCBiZSBzdHJpcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgVVJMIGxpbmtzJyB0ZXh0XG5cdCAqIGluIHtAbGluayBBdXRvbGlua2VyLm1hdGNoLlVybCBVUkwgbWF0Y2hlc30sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuXHQgKiBcblx0ICogVE9ETzogSGFuZGxlIHRoaXMgYmVmb3JlIGEgVVJMIE1hdGNoIG9iamVjdCBpcyBpbnN0YW50aWF0ZWQuXG5cdCAqL1xuXHRzdHJpcFByZWZpeCA6IHRydWUsXG5cdFxuXHRcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBtYXRjaGVyUmVnZXhcblx0ICogXG5cdCAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIFVSTHMsIGVtYWlsIGFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgaGFuZGxlcy5cblx0ICogXG5cdCAqIFRoaXMgcmVndWxhciBleHByZXNzaW9uIGhhcyB0aGUgZm9sbG93aW5nIGNhcHR1cmluZyBncm91cHM6XG5cdCAqIFxuXHQgKiAxLiBHcm91cCB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZXJlIGlzIGEgVHdpdHRlciBoYW5kbGUgbWF0Y2ggKGkuZS4gXFxAc29tZVR3aXR0ZXJVc2VyKS4gU2ltcGx5IGNoZWNrIGZvciBpdHMgXG5cdCAqICAgIGV4aXN0ZW5jZSB0byBkZXRlcm1pbmUgaWYgdGhlcmUgaXMgYSBUd2l0dGVyIGhhbmRsZSBtYXRjaC4gVGhlIG5leHQgY291cGxlIG9mIGNhcHR1cmluZyBncm91cHMgZ2l2ZSBpbmZvcm1hdGlvbiBcblx0ICogICAgYWJvdXQgdGhlIFR3aXR0ZXIgaGFuZGxlIG1hdGNoLlxuXHQgKiAyLiBUaGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBcXEBzaWduIGluIGEgVHdpdHRlciBoYW5kbGUuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgdGhlcmUgYXJlIG5vIGxvb2tiZWhpbmRzIGluXG5cdCAqICAgIEpTIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGFuZCBjYW4gYmUgdXNlZCB0byByZWNvbnN0cnVjdCB0aGUgb3JpZ2luYWwgc3RyaW5nIGluIGEgcmVwbGFjZSgpLlxuXHQgKiAzLiBUaGUgVHdpdHRlciBoYW5kbGUgaXRzZWxmIGluIGEgVHdpdHRlciBtYXRjaC4gSWYgdGhlIG1hdGNoIGlzICdAc29tZVR3aXR0ZXJVc2VyJywgdGhlIGhhbmRsZSBpcyAnc29tZVR3aXR0ZXJVc2VyJy5cblx0ICogNC4gR3JvdXAgdGhhdCBtYXRjaGVzIGFuIGVtYWlsIGFkZHJlc3MuIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBtYXRjaCBpcyBhbiBlbWFpbCBhZGRyZXNzLCBhcyB3ZWxsIGFzIGhvbGRpbmcgdGhlIGZ1bGwgXG5cdCAqICAgIGFkZHJlc3MuIEV4OiAnbWVAbXkuY29tJ1xuXHQgKiA1LiBHcm91cCB0aGF0IG1hdGNoZXMgYSBVUkwgaW4gdGhlIGlucHV0IHRleHQuIEV4OiAnaHR0cDovL2dvb2dsZS5jb20nLCAnd3d3Lmdvb2dsZS5jb20nLCBvciBqdXN0ICdnb29nbGUuY29tJy5cblx0ICogICAgVGhpcyBhbHNvIGluY2x1ZGVzIGEgcGF0aCwgdXJsIHBhcmFtZXRlcnMsIG9yIGhhc2ggYW5jaG9ycy4gRXg6IGdvb2dsZS5jb20vcGF0aC90by9maWxlP3ExPTEmcTI9MiNteUFuY2hvclxuXHQgKiA2LiBHcm91cCB0aGF0IG1hdGNoZXMgYSBwcm90b2NvbCBVUkwgKGkuZS4gJ2h0dHA6Ly9nb29nbGUuY29tJykuIFRoaXMgaXMgdXNlZCB0byBtYXRjaCBwcm90b2NvbCBVUkxzIHdpdGgganVzdCBhIHNpbmdsZVxuXHQgKiAgICB3b3JkLCBsaWtlICdodHRwOi8vbG9jYWxob3N0Jywgd2hlcmUgd2Ugd29uJ3QgZG91YmxlIGNoZWNrIHRoYXQgdGhlIGRvbWFpbiBuYW1lIGhhcyBhdCBsZWFzdCBvbmUgJy4nIGluIGl0LlxuXHQgKiA3LiBBIHByb3RvY29sLXJlbGF0aXZlICgnLy8nKSBtYXRjaCBmb3IgdGhlIGNhc2Ugb2YgYSAnd3d3LicgcHJlZml4ZWQgVVJMLiBXaWxsIGJlIGFuIGVtcHR5IHN0cmluZyBpZiBpdCBpcyBub3QgYSBcblx0ICogICAgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2guIFdlIG5lZWQgdG8ga25vdyB0aGUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgJy8vJyBpbiBvcmRlciB0byBkZXRlcm1pbmUgaWYgaXQgaXMgYSB2YWxpZCBtYXRjaFxuXHQgKiAgICBvciB0aGUgLy8gd2FzIGluIGEgc3RyaW5nIHdlIGRvbid0IHdhbnQgdG8gYXV0by1saW5rLlxuXHQgKiA4LiBBIHByb3RvY29sLXJlbGF0aXZlICgnLy8nKSBtYXRjaCBmb3IgdGhlIGNhc2Ugb2YgYSBrbm93biBUTEQgcHJlZml4ZWQgVVJMLiBXaWxsIGJlIGFuIGVtcHR5IHN0cmluZyBpZiBpdCBpcyBub3QgYSBcblx0ICogICAgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2guIFNlZSAjNiBmb3IgbW9yZSBpbmZvLiBcblx0ICovXG5cdG1hdGNoZXJSZWdleCA6IChmdW5jdGlvbigpIHtcblx0XHR2YXIgdHdpdHRlclJlZ2V4ID0gLyhefFteXFx3XSlAKFxcd3sxLDE1fSkvLCAgICAgICAgICAgICAgLy8gRm9yIG1hdGNoaW5nIGEgdHdpdHRlciBoYW5kbGUuIEV4OiBAZ3JlZ29yeV9qYWNvYnNcblx0XHQgICAgXG5cdFx0ICAgIGVtYWlsUmVnZXggPSAvKD86W1xcLTs6Jj1cXCtcXCQsXFx3XFwuXStAKS8sICAgICAgICAgICAgIC8vIHNvbWV0aGluZ0AgZm9yIGVtYWlsIGFkZHJlc3NlcyAoYS5rLmEuIGxvY2FsLXBhcnQpXG5cdFx0ICAgIFxuXHRcdCAgICBwcm90b2NvbFJlZ2V4ID0gLyg/OltBLVphLXpdWy0uK0EtWmEtejAtOV0rOig/IVtBLVphLXpdWy0uK0EtWmEtejAtOV0rOlxcL1xcLykoPyFcXGQrXFwvPykoPzpcXC9cXC8pPykvLCAgLy8gbWF0Y2ggcHJvdG9jb2wsIGFsbG93IGluIGZvcm1hdCBcImh0dHA6Ly9cIiBvciBcIm1haWx0bzpcIi4gSG93ZXZlciwgZG8gbm90IG1hdGNoIHRoZSBmaXJzdCBwYXJ0IG9mIHNvbWV0aGluZyBsaWtlICdsaW5rOmh0dHA6Ly93d3cuZ29vZ2xlLmNvbScgKGkuZS4gZG9uJ3QgbWF0Y2ggXCJsaW5rOlwiKS4gQWxzbywgbWFrZSBzdXJlIHdlIGRvbid0IGludGVycHJldCAnZ29vZ2xlLmNvbTo4MDAwJyBhcyBpZiAnZ29vZ2xlLmNvbScgd2FzIGEgcHJvdG9jb2wgaGVyZSAoaS5lLiBpZ25vcmUgYSB0cmFpbGluZyBwb3J0IG51bWJlciBpbiB0aGlzIHJlZ2V4KVxuXHRcdCAgICB3d3dSZWdleCA9IC8oPzp3d3dcXC4pLywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHdpdGggJ3d3dy4nXG5cdFx0ICAgIGRvbWFpbk5hbWVSZWdleCA9IC9bQS1aYS16MC05XFwuXFwtXSpbQS1aYS16MC05XFwtXS8sICAvLyBhbnl0aGluZyBsb29raW5nIGF0IGFsbCBsaWtlIGEgZG9tYWluLCBub24tdW5pY29kZSBkb21haW5zLCBub3QgZW5kaW5nIGluIGEgcGVyaW9kXG5cdFx0ICAgIHRsZFJlZ2V4ID0gL1xcLig/OmludGVybmF0aW9uYWx8Y29uc3RydWN0aW9ufGNvbnRyYWN0b3JzfGVudGVycHJpc2VzfHBob3RvZ3JhcGh5fHByb2R1Y3Rpb25zfGZvdW5kYXRpb258aW1tb2JpbGllbnxpbmR1c3RyaWVzfG1hbmFnZW1lbnR8cHJvcGVydGllc3x0ZWNobm9sb2d5fGNocmlzdG1hc3xjb21tdW5pdHl8ZGlyZWN0b3J5fGVkdWNhdGlvbnxlcXVpcG1lbnR8aW5zdGl0dXRlfG1hcmtldGluZ3xzb2x1dGlvbnN8dmFjYXRpb25zfGJhcmdhaW5zfGJvdXRpcXVlfGJ1aWxkZXJzfGNhdGVyaW5nfGNsZWFuaW5nfGNsb3RoaW5nfGNvbXB1dGVyfGRlbW9jcmF0fGRpYW1vbmRzfGdyYXBoaWNzfGhvbGRpbmdzfGxpZ2h0aW5nfHBhcnRuZXJzfHBsdW1iaW5nfHN1cHBsaWVzfHRyYWluaW5nfHZlbnR1cmVzfGFjYWRlbXl8Y2FyZWVyc3xjb21wYW55fGNydWlzZXN8ZG9tYWluc3xleHBvc2VkfGZsaWdodHN8ZmxvcmlzdHxnYWxsZXJ5fGd1aXRhcnN8aG9saWRheXxraXRjaGVufG5ldXN0YXJ8b2tpbmF3YXxyZWNpcGVzfHJlbnRhbHN8cmV2aWV3c3xzaGlrc2hhfHNpbmdsZXN8c3VwcG9ydHxzeXN0ZW1zfGFnZW5jeXxiZXJsaW58Y2FtZXJhfGNlbnRlcnxjb2ZmZWV8Y29uZG9zfGRhdGluZ3xlc3RhdGV8ZXZlbnRzfGV4cGVydHxmdXRib2x8a2F1ZmVufGx1eHVyeXxtYWlzb258bW9uYXNofG11c2V1bXxuYWdveWF8cGhvdG9zfHJlcGFpcnxyZXBvcnR8c29jaWFsfHN1cHBseXx0YXR0b298dGllbmRhfHRyYXZlbHx2aWFqZXN8dmlsbGFzfHZpc2lvbnx2b3Rpbmd8dm95YWdlfGFjdG9yfGJ1aWxkfGNhcmRzfGNoZWFwfGNvZGVzfGRhbmNlfGVtYWlsfGdsYXNzfGhvdXNlfG1hbmdvfG5pbmphfHBhcnRzfHBob3RvfHNob2VzfHNvbGFyfHRvZGF5fHRva3lvfHRvb2xzfHdhdGNofHdvcmtzfGFlcm98YXJwYXxhc2lhfGJlc3R8YmlrZXxibHVlfGJ1enp8Y2FtcHxjbHVifGNvb2x8Y29vcHxmYXJtfGZpc2h8Z2lmdHxndXJ1fGluZm98am9ic3xraXdpfGtyZWR8bGFuZHxsaW1vfGxpbmt8bWVudXxtb2JpfG1vZGF8bmFtZXxwaWNzfHBpbmt8cG9zdHxxcG9ufHJpY2h8cnVocnxzZXh5fHRpcHN8dm90ZXx2b3RvfHdhbmd8d2llbnx3aWtpfHpvbmV8YmFyfGJpZHxiaXp8Y2FifGNhdHxjZW98Y29tfGVkdXxnb3Z8aW50fGtpbXxtaWx8bmV0fG9ubHxvcmd8cHJvfHB1YnxyZWR8dGVsfHVub3x3ZWR8eHh4fHh5enxhY3xhZHxhZXxhZnxhZ3xhaXxhbHxhbXxhbnxhb3xhcXxhcnxhc3xhdHxhdXxhd3xheHxhenxiYXxiYnxiZHxiZXxiZnxiZ3xiaHxiaXxianxibXxibnxib3xicnxic3xidHxidnxid3xieXxienxjYXxjY3xjZHxjZnxjZ3xjaHxjaXxja3xjbHxjbXxjbnxjb3xjcnxjdXxjdnxjd3xjeHxjeXxjenxkZXxkanxka3xkbXxkb3xkenxlY3xlZXxlZ3xlcnxlc3xldHxldXxmaXxmanxma3xmbXxmb3xmcnxnYXxnYnxnZHxnZXxnZnxnZ3xnaHxnaXxnbHxnbXxnbnxncHxncXxncnxnc3xndHxndXxnd3xneXxoa3xobXxobnxocnxodHxodXxpZHxpZXxpbHxpbXxpbnxpb3xpcXxpcnxpc3xpdHxqZXxqbXxqb3xqcHxrZXxrZ3xraHxraXxrbXxrbnxrcHxrcnxrd3xreXxrenxsYXxsYnxsY3xsaXxsa3xscnxsc3xsdHxsdXxsdnxseXxtYXxtY3xtZHxtZXxtZ3xtaHxta3xtbHxtbXxtbnxtb3xtcHxtcXxtcnxtc3xtdHxtdXxtdnxtd3xteHxteXxtenxuYXxuY3xuZXxuZnxuZ3xuaXxubHxub3xucHxucnxudXxuenxvbXxwYXxwZXxwZnxwZ3xwaHxwa3xwbHxwbXxwbnxwcnxwc3xwdHxwd3xweXxxYXxyZXxyb3xyc3xydXxyd3xzYXxzYnxzY3xzZHxzZXxzZ3xzaHxzaXxzanxza3xzbHxzbXxzbnxzb3xzcnxzdHxzdXxzdnxzeHxzeXxzenx0Y3x0ZHx0Znx0Z3x0aHx0anx0a3x0bHx0bXx0bnx0b3x0cHx0cnx0dHx0dnx0d3x0enx1YXx1Z3x1a3x1c3x1eXx1enx2YXx2Y3x2ZXx2Z3x2aXx2bnx2dXx3Znx3c3x5ZXx5dHx6YXx6bXx6dylcXGIvLCAgIC8vIG1hdGNoIG91ciBrbm93biB0b3AgbGV2ZWwgZG9tYWlucyAoVExEcylcblx0XHQgICAgXG5cdFx0ICAgIC8vIEFsbG93IG9wdGlvbmFsIHBhdGgsIHF1ZXJ5IHN0cmluZywgYW5kIGhhc2ggYW5jaG9yLCBub3QgZW5kaW5nIGluIHRoZSBmb2xsb3dpbmcgY2hhcmFjdGVyczogXCI/ITosLjtcIlxuXHRcdCAgICAvLyBodHRwOi8vYmxvZy5jb2Rpbmdob3Jyb3IuY29tL3RoZS1wcm9ibGVtLXdpdGgtdXJscy9cblx0XHQgICAgdXJsU3VmZml4UmVnZXggPSAvW1xcLUEtWmEtejAtOSsmQCNcXC8lPX5fKCl8JyQqXFxbXFxdPyE6LC47XSpbXFwtQS1aYS16MC05KyZAI1xcLyU9fl8oKXwnJCpcXFtcXF1dLztcblx0XHRcblx0XHRyZXR1cm4gbmV3IFJlZ0V4cCggW1xuXHRcdFx0JygnLCAgLy8gKioqIENhcHR1cmluZyBncm91cCAkMSwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2hlY2sgZm9yIGEgdHdpdHRlciBoYW5kbGUgbWF0Y2guIFVzZSBncm91cCAkMyBmb3IgdGhlIGFjdHVhbCB0d2l0dGVyIGhhbmRsZSB0aG91Z2guICQyIG1heSBiZSB1c2VkIHRvIHJlY29uc3RydWN0IHRoZSBvcmlnaW5hbCBzdHJpbmcgaW4gYSByZXBsYWNlKCkgXG5cdFx0XHRcdC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDIsIHdoaWNoIG1hdGNoZXMgdGhlIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGJlZm9yZSB0aGUgJ0AnIHNpZ24gKG5lZWRlZCBiZWNhdXNlIG9mIG5vIGxvb2tiZWhpbmRzKSwgYW5kIFxuXHRcdFx0XHQvLyAqKiogQ2FwdHVyaW5nIGdyb3VwICQzLCB3aGljaCBtYXRjaGVzIHRoZSBhY3R1YWwgdHdpdHRlciBoYW5kbGVcblx0XHRcdFx0dHdpdHRlclJlZ2V4LnNvdXJjZSxcblx0XHRcdCcpJyxcblx0XHRcdFxuXHRcdFx0J3wnLFxuXHRcdFx0XG5cdFx0XHQnKCcsICAvLyAqKiogQ2FwdHVyaW5nIGdyb3VwICQ0LCB3aGljaCBpcyB1c2VkIHRvIGRldGVybWluZSBhbiBlbWFpbCBtYXRjaFxuXHRcdFx0XHRlbWFpbFJlZ2V4LnNvdXJjZSxcblx0XHRcdFx0ZG9tYWluTmFtZVJlZ2V4LnNvdXJjZSxcblx0XHRcdFx0dGxkUmVnZXguc291cmNlLFxuXHRcdFx0JyknLFxuXHRcdFx0XG5cdFx0XHQnfCcsXG5cdFx0XHRcblx0XHRcdCcoJywgIC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDUsIHdoaWNoIGlzIHVzZWQgdG8gbWF0Y2ggYSBVUkxcblx0XHRcdFx0Jyg/OicsIC8vIHBhcmVucyB0byBjb3ZlciBtYXRjaCBmb3IgcHJvdG9jb2wgKG9wdGlvbmFsKSwgYW5kIGRvbWFpblxuXHRcdFx0XHRcdCcoJywgIC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDYsIGZvciBhIHByb3RvY29sLXByZWZpeGVkIHVybCAoZXg6IGh0dHA6Ly9nb29nbGUuY29tKVxuXHRcdFx0XHRcdFx0cHJvdG9jb2xSZWdleC5zb3VyY2UsXG5cdFx0XHRcdFx0XHRkb21haW5OYW1lUmVnZXguc291cmNlLFxuXHRcdFx0XHRcdCcpJyxcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQnfCcsXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Jyg/OicsICAvLyBub24tY2FwdHVyaW5nIHBhcmVuIGZvciBhICd3d3cuJyBwcmVmaXhlZCB1cmwgKGV4OiB3d3cuZ29vZ2xlLmNvbSlcblx0XHRcdFx0XHRcdCcoLj8vLyk/JywgIC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDcgZm9yIGFuIG9wdGlvbmFsIHByb3RvY29sLXJlbGF0aXZlIFVSTC4gTXVzdCBiZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcgb3Igc3RhcnQgd2l0aCBhIG5vbi13b3JkIGNoYXJhY3RlclxuXHRcdFx0XHRcdFx0d3d3UmVnZXguc291cmNlLFxuXHRcdFx0XHRcdFx0ZG9tYWluTmFtZVJlZ2V4LnNvdXJjZSxcblx0XHRcdFx0XHQnKScsXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0J3wnLFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdCcoPzonLCAgLy8gbm9uLWNhcHR1cmluZyBwYXJlbiBmb3Iga25vd24gYSBUTEQgdXJsIChleDogZ29vZ2xlLmNvbSlcblx0XHRcdFx0XHRcdCcoLj8vLyk/JywgIC8vICoqKiBDYXB0dXJpbmcgZ3JvdXAgJDggZm9yIGFuIG9wdGlvbmFsIHByb3RvY29sLXJlbGF0aXZlIFVSTC4gTXVzdCBiZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcgb3Igc3RhcnQgd2l0aCBhIG5vbi13b3JkIGNoYXJhY3RlclxuXHRcdFx0XHRcdFx0ZG9tYWluTmFtZVJlZ2V4LnNvdXJjZSxcblx0XHRcdFx0XHRcdHRsZFJlZ2V4LnNvdXJjZSxcblx0XHRcdFx0XHQnKScsXG5cdFx0XHRcdCcpJyxcblx0XHRcdFx0XG5cdFx0XHRcdCcoPzonICsgdXJsU3VmZml4UmVnZXguc291cmNlICsgJyk/JywgIC8vIG1hdGNoIGZvciBwYXRoLCBxdWVyeSBzdHJpbmcsIGFuZC9vciBoYXNoIGFuY2hvciAtIG9wdGlvbmFsXG5cdFx0XHQnKSdcblx0XHRdLmpvaW4oIFwiXCIgKSwgJ2dpJyApO1xuXHR9ICkoKSxcblx0XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gY2hhckJlZm9yZVByb3RvY29sUmVsTWF0Y2hSZWdleFxuXHQgKiBcblx0ICogVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHJldHJpZXZlIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIGEgcHJvdG9jb2wtcmVsYXRpdmUgVVJMIG1hdGNoLlxuXHQgKiBcblx0ICogVGhpcyBpcyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIHtAbGluayAjbWF0Y2hlclJlZ2V4fSwgd2hpY2ggbmVlZHMgdG8gZ3JhYiB0aGUgY2hhcmFjdGVyIGJlZm9yZSBhIHByb3RvY29sLXJlbGF0aXZlXG5cdCAqICcvLycgZHVlIHRvIHRoZSBsYWNrIG9mIGEgbmVnYXRpdmUgbG9vay1iZWhpbmQgaW4gSmF2YVNjcmlwdCByZWd1bGFyIGV4cHJlc3Npb25zLiBUaGUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgbWF0Y2ggaXMgc3RyaXBwZWRcblx0ICogZnJvbSB0aGUgVVJMLlxuXHQgKi9cblx0Y2hhckJlZm9yZVByb3RvY29sUmVsTWF0Y2hSZWdleCA6IC9eKC4pP1xcL1xcLy8sXG5cdFxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHByb3BlcnR5IHtBdXRvbGlua2VyLk1hdGNoVmFsaWRhdG9yfSBtYXRjaFZhbGlkYXRvclxuXHQgKiBcblx0ICogVGhlIE1hdGNoVmFsaWRhdG9yIG9iamVjdCwgdXNlZCB0byBmaWx0ZXIgb3V0IGFueSBmYWxzZSBwb3NpdGl2ZXMgZnJvbSB0aGUge0BsaW5rICNtYXRjaGVyUmVnZXh9LiBTZWVcblx0ICoge0BsaW5rIEF1dG9saW5rZXIuTWF0Y2hWYWxpZGF0b3J9IGZvciBkZXRhaWxzLlxuXHQgKi9cblx0XG5cdFxuXHQvKipcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbY2ZnXSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgQW5jaG9yVGFnQnVpbGRlciBpbnN0YW5jZSwgc3BlY2lmaWVkIGluIGFuIE9iamVjdCAobWFwKS5cblx0ICovXG5cdGNvbnN0cnVjdG9yIDogZnVuY3Rpb24oIGNmZyApIHtcblx0XHRBdXRvbGlua2VyLlV0aWwuYXNzaWduKCB0aGlzLCBjZmcgKTtcblx0XG5cdFx0dGhpcy5tYXRjaFZhbGlkYXRvciA9IG5ldyBBdXRvbGlua2VyLk1hdGNoVmFsaWRhdG9yKCk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgaW5wdXQgYHRleHRgIHRvIHNlYXJjaCBmb3IgVVJMcy9lbWFpbHMvVHdpdHRlciBoYW5kbGVzLCBhbmQgY2FsbHMgdGhlIGByZXBsYWNlRm5gXG5cdCAqIHRvIGFsbG93IHJlcGxhY2VtZW50cyBvZiB0aGUgbWF0Y2hlcy4gUmV0dXJucyB0aGUgYHRleHRgIHdpdGggbWF0Y2hlcyByZXBsYWNlZC5cblx0ICogXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHNlYXJjaCBhbmQgcmVwYWNlIG1hdGNoZXMgaW4uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcGxhY2VGbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSByZXBsYWNlbWVudHMuIFRoZSBmdW5jdGlvbiB0YWtlcyBhXG5cdCAqICAgc2luZ2xlIGFyZ3VtZW50LCBhIHtAbGluayBBdXRvbGlua2VyLm1hdGNoLk1hdGNofSBvYmplY3QsIGFuZCBzaG91bGQgcmV0dXJuIHRoZSB0ZXh0IHRoYXQgc2hvdWxkXG5cdCAqICAgbWFrZSB0aGUgcmVwbGFjZW1lbnQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dE9iaj13aW5kb3ddIFRoZSBjb250ZXh0IG9iamVjdCAoXCJzY29wZVwiKSB0byBydW4gdGhlIGByZXBsYWNlRm5gIGluLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRyZXBsYWNlIDogZnVuY3Rpb24oIHRleHQsIHJlcGxhY2VGbiwgY29udGV4dE9iaiApIHtcblx0XHR2YXIgbWUgPSB0aGlzOyAgLy8gZm9yIGNsb3N1cmVcblx0XHRcblx0XHRyZXR1cm4gdGV4dC5yZXBsYWNlKCB0aGlzLm1hdGNoZXJSZWdleCwgZnVuY3Rpb24oIG1hdGNoU3RyLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDggKSB7XG5cdFx0XHR2YXIgbWF0Y2hEZXNjT2JqID0gbWUucHJvY2Vzc0NhbmRpZGF0ZU1hdGNoKCBtYXRjaFN0ciwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcsICQ4ICk7ICAvLyBcIm1hdGNoIGRlc2NyaXB0aW9uXCIgb2JqZWN0XG5cdFx0XHRcblx0XHRcdC8vIFJldHVybiBvdXQgd2l0aCBubyBjaGFuZ2VzIGZvciBtYXRjaCB0eXBlcyB0aGF0IGFyZSBkaXNhYmxlZCAodXJsLCBlbWFpbCwgdHdpdHRlciksIG9yIGZvciBtYXRjaGVzIHRoYXQgYXJlIFxuXHRcdFx0Ly8gaW52YWxpZCAoZmFsc2UgcG9zaXRpdmVzIGZyb20gdGhlIG1hdGNoZXJSZWdleCwgd2hpY2ggY2FuJ3QgdXNlIGxvb2stYmVoaW5kcyBzaW5jZSB0aGV5IGFyZSB1bmF2YWlsYWJsZSBpbiBKUykuXG5cdFx0XHRpZiggIW1hdGNoRGVzY09iaiApIHtcblx0XHRcdFx0cmV0dXJuIG1hdGNoU3RyO1xuXHRcdFx0XHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEdlbmVyYXRlIHJlcGxhY2VtZW50IHRleHQgZm9yIHRoZSBtYXRjaCBmcm9tIHRoZSBgcmVwbGFjZUZuYFxuXHRcdFx0XHR2YXIgcmVwbGFjZVN0ciA9IHJlcGxhY2VGbi5jYWxsKCBjb250ZXh0T2JqLCBtYXRjaERlc2NPYmoubWF0Y2ggKTtcblx0XHRcdFx0cmV0dXJuIG1hdGNoRGVzY09iai5wcmVmaXhTdHIgKyByZXBsYWNlU3RyICsgbWF0Y2hEZXNjT2JqLnN1ZmZpeFN0cjtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFByb2Nlc3NlcyBhIGNhbmRpZGF0ZSBtYXRjaCBmcm9tIHRoZSB7QGxpbmsgI21hdGNoZXJSZWdleH0uIFxuXHQgKiBcblx0ICogTm90IGFsbCBtYXRjaGVzIGZvdW5kIGJ5IHRoZSByZWdleCBhcmUgYWN0dWFsIFVSTC9lbWFpbC9Ud2l0dGVyIG1hdGNoZXMsIGFzIGRldGVybWluZWQgYnkgdGhlIHtAbGluayAjbWF0Y2hWYWxpZGF0b3J9LiBJblxuXHQgKiB0aGlzIGNhc2UsIHRoZSBtZXRob2QgcmV0dXJucyBgbnVsbGAuIE90aGVyd2lzZSwgYSB2YWxpZCBPYmplY3Qgd2l0aCBgcHJlZml4U3RyYCwgYG1hdGNoYCwgYW5kIGBzdWZmaXhTdHJgIGlzIHJldHVybmVkLlxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoU3RyIFRoZSBmdWxsIG1hdGNoIHRoYXQgd2FzIGZvdW5kIGJ5IHRoZSB7QGxpbmsgI21hdGNoZXJSZWdleH0uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0d2l0dGVyTWF0Y2ggVGhlIG1hdGNoZWQgdGV4dCBvZiBhIFR3aXR0ZXIgaGFuZGxlLCBpZiB0aGUgbWF0Y2ggaXMgYSBUd2l0dGVyIG1hdGNoLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHdpdHRlckhhbmRsZVByZWZpeFdoaXRlc3BhY2VDaGFyIFRoZSB3aGl0ZXNwYWNlIGNoYXIgYmVmb3JlIHRoZSBAIHNpZ24gaW4gYSBUd2l0dGVyIGhhbmRsZSBtYXRjaC4gVGhpcyBcblx0ICogICBpcyBuZWVkZWQgYmVjYXVzZSBvZiBubyBsb29rYmVoaW5kcyBpbiBKUyByZWdleGVzLCBhbmQgaXMgbmVlZCB0byByZS1pbmNsdWRlIHRoZSBjaGFyYWN0ZXIgZm9yIHRoZSBhbmNob3IgdGFnIHJlcGxhY2VtZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHdpdHRlckhhbmRsZSBUaGUgYWN0dWFsIFR3aXR0ZXIgdXNlciAoaS5lIHRoZSB3b3JkIGFmdGVyIHRoZSBAIHNpZ24gaW4gYSBUd2l0dGVyIG1hdGNoKS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGVtYWlsQWRkcmVzc01hdGNoIFRoZSBtYXRjaGVkIGVtYWlsIGFkZHJlc3MgZm9yIGFuIGVtYWlsIGFkZHJlc3MgbWF0Y2guXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxNYXRjaCBUaGUgbWF0Y2hlZCBVUkwgc3RyaW5nIGZvciBhIFVSTCBtYXRjaC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sVXJsTWF0Y2ggVGhlIG1hdGNoIFVSTCBzdHJpbmcgZm9yIGEgcHJvdG9jb2wgbWF0Y2guIEV4OiAnaHR0cDovL3lhaG9vLmNvbScuIFRoaXMgaXMgdXNlZCB0byBtYXRjaFxuXHQgKiAgIHNvbWV0aGluZyBsaWtlICdodHRwOi8vbG9jYWxob3N0Jywgd2hlcmUgd2Ugd29uJ3QgZG91YmxlIGNoZWNrIHRoYXQgdGhlIGRvbWFpbiBuYW1lIGhhcyBhdCBsZWFzdCBvbmUgJy4nIGluIGl0LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gd3d3UHJvdG9jb2xSZWxhdGl2ZU1hdGNoIFRoZSAnLy8nIGZvciBhIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoIGZyb20gYSAnd3d3JyB1cmwsIHdpdGggdGhlIGNoYXJhY3RlciB0aGF0IFxuXHQgKiAgIGNvbWVzIGJlZm9yZSB0aGUgJy8vJy5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHRsZFByb3RvY29sUmVsYXRpdmVNYXRjaCBUaGUgJy8vJyBmb3IgYSBwcm90b2NvbC1yZWxhdGl2ZSBtYXRjaCBmcm9tIGEgVExEICh0b3AgbGV2ZWwgZG9tYWluKSBtYXRjaCwgd2l0aCBcblx0ICogICB0aGUgY2hhcmFjdGVyIHRoYXQgY29tZXMgYmVmb3JlIHRoZSAnLy8nLlxuXHQgKiAgIFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgXCJtYXRjaCBkZXNjcmlwdGlvbiBvYmplY3RcIi4gVGhpcyB3aWxsIGJlIGBudWxsYCBpZiB0aGUgbWF0Y2ggd2FzIGludmFsaWQsIG9yIGlmIGEgbWF0Y2ggdHlwZSBpcyBkaXNhYmxlZC5cblx0ICogICBPdGhlcndpc2UsIHRoaXMgd2lsbCBiZSBhbiBPYmplY3QgKG1hcCkgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cdCAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJuLnByZWZpeFN0ciBUaGUgY2hhcihzKSB0aGF0IHNob3VsZCBiZSBwcmVwZW5kZWQgdG8gdGhlIHJlcGxhY2VtZW50IHN0cmluZy4gVGhlc2UgYXJlIGNoYXIocykgdGhhdFxuXHQgKiAgIHdlcmUgbmVlZGVkIHRvIGJlIGluY2x1ZGVkIGZyb20gdGhlIHJlZ2V4IG1hdGNoIHRoYXQgd2VyZSBpZ25vcmVkIGJ5IHByb2Nlc3NpbmcgY29kZSwgYW5kIHNob3VsZCBiZSByZS1pbnNlcnRlZCBpbnRvIFxuXHQgKiAgIHRoZSByZXBsYWNlbWVudCBzdHJlYW0uXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJuLnN1ZmZpeFN0ciBUaGUgY2hhcihzKSB0aGF0IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgcmVwbGFjZW1lbnQgc3RyaW5nLiBUaGVzZSBhcmUgY2hhcihzKSB0aGF0XG5cdCAqICAgd2VyZSBuZWVkZWQgdG8gYmUgaW5jbHVkZWQgZnJvbSB0aGUgcmVnZXggbWF0Y2ggdGhhdCB3ZXJlIGlnbm9yZWQgYnkgcHJvY2Vzc2luZyBjb2RlLCBhbmQgc2hvdWxkIGJlIHJlLWluc2VydGVkIGludG8gXG5cdCAqICAgdGhlIHJlcGxhY2VtZW50IHN0cmVhbS5cblx0ICogQHJldHVybiB7QXV0b2xpbmtlci5tYXRjaC5NYXRjaH0gcmV0dXJuLm1hdGNoIFRoZSBNYXRjaCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBtYXRjaCB0aGF0IHdhcyBmb3VuZC5cblx0ICovXG5cdHByb2Nlc3NDYW5kaWRhdGVNYXRjaCA6IGZ1bmN0aW9uKCBcblx0XHRtYXRjaFN0ciwgdHdpdHRlck1hdGNoLCB0d2l0dGVySGFuZGxlUHJlZml4V2hpdGVzcGFjZUNoYXIsIHR3aXR0ZXJIYW5kbGUsIFxuXHRcdGVtYWlsQWRkcmVzc01hdGNoLCB1cmxNYXRjaCwgcHJvdG9jb2xVcmxNYXRjaCwgd3d3UHJvdG9jb2xSZWxhdGl2ZU1hdGNoLCB0bGRQcm90b2NvbFJlbGF0aXZlTWF0Y2hcblx0KSB7XG5cdFx0Ly8gTm90ZTogVGhlIGBtYXRjaFN0cmAgdmFyaWFibGUgd2lsIGJlIGZpeGVkIHVwIHRvIHJlbW92ZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vIGxvbmdlciBuZWVkZWQgKHdoaWNoIHdpbGwgXG5cdFx0Ly8gYmUgYWRkZWQgdG8gYHByZWZpeFN0cmAgYW5kIGBzdWZmaXhTdHJgKS5cblx0XHRcblx0XHR2YXIgcHJvdG9jb2xSZWxhdGl2ZU1hdGNoID0gd3d3UHJvdG9jb2xSZWxhdGl2ZU1hdGNoIHx8IHRsZFByb3RvY29sUmVsYXRpdmVNYXRjaCxcblx0XHQgICAgbWF0Y2gsICAvLyBXaWxsIGJlIGFuIEF1dG9saW5rZXIubWF0Y2guTWF0Y2ggb2JqZWN0XG5cdFx0ICAgIFxuXHRcdCAgICBwcmVmaXhTdHIgPSBcIlwiLCAgICAgICAvLyBBIHN0cmluZyB0byB1c2UgdG8gcHJlZml4IHRoZSBhbmNob3IgdGFnIHRoYXQgaXMgY3JlYXRlZC4gVGhpcyBpcyBuZWVkZWQgZm9yIHRoZSBUd2l0dGVyIGhhbmRsZSBtYXRjaFxuXHRcdCAgICBzdWZmaXhTdHIgPSBcIlwiOyAgICAgICAvLyBBIHN0cmluZyB0byBzdWZmaXggdGhlIGFuY2hvciB0YWcgdGhhdCBpcyBjcmVhdGVkLiBUaGlzIGlzIHVzZWQgaWYgdGhlcmUgaXMgYSB0cmFpbGluZyBwYXJlbnRoZXNpcyB0aGF0IHNob3VsZCBub3QgYmUgYXV0by1saW5rZWQuXG5cdFx0ICAgIFxuXHRcdFxuXHRcdC8vIFJldHVybiBvdXQgd2l0aCBgbnVsbGAgZm9yIG1hdGNoIHR5cGVzIHRoYXQgYXJlIGRpc2FibGVkICh1cmwsIGVtYWlsLCB0d2l0dGVyKSwgb3IgZm9yIG1hdGNoZXMgdGhhdCBhcmUgXG5cdFx0Ly8gaW52YWxpZCAoZmFsc2UgcG9zaXRpdmVzIGZyb20gdGhlIG1hdGNoZXJSZWdleCwgd2hpY2ggY2FuJ3QgdXNlIGxvb2stYmVoaW5kcyBzaW5jZSB0aGV5IGFyZSB1bmF2YWlsYWJsZSBpbiBKUykuXG5cdFx0aWYoXG5cdFx0XHQoIHR3aXR0ZXJNYXRjaCAmJiAhdGhpcy50d2l0dGVyICkgfHwgKCBlbWFpbEFkZHJlc3NNYXRjaCAmJiAhdGhpcy5lbWFpbCApIHx8ICggdXJsTWF0Y2ggJiYgIXRoaXMudXJscyApIHx8XG5cdFx0XHQhdGhpcy5tYXRjaFZhbGlkYXRvci5pc1ZhbGlkTWF0Y2goIHVybE1hdGNoLCBwcm90b2NvbFVybE1hdGNoLCBwcm90b2NvbFJlbGF0aXZlTWF0Y2ggKSBcblx0XHQpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRcblx0XHQvLyBIYW5kbGUgYSBjbG9zaW5nIHBhcmVudGhlc2lzIGF0IHRoZSBlbmQgb2YgdGhlIG1hdGNoLCBhbmQgZXhjbHVkZSBpdCBpZiB0aGVyZSBpcyBub3QgYSBtYXRjaGluZyBvcGVuIHBhcmVudGhlc2lzXG5cdFx0Ly8gaW4gdGhlIG1hdGNoIGl0c2VsZi4gXG5cdFx0aWYoIHRoaXMubWF0Y2hIYXNVbmJhbGFuY2VkQ2xvc2luZ1BhcmVuKCBtYXRjaFN0ciApICkge1xuXHRcdFx0bWF0Y2hTdHIgPSBtYXRjaFN0ci5zdWJzdHIoIDAsIG1hdGNoU3RyLmxlbmd0aCAtIDEgKTsgIC8vIHJlbW92ZSB0aGUgdHJhaWxpbmcgXCIpXCJcblx0XHRcdHN1ZmZpeFN0ciA9IFwiKVwiOyAgLy8gdGhpcyB3aWxsIGJlIGFkZGVkIGFmdGVyIHRoZSBnZW5lcmF0ZWQgPGE+IHRhZ1xuXHRcdH1cblx0XHRcblx0XHRcblx0XHRpZiggZW1haWxBZGRyZXNzTWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IG5ldyBBdXRvbGlua2VyLm1hdGNoLkVtYWlsKCB7IG1hdGNoZWRUZXh0OiBtYXRjaFN0ciwgZW1haWw6IGVtYWlsQWRkcmVzc01hdGNoIH0gKTtcblx0XHRcdFxuXHRcdH0gZWxzZSBpZiggdHdpdHRlck1hdGNoICkge1xuXHRcdFx0Ly8gZml4IHVwIHRoZSBgbWF0Y2hTdHJgIGlmIHRoZXJlIHdhcyBhIHByZWNlZGluZyB3aGl0ZXNwYWNlIGNoYXIsIHdoaWNoIHdhcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIHRoZSBtYXRjaCBcblx0XHRcdC8vIGl0c2VsZiAoc2luY2UgdGhlcmUgYXJlIG5vIGxvb2stYmVoaW5kcyBpbiBKUyByZWdleGVzKVxuXHRcdFx0aWYoIHR3aXR0ZXJIYW5kbGVQcmVmaXhXaGl0ZXNwYWNlQ2hhciApIHtcblx0XHRcdFx0cHJlZml4U3RyID0gdHdpdHRlckhhbmRsZVByZWZpeFdoaXRlc3BhY2VDaGFyO1xuXHRcdFx0XHRtYXRjaFN0ciA9IG1hdGNoU3RyLnNsaWNlKCAxICk7ICAvLyByZW1vdmUgdGhlIHByZWZpeGVkIHdoaXRlc3BhY2UgY2hhciBmcm9tIHRoZSBtYXRjaFxuXHRcdFx0fVxuXHRcdFx0bWF0Y2ggPSBuZXcgQXV0b2xpbmtlci5tYXRjaC5Ud2l0dGVyKCB7IG1hdGNoZWRUZXh0OiBtYXRjaFN0ciwgdHdpdHRlckhhbmRsZTogdHdpdHRlckhhbmRsZSB9ICk7XG5cdFx0XHRcblx0XHR9IGVsc2UgeyAgLy8gdXJsIG1hdGNoXG5cdFx0XHQvLyBJZiBpdCdzIGEgcHJvdG9jb2wtcmVsYXRpdmUgJy8vJyBtYXRjaCwgcmVtb3ZlIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSAnLy8nICh3aGljaCB0aGUgbWF0Y2hlclJlZ2V4IG5lZWRlZFxuXHRcdFx0Ly8gdG8gbWF0Y2ggZHVlIHRvIHRoZSBsYWNrIG9mIGEgbmVnYXRpdmUgbG9vay1iZWhpbmQgaW4gSmF2YVNjcmlwdCByZWd1bGFyIGV4cHJlc3Npb25zKVxuXHRcdFx0aWYoIHByb3RvY29sUmVsYXRpdmVNYXRjaCApIHtcblx0XHRcdFx0dmFyIGNoYXJCZWZvcmVNYXRjaCA9IHByb3RvY29sUmVsYXRpdmVNYXRjaC5tYXRjaCggdGhpcy5jaGFyQmVmb3JlUHJvdG9jb2xSZWxNYXRjaFJlZ2V4IClbIDEgXSB8fCBcIlwiO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYoIGNoYXJCZWZvcmVNYXRjaCApIHsgIC8vIGZpeCB1cCB0aGUgYG1hdGNoU3RyYCBpZiB0aGVyZSB3YXMgYSBwcmVjZWRpbmcgY2hhciBiZWZvcmUgYSBwcm90b2NvbC1yZWxhdGl2ZSBtYXRjaCwgd2hpY2ggd2FzIG5lZWRlZCB0byBkZXRlcm1pbmUgdGhlIG1hdGNoIGl0c2VsZiAoc2luY2UgdGhlcmUgYXJlIG5vIGxvb2stYmVoaW5kcyBpbiBKUyByZWdleGVzKVxuXHRcdFx0XHRcdHByZWZpeFN0ciA9IGNoYXJCZWZvcmVNYXRjaDtcblx0XHRcdFx0XHRtYXRjaFN0ciA9IG1hdGNoU3RyLnNsaWNlKCAxICk7ICAvLyByZW1vdmUgdGhlIHByZWZpeGVkIGNoYXIgZnJvbSB0aGUgbWF0Y2hcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRtYXRjaCA9IG5ldyBBdXRvbGlua2VyLm1hdGNoLlVybCgge1xuXHRcdFx0XHRtYXRjaGVkVGV4dCA6IG1hdGNoU3RyLFxuXHRcdFx0XHR1cmwgOiBtYXRjaFN0cixcblx0XHRcdFx0cHJvdG9jb2xVcmxNYXRjaCA6ICEhcHJvdG9jb2xVcmxNYXRjaCxcblx0XHRcdFx0cHJvdG9jb2xSZWxhdGl2ZU1hdGNoIDogISFwcm90b2NvbFJlbGF0aXZlTWF0Y2gsXG5cdFx0XHRcdHN0cmlwUHJlZml4IDogdGhpcy5zdHJpcFByZWZpeFxuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4ge1xuXHRcdFx0cHJlZml4U3RyIDogcHJlZml4U3RyLFxuXHRcdFx0c3VmZml4U3RyIDogc3VmZml4U3RyLFxuXHRcdFx0bWF0Y2ggICAgIDogbWF0Y2hcblx0XHR9O1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIGEgbWF0Y2ggZm91bmQgaGFzIGFuIHVubWF0Y2hlZCBjbG9zaW5nIHBhcmVudGhlc2lzLiBJZiBzbywgdGhpcyBwYXJlbnRoZXNpcyB3aWxsIGJlIHJlbW92ZWRcblx0ICogZnJvbSB0aGUgbWF0Y2ggaXRzZWxmLCBhbmQgYXBwZW5kZWQgYWZ0ZXIgdGhlIGdlbmVyYXRlZCBhbmNob3IgdGFnIGluIHtAbGluayAjcHJvY2Vzc1RleHROb2RlfS5cblx0ICogXG5cdCAqIEEgbWF0Y2ggbWF5IGhhdmUgYW4gZXh0cmEgY2xvc2luZyBwYXJlbnRoZXNpcyBhdCB0aGUgZW5kIG9mIHRoZSBtYXRjaCBiZWNhdXNlIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gbXVzdCBpbmNsdWRlIHBhcmVudGhlc2lzXG5cdCAqIGZvciBVUkxzIHN1Y2ggYXMgXCJ3aWtpcGVkaWEuY29tL3NvbWV0aGluZ18oZGlzYW1iaWd1YXRpb24pXCIsIHdoaWNoIHNob3VsZCBiZSBhdXRvLWxpbmtlZC4gXG5cdCAqIFxuXHQgKiBIb3dldmVyLCBhbiBleHRyYSBwYXJlbnRoZXNpcyAqd2lsbCogYmUgaW5jbHVkZWQgd2hlbiB0aGUgVVJMIGl0c2VsZiBpcyB3cmFwcGVkIGluIHBhcmVudGhlc2lzLCBzdWNoIGFzIGluIHRoZSBjYXNlIG9mXG5cdCAqIFwiKHdpa2lwZWRpYS5jb20vc29tZXRoaW5nXyhkaXNhbWJpZ3VhdGlvbikpXCIuIEluIHRoaXMgY2FzZSwgdGhlIGxhc3QgY2xvc2luZyBwYXJlbnRoZXNpcyBzaG91bGQgKm5vdCogYmUgcGFydCBvZiB0aGUgVVJMIFxuXHQgKiBpdHNlbGYsIGFuZCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiBgdHJ1ZWAuXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbWF0Y2hTdHIgVGhlIGZ1bGwgbWF0Y2ggc3RyaW5nIGZyb20gdGhlIHtAbGluayAjbWF0Y2hlclJlZ2V4fS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZXJlIGlzIGFuIHVuYmFsYW5jZWQgY2xvc2luZyBwYXJlbnRoZXNpcyBhdCB0aGUgZW5kIG9mIHRoZSBgbWF0Y2hTdHJgLCBgZmFsc2VgIG90aGVyd2lzZS5cblx0ICovXG5cdG1hdGNoSGFzVW5iYWxhbmNlZENsb3NpbmdQYXJlbiA6IGZ1bmN0aW9uKCBtYXRjaFN0ciApIHtcblx0XHR2YXIgbGFzdENoYXIgPSBtYXRjaFN0ci5jaGFyQXQoIG1hdGNoU3RyLmxlbmd0aCAtIDEgKTtcblx0XHRcblx0XHRpZiggbGFzdENoYXIgPT09ICcpJyApIHtcblx0XHRcdHZhciBvcGVuUGFyZW5zTWF0Y2ggPSBtYXRjaFN0ci5tYXRjaCggL1xcKC9nICksXG5cdFx0XHQgICAgY2xvc2VQYXJlbnNNYXRjaCA9IG1hdGNoU3RyLm1hdGNoKCAvXFwpL2cgKSxcblx0XHRcdCAgICBudW1PcGVuUGFyZW5zID0gKCBvcGVuUGFyZW5zTWF0Y2ggJiYgb3BlblBhcmVuc01hdGNoLmxlbmd0aCApIHx8IDAsXG5cdFx0XHQgICAgbnVtQ2xvc2VQYXJlbnMgPSAoIGNsb3NlUGFyZW5zTWF0Y2ggJiYgY2xvc2VQYXJlbnNNYXRjaC5sZW5ndGggKSB8fCAwO1xuXHRcdFx0XG5cdFx0XHRpZiggbnVtT3BlblBhcmVucyA8IG51bUNsb3NlUGFyZW5zICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdFxufSApO1xuLypnbG9iYWwgQXV0b2xpbmtlciAqL1xuLypqc2hpbnQgc2NyaXB0dXJsOnRydWUgKi9cbi8qKlxuICogQHByaXZhdGVcbiAqIEBjbGFzcyBBdXRvbGlua2VyLk1hdGNoVmFsaWRhdG9yXG4gKiBAZXh0ZW5kcyBPYmplY3RcbiAqIFxuICogVXNlZCBieSBBdXRvbGlua2VyIHRvIGZpbHRlciBvdXQgZmFsc2UgcG9zaXRpdmVzIGZyb20gdGhlIHtAbGluayBBdXRvbGlua2VyI21hdGNoZXJSZWdleH0uXG4gKiBcbiAqIER1ZSB0byB0aGUgbGltaXRhdGlvbnMgb2YgcmVndWxhciBleHByZXNzaW9ucyAoaW5jbHVkaW5nIHRoZSBtaXNzaW5nIGZlYXR1cmUgb2YgbG9vay1iZWhpbmRzIGluIEpTIHJlZ3VsYXIgZXhwcmVzc2lvbnMpLFxuICogd2UgY2Fubm90IGFsd2F5cyBkZXRlcm1pbmUgdGhlIHZhbGlkaXR5IG9mIGEgZ2l2ZW4gbWF0Y2guIFRoaXMgY2xhc3MgYXBwbGllcyBhIGJpdCBvZiBhZGRpdGlvbmFsIGxvZ2ljIHRvIGZpbHRlciBvdXQgYW55XG4gKiBmYWxzZSBwb3NpdGl2ZXMgdGhhdCBoYXZlIGJlZW4gbWF0Y2hlZCBieSB0aGUge0BsaW5rIEF1dG9saW5rZXIjbWF0Y2hlclJlZ2V4fS5cbiAqL1xuQXV0b2xpbmtlci5NYXRjaFZhbGlkYXRvciA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIE9iamVjdCwge1xuXHRcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBpbnZhbGlkUHJvdG9jb2xSZWxNYXRjaFJlZ2V4XG5cdCAqIFxuXHQgKiBUaGUgcmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gY2hlY2sgYSBwb3RlbnRpYWwgcHJvdG9jb2wtcmVsYXRpdmUgVVJMIG1hdGNoLCBjb21pbmcgZnJvbSB0aGUgXG5cdCAqIHtAbGluayBBdXRvbGlua2VyI21hdGNoZXJSZWdleH0uIEEgcHJvdG9jb2wtcmVsYXRpdmUgVVJMIGlzLCBmb3IgZXhhbXBsZSwgXCIvL3lhaG9vLmNvbVwiXG5cdCAqIFxuXHQgKiBUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBjaGVja3MgdG8gc2VlIGlmIHRoZXJlIGlzIGEgd29yZCBjaGFyYWN0ZXIgYmVmb3JlIHRoZSAnLy8nIG1hdGNoIGluIG9yZGVyIHRvIGRldGVybWluZSBpZiBcblx0ICogd2Ugc2hvdWxkIGFjdHVhbGx5IGF1dG9saW5rIGEgcHJvdG9jb2wtcmVsYXRpdmUgVVJMLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHRoZXJlIGlzIG5vIG5lZ2F0aXZlIGxvb2stYmVoaW5kIGluIFxuXHQgKiBKYXZhU2NyaXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnMuIFxuXHQgKiBcblx0ICogRm9yIGluc3RhbmNlLCB3ZSB3YW50IHRvIGF1dG9saW5rIHNvbWV0aGluZyBsaWtlIFwiR28gdG86IC8vZ29vZ2xlLmNvbVwiLCBidXQgd2UgZG9uJ3Qgd2FudCB0byBhdXRvbGluayBzb21ldGhpbmcgXG5cdCAqIGxpa2UgXCJhYmMvL2dvb2dsZS5jb21cIlxuXHQgKi9cblx0aW52YWxpZFByb3RvY29sUmVsTWF0Y2hSZWdleCA6IC9eW1xcd11cXC9cXC8vLFxuXHRcblx0LyoqXG5cdCAqIFJlZ2V4IHRvIHRlc3QgZm9yIGEgZnVsbCBwcm90b2NvbCwgd2l0aCB0aGUgdHdvIHRyYWlsaW5nIHNsYXNoZXMuIEV4OiAnaHR0cDovLydcblx0ICogXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBoYXNGdWxsUHJvdG9jb2xSZWdleFxuXHQgKi9cblx0aGFzRnVsbFByb3RvY29sUmVnZXggOiAvXltBLVphLXpdWy0uK0EtWmEtejAtOV0rOlxcL1xcLy8sXG5cdFxuXHQvKipcblx0ICogUmVnZXggdG8gZmluZCB0aGUgVVJJIHNjaGVtZSwgc3VjaCBhcyAnbWFpbHRvOicuXG5cdCAqIFxuXHQgKiBUaGlzIGlzIHVzZWQgdG8gZmlsdGVyIG91dCAnamF2YXNjcmlwdDonIGFuZCAndmJzY3JpcHQ6JyBzY2hlbWVzLlxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHByb3BlcnR5IHtSZWdFeHB9IHVyaVNjaGVtZVJlZ2V4XG5cdCAqL1xuXHR1cmlTY2hlbWVSZWdleCA6IC9eW0EtWmEtel1bLS4rQS1aYS16MC05XSs6Lyxcblx0XG5cdC8qKlxuXHQgKiBSZWdleCB0byBkZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIHdvcmQgY2hhciBleGlzdHMgYWZ0ZXIgdGhlIHByb3RvY29sIChpLmUuIGFmdGVyIHRoZSAnOicpXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gaGFzV29yZENoYXJBZnRlclByb3RvY29sUmVnZXhcblx0ICovXG5cdGhhc1dvcmRDaGFyQWZ0ZXJQcm90b2NvbFJlZ2V4IDogLzpbXlxcc10qP1tBLVphLXpdLyxcblx0XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIG1hdGNoIGZvdW5kIGJ5IHtAbGluayBBdXRvbGlua2VyI3Byb2Nlc3NUZXh0Tm9kZX0gaXMgdmFsaWQuIFdpbGwgcmV0dXJuIGBmYWxzZWAgZm9yOlxuXHQgKiBcblx0ICogMSkgVVJMIG1hdGNoZXMgd2hpY2ggZG8gbm90IGhhdmUgYXQgbGVhc3QgaGF2ZSBvbmUgcGVyaW9kICgnLicpIGluIHRoZSBkb21haW4gbmFtZSAoZWZmZWN0aXZlbHkgc2tpcHBpbmcgb3ZlciBcblx0ICogICAgbWF0Y2hlcyBsaWtlIFwiYWJjOmRlZlwiKS4gSG93ZXZlciwgVVJMIG1hdGNoZXMgd2l0aCBhIHByb3RvY29sIHdpbGwgYmUgYWxsb3dlZCAoZXg6ICdodHRwOi8vbG9jYWxob3N0Jylcblx0ICogMikgVVJMIG1hdGNoZXMgd2hpY2ggZG8gbm90IGhhdmUgYXQgbGVhc3Qgb25lIHdvcmQgY2hhcmFjdGVyIGluIHRoZSBkb21haW4gbmFtZSAoZWZmZWN0aXZlbHkgc2tpcHBpbmcgb3ZlclxuXHQgKiAgICBtYXRjaGVzIGxpa2UgXCJnaXQ6MS4wXCIpLlxuXHQgKiAzKSBBIHByb3RvY29sLXJlbGF0aXZlIHVybCBtYXRjaCAoYSBVUkwgYmVnaW5uaW5nIHdpdGggJy8vJykgd2hvc2UgcHJldmlvdXMgY2hhcmFjdGVyIGlzIGEgd29yZCBjaGFyYWN0ZXIgXG5cdCAqICAgIChlZmZlY3RpdmVseSBza2lwcGluZyBvdmVyIHN0cmluZ3MgbGlrZSBcImFiYy8vZ29vZ2xlLmNvbVwiKVxuXHQgKiBcblx0ICogT3RoZXJ3aXNlLCByZXR1cm5zIGB0cnVlYC5cblx0ICogXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxNYXRjaCBUaGUgbWF0Y2hlZCBVUkwsIGlmIHRoZXJlIHdhcyBvbmUuIFdpbGwgYmUgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSBtYXRjaCBpcyBub3QgYSBVUkwgbWF0Y2guXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbFVybE1hdGNoIFRoZSBtYXRjaCBVUkwgc3RyaW5nIGZvciBhIHByb3RvY29sIG1hdGNoLiBFeDogJ2h0dHA6Ly95YWhvby5jb20nLiBUaGlzIGlzIHVzZWQgdG8gbWF0Y2hcblx0ICogICBzb21ldGhpbmcgbGlrZSAnaHR0cDovL2xvY2FsaG9zdCcsIHdoZXJlIHdlIHdvbid0IGRvdWJsZSBjaGVjayB0aGF0IHRoZSBkb21haW4gbmFtZSBoYXMgYXQgbGVhc3Qgb25lICcuJyBpbiBpdC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sUmVsYXRpdmVNYXRjaCBUaGUgcHJvdG9jb2wtcmVsYXRpdmUgc3RyaW5nIGZvciBhIFVSTCBtYXRjaCAoaS5lLiAnLy8nKSwgcG9zc2libHkgd2l0aCBhIHByZWNlZGluZ1xuXHQgKiAgIGNoYXJhY3RlciAoZXgsIGEgc3BhY2UsIHN1Y2ggYXM6ICcgLy8nLCBvciBhIGxldHRlciwgc3VjaCBhczogJ2EvLycpLiBUaGUgbWF0Y2ggaXMgaW52YWxpZCBpZiB0aGVyZSBpcyBhIHdvcmQgY2hhcmFjdGVyXG5cdCAqICAgcHJlY2VkaW5nIHRoZSAnLy8nLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIG1hdGNoIGdpdmVuIGlzIHZhbGlkIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBvciBgZmFsc2VgIGlmIHRoZSBtYXRjaCBpcyBpbnZhbGlkIGFuZC9vciBcblx0ICogICBzaG91bGQganVzdCBub3QgYmUgcHJvY2Vzc2VkLlxuXHQgKi9cblx0aXNWYWxpZE1hdGNoIDogZnVuY3Rpb24oIHVybE1hdGNoLCBwcm90b2NvbFVybE1hdGNoLCBwcm90b2NvbFJlbGF0aXZlTWF0Y2ggKSB7XG5cdFx0aWYoXG5cdFx0XHQoIHByb3RvY29sVXJsTWF0Y2ggJiYgIXRoaXMuaXNWYWxpZFVyaVNjaGVtZSggcHJvdG9jb2xVcmxNYXRjaCApICkgfHxcblx0XHRcdHRoaXMudXJsTWF0Y2hEb2VzTm90SGF2ZVByb3RvY29sT3JEb3QoIHVybE1hdGNoLCBwcm90b2NvbFVybE1hdGNoICkgfHwgICAgICAgLy8gQXQgbGVhc3Qgb25lIHBlcmlvZCAoJy4nKSBtdXN0IGV4aXN0IGluIHRoZSBVUkwgbWF0Y2ggZm9yIHVzIHRvIGNvbnNpZGVyIGl0IGFuIGFjdHVhbCBVUkwsICp1bmxlc3MqIGl0IHdhcyBhIGZ1bGwgcHJvdG9jb2wgbWF0Y2ggKGxpa2UgJ2h0dHA6Ly9sb2NhbGhvc3QnKVxuXHRcdFx0dGhpcy51cmxNYXRjaERvZXNOb3RIYXZlQXRMZWFzdE9uZVdvcmRDaGFyKCB1cmxNYXRjaCwgcHJvdG9jb2xVcmxNYXRjaCApIHx8ICAvLyBBdCBsZWFzdCBvbmUgbGV0dGVyIGNoYXJhY3RlciBtdXN0IGV4aXN0IGluIHRoZSBkb21haW4gbmFtZSBhZnRlciBhIHByb3RvY29sIG1hdGNoLiBFeDogc2tpcCBvdmVyIHNvbWV0aGluZyBsaWtlIFwiZ2l0OjEuMFwiXG5cdFx0XHR0aGlzLmlzSW52YWxpZFByb3RvY29sUmVsYXRpdmVNYXRjaCggcHJvdG9jb2xSZWxhdGl2ZU1hdGNoICkgICAgICAgICAgICAgICAgIC8vIEEgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2ggd2hpY2ggaGFzIGEgd29yZCBjaGFyYWN0ZXIgaW4gZnJvbnQgb2YgaXQgKHNvIHdlIGNhbiBza2lwIHNvbWV0aGluZyBsaWtlIFwiYWJjLy9nb29nbGUuY29tXCIpXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBVUkkgc2NoZW1lIGlzIGEgdmFsaWQgc2NoZW1lIHRvIGJlIGF1dG9saW5rZWQuIFJldHVybnMgYGZhbHNlYCBpZiB0aGUgc2NoZW1lIGlzIFxuXHQgKiAnamF2YXNjcmlwdDonIG9yICd2YnNjcmlwdDonXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdXJpU2NoZW1lTWF0Y2ggVGhlIG1hdGNoIFVSTCBzdHJpbmcgZm9yIGEgZnVsbCBVUkkgc2NoZW1lIG1hdGNoLiBFeDogJ2h0dHA6Ly95YWhvby5jb20nIFxuXHQgKiAgIG9yICdtYWlsdG86YUBhLmNvbScuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgc2NoZW1lIGlzIGEgdmFsaWQgb25lLCBgZmFsc2VgIG90aGVyd2lzZS5cblx0ICovXG5cdGlzVmFsaWRVcmlTY2hlbWUgOiBmdW5jdGlvbiggdXJpU2NoZW1lTWF0Y2ggKSB7XG5cdFx0dmFyIHVyaVNjaGVtZSA9IHVyaVNjaGVtZU1hdGNoLm1hdGNoKCB0aGlzLnVyaVNjaGVtZVJlZ2V4IClbIDAgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFxuXHRcdHJldHVybiAoIHVyaVNjaGVtZSAhPT0gJ2phdmFzY3JpcHQ6JyAmJiB1cmlTY2hlbWUgIT09ICd2YnNjcmlwdDonICk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgYSBVUkwgbWF0Y2ggZG9lcyBub3QgaGF2ZSBlaXRoZXI6XG5cdCAqIFxuXHQgKiBhKSBhIGZ1bGwgcHJvdG9jb2wgKGkuZS4gJ2h0dHA6Ly8nKSwgb3Jcblx0ICogYikgYXQgbGVhc3Qgb25lIGRvdCAoJy4nKSBpbiB0aGUgZG9tYWluIG5hbWUgKGZvciBhIG5vbi1mdWxsLXByb3RvY29sIG1hdGNoKS5cblx0ICogXG5cdCAqIEVpdGhlciBzaXR1YXRpb24gaXMgY29uc2lkZXJlZCBhbiBpbnZhbGlkIFVSTCAoZXg6ICdnaXQ6ZCcgZG9lcyBub3QgaGF2ZSBlaXRoZXIgdGhlICc6Ly8nIHBhcnQsIG9yIGF0IGxlYXN0IG9uZSBkb3Rcblx0ICogaW4gdGhlIGRvbWFpbiBuYW1lLiBJZiB0aGUgbWF0Y2ggd2FzICdnaXQ6YWJjLmNvbScsIHdlIHdvdWxkIGNvbnNpZGVyIHRoaXMgdmFsaWQuKVxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVybE1hdGNoIFRoZSBtYXRjaGVkIFVSTCwgaWYgdGhlcmUgd2FzIG9uZS4gV2lsbCBiZSBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIG1hdGNoIGlzIG5vdCBhIFVSTCBtYXRjaC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sVXJsTWF0Y2ggVGhlIG1hdGNoIFVSTCBzdHJpbmcgZm9yIGEgcHJvdG9jb2wgbWF0Y2guIEV4OiAnaHR0cDovL3lhaG9vLmNvbScuIFRoaXMgaXMgdXNlZCB0byBtYXRjaFxuXHQgKiAgIHNvbWV0aGluZyBsaWtlICdodHRwOi8vbG9jYWxob3N0Jywgd2hlcmUgd2Ugd29uJ3QgZG91YmxlIGNoZWNrIHRoYXQgdGhlIGRvbWFpbiBuYW1lIGhhcyBhdCBsZWFzdCBvbmUgJy4nIGluIGl0LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIFVSTCBtYXRjaCBkb2VzIG5vdCBoYXZlIGEgZnVsbCBwcm90b2NvbCwgb3IgYXQgbGVhc3Qgb25lIGRvdCAoJy4nKSBpbiBhIG5vbi1mdWxsLXByb3RvY29sXG5cdCAqICAgbWF0Y2guXG5cdCAqL1xuXHR1cmxNYXRjaERvZXNOb3RIYXZlUHJvdG9jb2xPckRvdCA6IGZ1bmN0aW9uKCB1cmxNYXRjaCwgcHJvdG9jb2xVcmxNYXRjaCApIHtcblx0XHRyZXR1cm4gKCAhIXVybE1hdGNoICYmICggIXByb3RvY29sVXJsTWF0Y2ggfHwgIXRoaXMuaGFzRnVsbFByb3RvY29sUmVnZXgudGVzdCggcHJvdG9jb2xVcmxNYXRjaCApICkgJiYgdXJsTWF0Y2guaW5kZXhPZiggJy4nICkgPT09IC0xICk7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgYSBVUkwgbWF0Y2ggZG9lcyBub3QgaGF2ZSBhdCBsZWFzdCBvbmUgd29yZCBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIHByb3RvY29sIChpLmUuIGluIHRoZSBkb21haW4gbmFtZSkuXG5cdCAqIFxuXHQgKiBBdCBsZWFzdCBvbmUgbGV0dGVyIGNoYXJhY3RlciBtdXN0IGV4aXN0IGluIHRoZSBkb21haW4gbmFtZSBhZnRlciBhIHByb3RvY29sIG1hdGNoLiBFeDogc2tpcCBvdmVyIHNvbWV0aGluZyBcblx0ICogbGlrZSBcImdpdDoxLjBcIlxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVybE1hdGNoIFRoZSBtYXRjaGVkIFVSTCwgaWYgdGhlcmUgd2FzIG9uZS4gV2lsbCBiZSBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIG1hdGNoIGlzIG5vdCBhIFVSTCBtYXRjaC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sVXJsTWF0Y2ggVGhlIG1hdGNoIFVSTCBzdHJpbmcgZm9yIGEgcHJvdG9jb2wgbWF0Y2guIEV4OiAnaHR0cDovL3lhaG9vLmNvbScuIFRoaXMgaXMgdXNlZCB0b1xuXHQgKiAgIGtub3cgd2hldGhlciBvciBub3Qgd2UgaGF2ZSBhIHByb3RvY29sIGluIHRoZSBVUkwgc3RyaW5nLCBpbiBvcmRlciB0byBjaGVjayBmb3IgYSB3b3JkIGNoYXJhY3RlciBhZnRlciB0aGUgcHJvdG9jb2xcblx0ICogICBzZXBhcmF0b3IgKCc6JykuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgVVJMIG1hdGNoIGRvZXMgbm90IGhhdmUgYXQgbGVhc3Qgb25lIHdvcmQgY2hhcmFjdGVyIGluIGl0IGFmdGVyIHRoZSBwcm90b2NvbCwgYGZhbHNlYFxuXHQgKiAgIG90aGVyd2lzZS5cblx0ICovXG5cdHVybE1hdGNoRG9lc05vdEhhdmVBdExlYXN0T25lV29yZENoYXIgOiBmdW5jdGlvbiggdXJsTWF0Y2gsIHByb3RvY29sVXJsTWF0Y2ggKSB7XG5cdFx0aWYoIHVybE1hdGNoICYmIHByb3RvY29sVXJsTWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gIXRoaXMuaGFzV29yZENoYXJBZnRlclByb3RvY29sUmVnZXgudGVzdCggdXJsTWF0Y2ggKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiBhIHByb3RvY29sLXJlbGF0aXZlIG1hdGNoIGlzIGFuIGludmFsaWQgb25lLiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSBpcyBhIGBwcm90b2NvbFJlbGF0aXZlTWF0Y2hgLFxuXHQgKiBhbmQgdGhhdCBtYXRjaCBjb250YWlucyBhIHdvcmQgY2hhcmFjdGVyIGJlZm9yZSB0aGUgJy8vJyAoaS5lLiBpdCBtdXN0IGNvbnRhaW4gd2hpdGVzcGFjZSBvciBub3RoaW5nIGJlZm9yZSB0aGUgJy8vJyBpblxuXHQgKiBvcmRlciB0byBiZSBjb25zaWRlcmVkIHZhbGlkKS5cblx0ICogXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbFJlbGF0aXZlTWF0Y2ggVGhlIHByb3RvY29sLXJlbGF0aXZlIHN0cmluZyBmb3IgYSBVUkwgbWF0Y2ggKGkuZS4gJy8vJyksIHBvc3NpYmx5IHdpdGggYSBwcmVjZWRpbmdcblx0ICogICBjaGFyYWN0ZXIgKGV4LCBhIHNwYWNlLCBzdWNoIGFzOiAnIC8vJywgb3IgYSBsZXR0ZXIsIHN1Y2ggYXM6ICdhLy8nKS4gVGhlIG1hdGNoIGlzIGludmFsaWQgaWYgdGhlcmUgaXMgYSB3b3JkIGNoYXJhY3RlclxuXHQgKiAgIHByZWNlZGluZyB0aGUgJy8vJy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGl0IGlzIGFuIGludmFsaWQgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2gsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuXHQgKi9cblx0aXNJbnZhbGlkUHJvdG9jb2xSZWxhdGl2ZU1hdGNoIDogZnVuY3Rpb24oIHByb3RvY29sUmVsYXRpdmVNYXRjaCApIHtcblx0XHRyZXR1cm4gKCAhIXByb3RvY29sUmVsYXRpdmVNYXRjaCAmJiB0aGlzLmludmFsaWRQcm90b2NvbFJlbE1hdGNoUmVnZXgudGVzdCggcHJvdG9jb2xSZWxhdGl2ZU1hdGNoICkgKTtcblx0fVxuXG59ICk7XG4vKmdsb2JhbCBBdXRvbGlua2VyICovXG4vKipcbiAqIEBhYnN0cmFjdFxuICogQGNsYXNzIEF1dG9saW5rZXIubWF0Y2guTWF0Y2hcbiAqIFxuICogUmVwcmVzZW50cyBhIG1hdGNoIGZvdW5kIGluIGFuIGlucHV0IHN0cmluZyB3aGljaCBzaG91bGQgYmUgQXV0b2xpbmtlZC4gQSBNYXRjaCBvYmplY3QgaXMgd2hhdCBpcyBwcm92aWRlZCBpbiBhIFxuICoge0BsaW5rIEF1dG9saW5rZXIjcmVwbGFjZUZuIHJlcGxhY2VGbn0sIGFuZCBtYXkgYmUgdXNlZCB0byBxdWVyeSBmb3IgZGV0YWlscyBhYm91dCB0aGUgbWF0Y2guXG4gKiBcbiAqIEZvciBleGFtcGxlOlxuICogXG4gKiAgICAgdmFyIGlucHV0ID0gXCIuLi5cIjsgIC8vIHN0cmluZyB3aXRoIFVSTHMsIEVtYWlsIEFkZHJlc3NlcywgYW5kIFR3aXR0ZXIgSGFuZGxlc1xuICogICAgIFxuICogICAgIHZhciBsaW5rZWRUZXh0ID0gQXV0b2xpbmtlci5saW5rKCBpbnB1dCwge1xuICogICAgICAgICByZXBsYWNlRm4gOiBmdW5jdGlvbiggYXV0b2xpbmtlciwgbWF0Y2ggKSB7XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJocmVmID0gXCIsIG1hdGNoLmdldEFuY2hvckhyZWYoKSApO1xuICogICAgICAgICAgICAgY29uc29sZS5sb2coIFwidGV4dCA9IFwiLCBtYXRjaC5nZXRBbmNob3JUZXh0KCkgKTtcbiAqICAgICAgICAgXG4gKiAgICAgICAgICAgICBzd2l0Y2goIG1hdGNoLmdldFR5cGUoKSApIHtcbiAqICAgICAgICAgICAgICAgICBjYXNlICd1cmwnIDogXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcInVybDogXCIsIG1hdGNoLmdldFVybCgpICk7XG4gKiAgICAgICAgICAgICAgICAgICAgIFxuICogICAgICAgICAgICAgICAgIGNhc2UgJ2VtYWlsJyA6XG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcImVtYWlsOiBcIiwgbWF0Y2guZ2V0RW1haWwoKSApO1xuICogICAgICAgICAgICAgICAgICAgICBcbiAqICAgICAgICAgICAgICAgICBjYXNlICd0d2l0dGVyJyA6XG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcInR3aXR0ZXI6IFwiLCBtYXRjaC5nZXRUd2l0dGVySGFuZGxlKCkgKTtcbiAqICAgICAgICAgICAgIH1cbiAqICAgICAgICAgfVxuICogICAgIH0gKTtcbiAqICAgICBcbiAqIFNlZSB0aGUge0BsaW5rIEF1dG9saW5rZXJ9IGNsYXNzIGZvciBtb3JlIGRldGFpbHMgb24gdXNpbmcgdGhlIHtAbGluayBBdXRvbGlua2VyI3JlcGxhY2VGbiByZXBsYWNlRm59LlxuICovXG5BdXRvbGlua2VyLm1hdGNoLk1hdGNoID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggT2JqZWN0LCB7XG5cdFxuXHQvKipcblx0ICogQGNmZyB7U3RyaW5nfSBtYXRjaGVkVGV4dCAocmVxdWlyZWQpXG5cdCAqIFxuXHQgKiBUaGUgb3JpZ2luYWwgdGV4dCB0aGF0IHdhcyBtYXRjaGVkLlxuXHQgKi9cblx0XG5cdFxuXHQvKipcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBmb3IgdGhlIE1hdGNoIGluc3RhbmNlLCBzcGVjaWZpZWQgaW4gYW4gT2JqZWN0IChtYXApLlxuXHQgKi9cblx0Y29uc3RydWN0b3IgOiBmdW5jdGlvbiggY2ZnICkge1xuXHRcdEF1dG9saW5rZXIuVXRpbC5hc3NpZ24oIHRoaXMsIGNmZyApO1xuXHR9LFxuXG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyBuYW1lIGZvciB0aGUgdHlwZSBvZiBtYXRjaCB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cblx0ICogXG5cdCAqIEBhYnN0cmFjdFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRUeXBlIDogQXV0b2xpbmtlci5VdGlsLmFic3RyYWN0TWV0aG9kLFxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCB0ZXh0IHRoYXQgd2FzIG1hdGNoZWQuXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRNYXRjaGVkVGV4dCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hdGNoZWRUZXh0O1xuXHR9LFxuXHRcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIGhyZWYgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXG5cdCAqIFxuXHQgKiBAYWJzdHJhY3Rcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0QW5jaG9ySHJlZiA6IEF1dG9saW5rZXIuVXRpbC5hYnN0cmFjdE1ldGhvZCxcblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIHRleHQgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXG5cdCAqIFxuXHQgKiBAYWJzdHJhY3Rcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0QW5jaG9yVGV4dCA6IEF1dG9saW5rZXIuVXRpbC5hYnN0cmFjdE1ldGhvZFxuXG59ICk7XG4vKmdsb2JhbCBBdXRvbGlua2VyICovXG4vKipcbiAqIEBjbGFzcyBBdXRvbGlua2VyLm1hdGNoLkVtYWlsXG4gKiBAZXh0ZW5kcyBBdXRvbGlua2VyLm1hdGNoLk1hdGNoXG4gKiBcbiAqIFJlcHJlc2VudHMgYSBFbWFpbCBtYXRjaCBmb3VuZCBpbiBhbiBpbnB1dCBzdHJpbmcgd2hpY2ggc2hvdWxkIGJlIEF1dG9saW5rZWQuXG4gKiBcbiAqIFNlZSB0aGlzIGNsYXNzJ3Mgc3VwZXJjbGFzcyAoe0BsaW5rIEF1dG9saW5rZXIubWF0Y2guTWF0Y2h9KSBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG5BdXRvbGlua2VyLm1hdGNoLkVtYWlsID0gQXV0b2xpbmtlci5VdGlsLmV4dGVuZCggQXV0b2xpbmtlci5tYXRjaC5NYXRjaCwge1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge1N0cmluZ30gZW1haWwgKHJlcXVpcmVkKVxuXHQgKiBcblx0ICogVGhlIGVtYWlsIGFkZHJlc3MgdGhhdCB3YXMgbWF0Y2hlZC5cblx0ICovXG5cdFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlIG9mIG1hdGNoIHRoYXQgdGhpcyBjbGFzcyByZXByZXNlbnRzLlxuXHQgKiBcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0VHlwZSA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAnZW1haWwnO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBlbWFpbCBhZGRyZXNzIHRoYXQgd2FzIG1hdGNoZWQuXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRFbWFpbCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVtYWlsO1xuXHR9LFxuXHRcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIGhyZWYgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRBbmNob3JIcmVmIDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdtYWlsdG86JyArIHRoaXMuZW1haWw7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFuY2hvciB0ZXh0IHRoYXQgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3IgdGhlIG1hdGNoLlxuXHQgKiBcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0QW5jaG9yVGV4dCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVtYWlsO1xuXHR9XG5cdFxufSApO1xuLypnbG9iYWwgQXV0b2xpbmtlciAqL1xuLyoqXG4gKiBAY2xhc3MgQXV0b2xpbmtlci5tYXRjaC5Ud2l0dGVyXG4gKiBAZXh0ZW5kcyBBdXRvbGlua2VyLm1hdGNoLk1hdGNoXG4gKiBcbiAqIFJlcHJlc2VudHMgYSBUd2l0dGVyIG1hdGNoIGZvdW5kIGluIGFuIGlucHV0IHN0cmluZyB3aGljaCBzaG91bGQgYmUgQXV0b2xpbmtlZC5cbiAqIFxuICogU2VlIHRoaXMgY2xhc3MncyBzdXBlcmNsYXNzICh7QGxpbmsgQXV0b2xpbmtlci5tYXRjaC5NYXRjaH0pIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbkF1dG9saW5rZXIubWF0Y2guVHdpdHRlciA9IEF1dG9saW5rZXIuVXRpbC5leHRlbmQoIEF1dG9saW5rZXIubWF0Y2guTWF0Y2gsIHtcblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtTdHJpbmd9IHR3aXR0ZXJIYW5kbGUgKHJlcXVpcmVkKVxuXHQgKiBcblx0ICogVGhlIFR3aXR0ZXIgaGFuZGxlIHRoYXQgd2FzIG1hdGNoZWQuXG5cdCAqL1xuXHRcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdHlwZSBvZiBtYXRjaCB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cblx0ICogXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldFR5cGUgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ3R3aXR0ZXInO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlIG9mIG1hdGNoIHRoYXQgdGhpcyBjbGFzcyByZXByZXNlbnRzLlxuXHQgKiBcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0VHdpdHRlckhhbmRsZSA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnR3aXR0ZXJIYW5kbGU7XG5cdH0sXG5cdFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhbmNob3IgaHJlZiB0aGF0IHNob3VsZCBiZSBnZW5lcmF0ZWQgZm9yIHRoZSBtYXRjaC5cblx0ICogXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldEFuY2hvckhyZWYgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ2h0dHBzOi8vdHdpdHRlci5jb20vJyArIHRoaXMudHdpdHRlckhhbmRsZTtcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIHRleHQgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRBbmNob3JUZXh0IDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdAJyArIHRoaXMudHdpdHRlckhhbmRsZTtcblx0fVxuXHRcbn0gKTtcbi8qZ2xvYmFsIEF1dG9saW5rZXIgKi9cbi8qKlxuICogQGNsYXNzIEF1dG9saW5rZXIubWF0Y2guVXJsXG4gKiBAZXh0ZW5kcyBBdXRvbGlua2VyLm1hdGNoLk1hdGNoXG4gKiBcbiAqIFJlcHJlc2VudHMgYSBVcmwgbWF0Y2ggZm91bmQgaW4gYW4gaW5wdXQgc3RyaW5nIHdoaWNoIHNob3VsZCBiZSBBdXRvbGlua2VkLlxuICogXG4gKiBTZWUgdGhpcyBjbGFzcydzIHN1cGVyY2xhc3MgKHtAbGluayBBdXRvbGlua2VyLm1hdGNoLk1hdGNofSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xuQXV0b2xpbmtlci5tYXRjaC5VcmwgPSBBdXRvbGlua2VyLlV0aWwuZXh0ZW5kKCBBdXRvbGlua2VyLm1hdGNoLk1hdGNoLCB7XG5cdFxuXHQvKipcblx0ICogQGNmZyB7U3RyaW5nfSB1cmwgKHJlcXVpcmVkKVxuXHQgKiBcblx0ICogVGhlIHVybCB0aGF0IHdhcyBtYXRjaGVkLlxuXHQgKi9cblx0XG5cdC8qKlxuXHQgKiBAY2ZnIHtCb29sZWFufSBwcm90b2NvbFVybE1hdGNoIChyZXF1aXJlZClcblx0ICogXG5cdCAqIGB0cnVlYCBpZiB0aGUgVVJMIGlzIGEgbWF0Y2ggd2hpY2ggYWxyZWFkeSBoYXMgYSBwcm90b2NvbCAoaS5lLiAnaHR0cDovLycpLCBgZmFsc2VgIGlmIHRoZSBtYXRjaCB3YXMgZnJvbSBhICd3d3cnIG9yXG5cdCAqIGtub3duIFRMRCBtYXRjaC5cblx0ICovXG5cdFxuXHQvKipcblx0ICogQGNmZyB7Qm9vbGVhbn0gcHJvdG9jb2xSZWxhdGl2ZU1hdGNoIChyZXF1aXJlZClcblx0ICogXG5cdCAqIGB0cnVlYCBpZiB0aGUgVVJMIGlzIGEgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2guIEEgcHJvdG9jb2wtcmVsYXRpdmUgbWF0Y2ggaXMgYSBVUkwgdGhhdCBzdGFydHMgd2l0aCAnLy8nLFxuXHQgKiBhbmQgd2lsbCBiZSBlaXRoZXIgaHR0cDovLyBvciBodHRwczovLyBiYXNlZCBvbiB0aGUgcHJvdG9jb2wgdGhhdCB0aGUgc2l0ZSBpcyBsb2FkZWQgdW5kZXIuXG5cdCAqL1xuXHRcblx0LyoqXG5cdCAqIEBjZmcge0Jvb2xlYW59IHN0cmlwUHJlZml4IChyZXF1aXJlZClcblx0ICogQGluaGVyaXRkb2MgQXV0b2xpbmtlciNzdHJpcFByZWZpeFxuXHQgKi9cblx0XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7UmVnRXhwfSB1cmxQcmVmaXhSZWdleFxuXHQgKiBcblx0ICogQSByZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byByZW1vdmUgdGhlICdodHRwOi8vJyBvciAnaHR0cHM6Ly8nIGFuZC9vciB0aGUgJ3d3dy4nIGZyb20gVVJMcy5cblx0ICovXG5cdHVybFByZWZpeFJlZ2V4OiAvXihodHRwcz86XFwvXFwvKT8od3d3XFwuKT8vaSxcblx0XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcHJvcGVydHkge1JlZ0V4cH0gcHJvdG9jb2xSZWxhdGl2ZVJlZ2V4XG5cdCAqIFxuXHQgKiBUaGUgcmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gcmVtb3ZlIHRoZSBwcm90b2NvbC1yZWxhdGl2ZSAnLy8nIGZyb20gdGhlIHtAbGluayAjdXJsfSBzdHJpbmcsIGZvciBwdXJwb3Nlc1xuXHQgKiBvZiB7QGxpbmsgI2dldEFuY2hvclRleHR9LiBBIHByb3RvY29sLXJlbGF0aXZlIFVSTCBpcywgZm9yIGV4YW1wbGUsIFwiLy95YWhvby5jb21cIlxuXHQgKi9cblx0cHJvdG9jb2xSZWxhdGl2ZVJlZ2V4IDogL15cXC9cXC8vLFxuXHRcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gcHJvdG9jb2xQcmVwZW5kZWRcblx0ICogXG5cdCAqIFdpbGwgYmUgc2V0IHRvIGB0cnVlYCBpZiB0aGUgJ2h0dHA6Ly8nIHByb3RvY29sIGhhcyBiZWVuIHByZXBlbmRlZCB0byB0aGUge0BsaW5rICN1cmx9IChiZWNhdXNlIHRoZVxuXHQgKiB7QGxpbmsgI3VybH0gZGlkIG5vdCBoYXZlIGEgcHJvdG9jb2wpXG5cdCAqL1xuXHRwcm90b2NvbFByZXBlbmRlZCA6IGZhbHNlLFxuXHRcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyBuYW1lIGZvciB0aGUgdHlwZSBvZiBtYXRjaCB0aGF0IHRoaXMgY2xhc3MgcmVwcmVzZW50cy5cblx0ICogXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldFR5cGUgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ3VybCc7XG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHVybCB0aGF0IHdhcyBtYXRjaGVkLCBhc3N1bWluZyB0aGUgcHJvdG9jb2wgdG8gYmUgJ2h0dHA6Ly8nIGlmIHRoZSBvcmlnaW5hbFxuXHQgKiBtYXRjaCB3YXMgbWlzc2luZyBhIHByb3RvY29sLlxuXHQgKiBcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0VXJsIDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHVybCA9IHRoaXMudXJsO1xuXHRcdFxuXHRcdC8vIGlmIHRoZSB1cmwgc3RyaW5nIGRvZXNuJ3QgYmVnaW4gd2l0aCBhIHByb3RvY29sLCBhc3N1bWUgJ2h0dHA6Ly8nXG5cdFx0aWYoICF0aGlzLnByb3RvY29sUmVsYXRpdmVNYXRjaCAmJiAhdGhpcy5wcm90b2NvbFVybE1hdGNoICYmICF0aGlzLnByb3RvY29sUHJlcGVuZGVkICkge1xuXHRcdFx0dXJsID0gdGhpcy51cmwgPSAnaHR0cDovLycgKyB1cmw7XG5cdFx0XHRcblx0XHRcdHRoaXMucHJvdG9jb2xQcmVwZW5kZWQgPSB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gdXJsO1xuXHR9LFxuXHRcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYW5jaG9yIGhyZWYgdGhhdCBzaG91bGQgYmUgZ2VuZXJhdGVkIGZvciB0aGUgbWF0Y2guXG5cdCAqIFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRBbmNob3JIcmVmIDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHVybCA9IHRoaXMuZ2V0VXJsKCk7XG5cdFx0XG5cdFx0cmV0dXJuIHVybC5yZXBsYWNlKCAvJmFtcDsvZywgJyYnICk7ICAvLyBhbnkgJmFtcDsncyBpbiB0aGUgVVJMIHNob3VsZCBiZSBjb252ZXJ0ZWQgYmFjayB0byAnJicgaWYgdGhleSB3ZXJlIGRpc3BsYXllZCBhcyAmYW1wOyBpbiB0aGUgc291cmNlIGh0bWwgXG5cdH0sXG5cdFxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFuY2hvciB0ZXh0IHRoYXQgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3IgdGhlIG1hdGNoLlxuXHQgKiBcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0QW5jaG9yVGV4dCA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhbmNob3JUZXh0ID0gdGhpcy5nZXRVcmwoKTtcblx0XHRcblx0XHRpZiggdGhpcy5wcm90b2NvbFJlbGF0aXZlTWF0Y2ggKSB7XG5cdFx0XHQvLyBTdHJpcCBvZmYgYW55IHByb3RvY29sLXJlbGF0aXZlICcvLycgZnJvbSB0aGUgYW5jaG9yIHRleHRcblx0XHRcdGFuY2hvclRleHQgPSB0aGlzLnN0cmlwUHJvdG9jb2xSZWxhdGl2ZVByZWZpeCggYW5jaG9yVGV4dCApO1xuXHRcdH1cblx0XHRpZiggdGhpcy5zdHJpcFByZWZpeCApIHtcblx0XHRcdGFuY2hvclRleHQgPSB0aGlzLnN0cmlwVXJsUHJlZml4KCBhbmNob3JUZXh0ICk7XG5cdFx0fVxuXHRcdGFuY2hvclRleHQgPSB0aGlzLnJlbW92ZVRyYWlsaW5nU2xhc2goIGFuY2hvclRleHQgKTsgIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaCwgaWYgdGhlcmUgaXMgb25lXG5cdFx0XG5cdFx0cmV0dXJuIGFuY2hvclRleHQ7XG5cdH0sXG5cdFxuXHRcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFxuXHQvLyBVdGlsaXR5IEZ1bmN0aW9uYWxpdHlcblx0XG5cdC8qKlxuXHQgKiBTdHJpcHMgdGhlIFVSTCBwcmVmaXggKHN1Y2ggYXMgXCJodHRwOi8vXCIgb3IgXCJodHRwczovL1wiKSBmcm9tIHRoZSBnaXZlbiB0ZXh0LlxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgb2YgdGhlIGFuY2hvciB0aGF0IGlzIGJlaW5nIGdlbmVyYXRlZCwgZm9yIHdoaWNoIHRvIHN0cmlwIG9mZiB0aGVcblx0ICogICB1cmwgcHJlZml4IChzdWNoIGFzIHN0cmlwcGluZyBvZmYgXCJodHRwOi8vXCIpXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGBhbmNob3JUZXh0YCwgd2l0aCB0aGUgcHJlZml4IHN0cmlwcGVkLlxuXHQgKi9cblx0c3RyaXBVcmxQcmVmaXggOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dC5yZXBsYWNlKCB0aGlzLnVybFByZWZpeFJlZ2V4LCAnJyApO1xuXHR9LFxuXHRcblx0XG5cdC8qKlxuXHQgKiBTdHJpcHMgYW55IHByb3RvY29sLXJlbGF0aXZlICcvLycgZnJvbSB0aGUgYW5jaG9yIHRleHQuXG5cdCAqIFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCBvZiB0aGUgYW5jaG9yIHRoYXQgaXMgYmVpbmcgZ2VuZXJhdGVkLCBmb3Igd2hpY2ggdG8gc3RyaXAgb2ZmIHRoZVxuXHQgKiAgIHByb3RvY29sLXJlbGF0aXZlIHByZWZpeCAoc3VjaCBhcyBzdHJpcHBpbmcgb2ZmIFwiLy9cIilcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgYGFuY2hvclRleHRgLCB3aXRoIHRoZSBwcm90b2NvbC1yZWxhdGl2ZSBwcmVmaXggc3RyaXBwZWQuXG5cdCAqL1xuXHRzdHJpcFByb3RvY29sUmVsYXRpdmVQcmVmaXggOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dC5yZXBsYWNlKCB0aGlzLnByb3RvY29sUmVsYXRpdmVSZWdleCwgJycgKTtcblx0fSxcblx0XG5cdFxuXHQvKipcblx0ICogUmVtb3ZlcyBhbnkgdHJhaWxpbmcgc2xhc2ggZnJvbSB0aGUgZ2l2ZW4gYGFuY2hvclRleHRgLCBpbiBwcmVwYXJhdGlvbiBmb3IgdGhlIHRleHQgdG8gYmUgZGlzcGxheWVkLlxuXHQgKiBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGFuY2hvclRleHQgVGhlIHRleHQgb2YgdGhlIGFuY2hvciB0aGF0IGlzIGJlaW5nIGdlbmVyYXRlZCwgZm9yIHdoaWNoIHRvIHJlbW92ZSBhbnkgdHJhaWxpbmdcblx0ICogICBzbGFzaCAoJy8nKSB0aGF0IG1heSBleGlzdC5cblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgYGFuY2hvclRleHRgLCB3aXRoIHRoZSB0cmFpbGluZyBzbGFzaCByZW1vdmVkLlxuXHQgKi9cblx0cmVtb3ZlVHJhaWxpbmdTbGFzaCA6IGZ1bmN0aW9uKCBhbmNob3JUZXh0ICkge1xuXHRcdGlmKCBhbmNob3JUZXh0LmNoYXJBdCggYW5jaG9yVGV4dC5sZW5ndGggLSAxICkgPT09ICcvJyApIHtcblx0XHRcdGFuY2hvclRleHQgPSBhbmNob3JUZXh0LnNsaWNlKCAwLCAtMSApO1xuXHRcdH1cblx0XHRyZXR1cm4gYW5jaG9yVGV4dDtcblx0fVxuXHRcbn0gKTtcbnJldHVybiBBdXRvbGlua2VyO1xuXG59KSk7XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKlxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG5DU1MzIEFOSU1BVElPTiBDSEVBVCBTSEVFVFxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG5cXHJcXG5NYWRlIGJ5IEp1c3RpbiBBZ3VpbGFyXFxyXFxuXFxyXFxud3d3Lmp1c3RpbmFndWlsYXIuY29tL2FuaW1hdGlvbnMvXFxyXFxuXFxyXFxuUXVlc3Rpb25zLCBjb21tZW50cywgY29uY2VybnMsIGxvdmUgbGV0dGVyczpcXHJcXG5qdXN0aW5AanVzdGluYWd1aWxhci5jb21cXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG4vKlxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG5zbGlkZURvd25cXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG5cXHJcXG4uc2xpZGVEb3due1xcclxcblxcdGFuaW1hdGlvbi1uYW1lOiBzbGlkZURvd247XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tbmFtZTogc2xpZGVEb3duO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMXM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDFzO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2U7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlO1xcclxcblxcclxcblxcdHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBzbGlkZURvd24ge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMCUpO1xcclxcblxcdH1cXHJcXG5cXHQ1MCV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDglKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjUle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNCUpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDQlKTtcXHJcXG5cXHR9XFxyXFxuXFx0OTUle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMiUpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIHNsaWRlRG93biB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDAlKTtcXHJcXG5cXHR9XFxyXFxuXFx0NTAle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDglKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjUle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC00JSk7XFxyXFxuXFx0fVxcclxcblxcdDgwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSg0JSk7XFxyXFxuXFx0fVxcclxcblxcdDk1JXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMiUpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG5zbGlkZVVwXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuXFxyXFxuLnNsaWRlVXB7XFxyXFxuXFx0YW5pbWF0aW9uLW5hbWU6IHNsaWRlVXA7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tbmFtZTogc2xpZGVVcDtcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDFzO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAxcztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZTtcXHJcXG5cXHJcXG5cXHR2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgc2xpZGVVcCB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgxMDAlKTtcXHJcXG5cXHR9XFxyXFxuXFx0NTAle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtOCUpO1xcclxcblxcdH1cXHJcXG5cXHQ2NSV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDQlKTtcXHJcXG5cXHR9XFxyXFxuXFx0ODAle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNCUpO1xcclxcblxcdH1cXHJcXG5cXHQ5NSV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIlKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBzbGlkZVVwIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMTAwJSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtOCUpO1xcclxcblxcdH1cXHJcXG5cXHQ2NSV7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoNCUpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCV7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTQlKTtcXHJcXG5cXHR9XFxyXFxuXFx0OTUle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIlKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuc2xpZGVMZWZ0XFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuXFxyXFxuLnNsaWRlTGVmdHtcXHJcXG5cXHRhbmltYXRpb24tbmFtZTogc2xpZGVMZWZ0O1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IHNsaWRlTGVmdDtcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDFzO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAxcztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluLW91dDtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2UtaW4tb3V0O1xcclxcblxcclxcblxcdHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBzbGlkZUxlZnQge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMTUwJSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTglKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjUle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWCg0JSk7XFxyXFxuXFx0fVxcclxcblxcdDgwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTQlKTtcXHJcXG5cXHR9XFxyXFxuXFx0OTUle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWCgyJSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwJSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG5ALXdlYmtpdC1rZXlmcmFtZXMgc2xpZGVMZWZ0IHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMTUwJSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtOCUpO1xcclxcblxcdH1cXHJcXG5cXHQ2NSV7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoNCUpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCV7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTQlKTtcXHJcXG5cXHR9XFxyXFxuXFx0OTUle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDIlKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCUpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuc2xpZGVSaWdodFxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG4qL1xcclxcblxcclxcblxcclxcbi5zbGlkZVJpZ2h0e1xcclxcblxcdGFuaW1hdGlvbi1uYW1lOiBzbGlkZVJpZ2h0O1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IHNsaWRlUmlnaHQ7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLWR1cmF0aW9uOiAxcztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMXM7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbi1vdXQ7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluLW91dDtcXHJcXG5cXHJcXG5cXHR2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgc2xpZGVSaWdodCB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMTUwJSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoOCUpO1xcclxcblxcdH1cXHJcXG5cXHQ2NSV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVYKC00JSk7XFxyXFxuXFx0fVxcclxcblxcdDgwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoNCUpO1xcclxcblxcdH1cXHJcXG5cXHQ5NSV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0yJSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwJSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG5ALXdlYmtpdC1rZXlmcmFtZXMgc2xpZGVSaWdodCB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0xNTAlKTtcXHJcXG5cXHR9XFxyXFxuXFx0NTAle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDglKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjUle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC00JSk7XFxyXFxuXFx0fVxcclxcblxcdDgwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCg0JSk7XFxyXFxuXFx0fVxcclxcblxcdDk1JXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMiUpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgwJSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG5zbGlkZUV4cGFuZFVwXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuXFxyXFxuLnNsaWRlRXhwYW5kVXB7XFxyXFxuXFx0YW5pbWF0aW9uLW5hbWU6IHNsaWRlRXhwYW5kVXA7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tbmFtZTogc2xpZGVFeHBhbmRVcDtcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDEuNnM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDEuNnM7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1vdXQ7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlIC1vdXQ7XFxyXFxuXFxyXFxuXFx0dmlzaWJpbGl0eTogdmlzaWJsZSAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIHNsaWRlRXhwYW5kVXAge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMTAwJSkgc2NhbGVYKDAuNSk7XFxyXFxuXFx0fVxcclxcblxcdDMwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTglKSBzY2FsZVgoMC41KTtcXHJcXG5cXHR9XFxyXFxuXFx0NDAle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgyJSkgc2NhbGVYKDAuNSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWCgxLjEpO1xcclxcblxcdH1cXHJcXG5cXHQ2MCV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKSBzY2FsZVgoMC45KTtcXHJcXG5cXHR9XFxyXFxuXFx0NzAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWCgxLjA1KTtcXHJcXG5cXHR9XFxyXFxuXFx0ODAle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVYKDAuOTUpO1xcclxcblxcdH1cXHJcXG5cXHQ5MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVYKDEuMDIpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVYKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIHNsaWRlRXhwYW5kVXAge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgxMDAlKSBzY2FsZVgoMC41KTtcXHJcXG5cXHR9XFxyXFxuXFx0MzAle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC04JSkgc2NhbGVYKDAuNSk7XFxyXFxuXFx0fVxcclxcblxcdDQwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgyJSkgc2NhbGVYKDAuNSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVYKDEuMSk7XFxyXFxuXFx0fVxcclxcblxcdDYwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVYKDAuOSk7XFxyXFxuXFx0fVxcclxcblxcdDcwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWCgxLjA1KTtcXHJcXG5cXHR9XFxyXFxuXFx0ODAle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKSBzY2FsZVgoMC45NSk7XFxyXFxuXFx0fVxcclxcblxcdDkwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWCgxLjAyKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVYKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuZXhwYW5kVXBcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG5cXHJcXG4uZXhwYW5kVXB7XFxyXFxuXFx0YW5pbWF0aW9uLW5hbWU6IGV4cGFuZFVwO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGV4cGFuZFVwO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMC43cztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC43cztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZTtcXHJcXG5cXHJcXG5cXHR2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgZXhwYW5kVXAge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMTAwJSkgc2NhbGUoMC42KSBzY2FsZVkoMC41KTtcXHJcXG5cXHR9XFxyXFxuXFx0NjAle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNyUpIHNjYWxlWSgxLjEyKTtcXHJcXG5cXHR9XFxyXFxuXFx0NzUle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgzJSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGUoMSkgc2NhbGVZKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIGV4cGFuZFVwIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMTAwJSkgc2NhbGUoMC42KSBzY2FsZVkoMC41KTtcXHJcXG5cXHR9XFxyXFxuXFx0NjAle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC03JSkgc2NhbGVZKDEuMTIpO1xcclxcblxcdH1cXHJcXG5cXHQ3NSV7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMyUpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGUoMSkgc2NhbGVZKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuZmFkZUluXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuLmZhZGVJbntcXHJcXG5cXHRhbmltYXRpb24tbmFtZTogZmFkZUluO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGZhZGVJbjtcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDEuNXM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDEuNXM7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbi1vdXQ7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluLW91dDtcXHJcXG5cXHJcXG5cXHR2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgZmFkZUluIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZSgwKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAwLjA7XFxyXFxuXFx0fVxcclxcblxcdDYwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGUoMC45KTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcblxcdFxcdG9wYWNpdHk6IDE7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG5ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZUluIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDApO1xcclxcblxcdFxcdG9wYWNpdHk6IDAuMDtcXHJcXG5cXHR9XFxyXFxuXFx0NjAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMS4xKTtcXHJcXG5cXHR9XFxyXFxuXFx0ODAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC45KTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbmV4cGFuZE9wZW5cXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG5cXHJcXG4uZXhwYW5kT3BlbntcXHJcXG5cXHRhbmltYXRpb24tbmFtZTogZXhwYW5kT3BlbjtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBleHBhbmRPcGVuO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMS4ycztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMS4ycztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2Utb3V0O1xcclxcblxcclxcblxcdHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBleHBhbmRPcGVuIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZSgxLjgpO1xcclxcblxcdH1cXHJcXG5cXHQ1MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGUoMC45NSk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZSgxLjA1KTtcXHJcXG5cXHR9XFxyXFxuXFx0OTAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlKDAuOTgpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIGV4cGFuZE9wZW4ge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMS44KTtcXHJcXG5cXHR9XFxyXFxuXFx0NTAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC45NSk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEuMDUpO1xcclxcblxcdH1cXHJcXG5cXHQ5MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjk4KTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuYmlnRW50cmFuY2VcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG5cXHJcXG4uYmlnRW50cmFuY2V7XFxyXFxuXFx0YW5pbWF0aW9uLW5hbWU6IGJpZ0VudHJhbmNlO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGJpZ0VudHJhbmNlO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMS42cztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMS42cztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2Utb3V0O1xcclxcblxcclxcblxcdHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBiaWdFbnRyYW5jZSB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGUoMC4zKSByb3RhdGUoNmRlZykgdHJhbnNsYXRlWCgtMzAlKSB0cmFuc2xhdGVZKDMwJSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMC4yO1xcclxcblxcdH1cXHJcXG5cXHQzMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGUoMS4wMykgcm90YXRlKC0yZGVnKSB0cmFuc2xhdGVYKDIlKSB0cmFuc2xhdGVZKC0yJSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMTtcXHJcXG5cXHR9XFxyXFxuXFx0NDUlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlKDAuOTgpIHJvdGF0ZSgxZGVnKSB0cmFuc2xhdGVYKDAlKSB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG5cXHQ2MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGUoMS4wMSkgcm90YXRlKC0xZGVnKSB0cmFuc2xhdGVYKDAlKSB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG5cXHQ3NSUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGUoMC45OSkgcm90YXRlKDFkZWcpIHRyYW5zbGF0ZVgoMCUpIHRyYW5zbGF0ZVkoMCUpO1xcclxcblxcdFxcdG9wYWNpdHk6IDE7XFxyXFxuXFx0fVxcclxcblxcdDkwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZSgxLjAxKSByb3RhdGUoMGRlZykgdHJhbnNsYXRlWCgwJSkgdHJhbnNsYXRlWSgwJSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZSgxKSByb3RhdGUoMGRlZykgdHJhbnNsYXRlWCgwJSkgdHJhbnNsYXRlWSgwJSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBiaWdFbnRyYW5jZSB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjMpIHJvdGF0ZSg2ZGVnKSB0cmFuc2xhdGVYKC0zMCUpIHRyYW5zbGF0ZVkoMzAlKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAwLjI7XFxyXFxuXFx0fVxcclxcblxcdDMwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEuMDMpIHJvdGF0ZSgtMmRlZykgdHJhbnNsYXRlWCgyJSkgdHJhbnNsYXRlWSgtMiUpO1xcclxcblxcdFxcdG9wYWNpdHk6IDE7XFxyXFxuXFx0fVxcclxcblxcdDQ1JSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuOTgpIHJvdGF0ZSgxZGVnKSB0cmFuc2xhdGVYKDAlKSB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG5cXHQ2MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLjAxKSByb3RhdGUoLTFkZWcpIHRyYW5zbGF0ZVgoMCUpIHRyYW5zbGF0ZVkoMCUpO1xcclxcblxcdFxcdG9wYWNpdHk6IDE7XFxyXFxuXFx0fVxcclxcblxcdDc1JSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuOTkpIHJvdGF0ZSgxZGVnKSB0cmFuc2xhdGVYKDAlKSB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG5cXHQ5MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLjAxKSByb3RhdGUoMGRlZykgdHJhbnNsYXRlWCgwJSkgdHJhbnNsYXRlWSgwJSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpIHJvdGF0ZSgwZGVnKSB0cmFuc2xhdGVYKDAlKSB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuaGF0Y2hcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG4uaGF0Y2h7XFxyXFxuXFx0YW5pbWF0aW9uLW5hbWU6IGhhdGNoO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGhhdGNoO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMnM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDJzO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2UtaW4tb3V0O1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbi1vdXQ7XFxyXFxuXFxyXFxuXFx0dHJhbnNmb3JtLW9yaWdpbjogNTAlIDEwMCU7XFxyXFxuXFx0LW1zLXRyYW5zZm9ybS1vcmlnaW46IDUwJSAxMDAlO1xcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogNTAlIDEwMCU7XFxyXFxuXFxyXFxuXFx0dmlzaWJpbGl0eTogdmlzaWJsZSAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIGhhdGNoIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZykgc2NhbGVZKDAuNik7XFxyXFxuXFx0fVxcclxcblxcdDIwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiByb3RhdGUoLTJkZWcpIHNjYWxlWSgxLjA1KTtcXHJcXG5cXHR9XFxyXFxuXFx0MzUlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHJvdGF0ZSgyZGVnKSBzY2FsZVkoMSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiByb3RhdGUoLTJkZWcpO1xcclxcblxcdH1cXHJcXG5cXHQ2NSUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogcm90YXRlKDFkZWcpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogcm90YXRlKC0xZGVnKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG5ALXdlYmtpdC1rZXlmcmFtZXMgaGF0Y2gge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpIHNjYWxlWSgwLjYpO1xcclxcblxcdH1cXHJcXG5cXHQyMCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoLTJkZWcpIHNjYWxlWSgxLjA1KTtcXHJcXG5cXHR9XFxyXFxuXFx0MzUlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDJkZWcpIHNjYWxlWSgxKTtcXHJcXG5cXHR9XFxyXFxuXFx0NTAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKC0yZGVnKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjUlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDFkZWcpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoLTFkZWcpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuYm91bmNlXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuXFxyXFxuLmJvdW5jZXtcXHJcXG5cXHRhbmltYXRpb24tbmFtZTogYm91bmNlO1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGJvdW5jZTtcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDEuNnM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDEuNnM7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZTtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2U7XFxyXFxuXFxyXFxuXFx0dHJhbnNmb3JtLW9yaWdpbjogNTAlIDEwMCU7XFxyXFxuXFx0LW1zLXRyYW5zZm9ybS1vcmlnaW46IDUwJSAxMDAlO1xcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogNTAlIDEwMCU7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgYm91bmNlIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKSBzY2FsZVkoMC42KTtcXHJcXG5cXHR9XFxyXFxuXFx0NjAle1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTAwJSkgc2NhbGVZKDEuMSk7XFxyXFxuXFx0fVxcclxcblxcdDcwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWSgwLjk1KSBzY2FsZVgoMS4wNSk7XFxyXFxuXFx0fVxcclxcblxcdDgwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWSgxLjA1KSBzY2FsZVgoMSk7XFxyXFxuXFx0fVxcclxcblxcdDkwJXtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWSgwLjk1KSBzY2FsZVgoMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCV7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKSBzY2FsZVkoMSkgc2NhbGVYKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIGJvdW5jZSB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKSBzY2FsZVkoMC42KTtcXHJcXG5cXHR9XFxyXFxuXFx0NjAle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDAlKSBzY2FsZVkoMS4xKTtcXHJcXG5cXHR9XFxyXFxuXFx0NzAle1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKSBzY2FsZVkoMC45NSkgc2NhbGVYKDEuMDUpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCV7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCUpIHNjYWxlWSgxLjA1KSBzY2FsZVgoMSk7XFxyXFxuXFx0fVxcclxcblxcdDkwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVZKDAuOTUpIHNjYWxlWCgxKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJXtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSkgc2NhbGVZKDEpIHNjYWxlWCgxKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcblxcclxcbi8qXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbnB1bHNlXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuLnB1bHNle1xcclxcblxcdGFuaW1hdGlvbi1uYW1lOiBwdWxzZTtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBwdWxzZTtcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDEuNXM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDEuNXM7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBwdWxzZSB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGUoMC45KTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAwLjc7XFxyXFxuXFx0fVxcclxcblxcdDUwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZSgxKTtcXHJcXG5cXHRcXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlKDAuOSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMC43O1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIHB1bHNlIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuOTUpO1xcclxcblxcdFxcdG9wYWNpdHk6IDAuNztcXHJcXG5cXHR9XFxyXFxuXFx0NTAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxyXFxuXFx0XFx0b3BhY2l0eTogMTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuOTUpO1xcclxcblxcdFxcdG9wYWNpdHk6IDAuNztcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbmZsb2F0aW5nXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuLmZsb2F0aW5ne1xcclxcblxcdGFuaW1hdGlvbi1uYW1lOiBmbG9hdGluZztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmbG9hdGluZztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDEuNXM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDEuNXM7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBmbG9hdGluZyB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwJSk7XFxyXFxuXFx0fVxcclxcblxcdDUwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDglKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBmbG9hdGluZyB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHR9XFxyXFxuXFx0NTAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSg4JSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDAlKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbnRvc3NpbmdcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG4udG9zc2luZ3tcXHJcXG5cXHRhbmltYXRpb24tbmFtZTogdG9zc2luZztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiB0b3NzaW5nO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMi41cztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMi41cztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIHRvc3Npbmcge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHJvdGF0ZSgtNGRlZyk7XFxyXFxuXFx0fVxcclxcblxcdDUwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiByb3RhdGUoNGRlZyk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogcm90YXRlKC00ZGVnKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyB0b3NzaW5nIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgtNGRlZyk7XFxyXFxuXFx0fVxcclxcblxcdDUwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0ZGVnKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgtNGRlZyk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG5wdWxsVXBcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG4ucHVsbFVwe1xcclxcblxcdGFuaW1hdGlvbi1uYW1lOiBwdWxsVXA7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tbmFtZTogcHVsbFVwO1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMS4xcztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMS4xcztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2Utb3V0O1xcclxcblxcclxcblxcdHRyYW5zZm9ybS1vcmlnaW46IDUwJSAxMDAlO1xcclxcblxcdC1tcy10cmFuc2Zvcm0tb3JpZ2luOiA1MCUgMTAwJTtcXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDUwJSAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIHB1bGxVcCB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVZKDAuMSk7XFxyXFxuXFx0fVxcclxcblxcdDQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVkoMS4wMik7XFxyXFxuXFx0fVxcclxcblxcdDYwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVkoMC45OCk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVkoMS4wMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVZKDAuOTgpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVZKDEuMDEpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlWSgxKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBwdWxsVXAge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDAuMSk7XFxyXFxuXFx0fVxcclxcblxcdDQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxLjAyKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDAuOTgpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMS4wMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMC45OCk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxLjAxKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbnB1bGxEb3duXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiovXFxyXFxuXFxyXFxuLnB1bGxEb3due1xcclxcblxcdGFuaW1hdGlvbi1uYW1lOiBwdWxsRG93bjtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBwdWxsRG93bjtcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tZHVyYXRpb246IDEuMXM7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDEuMXM7XFxyXFxuXFxyXFxuXFx0YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1vdXQ7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcXHJcXG5cXHJcXG5cXHR0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgMCU7XFxyXFxuXFx0LW1zLXRyYW5zZm9ybS1vcmlnaW46IDUwJSAwJTtcXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDUwJSAwJTtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBwdWxsRG93biB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVZKDAuMSk7XFxyXFxuXFx0fVxcclxcblxcdDQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVkoMS4wMik7XFxyXFxuXFx0fVxcclxcblxcdDYwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVkoMC45OCk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVkoMS4wMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVZKDAuOTgpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVZKDEuMDEpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlWSgxKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBwdWxsRG93biB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMC4xKTtcXHJcXG5cXHR9XFxyXFxuXFx0NDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDEuMDIpO1xcclxcblxcdH1cXHJcXG5cXHQ2MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVkoMC45OCk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgxLjAxKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWSgwLjk4KTtcXHJcXG5cXHR9XFxyXFxuXFx0ODAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDEuMDEpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVZKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuc3RyZXRjaExlZnRcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG4uc3RyZXRjaExlZnR7XFxyXFxuXFx0YW5pbWF0aW9uLW5hbWU6IHN0cmV0Y2hMZWZ0O1xcclxcblxcdC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IHN0cmV0Y2hMZWZ0O1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMS41cztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMS41cztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2Utb3V0O1xcclxcblxcclxcblxcdHRyYW5zZm9ybS1vcmlnaW46IDEwMCUgMCU7XFxyXFxuXFx0LW1zLXRyYW5zZm9ybS1vcmlnaW46IDEwMCUgMCU7XFxyXFxuXFx0LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiAxMDAlIDAlO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIHN0cmV0Y2hMZWZ0IHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVgoMC4zKTtcXHJcXG5cXHR9XFxyXFxuXFx0NDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlWCgxLjAyKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlWCgwLjk4KTtcXHJcXG5cXHR9XFxyXFxuXFx0ODAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlWCgxLjAxKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVgoMC45OCk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVgoMS4wMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVYKDEpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIHN0cmV0Y2hMZWZ0IHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWCgwLjMpO1xcclxcblxcdH1cXHJcXG5cXHQ0MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVgoMS4wMik7XFxyXFxuXFx0fVxcclxcblxcdDYwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWCgwLjk4KTtcXHJcXG5cXHR9XFxyXFxuXFx0ODAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVYKDEuMDEpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVYKDAuOTgpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVgoMS4wMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVgoMSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG5zdHJldGNoUmlnaHRcXHJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuKi9cXHJcXG5cXHJcXG4uc3RyZXRjaFJpZ2h0e1xcclxcblxcdGFuaW1hdGlvbi1uYW1lOiBzdHJldGNoUmlnaHQ7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb24tbmFtZTogc3RyZXRjaFJpZ2h0O1xcclxcblxcclxcblxcdGFuaW1hdGlvbi1kdXJhdGlvbjogMS41cztcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMS41cztcXHJcXG5cXHJcXG5cXHRhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcXHJcXG5cXHQtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2Utb3V0O1xcclxcblxcclxcblxcdHRyYW5zZm9ybS1vcmlnaW46IDAlIDAlO1xcclxcblxcdC1tcy10cmFuc2Zvcm0tb3JpZ2luOiAwJSAwJTtcXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDAlIDAlO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIHN0cmV0Y2hSaWdodCB7XFxyXFxuXFx0MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVYKDAuMyk7XFxyXFxuXFx0fVxcclxcblxcdDQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVgoMS4wMik7XFxyXFxuXFx0fVxcclxcblxcdDYwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVgoMC45OCk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiBzY2FsZVgoMS4wMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVYKDAuOTgpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdHRyYW5zZm9ybTogc2NhbGVYKDEuMDEpO1xcclxcblxcdH1cXHJcXG5cXHQxMDAlIHtcXHJcXG5cXHRcXHR0cmFuc2Zvcm06IHNjYWxlWCgxKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBzdHJldGNoUmlnaHQge1xcclxcblxcdDAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVYKDAuMyk7XFxyXFxuXFx0fVxcclxcblxcdDQwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWCgxLjAyKTtcXHJcXG5cXHR9XFxyXFxuXFx0NjAlIHtcXHJcXG5cXHRcXHQtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVYKDAuOTgpO1xcclxcblxcdH1cXHJcXG5cXHQ4MCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVgoMS4wMSk7XFxyXFxuXFx0fVxcclxcblxcdDEwMCUge1xcclxcblxcdFxcdC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVgoMC45OCk7XFxyXFxuXFx0fVxcclxcblxcdDgwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWCgxLjAxKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0LXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlWCgxKTtcXHJcXG5cXHR9XFxyXFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9jc3MtbG9hZGVyLzAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5lZGl0b3ItbGVmdCB7XFxyXFxuICBvdmVyZmxvdzogc2Nyb2xsO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZmxvdzogY29sdW1uO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcclxcbiAgYWxpZ24tY29udGVudDogY2VudGVyO1xcclxcbiAgaGVpZ2h0OiA4NXZoO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBwYWRkaW5nOiAycHg7XFxyXFxufVxcclxcblxcclxcbi5lZGl0b3ItbGVmdC5jYXJkID4gLmNhcmQtZm9vdGVyID4gLmNhcmQtYnRuIHtcXHJcXG4gIHdpZHRoOiA0OCU7XFxyXFxufVxcclxcblxcclxcbi5lZGl0b3ItcmlnaHQge1xcclxcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxyXFxuICBib3JkZXI6IDFweCBkYXNoZWQgZ3JlZW47XFxyXFxuICB3aWR0aDogOTAlO1xcclxcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcclxcbiAgaGVpZ2h0OiA4NXZoO1xcclxcbiAgcGFkZGluZzogMTBweDtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWZsb3c6IGNvbHVtbjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXHJcXG59XFxyXFxuXFxyXFxuLmVkaXRvci1pbnB1dCB7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uZWRpdG9yLXRleHQge1xcclxcbiAgaGVpZ2h0OiA1MDBweDtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDEwcHg7XFxyXFxufVxcclxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9jc3MtbG9hZGVyLzAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBpbXBvcnQgdXJsKGh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1SdWJpayk7XCIsIFwiXCJdKTtcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBpbXBvcnQgdXJsKGh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1JbmNvbnNvbGF0YSk7XCIsIFwiXCJdKTtcbmV4cG9ydHMuaShyZXF1aXJlKFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9jc3MtbG9hZGVyLzAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9hbmltYXRpb25zLmNzc1wiKSwgXCJcIik7XG5leHBvcnRzLmkocmVxdWlyZShcIi0hLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc2xpZGVzaG93LmNzc1wiKSwgXCJcIik7XG5leHBvcnRzLmkocmVxdWlyZShcIi0hLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vZWRpdG9yLmNzc1wiKSwgXCJcIik7XG5leHBvcnRzLmkocmVxdWlyZShcIi0hLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbW9kYWwuY3NzXCIpLCBcIlwiKTtcbmV4cG9ydHMuaShyZXF1aXJlKFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9jc3MtbG9hZGVyLzAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9wcmV2aWV3LmNzc1wiKSwgXCJcIik7XG5leHBvcnRzLmkocmVxdWlyZShcIi0hLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc2xpZGVzLmNzc1wiKSwgXCJcIik7XG5leHBvcnRzLmkocmVxdWlyZShcIi0hLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJlc2VudGF0aW9ucy5jc3NcIiksIFwiXCIpO1xuZXhwb3J0cy5pKHJlcXVpcmUoXCItIS4uLy4uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL2Nzcy1sb2FkZXIvMC4yOC4xMS9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3Rvb2xiYXIuY3NzXCIpLCBcIlwiKTtcblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiBpbmRleC5jc3MgKi9cXHJcXG5cXHJcXG5cXHJcXG4qIHtcXHJcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxufVxcclxcblxcclxcblxcclxcbmJvZHksXFxyXFxuaHRtbCB7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICBmb250LWZhbWlseTogXFxcIlJ1YmlrXFxcIiwgXFxcIkluY29uc29sYXRhXFxcIiwgc2Fucy1zZXJpZjtcXHJcXG59XFxyXFxuXFxyXFxuLm1haW4ge1xcclxcbiAgZGlzcGxheTogZ3JpZDtcXHJcXG4gIGdyaWQtdGVtcGxhdGUtYXJlYXM6IFxcXCJ0b29sYmFyXFxcIiBcXFwiYm9keVxcXCI7XFxyXFxufVxcclxcblxcclxcbi5jb250YWluZXIge1xcclxcblxcclxcbiAgcGFkZGluZzogNHB4O1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZmxvdzogY29sdW1uO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcclxcbiAgYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcXHJcXG59XFxyXFxuXFxyXFxuLmNhcmQge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZmxvdzogY29sdW1uO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzdHJldGNoO1xcclxcbiAgbWluLXdpZHRoOiAyMDBweDtcXHJcXG4gIG1heC13aWR0aDogMzAwcHg7XFxyXFxuICBoZWlnaHQ6IGZpdC1jb250ZW50O1xcclxcbiAgbWFyZ2luOiAxMHB4O1xcclxcbiAgYm9yZGVyLXJhZGl1czogMiU7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQ0LCA2MiwgODAsIDEpO1xcclxcbiAgYm94LXNoYWRvdzogMXB4IDFweCAycHggMXB4ICM5NWE1YTY7XFxyXFxuICBjb2xvcjogcmdiYSgyMzYsMjQwLDI0MSAsMSk7XFxyXFxufVxcclxcblxcclxcbi5jYXJkLWhlYWRlciB7XFxyXFxuICBtYXgtaGVpZ2h0OiAxMDBweDtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgcGFkZGluZzogNHB4O1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0NCwgNjIsIDgwLCAxKTtcXHJcXG4gIGJvcmRlci1ib3R0b206IDFweCAjMzQ0OTVlO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcclxcbiAgYWxpZ24tY29udGVudDogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZC1ib2R5IHtcXHJcXG4gIG1heC1oZWlnaHQ6IDIwMHB4O1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBwYWRkaW5nOiAycHg7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQ0LCA2MiwgODAsIDEpO1xcclxcbiAgYm9yZGVyLWJvdHRvbTogMXB4ICMzNDQ5NWU7XFxyXFxufVxcclxcblxcclxcbi5jYXJkOmhvdmVyIC5jYXJkLWRlbGV0ZSB7XFxyXFxuICBvcGFjaXR5OiAxO1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZC1mb290ZXIge1xcclxcbiAgbWF4LWhlaWdodDogMTAwcHg7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIHBhZGRpbmc6IDJweDtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDQsIDYyLCA4MCwgMSk7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1mbG93OiB3cmFwO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcclxcbiAgYWxpZ24tY29udGVudDogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZC1kZWxldGUge1xcclxcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcclxcbiAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgdG9wOiAtNXB4O1xcclxcbiAgcmlnaHQ6IC01cHg7XFxyXFxuICB3aWR0aDogMjBweDtcXHJcXG4gIGhlaWdodDogMjBweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXHJcXG4gIG9wYWNpdHk6IDA7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5jYXJkLWRlbGV0ZTpiZWZvcmUge1xcclxcbiAgZm9udC1zaXplOiAxMHB4O1xcclxcbiAgY29udGVudDogXFxcIlhcXFwiO1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZC1kZWxldGU6aG92ZXIge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogI2U3NGMzYztcXHJcXG4gIGNvbG9yOiByZ2JhKDQ0LCA2MiwgODAsIDEpO1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZC1idG4ge1xcclxcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcclxcbiAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcclxcbiAgaGVpZ2h0OiA0MHB4O1xcclxcbiAgbWFyZ2luOiAycHg7XFxyXFxuICBwYWRkaW5nOiAxMHB4O1xcclxcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgZm9udC1zaXplOiAxOHB4O1xcclxcbiAgdHJhbnNpdGlvbjogYWxsIDAuMnM7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1mbG93OiB3cmFwO1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZC1idG46aG92ZXIge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxODksMTk1LDE5OSwxKTtcXHJcXG4gICBjb2xvcjogcmdiYSg0NCwgNjIsIDgwLCAxKTtcXHJcXG59XFxyXFxuXFxyXFxuLmxhbmd1YWdlLWpzIHtcXHJcXG4gIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgcGFkZGluZzogMjBweDtcXHJcXG4gIGZvbnQtc2l6ZTogMTdweDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjJlbTtcXHJcXG4gIGJhY2tncm91bmQ6IHJnYmEoNDQsIDYyLCA4MCwgMSk7XFxyXFxuICBjb2xvcjogcmdiYSgzOSwgMTc0LCA5NiwgMSk7XFxyXFxuICBib3JkZXItcmFkaXVzOiA2cHg7XFxyXFxuICBmb250LWZhbWlseTogSW5jb25zb2xhdGE7XFxyXFxufVxcclxcblxcclxcbi5sYW5ndWFnZS1odG1sIHtcXHJcXG4gIGZvbnQtZmFtaWx5OiBjb2RlO1xcclxcbiAgYmFja2dyb3VuZDogcmdiYSg0NCwgNjIsIDgwLCAxKTtcXHJcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxODBkZWcsICNjY2MgMCwgI2NjYyAxLjJlbSwgI2VlZSAwKTtcXHJcXG4gIGNvbG9yOiByZ2JhKDQxLCAxMjgsIDE4NSwgMSk7XFxyXFxufVxcclxcblxcclxcbi5mdWxsLXdpZHRoIHtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDYwMHB4KSB7XFxyXFxuICAuY29udGFpbmVyIHtcXHJcXG4gICAgZmxleC1mbG93OiByb3c7XFxyXFxuICB9XFxyXFxufVxcclxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9jc3MtbG9hZGVyLzAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5tb2RhbC1jb250YWluZXIge1xcclxcbiAgcG9zaXRpb246YWJzb2x1dGU7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIGhlaWdodDogMTAwJTtcXHJcXG4gIGJhY2tncm91bmQ6IHJnYmEoNDQsIDYyLCA4MCwuOSk7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1mbG93OiBjb2x1bW47XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIHotaW5kZXg6IDEwO1xcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG4ubW9kYWwtY29udGFpbmVyID4gLmNhcmQge1xcclxcbiAgbWFyZ2luOiAwIGF1dG87XFxyXFxufVxcclxcblxcclxcbi5tb2RhbC1jb250ZW50IHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWZsb3c6IGNvbHVtbjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgYWxpZ24tY29udGVudDogY2VudGVyO1xcclxcbiAgd2lkdGg6IDgwJTtcXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsLWxhYmVsIHtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsLWlucHV0IHtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsLWNsb3NlIHtcXHJcXG4gIHdpZHRoOiAyMDBweDtcXHJcXG4gIGhlaWdodDogNDBweDtcXHJcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcclxcbn1cXHJcXG5cXHJcXG4ubW9kYWwtY2xvc2U6YmVmb3JlIHtcXHJcXG4gIGNvbnRlbnQ6ICdDYW5jZWwnXFxyXFxufVxcclxcblxcclxcbi5tb2RhbC1zYXZlQnRuIHtcXHJcXG5cXHJcXG59XFxyXFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL2Nzcy1sb2FkZXIvMC4yOC4xMS9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxyXFxuQGtleWZyYW1lcyBmYWRlSW4ge1xcclxcbiAgMCUge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgfVxcclxcblxcclxcbiAgMTAwJSB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgZmFkZU91dCB7XFxyXFxuICAwJSB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAxMDAlIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxuLnByZXNlbnRhdGlvbnMge1xcclxcbiAgYW5pbWF0aW9uOiBmYWRlSW4gLjVzIGVhc2UtaW4tb3V0O1xcclxcbn1cXHJcXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIucHJldmlldyB7XFxyXFxuICB3aWR0aDogMjAwcHg7XFxyXFxuICBoZWlnaHQ6IDIwMHB4O1xcclxcbiAgbWFyZ2luOiAxMnB4O1xcclxcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG59XFxyXFxuXFxyXFxuLmNhcmQucHJldmlldyB7XFxyXFxuICBjdXJzb3I6IGdyYWI7XFxyXFxufVxcclxcblxcclxcbi5wcmV2aWV3ID4gLmNhcmQtaGVhZGVyIHtcXHJcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG5cXHJcXG4ucHJldmlldyA+IC5jYXJkLWJvZHkge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcblxcclxcbi5wcmV2aWV3ID4gLmNhcmQtYm9keSA+ICoge1xcclxcbiAgb3BhY2l0eTogMC4xO1xcclxcbn1cXHJcXG5cXHJcXG4ucHJldmlldy1kZWxldGUge1xcclxcbiAgdG9wOiA0cHg7XFxyXFxuICByaWdodDogNHB4O1xcclxcbiAgei1pbmRleDogMztcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLnByZXZpZXctZGVsZXRlOmJlZm9yZSB7XFxyXFxuICBwYWRkaW5nLWxlZnQ6IDRweDtcXHJcXG59XFxyXFxuXFxyXFxuLnNsaWRlUG9zaXRpb24ge1xcclxcbiAgY29sb3I6ICNlNjdlMjI7XFxyXFxuICBmb250LXNpemU6IDZyZW07XFxyXFxufVxcclxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9jc3MtbG9hZGVyLzAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5zbGlkZXMge1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1ldmVubHk7XFxyXFxuICBhbmltYXRpb246IGZhZGVJbiAwLjVzIGVhc2UtaW4tb3V0O1xcclxcbn1cXHJcXG5cXHJcXG4ubGVmdC1kcmFnIHtcXHJcXG4gIGdyaWQtYXJlYTogbGVmdC1kcmFnO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZmxvdzogY29sdW1uO1xcclxcbiAgb3JkZXI6IDE7XFxyXFxuICBib3JkZXI6IDFweCBkYXNoZWQgcmdiYSg0NCwgNjIsIDgwLCAwLjMpO1xcclxcbiAgaGVpZ2h0OiA4OHZoO1xcclxcbn1cXHJcXG5cXHJcXG4ubGVmdC1kcmFnIC5jYXJkOmhvdmVyIHtcXHJcXG4gIGN1cnNvcjogZ3JhYjtcXHJcXG59XFxyXFxuXFxyXFxuLnJpZ2h0LWRyYWcge1xcclxcbiAgb3JkZXI6IDI7XFxyXFxuICBncmlkLWFyZWE6IHJpZ2h0LWRyYWc7XFxyXFxuICBmbGV4LWZsb3c6IHdyYXA7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgbWluLXdpZHRoOiAxMDAlO1xcclxcbiAgYm9yZGVyOiAxcHggZGFzaGVkIHJnYmEoNDQsIDYyLCA4MCwgMC4zKTtcXHJcXG59XFxyXFxuXFxyXFxuLmlzRHJhZ2dpbmcge1xcclxcbiAgYmFja2dyb3VuZDogcmdiYSg0NCwgNjIsIDgwLCAwLjMpO1xcclxcbiAgYm94LXNoYWRvdzogaW5zZXQgMCAwIDFweCByZ2JhKDQ0LCA2MiwgODAsIDEpO1xcclxcbn1cXHJcXG5cXHJcXG4uZHJvcCB7XFxyXFxuICBjdXJzb3I6IGRyb3A7XFxyXFxufVxcclxcblxcclxcbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNjAwcHgpIHtcXHJcXG4gIC5zbGlkZXMge1xcclxcbiAgICBkaXNwbGF5OiBpbmxpbmUtZ3JpZDtcXHJcXG4gICAgZ3JpZC10ZW1wbGF0ZS1hcmVhczogXFxcImxlZnQtZHJhZyByaWdodC1kcmFnXFxcIjtcXHJcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgMmZyO1xcclxcbiAgICBtYXgtaGVpZ2h0OiA5MHZoO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuc2xpZGVzaG93IHtcXHJcXG4gIGhlaWdodDogOTB2aDtcXHJcXG4gIHdpZHRoOiA5MCU7XFxyXFxuICBtYXJnaW46IDAgYXV0bztcXHJcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcclxcbiAgb3V0bGluZTogMDtcXHJcXG59XFxyXFxuXFxyXFxuLnNsaWRlY2FyZCB7XFxyXFxuICBhbmltYXRpb246IHN0cmV0Y2hSaWdodCAxcyBlYXNlLWluLW91dCBib3RoO1xcclxcbiAgb3V0bGluZTogMDtcXHJcXG59XFxyXFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL2Nzcy1sb2FkZXIvMC4yOC4xMS9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnRvb2xiYXIge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZmxvdzogY29sdW1uO1xcclxcbiAgbGluZS1oZWlnaHQ6IDI7XFxyXFxuICBiYWNrZ3JvdW5kOiAjZWNmMGYxO1xcclxcbiAgcGFkZGluZzogMnB4O1xcclxcbn1cXHJcXG5cXHJcXG4udG9vbGJhci1sZWZ0IHtcXHJcXG4gIG9yZGVyOiAxO1xcclxcbiAgZ3JpZC1hcmVhOiB0b29sYmFyLWxlZnQ7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1mbG93OiB3cmFwO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG4udG9vbGJhci1yaWdodCB7XFxyXFxuICBvcmRlcjogMjtcXHJcXG4gIGdyaWQtYXJlYTogdG9vbGJhci1yaWdodDtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWZsb3c6IHdyYXA7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxyXFxufVxcclxcblxcclxcbi50b29sYmFyLWl0ZW0ge1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcbiAgY29sb3I6IHJnYmEoNDQsIDYyLCA4MCwxKTtcXHJcXG4gIG1hcmdpbjogMnB4O1xcclxcbiAgcGFkZGluZzogMTBweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6MnB4O1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgdHJhbnNpdGlvbjogYWxsIC41cztcXHJcXG59XFxyXFxuXFxyXFxuLnRvb2xiYXItaXRlbTpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQ0LCA2MiwgODAsMSk7XFxyXFxuICBjb2xvcjogcmdiYSgyMzYsIDI0MCwgMjQxLDEuMCk7XFxyXFxufVxcclxcblxcclxcbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNjAwcHgpIHtcXHJcXG4gIC50b29sYmFyIHtcXHJcXG4gICAgZGlzcGxheTogaW5saW5lLWdyaWQ7XFxyXFxuICAgIGdyaWQtdGVtcGxhdGUtYXJlYXM6IFxcXCJ0b29sYmFyLWxlZnQgdG9vbGJhci1yaWdodFxcXCI7XFxyXFxuICAgIGxpbmUtaGVpZ2h0OiAyO1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDIzNiwgMjQwLCAyNDEsMS4wKTtcXHJcXG4gICAgcGFkZGluZzogMnB4O1xcclxcbiAgfVxcclxcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdGFzaycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbi8qKlxuICogQSBoZWxwZXIgZm9yIGRlbGF5aW5nIHRoZSBleGVjdXRpb24gb2YgYSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAc3VtbWFyeSAoQW55Li4uIC0+IEFueSkgLT4gVm9pZFxuICovXG52YXIgZGVsYXllZCA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnPyAgc2V0SW1tZWRpYXRlXG4gICAgICAgICAgICA6IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJz8gICAgICAgcHJvY2Vzcy5uZXh0VGlja1xuICAgICAgICAgICAgOiAvKiBvdGhlcndpc2UgKi8gICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXRcblxuLyoqXG4gKiBAbW9kdWxlIGxpYi90YXNrXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVGFzaztcblxuLy8gLS0gSW1wbGVtZW50YXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogVGhlIGBUYXNrW86xLCDOsl1gIHN0cnVjdHVyZSByZXByZXNlbnRzIHZhbHVlcyB0aGF0IGRlcGVuZCBvbiB0aW1lLiBUaGlzXG4gKiBhbGxvd3Mgb25lIHRvIG1vZGVsIHRpbWUtYmFzZWQgZWZmZWN0cyBleHBsaWNpdGx5LCBzdWNoIHRoYXQgb25lIGNhbiBoYXZlXG4gKiBmdWxsIGtub3dsZWRnZSBvZiB3aGVuIHRoZXkncmUgZGVhbGluZyB3aXRoIGRlbGF5ZWQgY29tcHV0YXRpb25zLCBsYXRlbmN5LFxuICogb3IgYW55dGhpbmcgdGhhdCBjYW4gbm90IGJlIGNvbXB1dGVkIGltbWVkaWF0ZWx5LlxuICpcbiAqIEEgY29tbW9uIHVzZSBmb3IgdGhpcyBzdHJ1Y3R1cmUgaXMgdG8gcmVwbGFjZSB0aGUgdXN1YWwgQ29udGludWF0aW9uLVBhc3NpbmdcbiAqIFN0eWxlIGZvcm0gb2YgcHJvZ3JhbW1pbmcsIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gY29tcG9zZSBhbmQgc2VxdWVuY2VcbiAqIHRpbWUtZGVwZW5kZW50IGVmZmVjdHMgdXNpbmcgdGhlIGdlbmVyaWMgYW5kIHBvd2VyZnVsIG1vbmFkaWMgb3BlcmF0aW9ucy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBzdW1tYXJ5XG4gKiAoKM6xIOKGkiBWb2lkKSwgKM6yIOKGkiBWb2lkKSDihpIgVm9pZCksIChWb2lkIOKGkiBWb2lkKSDihpIgVGFza1vOsSwgzrJdXG4gKlxuICogVGFza1vOsSwgzrJdIDw6IENoYWluW86yXVxuICogICAgICAgICAgICAgICAsIE1vbmFkW86yXVxuICogICAgICAgICAgICAgICAsIEZ1bmN0b3JbzrJdXG4gKiAgICAgICAgICAgICAgICwgQXBwbGljYXRpdmVbzrJdXG4gKiAgICAgICAgICAgICAgICwgU2VtaWdyb3VwW86yXVxuICogICAgICAgICAgICAgICAsIE1vbm9pZFvOsl1cbiAqICAgICAgICAgICAgICAgLCBTaG93XG4gKi9cbmZ1bmN0aW9uIFRhc2soY29tcHV0YXRpb24sIGNsZWFudXApIHtcbiAgdGhpcy5mb3JrID0gY29tcHV0YXRpb247XG5cbiAgdGhpcy5jbGVhbnVwID0gY2xlYW51cCB8fCBmdW5jdGlvbigpIHt9O1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYFRhc2tbzrEsIM6yXWAgY29udGFpbmluZyB0aGUgc2luZ2xlIHZhbHVlIGDOsmAuXG4gKlxuICogYM6yYCBjYW4gYmUgYW55IHZhbHVlLCBpbmNsdWRpbmcgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3IgYW5vdGhlclxuICogYFRhc2tbzrEsIM6yXWAgc3RydWN0dXJlLlxuICpcbiAqIEBzdW1tYXJ5IM6yIOKGkiBUYXNrW86xLCDOsl1cbiAqL1xuVGFzay5wcm90b3R5cGUub2YgPSBmdW5jdGlvbiBfb2YoYikge1xuICByZXR1cm4gbmV3IFRhc2soZnVuY3Rpb24oXywgcmVzb2x2ZSkge1xuICAgIHJldHVybiByZXNvbHZlKGIpO1xuICB9KTtcbn07XG5cblRhc2sub2YgPSBUYXNrLnByb3RvdHlwZS5vZjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBUYXNrW86xLCDOsl1gIGNvbnRhaW5pbmcgdGhlIHNpbmdsZSB2YWx1ZSBgzrFgLlxuICpcbiAqIGDOsWAgY2FuIGJlIGFueSB2YWx1ZSwgaW5jbHVkaW5nIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yIGFub3RoZXJcbiAqIGBUYXNrW86xLCDOsl1gIHN0cnVjdHVyZS5cbiAqXG4gKiBAc3VtbWFyeSDOsSDihpIgVGFza1vOsSwgzrJdXG4gKi9cblRhc2sucHJvdG90eXBlLnJlamVjdGVkID0gZnVuY3Rpb24gX3JlamVjdGVkKGEpIHtcbiAgcmV0dXJuIG5ldyBUYXNrKGZ1bmN0aW9uKHJlamVjdCkge1xuICAgIHJldHVybiByZWplY3QoYSk7XG4gIH0pO1xufTtcblxuVGFzay5yZWplY3RlZCA9IFRhc2sucHJvdG90eXBlLnJlamVjdGVkO1xuXG4vLyAtLSBGdW5jdG9yIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBzdWNjZXNzZnVsIHZhbHVlIG9mIHRoZSBgVGFza1vOsSwgzrJdYCB1c2luZyBhIHJlZ3VsYXIgdW5hcnlcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIEBzdW1tYXJ5IEBUYXNrW86xLCDOsl0gPT4gKM6yIOKGkiDOsykg4oaSIFRhc2tbzrEsIM6zXVxuICovXG5UYXNrLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBfbWFwKGYpIHtcbiAgdmFyIGZvcmsgPSB0aGlzLmZvcms7XG4gIHZhciBjbGVhbnVwID0gdGhpcy5jbGVhbnVwO1xuXG4gIHJldHVybiBuZXcgVGFzayhmdW5jdGlvbihyZWplY3QsIHJlc29sdmUpIHtcbiAgICByZXR1cm4gZm9yayhmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KGEpO1xuICAgIH0sIGZ1bmN0aW9uKGIpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKGYoYikpO1xuICAgIH0pO1xuICB9LCBjbGVhbnVwKTtcbn07XG5cbi8vIC0tIENoYWluIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHN1Y2Nlc2Z1bCB2YWx1ZSBvZiB0aGUgYFRhc2tbzrEsIM6yXWAgdXNpbmcgYSBmdW5jdGlvbiB0byBhXG4gKiBtb25hZC5cbiAqXG4gKiBAc3VtbWFyeSBAVGFza1vOsSwgzrJdID0+ICjOsiDihpIgVGFza1vOsSwgzrNdKSDihpIgVGFza1vOsSwgzrNdXG4gKi9cblRhc2sucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gX2NoYWluKGYpIHtcbiAgdmFyIGZvcmsgPSB0aGlzLmZvcms7XG4gIHZhciBjbGVhbnVwID0gdGhpcy5jbGVhbnVwO1xuXG4gIHJldHVybiBuZXcgVGFzayhmdW5jdGlvbihyZWplY3QsIHJlc29sdmUpIHtcbiAgICByZXR1cm4gZm9yayhmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KGEpO1xuICAgIH0sIGZ1bmN0aW9uKGIpIHtcbiAgICAgIHJldHVybiBmKGIpLmZvcmsocmVqZWN0LCByZXNvbHZlKTtcbiAgICB9KTtcbiAgfSwgY2xlYW51cCk7XG59O1xuXG4vLyAtLSBBcHBseSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBcHBseXMgdGhlIHN1Y2Nlc3NmdWwgdmFsdWUgb2YgdGhlIGBUYXNrW86xLCAozrIg4oaSIM6zKV1gIHRvIHRoZSBzdWNjZXNzZnVsXG4gKiB2YWx1ZSBvZiB0aGUgYFRhc2tbzrEsIM6yXWBcbiAqXG4gKiBAc3VtbWFyeSBAVGFza1vOsSwgKM6yIOKGkiDOsyldID0+IFRhc2tbzrEsIM6yXSDihpIgVGFza1vOsSwgzrNdXG4gKi9cblxuVGFzay5wcm90b3R5cGUuYXAgPSBmdW5jdGlvbiBfYXAodGhhdCkge1xuICB2YXIgZm9ya1RoaXMgPSB0aGlzLmZvcms7XG4gIHZhciBmb3JrVGhhdCA9IHRoYXQuZm9yaztcbiAgdmFyIGNsZWFudXBUaGlzID0gdGhpcy5jbGVhbnVwO1xuICB2YXIgY2xlYW51cFRoYXQgPSB0aGF0LmNsZWFudXA7XG5cbiAgZnVuY3Rpb24gY2xlYW51cEJvdGgoc3RhdGUpIHtcbiAgICBjbGVhbnVwVGhpcyhzdGF0ZVswXSk7XG4gICAgY2xlYW51cFRoYXQoc3RhdGVbMV0pO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUYXNrKGZ1bmN0aW9uKHJlamVjdCwgcmVzb2x2ZSkge1xuICAgIHZhciBmdW5jLCBmdW5jTG9hZGVkID0gZmFsc2U7XG4gICAgdmFyIHZhbCwgdmFsTG9hZGVkID0gZmFsc2U7XG4gICAgdmFyIHJlamVjdGVkID0gZmFsc2U7XG4gICAgdmFyIGFsbFN0YXRlO1xuXG4gICAgdmFyIHRoaXNTdGF0ZSA9IGZvcmtUaGlzKGd1YXJkUmVqZWN0LCBndWFyZFJlc29sdmUoZnVuY3Rpb24oeCkge1xuICAgICAgZnVuY0xvYWRlZCA9IHRydWU7XG4gICAgICBmdW5jID0geDtcbiAgICB9KSk7XG5cbiAgICB2YXIgdGhhdFN0YXRlID0gZm9ya1RoYXQoZ3VhcmRSZWplY3QsIGd1YXJkUmVzb2x2ZShmdW5jdGlvbih4KSB7XG4gICAgICB2YWxMb2FkZWQgPSB0cnVlO1xuICAgICAgdmFsID0geDtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBndWFyZFJlc29sdmUoc2V0dGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0ZXIoeCk7XG4gICAgICAgIGlmIChmdW5jTG9hZGVkICYmIHZhbExvYWRlZCkge1xuICAgICAgICAgIGRlbGF5ZWQoZnVuY3Rpb24oKXsgY2xlYW51cEJvdGgoYWxsU3RhdGUpIH0pO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGZ1bmModmFsKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBndWFyZFJlamVjdCh4KSB7XG4gICAgICBpZiAoIXJlamVjdGVkKSB7XG4gICAgICAgIHJlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlamVjdCh4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWxsU3RhdGUgPSBbdGhpc1N0YXRlLCB0aGF0U3RhdGVdO1xuICB9LCBjbGVhbnVwQm90aCk7XG59O1xuXG4vLyAtLSBTZW1pZ3JvdXAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogU2VsZWN0cyB0aGUgZWFybGllciBvZiB0aGUgdHdvIHRhc2tzIGBUYXNrW86xLCDOsl1gXG4gKlxuICogQHN1bW1hcnkgQFRhc2tbzrEsIM6yXSA9PiBUYXNrW86xLCDOsl0g4oaSIFRhc2tbzrEsIM6yXVxuICovXG5cblRhc2sucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIF9jb25jYXQodGhhdCkge1xuICB2YXIgZm9ya1RoaXMgPSB0aGlzLmZvcms7XG4gIHZhciBmb3JrVGhhdCA9IHRoYXQuZm9yaztcbiAgdmFyIGNsZWFudXBUaGlzID0gdGhpcy5jbGVhbnVwO1xuICB2YXIgY2xlYW51cFRoYXQgPSB0aGF0LmNsZWFudXA7XG5cbiAgZnVuY3Rpb24gY2xlYW51cEJvdGgoc3RhdGUpIHtcbiAgICBjbGVhbnVwVGhpcyhzdGF0ZVswXSk7XG4gICAgY2xlYW51cFRoYXQoc3RhdGVbMV0pO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUYXNrKGZ1bmN0aW9uKHJlamVjdCwgcmVzb2x2ZSkge1xuICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgdmFyIGFsbFN0YXRlO1xuICAgIHZhciB0aGlzU3RhdGUgPSBmb3JrVGhpcyhndWFyZChyZWplY3QpLCBndWFyZChyZXNvbHZlKSk7XG4gICAgdmFyIHRoYXRTdGF0ZSA9IGZvcmtUaGF0KGd1YXJkKHJlamVjdCksIGd1YXJkKHJlc29sdmUpKTtcblxuICAgIHJldHVybiBhbGxTdGF0ZSA9IFt0aGlzU3RhdGUsIHRoYXRTdGF0ZV07XG5cbiAgICBmdW5jdGlvbiBndWFyZChmKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICBkZWxheWVkKGZ1bmN0aW9uKCl7IGNsZWFudXBCb3RoKGFsbFN0YXRlKSB9KVxuICAgICAgICAgIHJldHVybiBmKHgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwgY2xlYW51cEJvdGgpO1xuXG59O1xuXG4vLyAtLSBNb25vaWQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogUmV0dXJucyBhIFRhc2sgdGhhdCB3aWxsIG5ldmVyIHJlc29sdmVcbiAqXG4gKiBAc3VtbWFyeSBWb2lkIOKGkiBUYXNrW86xLCBfXVxuICovXG5UYXNrLmVtcHR5ID0gZnVuY3Rpb24gX2VtcHR5KCkge1xuICByZXR1cm4gbmV3IFRhc2soZnVuY3Rpb24oKSB7fSk7XG59O1xuXG5UYXNrLnByb3RvdHlwZS5lbXB0eSA9IFRhc2suZW1wdHk7XG5cbi8vIC0tIFNob3cgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFJldHVybnMgYSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgVGFza1vOsSwgzrJdYFxuICpcbiAqIEBzdW1tYXJ5IEBUYXNrW86xLCDOsl0gPT4gVm9pZCDihpIgU3RyaW5nXG4gKi9cblRhc2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gX3RvU3RyaW5nKCkge1xuICByZXR1cm4gJ1Rhc2snO1xufTtcblxuLy8gLS0gRXh0cmFjdGluZyBhbmQgcmVjb3ZlcmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGZhaWx1cmUgdmFsdWUgaW50byBhIG5ldyBgVGFza1vOsSwgzrJdYC4gRG9lcyBub3RoaW5nIGlmIHRoZVxuICogc3RydWN0dXJlIGFscmVhZHkgY29udGFpbnMgYSBzdWNjZXNzZnVsIHZhbHVlLlxuICpcbiAqIEBzdW1tYXJ5IEBUYXNrW86xLCDOsl0gPT4gKM6xIOKGkiBUYXNrW86zLCDOsl0pIOKGkiBUYXNrW86zLCDOsl1cbiAqL1xuVGFzay5wcm90b3R5cGUub3JFbHNlID0gZnVuY3Rpb24gX29yRWxzZShmKSB7XG4gIHZhciBmb3JrID0gdGhpcy5mb3JrO1xuICB2YXIgY2xlYW51cCA9IHRoaXMuY2xlYW51cDtcblxuICByZXR1cm4gbmV3IFRhc2soZnVuY3Rpb24ocmVqZWN0LCByZXNvbHZlKSB7XG4gICAgcmV0dXJuIGZvcmsoZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGYoYSkuZm9yayhyZWplY3QsIHJlc29sdmUpO1xuICAgIH0sIGZ1bmN0aW9uKGIpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKGIpO1xuICAgIH0pO1xuICB9LCBjbGVhbnVwKTtcbn07XG5cbi8vIC0tIEZvbGRzIGFuZCBleHRlbmRlZCB0cmFuc2Zvcm1hdGlvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIENhdGFtb3JwaGlzbS4gVGFrZXMgdHdvIGZ1bmN0aW9ucywgYXBwbGllcyB0aGUgbGVmdG1vc3Qgb25lIHRvIHRoZSBmYWlsdXJlXG4gKiB2YWx1ZSwgYW5kIHRoZSByaWdodG1vc3Qgb25lIHRvIHRoZSBzdWNjZXNzZnVsIHZhbHVlLCBkZXBlbmRpbmcgb24gd2hpY2ggb25lXG4gKiBpcyBwcmVzZW50LlxuICpcbiAqIEBzdW1tYXJ5IEBUYXNrW86xLCDOsl0gPT4gKM6xIOKGkiDOsyksICjOsiDihpIgzrMpIOKGkiBUYXNrW860LCDOs11cbiAqL1xuVGFzay5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uIF9mb2xkKGYsIGcpIHtcbiAgdmFyIGZvcmsgPSB0aGlzLmZvcms7XG4gIHZhciBjbGVhbnVwID0gdGhpcy5jbGVhbnVwO1xuXG4gIHJldHVybiBuZXcgVGFzayhmdW5jdGlvbihyZWplY3QsIHJlc29sdmUpIHtcbiAgICByZXR1cm4gZm9yayhmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShmKGEpKTtcbiAgICB9LCBmdW5jdGlvbihiKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShnKGIpKTtcbiAgICB9KTtcbiAgfSwgY2xlYW51cCk7XG59O1xuXG4vKipcbiAqIENhdGFtb3JwaGlzbS5cbiAqXG4gKiBAc3VtbWFyeSBAVGFza1vOsSwgzrJdID0+IHsgUmVqZWN0ZWQ6IM6xIOKGkiDOsywgUmVzb2x2ZWQ6IM6yIOKGkiDOsyB9IOKGkiBUYXNrW860LCDOs11cbiAqL1xuVGFzay5wcm90b3R5cGUuY2F0YSA9IGZ1bmN0aW9uIF9jYXRhKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHRoaXMuZm9sZChwYXR0ZXJuLlJlamVjdGVkLCBwYXR0ZXJuLlJlc29sdmVkKTtcbn07XG5cbi8qKlxuICogU3dhcHMgdGhlIGRpc2p1bmN0aW9uIHZhbHVlcy5cbiAqXG4gKiBAc3VtbWFyeSBAVGFza1vOsSwgzrJdID0+IFZvaWQg4oaSIFRhc2tbzrIsIM6xXVxuICovXG5UYXNrLnByb3RvdHlwZS5zd2FwID0gZnVuY3Rpb24gX3N3YXAoKSB7XG4gIHZhciBmb3JrID0gdGhpcy5mb3JrO1xuICB2YXIgY2xlYW51cCA9IHRoaXMuY2xlYW51cDtcblxuICByZXR1cm4gbmV3IFRhc2soZnVuY3Rpb24ocmVqZWN0LCByZXNvbHZlKSB7XG4gICAgcmV0dXJuIGZvcmsoZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUoYSk7XG4gICAgfSwgZnVuY3Rpb24oYikge1xuICAgICAgcmV0dXJuIHJlamVjdChiKTtcbiAgICB9KTtcbiAgfSwgY2xlYW51cCk7XG59O1xuXG4vKipcbiAqIE1hcHMgYm90aCBzaWRlcyBvZiB0aGUgZGlzanVuY3Rpb24uXG4gKlxuICogQHN1bW1hcnkgQFRhc2tbzrEsIM6yXSA9PiAozrEg4oaSIM6zKSwgKM6yIOKGkiDOtCkg4oaSIFRhc2tbzrMsIM60XVxuICovXG5UYXNrLnByb3RvdHlwZS5iaW1hcCA9IGZ1bmN0aW9uIF9iaW1hcChmLCBnKSB7XG4gIHZhciBmb3JrID0gdGhpcy5mb3JrO1xuICB2YXIgY2xlYW51cCA9IHRoaXMuY2xlYW51cDtcblxuICByZXR1cm4gbmV3IFRhc2soZnVuY3Rpb24ocmVqZWN0LCByZXNvbHZlKSB7XG4gICAgcmV0dXJuIGZvcmsoZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHJlamVjdChmKGEpKTtcbiAgICB9LCBmdW5jdGlvbihiKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShnKGIpKTtcbiAgICB9KTtcbiAgfSwgY2xlYW51cCk7XG59O1xuXG4vKipcbiAqIE1hcHMgdGhlIGxlZnQgc2lkZSBvZiB0aGUgZGlzanVuY3Rpb24gKGZhaWx1cmUpLlxuICpcbiAqIEBzdW1tYXJ5IEBUYXNrW86xLCDOsl0gPT4gKM6xIOKGkiDOsykg4oaSIFRhc2tbzrMsIM6yXVxuICovXG5UYXNrLnByb3RvdHlwZS5yZWplY3RlZE1hcCA9IGZ1bmN0aW9uIF9yZWplY3RlZE1hcChmKSB7XG4gIHZhciBmb3JrID0gdGhpcy5mb3JrO1xuICB2YXIgY2xlYW51cCA9IHRoaXMuY2xlYW51cDtcblxuICByZXR1cm4gbmV3IFRhc2soZnVuY3Rpb24ocmVqZWN0LCByZXNvbHZlKSB7XG4gICAgcmV0dXJuIGZvcmsoZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIHJlamVjdChmKGEpKTtcbiAgICB9LCBmdW5jdGlvbihiKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShiKTtcbiAgICB9KTtcbiAgfSwgY2xlYW51cCk7XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cclxuOyhmdW5jdGlvbigpIHtcclxuXCJ1c2Ugc3RyaWN0XCJcclxuLyogZXNsaW50LWVuYWJsZSAqL1xyXG5cclxudmFyIGd1aWQgPSAwLCBIQUxUID0ge31cclxuZnVuY3Rpb24gY3JlYXRlU3RyZWFtKCkge1xyXG5cdGZ1bmN0aW9uIHN0cmVhbSgpIHtcclxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IEhBTFQpIHVwZGF0ZVN0cmVhbShzdHJlYW0sIGFyZ3VtZW50c1swXSlcclxuXHRcdHJldHVybiBzdHJlYW0uX3N0YXRlLnZhbHVlXHJcblx0fVxyXG5cdGluaXRTdHJlYW0oc3RyZWFtKVxyXG5cclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSBIQUxUKSB1cGRhdGVTdHJlYW0oc3RyZWFtLCBhcmd1bWVudHNbMF0pXHJcblxyXG5cdHJldHVybiBzdHJlYW1cclxufVxyXG5mdW5jdGlvbiBpbml0U3RyZWFtKHN0cmVhbSkge1xyXG5cdHN0cmVhbS5jb25zdHJ1Y3RvciA9IGNyZWF0ZVN0cmVhbVxyXG5cdHN0cmVhbS5fc3RhdGUgPSB7aWQ6IGd1aWQrKywgdmFsdWU6IHVuZGVmaW5lZCwgc3RhdGU6IDAsIGRlcml2ZTogdW5kZWZpbmVkLCByZWNvdmVyOiB1bmRlZmluZWQsIGRlcHM6IHt9LCBwYXJlbnRzOiBbXSwgZW5kU3RyZWFtOiB1bmRlZmluZWQsIHVucmVnaXN0ZXI6IHVuZGVmaW5lZH1cclxuXHRzdHJlYW0ubWFwID0gc3RyZWFtW1wiZmFudGFzeS1sYW5kL21hcFwiXSA9IG1hcCwgc3RyZWFtW1wiZmFudGFzeS1sYW5kL2FwXCJdID0gYXAsIHN0cmVhbVtcImZhbnRhc3ktbGFuZC9vZlwiXSA9IGNyZWF0ZVN0cmVhbVxyXG5cdHN0cmVhbS52YWx1ZU9mID0gdmFsdWVPZiwgc3RyZWFtLnRvSlNPTiA9IHRvSlNPTiwgc3RyZWFtLnRvU3RyaW5nID0gdmFsdWVPZlxyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJlYW0sIHtcclxuXHRcdGVuZDoge2dldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdGlmICghc3RyZWFtLl9zdGF0ZS5lbmRTdHJlYW0pIHtcclxuXHRcdFx0XHR2YXIgZW5kU3RyZWFtID0gY3JlYXRlU3RyZWFtKClcclxuXHRcdFx0XHRlbmRTdHJlYW0ubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IHRydWUpIHtcclxuXHRcdFx0XHRcdFx0dW5yZWdpc3RlclN0cmVhbShzdHJlYW0pXHJcblx0XHRcdFx0XHRcdGVuZFN0cmVhbS5fc3RhdGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uKCl7dW5yZWdpc3RlclN0cmVhbShlbmRTdHJlYW0pfVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlXHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHRzdHJlYW0uX3N0YXRlLmVuZFN0cmVhbSA9IGVuZFN0cmVhbVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBzdHJlYW0uX3N0YXRlLmVuZFN0cmVhbVxyXG5cdFx0fX1cclxuXHR9KVxyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZVN0cmVhbShzdHJlYW0sIHZhbHVlKSB7XHJcblx0dXBkYXRlU3RhdGUoc3RyZWFtLCB2YWx1ZSlcclxuXHRmb3IgKHZhciBpZCBpbiBzdHJlYW0uX3N0YXRlLmRlcHMpIHVwZGF0ZURlcGVuZGVuY3koc3RyZWFtLl9zdGF0ZS5kZXBzW2lkXSwgZmFsc2UpXHJcblx0aWYgKHN0cmVhbS5fc3RhdGUudW5yZWdpc3RlciAhPSBudWxsKSBzdHJlYW0uX3N0YXRlLnVucmVnaXN0ZXIoKVxyXG5cdGZpbmFsaXplKHN0cmVhbSlcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZShzdHJlYW0sIHZhbHVlKSB7XHJcblx0c3RyZWFtLl9zdGF0ZS52YWx1ZSA9IHZhbHVlXHJcblx0c3RyZWFtLl9zdGF0ZS5jaGFuZ2VkID0gdHJ1ZVxyXG5cdGlmIChzdHJlYW0uX3N0YXRlLnN0YXRlICE9PSAyKSBzdHJlYW0uX3N0YXRlLnN0YXRlID0gMVxyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZURlcGVuZGVuY3koc3RyZWFtLCBtdXN0U3luYykge1xyXG5cdHZhciBzdGF0ZSA9IHN0cmVhbS5fc3RhdGUsIHBhcmVudHMgPSBzdGF0ZS5wYXJlbnRzXHJcblx0aWYgKHBhcmVudHMubGVuZ3RoID4gMCAmJiBwYXJlbnRzLmV2ZXJ5KGFjdGl2ZSkgJiYgKG11c3RTeW5jIHx8IHBhcmVudHMuc29tZShjaGFuZ2VkKSkpIHtcclxuXHRcdHZhciB2YWx1ZSA9IHN0cmVhbS5fc3RhdGUuZGVyaXZlKClcclxuXHRcdGlmICh2YWx1ZSA9PT0gSEFMVCkgcmV0dXJuIGZhbHNlXHJcblx0XHR1cGRhdGVTdGF0ZShzdHJlYW0sIHZhbHVlKVxyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBmaW5hbGl6ZShzdHJlYW0pIHtcclxuXHRzdHJlYW0uX3N0YXRlLmNoYW5nZWQgPSBmYWxzZVxyXG5cdGZvciAodmFyIGlkIGluIHN0cmVhbS5fc3RhdGUuZGVwcykgc3RyZWFtLl9zdGF0ZS5kZXBzW2lkXS5fc3RhdGUuY2hhbmdlZCA9IGZhbHNlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbWJpbmUoZm4sIHN0cmVhbXMpIHtcclxuXHRpZiAoIXN0cmVhbXMuZXZlcnkodmFsaWQpKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhhdCBlYWNoIGl0ZW0gcGFzc2VkIHRvIHN0cmVhbS5jb21iaW5lL3N0cmVhbS5tZXJnZSBpcyBhIHN0cmVhbVwiKVxyXG5cdHJldHVybiBpbml0RGVwZW5kZW5jeShjcmVhdGVTdHJlYW0oKSwgc3RyZWFtcywgZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gZm4uYXBwbHkodGhpcywgc3RyZWFtcy5jb25jYXQoW3N0cmVhbXMuZmlsdGVyKGNoYW5nZWQpXSkpXHJcblx0fSlcclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdERlcGVuZGVuY3koZGVwLCBzdHJlYW1zLCBkZXJpdmUpIHtcclxuXHR2YXIgc3RhdGUgPSBkZXAuX3N0YXRlXHJcblx0c3RhdGUuZGVyaXZlID0gZGVyaXZlXHJcblx0c3RhdGUucGFyZW50cyA9IHN0cmVhbXMuZmlsdGVyKG5vdEVuZGVkKVxyXG5cclxuXHRyZWdpc3RlckRlcGVuZGVuY3koZGVwLCBzdGF0ZS5wYXJlbnRzKVxyXG5cdHVwZGF0ZURlcGVuZGVuY3koZGVwLCB0cnVlKVxyXG5cclxuXHRyZXR1cm4gZGVwXHJcbn1cclxuZnVuY3Rpb24gcmVnaXN0ZXJEZXBlbmRlbmN5KHN0cmVhbSwgcGFyZW50cykge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0cGFyZW50c1tpXS5fc3RhdGUuZGVwc1tzdHJlYW0uX3N0YXRlLmlkXSA9IHN0cmVhbVxyXG5cdFx0cmVnaXN0ZXJEZXBlbmRlbmN5KHN0cmVhbSwgcGFyZW50c1tpXS5fc3RhdGUucGFyZW50cylcclxuXHR9XHJcbn1cclxuZnVuY3Rpb24gdW5yZWdpc3RlclN0cmVhbShzdHJlYW0pIHtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0cmVhbS5fc3RhdGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIHBhcmVudCA9IHN0cmVhbS5fc3RhdGUucGFyZW50c1tpXVxyXG5cdFx0ZGVsZXRlIHBhcmVudC5fc3RhdGUuZGVwc1tzdHJlYW0uX3N0YXRlLmlkXVxyXG5cdH1cclxuXHRmb3IgKHZhciBpZCBpbiBzdHJlYW0uX3N0YXRlLmRlcHMpIHtcclxuXHRcdHZhciBkZXBlbmRlbnQgPSBzdHJlYW0uX3N0YXRlLmRlcHNbaWRdXHJcblx0XHR2YXIgaW5kZXggPSBkZXBlbmRlbnQuX3N0YXRlLnBhcmVudHMuaW5kZXhPZihzdHJlYW0pXHJcblx0XHRpZiAoaW5kZXggPiAtMSkgZGVwZW5kZW50Ll9zdGF0ZS5wYXJlbnRzLnNwbGljZShpbmRleCwgMSlcclxuXHR9XHJcblx0c3RyZWFtLl9zdGF0ZS5zdGF0ZSA9IDIgLy9lbmRlZFxyXG5cdHN0cmVhbS5fc3RhdGUuZGVwcyA9IHt9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcChmbikge3JldHVybiBjb21iaW5lKGZ1bmN0aW9uKHN0cmVhbSkge3JldHVybiBmbihzdHJlYW0oKSl9LCBbdGhpc10pfVxyXG5mdW5jdGlvbiBhcChzdHJlYW0pIHtyZXR1cm4gY29tYmluZShmdW5jdGlvbihzMSwgczIpIHtyZXR1cm4gczEoKShzMigpKX0sIFtzdHJlYW0sIHRoaXNdKX1cclxuZnVuY3Rpb24gdmFsdWVPZigpIHtyZXR1cm4gdGhpcy5fc3RhdGUudmFsdWV9XHJcbmZ1bmN0aW9uIHRvSlNPTigpIHtyZXR1cm4gdGhpcy5fc3RhdGUudmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdGhpcy5fc3RhdGUudmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9zdGF0ZS52YWx1ZS50b0pTT04oKSA6IHRoaXMuX3N0YXRlLnZhbHVlfVxyXG5cclxuZnVuY3Rpb24gdmFsaWQoc3RyZWFtKSB7cmV0dXJuIHN0cmVhbS5fc3RhdGUgfVxyXG5mdW5jdGlvbiBhY3RpdmUoc3RyZWFtKSB7cmV0dXJuIHN0cmVhbS5fc3RhdGUuc3RhdGUgPT09IDF9XHJcbmZ1bmN0aW9uIGNoYW5nZWQoc3RyZWFtKSB7cmV0dXJuIHN0cmVhbS5fc3RhdGUuY2hhbmdlZH1cclxuZnVuY3Rpb24gbm90RW5kZWQoc3RyZWFtKSB7cmV0dXJuIHN0cmVhbS5fc3RhdGUuc3RhdGUgIT09IDJ9XHJcblxyXG5mdW5jdGlvbiBtZXJnZShzdHJlYW1zKSB7XHJcblx0cmV0dXJuIGNvbWJpbmUoZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gc3RyZWFtcy5tYXAoZnVuY3Rpb24ocykge3JldHVybiBzKCl9KVxyXG5cdH0sIHN0cmVhbXMpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNjYW4ocmVkdWNlciwgc2VlZCwgc3RyZWFtKSB7XHJcblx0dmFyIG5ld1N0cmVhbSA9IGNvbWJpbmUoZnVuY3Rpb24gKHMpIHtcclxuXHRcdHJldHVybiBzZWVkID0gcmVkdWNlcihzZWVkLCBzLl9zdGF0ZS52YWx1ZSlcclxuXHR9LCBbc3RyZWFtXSlcclxuXHJcblx0aWYgKG5ld1N0cmVhbS5fc3RhdGUuc3RhdGUgPT09IDApIG5ld1N0cmVhbShzZWVkKVxyXG5cclxuXHRyZXR1cm4gbmV3U3RyZWFtXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNjYW5NZXJnZSh0dXBsZXMsIHNlZWQpIHtcclxuXHR2YXIgc3RyZWFtcyA9IHR1cGxlcy5tYXAoZnVuY3Rpb24odHVwbGUpIHtcclxuXHRcdHZhciBzdHJlYW0gPSB0dXBsZVswXVxyXG5cdFx0aWYgKHN0cmVhbS5fc3RhdGUuc3RhdGUgPT09IDApIHN0cmVhbSh1bmRlZmluZWQpXHJcblx0XHRyZXR1cm4gc3RyZWFtXHJcblx0fSlcclxuXHJcblx0dmFyIG5ld1N0cmVhbSA9IGNvbWJpbmUoZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgY2hhbmdlZCA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV1cclxuXHJcblx0XHRzdHJlYW1zLmZvckVhY2goZnVuY3Rpb24oc3RyZWFtLCBpZHgpIHtcclxuXHRcdFx0aWYgKGNoYW5nZWQuaW5kZXhPZihzdHJlYW0pID4gLTEpIHtcclxuXHRcdFx0XHRzZWVkID0gdHVwbGVzW2lkeF1bMV0oc2VlZCwgc3RyZWFtLl9zdGF0ZS52YWx1ZSlcclxuXHRcdFx0fVxyXG5cdFx0fSlcclxuXHJcblx0XHRyZXR1cm4gc2VlZFxyXG5cdH0sIHN0cmVhbXMpXHJcblxyXG5cdHJldHVybiBuZXdTdHJlYW1cclxufVxyXG5cclxuY3JlYXRlU3RyZWFtW1wiZmFudGFzeS1sYW5kL29mXCJdID0gY3JlYXRlU3RyZWFtXHJcbmNyZWF0ZVN0cmVhbS5tZXJnZSA9IG1lcmdlXHJcbmNyZWF0ZVN0cmVhbS5jb21iaW5lID0gY29tYmluZVxyXG5jcmVhdGVTdHJlYW0uc2NhbiA9IHNjYW5cclxuY3JlYXRlU3RyZWFtLnNjYW5NZXJnZSA9IHNjYW5NZXJnZVxyXG5jcmVhdGVTdHJlYW0uSEFMVCA9IEhBTFRcclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSBtb2R1bGVbXCJleHBvcnRzXCJdID0gY3JlYXRlU3RyZWFtXHJcbmVsc2UgaWYgKHR5cGVvZiB3aW5kb3cubSA9PT0gXCJmdW5jdGlvblwiICYmICEoXCJzdHJlYW1cIiBpbiB3aW5kb3cubSkpIHdpbmRvdy5tLnN0cmVhbSA9IGNyZWF0ZVN0cmVhbVxyXG5lbHNlIHdpbmRvdy5tID0ge3N0cmVhbSA6IGNyZWF0ZVN0cmVhbX1cclxuXHJcbn0oKSk7XHJcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBWbm9kZSA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvdm5vZGVcIilcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyZWRyYXdTZXJ2aWNlKSB7XG5cdHJldHVybiBmdW5jdGlvbihyb290LCBjb21wb25lbnQpIHtcblx0XHRpZiAoY29tcG9uZW50ID09PSBudWxsKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlLnVuc3Vic2NyaWJlKHJvb3QpXG5cdFx0fSBlbHNlIGlmIChjb21wb25lbnQudmlldyA9PSBudWxsICYmIHR5cGVvZiBjb21wb25lbnQgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibS5tb3VudChlbGVtZW50LCBjb21wb25lbnQpIGV4cGVjdHMgYSBjb21wb25lbnQsIG5vdCBhIHZub2RlXCIpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlZHJhd1NlcnZpY2Uuc3Vic2NyaWJlKHJvb3QsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVm5vZGUoY29tcG9uZW50KSB9KVxuXHRcdH1cblx0fVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGNvcmVSZW5kZXJlciA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvcmVuZGVyXCIpXG5cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrKSB7XG5cdHZhciBwZW5kaW5nID0gbnVsbFxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHBlbmRpbmcgPT09IG51bGwpIHtcblx0XHRcdHBlbmRpbmcgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHBlbmRpbmcgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrKClcblx0XHRcdH0pXG5cdFx0fVxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJHdpbmRvdywgdGhyb3R0bGVNb2NrKSB7XG5cdHZhciByZW5kZXJTZXJ2aWNlID0gY29yZVJlbmRlcmVyKCR3aW5kb3cpXG5cdHZhciBzdWJzY3JpcHRpb25zID0gW11cblx0dmFyIHJlbmRlcmluZyA9IGZhbHNlXG5cblx0ZnVuY3Rpb24gcnVuKHN1Yikge1xuXHRcdHZhciB2bm9kZSA9IHN1Yi5jKHN1Yilcblx0XHRpZiAodm5vZGUgIT09IHN1YikgcmVuZGVyU2VydmljZS5yZW5kZXIoc3ViLmssIHZub2RlKVxuXHR9XG5cdGZ1bmN0aW9uIHN1YnNjcmliZShrZXksIGNhbGxiYWNrLCBvbnJlbW92ZSkge1xuXHRcdHZhciBzdWIgPSB7azoga2V5LCBjOiBjYWxsYmFjaywgcjogb25yZW1vdmV9XG5cdFx0dW5zdWJzY3JpYmUoa2V5KVxuXHRcdHN1YnNjcmlwdGlvbnMucHVzaChzdWIpXG5cdFx0dmFyIHZub2RlID0gc3ViLmMoc3ViKVxuXHRcdGlmICh2bm9kZSAhPT0gc3ViKSByZW5kZXJTZXJ2aWNlLnJlbmRlcihzdWIuaywgdm5vZGUpXG5cdH1cblx0ZnVuY3Rpb24gdW5zdWJzY3JpYmUoa2V5KSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgc3ViID0gc3Vic2NyaXB0aW9uc1tpXVxuXHRcdFx0aWYgKHN1Yi5rID09PSBrZXkpIHtcblx0XHRcdFx0c3Vic2NyaXB0aW9ucy5zcGxpY2UoaSwgMSlcblx0XHRcdFx0cmVuZGVyU2VydmljZS5yZW5kZXIoc3ViLmssIFtdKVxuXHRcdFx0XHRpZiAodHlwZW9mIHN1Yi5yID09PSBcImZ1bmN0aW9uXCIpIHN1Yi5yKClcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc3luYygpIHtcblx0XHRpZiAocmVuZGVyaW5nKSB0aHJvdyBuZXcgRXJyb3IoXCJOZXN0ZWQgbS5yZWRyYXcuc3luYygpIGNhbGxcIilcblx0XHRyZW5kZXJpbmcgPSB0cnVlXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0cnkgeyBydW4oc3Vic2NyaXB0aW9uc1tpXSkgfVxuXHRcdFx0Y2F0Y2ggKGUpIHsgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLmVycm9yKGUpIH1cblx0XHR9XG5cdFx0cmVuZGVyaW5nID0gZmFsc2Vcblx0fVxuXG5cdHZhciByZWRyYXcgPSAodGhyb3R0bGVNb2NrIHx8IHRocm90dGxlKShzeW5jKVxuXHRyZWRyYXcuc3luYyA9IHN5bmNcblx0cmVuZGVyU2VydmljZS5zZXRSZWRyYXcocmVkcmF3KVxuXHRyZXR1cm4ge3N1YnNjcmliZTogc3Vic2NyaWJlLCB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUsIHJlZHJhdzogcmVkcmF3LCByZW5kZXI6IHJlbmRlclNlcnZpY2UucmVuZGVyfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIFZub2RlID0gcmVxdWlyZShcIi4uL3JlbmRlci92bm9kZVwiKVxudmFyIFByb21pc2UgPSByZXF1aXJlKFwiLi4vcHJvbWlzZS9wcm9taXNlXCIpXG52YXIgY29yZVJvdXRlciA9IHJlcXVpcmUoXCIuLi9yb3V0ZXIvcm91dGVyXCIpXG5cbnZhciBzZW50aW5lbCA9IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oJHdpbmRvdywgcmVkcmF3U2VydmljZSkge1xuXHR2YXIgcm91dGVTZXJ2aWNlID0gY29yZVJvdXRlcigkd2luZG93KVxuXG5cdHZhciBjdXJyZW50UmVzb2x2ZXIgPSBzZW50aW5lbCwgY29tcG9uZW50LCBhdHRycywgY3VycmVudFBhdGgsIGxhc3RVcGRhdGVcblx0dmFyIHJvdXRlID0gZnVuY3Rpb24ocm9vdCwgZGVmYXVsdFJvdXRlLCByb3V0ZXMpIHtcblx0XHRpZiAocm9vdCA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IHRoYXQgd2FzIHBhc3NlZCB0byBgbS5yb3V0ZWAgaXMgbm90IHVuZGVmaW5lZFwiKVxuXHRcdHZhciBpbml0ID0gZmFsc2Vcblx0XHR2YXIgYmFpbCA9IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdGlmIChwYXRoICE9PSBkZWZhdWx0Um91dGUpIHJvdXRlU2VydmljZS5zZXRQYXRoKGRlZmF1bHRSb3V0ZSwgbnVsbCwge3JlcGxhY2U6IHRydWV9KVxuXHRcdFx0ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSBkZWZhdWx0IHJvdXRlIFwiICsgZGVmYXVsdFJvdXRlKVxuXHRcdH1cblx0XHRmdW5jdGlvbiBydW4oKSB7XG5cdFx0XHRpbml0ID0gdHJ1ZVxuXHRcdFx0aWYgKHNlbnRpbmVsICE9PSBjdXJyZW50UmVzb2x2ZXIpIHtcblx0XHRcdFx0dmFyIHZub2RlID0gVm5vZGUoY29tcG9uZW50LCBhdHRycy5rZXksIGF0dHJzKVxuXHRcdFx0XHRpZiAoY3VycmVudFJlc29sdmVyKSB2bm9kZSA9IGN1cnJlbnRSZXNvbHZlci5yZW5kZXIodm5vZGUpXG5cdFx0XHRcdHJldHVybiB2bm9kZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyb3V0ZVNlcnZpY2UuZGVmaW5lUm91dGVzKHJvdXRlcywgZnVuY3Rpb24ocGF5bG9hZCwgcGFyYW1zLCBwYXRoLCByb3V0ZSkge1xuXHRcdFx0dmFyIHVwZGF0ZSA9IGxhc3RVcGRhdGUgPSBmdW5jdGlvbihyb3V0ZVJlc29sdmVyLCBjb21wKSB7XG5cdFx0XHRcdGlmICh1cGRhdGUgIT09IGxhc3RVcGRhdGUpIHJldHVyblxuXHRcdFx0XHRjb21wb25lbnQgPSBjb21wICE9IG51bGwgJiYgKHR5cGVvZiBjb21wLnZpZXcgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgY29tcCA9PT0gXCJmdW5jdGlvblwiKT8gY29tcCA6IFwiZGl2XCJcblx0XHRcdFx0YXR0cnMgPSBwYXJhbXMsIGN1cnJlbnRQYXRoID0gcGF0aCwgbGFzdFVwZGF0ZSA9IG51bGxcblx0XHRcdFx0Y3VycmVudFJlc29sdmVyID0gcm91dGVSZXNvbHZlci5yZW5kZXIgPyByb3V0ZVJlc29sdmVyIDogbnVsbFxuXHRcdFx0XHRpZiAoaW5pdCkgcmVkcmF3U2VydmljZS5yZWRyYXcoKVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpbml0ID0gdHJ1ZVxuXHRcdFx0XHRcdHJlZHJhd1NlcnZpY2UucmVkcmF3LnN5bmMoKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAocGF5bG9hZC52aWV3IHx8IHR5cGVvZiBwYXlsb2FkID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZSh7fSwgcGF5bG9hZClcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAocGF5bG9hZC5vbm1hdGNoKSB7XG5cdFx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKHBheWxvYWQub25tYXRjaChwYXJhbXMsIHBhdGgsIHJvdXRlKSkudGhlbihmdW5jdGlvbihyZXNvbHZlZCkge1xuXHRcdFx0XHRcdFx0dXBkYXRlKHBheWxvYWQsIHJlc29sdmVkKVxuXHRcdFx0XHRcdH0sIGZ1bmN0aW9uICgpIHsgYmFpbChwYXRoKSB9KVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgdXBkYXRlKHBheWxvYWQsIFwiZGl2XCIpXG5cdFx0XHR9XG5cdFx0fSwgYmFpbCwgZGVmYXVsdFJvdXRlLCBmdW5jdGlvbiAodW5zdWJzY3JpYmUpIHtcblx0XHRcdHJlZHJhd1NlcnZpY2Uuc3Vic2NyaWJlKHJvb3QsIGZ1bmN0aW9uKHN1Yikge1xuXHRcdFx0XHRzdWIuYyA9IHJ1blxuXHRcdFx0XHRyZXR1cm4gc3ViXG5cdFx0XHR9LCB1bnN1YnNjcmliZSlcblx0XHR9KVxuXHR9XG5cdHJvdXRlLnNldCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHRpZiAobGFzdFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXHRcdFx0b3B0aW9ucy5yZXBsYWNlID0gdHJ1ZVxuXHRcdH1cblx0XHRsYXN0VXBkYXRlID0gbnVsbFxuXHRcdHJvdXRlU2VydmljZS5zZXRQYXRoKHBhdGgsIGRhdGEsIG9wdGlvbnMpXG5cdH1cblx0cm91dGUuZ2V0ID0gZnVuY3Rpb24oKSB7cmV0dXJuIGN1cnJlbnRQYXRofVxuXHRyb3V0ZS5wcmVmaXggPSBmdW5jdGlvbihwcmVmaXgpIHtyb3V0ZVNlcnZpY2UucHJlZml4ID0gcHJlZml4fVxuXHR2YXIgbGluayA9IGZ1bmN0aW9uKG9wdGlvbnMsIHZub2RlKSB7XG5cdFx0dm5vZGUuZG9tLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgcm91dGVTZXJ2aWNlLnByZWZpeCArIHZub2RlLmF0dHJzLmhyZWYpXG5cdFx0dm5vZGUuZG9tLm9uY2xpY2sgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5IHx8IGUud2hpY2ggPT09IDIpIHJldHVyblxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRlLnJlZHJhdyA9IGZhbHNlXG5cdFx0XHR2YXIgaHJlZiA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKVxuXHRcdFx0aWYgKGhyZWYuaW5kZXhPZihyb3V0ZVNlcnZpY2UucHJlZml4KSA9PT0gMCkgaHJlZiA9IGhyZWYuc2xpY2Uocm91dGVTZXJ2aWNlLnByZWZpeC5sZW5ndGgpXG5cdFx0XHRyb3V0ZS5zZXQoaHJlZiwgdW5kZWZpbmVkLCBvcHRpb25zKVxuXHRcdH1cblx0fVxuXHRyb3V0ZS5saW5rID0gZnVuY3Rpb24oYXJncykge1xuXHRcdGlmIChhcmdzLnRhZyA9PSBudWxsKSByZXR1cm4gbGluay5iaW5kKGxpbmssIGFyZ3MpXG5cdFx0cmV0dXJuIGxpbmsoe30sIGFyZ3MpXG5cdH1cblx0cm91dGUucGFyYW0gPSBmdW5jdGlvbihrZXkpIHtcblx0XHRpZih0eXBlb2YgYXR0cnMgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGtleSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGF0dHJzW2tleV1cblx0XHRyZXR1cm4gYXR0cnNcblx0fVxuXG5cdHJldHVybiByb3V0ZVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGh5cGVyc2NyaXB0ID0gcmVxdWlyZShcIi4vcmVuZGVyL2h5cGVyc2NyaXB0XCIpXG5cbmh5cGVyc2NyaXB0LnRydXN0ID0gcmVxdWlyZShcIi4vcmVuZGVyL3RydXN0XCIpXG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IHJlcXVpcmUoXCIuL3JlbmRlci9mcmFnbWVudFwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGVyc2NyaXB0XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgaHlwZXJzY3JpcHQgPSByZXF1aXJlKFwiLi9oeXBlcnNjcmlwdFwiKVxudmFyIG0gPSBmdW5jdGlvbiBtKCkgeyByZXR1cm4gaHlwZXJzY3JpcHQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG5tLm0gPSBoeXBlcnNjcmlwdFxubS50cnVzdCA9IGh5cGVyc2NyaXB0LnRydXN0XG5tLmZyYWdtZW50ID0gaHlwZXJzY3JpcHQuZnJhZ21lbnRcblxudmFyIHJlcXVlc3RTZXJ2aWNlID0gcmVxdWlyZShcIi4vcmVxdWVzdFwiKVxudmFyIHJlZHJhd1NlcnZpY2UgPSByZXF1aXJlKFwiLi9yZWRyYXdcIilcblxucmVxdWVzdFNlcnZpY2Uuc2V0Q29tcGxldGlvbkNhbGxiYWNrKHJlZHJhd1NlcnZpY2UucmVkcmF3KVxuXG5tLm1vdW50ID0gcmVxdWlyZShcIi4vbW91bnRcIilcbm0ucm91dGUgPSByZXF1aXJlKFwiLi9yb3V0ZVwiKVxubS5yZW5kZXIgPSByZXF1aXJlKFwiLi9yZW5kZXJcIikucmVuZGVyXG5tLnJlZHJhdyA9IHJlZHJhd1NlcnZpY2UucmVkcmF3XG5tLnJlcXVlc3QgPSByZXF1ZXN0U2VydmljZS5yZXF1ZXN0XG5tLmpzb25wID0gcmVxdWVzdFNlcnZpY2UuanNvbnBcbm0ucGFyc2VRdWVyeVN0cmluZyA9IHJlcXVpcmUoXCIuL3F1ZXJ5c3RyaW5nL3BhcnNlXCIpXG5tLmJ1aWxkUXVlcnlTdHJpbmcgPSByZXF1aXJlKFwiLi9xdWVyeXN0cmluZy9idWlsZFwiKVxubS5wYXJzZVBhdGhuYW1lID0gcmVxdWlyZShcIi4vcGF0aG5hbWUvcGFyc2VcIilcbm0uYnVpbGRQYXRobmFtZSA9IHJlcXVpcmUoXCIuL3BhdGhuYW1lL2J1aWxkXCIpXG5tLnZlcnNpb24gPSByZXF1aXJlKFwiLi9wYWNrYWdlLmpzb25cIikudmVyc2lvblxubS52bm9kZSA9IHJlcXVpcmUoXCIuL3JlbmRlci92bm9kZVwiKVxubS5Qcm9taXNlUG9seWZpbGwgPSByZXF1aXJlKFwiLi9wcm9taXNlL3BvbHlmaWxsXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gbVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIHJlZHJhd1NlcnZpY2UgPSByZXF1aXJlKFwiLi9yZWRyYXdcIilcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9hcGkvbW91bnRcIikocmVkcmF3U2VydmljZSlcbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSkge1xuXHRpZihzb3VyY2UpIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XSB9KVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSByZXF1aXJlKFwiLi4vcXVlcnlzdHJpbmcvYnVpbGRcIilcbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9hc3NpZ25cIilcblxuLy8gUmV0dXJucyBgcGF0aGAgZnJvbSBgdGVtcGxhdGVgICsgYHBhcmFtc2Bcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGVtcGxhdGUsIHBhcmFtcykge1xuXHRpZiAoKC86KFteXFwvXFwuLV0rKShcXC57M30pPzovKS50ZXN0KHRlbXBsYXRlKSkge1xuXHRcdHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRlbXBsYXRlIHBhcmFtZXRlciBuYW1lcyAqbXVzdCogYmUgc2VwYXJhdGVkXCIpXG5cdH1cblx0aWYgKHBhcmFtcyA9PSBudWxsKSByZXR1cm4gdGVtcGxhdGVcblx0dmFyIHF1ZXJ5SW5kZXggPSB0ZW1wbGF0ZS5pbmRleE9mKFwiP1wiKVxuXHR2YXIgaGFzaEluZGV4ID0gdGVtcGxhdGUuaW5kZXhPZihcIiNcIilcblx0dmFyIHF1ZXJ5RW5kID0gaGFzaEluZGV4IDwgMCA/IHRlbXBsYXRlLmxlbmd0aCA6IGhhc2hJbmRleFxuXHR2YXIgcGF0aEVuZCA9IHF1ZXJ5SW5kZXggPCAwID8gcXVlcnlFbmQgOiBxdWVyeUluZGV4XG5cdHZhciBwYXRoID0gdGVtcGxhdGUuc2xpY2UoMCwgcGF0aEVuZClcblx0dmFyIHF1ZXJ5ID0ge31cblxuXHRhc3NpZ24ocXVlcnksIHBhcmFtcylcblxuXHR2YXIgcmVzb2x2ZWQgPSBwYXRoLnJlcGxhY2UoLzooW15cXC9cXC4tXSspKFxcLnszfSk/L2csIGZ1bmN0aW9uKG0sIGtleSwgdmFyaWFkaWMpIHtcblx0XHRkZWxldGUgcXVlcnlba2V5XVxuXHRcdC8vIElmIG5vIHN1Y2ggcGFyYW1ldGVyIGV4aXN0cywgZG9uJ3QgaW50ZXJwb2xhdGUgaXQuXG5cdFx0aWYgKHBhcmFtc1trZXldID09IG51bGwpIHJldHVybiBtXG5cdFx0Ly8gRXNjYXBlIG5vcm1hbCBwYXJhbWV0ZXJzLCBidXQgbm90IHZhcmlhZGljIG9uZXMuXG5cdFx0cmV0dXJuIHZhcmlhZGljID8gcGFyYW1zW2tleV0gOiBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHBhcmFtc1trZXldKSlcblx0fSlcblxuXHQvLyBJbiBjYXNlIHRoZSB0ZW1wbGF0ZSBzdWJzdGl0dXRpb24gYWRkcyBuZXcgcXVlcnkvaGFzaCBwYXJhbWV0ZXJzLlxuXHR2YXIgbmV3UXVlcnlJbmRleCA9IHJlc29sdmVkLmluZGV4T2YoXCI/XCIpXG5cdHZhciBuZXdIYXNoSW5kZXggPSByZXNvbHZlZC5pbmRleE9mKFwiI1wiKVxuXHR2YXIgbmV3UXVlcnlFbmQgPSBuZXdIYXNoSW5kZXggPCAwID8gcmVzb2x2ZWQubGVuZ3RoIDogbmV3SGFzaEluZGV4XG5cdHZhciBuZXdQYXRoRW5kID0gbmV3UXVlcnlJbmRleCA8IDAgPyBuZXdRdWVyeUVuZCA6IG5ld1F1ZXJ5SW5kZXhcblx0dmFyIHJlc3VsdCA9IHJlc29sdmVkLnNsaWNlKDAsIG5ld1BhdGhFbmQpXG5cblx0aWYgKHF1ZXJ5SW5kZXggPj0gMCkgcmVzdWx0ICs9IHRlbXBsYXRlLnNsaWNlKHF1ZXJ5SW5kZXgsIHF1ZXJ5RW5kKVxuXHRpZiAobmV3UXVlcnlJbmRleCA+PSAwKSByZXN1bHQgKz0gKHF1ZXJ5SW5kZXggPCAwID8gXCI/XCIgOiBcIiZcIikgKyByZXNvbHZlZC5zbGljZShuZXdRdWVyeUluZGV4LCBuZXdRdWVyeUVuZClcblx0dmFyIHF1ZXJ5c3RyaW5nID0gYnVpbGRRdWVyeVN0cmluZyhxdWVyeSlcblx0aWYgKHF1ZXJ5c3RyaW5nKSByZXN1bHQgKz0gKHF1ZXJ5SW5kZXggPCAwICYmIG5ld1F1ZXJ5SW5kZXggPCAwID8gXCI/XCIgOiBcIiZcIikgKyBxdWVyeXN0cmluZ1xuXHRpZiAoaGFzaEluZGV4ID49IDApIHJlc3VsdCArPSB0ZW1wbGF0ZS5zbGljZShoYXNoSW5kZXgpXG5cdGlmIChuZXdIYXNoSW5kZXggPj0gMCkgcmVzdWx0ICs9IChoYXNoSW5kZXggPCAwID8gXCJcIiA6IFwiJlwiKSArIHJlc29sdmVkLnNsaWNlKG5ld0hhc2hJbmRleClcblx0cmV0dXJuIHJlc3VsdFxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIHBhcnNlUGF0aG5hbWUgPSByZXF1aXJlKFwiLi9wYXJzZVwiKVxuXG4vLyBDb21waWxlcyBhIHRlbXBsYXRlIGludG8gYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgcmVzb2x2ZWQgcGF0aCAod2l0aG91dCBxdWVyeVxuLy8gc3RyaW5ncykgYW5kIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRlbXBsYXRlIHBhcmFtZXRlcnMgd2l0aCB0aGVpclxuLy8gcGFyc2VkIHZhbHVlcy4gVGhpcyBleHBlY3RzIHRoZSBpbnB1dCBvZiB0aGUgY29tcGlsZWQgdGVtcGxhdGUgdG8gYmUgdGhlXG4vLyBvdXRwdXQgb2YgYHBhcnNlUGF0aG5hbWVgLiBOb3RlIHRoYXQgaXQgZG9lcyAqbm90KiByZW1vdmUgcXVlcnkgcGFyYW1ldGVyc1xuLy8gc3BlY2lmaWVkIGluIHRoZSB0ZW1wbGF0ZS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGVtcGxhdGUpIHtcblx0dmFyIHRlbXBsYXRlRGF0YSA9IHBhcnNlUGF0aG5hbWUodGVtcGxhdGUpXG5cdHZhciB0ZW1wbGF0ZUtleXMgPSBPYmplY3Qua2V5cyh0ZW1wbGF0ZURhdGEucGFyYW1zKVxuXHR2YXIga2V5cyA9IFtdXG5cdHZhciByZWdleHAgPSBuZXcgUmVnRXhwKFwiXlwiICsgdGVtcGxhdGVEYXRhLnBhdGgucmVwbGFjZShcblx0XHQvLyBJIGVzY2FwZSBsaXRlcmFsIHRleHQgc28gcGVvcGxlIGNhbiB1c2UgdGhpbmdzIGxpa2UgYDpmaWxlLjpleHRgIG9yXG5cdFx0Ly8gYDpsYW5nLTpsb2NhbGVgIGluIHJvdXRlcy4gVGhpcyBpcyBhbGwgbWVyZ2VkIGludG8gb25lIHBhc3Mgc28gSVxuXHRcdC8vIGRvbid0IGFsc28gYWNjaWRlbnRhbGx5IGVzY2FwZSBgLWAgYW5kIG1ha2UgaXQgaGFyZGVyIHRvIGRldGVjdCBpdCB0b1xuXHRcdC8vIGJhbiBpdCBmcm9tIHRlbXBsYXRlIHBhcmFtZXRlcnMuXG5cdFx0LzooW15cXC8uLV0rKShcXC57M318XFwuKD8hXFwuKXwtKT98W1xcXFxeJCorLigpfFxcW1xcXXt9XS9nLFxuXHRcdGZ1bmN0aW9uKG0sIGtleSwgZXh0cmEpIHtcblx0XHRcdGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIFwiXFxcXFwiICsgbVxuXHRcdFx0a2V5cy5wdXNoKHtrOiBrZXksIHI6IGV4dHJhID09PSBcIi4uLlwifSlcblx0XHRcdGlmIChleHRyYSA9PT0gXCIuLi5cIikgcmV0dXJuIFwiKC4qKVwiXG5cdFx0XHRpZiAoZXh0cmEgPT09IFwiLlwiKSByZXR1cm4gXCIoW14vXSspXFxcXC5cIlxuXHRcdFx0cmV0dXJuIFwiKFteL10rKVwiICsgKGV4dHJhIHx8IFwiXCIpXG5cdFx0fVxuXHQpICsgXCIkXCIpXG5cdHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0Ly8gRmlyc3QsIGNoZWNrIHRoZSBwYXJhbXMuIFVzdWFsbHksIHRoZXJlIGlzbid0IGFueSwgYW5kIGl0J3MganVzdFxuXHRcdC8vIGNoZWNraW5nIGEgc3RhdGljIHNldC5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBsYXRlS2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRlbXBsYXRlRGF0YS5wYXJhbXNbdGVtcGxhdGVLZXlzW2ldXSAhPT0gZGF0YS5wYXJhbXNbdGVtcGxhdGVLZXlzW2ldXSkgcmV0dXJuIGZhbHNlXG5cdFx0fVxuXHRcdC8vIElmIG5vIGludGVycG9sYXRpb25zIGV4aXN0LCBsZXQncyBza2lwIGFsbCB0aGUgY2VyZW1vbnlcblx0XHRpZiAoIWtleXMubGVuZ3RoKSByZXR1cm4gcmVnZXhwLnRlc3QoZGF0YS5wYXRoKVxuXHRcdHZhciB2YWx1ZXMgPSByZWdleHAuZXhlYyhkYXRhLnBhdGgpXG5cdFx0aWYgKHZhbHVlcyA9PSBudWxsKSByZXR1cm4gZmFsc2Vcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGRhdGEucGFyYW1zW2tleXNbaV0ua10gPSBrZXlzW2ldLnIgPyB2YWx1ZXNbaSArIDFdIDogZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlc1tpICsgMV0pXG5cdFx0fVxuXHRcdHJldHVybiB0cnVlXG5cdH1cbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gcmVxdWlyZShcIi4uL3F1ZXJ5c3RyaW5nL3BhcnNlXCIpXG5cbi8vIFJldHVybnMgYHtwYXRoLCBwYXJhbXN9YCBmcm9tIGB1cmxgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVybCkge1xuXHR2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKFwiP1wiKVxuXHR2YXIgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpXG5cdHZhciBxdWVyeUVuZCA9IGhhc2hJbmRleCA8IDAgPyB1cmwubGVuZ3RoIDogaGFzaEluZGV4XG5cdHZhciBwYXRoRW5kID0gcXVlcnlJbmRleCA8IDAgPyBxdWVyeUVuZCA6IHF1ZXJ5SW5kZXhcblx0dmFyIHBhdGggPSB1cmwuc2xpY2UoMCwgcGF0aEVuZCkucmVwbGFjZSgvXFwvezIsfS9nLCBcIi9cIilcblxuXHRpZiAoIXBhdGgpIHBhdGggPSBcIi9cIlxuXHRlbHNlIHtcblx0XHRpZiAocGF0aFswXSAhPT0gXCIvXCIpIHBhdGggPSBcIi9cIiArIHBhdGhcblx0XHRpZiAocGF0aC5sZW5ndGggPiAxICYmIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gXCIvXCIpIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKVxuXHR9XG5cdHJldHVybiB7XG5cdFx0cGF0aDogcGF0aCxcblx0XHRwYXJhbXM6IHF1ZXJ5SW5kZXggPCAwXG5cdFx0XHQ/IHt9XG5cdFx0XHQ6IHBhcnNlUXVlcnlTdHJpbmcodXJsLnNsaWNlKHF1ZXJ5SW5kZXggKyAxLCBxdWVyeUVuZCkpLFxuXHR9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuLyoqIEBjb25zdHJ1Y3RvciAqL1xudmFyIFByb21pc2VQb2x5ZmlsbCA9IGZ1bmN0aW9uKGV4ZWN1dG9yKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlUG9seWZpbGwpKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlIG11c3QgYmUgY2FsbGVkIHdpdGggYG5ld2BcIilcblx0aWYgKHR5cGVvZiBleGVjdXRvciAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpXG5cblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblxuXHRleGVjdXRlT25jZShleGVjdXRvcilcbn1cblByb21pc2VQb2x5ZmlsbC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGlvbikge1xuXHR2YXIgc2VsZiA9IHRoaXMsIGluc3RhbmNlID0gc2VsZi5faW5zdGFuY2Vcblx0ZnVuY3Rpb24gaGFuZGxlKGNhbGxiYWNrLCBsaXN0LCBuZXh0LCBzdGF0ZSkge1xuXHRcdGxpc3QucHVzaChmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSBuZXh0KHZhbHVlKVxuXHRcdFx0ZWxzZSB0cnkge3Jlc29sdmVOZXh0KGNhbGxiYWNrKHZhbHVlKSl9IGNhdGNoIChlKSB7aWYgKHJlamVjdE5leHQpIHJlamVjdE5leHQoZSl9XG5cdFx0fSlcblx0XHRpZiAodHlwZW9mIGluc3RhbmNlLnJldHJ5ID09PSBcImZ1bmN0aW9uXCIgJiYgc3RhdGUgPT09IGluc3RhbmNlLnN0YXRlKSBpbnN0YW5jZS5yZXRyeSgpXG5cdH1cblx0dmFyIHJlc29sdmVOZXh0LCByZWplY3ROZXh0XG5cdHZhciBwcm9taXNlID0gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtyZXNvbHZlTmV4dCA9IHJlc29sdmUsIHJlamVjdE5leHQgPSByZWplY3R9KVxuXHRoYW5kbGUob25GdWxmaWxsZWQsIGluc3RhbmNlLnJlc29sdmVycywgcmVzb2x2ZU5leHQsIHRydWUpLCBoYW5kbGUob25SZWplY3Rpb24sIGluc3RhbmNlLnJlamVjdG9ycywgcmVqZWN0TmV4dCwgZmFsc2UpXG5cdHJldHVybiBwcm9taXNlXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24ob25SZWplY3Rpb24pIHtcblx0cmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbilcbn1cblByb21pc2VQb2x5ZmlsbC5wcm90b3R5cGUuZmluYWxseSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdHJldHVybiB0aGlzLnRoZW4oXG5cdFx0ZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdH0pXG5cdFx0fSxcblx0XHRmdW5jdGlvbihyZWFzb24pIHtcblx0XHRcdHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlamVjdChyZWFzb24pO1xuXHRcdFx0fSlcblx0XHR9XG5cdClcbn1cblByb21pc2VQb2x5ZmlsbC5yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0aWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZVBvbHlmaWxsKSByZXR1cm4gdmFsdWVcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSkge3Jlc29sdmUodmFsdWUpfSlcbn1cblByb21pc2VQb2x5ZmlsbC5yZWplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtyZWplY3QodmFsdWUpfSlcbn1cblByb21pc2VQb2x5ZmlsbC5hbGwgPSBmdW5jdGlvbihsaXN0KSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdHZhciB0b3RhbCA9IGxpc3QubGVuZ3RoLCBjb3VudCA9IDAsIHZhbHVlcyA9IFtdXG5cdFx0aWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXNvbHZlKFtdKVxuXHRcdGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQoZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRmdW5jdGlvbiBjb25zdW1lKHZhbHVlKSB7XG5cdFx0XHRcdFx0Y291bnQrK1xuXHRcdFx0XHRcdHZhbHVlc1tpXSA9IHZhbHVlXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSB0b3RhbCkgcmVzb2x2ZSh2YWx1ZXMpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxpc3RbaV0gIT0gbnVsbCAmJiAodHlwZW9mIGxpc3RbaV0gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGxpc3RbaV0gPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mIGxpc3RbaV0udGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0bGlzdFtpXS50aGVuKGNvbnN1bWUsIHJlamVjdClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGNvbnN1bWUobGlzdFtpXSlcblx0XHRcdH0pKGkpXG5cdFx0fVxuXHR9KVxufVxuUHJvbWlzZVBvbHlmaWxsLnJhY2UgPSBmdW5jdGlvbihsaXN0KSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGlzdFtpXS50aGVuKHJlc29sdmUsIHJlamVjdClcblx0XHR9XG5cdH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZVBvbHlmaWxsXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gcmVxdWlyZShcIi4vcG9seWZpbGxcIilcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdHdpbmRvdy5Qcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG5cdH0gZWxzZSBpZiAoIXdpbmRvdy5Qcm9taXNlLnByb3RvdHlwZS5maW5hbGx5KSB7XG5cdFx0d2luZG93LlByb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSBQcm9taXNlUG9seWZpbGwucHJvdG90eXBlLmZpbmFsbHlcblx0fVxuXHRtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdGdsb2JhbC5Qcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG5cdH0gZWxzZSBpZiAoIWdsb2JhbC5Qcm9taXNlLnByb3RvdHlwZS5maW5hbGx5KSB7XG5cdFx0Z2xvYmFsLlByb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSBQcm9taXNlUG9seWZpbGwucHJvdG90eXBlLmZpbmFsbHlcblx0fVxuXHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IFByb21pc2VQb2x5ZmlsbFxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXG5cdHZhciBhcmdzID0gW11cblx0Zm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuXHRcdGRlc3RydWN0dXJlKGtleSwgb2JqZWN0W2tleV0pXG5cdH1cblxuXHRyZXR1cm4gYXJncy5qb2luKFwiJlwiKVxuXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleSwgdmFsdWUpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5ICsgXCJbXCIgKyBpICsgXCJdXCIsIHZhbHVlW2ldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIHZhbHVlKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleSArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gXCJcIiA/IFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IFwiXCIpKVxuXHR9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG4vLyBUaGUgZXh0cmEgYGRhdGFgIHBhcmFtZXRlciBpcyBmb3IgaWYgeW91IHdhbnQgdG8gYXBwZW5kIHRvIGFuIGV4aXN0aW5nXG4vLyBwYXJhbWV0ZXJzIG9iamVjdC5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdGlmIChzdHJpbmcgPT09IFwiXCIgfHwgc3RyaW5nID09IG51bGwpIHJldHVybiB7fVxuXHRpZiAoc3RyaW5nLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHN0cmluZyA9IHN0cmluZy5zbGljZSgxKVxuXG5cdHZhciBlbnRyaWVzID0gc3RyaW5nLnNwbGl0KFwiJlwiKSwgY291bnRlcnMgPSB7fSwgZGF0YSA9IHt9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBlbnRyeSA9IGVudHJpZXNbaV0uc3BsaXQoXCI9XCIpXG5cdFx0dmFyIGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVswXSlcblx0XHR2YXIgdmFsdWUgPSBlbnRyeS5sZW5ndGggPT09IDIgPyBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMV0pIDogXCJcIlxuXG5cdFx0aWYgKHZhbHVlID09PSBcInRydWVcIikgdmFsdWUgPSB0cnVlXG5cdFx0ZWxzZSBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikgdmFsdWUgPSBmYWxzZVxuXG5cdFx0dmFyIGxldmVscyA9IGtleS5zcGxpdCgvXFxdXFxbP3xcXFsvKVxuXHRcdHZhciBjdXJzb3IgPSBkYXRhXG5cdFx0aWYgKGtleS5pbmRleE9mKFwiW1wiKSA+IC0xKSBsZXZlbHMucG9wKClcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzW2pdLCBuZXh0TGV2ZWwgPSBsZXZlbHNbaiArIDFdXG5cdFx0XHR2YXIgaXNOdW1iZXIgPSBuZXh0TGV2ZWwgPT0gXCJcIiB8fCAhaXNOYU4ocGFyc2VJbnQobmV4dExldmVsLCAxMCkpXG5cdFx0XHR2YXIgaXNWYWx1ZSA9IGogPT09IGxldmVscy5sZW5ndGggLSAxXG5cdFx0XHRpZiAobGV2ZWwgPT09IFwiXCIpIHtcblx0XHRcdFx0dmFyIGtleSA9IGxldmVscy5zbGljZSgwLCBqKS5qb2luKClcblx0XHRcdFx0aWYgKGNvdW50ZXJzW2tleV0gPT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvdW50ZXJzW2tleV0gPSBBcnJheS5pc0FycmF5KGN1cnNvcikgPyBjdXJzb3IubGVuZ3RoIDogMFxuXHRcdFx0XHR9XG5cdFx0XHRcdGxldmVsID0gY291bnRlcnNba2V5XSsrXG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNWYWx1ZSkgY3Vyc29yW2xldmVsXSA9IHZhbHVlXG5cdFx0XHRlbHNlIGlmIChjdXJzb3JbbGV2ZWxdID09IG51bGwpIGN1cnNvcltsZXZlbF0gPSBpc051bWJlciA/IFtdIDoge31cblx0XHRcdGN1cnNvciA9IGN1cnNvcltsZXZlbF1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGFcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vYXBpL3JlZHJhd1wiKSh3aW5kb3cpXG4iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3JlbmRlci9yZW5kZXJcIikod2luZG93KVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIFZub2RlID0gcmVxdWlyZShcIi4uL3JlbmRlci92bm9kZVwiKVxudmFyIGh5cGVyc2NyaXB0Vm5vZGUgPSByZXF1aXJlKFwiLi9oeXBlcnNjcmlwdFZub2RlXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG5cdHZhciB2bm9kZSA9IGh5cGVyc2NyaXB0Vm5vZGUuYXBwbHkoMCwgYXJndW1lbnRzKVxuXG5cdHZub2RlLnRhZyA9IFwiW1wiXG5cdHZub2RlLmNoaWxkcmVuID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGUuY2hpbGRyZW4pXG5cdHJldHVybiB2bm9kZVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIFZub2RlID0gcmVxdWlyZShcIi4uL3JlbmRlci92bm9kZVwiKVxudmFyIGh5cGVyc2NyaXB0Vm5vZGUgPSByZXF1aXJlKFwiLi9oeXBlcnNjcmlwdFZub2RlXCIpXG5cbnZhciBzZWxlY3RvclBhcnNlciA9IC8oPzooXnwjfFxcLikoW14jXFwuXFxbXFxdXSspKXwoXFxbKC4rPykoPzpcXHMqPVxccyooXCJ8J3wpKCg/OlxcXFxbXCInXFxdXXwuKSo/KVxcNSk/XFxdKS9nXG52YXIgc2VsZWN0b3JDYWNoZSA9IHt9XG52YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHlcblxuZnVuY3Rpb24gaXNFbXB0eShvYmplY3QpIHtcblx0Zm9yICh2YXIga2V5IGluIG9iamVjdCkgaWYgKGhhc093bi5jYWxsKG9iamVjdCwga2V5KSkgcmV0dXJuIGZhbHNlXG5cdHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVTZWxlY3RvcihzZWxlY3Rvcikge1xuXHR2YXIgbWF0Y2gsIHRhZyA9IFwiZGl2XCIsIGNsYXNzZXMgPSBbXSwgYXR0cnMgPSB7fVxuXHR3aGlsZSAobWF0Y2ggPSBzZWxlY3RvclBhcnNlci5leGVjKHNlbGVjdG9yKSkge1xuXHRcdHZhciB0eXBlID0gbWF0Y2hbMV0sIHZhbHVlID0gbWF0Y2hbMl1cblx0XHRpZiAodHlwZSA9PT0gXCJcIiAmJiB2YWx1ZSAhPT0gXCJcIikgdGFnID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIiNcIikgYXR0cnMuaWQgPSB2YWx1ZVxuXHRcdGVsc2UgaWYgKHR5cGUgPT09IFwiLlwiKSBjbGFzc2VzLnB1c2godmFsdWUpXG5cdFx0ZWxzZSBpZiAobWF0Y2hbM11bMF0gPT09IFwiW1wiKSB7XG5cdFx0XHR2YXIgYXR0clZhbHVlID0gbWF0Y2hbNl1cblx0XHRcdGlmIChhdHRyVmFsdWUpIGF0dHJWYWx1ZSA9IGF0dHJWYWx1ZS5yZXBsYWNlKC9cXFxcKFtcIiddKS9nLCBcIiQxXCIpLnJlcGxhY2UoL1xcXFxcXFxcL2csIFwiXFxcXFwiKVxuXHRcdFx0aWYgKG1hdGNoWzRdID09PSBcImNsYXNzXCIpIGNsYXNzZXMucHVzaChhdHRyVmFsdWUpXG5cdFx0XHRlbHNlIGF0dHJzW21hdGNoWzRdXSA9IGF0dHJWYWx1ZSA9PT0gXCJcIiA/IGF0dHJWYWx1ZSA6IGF0dHJWYWx1ZSB8fCB0cnVlXG5cdFx0fVxuXHR9XG5cdGlmIChjbGFzc2VzLmxlbmd0aCA+IDApIGF0dHJzLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbihcIiBcIilcblx0cmV0dXJuIHNlbGVjdG9yQ2FjaGVbc2VsZWN0b3JdID0ge3RhZzogdGFnLCBhdHRyczogYXR0cnN9XG59XG5cbmZ1bmN0aW9uIGV4ZWNTZWxlY3RvcihzdGF0ZSwgdm5vZGUpIHtcblx0dmFyIGF0dHJzID0gdm5vZGUuYXR0cnNcblx0dmFyIGNoaWxkcmVuID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGUuY2hpbGRyZW4pXG5cdHZhciBoYXNDbGFzcyA9IGhhc093bi5jYWxsKGF0dHJzLCBcImNsYXNzXCIpXG5cdHZhciBjbGFzc05hbWUgPSBoYXNDbGFzcyA/IGF0dHJzLmNsYXNzIDogYXR0cnMuY2xhc3NOYW1lXG5cblx0dm5vZGUudGFnID0gc3RhdGUudGFnXG5cdHZub2RlLmF0dHJzID0gbnVsbFxuXHR2bm9kZS5jaGlsZHJlbiA9IHVuZGVmaW5lZFxuXG5cdGlmICghaXNFbXB0eShzdGF0ZS5hdHRycykgJiYgIWlzRW1wdHkoYXR0cnMpKSB7XG5cdFx0dmFyIG5ld0F0dHJzID0ge31cblxuXHRcdGZvciAodmFyIGtleSBpbiBhdHRycykge1xuXHRcdFx0aWYgKGhhc093bi5jYWxsKGF0dHJzLCBrZXkpKSBuZXdBdHRyc1trZXldID0gYXR0cnNba2V5XVxuXHRcdH1cblxuXHRcdGF0dHJzID0gbmV3QXR0cnNcblx0fVxuXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSAmJiBrZXkgIT09IFwiY2xhc3NOYW1lXCIgJiYgIWhhc093bi5jYWxsKGF0dHJzLCBrZXkpKXtcblx0XHRcdGF0dHJzW2tleV0gPSBzdGF0ZS5hdHRyc1trZXldXG5cdFx0fVxuXHR9XG5cdGlmIChjbGFzc05hbWUgIT0gbnVsbCB8fCBzdGF0ZS5hdHRycy5jbGFzc05hbWUgIT0gbnVsbCkgYXR0cnMuY2xhc3NOYW1lID1cblx0XHRjbGFzc05hbWUgIT0gbnVsbFxuXHRcdFx0PyBzdGF0ZS5hdHRycy5jbGFzc05hbWUgIT0gbnVsbFxuXHRcdFx0XHQ/IFN0cmluZyhzdGF0ZS5hdHRycy5jbGFzc05hbWUpICsgXCIgXCIgKyBTdHJpbmcoY2xhc3NOYW1lKVxuXHRcdFx0XHQ6IGNsYXNzTmFtZVxuXHRcdFx0OiBzdGF0ZS5hdHRycy5jbGFzc05hbWUgIT0gbnVsbFxuXHRcdFx0XHQ/IHN0YXRlLmF0dHJzLmNsYXNzTmFtZVxuXHRcdFx0XHQ6IG51bGxcblxuXHRpZiAoaGFzQ2xhc3MpIGF0dHJzLmNsYXNzID0gbnVsbFxuXG5cdGZvciAodmFyIGtleSBpbiBhdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChhdHRycywga2V5KSAmJiBrZXkgIT09IFwia2V5XCIpIHtcblx0XHRcdHZub2RlLmF0dHJzID0gYXR0cnNcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cblx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXSAhPSBudWxsICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCIjXCIpIHtcblx0XHR2bm9kZS50ZXh0ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0fSBlbHNlIHtcblx0XHR2bm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuXG5cdH1cblxuXHRyZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gaHlwZXJzY3JpcHQoc2VsZWN0b3IpIHtcblx0aWYgKHNlbGVjdG9yID09IG51bGwgfHwgdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzZWxlY3Rvci52aWV3ICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHR0aHJvdyBFcnJvcihcIlRoZSBzZWxlY3RvciBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBhIGNvbXBvbmVudC5cIik7XG5cdH1cblxuXHR2YXIgdm5vZGUgPSBoeXBlcnNjcmlwdFZub2RlLmFwcGx5KDEsIGFyZ3VtZW50cylcblxuXHRpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG5cdFx0dm5vZGUuY2hpbGRyZW4gPSBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbih2bm9kZS5jaGlsZHJlbilcblx0XHRpZiAoc2VsZWN0b3IgIT09IFwiW1wiKSByZXR1cm4gZXhlY1NlbGVjdG9yKHNlbGVjdG9yQ2FjaGVbc2VsZWN0b3JdIHx8IGNvbXBpbGVTZWxlY3RvcihzZWxlY3RvciksIHZub2RlKVxuXHR9XG5cblx0dm5vZGUudGFnID0gc2VsZWN0b3Jcblx0cmV0dXJuIHZub2RlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwZXJzY3JpcHRcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBWbm9kZSA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvdm5vZGVcIilcblxuLy8gQ2FsbCB2aWEgYGh5cGVyc2NyaXB0Vm5vZGUuYXBwbHkoc3RhcnRPZmZzZXQsIGFyZ3VtZW50cylgXG4vL1xuLy8gVGhlIHJlYXNvbiBJIGRvIGl0IHRoaXMgd2F5LCBmb3J3YXJkaW5nIHRoZSBhcmd1bWVudHMgYW5kIHBhc3NpbmcgdGhlIHN0YXJ0XG4vLyBvZmZzZXQgaW4gYHRoaXNgLCBpcyBzbyBJIGRvbid0IGhhdmUgdG8gY3JlYXRlIGEgdGVtcG9yYXJ5IGFycmF5IGluIGFcbi8vIHBlcmZvcm1hbmNlLWNyaXRpY2FsIHBhdGguXG4vL1xuLy8gSW4gbmF0aXZlIEVTNiwgSSdkIGluc3RlYWQgYWRkIGEgZmluYWwgYC4uLmFyZ3NgIHBhcmFtZXRlciB0byB0aGVcbi8vIGBoeXBlcnNjcmlwdGAgYW5kIGBmcmFnbWVudGAgZmFjdG9yaWVzIGFuZCBkZWZpbmUgdGhpcyBhc1xuLy8gYGh5cGVyc2NyaXB0Vm5vZGUoLi4uYXJncylgLCBzaW5jZSBtb2Rlcm4gZW5naW5lcyBkbyBvcHRpbWl6ZSB0aGF0IGF3YXkuIEJ1dFxuLy8gRVM1ICh3aGF0IE1pdGhyaWwgcmVxdWlyZXMgdGhhbmtzIHRvIElFIHN1cHBvcnQpIGRvZXNuJ3QgZ2l2ZSBtZSB0aGF0IGx1eHVyeSxcbi8vIGFuZCBlbmdpbmVzIGFyZW4ndCBuZWFybHkgaW50ZWxsaWdlbnQgZW5vdWdoIHRvIGRvIGVpdGhlciBvZiB0aGVzZTpcbi8vXG4vLyAxLiBFbGlkZSB0aGUgYWxsb2NhdGlvbiBmb3IgYFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKWAgd2hlbiBpdCdzIHBhc3NlZCB0b1xuLy8gICAgYW5vdGhlciBmdW5jdGlvbiBvbmx5IHRvIGJlIGluZGV4ZWQuXG4vLyAyLiBFbGlkZSBhbiBgYXJndW1lbnRzYCBhbGxvY2F0aW9uIHdoZW4gaXQncyBwYXNzZWQgdG8gYW55IGZ1bmN0aW9uIG90aGVyXG4vLyAgICB0aGFuIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgIG9yIGBSZWZsZWN0LmFwcGx5YC5cbi8vXG4vLyBJbiBFUzYsIGl0J2QgcHJvYmFibHkgbG9vayBjbG9zZXIgdG8gdGhpcyAoSSdkIG5lZWQgdG8gcHJvZmlsZSBpdCwgdGhvdWdoKTpcbi8vIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXR0cnMsIC4uLmNoaWxkcmVuKSB7XG4vLyAgICAgaWYgKGF0dHJzID09IG51bGwgfHwgdHlwZW9mIGF0dHJzID09PSBcIm9iamVjdFwiICYmIGF0dHJzLnRhZyA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuLy8gICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoY2hpbGRyZW5bMF0pKSBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdXG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgQXJyYXkuaXNBcnJheShhdHRycykgPyBhdHRycyA6IFthdHRycywgLi4uY2hpbGRyZW5dXG4vLyAgICAgICAgIGF0dHJzID0gdW5kZWZpbmVkXG4vLyAgICAgfVxuLy9cbi8vICAgICBpZiAoYXR0cnMgPT0gbnVsbCkgYXR0cnMgPSB7fVxuLy8gICAgIHJldHVybiBWbm9kZShcIlwiLCBhdHRycy5rZXksIGF0dHJzLCBjaGlsZHJlbilcbi8vIH1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG5cdHZhciBhdHRycyA9IGFyZ3VtZW50c1t0aGlzXSwgc3RhcnQgPSB0aGlzICsgMSwgY2hpbGRyZW5cblxuXHRpZiAoYXR0cnMgPT0gbnVsbCkge1xuXHRcdGF0dHJzID0ge31cblx0fSBlbHNlIGlmICh0eXBlb2YgYXR0cnMgIT09IFwib2JqZWN0XCIgfHwgYXR0cnMudGFnICE9IG51bGwgfHwgQXJyYXkuaXNBcnJheShhdHRycykpIHtcblx0XHRhdHRycyA9IHt9XG5cdFx0c3RhcnQgPSB0aGlzXG5cdH1cblxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cblx0cmV0dXJuIFZub2RlKFwiXCIsIGF0dHJzLmtleSwgYXR0cnMsIGNoaWxkcmVuKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIFZub2RlID0gcmVxdWlyZShcIi4uL3JlbmRlci92bm9kZVwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyICRkb2MgPSAkd2luZG93LmRvY3VtZW50XG5cblx0dmFyIG5hbWVTcGFjZSA9IHtcblx0XHRzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcblx0XHRtYXRoOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIlxuXHR9XG5cblx0dmFyIHJlZHJhd1xuXHRmdW5jdGlvbiBzZXRSZWRyYXcoY2FsbGJhY2spIHtyZXR1cm4gcmVkcmF3ID0gY2FsbGJhY2t9XG5cblx0ZnVuY3Rpb24gZ2V0TmFtZVNwYWNlKHZub2RlKSB7XG5cdFx0cmV0dXJuIHZub2RlLmF0dHJzICYmIHZub2RlLmF0dHJzLnhtbG5zIHx8IG5hbWVTcGFjZVt2bm9kZS50YWddXG5cdH1cblxuXHQvL3Nhbml0eSBjaGVjayB0byBkaXNjb3VyYWdlIHBlb3BsZSBmcm9tIGRvaW5nIGB2bm9kZS5zdGF0ZSA9IC4uLmBcblx0ZnVuY3Rpb24gY2hlY2tTdGF0ZSh2bm9kZSwgb3JpZ2luYWwpIHtcblx0XHRpZiAodm5vZGUuc3RhdGUgIT09IG9yaWdpbmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJgdm5vZGUuc3RhdGVgIG11c3Qgbm90IGJlIG1vZGlmaWVkXCIpXG5cdH1cblxuXHQvL05vdGU6IHRoZSBob29rIGlzIHBhc3NlZCBhcyB0aGUgYHRoaXNgIGFyZ3VtZW50IHRvIGFsbG93IHByb3h5aW5nIHRoZVxuXHQvL2FyZ3VtZW50cyB3aXRob3V0IHJlcXVpcmluZyBhIGZ1bGwgYXJyYXkgYWxsb2NhdGlvbiB0byBkbyBzby4gSXQgYWxzb1xuXHQvL3Rha2VzIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGUgY3VycmVudCBgdm5vZGVgIGlzIHRoZSBmaXJzdCBhcmd1bWVudCBpblxuXHQvL2FsbCBsaWZlY3ljbGUgbWV0aG9kcy5cblx0ZnVuY3Rpb24gY2FsbEhvb2sodm5vZGUpIHtcblx0XHR2YXIgb3JpZ2luYWwgPSB2bm9kZS5zdGF0ZVxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseShvcmlnaW5hbCwgYXJndW1lbnRzKVxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRjaGVja1N0YXRlKHZub2RlLCBvcmlnaW5hbClcblx0XHR9XG5cdH1cblxuXHQvLyBJRTExIChhdCBsZWFzdCkgdGhyb3dzIGFuIFVuc3BlY2lmaWVkRXJyb3Igd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB3aGVuXG5cdC8vIGluc2lkZSBhbiBpZnJhbWUuIENhdGNoIGFuZCBzd2FsbG93IHRoaXMgZXJyb3IsIGFuZCBoZWF2eS1oYW5kaWRseSByZXR1cm4gbnVsbC5cblx0ZnVuY3Rpb24gYWN0aXZlRWxlbWVudCgpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuICRkb2MuYWN0aXZlRWxlbWVudFxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBudWxsXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHZhbGlkYXRlS2V5cyh2bm9kZXMsIGlzS2V5ZWQpIHtcblx0XHQvLyBOb3RlOiB0aGlzIGlzIGEgKnZlcnkqIHBlcmYtc2Vuc2l0aXZlIGNoZWNrLlxuXHRcdC8vIEZ1biBmYWN0OiBtZXJnaW5nIHRoZSBsb29wIGxpa2UgdGhpcyBpcyBzb21laG93IGZhc3RlciB0aGFuIHNwbGl0dGluZ1xuXHRcdC8vIGl0LCBub3RpY2VhYmx5IHNvLlxuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoKHZub2Rlc1tpXSAhPSBudWxsICYmIHZub2Rlc1tpXS5rZXkgIT0gbnVsbCkgIT09IGlzS2V5ZWQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIlZub2RlcyBtdXN0IGVpdGhlciBhbHdheXMgaGF2ZSBrZXlzIG9yIG5ldmVyIGhhdmUga2V5cyFcIilcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9jcmVhdGVcblx0ZnVuY3Rpb24gY3JlYXRlTm9kZXNDaGVja2VkKHBhcmVudCwgdm5vZGVzLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0aWYgKHZub2Rlcy5sZW5ndGgpIHtcblx0XHRcdHZhbGlkYXRlS2V5cyh2bm9kZXMsIHZub2Rlc1swXSAhPSBudWxsICYmIHZub2Rlc1swXS5rZXkgIT0gbnVsbClcblx0XHRcdGNyZWF0ZU5vZGVzVW5jaGVja2VkKHBhcmVudCwgdm5vZGVzLCAwLCB2bm9kZXMubGVuZ3RoLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVOb2Rlc1VuY2hlY2tlZChwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCwgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmICh0eXBlb2YgdGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHt9XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0c3dpdGNoICh0YWcpIHtcblx0XHRcdFx0Y2FzZSBcIiNcIjogY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZyk7IGJyZWFrXG5cdFx0XHRcdGNhc2UgXCI8XCI6IGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbnMsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0Y2FzZSBcIltcIjogY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZyk7IGJyZWFrXG5cdFx0XHRcdGRlZmF1bHQ6IGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dm5vZGUuZG9tID0gJGRvYy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS5jaGlsZHJlbilcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgdm5vZGUuZG9tLCBuZXh0U2libGluZylcblx0fVxuXHR2YXIgcG9zc2libGVQYXJlbnRzID0ge2NhcHRpb246IFwidGFibGVcIiwgdGhlYWQ6IFwidGFibGVcIiwgdGJvZHk6IFwidGFibGVcIiwgdGZvb3Q6IFwidGFibGVcIiwgdHI6IFwidGJvZHlcIiwgdGg6IFwidHJcIiwgdGQ6IFwidHJcIiwgY29sZ3JvdXA6IFwidGFibGVcIiwgY29sOiBcImNvbGdyb3VwXCJ9XG5cdGZ1bmN0aW9uIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIG1hdGNoID0gdm5vZGUuY2hpbGRyZW4ubWF0Y2goL15cXHMqPzwoXFx3KykvaW0pIHx8IFtdXG5cdFx0Ly8gbm90IHVzaW5nIHRoZSBwcm9wZXIgcGFyZW50IG1ha2VzIHRoZSBjaGlsZCBlbGVtZW50KHMpIHZhbmlzaC5cblx0XHQvLyAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcblx0XHQvLyAgICAgZGl2LmlubmVySFRNTCA9IFwiPHRkPmk8L3RkPjx0ZD5qPC90ZD5cIlxuXHRcdC8vICAgICBjb25zb2xlLmxvZyhkaXYuaW5uZXJIVE1MKVxuXHRcdC8vIC0tPiBcImlqXCIsIG5vIDx0ZD4gaW4gc2lnaHQuXG5cdFx0dmFyIHRlbXAgPSAkZG9jLmNyZWF0ZUVsZW1lbnQocG9zc2libGVQYXJlbnRzW21hdGNoWzFdXSB8fCBcImRpdlwiKVxuXHRcdGlmIChucyA9PT0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSB7XG5cdFx0XHR0ZW1wLmlubmVySFRNTCA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPlwiICsgdm5vZGUuY2hpbGRyZW4gKyBcIjwvc3ZnPlwiXG5cdFx0XHR0ZW1wID0gdGVtcC5maXJzdENoaWxkXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRlbXAuaW5uZXJIVE1MID0gdm5vZGUuY2hpbGRyZW5cblx0XHR9XG5cdFx0dm5vZGUuZG9tID0gdGVtcC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IHRlbXAuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdHZhciBjaGlsZFxuXHRcdHdoaWxlIChjaGlsZCA9IHRlbXAuZmlyc3RDaGlsZCkge1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRjcmVhdGVOb2Rlc0NoZWNrZWQoZnJhZ21lbnQsIGNoaWxkcmVuLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IGZyYWdtZW50LmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHR2YXIgYXR0cnMgPSB2bm9kZS5hdHRyc1xuXHRcdHZhciBpcyA9IGF0dHJzICYmIGF0dHJzLmlzXG5cblx0XHRucyA9IGdldE5hbWVTcGFjZSh2bm9kZSkgfHwgbnNcblxuXHRcdHZhciBlbGVtZW50ID0gbnMgP1xuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKSA6XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcpXG5cdFx0dm5vZGUuZG9tID0gZWxlbWVudFxuXG5cdFx0aWYgKGF0dHJzICE9IG51bGwpIHtcblx0XHRcdHNldEF0dHJzKHZub2RlLCBhdHRycywgbnMpXG5cdFx0fVxuXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGVsZW1lbnQsIG5leHRTaWJsaW5nKVxuXG5cdFx0aWYgKCFtYXliZVNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSkpIHtcblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnRleHQgIT09IFwiXCIpIGVsZW1lbnQudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0XG5cdFx0XHRcdGVsc2Ugdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR9XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0XHRjcmVhdGVOb2Rlc0NoZWNrZWQoZWxlbWVudCwgY2hpbGRyZW4sIGhvb2tzLCBudWxsLCBucylcblx0XHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIiAmJiBhdHRycyAhPSBudWxsKSBzZXRMYXRlU2VsZWN0QXR0cnModm5vZGUsIGF0dHJzKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpbml0Q29tcG9uZW50KHZub2RlLCBob29rcykge1xuXHRcdHZhciBzZW50aW5lbFxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnLnZpZXcgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBPYmplY3QuY3JlYXRlKHZub2RlLnRhZylcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUuc3RhdGUudmlld1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVyblxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLnN0YXRlID0gdm9pZCAwXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnRhZ1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVyblxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0XHR2bm9kZS5zdGF0ZSA9ICh2bm9kZS50YWcucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLnRhZy5wcm90b3R5cGUudmlldyA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyB2bm9kZS50YWcodm5vZGUpIDogdm5vZGUudGFnKHZub2RlKVxuXHRcdH1cblx0XHRpbml0TGlmZWN5Y2xlKHZub2RlLnN0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZShjYWxsSG9vay5jYWxsKHZub2RlLnN0YXRlLnZpZXcsIHZub2RlKSlcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgPT09IHZub2RlKSB0aHJvdyBFcnJvcihcIkEgdmlldyBjYW5ub3QgcmV0dXJuIHRoZSB2bm9kZSBpdCByZWNlaXZlZCBhcyBhcmd1bWVudFwiKVxuXHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gbnVsbFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmRvbSAhPSBudWxsID8gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZSA6IDBcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdH1cblx0fVxuXG5cdC8vdXBkYXRlXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR8RnJhZ21lbnR9IHBhcmVudCAtIHRoZSBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge1Zub2RlW10gfCBudWxsfSBvbGQgLSB0aGUgbGlzdCBvZiB2bm9kZXMgb2YgdGhlIGxhc3QgYHJlbmRlcigpYCBjYWxsIGZvclxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHBhcnQgb2YgdGhlIHRyZWVcblx0ICogQHBhcmFtIHtWbm9kZVtdIHwgbnVsbH0gdm5vZGVzIC0gYXMgYWJvdmUsIGJ1dCBmb3IgdGhlIGN1cnJlbnQgYHJlbmRlcigpYCBjYWxsLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uW119IGhvb2tzIC0gYW4gYWNjdW11bGF0b3Igb2YgcG9zdC1yZW5kZXIgaG9va3MgKG9uY3JlYXRlL29udXBkYXRlKVxuXHQgKiBAcGFyYW0ge0VsZW1lbnQgfCBudWxsfSBuZXh0U2libGluZyAtIHRoZSBuZXh0IERPTSBub2RlIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgdGhhdCBpcyBub3QgdGhlIGxhc3QgaXRlbSBpbiBpdHNcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRcblx0ICogQHBhcmFtIHsnc3ZnJyB8ICdtYXRoJyB8IFN0cmluZyB8IG51bGx9IG5zKSAtIHRoZSBjdXJyZW50IFhNTCBuYW1lc3BhY2UsIGlmIGFueVxuXHQgKiBAcmV0dXJucyB2b2lkXG5cdCAqL1xuXHQvLyBUaGlzIGZ1bmN0aW9uIGRpZmZzIGFuZCBwYXRjaGVzIGxpc3RzIG9mIHZub2RlcywgYm90aCBrZXllZCBhbmQgdW5rZXllZC5cblx0Ly9cblx0Ly8gV2Ugd2lsbDpcblx0Ly9cblx0Ly8gMS4gZGVzY3JpYmUgaXRzIGdlbmVyYWwgc3RydWN0dXJlXG5cdC8vIDIuIGZvY3VzIG9uIHRoZSBkaWZmIGFsZ29yaXRobSBvcHRpbWl6YXRpb25zXG5cdC8vIDMuIGRpc2N1c3MgRE9NIG5vZGUgb3BlcmF0aW9ucy5cblxuXHQvLyAjIyBPdmVydmlldzpcblx0Ly9cblx0Ly8gVGhlIHVwZGF0ZU5vZGVzKCkgZnVuY3Rpb246XG5cdC8vIC0gZGVhbHMgd2l0aCB0cml2aWFsIGNhc2VzXG5cdC8vIC0gZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBsaXN0cyBhcmUga2V5ZWQgb3IgdW5rZXllZCBiYXNlZCBvbiB0aGUgZmlyc3Qgbm9uLW51bGwgbm9kZVxuXHQvLyAgIG9mIGVhY2ggbGlzdC5cblx0Ly8gLSBkaWZmcyB0aGVtIGFuZCBwYXRjaGVzIHRoZSBET00gaWYgbmVlZGVkICh0aGF0J3MgdGhlIGJydW50IG9mIHRoZSBjb2RlKVxuXHQvLyAtIG1hbmFnZXMgdGhlIGxlZnRvdmVyczogYWZ0ZXIgZGlmZmluZywgYXJlIHRoZXJlOlxuXHQvLyAgIC0gb2xkIG5vZGVzIGxlZnQgdG8gcmVtb3ZlP1xuXHQvLyBcdCAtIG5ldyBub2RlcyB0byBpbnNlcnQ/XG5cdC8vIFx0IGRlYWwgd2l0aCB0aGVtIVxuXHQvL1xuXHQvLyBUaGUgbGlzdHMgYXJlIG9ubHkgaXRlcmF0ZWQgb3ZlciBvbmNlLCB3aXRoIGFuIGV4Y2VwdGlvbiBmb3IgdGhlIG5vZGVzIGluIGBvbGRgIHRoYXRcblx0Ly8gYXJlIHZpc2l0ZWQgaW4gdGhlIGZvdXJ0aCBwYXJ0IG9mIHRoZSBkaWZmIGFuZCBpbiB0aGUgYHJlbW92ZU5vZGVzYCBsb29wLlxuXG5cdC8vICMjIERpZmZpbmdcblx0Ly9cblx0Ly8gUmVhZGluZyBodHRwczovL2dpdGh1Yi5jb20vbG9jYWx2b2lkL2l2aS9ibG9iL2RkYzA5ZDA2YWJhZWY0NTI0OGU2MTMzZjcwNDBkMDBkM2M2YmU4NTMvcGFja2FnZXMvaXZpL3NyYy92ZG9tL2ltcGxlbWVudGF0aW9uLnRzI0w2MTctTDgzN1xuXHQvLyBtYXkgYmUgZ29vZCBmb3IgY29udGV4dCBvbiBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UtYmFzZWQgbG9naWMgZm9yIG1vdmluZyBub2Rlcy5cblx0Ly9cblx0Ly8gSW4gb3JkZXIgdG8gZGlmZiBrZXllZCBsaXN0cywgb25lIGhhcyB0b1xuXHQvL1xuXHQvLyAxKSBtYXRjaCBub2RlcyBpbiBib3RoIGxpc3RzLCBwZXIga2V5LCBhbmQgdXBkYXRlIHRoZW0gYWNjb3JkaW5nbHlcblx0Ly8gMikgY3JlYXRlIHRoZSBub2RlcyBwcmVzZW50IGluIHRoZSBuZXcgbGlzdCwgYnV0IGFic2VudCBpbiB0aGUgb2xkIG9uZVxuXHQvLyAzKSByZW1vdmUgdGhlIG5vZGVzIHByZXNlbnQgaW4gdGhlIG9sZCBsaXN0LCBidXQgYWJzZW50IGluIHRoZSBuZXcgb25lXG5cdC8vIDQpIGZpZ3VyZSBvdXQgd2hhdCBub2RlcyBpbiAxKSB0byBtb3ZlIGluIG9yZGVyIHRvIG1pbmltaXplIHRoZSBET00gb3BlcmF0aW9ucy5cblx0Ly9cblx0Ly8gVG8gYWNoaWV2ZSAxKSBvbmUgY2FuIGNyZWF0ZSBhIGRpY3Rpb25hcnkgb2Yga2V5cyA9PiBpbmRleCAoZm9yIHRoZSBvbGQgbGlzdCksIHRoZW4gaXRlcmF0ZVxuXHQvLyBvdmVyIHRoZSBuZXcgbGlzdCBhbmQgZm9yIGVhY2ggbmV3IHZub2RlLCBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIHZub2RlIGluIHRoZSBvbGQgbGlzdCB1c2luZ1xuXHQvLyB0aGUgbWFwLlxuXHQvLyAyKSBpcyBhY2hpZXZlZCBpbiB0aGUgc2FtZSBzdGVwOiBpZiBhIG5ldyBub2RlIGhhcyBubyBjb3JyZXNwb25kaW5nIGVudHJ5IGluIHRoZSBtYXAsIGl0IGlzIG5ld1xuXHQvLyBhbmQgbXVzdCBiZSBjcmVhdGVkLlxuXHQvLyBGb3IgdGhlIHJlbW92YWxzLCB3ZSBhY3R1YWxseSByZW1vdmUgdGhlIG5vZGVzIHRoYXQgaGF2ZSBiZWVuIHVwZGF0ZWQgZnJvbSB0aGUgb2xkIGxpc3QuXG5cdC8vIFRoZSBub2RlcyB0aGF0IHJlbWFpbiBpbiB0aGF0IGxpc3QgYWZ0ZXIgMSkgYW5kIDIpIGhhdmUgYmVlbiBwZXJmb3JtZWQgY2FuIGJlIHNhZmVseSByZW1vdmVkLlxuXHQvLyBUaGUgZm91cnRoIHN0ZXAgaXMgYSBiaXQgbW9yZSBjb21wbGV4IGFuZCByZWxpZXMgb24gdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSAoTElTKVxuXHQvLyBhbGdvcml0aG0uXG5cdC8vXG5cdC8vIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UgaXMgdGhlIGxpc3Qgb2Ygbm9kZXMgdGhhdCBjYW4gcmVtYWluIGluIHBsYWNlLiBJbWFnaW5lIGdvaW5nXG5cdC8vIGZyb20gYDEsMiwzLDQsNWAgdG8gYDQsNSwxLDIsM2Agd2hlcmUgdGhlIG51bWJlcnMgYXJlIG5vdCBuZWNlc3NhcmlseSB0aGUga2V5cywgYnV0IHRoZSBpbmRpY2VzXG5cdC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGtleWVkIG5vZGVzIGluIHRoZSBvbGQgbGlzdCAoa2V5ZWQgbm9kZXMgYGUsZCxjLGIsYWAgPT4gYGIsYSxlLGQsY2Agd291bGRcblx0Ly8gIG1hdGNoIHRoZSBhYm92ZSBsaXN0cywgZm9yIGV4YW1wbGUpLlxuXHQvL1xuXHQvLyBJbiB0aGVyZSBhcmUgdHdvIGluY3JlYXNpbmcgc3Vic2VxdWVuY2VzOiBgNCw1YCBhbmQgYDEsMiwzYCwgdGhlIGxhdHRlciBiZWluZyB0aGUgbG9uZ2VzdC4gV2Vcblx0Ly8gY2FuIHVwZGF0ZSB0aG9zZSBub2RlcyB3aXRob3V0IG1vdmluZyB0aGVtLCBhbmQgb25seSBjYWxsIGBpbnNlcnROb2RlYCBvbiBgNGAgYW5kIGA1YC5cblx0Ly9cblx0Ly8gQGxvY2Fsdm9pZCBhZGFwdGVkIHRoZSBhbGdvIHRvIGFsc28gc3VwcG9ydCBub2RlIGRlbGV0aW9ucyBhbmQgaW5zZXJ0aW9ucyAodGhlIGBsaXNgIGlzIGFjdHVhbGx5XG5cdC8vIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UgKm9mIG9sZCBub2RlcyBzdGlsbCBwcmVzZW50IGluIHRoZSBuZXcgbGlzdCopLlxuXHQvL1xuXHQvLyBJdCBpcyBhIGdlbmVyYWwgYWxnb3JpdGhtIHRoYXQgaXMgZmlyZXByb29mIGluIGFsbCBjaXJjdW1zdGFuY2VzLCBidXQgaXQgcmVxdWlyZXMgdGhlIGFsbG9jYXRpb25cblx0Ly8gYW5kIHRoZSBjb25zdHJ1Y3Rpb24gb2YgYSBga2V5ID0+IG9sZEluZGV4YCBtYXAsIGFuZCB0aHJlZSBhcnJheXMgKG9uZSB3aXRoIGBuZXdJbmRleCA9PiBvbGRJbmRleGAsXG5cdC8vIHRoZSBgTElTYCBhbmQgYSB0ZW1wb3Jhcnkgb25lIHRvIGNyZWF0ZSB0aGUgTElTKS5cblx0Ly9cblx0Ly8gU28gd2UgY2hlYXQgd2hlcmUgd2UgY2FuOiBpZiB0aGUgdGFpbHMgb2YgdGhlIGxpc3RzIGFyZSBpZGVudGljYWwsIHRoZXkgYXJlIGd1YXJhbnRlZWQgdG8gYmUgcGFydCBvZlxuXHQvLyB0aGUgTElTIGFuZCBjYW4gYmUgdXBkYXRlZCB3aXRob3V0IG1vdmluZyB0aGVtLlxuXHQvL1xuXHQvLyBJZiB0d28gbm9kZXMgYXJlIHN3YXBwZWQsIHRoZXkgYXJlIGd1YXJhbnRlZWQgbm90IHRvIGJlIHBhcnQgb2YgdGhlIExJUywgYW5kIG11c3QgYmUgbW92ZWQgKHdpdGhcblx0Ly8gdGhlIGV4Y2VwdGlvbiBvZiB0aGUgbGFzdCBub2RlIGlmIHRoZSBsaXN0IGlzIGZ1bGx5IHJldmVyc2VkKS5cblx0Ly9cblx0Ly8gIyMgRmluZGluZyB0aGUgbmV4dCBzaWJsaW5nLlxuXHQvL1xuXHQvLyBgdXBkYXRlTm9kZSgpYCBhbmQgYGNyZWF0ZU5vZGUoKWAgZXhwZWN0IGEgbmV4dFNpYmxpbmcgcGFyYW1ldGVyIHRvIHBlcmZvcm0gRE9NIG9wZXJhdGlvbnMuXG5cdC8vIFdoZW4gdGhlIGxpc3QgaXMgYmVpbmcgdHJhdmVyc2VkIHRvcC1kb3duLCBhdCBhbnkgaW5kZXgsIHRoZSBET00gbm9kZXMgdXAgdG8gdGhlIHByZXZpb3VzXG5cdC8vIHZub2RlIHJlZmxlY3QgdGhlIGNvbnRlbnQgb2YgdGhlIG5ldyBsaXN0LCB3aGVyZWFzIHRoZSByZXN0IG9mIHRoZSBET00gbm9kZXMgcmVmbGVjdCB0aGUgb2xkXG5cdC8vIGxpc3QuIFRoZSBuZXh0IHNpYmxpbmcgbXVzdCBiZSBsb29rZWQgZm9yIGluIHRoZSBvbGQgbGlzdCB1c2luZyBgZ2V0TmV4dFNpYmxpbmcoLi4uIG9sZFN0YXJ0ICsgMSAuLi4pYC5cblx0Ly9cblx0Ly8gSW4gdGhlIG90aGVyIHNjZW5hcmlvcyAoc3dhcHMsIHVwd2FyZHMgdHJhdmVyc2FsLCBtYXAtYmFzZWQgZGlmZiksXG5cdC8vIHRoZSBuZXcgdm5vZGVzIGxpc3QgaXMgdHJhdmVyc2VkIHVwd2FyZHMuIFRoZSBET00gbm9kZXMgYXQgdGhlIGJvdHRvbSBvZiB0aGUgbGlzdCByZWZsZWN0IHRoZVxuXHQvLyBib3R0b20gcGFydCBvZiB0aGUgbmV3IHZub2RlcyBsaXN0LCBhbmQgd2UgY2FuIHVzZSB0aGUgYHYuZG9tYCAgdmFsdWUgb2YgdGhlIHByZXZpb3VzIG5vZGVcblx0Ly8gYXMgdGhlIG5leHQgc2libGluZyAoY2FjaGVkIGluIHRoZSBgbmV4dFNpYmxpbmdgIHZhcmlhYmxlKS5cblxuXG5cdC8vICMjIERPTSBub2RlIG1vdmVzXG5cdC8vXG5cdC8vIEluIG1vc3Qgc2NlbmFyaW9zIGB1cGRhdGVOb2RlKClgIGFuZCBgY3JlYXRlTm9kZSgpYCBwZXJmb3JtIHRoZSBET00gb3BlcmF0aW9ucy4gSG93ZXZlcixcblx0Ly8gdGhpcyBpcyBub3QgdGhlIGNhc2UgaWYgdGhlIG5vZGUgbW92ZWQgKHNlY29uZCBhbmQgZm91cnRoIHBhcnQgb2YgdGhlIGRpZmYgYWxnbykuIFdlIG1vdmVcblx0Ly8gdGhlIG9sZCBET00gbm9kZXMgYmVmb3JlIHVwZGF0ZU5vZGUgcnVucyBiZWNhdXNlIGl0IGVuYWJsZXMgdXMgdG8gdXNlIHRoZSBjYWNoZWQgYG5leHRTaWJsaW5nYFxuXHQvLyB2YXJpYWJsZSByYXRoZXIgdGhhbiBmZXRjaGluZyBpdCB1c2luZyBgZ2V0TmV4dFNpYmxpbmcoKWAuXG5cdC8vXG5cdC8vIFRoZSBmb3VydGggcGFydCBvZiB0aGUgZGlmZiBjdXJyZW50bHkgaW5zZXJ0cyBub2RlcyB1bmNvbmRpdGlvbmFsbHksIGxlYWRpbmcgdG8gaXNzdWVzXG5cdC8vIGxpa2UgIzE3OTEgYW5kICMxOTk5LiBXZSBuZWVkIHRvIGJlIHNtYXJ0ZXIgYWJvdXQgdGhvc2Ugc2l0dWF0aW9ucyB3aGVyZSBhZGphc2NlbnQgb2xkXG5cdC8vIG5vZGVzIHJlbWFpbiB0b2dldGhlciBpbiB0aGUgbmV3IGxpc3QgaW4gYSB3YXkgdGhhdCBpc24ndCBjb3ZlcmVkIGJ5IHBhcnRzIG9uZSBhbmRcblx0Ly8gdGhyZWUgb2YgdGhlIGRpZmYgYWxnby5cblxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZCwgdm5vZGVzLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0aWYgKG9sZCA9PT0gdm5vZGVzIHx8IG9sZCA9PSBudWxsICYmIHZub2RlcyA9PSBudWxsKSByZXR1cm5cblx0XHRlbHNlIGlmIChvbGQgPT0gbnVsbCB8fCBvbGQubGVuZ3RoID09PSAwKSBjcmVhdGVOb2Rlc0NoZWNrZWQocGFyZW50LCB2bm9kZXMsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0ZWxzZSBpZiAodm5vZGVzID09IG51bGwgfHwgdm5vZGVzLmxlbmd0aCA9PT0gMCkgcmVtb3ZlTm9kZXMob2xkLCAwLCBvbGQubGVuZ3RoKVxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGlzT2xkS2V5ZWQgPSBvbGRbMF0gIT0gbnVsbCAmJiBvbGRbMF0ua2V5ICE9IG51bGxcblx0XHRcdHZhciBpc0tleWVkID0gdm5vZGVzWzBdICE9IG51bGwgJiYgdm5vZGVzWzBdLmtleSAhPSBudWxsXG5cdFx0XHR2YXIgc3RhcnQgPSAwLCBvbGRTdGFydCA9IDBcblx0XHRcdHZhbGlkYXRlS2V5cyh2bm9kZXMsIGlzS2V5ZWQpXG5cdFx0XHRpZiAoIWlzT2xkS2V5ZWQpIHdoaWxlIChvbGRTdGFydCA8IG9sZC5sZW5ndGggJiYgb2xkW29sZFN0YXJ0XSA9PSBudWxsKSBvbGRTdGFydCsrXG5cdFx0XHRpZiAoIWlzS2V5ZWQpIHdoaWxlIChzdGFydCA8IHZub2Rlcy5sZW5ndGggJiYgdm5vZGVzW3N0YXJ0XSA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRpZiAoaXNLZXllZCA9PT0gbnVsbCAmJiBpc09sZEtleWVkID09IG51bGwpIHJldHVybiAvLyBib3RoIGxpc3RzIGFyZSBmdWxsIG9mIG51bGxzXG5cdFx0XHRpZiAoaXNPbGRLZXllZCAhPT0gaXNLZXllZCkge1xuXHRcdFx0XHRyZW1vdmVOb2RlcyhvbGQsIG9sZFN0YXJ0LCBvbGQubGVuZ3RoKVxuXHRcdFx0XHRjcmVhdGVOb2Rlc1VuY2hlY2tlZChwYXJlbnQsIHZub2Rlcywgc3RhcnQsIHZub2Rlcy5sZW5ndGgsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0XHR9IGVsc2UgaWYgKCFpc0tleWVkKSB7XG5cdFx0XHRcdC8vIERvbid0IGluZGV4IHBhc3QgdGhlIGVuZCBvZiBlaXRoZXIgbGlzdCAoY2F1c2VzIGRlb3B0cykuXG5cdFx0XHRcdHZhciBjb21tb25MZW5ndGggPSBvbGQubGVuZ3RoIDwgdm5vZGVzLmxlbmd0aCA/IG9sZC5sZW5ndGggOiB2bm9kZXMubGVuZ3RoXG5cdFx0XHRcdC8vIFJld2luZCBpZiBuZWNlc3NhcnkgdG8gdGhlIGZpcnN0IG5vbi1udWxsIGluZGV4IG9uIGVpdGhlciBzaWRlLlxuXHRcdFx0XHQvLyBXZSBjb3VsZCBhbHRlcm5hdGl2ZWx5IGVpdGhlciBleHBsaWNpdGx5IGNyZWF0ZSBvciByZW1vdmUgbm9kZXMgd2hlbiBgc3RhcnQgIT09IG9sZFN0YXJ0YFxuXHRcdFx0XHQvLyBidXQgdGhhdCB3b3VsZCBiZSBvcHRpbWl6aW5nIGZvciBzcGFyc2UgbGlzdHMgd2hpY2ggYXJlIG1vcmUgcmFyZSB0aGFuIGRlbnNlIG9uZXMuXG5cdFx0XHRcdHN0YXJ0ID0gc3RhcnQgPCBvbGRTdGFydCA/IHN0YXJ0IDogb2xkU3RhcnRcblx0XHRcdFx0Zm9yICg7IHN0YXJ0IDwgY29tbW9uTGVuZ3RoOyBzdGFydCsrKSB7XG5cdFx0XHRcdFx0byA9IG9sZFtzdGFydF1cblx0XHRcdFx0XHR2ID0gdm5vZGVzW3N0YXJ0XVxuXHRcdFx0XHRcdGlmIChvID09PSB2IHx8IG8gPT0gbnVsbCAmJiB2ID09IG51bGwpIGNvbnRpbnVlXG5cdFx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBjcmVhdGVOb2RlKHBhcmVudCwgdiwgaG9va3MsIG5zLCBnZXROZXh0U2libGluZyhvbGQsIHN0YXJ0ICsgMSwgbmV4dFNpYmxpbmcpKVxuXHRcdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgcmVtb3ZlTm9kZShvKVxuXHRcdFx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIHN0YXJ0ICsgMSwgbmV4dFNpYmxpbmcpLCBucylcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob2xkLmxlbmd0aCA+IGNvbW1vbkxlbmd0aCkgcmVtb3ZlTm9kZXMob2xkLCBzdGFydCwgb2xkLmxlbmd0aClcblx0XHRcdFx0aWYgKHZub2Rlcy5sZW5ndGggPiBjb21tb25MZW5ndGgpIGNyZWF0ZU5vZGVzVW5jaGVja2VkKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgdm5vZGVzLmxlbmd0aCwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGtleWVkIGRpZmZcblx0XHRcdFx0dmFyIG9sZEVuZCA9IG9sZC5sZW5ndGggLSAxLCBlbmQgPSB2bm9kZXMubGVuZ3RoIC0gMSwgbWFwLCBvLCB2LCBvZSwgdmUsIHRvcFNpYmxpbmdcblxuXHRcdFx0XHQvLyBib3R0b20tdXBcblx0XHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0XHRvZSA9IG9sZFtvbGRFbmRdXG5cdFx0XHRcdFx0dmUgPSB2bm9kZXNbZW5kXVxuXHRcdFx0XHRcdGlmIChvZS5rZXkgIT09IHZlLmtleSkgYnJlYWtcblx0XHRcdFx0XHRpZiAob2UgIT09IHZlKSB1cGRhdGVOb2RlKHBhcmVudCwgb2UsIHZlLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0XHRcdGlmICh2ZS5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSB2ZS5kb21cblx0XHRcdFx0XHRvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyB0b3AtZG93blxuXHRcdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHRcdG8gPSBvbGRbb2xkU3RhcnRdXG5cdFx0XHRcdFx0diA9IHZub2Rlc1tzdGFydF1cblx0XHRcdFx0XHRpZiAoby5rZXkgIT09IHYua2V5KSBicmVha1xuXHRcdFx0XHRcdG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0XHRpZiAobyAhPT0gdikgdXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZyksIG5zKVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHN3YXBzIGFuZCBsaXN0IHJldmVyc2Fsc1xuXHRcdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHRcdGlmIChzdGFydCA9PT0gZW5kKSBicmVha1xuXHRcdFx0XHRcdGlmIChvLmtleSAhPT0gdmUua2V5IHx8IG9lLmtleSAhPT0gdi5rZXkpIGJyZWFrXG5cdFx0XHRcdFx0dG9wU2libGluZyA9IGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG9lKSwgdG9wU2libGluZylcblx0XHRcdFx0XHRpZiAob2UgIT09IHYpIHVwZGF0ZU5vZGUocGFyZW50LCBvZSwgdiwgaG9va3MsIHRvcFNpYmxpbmcsIG5zKVxuXHRcdFx0XHRcdGlmICgrK3N0YXJ0IDw9IC0tZW5kKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0aWYgKG8gIT09IHZlKSB1cGRhdGVOb2RlKHBhcmVudCwgbywgdmUsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0XHRcdFx0aWYgKHZlLmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IHZlLmRvbVxuXHRcdFx0XHRcdG9sZFN0YXJ0Kys7IG9sZEVuZC0tXG5cdFx0XHRcdFx0b2UgPSBvbGRbb2xkRW5kXVxuXHRcdFx0XHRcdHZlID0gdm5vZGVzW2VuZF1cblx0XHRcdFx0XHRvID0gb2xkW29sZFN0YXJ0XVxuXHRcdFx0XHRcdHYgPSB2bm9kZXNbc3RhcnRdXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gYm90dG9tIHVwIG9uY2UgYWdhaW5cblx0XHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0XHRpZiAob2Uua2V5ICE9PSB2ZS5rZXkpIGJyZWFrXG5cdFx0XHRcdFx0aWYgKG9lICE9PSB2ZSkgdXBkYXRlTm9kZShwYXJlbnQsIG9lLCB2ZSwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRcdFx0XHRpZiAodmUuZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gdmUuZG9tXG5cdFx0XHRcdFx0b2xkRW5kLS0sIGVuZC0tXG5cdFx0XHRcdFx0b2UgPSBvbGRbb2xkRW5kXVxuXHRcdFx0XHRcdHZlID0gdm5vZGVzW2VuZF1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc3RhcnQgPiBlbmQpIHJlbW92ZU5vZGVzKG9sZCwgb2xkU3RhcnQsIG9sZEVuZCArIDEpXG5cdFx0XHRcdGVsc2UgaWYgKG9sZFN0YXJ0ID4gb2xkRW5kKSBjcmVhdGVOb2Rlc1VuY2hlY2tlZChwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCArIDEsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIGluc3BpcmVkIGJ5IGl2aSBodHRwczovL2dpdGh1Yi5jb20vaXZpanMvaXZpLyBieSBCb3JpcyBLYXVsXG5cdFx0XHRcdFx0dmFyIG9yaWdpbmFsTmV4dFNpYmxpbmcgPSBuZXh0U2libGluZywgdm5vZGVzTGVuZ3RoID0gZW5kIC0gc3RhcnQgKyAxLCBvbGRJbmRpY2VzID0gbmV3IEFycmF5KHZub2Rlc0xlbmd0aCksIGxpPTAsIGk9MCwgcG9zID0gMjE0NzQ4MzY0NywgbWF0Y2hlZCA9IDAsIG1hcCwgbGlzSW5kaWNlc1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB2bm9kZXNMZW5ndGg7IGkrKykgb2xkSW5kaWNlc1tpXSA9IC0xXG5cdFx0XHRcdFx0Zm9yIChpID0gZW5kOyBpID49IHN0YXJ0OyBpLS0pIHtcblx0XHRcdFx0XHRcdGlmIChtYXAgPT0gbnVsbCkgbWFwID0gZ2V0S2V5TWFwKG9sZCwgb2xkU3RhcnQsIG9sZEVuZCArIDEpXG5cdFx0XHRcdFx0XHR2ZSA9IHZub2Rlc1tpXVxuXHRcdFx0XHRcdFx0dmFyIG9sZEluZGV4ID0gbWFwW3ZlLmtleV1cblx0XHRcdFx0XHRcdGlmIChvbGRJbmRleCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHBvcyA9IChvbGRJbmRleCA8IHBvcykgPyBvbGRJbmRleCA6IC0xIC8vIGJlY29tZXMgLTEgaWYgbm9kZXMgd2VyZSByZS1vcmRlcmVkXG5cdFx0XHRcdFx0XHRcdG9sZEluZGljZXNbaS1zdGFydF0gPSBvbGRJbmRleFxuXHRcdFx0XHRcdFx0XHRvZSA9IG9sZFtvbGRJbmRleF1cblx0XHRcdFx0XHRcdFx0b2xkW29sZEluZGV4XSA9IG51bGxcblx0XHRcdFx0XHRcdFx0aWYgKG9lICE9PSB2ZSkgdXBkYXRlTm9kZShwYXJlbnQsIG9lLCB2ZSwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRcdFx0XHRcdFx0aWYgKHZlLmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IHZlLmRvbVxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkKytcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV4dFNpYmxpbmcgPSBvcmlnaW5hbE5leHRTaWJsaW5nXG5cdFx0XHRcdFx0aWYgKG1hdGNoZWQgIT09IG9sZEVuZCAtIG9sZFN0YXJ0ICsgMSkgcmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSlcblx0XHRcdFx0XHRpZiAobWF0Y2hlZCA9PT0gMCkgY3JlYXRlTm9kZXNVbmNoZWNrZWQocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKHBvcyA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0Ly8gdGhlIGluZGljZXMgb2YgdGhlIGluZGljZXMgb2YgdGhlIGl0ZW1zIHRoYXQgYXJlIHBhcnQgb2YgdGhlXG5cdFx0XHRcdFx0XHRcdC8vIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBpbiB0aGUgb2xkSW5kaWNlcyBsaXN0XG5cdFx0XHRcdFx0XHRcdGxpc0luZGljZXMgPSBtYWtlTGlzSW5kaWNlcyhvbGRJbmRpY2VzKVxuXHRcdFx0XHRcdFx0XHRsaSA9IGxpc0luZGljZXMubGVuZ3RoIC0gMVxuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSBlbmQ7IGkgPj0gc3RhcnQ7IGktLSkge1xuXHRcdFx0XHRcdFx0XHRcdHYgPSB2bm9kZXNbaV1cblx0XHRcdFx0XHRcdFx0XHRpZiAob2xkSW5kaWNlc1tpLXN0YXJ0XSA9PT0gLTEpIGNyZWF0ZU5vZGUocGFyZW50LCB2LCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGxpc0luZGljZXNbbGldID09PSBpIC0gc3RhcnQpIGxpLS1cblx0XHRcdFx0XHRcdFx0XHRcdGVsc2UgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQodiksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAodi5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSB2bm9kZXNbaV0uZG9tXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IGVuZDsgaSA+PSBzdGFydDsgaS0tKSB7XG5cdFx0XHRcdFx0XHRcdFx0diA9IHZub2Rlc1tpXVxuXHRcdFx0XHRcdFx0XHRcdGlmIChvbGRJbmRpY2VzW2ktc3RhcnRdID09PSAtMSkgY3JlYXRlTm9kZShwYXJlbnQsIHYsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHYuZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gdm5vZGVzW2ldLmRvbVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZU5vZGUocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmIChzaG91bGROb3RVcGRhdGUodm5vZGUsIG9sZCkpIHJldHVyblxuXHRcdFx0aWYgKHR5cGVvZiBvbGRUYWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIHtcblx0XHRcdFx0XHR1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5zLCBuZXh0U2libGluZyk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIltcIjogdXBkYXRlRnJhZ21lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKTsgYnJlYWtcblx0XHRcdFx0XHRkZWZhdWx0OiB1cGRhdGVFbGVtZW50KG9sZCwgdm5vZGUsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkKVxuXHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVUZXh0KG9sZCwgdm5vZGUpIHtcblx0XHRpZiAob2xkLmNoaWxkcmVuLnRvU3RyaW5nKCkgIT09IHZub2RlLmNoaWxkcmVuLnRvU3RyaW5nKCkpIHtcblx0XHRcdG9sZC5kb20ubm9kZVZhbHVlID0gdm5vZGUuY2hpbGRyZW5cblx0XHR9XG5cdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUhUTUwocGFyZW50LCBvbGQsIHZub2RlLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAob2xkLmNoaWxkcmVuICE9PSB2bm9kZS5jaGlsZHJlbikge1xuXHRcdFx0dG9GcmFnbWVudChvbGQpXG5cdFx0XHRjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5zLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHR1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZC5jaGlsZHJlbiwgdm5vZGUuY2hpbGRyZW4sIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0dmFyIGRvbVNpemUgPSAwLCBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gbnVsbFxuXHRcdGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsICYmIGNoaWxkLmRvbSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHZub2RlLmRvbSA9PSBudWxsKSB2bm9kZS5kb20gPSBjaGlsZC5kb21cblx0XHRcdFx0XHRkb21TaXplICs9IGNoaWxkLmRvbVNpemUgfHwgMVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZG9tU2l6ZSAhPT0gMSkgdm5vZGUuZG9tU2l6ZSA9IGRvbVNpemVcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRucyA9IGdldE5hbWVTcGFjZSh2bm9kZSkgfHwgbnNcblxuXHRcdGlmICh2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikge1xuXHRcdFx0aWYgKHZub2RlLmF0dHJzID09IG51bGwpIHZub2RlLmF0dHJzID0ge31cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuYXR0cnMudmFsdWUgPSB2bm9kZS50ZXh0IC8vRklYTUUgaGFuZGxlIG11bHRpcGxlIGNoaWxkcmVuXG5cdFx0XHRcdHZub2RlLnRleHQgPSB1bmRlZmluZWRcblx0XHRcdH1cblx0XHR9XG5cdFx0dXBkYXRlQXR0cnModm5vZGUsIG9sZC5hdHRycywgdm5vZGUuYXR0cnMsIG5zKVxuXHRcdGlmICghbWF5YmVTZXRDb250ZW50RWRpdGFibGUodm5vZGUpKSB7XG5cdFx0XHRpZiAob2xkLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPT0gXCJcIikge1xuXHRcdFx0XHRpZiAob2xkLnRleHQudG9TdHJpbmcoKSAhPT0gdm5vZGUudGV4dC50b1N0cmluZygpKSBvbGQuZG9tLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdm5vZGUudGV4dFxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmIChvbGQudGV4dCAhPSBudWxsKSBvbGQuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGQudGV4dCwgdW5kZWZpbmVkLCBvbGQuZG9tLmZpcnN0Q2hpbGQpXVxuXHRcdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB2bm9kZS5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHZub2RlLnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKV1cblx0XHRcdFx0dXBkYXRlTm9kZXMoZWxlbWVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgaG9va3MsIG51bGwsIG5zKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUoY2FsbEhvb2suY2FsbCh2bm9kZS5zdGF0ZS52aWV3LCB2bm9kZSkpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHR1cGRhdGVMaWZlY3ljbGUodm5vZGUuc3RhdGUsIHZub2RlLCBob29rcylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdGlmIChvbGQuaW5zdGFuY2UgPT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLmluc3RhbmNlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLmluc3RhbmNlLCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmluc3RhbmNlLmRvbVNpemVcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLmluc3RhbmNlKVxuXHRcdFx0dm5vZGUuZG9tID0gdW5kZWZpbmVkXG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBnZXRLZXlNYXAodm5vZGVzLCBzdGFydCwgZW5kKSB7XG5cdFx0dmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbClcblx0XHRmb3IgKDsgc3RhcnQgPCBlbmQ7IHN0YXJ0KyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tzdGFydF1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBrZXkgPSB2bm9kZS5rZXlcblx0XHRcdFx0aWYgKGtleSAhPSBudWxsKSBtYXBba2V5XSA9IHN0YXJ0XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXBcblx0fVxuXHQvLyBMaWZ0ZWQgZnJvbSBpdmkgaHR0cHM6Ly9naXRodWIuY29tL2l2aWpzL2l2aS9cblx0Ly8gdGFrZXMgYSBsaXN0IG9mIHVuaXF1ZSBudW1iZXJzICgtMSBpcyBzcGVjaWFsIGFuZCBjYW5cblx0Ly8gb2NjdXIgbXVsdGlwbGUgdGltZXMpIGFuZCByZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIGluZGljZXNcblx0Ly8gb2YgdGhlIGl0ZW1zIHRoYXQgYXJlIHBhcnQgb2YgdGhlIGxvbmdlc3QgaW5jcmVhc2luZ1xuXHQvLyBzdWJzZXF1ZWNlXG5cdHZhciBsaXNUZW1wID0gW11cblx0ZnVuY3Rpb24gbWFrZUxpc0luZGljZXMoYSkge1xuXHRcdHZhciByZXN1bHQgPSBbMF1cblx0XHR2YXIgdSA9IDAsIHYgPSAwLCBpID0gMFxuXHRcdHZhciBpbCA9IGxpc1RlbXAubGVuZ3RoID0gYS5sZW5ndGhcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGlsOyBpKyspIGxpc1RlbXBbaV0gPSBhW2ldXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbDsgKytpKSB7XG5cdFx0XHRpZiAoYVtpXSA9PT0gLTEpIGNvbnRpbnVlXG5cdFx0XHR2YXIgaiA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV1cblx0XHRcdGlmIChhW2pdIDwgYVtpXSkge1xuXHRcdFx0XHRsaXNUZW1wW2ldID0galxuXHRcdFx0XHRyZXN1bHQucHVzaChpKVxuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0fVxuXHRcdFx0dSA9IDBcblx0XHRcdHYgPSByZXN1bHQubGVuZ3RoIC0gMVxuXHRcdFx0d2hpbGUgKHUgPCB2KSB7XG5cdFx0XHRcdC8vIEZhc3QgaW50ZWdlciBhdmVyYWdlIHdpdGhvdXQgb3ZlcmZsb3cuXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG5cdFx0XHRcdHZhciBjID0gKHUgPj4+IDEpICsgKHYgPj4+IDEpICsgKHUgJiB2ICYgMSlcblx0XHRcdFx0aWYgKGFbcmVzdWx0W2NdXSA8IGFbaV0pIHtcblx0XHRcdFx0XHR1ID0gYyArIDFcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2ID0gY1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoYVtpXSA8IGFbcmVzdWx0W3VdXSkge1xuXHRcdFx0XHRpZiAodSA+IDApIGxpc1RlbXBbaV0gPSByZXN1bHRbdSAtIDFdXG5cdFx0XHRcdHJlc3VsdFt1XSA9IGlcblx0XHRcdH1cblx0XHR9XG5cdFx0dSA9IHJlc3VsdC5sZW5ndGhcblx0XHR2ID0gcmVzdWx0W3UgLSAxXVxuXHRcdHdoaWxlICh1LS0gPiAwKSB7XG5cdFx0XHRyZXN1bHRbdV0gPSB2XG5cdFx0XHR2ID0gbGlzVGVtcFt2XVxuXHRcdH1cblx0XHRsaXNUZW1wLmxlbmd0aCA9IDBcblx0XHRyZXR1cm4gcmVzdWx0XG5cdH1cblxuXHRmdW5jdGlvbiB0b0ZyYWdtZW50KHZub2RlKSB7XG5cdFx0dmFyIGNvdW50ID0gdm5vZGUuZG9tU2l6ZVxuXHRcdGlmIChjb3VudCAhPSBudWxsIHx8IHZub2RlLmRvbSA9PSBudWxsKSB7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdFx0aWYgKGNvdW50ID4gMCkge1xuXHRcdFx0XHR2YXIgZG9tID0gdm5vZGUuZG9tXG5cdFx0XHRcdHdoaWxlICgtLWNvdW50KSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdGZyYWdtZW50Lmluc2VydEJlZm9yZShkb20sIGZyYWdtZW50LmZpcnN0Q2hpbGQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnJhZ21lbnRcblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcodm5vZGVzLCBpLCBuZXh0U2libGluZykge1xuXHRcdGZvciAoOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgdm5vZGVzW2ldLmRvbSAhPSBudWxsKSByZXR1cm4gdm5vZGVzW2ldLmRvbVxuXHRcdH1cblx0XHRyZXR1cm4gbmV4dFNpYmxpbmdcblx0fVxuXG5cdGZ1bmN0aW9uIGluc2VydE5vZGUocGFyZW50LCBkb20sIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG5leHRTaWJsaW5nICE9IG51bGwpIHBhcmVudC5pbnNlcnRCZWZvcmUoZG9tLCBuZXh0U2libGluZylcblx0XHRlbHNlIHBhcmVudC5hcHBlbmRDaGlsZChkb20pXG5cdH1cblxuXHRmdW5jdGlvbiBtYXliZVNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5hdHRycyA9PSBudWxsIHx8IChcblx0XHRcdHZub2RlLmF0dHJzLmNvbnRlbnRlZGl0YWJsZSA9PSBudWxsICYmIC8vIGF0dHJpYnV0ZVxuXHRcdFx0dm5vZGUuYXR0cnMuY29udGVudEVkaXRhYmxlID09IG51bGwgLy8gcHJvcGVydHlcblx0XHQpKSByZXR1cm5cblx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdGlmIChjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiPFwiKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdFx0XHRpZiAodm5vZGUuZG9tLmlubmVySFRNTCAhPT0gY29udGVudCkgdm5vZGUuZG9tLmlubmVySFRNTCA9IGNvbnRlbnRcblx0XHR9XG5cdFx0ZWxzZSBpZiAodm5vZGUudGV4dCAhPSBudWxsIHx8IGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBub2RlIG9mIGEgY29udGVudGVkaXRhYmxlIG11c3QgYmUgdHJ1c3RlZFwiKVxuXHR9XG5cblx0Ly9yZW1vdmVcblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZXModm5vZGVzLCBzdGFydCwgZW5kKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHJlbW92ZU5vZGUodm5vZGUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGUodm5vZGUpIHtcblx0XHR2YXIgZXhwZWN0ZWQgPSAxLCBjYWxsZWQgPSAwXG5cdFx0dmFyIG9yaWdpbmFsID0gdm5vZGUuc3RhdGVcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuc3RhdGUub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IGNhbGxIb29rLmNhbGwodm5vZGUuc3RhdGUub25iZWZvcmVyZW1vdmUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IGNhbGxIb29rLmNhbGwodm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnRpbnVhdGlvbigpXG5cdFx0ZnVuY3Rpb24gY29udGludWF0aW9uKCkge1xuXHRcdFx0aWYgKCsrY2FsbGVkID09PSBleHBlY3RlZCkge1xuXHRcdFx0XHRjaGVja1N0YXRlKHZub2RlLCBvcmlnaW5hbClcblx0XHRcdFx0b25yZW1vdmUodm5vZGUpXG5cdFx0XHRcdGlmICh2bm9kZS5kb20pIHtcblx0XHRcdFx0XHR2YXIgcGFyZW50ID0gdm5vZGUuZG9tLnBhcmVudE5vZGVcblx0XHRcdFx0XHR2YXIgY291bnQgPSB2bm9kZS5kb21TaXplIHx8IDFcblx0XHRcdFx0XHR3aGlsZSAoLS1jb3VudCkgcGFyZW50LnJlbW92ZUNoaWxkKHZub2RlLmRvbS5uZXh0U2libGluZylcblx0XHRcdFx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQodm5vZGUuZG9tKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG9ucmVtb3ZlKHZub2RlKSB7XG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLnN0YXRlLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIGNhbGxIb29rLmNhbGwodm5vZGUuc3RhdGUub25yZW1vdmUsIHZub2RlKVxuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgY2FsbEhvb2suY2FsbCh2bm9kZS5hdHRycy5vbnJlbW92ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSBvbnJlbW92ZSh2bm9kZS5pbnN0YW5jZSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCkgb25yZW1vdmUoY2hpbGQpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvL2F0dHJzXG5cdGZ1bmN0aW9uIHNldEF0dHJzKHZub2RlLCBhdHRycywgbnMpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRcdHNldEF0dHIodm5vZGUsIGtleSwgbnVsbCwgYXR0cnNba2V5XSwgbnMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldEF0dHIodm5vZGUsIGtleSwgb2xkLCB2YWx1ZSwgbnMpIHtcblx0XHRpZiAoa2V5ID09PSBcImtleVwiIHx8IGtleSA9PT0gXCJpc1wiIHx8IHZhbHVlID09IG51bGwgfHwgaXNMaWZlY3ljbGVNZXRob2Qoa2V5KSB8fCAob2xkID09PSB2YWx1ZSAmJiAhaXNGb3JtQXR0cmlidXRlKHZub2RlLCBrZXkpKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHJldHVyblxuXHRcdGlmIChrZXlbMF0gPT09IFwib1wiICYmIGtleVsxXSA9PT0gXCJuXCIpIHJldHVybiB1cGRhdGVFdmVudCh2bm9kZSwga2V5LCB2YWx1ZSlcblx0XHRpZiAoa2V5LnNsaWNlKDAsIDYpID09PSBcInhsaW5rOlwiKSB2bm9kZS5kb20uc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIGtleS5zbGljZSg2KSwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHVwZGF0ZVN0eWxlKHZub2RlLmRvbSwgb2xkLCB2YWx1ZSlcblx0XHRlbHNlIGlmIChoYXNQcm9wZXJ0eUtleSh2bm9kZSwga2V5LCBucykpIHtcblx0XHRcdGlmIChrZXkgPT09IFwidmFsdWVcIikge1xuXHRcdFx0XHQvLyBPbmx5IGRvIHRoZSBjb2VyY2lvbiBpZiB3ZSdyZSBhY3R1YWxseSBnb2luZyB0byBjaGVjayB0aGUgdmFsdWUuXG5cdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWltcGxpY2l0LWNvZXJjaW9uICovXG5cdFx0XHRcdC8vc2V0dGluZyBpbnB1dFt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSBieSB0eXBpbmcgb24gZm9jdXNlZCBlbGVtZW50IG1vdmVzIGN1cnNvciB0byBlbmQgaW4gQ2hyb21lXG5cdFx0XHRcdGlmICgodm5vZGUudGFnID09PSBcImlucHV0XCIgfHwgdm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gXCJcIiArIHZhbHVlICYmIHZub2RlLmRvbSA9PT0gYWN0aXZlRWxlbWVudCgpKSByZXR1cm5cblx0XHRcdFx0Ly9zZXR0aW5nIHNlbGVjdFt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIiAmJiBvbGQgIT09IG51bGwgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBcIlwiICsgdmFsdWUpIHJldHVyblxuXHRcdFx0XHQvL3NldHRpbmcgb3B0aW9uW3ZhbHVlXSB0byBzYW1lIHZhbHVlIHdoaWxlIGhhdmluZyBzZWxlY3Qgb3BlbiBibGlua3Mgc2VsZWN0IGRyb3Bkb3duIGluIENocm9tZVxuXHRcdFx0XHRpZiAodm5vZGUudGFnID09PSBcIm9wdGlvblwiICYmIG9sZCAhPT0gbnVsbCAmJiB2bm9kZS5kb20udmFsdWUgPT09IFwiXCIgKyB2YWx1ZSkgcmV0dXJuXG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8taW1wbGljaXQtY29lcmNpb24gKi9cblx0XHRcdH1cblx0XHRcdC8vIElmIHlvdSBhc3NpZ24gYW4gaW5wdXQgdHlwZSB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUgMTEgd2l0aCBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24sIGFuIGVycm9yIHdpbGwgb2NjdXIuXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcImlucHV0XCIgJiYga2V5ID09PSBcInR5cGVcIikgdm5vZGUuZG9tLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuXHRcdFx0ZWxzZSB2bm9kZS5kb21ba2V5XSA9IHZhbHVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSkgdm5vZGUuZG9tLnNldEF0dHJpYnV0ZShrZXksIFwiXCIpXG5cdFx0XHRcdGVsc2Ugdm5vZGUuZG9tLnJlbW92ZUF0dHJpYnV0ZShrZXkpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHZub2RlLmRvbS5zZXRBdHRyaWJ1dGUoa2V5ID09PSBcImNsYXNzTmFtZVwiID8gXCJjbGFzc1wiIDoga2V5LCB2YWx1ZSlcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlQXR0cih2bm9kZSwga2V5LCBvbGQsIG5zKSB7XG5cdFx0aWYgKGtleSA9PT0gXCJrZXlcIiB8fCBrZXkgPT09IFwiaXNcIiB8fCBvbGQgPT0gbnVsbCB8fCBpc0xpZmVjeWNsZU1ldGhvZChrZXkpKSByZXR1cm5cblx0XHRpZiAoa2V5WzBdID09PSBcIm9cIiAmJiBrZXlbMV0gPT09IFwiblwiICYmICFpc0xpZmVjeWNsZU1ldGhvZChrZXkpKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5LCB1bmRlZmluZWQpXG5cdFx0ZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHVwZGF0ZVN0eWxlKHZub2RlLmRvbSwgb2xkLCBudWxsKVxuXHRcdGVsc2UgaWYgKFxuXHRcdFx0aGFzUHJvcGVydHlLZXkodm5vZGUsIGtleSwgbnMpXG5cdFx0XHQmJiBrZXkgIT09IFwiY2xhc3NOYW1lXCJcblx0XHRcdCYmICEoa2V5ID09PSBcInZhbHVlXCIgJiYgKFxuXHRcdFx0XHR2bm9kZS50YWcgPT09IFwib3B0aW9uXCJcblx0XHRcdFx0fHwgdm5vZGUudGFnID09PSBcInNlbGVjdFwiICYmIHZub2RlLmRvbS5zZWxlY3RlZEluZGV4ID09PSAtMSAmJiB2bm9kZS5kb20gPT09IGFjdGl2ZUVsZW1lbnQoKVxuXHRcdFx0KSlcblx0XHRcdCYmICEodm5vZGUudGFnID09PSBcImlucHV0XCIgJiYga2V5ID09PSBcInR5cGVcIilcblx0XHQpIHtcblx0XHRcdHZub2RlLmRvbVtrZXldID0gbnVsbFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbnNMYXN0SW5kZXggPSBrZXkuaW5kZXhPZihcIjpcIilcblx0XHRcdGlmIChuc0xhc3RJbmRleCAhPT0gLTEpIGtleSA9IGtleS5zbGljZShuc0xhc3RJbmRleCArIDEpXG5cdFx0XHRpZiAob2xkICE9PSBmYWxzZSkgdm5vZGUuZG9tLnJlbW92ZUF0dHJpYnV0ZShrZXkgPT09IFwiY2xhc3NOYW1lXCIgPyBcImNsYXNzXCIgOiBrZXkpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldExhdGVTZWxlY3RBdHRycyh2bm9kZSwgYXR0cnMpIHtcblx0XHRpZiAoXCJ2YWx1ZVwiIGluIGF0dHJzKSB7XG5cdFx0XHRpZihhdHRycy52YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodm5vZGUuZG9tLnNlbGVjdGVkSW5kZXggIT09IC0xKSB2bm9kZS5kb20udmFsdWUgPSBudWxsXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgbm9ybWFsaXplZCA9IFwiXCIgKyBhdHRycy52YWx1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uXG5cdFx0XHRcdGlmICh2bm9kZS5kb20udmFsdWUgIT09IG5vcm1hbGl6ZWQgfHwgdm5vZGUuZG9tLnNlbGVjdGVkSW5kZXggPT09IC0xKSB7XG5cdFx0XHRcdFx0dm5vZGUuZG9tLnZhbHVlID0gbm9ybWFsaXplZFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChcInNlbGVjdGVkSW5kZXhcIiBpbiBhdHRycykgc2V0QXR0cih2bm9kZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwsIGF0dHJzLnNlbGVjdGVkSW5kZXgsIHVuZGVmaW5lZClcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVBdHRycyh2bm9kZSwgb2xkLCBhdHRycywgbnMpIHtcblx0XHRpZiAoYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG5cdFx0XHRcdHNldEF0dHIodm5vZGUsIGtleSwgb2xkICYmIG9sZFtrZXldLCBhdHRyc1trZXldLCBucylcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIHZhbFxuXHRcdGlmIChvbGQgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIG9sZCkge1xuXHRcdFx0XHRpZiAoKCh2YWwgPSBvbGRba2V5XSkgIT0gbnVsbCkgJiYgKGF0dHJzID09IG51bGwgfHwgYXR0cnNba2V5XSA9PSBudWxsKSkge1xuXHRcdFx0XHRcdHJlbW92ZUF0dHIodm5vZGUsIGtleSwgdmFsLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJ2YWx1ZVwiIHx8IGF0dHIgPT09IFwiY2hlY2tlZFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRJbmRleFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRcIiAmJiB2bm9kZS5kb20gPT09IGFjdGl2ZUVsZW1lbnQoKSB8fCB2bm9kZS50YWcgPT09IFwib3B0aW9uXCIgJiYgdm5vZGUuZG9tLnBhcmVudE5vZGUgPT09ICRkb2MuYWN0aXZlRWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGlzTGlmZWN5Y2xlTWV0aG9kKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJvbmluaXRcIiB8fCBhdHRyID09PSBcIm9uY3JlYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnVwZGF0ZVwiIHx8IGF0dHIgPT09IFwib25yZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JlcmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXVwZGF0ZVwiXG5cdH1cblx0ZnVuY3Rpb24gaGFzUHJvcGVydHlLZXkodm5vZGUsIGtleSwgbnMpIHtcblx0XHQvLyBGaWx0ZXIgb3V0IG5hbWVzcGFjZWQga2V5c1xuXHRcdHJldHVybiBucyA9PT0gdW5kZWZpbmVkICYmIChcblx0XHRcdC8vIElmIGl0J3MgYSBjdXN0b20gZWxlbWVudCwganVzdCBrZWVwIGl0LlxuXHRcdFx0dm5vZGUudGFnLmluZGV4T2YoXCItXCIpID4gLTEgfHwgdm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5pcyB8fFxuXHRcdFx0Ly8gSWYgaXQncyBhIG5vcm1hbCBlbGVtZW50LCBsZXQncyB0cnkgdG8gYXZvaWQgYSBmZXcgYnJvd3NlciBidWdzLlxuXHRcdFx0a2V5ICE9PSBcImhyZWZcIiAmJiBrZXkgIT09IFwibGlzdFwiICYmIGtleSAhPT0gXCJmb3JtXCIgJiYga2V5ICE9PSBcIndpZHRoXCIgJiYga2V5ICE9PSBcImhlaWdodFwiLy8gJiYga2V5ICE9PSBcInR5cGVcIlxuXHRcdFx0Ly8gRGVmZXIgdGhlIHByb3BlcnR5IGNoZWNrIHVudGlsICphZnRlciogd2UgY2hlY2sgZXZlcnl0aGluZy5cblx0XHQpICYmIGtleSBpbiB2bm9kZS5kb21cblx0fVxuXG5cdC8vc3R5bGVcblx0dmFyIHVwcGVyY2FzZVJlZ2V4ID0gL1tBLVpdL2dcblx0ZnVuY3Rpb24gdG9Mb3dlckNhc2UoY2FwaXRhbCkgeyByZXR1cm4gXCItXCIgKyBjYXBpdGFsLnRvTG93ZXJDYXNlKCkgfVxuXHRmdW5jdGlvbiBub3JtYWxpemVLZXkoa2V5KSB7XG5cdFx0cmV0dXJuIGtleVswXSA9PT0gXCItXCIgJiYga2V5WzFdID09PSBcIi1cIiA/IGtleSA6XG5cdFx0XHRrZXkgPT09IFwiY3NzRmxvYXRcIiA/IFwiZmxvYXRcIiA6XG5cdFx0XHRcdGtleS5yZXBsYWNlKHVwcGVyY2FzZVJlZ2V4LCB0b0xvd2VyQ2FzZSlcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHN0eWxlKSB7XG5cdFx0aWYgKG9sZCA9PT0gc3R5bGUpIHtcblx0XHRcdC8vIFN0eWxlcyBhcmUgZXF1aXZhbGVudCwgZG8gbm90aGluZy5cblx0XHR9IGVsc2UgaWYgKHN0eWxlID09IG51bGwpIHtcblx0XHRcdC8vIE5ldyBzdHlsZSBpcyBtaXNzaW5nLCBqdXN0IGNsZWFyIGl0LlxuXHRcdFx0ZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHN0eWxlICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHQvLyBOZXcgc3R5bGUgaXMgYSBzdHJpbmcsIGxldCBlbmdpbmUgZGVhbCB3aXRoIHBhdGNoaW5nLlxuXHRcdFx0ZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVcblx0XHR9IGVsc2UgaWYgKG9sZCA9PSBudWxsIHx8IHR5cGVvZiBvbGQgIT09IFwib2JqZWN0XCIpIHtcblx0XHRcdC8vIGBvbGRgIGlzIG1pc3Npbmcgb3IgYSBzdHJpbmcsIGBzdHlsZWAgaXMgYW4gb2JqZWN0LlxuXHRcdFx0ZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdFx0Ly8gQWRkIG5ldyBzdHlsZSBwcm9wZXJ0aWVzXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gc3R5bGUpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gc3R5bGVba2V5XVxuXHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbCkgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShub3JtYWxpemVLZXkoa2V5KSwgU3RyaW5nKHZhbHVlKSlcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQm90aCBvbGQgJiBuZXcgYXJlIChkaWZmZXJlbnQpIG9iamVjdHMuXG5cdFx0XHQvLyBVcGRhdGUgc3R5bGUgcHJvcGVydGllcyB0aGF0IGhhdmUgY2hhbmdlZFxuXHRcdFx0Zm9yICh2YXIga2V5IGluIHN0eWxlKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHN0eWxlW2tleV1cblx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlID0gU3RyaW5nKHZhbHVlKSkgIT09IFN0cmluZyhvbGRba2V5XSkpIHtcblx0XHRcdFx0XHRlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KG5vcm1hbGl6ZUtleShrZXkpLCB2YWx1ZSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gUmVtb3ZlIHN0eWxlIHByb3BlcnRpZXMgdGhhdCBubyBsb25nZXIgZXhpc3Rcblx0XHRcdGZvciAodmFyIGtleSBpbiBvbGQpIHtcblx0XHRcdFx0aWYgKG9sZFtrZXldICE9IG51bGwgJiYgc3R5bGVba2V5XSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShub3JtYWxpemVLZXkoa2V5KSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEhlcmUncyBhbiBleHBsYW5hdGlvbiBvZiBob3cgdGhpcyB3b3Jrczpcblx0Ly8gMS4gVGhlIGV2ZW50IG5hbWVzIGFyZSBhbHdheXMgKGJ5IGRlc2lnbikgcHJlZml4ZWQgYnkgYG9uYC5cblx0Ly8gMi4gVGhlIEV2ZW50TGlzdGVuZXIgaW50ZXJmYWNlIGFjY2VwdHMgZWl0aGVyIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0XG5cdC8vICAgIHdpdGggYSBgaGFuZGxlRXZlbnRgIG1ldGhvZC5cblx0Ly8gMy4gVGhlIG9iamVjdCBkb2VzIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLCB0byBhdm9pZFxuXHQvLyAgICBhbnkgcG90ZW50aWFsIGludGVyZmVyZW5jZSB3aXRoIHRoYXQgKGUuZy4gc2V0dGVycykuXG5cdC8vIDQuIFRoZSBldmVudCBuYW1lIGlzIHJlbWFwcGVkIHRvIHRoZSBoYW5kbGVyIGJlZm9yZSBjYWxsaW5nIGl0LlxuXHQvLyA1LiBJbiBmdW5jdGlvbi1iYXNlZCBldmVudCBoYW5kbGVycywgYGV2LnRhcmdldCA9PT0gdGhpc2AuIFdlIHJlcGxpY2F0ZVxuXHQvLyAgICB0aGF0IGJlbG93LlxuXHQvLyA2LiBJbiBmdW5jdGlvbi1iYXNlZCBldmVudCBoYW5kbGVycywgYHJldHVybiBmYWxzZWAgcHJldmVudHMgdGhlIGRlZmF1bHRcblx0Ly8gICAgYWN0aW9uIGFuZCBzdG9wcyBldmVudCBwcm9wYWdhdGlvbi4gV2UgcmVwbGljYXRlIHRoYXQgYmVsb3cuXG5cdGZ1bmN0aW9uIEV2ZW50RGljdCgpIHt9XG5cdEV2ZW50RGljdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cdEV2ZW50RGljdC5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXYpIHtcblx0XHR2YXIgaGFuZGxlciA9IHRoaXNbXCJvblwiICsgZXYudHlwZV1cblx0XHR2YXIgcmVzdWx0XG5cdFx0aWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHJlc3VsdCA9IGhhbmRsZXIuY2FsbChldi5jdXJyZW50VGFyZ2V0LCBldilcblx0XHRlbHNlIGlmICh0eXBlb2YgaGFuZGxlci5oYW5kbGVFdmVudCA9PT0gXCJmdW5jdGlvblwiKSBoYW5kbGVyLmhhbmRsZUV2ZW50KGV2KVxuXHRcdGlmIChldi5yZWRyYXcgPT09IGZhbHNlKSBldi5yZWRyYXcgPSB1bmRlZmluZWRcblx0XHRlbHNlIGlmICh0eXBlb2YgcmVkcmF3ID09PSBcImZ1bmN0aW9uXCIpIHJlZHJhdygpXG5cdFx0aWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcblx0XHRcdGV2LnByZXZlbnREZWZhdWx0KClcblx0XHRcdGV2LnN0b3BQcm9wYWdhdGlvbigpXG5cdFx0fVxuXHR9XG5cblx0Ly9ldmVudFxuXHRmdW5jdGlvbiB1cGRhdGVFdmVudCh2bm9kZSwga2V5LCB2YWx1ZSkge1xuXHRcdGlmICh2bm9kZS5ldmVudHMgIT0gbnVsbCkge1xuXHRcdFx0aWYgKHZub2RlLmV2ZW50c1trZXldID09PSB2YWx1ZSkgcmV0dXJuXG5cdFx0XHRpZiAodmFsdWUgIT0gbnVsbCAmJiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSkge1xuXHRcdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleV0gPT0gbnVsbCkgdm5vZGUuZG9tLmFkZEV2ZW50TGlzdGVuZXIoa2V5LnNsaWNlKDIpLCB2bm9kZS5ldmVudHMsIGZhbHNlKVxuXHRcdFx0XHR2bm9kZS5ldmVudHNba2V5XSA9IHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleV0gIT0gbnVsbCkgdm5vZGUuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5LnNsaWNlKDIpLCB2bm9kZS5ldmVudHMsIGZhbHNlKVxuXHRcdFx0XHR2bm9kZS5ldmVudHNba2V5XSA9IHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSkge1xuXHRcdFx0dm5vZGUuZXZlbnRzID0gbmV3IEV2ZW50RGljdCgpXG5cdFx0XHR2bm9kZS5kb20uYWRkRXZlbnRMaXN0ZW5lcihrZXkuc2xpY2UoMiksIHZub2RlLmV2ZW50cywgZmFsc2UpXG5cdFx0XHR2bm9kZS5ldmVudHNba2V5XSA9IHZhbHVlXG5cdFx0fVxuXHR9XG5cblx0Ly9saWZlY3ljbGVcblx0ZnVuY3Rpb24gaW5pdExpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uaW5pdCA9PT0gXCJmdW5jdGlvblwiKSBjYWxsSG9vay5jYWxsKHNvdXJjZS5vbmluaXQsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goY2FsbEhvb2suYmluZChzb3VyY2Uub25jcmVhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKGNhbGxIb29rLmJpbmQoc291cmNlLm9udXBkYXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpIHtcblx0XHRkbyB7XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR2YXIgZm9yY2UgPSBjYWxsSG9vay5jYWxsKHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlLCB2bm9kZSwgb2xkKVxuXHRcdFx0XHRpZiAoZm9yY2UgIT09IHVuZGVmaW5lZCAmJiAhZm9yY2UpIGJyZWFrXG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuc3RhdGUub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR2YXIgZm9yY2UgPSBjYWxsSG9vay5jYWxsKHZub2RlLnN0YXRlLm9uYmVmb3JldXBkYXRlLCB2bm9kZSwgb2xkKVxuXHRcdFx0XHRpZiAoZm9yY2UgIT09IHVuZGVmaW5lZCAmJiAhZm9yY2UpIGJyZWFrXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHR9IHdoaWxlIChmYWxzZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG5cdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdHZub2RlLmluc3RhbmNlID0gb2xkLmluc3RhbmNlXG5cdFx0Ly8gT25lIHdvdWxkIHRoaW5rIGhhdmluZyB0aGUgYWN0dWFsIGxhdGVzdCBhdHRyaWJ1dGVzIHdvdWxkIGJlIGlkZWFsLFxuXHRcdC8vIGJ1dCBpdCBkb2Vzbid0IGxldCB1cyBwcm9wZXJseSBkaWZmIGJhc2VkIG9uIG91ciBjdXJyZW50IGludGVybmFsXG5cdFx0Ly8gcmVwcmVzZW50YXRpb24uIFdlIGhhdmUgdG8gc2F2ZSBub3Qgb25seSB0aGUgb2xkIERPTSBpbmZvLCBidXQgYWxzb1xuXHRcdC8vIHRoZSBhdHRyaWJ1dGVzIHVzZWQgdG8gY3JlYXRlIGl0LCBhcyB3ZSBkaWZmICp0aGF0Kiwgbm90IGFnYWluc3QgdGhlXG5cdFx0Ly8gRE9NIGRpcmVjdGx5ICh3aXRoIGEgZmV3IGV4Y2VwdGlvbnMgaW4gYHNldEF0dHJgKS4gQW5kLCBvZiBjb3Vyc2UsIHdlXG5cdFx0Ly8gbmVlZCB0byBzYXZlIHRoZSBjaGlsZHJlbiBhbmQgdGV4dCBhcyB0aGV5IGFyZSBjb25jZXB0dWFsbHkgbm90XG5cdFx0Ly8gdW5saWtlIHNwZWNpYWwgXCJhdHRyaWJ1dGVzXCIgaW50ZXJuYWxseS5cblx0XHR2bm9kZS5hdHRycyA9IG9sZC5hdHRyc1xuXHRcdHZub2RlLmNoaWxkcmVuID0gb2xkLmNoaWxkcmVuXG5cdFx0dm5vZGUudGV4dCA9IG9sZC50ZXh0XG5cdFx0cmV0dXJuIHRydWVcblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlcihkb20sIHZub2Rlcykge1xuXHRcdGlmICghZG9tKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIilcblx0XHR2YXIgaG9va3MgPSBbXVxuXHRcdHZhciBhY3RpdmUgPSBhY3RpdmVFbGVtZW50KClcblx0XHR2YXIgbmFtZXNwYWNlID0gZG9tLm5hbWVzcGFjZVVSSVxuXG5cdFx0Ly8gRmlyc3QgdGltZSByZW5kZXJpbmcgaW50byBhIG5vZGUgY2xlYXJzIGl0IG91dFxuXHRcdGlmIChkb20udm5vZGVzID09IG51bGwpIGRvbS50ZXh0Q29udGVudCA9IFwiXCJcblxuXHRcdHZub2RlcyA9IFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKEFycmF5LmlzQXJyYXkodm5vZGVzKSA/IHZub2RlcyA6IFt2bm9kZXNdKVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2Rlcywgdm5vZGVzLCBob29rcywgbnVsbCwgbmFtZXNwYWNlID09PSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZSlcblx0XHRkb20udm5vZGVzID0gdm5vZGVzXG5cdFx0Ly8gYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGNhbiByZXR1cm4gbnVsbDogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNkb20tZG9jdW1lbnQtYWN0aXZlZWxlbWVudFxuXHRcdGlmIChhY3RpdmUgIT0gbnVsbCAmJiBhY3RpdmVFbGVtZW50KCkgIT09IGFjdGl2ZSAmJiB0eXBlb2YgYWN0aXZlLmZvY3VzID09PSBcImZ1bmN0aW9uXCIpIGFjdGl2ZS5mb2N1cygpXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykgaG9va3NbaV0oKVxuXHR9XG5cblx0cmV0dXJuIHtyZW5kZXI6IHJlbmRlciwgc2V0UmVkcmF3OiBzZXRSZWRyYXd9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgVm5vZGUgPSByZXF1aXJlKFwiLi4vcmVuZGVyL3Zub2RlXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaHRtbCkge1xuXHRpZiAoaHRtbCA9PSBudWxsKSBodG1sID0gXCJcIlxuXHRyZXR1cm4gVm5vZGUoXCI8XCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBodG1sLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIFZub2RlKHRhZywga2V5LCBhdHRycywgY2hpbGRyZW4sIHRleHQsIGRvbSkge1xuXHRyZXR1cm4ge3RhZzogdGFnLCBrZXk6IGtleSwgYXR0cnM6IGF0dHJzLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIGV2ZW50czogdW5kZWZpbmVkLCBpbnN0YW5jZTogdW5kZWZpbmVkfVxufVxuVm5vZGUubm9ybWFsaXplID0gZnVuY3Rpb24obm9kZSkge1xuXHRpZiAoQXJyYXkuaXNBcnJheShub2RlKSkgcmV0dXJuIFZub2RlKFwiW1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4obm9kZSksIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRpZiAobm9kZSA9PSBudWxsIHx8IHR5cGVvZiBub2RlID09PSBcImJvb2xlYW5cIikgcmV0dXJuIG51bGxcblx0aWYgKHR5cGVvZiBub2RlID09PSBcIm9iamVjdFwiKSByZXR1cm4gbm9kZVxuXHRyZXR1cm4gVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcobm9kZSksIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbihpbnB1dCkge1xuXHR2YXIgY2hpbGRyZW4gPSBbXVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoaW5wdXRbaV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gVm5vZGVcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBQcm9taXNlUG9seWZpbGwgPSByZXF1aXJlKFwiLi9wcm9taXNlL3Byb21pc2VcIilcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcmVxdWVzdC9yZXF1ZXN0XCIpKHdpbmRvdywgUHJvbWlzZVBvbHlmaWxsKVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGJ1aWxkUGF0aG5hbWUgPSByZXF1aXJlKFwiLi4vcGF0aG5hbWUvYnVpbGRcIilcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cblx0ZnVuY3Rpb24gUHJvbWlzZVByb3h5KGV4ZWN1dG9yKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKGV4ZWN1dG9yKVxuXHR9XG5cblx0Ly8gSW4gY2FzZSB0aGUgZ2xvYmFsIFByb21pc2UgaXMgc29tZSB1c2VybGFuZCBsaWJyYXJ5J3Mgd2hlcmUgdGhleSByZWx5IG9uXG5cdC8vIGBmb28gaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yYCwgYHRoaXMuY29uc3RydWN0b3IucmVzb2x2ZSh2YWx1ZSlgLCBvclxuXHQvLyBzaW1pbGFyLiBMZXQncyAqbm90KiBicmVhayB0aGVtLlxuXHRQcm9taXNlUHJveHkucHJvdG90eXBlID0gUHJvbWlzZS5wcm90b3R5cGVcblx0UHJvbWlzZVByb3h5Ll9fcHJvdG9fXyA9IFByb21pc2UgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG5cdGZ1bmN0aW9uIG1ha2VSZXF1ZXN0KGZhY3RvcnkpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odXJsLCBhcmdzKSB7XG5cdFx0XHRpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIikgeyBhcmdzID0gdXJsOyB1cmwgPSB1cmwudXJsIH1cblx0XHRcdGVsc2UgaWYgKGFyZ3MgPT0gbnVsbCkgYXJncyA9IHt9XG5cdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0XHRmYWN0b3J5KGJ1aWxkUGF0aG5hbWUodXJsLCBhcmdzLnBhcmFtcyksIGFyZ3MsIGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBhcmdzLnR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVtpXSA9IG5ldyBhcmdzLnR5cGUoZGF0YVtpXSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBkYXRhID0gbmV3IGFyZ3MudHlwZShkYXRhKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXNvbHZlKGRhdGEpXG5cdFx0XHRcdH0sIHJlamVjdClcblx0XHRcdH0pXG5cdFx0XHRpZiAoYXJncy5iYWNrZ3JvdW5kID09PSB0cnVlKSByZXR1cm4gcHJvbWlzZVxuXHRcdFx0dmFyIGNvdW50ID0gMFxuXHRcdFx0ZnVuY3Rpb24gY29tcGxldGUoKSB7XG5cdFx0XHRcdGlmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKClcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHdyYXAocHJvbWlzZSlcblxuXHRcdFx0ZnVuY3Rpb24gd3JhcChwcm9taXNlKSB7XG5cdFx0XHRcdHZhciB0aGVuID0gcHJvbWlzZS50aGVuXG5cdFx0XHRcdC8vIFNldCB0aGUgY29uc3RydWN0b3IsIHNvIGVuZ2luZXMga25vdyB0byBub3QgYXdhaXQgb3IgcmVzb2x2ZVxuXHRcdFx0XHQvLyB0aGlzIGFzIGEgbmF0aXZlIHByb21pc2UuIEF0IHRoZSB0aW1lIG9mIHdyaXRpbmcsIHRoaXMgaXNcblx0XHRcdFx0Ly8gb25seSBuZWNlc3NhcnkgZm9yIFY4LCBidXQgdGhlaXIgYmVoYXZpb3IgaXMgdGhlIGNvcnJlY3Rcblx0XHRcdFx0Ly8gYmVoYXZpb3IgcGVyIHNwZWMuIFNlZSB0aGlzIHNwZWMgaXNzdWUgZm9yIG1vcmUgZGV0YWlsczpcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvZWNtYTI2Mi9pc3N1ZXMvMTU3Ny4gQWxzbywgc2VlIHRoZVxuXHRcdFx0XHQvLyBjb3JyZXNwb25kaW5nIGNvbW1lbnQgaW4gYHJlcXVlc3QvdGVzdHMvdGVzdC1yZXF1ZXN0LmpzYCBmb3Jcblx0XHRcdFx0Ly8gYSBiaXQgbW9yZSBiYWNrZ3JvdW5kIG9uIHRoZSBpc3N1ZSBhdCBoYW5kLlxuXHRcdFx0XHRwcm9taXNlLmNvbnN0cnVjdG9yID0gUHJvbWlzZVByb3h5XG5cdFx0XHRcdHByb21pc2UudGhlbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YXIgbmV4dCA9IHRoZW4uYXBwbHkocHJvbWlzZSwgYXJndW1lbnRzKVxuXHRcdFx0XHRcdG5leHQudGhlbihjb21wbGV0ZSwgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdFx0Y29tcGxldGUoKVxuXHRcdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRyZXR1cm4gd3JhcChuZXh0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwcm9taXNlXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaGFzSGVhZGVyKGFyZ3MsIG5hbWUpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gYXJncy5oZWFkZXJzKSB7XG5cdFx0XHRpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcmdzLmhlYWRlcnMsIGtleSkgJiYgbmFtZS50ZXN0KGtleSkpIHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRyZXF1ZXN0OiBtYWtlUmVxdWVzdChmdW5jdGlvbih1cmwsIGFyZ3MsIHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0dmFyIG1ldGhvZCA9IGFyZ3MubWV0aG9kICE9IG51bGwgPyBhcmdzLm1ldGhvZC50b1VwcGVyQ2FzZSgpIDogXCJHRVRcIlxuXHRcdFx0dmFyIGJvZHkgPSBhcmdzLmJvZHlcblx0XHRcdHZhciBhc3N1bWVKU09OID0gKGFyZ3Muc2VyaWFsaXplID09IG51bGwgfHwgYXJncy5zZXJpYWxpemUgPT09IEpTT04uc2VyaWFsaXplKSAmJiAhKGJvZHkgaW5zdGFuY2VvZiAkd2luZG93LkZvcm1EYXRhKVxuXHRcdFx0dmFyIHJlc3BvbnNlVHlwZSA9IGFyZ3MucmVzcG9uc2VUeXBlIHx8ICh0eXBlb2YgYXJncy5leHRyYWN0ID09PSBcImZ1bmN0aW9uXCIgPyBcIlwiIDogXCJqc29uXCIpXG5cblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLCBhYm9ydGVkID0gZmFsc2Vcblx0XHRcdHZhciBvcmlnaW5hbCA9IHhociwgcmVwbGFjZWRBYm9ydFxuXHRcdFx0dmFyIGFib3J0ID0geGhyLmFib3J0XG5cblx0XHRcdHhoci5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRhYm9ydGVkID0gdHJ1ZVxuXHRcdFx0XHRhYm9ydC5jYWxsKHRoaXMpXG5cdFx0XHR9XG5cblx0XHRcdHhoci5vcGVuKG1ldGhvZCwgdXJsLCBhcmdzLmFzeW5jICE9PSBmYWxzZSwgdHlwZW9mIGFyZ3MudXNlciA9PT0gXCJzdHJpbmdcIiA/IGFyZ3MudXNlciA6IHVuZGVmaW5lZCwgdHlwZW9mIGFyZ3MucGFzc3dvcmQgPT09IFwic3RyaW5nXCIgPyBhcmdzLnBhc3N3b3JkIDogdW5kZWZpbmVkKVxuXG5cdFx0XHRpZiAoYXNzdW1lSlNPTiAmJiBib2R5ICE9IG51bGwgJiYgIWhhc0hlYWRlcihhcmdzLCAvXmNvbnRlbnQtdHlwZSQvaSkpIHtcblx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpXG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIGFyZ3MuZGVzZXJpYWxpemUgIT09IFwiZnVuY3Rpb25cIiAmJiAhaGFzSGVhZGVyKGFyZ3MsIC9eYWNjZXB0JC9pKSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGlmIChhcmdzLnRpbWVvdXQpIHhoci50aW1lb3V0ID0gYXJncy50aW1lb3V0XG5cdFx0XHR4aHIucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlXG5cblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIHtcblx0XHRcdFx0aWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXJncy5oZWFkZXJzLCBrZXkpKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBhcmdzLmhlYWRlcnNba2V5XSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0Ly8gRG9uJ3QgdGhyb3cgZXJyb3JzIG9uIHhoci5hYm9ydCgpLlxuXHRcdFx0XHRpZiAoYWJvcnRlZCkgcmV0dXJuXG5cblx0XHRcdFx0aWYgKGV2LnRhcmdldC5yZWFkeVN0YXRlID09PSA0KSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHZhciBzdWNjZXNzID0gKGV2LnRhcmdldC5zdGF0dXMgPj0gMjAwICYmIGV2LnRhcmdldC5zdGF0dXMgPCAzMDApIHx8IGV2LnRhcmdldC5zdGF0dXMgPT09IDMwNCB8fCAoL15maWxlOlxcL1xcLy9pKS50ZXN0KHVybClcblx0XHRcdFx0XHRcdC8vIFdoZW4gdGhlIHJlc3BvbnNlIHR5cGUgaXNuJ3QgXCJcIiBvciBcInRleHRcIixcblx0XHRcdFx0XHRcdC8vIGB4aHIucmVzcG9uc2VUZXh0YCBpcyB0aGUgd3JvbmcgdGhpbmcgdG8gdXNlLlxuXHRcdFx0XHRcdFx0Ly8gQnJvd3NlcnMgZG8gdGhlIHJpZ2h0IHRoaW5nIGFuZCB0aHJvdyBoZXJlLCBhbmQgd2Vcblx0XHRcdFx0XHRcdC8vIHNob3VsZCBob25vciB0aGF0IGFuZCBkbyB0aGUgcmlnaHQgdGhpbmcgYnlcblx0XHRcdFx0XHRcdC8vIHByZWZlcnJpbmcgYHhoci5yZXNwb25zZWAgd2hlcmUgcG9zc2libGUvcHJhY3RpY2FsLlxuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gZXYudGFyZ2V0LnJlc3BvbnNlLCBtZXNzYWdlXG5cblx0XHRcdFx0XHRcdGlmIChyZXNwb25zZVR5cGUgPT09IFwianNvblwiKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEZvciBJRSBhbmQgRWRnZSwgd2hpY2ggZG9uJ3QgaW1wbGVtZW50XG5cdFx0XHRcdFx0XHRcdC8vIGByZXNwb25zZVR5cGU6IFwianNvblwiYC5cblx0XHRcdFx0XHRcdFx0aWYgKCFldi50YXJnZXQucmVzcG9uc2VUeXBlICYmIHR5cGVvZiBhcmdzLmV4dHJhY3QgIT09IFwiZnVuY3Rpb25cIikgcmVzcG9uc2UgPSBKU09OLnBhcnNlKGV2LnRhcmdldC5yZXNwb25zZVRleHQpXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSBcInRleHRcIikge1xuXHRcdFx0XHRcdFx0XHQvLyBPbmx5IHVzZSB0aGlzIGRlZmF1bHQgaWYgaXQncyB0ZXh0LiBJZiBhIHBhcnNlZFxuXHRcdFx0XHRcdFx0XHQvLyBkb2N1bWVudCBpcyBuZWVkZWQgb24gb2xkIElFIGFuZCBmcmllbmRzIChhbGxcblx0XHRcdFx0XHRcdFx0Ly8gdW5zdXBwb3J0ZWQpLCB0aGUgdXNlciBzaG91bGQgdXNlIGEgY3VzdG9tXG5cdFx0XHRcdFx0XHRcdC8vIGBjb25maWdgIGluc3RlYWQuIFRoZXkncmUgYWxyZWFkeSB1c2luZyB0aGlzIGF0XG5cdFx0XHRcdFx0XHRcdC8vIHRoZWlyIG93biByaXNrLlxuXHRcdFx0XHRcdFx0XHRpZiAocmVzcG9uc2UgPT0gbnVsbCkgcmVzcG9uc2UgPSBldi50YXJnZXQucmVzcG9uc2VUZXh0XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBhcmdzLmV4dHJhY3QoZXYudGFyZ2V0LCBhcmdzKVxuXHRcdFx0XHRcdFx0XHRzdWNjZXNzID0gdHJ1ZVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gYXJncy5kZXNlcmlhbGl6ZShyZXNwb25zZSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChzdWNjZXNzKSByZXNvbHZlKHJlc3BvbnNlKVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRyeSB7IG1lc3NhZ2UgPSBldi50YXJnZXQucmVzcG9uc2VUZXh0IH1cblx0XHRcdFx0XHRcdFx0Y2F0Y2ggKGUpIHsgbWVzc2FnZSA9IHJlc3BvbnNlIH1cblx0XHRcdFx0XHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpXG5cdFx0XHRcdFx0XHRcdGVycm9yLmNvZGUgPSBldi50YXJnZXQuc3RhdHVzXG5cdFx0XHRcdFx0XHRcdGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2Vcblx0XHRcdFx0XHRcdFx0cmVqZWN0KGVycm9yKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0cmVqZWN0KGUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgYXJncy5jb25maWcgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MsIHVybCkgfHwgeGhyXG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIHRoZSBgYWJvcnRgIHRvIGFueSByZXBsYWNlbWVudCBYSFIgYXMgd2VsbC5cblx0XHRcdFx0aWYgKHhociAhPT0gb3JpZ2luYWwpIHtcblx0XHRcdFx0XHRyZXBsYWNlZEFib3J0ID0geGhyLmFib3J0XG5cdFx0XHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRhYm9ydGVkID0gdHJ1ZVxuXHRcdFx0XHRcdFx0cmVwbGFjZWRBYm9ydC5jYWxsKHRoaXMpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChib2R5ID09IG51bGwpIHhoci5zZW5kKClcblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBhcmdzLnNlcmlhbGl6ZSA9PT0gXCJmdW5jdGlvblwiKSB4aHIuc2VuZChhcmdzLnNlcmlhbGl6ZShib2R5KSlcblx0XHRcdGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiAkd2luZG93LkZvcm1EYXRhKSB4aHIuc2VuZChib2R5KVxuXHRcdFx0ZWxzZSB4aHIuc2VuZChKU09OLnN0cmluZ2lmeShib2R5KSlcblx0XHR9KSxcblx0XHRqc29ucDogbWFrZVJlcXVlc3QoZnVuY3Rpb24odXJsLCBhcmdzLCByZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdHZhciBjYWxsYmFja05hbWUgPSBhcmdzLmNhbGxiYWNrTmFtZSB8fCBcIl9taXRocmlsX1wiICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMWUxNikgKyBcIl9cIiArIGNhbGxiYWNrQ291bnQrK1xuXHRcdFx0dmFyIHNjcmlwdCA9ICR3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKVxuXHRcdFx0JHdpbmRvd1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRkZWxldGUgJHdpbmRvd1tjYWxsYmFja05hbWVdXG5cdFx0XHRcdHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdClcblx0XHRcdFx0cmVzb2x2ZShkYXRhKVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpXG5cdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoXCJKU09OUCByZXF1ZXN0IGZhaWxlZFwiKSlcblx0XHRcdH1cblx0XHRcdHNjcmlwdC5zcmMgPSB1cmwgKyAodXJsLmluZGV4T2YoXCI/XCIpIDwgMCA/IFwiP1wiIDogXCImXCIpICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3MuY2FsbGJhY2tLZXkgfHwgXCJjYWxsYmFja1wiKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KGNhbGxiYWNrTmFtZSlcblx0XHRcdCR3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdClcblx0XHR9KSxcblx0XHRzZXRDb21wbGV0aW9uQ2FsbGJhY2s6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRvbmNvbXBsZXRpb24gPSBjYWxsYmFja1xuXHRcdH0sXG5cdH1cbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciByZWRyYXdTZXJ2aWNlID0gcmVxdWlyZShcIi4vcmVkcmF3XCIpXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vYXBpL3JvdXRlclwiKSh3aW5kb3csIHJlZHJhd1NlcnZpY2UpXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgYnVpbGRQYXRobmFtZSA9IHJlcXVpcmUoXCIuLi9wYXRobmFtZS9idWlsZFwiKVxudmFyIHBhcnNlUGF0aG5hbWUgPSByZXF1aXJlKFwiLi4vcGF0aG5hbWUvcGFyc2VcIilcbnZhciBjb21waWxlVGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vcGF0aG5hbWUvY29tcGlsZVRlbXBsYXRlXCIpXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4uL3BhdGhuYW1lL2Fzc2lnblwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIGNhbGxBc3luYyA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IHNldFRpbWVvdXRcblx0dmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gdHlwZW9mICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPT09IFwiZnVuY3Rpb25cIlxuXHR2YXIgZmlyZUFzeW5jXG5cblx0cmV0dXJuIHtcblx0XHRwcmVmaXg6IFwiIyFcIixcblxuXHRcdGdldFBhdGg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gQ29uc2lkZXIgdGhlIHBhdGhuYW1lIGhvbGlzdGljYWxseS4gVGhlIHByZWZpeCBtaWdodCBldmVuIGJlIGludmFsaWQsXG5cdFx0XHQvLyBidXQgdGhhdCdzIG5vdCBvdXIgcHJvYmxlbS5cblx0XHRcdHZhciBwcmVmaXggPSAkd2luZG93LmxvY2F0aW9uLmhhc2hcblx0XHRcdGlmICh0aGlzLnByZWZpeFswXSAhPT0gXCIjXCIpIHtcblx0XHRcdFx0cHJlZml4ID0gJHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyBwcmVmaXhcblx0XHRcdFx0aWYgKHRoaXMucHJlZml4WzBdICE9PSBcIj9cIikge1xuXHRcdFx0XHRcdHByZWZpeCA9ICR3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyBwcmVmaXhcblx0XHRcdFx0XHRpZiAocHJlZml4WzBdICE9PSBcIi9cIikgcHJlZml4ID0gXCIvXCIgKyBwcmVmaXhcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gVGhpcyBzZWVtaW5nbHkgdXNlbGVzcyBgLmNvbmNhdCgpYCBzcGVlZHMgdXAgdGhlIHRlc3RzIHF1aXRlIGEgYml0LFxuXHRcdFx0Ly8gc2luY2UgdGhlIHJlcHJlc2VudGF0aW9uIGlzIGNvbnNpc3RlbnRseSBhIHJlbGF0aXZlbHkgcG9vcmx5XG5cdFx0XHQvLyBvcHRpbWl6ZWQgY29ucyBzdHJpbmcuXG5cdFx0XHRyZXR1cm4gcHJlZml4LmNvbmNhdCgpXG5cdFx0XHRcdC5yZXBsYWNlKC8oPzolW2EtZjg5XVthLWYwLTldKSsvZ2ltLCBkZWNvZGVVUklDb21wb25lbnQpXG5cdFx0XHRcdC5zbGljZSh0aGlzLnByZWZpeC5sZW5ndGgpXG5cdFx0fSxcblxuXHRcdHNldFBhdGg6IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHRcdHBhdGggPSBidWlsZFBhdGhuYW1lKHBhdGgsIGRhdGEpXG5cdFx0XHRpZiAoZmlyZUFzeW5jICE9IG51bGwpIHtcblx0XHRcdFx0ZmlyZUFzeW5jKClcblx0XHRcdFx0dmFyIHN0YXRlID0gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdGUgOiBudWxsXG5cdFx0XHRcdHZhciB0aXRsZSA9IG9wdGlvbnMgPyBvcHRpb25zLnRpdGxlIDogbnVsbFxuXHRcdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpICR3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCB0aGlzLnByZWZpeCArIHBhdGgpXG5cdFx0XHRcdGVsc2UgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHRoaXMucHJlZml4ICsgcGF0aClcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQkd2luZG93LmxvY2F0aW9uLmhyZWYgPSB0aGlzLnByZWZpeCArIHBhdGhcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZGVmaW5lUm91dGVzOiBmdW5jdGlvbihyb3V0ZXMsIHJlc29sdmUsIHJlamVjdCwgZGVmYXVsdFJvdXRlLCBzdWJzY3JpYmUpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpc1xuXHRcdFx0dmFyIGNvbXBpbGVkID0gT2JqZWN0LmtleXMocm91dGVzKS5tYXAoZnVuY3Rpb24ocm91dGUpIHtcblx0XHRcdFx0aWYgKHJvdXRlWzBdICE9PSBcIi9cIikgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiUm91dGVzIG11c3Qgc3RhcnQgd2l0aCBhIGAvYFwiKVxuXHRcdFx0XHRpZiAoKC86KFteXFwvXFwuLV0rKShcXC57M30pPzovKS50ZXN0KHJvdXRlKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBTeW50YXhFcnJvcihcIlJvdXRlIHBhcmFtZXRlciBuYW1lcyBtdXN0IGJlIHNlcGFyYXRlZCB3aXRoIGVpdGhlciBgL2AsIGAuYCwgb3IgYC1gXCIpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRyb3V0ZTogcm91dGUsXG5cdFx0XHRcdFx0Y29tcG9uZW50OiByb3V0ZXNbcm91dGVdLFxuXHRcdFx0XHRcdGNoZWNrOiBjb21waWxlVGVtcGxhdGUocm91dGUpLFxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdFx0dmFyIHVuc3Vic2NyaWJlLCBhc3luY0lkXG5cblx0XHRcdGZpcmVBc3luYyA9IG51bGxcblxuXHRcdFx0aWYgKGRlZmF1bHRSb3V0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBkZWZhdWx0RGF0YSA9IHBhcnNlUGF0aG5hbWUoZGVmYXVsdFJvdXRlKVxuXG5cdFx0XHRcdGlmICghY29tcGlsZWQuc29tZShmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5jaGVjayhkZWZhdWx0RGF0YSkgfSkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJEZWZhdWx0IHJvdXRlIGRvZXNuJ3QgbWF0Y2ggYW55IGtub3duIHJvdXRlc1wiKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHJlc29sdmVSb3V0ZSgpIHtcblx0XHRcdFx0dmFyIHBhdGggPSBzZWxmLmdldFBhdGgoKVxuXHRcdFx0XHR2YXIgZGF0YSA9IHBhcnNlUGF0aG5hbWUocGF0aClcblxuXHRcdFx0XHRhc3NpZ24oZGF0YS5wYXJhbXMsICR3aW5kb3cuaGlzdG9yeS5zdGF0ZSlcblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBpbGVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGNvbXBpbGVkW2ldLmNoZWNrKGRhdGEpKSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKGNvbXBpbGVkW2ldLmNvbXBvbmVudCwgZGF0YS5wYXJhbXMsIHBhdGgsIGNvbXBpbGVkW2ldLnJvdXRlKVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVqZWN0KHBhdGgsIGRhdGEucGFyYW1zKVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcblx0XHRcdFx0dW5zdWJzY3JpYmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBmaXJlQXN5bmMsIGZhbHNlKVxuXHRcdFx0XHR9XG5cdFx0XHRcdCR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIGZpcmVBc3luYyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmIChhc3luY0lkKSByZXR1cm5cblx0XHRcdFx0XHRhc3luY0lkID0gY2FsbEFzeW5jKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0YXN5bmNJZCA9IG51bGxcblx0XHRcdFx0XHRcdHJlc29sdmVSb3V0ZSgpXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fSwgZmFsc2UpXG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMucHJlZml4WzBdID09PSBcIiNcIikge1xuXHRcdFx0XHR1bnN1YnNjcmliZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImhhc2hjaGFuZ2VcIiwgcmVzb2x2ZVJvdXRlLCBmYWxzZSlcblx0XHRcdFx0fVxuXHRcdFx0XHQkd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsIHJlc29sdmVSb3V0ZSwgZmFsc2UpXG5cdFx0XHR9XG5cblx0XHRcdHN1YnNjcmliZSh1bnN1YnNjcmliZSlcblx0XHRcdHJlc29sdmVSb3V0ZSgpXG5cdFx0fSxcblx0fVxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsImltcG9ydCBhbHdheXMgZnJvbSAnLi9hbHdheXMnO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyBgZmFsc2VgLiBBbnkgcGFzc2VkIGluIHBhcmFtZXRlcnMgYXJlIGlnbm9yZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKiAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmFsd2F5cywgUi5UXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5GKCk7IC8vPT4gZmFsc2VcbiAqL1xudmFyIEYgPSAvKiNfX1BVUkVfXyovYWx3YXlzKGZhbHNlKTtcbmV4cG9ydCBkZWZhdWx0IEY7IiwiaW1wb3J0IGFsd2F5cyBmcm9tICcuL2Fsd2F5cyc7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIGB0cnVlYC4gQW55IHBhc3NlZCBpbiBwYXJhbWV0ZXJzIGFyZSBpZ25vcmVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICogLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5hbHdheXMsIFIuRlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuVCgpOyAvLz0+IHRydWVcbiAqL1xudmFyIFQgPSAvKiNfX1BVUkVfXyovYWx3YXlzKHRydWUpO1xuZXhwb3J0IGRlZmF1bHQgVDsiLCIvKipcbiAqIEEgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSB1c2VkIHRvIHNwZWNpZnkgXCJnYXBzXCIgd2l0aGluIGN1cnJpZWQgZnVuY3Rpb25zLFxuICogYWxsb3dpbmcgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzLCByZWdhcmRsZXNzIG9mXG4gKiB0aGVpciBwb3NpdGlvbnMuXG4gKlxuICogSWYgYGdgIGlzIGEgY3VycmllZCB0ZXJuYXJ5IGZ1bmN0aW9uIGFuZCBgX2AgaXMgYFIuX19gLCB0aGUgZm9sbG93aW5nIGFyZVxuICogZXF1aXZhbGVudDpcbiAqXG4gKiAgIC0gYGcoMSwgMiwgMylgXG4gKiAgIC0gYGcoXywgMiwgMykoMSlgXG4gKiAgIC0gYGcoXywgXywgMykoMSkoMilgXG4gKiAgIC0gYGcoXywgXywgMykoMSwgMilgXG4gKiAgIC0gYGcoXywgMiwgXykoMSwgMylgXG4gKiAgIC0gYGcoXywgMikoMSkoMylgXG4gKiAgIC0gYGcoXywgMikoMSwgMylgXG4gKiAgIC0gYGcoXywgMikoXywgMykoMSlgXG4gKlxuICogQGNvbnN0YW50XG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjYuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGdyZWV0ID0gUi5yZXBsYWNlKCd7bmFtZX0nLCBSLl9fLCAnSGVsbG8sIHtuYW1lfSEnKTtcbiAqICAgICAgZ3JlZXQoJ0FsaWNlJyk7IC8vPT4gJ0hlbGxvLCBBbGljZSEnXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHsgJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlcic6IHRydWUgfTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIEFkZHMgdHdvIHZhbHVlcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gYVxuICogQHBhcmFtIHtOdW1iZXJ9IGJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBzZWUgUi5zdWJ0cmFjdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYWRkKDIsIDMpOyAgICAgICAvLz0+ICA1XG4gKiAgICAgIFIuYWRkKDcpKDEwKTsgICAgICAvLz0+IDE3XG4gKi9cbnZhciBhZGQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBhZGQoYSwgYikge1xuICByZXR1cm4gTnVtYmVyKGEpICsgTnVtYmVyKGIpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBhZGQ7IiwiaW1wb3J0IF9jb25jYXQgZnJvbSAnLi9pbnRlcm5hbC9fY29uY2F0JztcbmltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgY3VycnlOIGZyb20gJy4vY3VycnlOJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGxpc3QgaXRlcmF0aW9uIGZ1bmN0aW9uIGZyb20gYW4gZXhpc3Rpbmcgb25lIGJ5IGFkZGluZyB0d28gbmV3XG4gKiBwYXJhbWV0ZXJzIHRvIGl0cyBjYWxsYmFjayBmdW5jdGlvbjogdGhlIGN1cnJlbnQgaW5kZXgsIGFuZCB0aGUgZW50aXJlIGxpc3QuXG4gKlxuICogVGhpcyB3b3VsZCB0dXJuLCBmb3IgaW5zdGFuY2UsIFtgUi5tYXBgXSgjbWFwKSBmdW5jdGlvbiBpbnRvIG9uZSB0aGF0XG4gKiBtb3JlIGNsb3NlbHkgcmVzZW1ibGVzIGBBcnJheS5wcm90b3R5cGUubWFwYC4gTm90ZSB0aGF0IHRoaXMgd2lsbCBvbmx5IHdvcmtcbiAqIGZvciBmdW5jdGlvbnMgaW4gd2hpY2ggdGhlIGl0ZXJhdGlvbiBjYWxsYmFjayBmdW5jdGlvbiBpcyB0aGUgZmlyc3RcbiAqIHBhcmFtZXRlciwgYW5kIHdoZXJlIHRoZSBsaXN0IGlzIHRoZSBsYXN0IHBhcmFtZXRlci4gKFRoaXMgbGF0dGVyIG1pZ2h0IGJlXG4gKiB1bmltcG9ydGFudCBpZiB0aGUgbGlzdCBwYXJhbWV0ZXIgaXMgbm90IHVzZWQuKVxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE1LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhIC4uLiAtPiBiKSAuLi4gLT4gW2FdIC0+ICopIC0+IChhIC4uLiwgSW50LCBbYV0gLT4gYikgLi4uIC0+IFthXSAtPiAqKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBsaXN0IGl0ZXJhdGlvbiBmdW5jdGlvbiB0aGF0IGRvZXMgbm90IHBhc3MgaW5kZXggb3IgbGlzdCB0byBpdHMgY2FsbGJhY2tcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBbiBhbHRlcmVkIGxpc3QgaXRlcmF0aW9uIGZ1bmN0aW9uIHRoYXQgcGFzc2VzIChpdGVtLCBpbmRleCwgbGlzdCkgdG8gaXRzIGNhbGxiYWNrXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG1hcEluZGV4ZWQgPSBSLmFkZEluZGV4KFIubWFwKTtcbiAqICAgICAgbWFwSW5kZXhlZCgodmFsLCBpZHgpID0+IGlkeCArICctJyArIHZhbCwgWydmJywgJ28nLCAnbycsICdiJywgJ2EnLCAnciddKTtcbiAqICAgICAgLy89PiBbJzAtZicsICcxLW8nLCAnMi1vJywgJzMtYicsICc0LWEnLCAnNS1yJ11cbiAqL1xudmFyIGFkZEluZGV4ID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gYWRkSW5kZXgoZm4pIHtcbiAgcmV0dXJuIGN1cnJ5Tihmbi5sZW5ndGgsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgb3JpZ0ZuID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsaXN0ID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgYXJnc1swXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvcmlnRm4uYXBwbHkodGhpcywgX2NvbmNhdChhcmd1bWVudHMsIFtpZHgsIGxpc3RdKSk7XG4gICAgICBpZHggKz0gMTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gIH0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBhZGRJbmRleDsiLCJpbXBvcnQgX2NvbmNhdCBmcm9tICcuL2ludGVybmFsL19jb25jYXQnO1xuaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLyoqXG4gKiBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBpbmRleCBvZiBhbiBhcnJheSwgcmV0dXJuaW5nIGFcbiAqIG5ldyBjb3B5IG9mIHRoZSBhcnJheSB3aXRoIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleCByZXBsYWNlZCB3aXRoIHRoZVxuICogcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBhcHBsaWNhdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBhKSAtPiBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5LlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkeCBUaGUgaW5kZXguXG4gKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c30gbGlzdCBBbiBhcnJheS1saWtlIG9iamVjdCB3aG9zZSB2YWx1ZVxuICogICAgICAgIGF0IHRoZSBzdXBwbGllZCBpbmRleCB3aWxsIGJlIHJlcGxhY2VkLlxuICogQHJldHVybiB7QXJyYXl9IEEgY29weSBvZiB0aGUgc3VwcGxpZWQgYXJyYXktbGlrZSBvYmplY3Qgd2l0aFxuICogICAgICAgICB0aGUgZWxlbWVudCBhdCBpbmRleCBgaWR4YCByZXBsYWNlZCB3aXRoIHRoZSB2YWx1ZVxuICogICAgICAgICByZXR1cm5lZCBieSBhcHBseWluZyBgZm5gIHRvIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICogQHNlZSBSLnVwZGF0ZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYWRqdXN0KFIuYWRkKDEwKSwgMSwgWzEsIDIsIDNdKTsgICAgIC8vPT4gWzEsIDEyLCAzXVxuICogICAgICBSLmFkanVzdChSLmFkZCgxMCkpKDEpKFsxLCAyLCAzXSk7ICAgICAvLz0+IFsxLCAxMiwgM11cbiAqIEBzeW1iIFIuYWRqdXN0KGYsIC0xLCBbYSwgYl0pID0gW2EsIGYoYildXG4gKiBAc3ltYiBSLmFkanVzdChmLCAwLCBbYSwgYl0pID0gW2YoYSksIGJdXG4gKi9cbnZhciBhZGp1c3QgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBhZGp1c3QoZm4sIGlkeCwgbGlzdCkge1xuICBpZiAoaWR4ID49IGxpc3QubGVuZ3RoIHx8IGlkeCA8IC1saXN0Lmxlbmd0aCkge1xuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIHZhciBzdGFydCA9IGlkeCA8IDAgPyBsaXN0Lmxlbmd0aCA6IDA7XG4gIHZhciBfaWR4ID0gc3RhcnQgKyBpZHg7XG4gIHZhciBfbGlzdCA9IF9jb25jYXQobGlzdCk7XG4gIF9saXN0W19pZHhdID0gZm4obGlzdFtfaWR4XSk7XG4gIHJldHVybiBfbGlzdDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgYWRqdXN0OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tICcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnO1xuaW1wb3J0IF94YWxsIGZyb20gJy4vaW50ZXJuYWwvX3hhbGwnO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBvZiB0aGUgbGlzdCBtYXRjaCB0aGUgcHJlZGljYXRlLCBgZmFsc2VgIGlmXG4gKiB0aGVyZSBhcmUgYW55IHRoYXQgZG9uJ3QuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGFsbGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJlZGljYXRlIGlzIHNhdGlzZmllZCBieSBldmVyeSBlbGVtZW50LCBgZmFsc2VgXG4gKiAgICAgICAgIG90aGVyd2lzZS5cbiAqIEBzZWUgUi5hbnksIFIubm9uZSwgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZXF1YWxzMyA9IFIuZXF1YWxzKDMpO1xuICogICAgICBSLmFsbChlcXVhbHMzKShbMywgMywgMywgM10pOyAvLz0+IHRydWVcbiAqICAgICAgUi5hbGwoZXF1YWxzMykoWzMsIDMsIDEsIDNdKTsgLy89PiBmYWxzZVxuICovXG52YXIgYWxsID0gLyojX19QVVJFX18qL19jdXJyeTIoIC8qI19fUFVSRV9fKi9fZGlzcGF0Y2hhYmxlKFsnYWxsJ10sIF94YWxsLCBmdW5jdGlvbiBhbGwoZm4sIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgIGlmICghZm4obGlzdFtpZHhdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0pKTtcbmV4cG9ydCBkZWZhdWx0IGFsbDsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IGN1cnJ5TiBmcm9tICcuL2N1cnJ5Tic7XG5pbXBvcnQgbWF4IGZyb20gJy4vbWF4JztcbmltcG9ydCBwbHVjayBmcm9tICcuL3BsdWNrJztcbmltcG9ydCByZWR1Y2UgZnJvbSAnLi9yZWR1Y2UnO1xuXG4vKipcbiAqIFRha2VzIGEgbGlzdCBvZiBwcmVkaWNhdGVzIGFuZCByZXR1cm5zIGEgcHJlZGljYXRlIHRoYXQgcmV0dXJucyB0cnVlIGZvciBhXG4gKiBnaXZlbiBsaXN0IG9mIGFyZ3VtZW50cyBpZiBldmVyeSBvbmUgb2YgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZXMgaXMgc2F0aXNmaWVkXG4gKiBieSB0aG9zZSBhcmd1bWVudHMuXG4gKlxuICogVGhlIGZ1bmN0aW9uIHJldHVybmVkIGlzIGEgY3VycmllZCBmdW5jdGlvbiB3aG9zZSBhcml0eSBtYXRjaGVzIHRoYXQgb2YgdGhlXG4gKiBoaWdoZXN0LWFyaXR5IHByZWRpY2F0ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyBbKCouLi4gLT4gQm9vbGVhbildIC0+ICgqLi4uIC0+IEJvb2xlYW4pXG4gKiBAcGFyYW0ge0FycmF5fSBwcmVkaWNhdGVzIEFuIGFycmF5IG9mIHByZWRpY2F0ZXMgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY29tYmluZWQgcHJlZGljYXRlXG4gKiBAc2VlIFIuYW55UGFzc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc1F1ZWVuID0gUi5wcm9wRXEoJ3JhbmsnLCAnUScpO1xuICogICAgICB2YXIgaXNTcGFkZSA9IFIucHJvcEVxKCdzdWl0JywgJ+KZoO+4jicpO1xuICogICAgICB2YXIgaXNRdWVlbk9mU3BhZGVzID0gUi5hbGxQYXNzKFtpc1F1ZWVuLCBpc1NwYWRlXSk7XG4gKlxuICogICAgICBpc1F1ZWVuT2ZTcGFkZXMoe3Jhbms6ICdRJywgc3VpdDogJ+KZo++4jid9KTsgLy89PiBmYWxzZVxuICogICAgICBpc1F1ZWVuT2ZTcGFkZXMoe3Jhbms6ICdRJywgc3VpdDogJ+KZoO+4jid9KTsgLy89PiB0cnVlXG4gKi9cbnZhciBhbGxQYXNzID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gYWxsUGFzcyhwcmVkcykge1xuICByZXR1cm4gY3VycnlOKHJlZHVjZShtYXgsIDAsIHBsdWNrKCdsZW5ndGgnLCBwcmVkcykpLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIGxlbiA9IHByZWRzLmxlbmd0aDtcbiAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICBpZiAoIXByZWRzW2lkeF0uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBhbGxQYXNzOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybnMgdGhlIGdpdmVuIHZhbHVlLiBOb3RlIHRoYXQgZm9yXG4gKiBub24tcHJpbWl0aXZlcyB0aGUgdmFsdWUgcmV0dXJuZWQgaXMgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIHZhbHVlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMga25vd24gYXMgYGNvbnN0YCwgYGNvbnN0YW50YCwgb3IgYEtgIChmb3IgSyBjb21iaW5hdG9yKSBpblxuICogb3RoZXIgbGFuZ3VhZ2VzIGFuZCBsaWJyYXJpZXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgYSAtPiAoKiAtPiBhKVxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBmdW5jdGlvblxuICogQHJldHVybiB7RnVuY3Rpb259IEEgRnVuY3Rpb24gOjogKiAtPiB2YWwuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHQgPSBSLmFsd2F5cygnVGVlJyk7XG4gKiAgICAgIHQoKTsgLy89PiAnVGVlJ1xuICovXG52YXIgYWx3YXlzID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gYWx3YXlzKHZhbCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB2YWw7XG4gIH07XG59KTtcbmV4cG9ydCBkZWZhdWx0IGFsd2F5czsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGJvdGggYXJndW1lbnRzIGFyZSBgdHJ1ZWA7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIGEgLT4gYiAtPiBhIHwgYlxuICogQHBhcmFtIHtBbnl9IGFcbiAqIEBwYXJhbSB7QW55fSBiXG4gKiBAcmV0dXJuIHtBbnl9IHRoZSBmaXJzdCBhcmd1bWVudCBpZiBpdCBpcyBmYWxzeSwgb3RoZXJ3aXNlIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gKiBAc2VlIFIuYm90aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYW5kKHRydWUsIHRydWUpOyAvLz0+IHRydWVcbiAqICAgICAgUi5hbmQodHJ1ZSwgZmFsc2UpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuYW5kKGZhbHNlLCB0cnVlKTsgLy89PiBmYWxzZVxuICogICAgICBSLmFuZChmYWxzZSwgZmFsc2UpOyAvLz0+IGZhbHNlXG4gKi9cbnZhciBhbmQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBhbmQoYSwgYikge1xuICByZXR1cm4gYSAmJiBiO1xufSk7XG5leHBvcnQgZGVmYXVsdCBhbmQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZSc7XG5pbXBvcnQgX3hhbnkgZnJvbSAnLi9pbnRlcm5hbC9feGFueSc7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIG9mIGVsZW1lbnRzIG9mIHRoZSBsaXN0IG1hdGNoIHRoZSBwcmVkaWNhdGUsXG4gKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgYW55YCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcmVkaWNhdGUgaXMgc2F0aXNmaWVkIGJ5IGF0IGxlYXN0IG9uZSBlbGVtZW50LCBgZmFsc2VgXG4gKiAgICAgICAgIG90aGVyd2lzZS5cbiAqIEBzZWUgUi5hbGwsIFIubm9uZSwgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbGVzc1RoYW4wID0gUi5mbGlwKFIubHQpKDApO1xuICogICAgICB2YXIgbGVzc1RoYW4yID0gUi5mbGlwKFIubHQpKDIpO1xuICogICAgICBSLmFueShsZXNzVGhhbjApKFsxLCAyXSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5hbnkobGVzc1RoYW4yKShbMSwgMl0pOyAvLz0+IHRydWVcbiAqL1xudmFyIGFueSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovX2Rpc3BhdGNoYWJsZShbJ2FueSddLCBfeGFueSwgZnVuY3Rpb24gYW55KGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn0pKTtcbmV4cG9ydCBkZWZhdWx0IGFueTsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IGN1cnJ5TiBmcm9tICcuL2N1cnJ5Tic7XG5pbXBvcnQgbWF4IGZyb20gJy4vbWF4JztcbmltcG9ydCBwbHVjayBmcm9tICcuL3BsdWNrJztcbmltcG9ydCByZWR1Y2UgZnJvbSAnLi9yZWR1Y2UnO1xuXG4vKipcbiAqIFRha2VzIGEgbGlzdCBvZiBwcmVkaWNhdGVzIGFuZCByZXR1cm5zIGEgcHJlZGljYXRlIHRoYXQgcmV0dXJucyB0cnVlIGZvciBhXG4gKiBnaXZlbiBsaXN0IG9mIGFyZ3VtZW50cyBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZXMgaXNcbiAqIHNhdGlzZmllZCBieSB0aG9zZSBhcmd1bWVudHMuXG4gKlxuICogVGhlIGZ1bmN0aW9uIHJldHVybmVkIGlzIGEgY3VycmllZCBmdW5jdGlvbiB3aG9zZSBhcml0eSBtYXRjaGVzIHRoYXQgb2YgdGhlXG4gKiBoaWdoZXN0LWFyaXR5IHByZWRpY2F0ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyBbKCouLi4gLT4gQm9vbGVhbildIC0+ICgqLi4uIC0+IEJvb2xlYW4pXG4gKiBAcGFyYW0ge0FycmF5fSBwcmVkaWNhdGVzIEFuIGFycmF5IG9mIHByZWRpY2F0ZXMgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY29tYmluZWQgcHJlZGljYXRlXG4gKiBAc2VlIFIuYWxsUGFzc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc0NsdWIgPSBSLnByb3BFcSgnc3VpdCcsICfimaMnKTtcbiAqICAgICAgdmFyIGlzU3BhZGUgPSBSLnByb3BFcSgnc3VpdCcsICfimaAnKTtcbiAqICAgICAgdmFyIGlzQmxhY2tDYXJkID0gUi5hbnlQYXNzKFtpc0NsdWIsIGlzU3BhZGVdKTtcbiAqXG4gKiAgICAgIGlzQmxhY2tDYXJkKHtyYW5rOiAnMTAnLCBzdWl0OiAn4pmjJ30pOyAvLz0+IHRydWVcbiAqICAgICAgaXNCbGFja0NhcmQoe3Jhbms6ICdRJywgc3VpdDogJ+KZoCd9KTsgLy89PiB0cnVlXG4gKiAgICAgIGlzQmxhY2tDYXJkKHtyYW5rOiAnUScsIHN1aXQ6ICfimaYnfSk7IC8vPT4gZmFsc2VcbiAqL1xudmFyIGFueVBhc3MgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBhbnlQYXNzKHByZWRzKSB7XG4gIHJldHVybiBjdXJyeU4ocmVkdWNlKG1heCwgMCwgcGx1Y2soJ2xlbmd0aCcsIHByZWRzKSksIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgbGVuID0gcHJlZHMubGVuZ3RoO1xuICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgIGlmIChwcmVkc1tpZHhdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgYW55UGFzczsiLCJpbXBvcnQgX2NvbmNhdCBmcm9tICcuL2ludGVybmFsL19jb25jYXQnO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfcmVkdWNlIGZyb20gJy4vaW50ZXJuYWwvX3JlZHVjZSc7XG5pbXBvcnQgbWFwIGZyb20gJy4vbWFwJztcblxuLyoqXG4gKiBhcCBhcHBsaWVzIGEgbGlzdCBvZiBmdW5jdGlvbnMgdG8gYSBsaXN0IG9mIHZhbHVlcy5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgYXBgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LiBBbHNvXG4gKiB0cmVhdHMgY3VycmllZCBmdW5jdGlvbnMgYXMgYXBwbGljYXRpdmVzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIFthIC0+IGJdIC0+IFthXSAtPiBbYl1cbiAqIEBzaWcgQXBwbHkgZiA9PiBmIChhIC0+IGIpIC0+IGYgYSAtPiBmIGJcbiAqIEBzaWcgKGEgLT4gYiAtPiBjKSAtPiAoYSAtPiBiKSAtPiAoYSAtPiBjKVxuICogQHBhcmFtIHsqfSBhcHBseUZcbiAqIEBwYXJhbSB7Kn0gYXBwbHlYXG4gKiBAcmV0dXJuIHsqfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYXAoW1IubXVsdGlwbHkoMiksIFIuYWRkKDMpXSwgWzEsMiwzXSk7IC8vPT4gWzIsIDQsIDYsIDQsIDUsIDZdXG4gKiAgICAgIFIuYXAoW1IuY29uY2F0KCd0YXN0eSAnKSwgUi50b1VwcGVyXSwgWydwaXp6YScsICdzYWxhZCddKTsgLy89PiBbXCJ0YXN0eSBwaXp6YVwiLCBcInRhc3R5IHNhbGFkXCIsIFwiUElaWkFcIiwgXCJTQUxBRFwiXVxuICpcbiAqICAgICAgLy8gUi5hcCBjYW4gYWxzbyBiZSB1c2VkIGFzIFMgY29tYmluYXRvclxuICogICAgICAvLyB3aGVuIG9ubHkgdHdvIGZ1bmN0aW9ucyBhcmUgcGFzc2VkXG4gKiAgICAgIFIuYXAoUi5jb25jYXQsIFIudG9VcHBlcikoJ1JhbWRhJykgLy89PiAnUmFtZGFSQU1EQSdcbiAqIEBzeW1iIFIuYXAoW2YsIGddLCBbYSwgYl0pID0gW2YoYSksIGYoYiksIGcoYSksIGcoYildXG4gKi9cbnZhciBhcCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGFwKGFwcGx5RiwgYXBwbHlYKSB7XG4gIHJldHVybiB0eXBlb2YgYXBwbHlYWydmYW50YXN5LWxhbmQvYXAnXSA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGx5WFsnZmFudGFzeS1sYW5kL2FwJ10oYXBwbHlGKSA6IHR5cGVvZiBhcHBseUYuYXAgPT09ICdmdW5jdGlvbicgPyBhcHBseUYuYXAoYXBwbHlYKSA6IHR5cGVvZiBhcHBseUYgPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBhcHBseUYoeCkoYXBwbHlYKHgpKTtcbiAgfSA6XG4gIC8vIGVsc2VcbiAgX3JlZHVjZShmdW5jdGlvbiAoYWNjLCBmKSB7XG4gICAgcmV0dXJuIF9jb25jYXQoYWNjLCBtYXAoZiwgYXBwbHlYKSk7XG4gIH0sIFtdLCBhcHBseUYpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBhcDsiLCJpbXBvcnQgX2FwZXJ0dXJlIGZyb20gJy4vaW50ZXJuYWwvX2FwZXJ0dXJlJztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tICcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnO1xuaW1wb3J0IF94YXBlcnR1cmUgZnJvbSAnLi9pbnRlcm5hbC9feGFwZXJ0dXJlJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QsIGNvbXBvc2VkIG9mIG4tdHVwbGVzIG9mIGNvbnNlY3V0aXZlIGVsZW1lbnRzLiBJZiBgbmAgaXNcbiAqIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBsaXN0LCBhbiBlbXB0eSBsaXN0IGlzIHJldHVybmVkLlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFtbYV1dXG4gKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgdHVwbGVzIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBzcGxpdCBpbnRvIGBuYC1sZW5ndGggdHVwbGVzXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIHJlc3VsdGluZyBsaXN0IG9mIGBuYC1sZW5ndGggdHVwbGVzXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5hcGVydHVyZSgyLCBbMSwgMiwgMywgNCwgNV0pOyAvLz0+IFtbMSwgMl0sIFsyLCAzXSwgWzMsIDRdLCBbNCwgNV1dXG4gKiAgICAgIFIuYXBlcnR1cmUoMywgWzEsIDIsIDMsIDQsIDVdKTsgLy89PiBbWzEsIDIsIDNdLCBbMiwgMywgNF0sIFszLCA0LCA1XV1cbiAqICAgICAgUi5hcGVydHVyZSg3LCBbMSwgMiwgMywgNCwgNV0pOyAvLz0+IFtdXG4gKi9cbnZhciBhcGVydHVyZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovX2Rpc3BhdGNoYWJsZShbXSwgX3hhcGVydHVyZSwgX2FwZXJ0dXJlKSk7XG5leHBvcnQgZGVmYXVsdCBhcGVydHVyZTsiLCJpbXBvcnQgX2NvbmNhdCBmcm9tICcuL2ludGVybmFsL19jb25jYXQnO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgY29udGVudHMgb2YgdGhlIGdpdmVuIGxpc3QsIGZvbGxvd2VkIGJ5XG4gKiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHsqfSBlbCBUaGUgZWxlbWVudCB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgbmV3IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IG9mIGVsZW1lbnRzIHRvIGFkZCBhIG5ldyBpdGVtIHRvLlxuICogICAgICAgIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgb2xkIGxpc3QgZm9sbG93ZWQgYnkgYGVsYC5cbiAqIEBzZWUgUi5wcmVwZW5kXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5hcHBlbmQoJ3Rlc3RzJywgWyd3cml0ZScsICdtb3JlJ10pOyAvLz0+IFsnd3JpdGUnLCAnbW9yZScsICd0ZXN0cyddXG4gKiAgICAgIFIuYXBwZW5kKCd0ZXN0cycsIFtdKTsgLy89PiBbJ3Rlc3RzJ11cbiAqICAgICAgUi5hcHBlbmQoWyd0ZXN0cyddLCBbJ3dyaXRlJywgJ21vcmUnXSk7IC8vPT4gWyd3cml0ZScsICdtb3JlJywgWyd0ZXN0cyddXVxuICovXG52YXIgYXBwZW5kID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gYXBwZW5kKGVsLCBsaXN0KSB7XG4gIHJldHVybiBfY29uY2F0KGxpc3QsIFtlbF0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBhcHBlbmQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBBcHBsaWVzIGZ1bmN0aW9uIGBmbmAgdG8gdGhlIGFyZ3VtZW50IGxpc3QgYGFyZ3NgLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAqIGNyZWF0aW5nIGEgZml4ZWQtYXJpdHkgZnVuY3Rpb24gZnJvbSBhIHZhcmlhZGljIGZ1bmN0aW9uLiBgZm5gIHNob3VsZCBiZSBhXG4gKiBib3VuZCBmdW5jdGlvbiBpZiBjb250ZXh0IGlzIHNpZ25pZmljYW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjcuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgqLi4uIC0+IGEpIC0+IFsqXSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCBgYXJnc2BcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBjYWxsIGBmbmAgd2l0aFxuICogQHJldHVybiB7Kn0gcmVzdWx0IFRoZSByZXN1bHQsIGVxdWl2YWxlbnQgdG8gYGZuKC4uLmFyZ3MpYFxuICogQHNlZSBSLmNhbGwsIFIudW5hcHBseVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBudW1zID0gWzEsIDIsIDMsIC05OSwgNDIsIDYsIDddO1xuICogICAgICBSLmFwcGx5KE1hdGgubWF4LCBudW1zKTsgLy89PiA0MlxuICogQHN5bWIgUi5hcHBseShmLCBbYSwgYiwgY10pID0gZihhLCBiLCBjKVxuICovXG52YXIgYXBwbHkgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBhcHBseShmbiwgYXJncykge1xuICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGFwcGx5OyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgYXBwbHkgZnJvbSAnLi9hcHBseSc7XG5pbXBvcnQgY3VycnlOIGZyb20gJy4vY3VycnlOJztcbmltcG9ydCBtYXAgZnJvbSAnLi9tYXAnO1xuaW1wb3J0IG1heCBmcm9tICcuL21heCc7XG5pbXBvcnQgcGx1Y2sgZnJvbSAnLi9wbHVjayc7XG5pbXBvcnQgcmVkdWNlIGZyb20gJy4vcmVkdWNlJztcbmltcG9ydCB2YWx1ZXMgZnJvbSAnLi92YWx1ZXMnO1xuXG4vKipcbiAqIEdpdmVuIGEgc3BlYyBvYmplY3QgcmVjdXJzaXZlbHkgbWFwcGluZyBwcm9wZXJ0aWVzIHRvIGZ1bmN0aW9ucywgY3JlYXRlcyBhXG4gKiBmdW5jdGlvbiBwcm9kdWNpbmcgYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHN0cnVjdHVyZSwgYnkgbWFwcGluZyBlYWNoIHByb3BlcnR5XG4gKiB0byB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgaXRzIGFzc29jaWF0ZWQgZnVuY3Rpb24gd2l0aCB0aGUgc3VwcGxpZWQgYXJndW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIwLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyB7azogKChhLCBiLCAuLi4sIG0pIC0+IHYpfSAtPiAoKGEsIGIsIC4uLiwgbSkgLT4ge2s6IHZ9KVxuICogQHBhcmFtIHtPYmplY3R9IHNwZWMgYW4gb2JqZWN0IHJlY3Vyc2l2ZWx5IG1hcHBpbmcgcHJvcGVydGllcyB0byBmdW5jdGlvbnMgZm9yXG4gKiAgICAgICAgcHJvZHVjaW5nIHRoZSB2YWx1ZXMgZm9yIHRoZXNlIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHN0cnVjdHVyZVxuICogYXMgYHNwZWMnLCB3aXRoIGVhY2ggcHJvcGVydHkgc2V0IHRvIHRoZSB2YWx1ZSByZXR1cm5lZCBieSBjYWxsaW5nIGl0c1xuICogYXNzb2NpYXRlZCBmdW5jdGlvbiB3aXRoIHRoZSBzdXBwbGllZCBhcmd1bWVudHMuXG4gKiBAc2VlIFIuY29udmVyZ2UsIFIuanV4dFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBnZXRNZXRyaWNzID0gUi5hcHBseVNwZWMoe1xuICogICAgICAgIHN1bTogUi5hZGQsXG4gKiAgICAgICAgbmVzdGVkOiB7IG11bDogUi5tdWx0aXBseSB9XG4gKiAgICAgIH0pO1xuICogICAgICBnZXRNZXRyaWNzKDIsIDQpOyAvLyA9PiB7IHN1bTogNiwgbmVzdGVkOiB7IG11bDogOCB9IH1cbiAqIEBzeW1iIFIuYXBwbHlTcGVjKHsgeDogZiwgeTogeyB6OiBnIH0gfSkoYSwgYikgPSB7IHg6IGYoYSwgYiksIHk6IHsgejogZyhhLCBiKSB9IH1cbiAqL1xudmFyIGFwcGx5U3BlYyA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGFwcGx5U3BlYyhzcGVjKSB7XG4gIHNwZWMgPSBtYXAoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT0gJ2Z1bmN0aW9uJyA/IHYgOiBhcHBseVNwZWModik7XG4gIH0sIHNwZWMpO1xuICByZXR1cm4gY3VycnlOKHJlZHVjZShtYXgsIDAsIHBsdWNrKCdsZW5ndGgnLCB2YWx1ZXMoc3BlYykpKSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBtYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBhcHBseShmLCBhcmdzKTtcbiAgICB9LCBzcGVjKTtcbiAgfSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGFwcGx5U3BlYzsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiogVGFrZXMgYSB2YWx1ZSBhbmQgYXBwbGllcyBhIGZ1bmN0aW9uIHRvIGl0LlxuKlxuKiBUaGlzIGZ1bmN0aW9uIGlzIGFsc28ga25vd24gYXMgdGhlIGB0aHJ1c2hgIGNvbWJpbmF0b3IuXG4qXG4qIEBmdW5jXG4qIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjUuMFxuKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiogQHNpZyBhIC0+IChhIC0+IGIpIC0+IGJcbiogQHBhcmFtIHsqfSB4IFRoZSB2YWx1ZVxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIFRoZSBmdW5jdGlvbiB0byBhcHBseVxuKiBAcmV0dXJuIHsqfSBUaGUgcmVzdWx0IG9mIGFwcGx5aW5nIGBmYCB0byBgeGBcbiogQGV4YW1wbGVcbipcbiogICAgICB2YXIgdDQyID0gUi5hcHBseVRvKDQyKTtcbiogICAgICB0NDIoUi5pZGVudGl0eSk7IC8vPT4gNDJcbiogICAgICB0NDIoUi5hZGQoMSkpOyAvLz0+IDQzXG4qL1xudmFyIGFwcGx5VG8gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBhcHBseVRvKHgsIGYpIHtcbiAgcmV0dXJuIGYoeCk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGFwcGx5VG87IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLyoqXG4gKiBNYWtlcyBhbiBhc2NlbmRpbmcgY29tcGFyYXRvciBmdW5jdGlvbiBvdXQgb2YgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB2YWx1ZVxuICogdGhhdCBjYW4gYmUgY29tcGFyZWQgd2l0aCBgPGAgYW5kIGA+YC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMy4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgT3JkIGIgPT4gKGEgLT4gYikgLT4gYSAtPiBhIC0+IE51bWJlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiBvZiBhcml0eSBvbmUgdGhhdCByZXR1cm5zIGEgdmFsdWUgdGhhdCBjYW4gYmUgY29tcGFyZWRcbiAqIEBwYXJhbSB7Kn0gYSBUaGUgZmlyc3QgaXRlbSB0byBiZSBjb21wYXJlZC5cbiAqIEBwYXJhbSB7Kn0gYiBUaGUgc2Vjb25kIGl0ZW0gdG8gYmUgY29tcGFyZWQuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGAtMWAgaWYgZm4oYSkgPCBmbihiKSwgYDFgIGlmIGZuKGIpIDwgZm4oYSksIG90aGVyd2lzZSBgMGBcbiAqIEBzZWUgUi5kZXNjZW5kXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGJ5QWdlID0gUi5hc2NlbmQoUi5wcm9wKCdhZ2UnKSk7XG4gKiAgICAgIHZhciBwZW9wbGUgPSBbXG4gKiAgICAgICAgLy8gLi4uXG4gKiAgICAgIF07XG4gKiAgICAgIHZhciBwZW9wbGVCeVlvdW5nZXN0Rmlyc3QgPSBSLnNvcnQoYnlBZ2UsIHBlb3BsZSk7XG4gKi9cbnZhciBhc2NlbmQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBhc2NlbmQoZm4sIGEsIGIpIHtcbiAgdmFyIGFhID0gZm4oYSk7XG4gIHZhciBiYiA9IGZuKGIpO1xuICByZXR1cm4gYWEgPCBiYiA/IC0xIDogYWEgPiBiYiA/IDEgOiAwO1xufSk7XG5leHBvcnQgZGVmYXVsdCBhc2NlbmQ7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLyoqXG4gKiBNYWtlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYW4gb2JqZWN0LCBzZXR0aW5nIG9yIG92ZXJyaWRpbmcgdGhlIHNwZWNpZmllZFxuICogcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuIE5vdGUgdGhhdCB0aGlzIGNvcGllcyBhbmQgZmxhdHRlbnMgcHJvdG90eXBlXG4gKiBwcm9wZXJ0aWVzIG9udG8gdGhlIG5ldyBvYmplY3QgYXMgd2VsbC4gQWxsIG5vbi1wcmltaXRpdmUgcHJvcGVydGllcyBhcmVcbiAqIGNvcGllZCBieSByZWZlcmVuY2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIFN0cmluZyAtPiBhIC0+IHtrOiB2fSAtPiB7azogdn1cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBwcm9wZXJ0eSBuYW1lIHRvIHNldFxuICogQHBhcmFtIHsqfSB2YWwgVGhlIG5ldyB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNsb25lXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCBlcXVpdmFsZW50IHRvIHRoZSBvcmlnaW5hbCBleGNlcHQgZm9yIHRoZSBjaGFuZ2VkIHByb3BlcnR5LlxuICogQHNlZSBSLmRpc3NvY1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYXNzb2MoJ2MnLCAzLCB7YTogMSwgYjogMn0pOyAvLz0+IHthOiAxLCBiOiAyLCBjOiAzfVxuICovXG52YXIgYXNzb2MgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBhc3NvYyhwcm9wLCB2YWwsIG9iaikge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZvciAodmFyIHAgaW4gb2JqKSB7XG4gICAgcmVzdWx0W3BdID0gb2JqW3BdO1xuICB9XG4gIHJlc3VsdFtwcm9wXSA9IHZhbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgYXNzb2M7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcbmltcG9ydCBfaGFzIGZyb20gJy4vaW50ZXJuYWwvX2hhcyc7XG5pbXBvcnQgX2lzQXJyYXkgZnJvbSAnLi9pbnRlcm5hbC9faXNBcnJheSc7XG5pbXBvcnQgX2lzSW50ZWdlciBmcm9tICcuL2ludGVybmFsL19pc0ludGVnZXInO1xuaW1wb3J0IGFzc29jIGZyb20gJy4vYXNzb2MnO1xuaW1wb3J0IGlzTmlsIGZyb20gJy4vaXNOaWwnO1xuXG4vKipcbiAqIE1ha2VzIGEgc2hhbGxvdyBjbG9uZSBvZiBhbiBvYmplY3QsIHNldHRpbmcgb3Igb3ZlcnJpZGluZyB0aGUgbm9kZXMgcmVxdWlyZWRcbiAqIHRvIGNyZWF0ZSB0aGUgZ2l2ZW4gcGF0aCwgYW5kIHBsYWNpbmcgdGhlIHNwZWNpZmljIHZhbHVlIGF0IHRoZSB0YWlsIGVuZCBvZlxuICogdGhhdCBwYXRoLiBOb3RlIHRoYXQgdGhpcyBjb3BpZXMgYW5kIGZsYXR0ZW5zIHByb3RvdHlwZSBwcm9wZXJ0aWVzIG9udG8gdGhlXG4gKiBuZXcgb2JqZWN0IGFzIHdlbGwuIEFsbCBub24tcHJpbWl0aXZlIHByb3BlcnRpZXMgYXJlIGNvcGllZCBieSByZWZlcmVuY2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gSWR4ID0gU3RyaW5nIHwgSW50XG4gKiBAc2lnIFtJZHhdIC0+IGEgLT4ge2F9IC0+IHthfVxuICogQHBhcmFtIHtBcnJheX0gcGF0aCB0aGUgcGF0aCB0byBzZXRcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSBuZXcgdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjbG9uZVxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBvYmplY3QgZXF1aXZhbGVudCB0byB0aGUgb3JpZ2luYWwgZXhjZXB0IGFsb25nIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAqIEBzZWUgUi5kaXNzb2NQYXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5hc3NvY1BhdGgoWydhJywgJ2InLCAnYyddLCA0Miwge2E6IHtiOiB7YzogMH19fSk7IC8vPT4ge2E6IHtiOiB7YzogNDJ9fX1cbiAqXG4gKiAgICAgIC8vIEFueSBtaXNzaW5nIG9yIG5vbi1vYmplY3Qga2V5cyBpbiBwYXRoIHdpbGwgYmUgb3ZlcnJpZGRlblxuICogICAgICBSLmFzc29jUGF0aChbJ2EnLCAnYicsICdjJ10sIDQyLCB7YTogNX0pOyAvLz0+IHthOiB7Yjoge2M6IDQyfX19XG4gKi9cbnZhciBhc3NvY1BhdGggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBhc3NvY1BhdGgocGF0aCwgdmFsLCBvYmopIHtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB2YXIgaWR4ID0gcGF0aFswXTtcbiAgaWYgKHBhdGgubGVuZ3RoID4gMSkge1xuICAgIHZhciBuZXh0T2JqID0gIWlzTmlsKG9iaikgJiYgX2hhcyhpZHgsIG9iaikgPyBvYmpbaWR4XSA6IF9pc0ludGVnZXIocGF0aFsxXSkgPyBbXSA6IHt9O1xuICAgIHZhbCA9IGFzc29jUGF0aChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChwYXRoLCAxKSwgdmFsLCBuZXh0T2JqKTtcbiAgfVxuICBpZiAoX2lzSW50ZWdlcihpZHgpICYmIF9pc0FycmF5KG9iaikpIHtcbiAgICB2YXIgYXJyID0gW10uY29uY2F0KG9iaik7XG4gICAgYXJyW2lkeF0gPSB2YWw7XG4gICAgcmV0dXJuIGFycjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXNzb2MoaWR4LCB2YWwsIG9iaik7XG4gIH1cbn0pO1xuZXhwb3J0IGRlZmF1bHQgYXNzb2NQYXRoOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgbkFyeSBmcm9tICcuL25BcnknO1xuXG4vKipcbiAqIFdyYXBzIGEgZnVuY3Rpb24gb2YgYW55IGFyaXR5IChpbmNsdWRpbmcgbnVsbGFyeSkgaW4gYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHNcbiAqIGV4YWN0bHkgMiBwYXJhbWV0ZXJzLiBBbnkgZXh0cmFuZW91cyBwYXJhbWV0ZXJzIHdpbGwgbm90IGJlIHBhc3NlZCB0byB0aGVcbiAqIHN1cHBsaWVkIGZ1bmN0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgqIC0+IGMpIC0+IChhLCBiIC0+IGMpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyBgZm5gLiBUaGUgbmV3IGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgb2ZcbiAqICAgICAgICAgYXJpdHkgMi5cbiAqIEBzZWUgUi5uQXJ5LCBSLnVuYXJ5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHRha2VzVGhyZWVBcmdzID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICogICAgICAgIHJldHVybiBbYSwgYiwgY107XG4gKiAgICAgIH07XG4gKiAgICAgIHRha2VzVGhyZWVBcmdzLmxlbmd0aDsgLy89PiAzXG4gKiAgICAgIHRha2VzVGhyZWVBcmdzKDEsIDIsIDMpOyAvLz0+IFsxLCAyLCAzXVxuICpcbiAqICAgICAgdmFyIHRha2VzVHdvQXJncyA9IFIuYmluYXJ5KHRha2VzVGhyZWVBcmdzKTtcbiAqICAgICAgdGFrZXNUd29BcmdzLmxlbmd0aDsgLy89PiAyXG4gKiAgICAgIC8vIE9ubHkgMiBhcmd1bWVudHMgYXJlIHBhc3NlZCB0byB0aGUgd3JhcHBlZCBmdW5jdGlvblxuICogICAgICB0YWtlc1R3b0FyZ3MoMSwgMiwgMyk7IC8vPT4gWzEsIDIsIHVuZGVmaW5lZF1cbiAqIEBzeW1iIFIuYmluYXJ5KGYpKGEsIGIsIGMpID0gZihhLCBiKVxuICovXG52YXIgYmluYXJ5ID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gYmluYXJ5KGZuKSB7XG4gIHJldHVybiBuQXJ5KDIsIGZuKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgYmluYXJ5OyIsImltcG9ydCBfYXJpdHkgZnJvbSAnLi9pbnRlcm5hbC9fYXJpdHknO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyBib3VuZCB0byBhIGNvbnRleHQuXG4gKiBOb3RlOiBgUi5iaW5kYCBkb2VzIG5vdCBwcm92aWRlIHRoZSBhZGRpdGlvbmFsIGFyZ3VtZW50LWJpbmRpbmcgY2FwYWJpbGl0aWVzIG9mXG4gKiBbRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQpLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjYuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgqIC0+ICopIC0+IHsqfSAtPiAoKiAtPiAqKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGJpbmQgdG8gY29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNPYmogVGhlIGNvbnRleHQgdG8gYmluZCBgZm5gIHRvXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgZXhlY3V0ZSBpbiB0aGUgY29udGV4dCBvZiBgdGhpc09iamAuXG4gKiBAc2VlIFIucGFydGlhbFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBsb2cgPSBSLmJpbmQoY29uc29sZS5sb2csIGNvbnNvbGUpO1xuICogICAgICBSLnBpcGUoUi5hc3NvYygnYScsIDIpLCBSLnRhcChsb2cpLCBSLmFzc29jKCdhJywgMykpKHthOiAxfSk7IC8vPT4ge2E6IDN9XG4gKiAgICAgIC8vIGxvZ3Mge2E6IDJ9XG4gKiBAc3ltYiBSLmJpbmQoZiwgbykoYSwgYikgPSBmLmNhbGwobywgYSwgYilcbiAqL1xudmFyIGJpbmQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBiaW5kKGZuLCB0aGlzT2JqKSB7XG4gIHJldHVybiBfYXJpdHkoZm4ubGVuZ3RoLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNPYmosIGFyZ3VtZW50cyk7XG4gIH0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBiaW5kOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2lzRnVuY3Rpb24gZnJvbSAnLi9pbnRlcm5hbC9faXNGdW5jdGlvbic7XG5pbXBvcnQgYW5kIGZyb20gJy4vYW5kJztcbmltcG9ydCBsaWZ0IGZyb20gJy4vbGlmdCc7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB3aGljaCBjYWxscyB0aGUgdHdvIHByb3ZpZGVkIGZ1bmN0aW9ucyBhbmQgcmV0dXJucyB0aGUgYCYmYFxuICogb2YgdGhlIHJlc3VsdHMuXG4gKiBJdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGZpcnN0IGZ1bmN0aW9uIGlmIGl0IGlzIGZhbHNlLXkgYW5kIHRoZSByZXN1bHRcbiAqIG9mIHRoZSBzZWNvbmQgZnVuY3Rpb24gb3RoZXJ3aXNlLiBOb3RlIHRoYXQgdGhpcyBpcyBzaG9ydC1jaXJjdWl0ZWQsXG4gKiBtZWFuaW5nIHRoYXQgdGhlIHNlY29uZCBmdW5jdGlvbiB3aWxsIG5vdCBiZSBpbnZva2VkIGlmIHRoZSBmaXJzdCByZXR1cm5zIGFcbiAqIGZhbHNlLXkgdmFsdWUuXG4gKlxuICogSW4gYWRkaXRpb24gdG8gZnVuY3Rpb25zLCBgUi5ib3RoYCBhbHNvIGFjY2VwdHMgYW55IGZhbnRhc3ktbGFuZCBjb21wYXRpYmxlXG4gKiBhcHBsaWNhdGl2ZSBmdW5jdG9yLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEyLjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyAoKi4uLiAtPiBCb29sZWFuKSAtPiAoKi4uLiAtPiBCb29sZWFuKSAtPiAoKi4uLiAtPiBCb29sZWFuKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZiBBIHByZWRpY2F0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZyBBbm90aGVyIHByZWRpY2F0ZVxuICogQHJldHVybiB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBhcHBsaWVzIGl0cyBhcmd1bWVudHMgdG8gYGZgIGFuZCBgZ2AgYW5kIGAmJmBzIHRoZWlyIG91dHB1dHMgdG9nZXRoZXIuXG4gKiBAc2VlIFIuYW5kXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGd0MTAgPSBSLmd0KFIuX18sIDEwKVxuICogICAgICB2YXIgbHQyMCA9IFIubHQoUi5fXywgMjApXG4gKiAgICAgIHZhciBmID0gUi5ib3RoKGd0MTAsIGx0MjApO1xuICogICAgICBmKDE1KTsgLy89PiB0cnVlXG4gKiAgICAgIGYoMzApOyAvLz0+IGZhbHNlXG4gKi9cbnZhciBib3RoID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gYm90aChmLCBnKSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbihmKSA/IGZ1bmN0aW9uIF9ib3RoKCkge1xuICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgJiYgZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9IDogbGlmdChhbmQpKGYsIGcpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBib3RoOyIsImltcG9ydCBjdXJyeSBmcm9tICcuL2N1cnJ5JztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgY2FsbGluZyBpdHMgZmlyc3QgYXJndW1lbnQgd2l0aCB0aGUgcmVtYWluaW5nXG4gKiBhcmd1bWVudHMuIFRoaXMgaXMgb2NjYXNpb25hbGx5IHVzZWZ1bCBhcyBhIGNvbnZlcmdpbmcgZnVuY3Rpb24gZm9yXG4gKiBbYFIuY29udmVyZ2VgXSgjY29udmVyZ2UpOiB0aGUgZmlyc3QgYnJhbmNoIGNhbiBwcm9kdWNlIGEgZnVuY3Rpb24gd2hpbGUgdGhlXG4gKiByZW1haW5pbmcgYnJhbmNoZXMgcHJvZHVjZSB2YWx1ZXMgdG8gYmUgcGFzc2VkIHRvIHRoYXQgZnVuY3Rpb24gYXMgaXRzXG4gKiBhcmd1bWVudHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCouLi4gLT4gYSksKi4uLiAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIHJlbWFpbmluZyBhcmd1bWVudHMuXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQW55IG51bWJlciBvZiBwb3NpdGlvbmFsIGFyZ3VtZW50cy5cbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIuYXBwbHlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmNhbGwoUi5hZGQsIDEsIDIpOyAvLz0+IDNcbiAqXG4gKiAgICAgIHZhciBpbmRlbnROID0gUi5waXBlKFIucmVwZWF0KCcgJyksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFIuam9pbignJyksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFIucmVwbGFjZSgvXig/ISQpL2dtKSk7XG4gKlxuICogICAgICB2YXIgZm9ybWF0ID0gUi5jb252ZXJnZShSLmNhbGwsIFtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFIucGlwZShSLnByb3AoJ2luZGVudCcpLCBpbmRlbnROKSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFIucHJvcCgndmFsdWUnKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAqXG4gKiAgICAgIGZvcm1hdCh7aW5kZW50OiAyLCB2YWx1ZTogJ2Zvb1xcbmJhclxcbmJhelxcbid9KTsgLy89PiAnICBmb29cXG4gIGJhclxcbiAgYmF6XFxuJ1xuICogQHN5bWIgUi5jYWxsKGYsIGEsIGIpID0gZihhLCBiKVxuICovXG52YXIgY2FsbCA9IC8qI19fUFVSRV9fKi9jdXJyeShmdW5jdGlvbiBjYWxsKGZuKSB7XG4gIHJldHVybiBmbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgY2FsbDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfbWFrZUZsYXQgZnJvbSAnLi9pbnRlcm5hbC9fbWFrZUZsYXQnO1xuaW1wb3J0IF94Y2hhaW4gZnJvbSAnLi9pbnRlcm5hbC9feGNoYWluJztcbmltcG9ydCBtYXAgZnJvbSAnLi9tYXAnO1xuXG4vKipcbiAqIGBjaGFpbmAgbWFwcyBhIGZ1bmN0aW9uIG92ZXIgYSBsaXN0IGFuZCBjb25jYXRlbmF0ZXMgdGhlIHJlc3VsdHMuIGBjaGFpbmBcbiAqIGlzIGFsc28ga25vd24gYXMgYGZsYXRNYXBgIGluIHNvbWUgbGlicmFyaWVzXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGNoYWluYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudCxcbiAqIGFjY29yZGluZyB0byB0aGUgW0ZhbnRhc3lMYW5kIENoYWluIHNwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY2hhaW4pLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgQ2hhaW4gbSA9PiAoYSAtPiBtIGIpIC0+IG0gYSAtPiBtIGJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXAgd2l0aFxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBtYXAgb3ZlclxuICogQHJldHVybiB7QXJyYXl9IFRoZSByZXN1bHQgb2YgZmxhdC1tYXBwaW5nIGBsaXN0YCB3aXRoIGBmbmBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZHVwbGljYXRlID0gbiA9PiBbbiwgbl07XG4gKiAgICAgIFIuY2hhaW4oZHVwbGljYXRlLCBbMSwgMiwgM10pOyAvLz0+IFsxLCAxLCAyLCAyLCAzLCAzXVxuICpcbiAqICAgICAgUi5jaGFpbihSLmFwcGVuZCwgUi5oZWFkKShbMSwgMiwgM10pOyAvLz0+IFsxLCAyLCAzLCAxXVxuICovXG52YXIgY2hhaW4gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoWydmYW50YXN5LWxhbmQvY2hhaW4nLCAnY2hhaW4nXSwgX3hjaGFpbiwgZnVuY3Rpb24gY2hhaW4oZm4sIG1vbmFkKSB7XG4gIGlmICh0eXBlb2YgbW9uYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBmbihtb25hZCh4KSkoeCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gX21ha2VGbGF0KGZhbHNlKShtYXAoZm4sIG1vbmFkKSk7XG59KSk7XG5leHBvcnQgZGVmYXVsdCBjaGFpbjsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIFJlc3RyaWN0cyBhIG51bWJlciB0byBiZSB3aXRoaW4gYSByYW5nZS5cbiAqXG4gKiBBbHNvIHdvcmtzIGZvciBvdGhlciBvcmRlcmVkIHR5cGVzIHN1Y2ggYXMgU3RyaW5ncyBhbmQgRGF0ZXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjAuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBhIC0+IGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5pbXVtIFRoZSBsb3dlciBsaW1pdCBvZiB0aGUgY2xhbXAgKGluY2x1c2l2ZSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhpbXVtIFRoZSB1cHBlciBsaW1pdCBvZiB0aGUgY2xhbXAgKGluY2x1c2l2ZSlcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBiZSBjbGFtcGVkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgYG1pbmltdW1gIHdoZW4gYHZhbCA8IG1pbmltdW1gLCBgbWF4aW11bWAgd2hlbiBgdmFsID4gbWF4aW11bWAsIHJldHVybnMgYHZhbGAgb3RoZXJ3aXNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5jbGFtcCgxLCAxMCwgLTUpIC8vID0+IDFcbiAqICAgICAgUi5jbGFtcCgxLCAxMCwgMTUpIC8vID0+IDEwXG4gKiAgICAgIFIuY2xhbXAoMSwgMTAsIDQpICAvLyA9PiA0XG4gKi9cbnZhciBjbGFtcCA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIGNsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICBpZiAobWluID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtaW4gbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIG1heCBpbiBjbGFtcChtaW4sIG1heCwgdmFsdWUpJyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgY2xhbXA7IiwiaW1wb3J0IF9jbG9uZSBmcm9tICcuL2ludGVybmFsL19jbG9uZSc7XG5pbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgdGhlIHZhbHVlIHdoaWNoIG1heSBjb250YWluIChuZXN0ZWQpIGBBcnJheWBzIGFuZFxuICogYE9iamVjdGBzLCBgTnVtYmVyYHMsIGBTdHJpbmdgcywgYEJvb2xlYW5gcyBhbmQgYERhdGVgcy4gYEZ1bmN0aW9uYHMgYXJlXG4gKiBhc3NpZ25lZCBieSByZWZlcmVuY2UgcmF0aGVyIHRoYW4gY29waWVkXG4gKlxuICogRGlzcGF0Y2hlcyB0byBhIGBjbG9uZWAgbWV0aG9kIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHsqfSAtPiB7Kn1cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG9iamVjdCBvciBhcnJheSB0byBjbG9uZVxuICogQHJldHVybiB7Kn0gQSBkZWVwbHkgY2xvbmVkIGNvcHkgb2YgYHZhbGBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgb2JqZWN0cyA9IFt7fSwge30sIHt9XTtcbiAqICAgICAgdmFyIG9iamVjdHNDbG9uZSA9IFIuY2xvbmUob2JqZWN0cyk7XG4gKiAgICAgIG9iamVjdHMgPT09IG9iamVjdHNDbG9uZTsgLy89PiBmYWxzZVxuICogICAgICBvYmplY3RzWzBdID09PSBvYmplY3RzQ2xvbmVbMF07IC8vPT4gZmFsc2VcbiAqL1xudmFyIGNsb25lID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLmNsb25lID09PSAnZnVuY3Rpb24nID8gdmFsdWUuY2xvbmUoKSA6IF9jbG9uZSh2YWx1ZSwgW10sIFtdLCB0cnVlKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgY2xvbmU7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcblxuLyoqXG4gKiBNYWtlcyBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gb3V0IG9mIGEgZnVuY3Rpb24gdGhhdCByZXBvcnRzIHdoZXRoZXIgdGhlIGZpcnN0XG4gKiBlbGVtZW50IGlzIGxlc3MgdGhhbiB0aGUgc2Vjb25kLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgoYSwgYikgLT4gQm9vbGVhbikgLT4gKChhLCBiKSAtPiBOdW1iZXIpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIGZ1bmN0aW9uIG9mIGFyaXR5IHR3byB3aGljaCB3aWxsIHJldHVybiBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIEZ1bmN0aW9uIDo6IGEgLT4gYiAtPiBJbnQgdGhhdCByZXR1cm5zIGAtMWAgaWYgYSA8IGIsIGAxYCBpZiBiIDwgYSwgb3RoZXJ3aXNlIGAwYFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBieUFnZSA9IFIuY29tcGFyYXRvcigoYSwgYikgPT4gYS5hZ2UgPCBiLmFnZSk7XG4gKiAgICAgIHZhciBwZW9wbGUgPSBbXG4gKiAgICAgICAgLy8gLi4uXG4gKiAgICAgIF07XG4gKiAgICAgIHZhciBwZW9wbGVCeUluY3JlYXNpbmdBZ2UgPSBSLnNvcnQoYnlBZ2UsIHBlb3BsZSk7XG4gKi9cbnZhciBjb21wYXJhdG9yID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gY29tcGFyYXRvcihwcmVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBwcmVkKGEsIGIpID8gLTEgOiBwcmVkKGIsIGEpID8gMSA6IDA7XG4gIH07XG59KTtcbmV4cG9ydCBkZWZhdWx0IGNvbXBhcmF0b3I7IiwiaW1wb3J0IGxpZnQgZnJvbSAnLi9saWZ0JztcbmltcG9ydCBub3QgZnJvbSAnLi9ub3QnO1xuXG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYGZgIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gYGdgIHN1Y2ggdGhhdCBpZiBjYWxsZWQgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHNcbiAqIHdoZW4gYGZgIHJldHVybnMgYSBcInRydXRoeVwiIHZhbHVlLCBgZ2AgcmV0dXJucyBgZmFsc2VgIGFuZCB3aGVuIGBmYCByZXR1cm5zIGEgXCJmYWxzeVwiIHZhbHVlIGBnYCByZXR1cm5zIGB0cnVlYC5cbiAqXG4gKiBgUi5jb21wbGVtZW50YCBtYXkgYmUgYXBwbGllZCB0byBhbnkgZnVuY3RvclxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEyLjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyAoKi4uLiAtPiAqKSAtPiAoKi4uLiAtPiBCb29sZWFuKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIubm90XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGlzTm90TmlsID0gUi5jb21wbGVtZW50KFIuaXNOaWwpO1xuICogICAgICBpc05pbChudWxsKTsgLy89PiB0cnVlXG4gKiAgICAgIGlzTm90TmlsKG51bGwpOyAvLz0+IGZhbHNlXG4gKiAgICAgIGlzTmlsKDcpOyAvLz0+IGZhbHNlXG4gKiAgICAgIGlzTm90TmlsKDcpOyAvLz0+IHRydWVcbiAqL1xudmFyIGNvbXBsZW1lbnQgPSAvKiNfX1BVUkVfXyovbGlmdChub3QpO1xuZXhwb3J0IGRlZmF1bHQgY29tcGxlbWVudDsiLCJpbXBvcnQgcGlwZSBmcm9tICcuL3BpcGUnO1xuaW1wb3J0IHJldmVyc2UgZnJvbSAnLi9yZXZlcnNlJztcblxuLyoqXG4gKiBQZXJmb3JtcyByaWdodC10by1sZWZ0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLiBUaGUgcmlnaHRtb3N0IGZ1bmN0aW9uIG1heSBoYXZlXG4gKiBhbnkgYXJpdHk7IHRoZSByZW1haW5pbmcgZnVuY3Rpb25zIG11c3QgYmUgdW5hcnkuXG4gKlxuICogKipOb3RlOioqIFRoZSByZXN1bHQgb2YgY29tcG9zZSBpcyBub3QgYXV0b21hdGljYWxseSBjdXJyaWVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgoeSAtPiB6KSwgKHggLT4geSksIC4uLiwgKG8gLT4gcCksICgoYSwgYiwgLi4uLCBuKSAtPiBvKSkgLT4gKChhLCBiLCAuLi4sIG4pIC0+IHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSAuLi5mdW5jdGlvbnMgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5waXBlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGNsYXNzeUdyZWV0aW5nID0gKGZpcnN0TmFtZSwgbGFzdE5hbWUpID0+IFwiVGhlIG5hbWUncyBcIiArIGxhc3ROYW1lICsgXCIsIFwiICsgZmlyc3ROYW1lICsgXCIgXCIgKyBsYXN0TmFtZVxuICogICAgICB2YXIgeWVsbEdyZWV0aW5nID0gUi5jb21wb3NlKFIudG9VcHBlciwgY2xhc3N5R3JlZXRpbmcpO1xuICogICAgICB5ZWxsR3JlZXRpbmcoJ0phbWVzJywgJ0JvbmQnKTsgLy89PiBcIlRIRSBOQU1FJ1MgQk9ORCwgSkFNRVMgQk9ORFwiXG4gKlxuICogICAgICBSLmNvbXBvc2UoTWF0aC5hYnMsIFIuYWRkKDEpLCBSLm11bHRpcGx5KDIpKSgtNCkgLy89PiA3XG4gKlxuICogQHN5bWIgUi5jb21wb3NlKGYsIGcsIGgpKGEsIGIpID0gZihnKGgoYSwgYikpKVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29tcG9zZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgfVxuICByZXR1cm4gcGlwZS5hcHBseSh0aGlzLCByZXZlcnNlKGFyZ3VtZW50cykpO1xufSIsImltcG9ydCBjaGFpbiBmcm9tICcuL2NoYWluJztcbmltcG9ydCBjb21wb3NlIGZyb20gJy4vY29tcG9zZSc7XG5pbXBvcnQgbWFwIGZyb20gJy4vbWFwJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByaWdodC10by1sZWZ0IEtsZWlzbGkgY29tcG9zaXRpb24gb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyxcbiAqIGVhY2ggb2Ygd2hpY2ggbXVzdCByZXR1cm4gYSB2YWx1ZSBvZiBhIHR5cGUgc3VwcG9ydGVkIGJ5IFtgY2hhaW5gXSgjY2hhaW4pLlxuICpcbiAqIGBSLmNvbXBvc2VLKGgsIGcsIGYpYCBpcyBlcXVpdmFsZW50IHRvIGBSLmNvbXBvc2UoUi5jaGFpbihoKSwgUi5jaGFpbihnKSwgZilgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBDaGFpbiBtID0+ICgoeSAtPiBtIHopLCAoeCAtPiBtIHkpLCAuLi4sIChhIC0+IG0gYikpIC0+IChhIC0+IG0geilcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IC4uLmZ1bmN0aW9ucyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSBSLnBpcGVLXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgIC8vICBnZXQgOjogU3RyaW5nIC0+IE9iamVjdCAtPiBNYXliZSAqXG4gKiAgICAgICB2YXIgZ2V0ID0gUi5jdXJyeSgocHJvcE5hbWUsIG9iaikgPT4gTWF5YmUob2JqW3Byb3BOYW1lXSkpXG4gKlxuICogICAgICAgLy8gIGdldFN0YXRlQ29kZSA6OiBNYXliZSBTdHJpbmcgLT4gTWF5YmUgU3RyaW5nXG4gKiAgICAgICB2YXIgZ2V0U3RhdGVDb2RlID0gUi5jb21wb3NlSyhcbiAqICAgICAgICAgUi5jb21wb3NlKE1heWJlLm9mLCBSLnRvVXBwZXIpLFxuICogICAgICAgICBnZXQoJ3N0YXRlJyksXG4gKiAgICAgICAgIGdldCgnYWRkcmVzcycpLFxuICogICAgICAgICBnZXQoJ3VzZXInKSxcbiAqICAgICAgICk7XG4gKiAgICAgICBnZXRTdGF0ZUNvZGUoe1widXNlclwiOntcImFkZHJlc3NcIjp7XCJzdGF0ZVwiOlwibnlcIn19fSk7IC8vPT4gTWF5YmUuSnVzdChcIk5ZXCIpXG4gKiAgICAgICBnZXRTdGF0ZUNvZGUoe30pOyAvLz0+IE1heWJlLk5vdGhpbmcoKVxuICogQHN5bWIgUi5jb21wb3NlSyhmLCBnLCBoKShhKSA9IFIuY2hhaW4oZiwgUi5jaGFpbihnLCBoKGEpKSlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcG9zZUsoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb21wb3NlSyByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgfVxuICB2YXIgaW5pdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIHZhciBsYXN0ID0gaW5pdC5wb3AoKTtcbiAgcmV0dXJuIGNvbXBvc2UoY29tcG9zZS5hcHBseSh0aGlzLCBtYXAoY2hhaW4sIGluaXQpKSwgbGFzdCk7XG59IiwiaW1wb3J0IHBpcGVQIGZyb20gJy4vcGlwZVAnO1xuaW1wb3J0IHJldmVyc2UgZnJvbSAnLi9yZXZlcnNlJztcblxuLyoqXG4gKiBQZXJmb3JtcyByaWdodC10by1sZWZ0IGNvbXBvc2l0aW9uIG9mIG9uZSBvciBtb3JlIFByb21pc2UtcmV0dXJuaW5nXG4gKiBmdW5jdGlvbnMuIFRoZSByaWdodG1vc3QgZnVuY3Rpb24gbWF5IGhhdmUgYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nXG4gKiBmdW5jdGlvbnMgbXVzdCBiZSB1bmFyeS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCh5IC0+IFByb21pc2UgeiksICh4IC0+IFByb21pc2UgeSksIC4uLiwgKGEgLT4gUHJvbWlzZSBiKSkgLT4gKGEgLT4gUHJvbWlzZSB6KVxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3Rpb25zIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIucGlwZVBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZGIgPSB7XG4gKiAgICAgICAgdXNlcnM6IHtcbiAqICAgICAgICAgIEpPRToge1xuICogICAgICAgICAgICBuYW1lOiAnSm9lJyxcbiAqICAgICAgICAgICAgZm9sbG93ZXJzOiBbJ1NURVZFJywgJ1NVWlknXVxuICogICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgICAgfVxuICpcbiAqICAgICAgLy8gV2UnbGwgcHJldGVuZCB0byBkbyBhIGRiIGxvb2t1cCB3aGljaCByZXR1cm5zIGEgcHJvbWlzZVxuICogICAgICB2YXIgbG9va3VwVXNlciA9ICh1c2VySWQpID0+IFByb21pc2UucmVzb2x2ZShkYi51c2Vyc1t1c2VySWRdKVxuICogICAgICB2YXIgbG9va3VwRm9sbG93ZXJzID0gKHVzZXIpID0+IFByb21pc2UucmVzb2x2ZSh1c2VyLmZvbGxvd2VycylcbiAqICAgICAgbG9va3VwVXNlcignSk9FJykudGhlbihsb29rdXBGb2xsb3dlcnMpXG4gKlxuICogICAgICAvLyAgZm9sbG93ZXJzRm9yVXNlciA6OiBTdHJpbmcgLT4gUHJvbWlzZSBbVXNlcklkXVxuICogICAgICB2YXIgZm9sbG93ZXJzRm9yVXNlciA9IFIuY29tcG9zZVAobG9va3VwRm9sbG93ZXJzLCBsb29rdXBVc2VyKTtcbiAqICAgICAgZm9sbG93ZXJzRm9yVXNlcignSk9FJykudGhlbihmb2xsb3dlcnMgPT4gY29uc29sZS5sb2coJ0ZvbGxvd2VyczonLCBmb2xsb3dlcnMpKVxuICogICAgICAvLyBGb2xsb3dlcnM6IFtcIlNURVZFXCIsXCJTVVpZXCJdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBvc2VQKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29tcG9zZVAgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gIH1cbiAgcmV0dXJuIHBpcGVQLmFwcGx5KHRoaXMsIHJldmVyc2UoYXJndW1lbnRzKSk7XG59IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfaXNBcnJheSBmcm9tICcuL2ludGVybmFsL19pc0FycmF5JztcbmltcG9ydCBfaXNGdW5jdGlvbiBmcm9tICcuL2ludGVybmFsL19pc0Z1bmN0aW9uJztcbmltcG9ydCBfaXNTdHJpbmcgZnJvbSAnLi9pbnRlcm5hbC9faXNTdHJpbmcnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsaXN0cyBvciBzdHJpbmdzLlxuICpcbiAqIE5vdGU6IGBSLmNvbmNhdGAgZXhwZWN0cyBib3RoIGFyZ3VtZW50cyB0byBiZSBvZiB0aGUgc2FtZSB0eXBlLFxuICogdW5saWtlIHRoZSBuYXRpdmUgYEFycmF5LnByb3RvdHlwZS5jb25jYXRgIG1ldGhvZC4gSXQgd2lsbCB0aHJvd1xuICogYW4gZXJyb3IgaWYgeW91IGBjb25jYXRgIGFuIEFycmF5IHdpdGggYSBub24tQXJyYXkgdmFsdWUuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGNvbmNhdGAgbWV0aG9kIG9mIHRoZSBmaXJzdCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqIENhbiBhbHNvIGNvbmNhdGVuYXRlIHR3byBtZW1iZXJzIG9mIGEgW2ZhbnRhc3ktbGFuZFxuICogY29tcGF0aWJsZSBzZW1pZ3JvdXBdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjc2VtaWdyb3VwKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gZmlyc3RMaXN0IFRoZSBmaXJzdCBsaXN0XG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gc2Vjb25kTGlzdCBUaGUgc2Vjb25kIGxpc3RcbiAqIEByZXR1cm4ge0FycmF5fFN0cmluZ30gQSBsaXN0IGNvbnNpc3Rpbmcgb2YgdGhlIGVsZW1lbnRzIG9mIGBmaXJzdExpc3RgIGZvbGxvd2VkIGJ5IHRoZSBlbGVtZW50cyBvZlxuICogYHNlY29uZExpc3RgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmNvbmNhdCgnQUJDJywgJ0RFRicpOyAvLyAnQUJDREVGJ1xuICogICAgICBSLmNvbmNhdChbNCwgNSwgNl0sIFsxLCAyLCAzXSk7IC8vPT4gWzQsIDUsIDYsIDEsIDIsIDNdXG4gKiAgICAgIFIuY29uY2F0KFtdLCBbXSk7IC8vPT4gW11cbiAqL1xudmFyIGNvbmNhdCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gIGlmIChfaXNBcnJheShhKSkge1xuICAgIGlmIChfaXNBcnJheShiKSkge1xuICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHRvU3RyaW5nKGIpICsgJyBpcyBub3QgYW4gYXJyYXknKTtcbiAgfVxuICBpZiAoX2lzU3RyaW5nKGEpKSB7XG4gICAgaWYgKF9pc1N0cmluZyhiKSkge1xuICAgICAgcmV0dXJuIGEgKyBiO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHRvU3RyaW5nKGIpICsgJyBpcyBub3QgYSBzdHJpbmcnKTtcbiAgfVxuICBpZiAoYSAhPSBudWxsICYmIF9pc0Z1bmN0aW9uKGFbJ2ZhbnRhc3ktbGFuZC9jb25jYXQnXSkpIHtcbiAgICByZXR1cm4gYVsnZmFudGFzeS1sYW5kL2NvbmNhdCddKGIpO1xuICB9XG4gIGlmIChhICE9IG51bGwgJiYgX2lzRnVuY3Rpb24oYS5jb25jYXQpKSB7XG4gICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IodG9TdHJpbmcoYSkgKyAnIGRvZXMgbm90IGhhdmUgYSBtZXRob2QgbmFtZWQgXCJjb25jYXRcIiBvciBcImZhbnRhc3ktbGFuZC9jb25jYXRcIicpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBjb25jYXQ7IiwiaW1wb3J0IF9hcml0eSBmcm9tICcuL2ludGVybmFsL19hcml0eSc7XG5pbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IG1hcCBmcm9tICcuL21hcCc7XG5pbXBvcnQgbWF4IGZyb20gJy4vbWF4JztcbmltcG9ydCByZWR1Y2UgZnJvbSAnLi9yZWR1Y2UnO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiwgYGZuYCwgd2hpY2ggZW5jYXBzdWxhdGVzIGBpZi9lbHNlLCBpZi9lbHNlLCAuLi5gIGxvZ2ljLlxuICogYFIuY29uZGAgdGFrZXMgYSBsaXN0IG9mIFtwcmVkaWNhdGUsIHRyYW5zZm9ybWVyXSBwYWlycy4gQWxsIG9mIHRoZSBhcmd1bWVudHNcbiAqIHRvIGBmbmAgYXJlIGFwcGxpZWQgdG8gZWFjaCBvZiB0aGUgcHJlZGljYXRlcyBpbiB0dXJuIHVudGlsIG9uZSByZXR1cm5zIGFcbiAqIFwidHJ1dGh5XCIgdmFsdWUsIGF0IHdoaWNoIHBvaW50IGBmbmAgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGl0c1xuICogYXJndW1lbnRzIHRvIHRoZSBjb3JyZXNwb25kaW5nIHRyYW5zZm9ybWVyLiBJZiBub25lIG9mIHRoZSBwcmVkaWNhdGVzXG4gKiBtYXRjaGVzLCBgZm5gIHJldHVybnMgdW5kZWZpbmVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjYuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIFtbKCouLi4gLT4gQm9vbGVhbiksKCouLi4gLT4gKildXSAtPiAoKi4uLiAtPiAqKVxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMgQSBsaXN0IG9mIFtwcmVkaWNhdGUsIHRyYW5zZm9ybWVyXVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGZuID0gUi5jb25kKFtcbiAqICAgICAgICBbUi5lcXVhbHMoMCksICAgUi5hbHdheXMoJ3dhdGVyIGZyZWV6ZXMgYXQgMMKwQycpXSxcbiAqICAgICAgICBbUi5lcXVhbHMoMTAwKSwgUi5hbHdheXMoJ3dhdGVyIGJvaWxzIGF0IDEwMMKwQycpXSxcbiAqICAgICAgICBbUi5ULCAgICAgICAgICAgdGVtcCA9PiAnbm90aGluZyBzcGVjaWFsIGhhcHBlbnMgYXQgJyArIHRlbXAgKyAnwrBDJ11cbiAqICAgICAgXSk7XG4gKiAgICAgIGZuKDApOyAvLz0+ICd3YXRlciBmcmVlemVzIGF0IDDCsEMnXG4gKiAgICAgIGZuKDUwKTsgLy89PiAnbm90aGluZyBzcGVjaWFsIGhhcHBlbnMgYXQgNTDCsEMnXG4gKiAgICAgIGZuKDEwMCk7IC8vPT4gJ3dhdGVyIGJvaWxzIGF0IDEwMMKwQydcbiAqL1xudmFyIGNvbmQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBjb25kKHBhaXJzKSB7XG4gIHZhciBhcml0eSA9IHJlZHVjZShtYXgsIDAsIG1hcChmdW5jdGlvbiAocGFpcikge1xuICAgIHJldHVybiBwYWlyWzBdLmxlbmd0aDtcbiAgfSwgcGFpcnMpKTtcbiAgcmV0dXJuIF9hcml0eShhcml0eSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZHggPSAwO1xuICAgIHdoaWxlIChpZHggPCBwYWlycy5sZW5ndGgpIHtcbiAgICAgIGlmIChwYWlyc1tpZHhdWzBdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIHBhaXJzW2lkeF1bMV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgfSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGNvbmQ7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBjb25zdHJ1Y3ROIGZyb20gJy4vY29uc3RydWN0Tic7XG5cbi8qKlxuICogV3JhcHMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBpbnNpZGUgYSBjdXJyaWVkIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZFxuICogd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMgYW5kIHJldHVybnMgdGhlIHNhbWUgdHlwZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKiAtPiB7Kn0pIC0+ICgqIC0+IHsqfSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0byB3cmFwLlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgd3JhcHBlZCwgY3VycmllZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqIEBzZWUgUi5pbnZva2VyXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gQ29uc3RydWN0b3IgZnVuY3Rpb25cbiAqICAgICAgZnVuY3Rpb24gQW5pbWFsKGtpbmQpIHtcbiAqICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICogICAgICB9O1xuICogICAgICBBbmltYWwucHJvdG90eXBlLnNpZ2h0aW5nID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgcmV0dXJuIFwiSXQncyBhIFwiICsgdGhpcy5raW5kICsgXCIhXCI7XG4gKiAgICAgIH1cbiAqXG4gKiAgICAgIHZhciBBbmltYWxDb25zdHJ1Y3RvciA9IFIuY29uc3RydWN0KEFuaW1hbClcbiAqXG4gKiAgICAgIC8vIE5vdGljZSB3ZSBubyBsb25nZXIgbmVlZCB0aGUgJ25ldycga2V5d29yZDpcbiAqICAgICAgQW5pbWFsQ29uc3RydWN0b3IoJ1BpZycpOyAvLz0+IHtcImtpbmRcIjogXCJQaWdcIiwgXCJzaWdodGluZ1wiOiBmdW5jdGlvbiAoKXsuLi59fTtcbiAqXG4gKiAgICAgIHZhciBhbmltYWxUeXBlcyA9IFtcIkxpb25cIiwgXCJUaWdlclwiLCBcIkJlYXJcIl07XG4gKiAgICAgIHZhciBhbmltYWxTaWdodGluZyA9IFIuaW52b2tlcigwLCAnc2lnaHRpbmcnKTtcbiAqICAgICAgdmFyIHNpZ2h0TmV3QW5pbWFsID0gUi5jb21wb3NlKGFuaW1hbFNpZ2h0aW5nLCBBbmltYWxDb25zdHJ1Y3Rvcik7XG4gKiAgICAgIFIubWFwKHNpZ2h0TmV3QW5pbWFsLCBhbmltYWxUeXBlcyk7IC8vPT4gW1wiSXQncyBhIExpb24hXCIsIFwiSXQncyBhIFRpZ2VyIVwiLCBcIkl0J3MgYSBCZWFyIVwiXVxuICovXG52YXIgY29uc3RydWN0ID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gY29uc3RydWN0KEZuKSB7XG4gIHJldHVybiBjb25zdHJ1Y3ROKEZuLmxlbmd0aCwgRm4pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBjb25zdHJ1Y3Q7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBjdXJyeSBmcm9tICcuL2N1cnJ5JztcbmltcG9ydCBuQXJ5IGZyb20gJy4vbkFyeSc7XG5cbi8qKlxuICogV3JhcHMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBpbnNpZGUgYSBjdXJyaWVkIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZFxuICogd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMgYW5kIHJldHVybnMgdGhlIHNhbWUgdHlwZS4gVGhlIGFyaXR5IG9mIHRoZSBmdW5jdGlvblxuICogcmV0dXJuZWQgaXMgc3BlY2lmaWVkIHRvIGFsbG93IHVzaW5nIHZhcmlhZGljIGNvbnN0cnVjdG9yIGZ1bmN0aW9ucy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC40LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBOdW1iZXIgLT4gKCogLT4geyp9KSAtPiAoKiAtPiB7Kn0pXG4gKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgYXJpdHkgb2YgdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gRm4gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSB3cmFwcGVkLCBjdXJyaWVkIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIC8vIFZhcmlhZGljIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gKiAgICAgIGZ1bmN0aW9uIFNhbGFkKCkge1xuICogICAgICAgIHRoaXMuaW5ncmVkaWVudHMgPSBhcmd1bWVudHM7XG4gKiAgICAgIH1cbiAqXG4gKiAgICAgIFNhbGFkLnByb3RvdHlwZS5yZWNpcGUgPSBmdW5jdGlvbigpIHtcbiAqICAgICAgICB2YXIgaW5zdHJ1Y3Rpb25zID0gUi5tYXAoaW5ncmVkaWVudCA9PiAnQWRkIGEgZG9sbG9wIG9mICcgKyBpbmdyZWRpZW50LCB0aGlzLmluZ3JlZGllbnRzKTtcbiAqICAgICAgICByZXR1cm4gUi5qb2luKCdcXG4nLCBpbnN0cnVjdGlvbnMpO1xuICogICAgICB9O1xuICpcbiAqICAgICAgdmFyIFRocmVlTGF5ZXJTYWxhZCA9IFIuY29uc3RydWN0TigzLCBTYWxhZCk7XG4gKlxuICogICAgICAvLyBOb3RpY2Ugd2Ugbm8gbG9uZ2VyIG5lZWQgdGhlICduZXcnIGtleXdvcmQsIGFuZCB0aGUgY29uc3RydWN0b3IgaXMgY3VycmllZCBmb3IgMyBhcmd1bWVudHMuXG4gKiAgICAgIHZhciBzYWxhZCA9IFRocmVlTGF5ZXJTYWxhZCgnTWF5b25uYWlzZScpKCdQb3RhdG8gQ2hpcHMnKSgnS2V0Y2h1cCcpO1xuICpcbiAqICAgICAgY29uc29sZS5sb2coc2FsYWQucmVjaXBlKCkpO1xuICogICAgICAvLyBBZGQgYSBkb2xsb3Agb2YgTWF5b25uYWlzZVxuICogICAgICAvLyBBZGQgYSBkb2xsb3Agb2YgUG90YXRvIENoaXBzXG4gKiAgICAgIC8vIEFkZCBhIGRvbGxvcCBvZiBLZXRjaHVwXG4gKi9cbnZhciBjb25zdHJ1Y3ROID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gY29uc3RydWN0TihuLCBGbikge1xuICBpZiAobiA+IDEwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJ1Y3RvciB3aXRoIGdyZWF0ZXIgdGhhbiB0ZW4gYXJndW1lbnRzJyk7XG4gIH1cbiAgaWYgKG4gPT09IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBGbigpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGN1cnJ5KG5BcnkobiwgZnVuY3Rpb24gKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDgsICQ5KSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBuZXcgRm4oJDApO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMik7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMpO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCk7XG4gICAgICBjYXNlIDY6XG4gICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0LCAkNSk7XG4gICAgICBjYXNlIDc6XG4gICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYpO1xuICAgICAgY2FzZSA4OlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNyk7XG4gICAgICBjYXNlIDk6XG4gICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYsICQ3LCAkOCk7XG4gICAgICBjYXNlIDEwOlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDgsICQ5KTtcbiAgICB9XG4gIH0pKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgY29uc3RydWN0TjsiLCJpbXBvcnQgX2NvbnRhaW5zIGZyb20gJy4vaW50ZXJuYWwvX2NvbnRhaW5zJztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBlcXVhbCwgaW4gW2BSLmVxdWFsc2BdKCNlcXVhbHMpXG4gKiB0ZXJtcywgdG8gYXQgbGVhc3Qgb25lIGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Q7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiBbYV0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIGl0ZW0gdG8gY29tcGFyZSBhZ2FpbnN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYW4gZXF1aXZhbGVudCBpdGVtIGlzIGluIHRoZSBsaXN0LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIEBzZWUgUi5hbnlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmNvbnRhaW5zKDMsIFsxLCAyLCAzXSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmNvbnRhaW5zKDQsIFsxLCAyLCAzXSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5jb250YWlucyh7IG5hbWU6ICdGcmVkJyB9LCBbeyBuYW1lOiAnRnJlZCcgfV0pOyAvLz0+IHRydWVcbiAqICAgICAgUi5jb250YWlucyhbNDJdLCBbWzQyXV0pOyAvLz0+IHRydWVcbiAqL1xudmFyIGNvbnRhaW5zID0gLyojX19QVVJFX18qL19jdXJyeTIoX2NvbnRhaW5zKTtcbmV4cG9ydCBkZWZhdWx0IGNvbnRhaW5zOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX21hcCBmcm9tICcuL2ludGVybmFsL19tYXAnO1xuaW1wb3J0IGN1cnJ5TiBmcm9tICcuL2N1cnJ5Tic7XG5pbXBvcnQgbWF4IGZyb20gJy4vbWF4JztcbmltcG9ydCBwbHVjayBmcm9tICcuL3BsdWNrJztcbmltcG9ydCByZWR1Y2UgZnJvbSAnLi9yZWR1Y2UnO1xuXG4vKipcbiAqIEFjY2VwdHMgYSBjb252ZXJnaW5nIGZ1bmN0aW9uIGFuZCBhIGxpc3Qgb2YgYnJhbmNoaW5nIGZ1bmN0aW9ucyBhbmQgcmV0dXJuc1xuICogYSBuZXcgZnVuY3Rpb24uIFdoZW4gaW52b2tlZCwgdGhpcyBuZXcgZnVuY3Rpb24gaXMgYXBwbGllZCB0byBzb21lXG4gKiBhcmd1bWVudHMsIGVhY2ggYnJhbmNoaW5nIGZ1bmN0aW9uIGlzIGFwcGxpZWQgdG8gdGhvc2Ugc2FtZSBhcmd1bWVudHMuIFRoZVxuICogcmVzdWx0cyBvZiBlYWNoIGJyYW5jaGluZyBmdW5jdGlvbiBhcmUgcGFzc2VkIGFzIGFyZ3VtZW50cyB0byB0aGUgY29udmVyZ2luZ1xuICogZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgcmV0dXJuIHZhbHVlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjQuMlxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgoeDEsIHgyLCAuLi4pIC0+IHopIC0+IFsoKGEsIGIsIC4uLikgLT4geDEpLCAoKGEsIGIsIC4uLikgLT4geDIpLCAuLi5dIC0+IChhIC0+IGIgLT4gLi4uIC0+IHopXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhZnRlciBBIGZ1bmN0aW9uLiBgYWZ0ZXJgIHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWVzIG9mXG4gKiAgICAgICAgYGZuMWAgYW5kIGBmbjJgIGFzIGl0cyBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge0FycmF5fSBmdW5jdGlvbnMgQSBsaXN0IG9mIGZ1bmN0aW9ucy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbi5cbiAqIEBzZWUgUi51c2VXaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGF2ZXJhZ2UgPSBSLmNvbnZlcmdlKFIuZGl2aWRlLCBbUi5zdW0sIFIubGVuZ3RoXSlcbiAqICAgICAgYXZlcmFnZShbMSwgMiwgMywgNCwgNSwgNiwgN10pIC8vPT4gNFxuICpcbiAqICAgICAgdmFyIHN0cmFuZ2VDb25jYXQgPSBSLmNvbnZlcmdlKFIuY29uY2F0LCBbUi50b1VwcGVyLCBSLnRvTG93ZXJdKVxuICogICAgICBzdHJhbmdlQ29uY2F0KFwiWW9kZWxcIikgLy89PiBcIllPREVMeW9kZWxcIlxuICpcbiAqIEBzeW1iIFIuY29udmVyZ2UoZiwgW2csIGhdKShhLCBiKSA9IGYoZyhhLCBiKSwgaChhLCBiKSlcbiAqL1xudmFyIGNvbnZlcmdlID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gY29udmVyZ2UoYWZ0ZXIsIGZucykge1xuICByZXR1cm4gY3VycnlOKHJlZHVjZShtYXgsIDAsIHBsdWNrKCdsZW5ndGgnLCBmbnMpKSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICByZXR1cm4gYWZ0ZXIuYXBwbHkoY29udGV4dCwgX21hcChmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9LCBmbnMpKTtcbiAgfSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGNvbnZlcmdlOyIsImltcG9ydCByZWR1Y2VCeSBmcm9tICcuL3JlZHVjZUJ5JztcblxuLyoqXG4gKiBDb3VudHMgdGhlIGVsZW1lbnRzIG9mIGEgbGlzdCBhY2NvcmRpbmcgdG8gaG93IG1hbnkgbWF0Y2ggZWFjaCB2YWx1ZSBvZiBhXG4gKiBrZXkgZ2VuZXJhdGVkIGJ5IHRoZSBzdXBwbGllZCBmdW5jdGlvbi4gUmV0dXJucyBhbiBvYmplY3QgbWFwcGluZyB0aGUga2V5c1xuICogcHJvZHVjZWQgYnkgYGZuYCB0byB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzIGluIHRoZSBsaXN0LiBOb3RlIHRoYXQgYWxsXG4gKiBrZXlzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgYmVjYXVzZSBvZiBob3cgSmF2YVNjcmlwdCBvYmplY3RzIHdvcmsuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIChhIC0+IFN0cmluZykgLT4gW2FdIC0+IHsqfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gbWFwIHZhbHVlcyB0byBrZXlzLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBjb3VudCBlbGVtZW50cyBmcm9tLlxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgbWFwcGluZyBrZXlzIHRvIG51bWJlciBvZiBvY2N1cnJlbmNlcyBpbiB0aGUgbGlzdC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbnVtYmVycyA9IFsxLjAsIDEuMSwgMS4yLCAyLjAsIDMuMCwgMi4yXTtcbiAqICAgICAgUi5jb3VudEJ5KE1hdGguZmxvb3IpKG51bWJlcnMpOyAgICAvLz0+IHsnMSc6IDMsICcyJzogMiwgJzMnOiAxfVxuICpcbiAqICAgICAgdmFyIGxldHRlcnMgPSBbJ2EnLCAnYicsICdBJywgJ2EnLCAnQicsICdjJ107XG4gKiAgICAgIFIuY291bnRCeShSLnRvTG93ZXIpKGxldHRlcnMpOyAgIC8vPT4geydhJzogMywgJ2InOiAyLCAnYyc6IDF9XG4gKi9cbnZhciBjb3VudEJ5ID0gLyojX19QVVJFX18qL3JlZHVjZUJ5KGZ1bmN0aW9uIChhY2MsIGVsZW0pIHtcbiAgcmV0dXJuIGFjYyArIDE7XG59LCAwKTtcbmV4cG9ydCBkZWZhdWx0IGNvdW50Qnk7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBjdXJyeU4gZnJvbSAnLi9jdXJyeU4nO1xuXG4vKipcbiAqIFJldHVybnMgYSBjdXJyaWVkIGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLiBUaGUgY3VycmllZCBmdW5jdGlvblxuICogaGFzIHR3byB1bnVzdWFsIGNhcGFiaWxpdGllcy4gRmlyc3QsIGl0cyBhcmd1bWVudHMgbmVlZG4ndCBiZSBwcm92aWRlZCBvbmVcbiAqIGF0IGEgdGltZS4gSWYgYGZgIGlzIGEgdGVybmFyeSBmdW5jdGlvbiBhbmQgYGdgIGlzIGBSLmN1cnJ5KGYpYCwgdGhlXG4gKiBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEpKDIpKDMpYFxuICogICAtIGBnKDEpKDIsIDMpYFxuICogICAtIGBnKDEsIDIpKDMpYFxuICogICAtIGBnKDEsIDIsIDMpYFxuICpcbiAqIFNlY29uZGx5LCB0aGUgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSBbYFIuX19gXSgjX18pIG1heSBiZSB1c2VkIHRvIHNwZWNpZnlcbiAqIFwiZ2Fwc1wiLCBhbGxvd2luZyBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMsXG4gKiByZWdhcmRsZXNzIG9mIHRoZWlyIHBvc2l0aW9ucy4gSWYgYGdgIGlzIGFzIGFib3ZlIGFuZCBgX2AgaXMgW2BSLl9fYF0oI19fKSxcbiAqIHRoZSBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEsIDIsIDMpYFxuICogICAtIGBnKF8sIDIsIDMpKDEpYFxuICogICAtIGBnKF8sIF8sIDMpKDEpKDIpYFxuICogICAtIGBnKF8sIF8sIDMpKDEsIDIpYFxuICogICAtIGBnKF8sIDIpKDEpKDMpYFxuICogICAtIGBnKF8sIDIpKDEsIDMpYFxuICogICAtIGBnKF8sIDIpKF8sIDMpKDEpYFxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgqIC0+IGEpIC0+ICgqIC0+IGEpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcsIGN1cnJpZWQgZnVuY3Rpb24uXG4gKiBAc2VlIFIuY3VycnlOXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGFkZEZvdXJOdW1iZXJzID0gKGEsIGIsIGMsIGQpID0+IGEgKyBiICsgYyArIGQ7XG4gKlxuICogICAgICB2YXIgY3VycmllZEFkZEZvdXJOdW1iZXJzID0gUi5jdXJyeShhZGRGb3VyTnVtYmVycyk7XG4gKiAgICAgIHZhciBmID0gY3VycmllZEFkZEZvdXJOdW1iZXJzKDEsIDIpO1xuICogICAgICB2YXIgZyA9IGYoMyk7XG4gKiAgICAgIGcoNCk7IC8vPT4gMTBcbiAqL1xudmFyIGN1cnJ5ID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gY3VycnkoZm4pIHtcbiAgcmV0dXJuIGN1cnJ5Tihmbi5sZW5ndGgsIGZuKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgY3Vycnk7IiwiaW1wb3J0IF9hcml0eSBmcm9tICcuL2ludGVybmFsL19hcml0eSc7XG5pbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfY3VycnlOIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Tic7XG5cbi8qKlxuICogUmV0dXJucyBhIGN1cnJpZWQgZXF1aXZhbGVudCBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24sIHdpdGggdGhlIHNwZWNpZmllZFxuICogYXJpdHkuIFRoZSBjdXJyaWVkIGZ1bmN0aW9uIGhhcyB0d28gdW51c3VhbCBjYXBhYmlsaXRpZXMuIEZpcnN0LCBpdHNcbiAqIGFyZ3VtZW50cyBuZWVkbid0IGJlIHByb3ZpZGVkIG9uZSBhdCBhIHRpbWUuIElmIGBnYCBpcyBgUi5jdXJyeU4oMywgZilgLCB0aGVcbiAqIGZvbGxvd2luZyBhcmUgZXF1aXZhbGVudDpcbiAqXG4gKiAgIC0gYGcoMSkoMikoMylgXG4gKiAgIC0gYGcoMSkoMiwgMylgXG4gKiAgIC0gYGcoMSwgMikoMylgXG4gKiAgIC0gYGcoMSwgMiwgMylgXG4gKlxuICogU2Vjb25kbHksIHRoZSBzcGVjaWFsIHBsYWNlaG9sZGVyIHZhbHVlIFtgUi5fX2BdKCNfXykgbWF5IGJlIHVzZWQgdG8gc3BlY2lmeVxuICogXCJnYXBzXCIsIGFsbG93aW5nIHBhcnRpYWwgYXBwbGljYXRpb24gb2YgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyxcbiAqIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgcG9zaXRpb25zLiBJZiBgZ2AgaXMgYXMgYWJvdmUgYW5kIGBfYCBpcyBbYFIuX19gXSgjX18pLFxuICogdGhlIGZvbGxvd2luZyBhcmUgZXF1aXZhbGVudDpcbiAqXG4gKiAgIC0gYGcoMSwgMiwgMylgXG4gKiAgIC0gYGcoXywgMiwgMykoMSlgXG4gKiAgIC0gYGcoXywgXywgMykoMSkoMilgXG4gKiAgIC0gYGcoXywgXywgMykoMSwgMilgXG4gKiAgIC0gYGcoXywgMikoMSkoMylgXG4gKiAgIC0gYGcoXywgMikoMSwgMylgXG4gKiAgIC0gYGcoXywgMikoXywgMykoMSlgXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgTnVtYmVyIC0+ICgqIC0+IGEpIC0+ICgqIC0+IGEpXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBmb3IgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3LCBjdXJyaWVkIGZ1bmN0aW9uLlxuICogQHNlZSBSLmN1cnJ5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHN1bUFyZ3MgPSAoLi4uYXJncykgPT4gUi5zdW0oYXJncyk7XG4gKlxuICogICAgICB2YXIgY3VycmllZEFkZEZvdXJOdW1iZXJzID0gUi5jdXJyeU4oNCwgc3VtQXJncyk7XG4gKiAgICAgIHZhciBmID0gY3VycmllZEFkZEZvdXJOdW1iZXJzKDEsIDIpO1xuICogICAgICB2YXIgZyA9IGYoMyk7XG4gKiAgICAgIGcoNCk7IC8vPT4gMTBcbiAqL1xudmFyIGN1cnJ5TiA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGN1cnJ5TihsZW5ndGgsIGZuKSB7XG4gIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gX2N1cnJ5MShmbik7XG4gIH1cbiAgcmV0dXJuIF9hcml0eShsZW5ndGgsIF9jdXJyeU4obGVuZ3RoLCBbXSwgZm4pKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgY3VycnlOOyIsImltcG9ydCBhZGQgZnJvbSAnLi9hZGQnO1xuXG4vKipcbiAqIERlY3JlbWVudHMgaXRzIGFyZ3VtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge051bWJlcn0gbiAtIDFcbiAqIEBzZWUgUi5pbmNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmRlYyg0Mik7IC8vPT4gNDFcbiAqL1xudmFyIGRlYyA9IC8qI19fUFVSRV9fKi9hZGQoLTEpO1xuZXhwb3J0IGRlZmF1bHQgZGVjOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2Vjb25kIGFyZ3VtZW50IGlmIGl0IGlzIG5vdCBgbnVsbGAsIGB1bmRlZmluZWRgIG9yIGBOYU5gO1xuICogb3RoZXJ3aXNlIHRoZSBmaXJzdCBhcmd1bWVudCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgYSAtPiBiIC0+IGEgfCBiXG4gKiBAcGFyYW0ge2F9IGRlZmF1bHQgVGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0ge2J9IHZhbCBgdmFsYCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgYGRlZmF1bHRgIHVubGVzcyBgdmFsYCBpcyBgbnVsbGAsIGB1bmRlZmluZWRgIG9yIGBOYU5gLlxuICogQHJldHVybiB7Kn0gVGhlIHNlY29uZCB2YWx1ZSBpZiBpdCBpcyBub3QgYG51bGxgLCBgdW5kZWZpbmVkYCBvciBgTmFOYCwgb3RoZXJ3aXNlIHRoZSBkZWZhdWx0IHZhbHVlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGRlZmF1bHRUbzQyID0gUi5kZWZhdWx0VG8oNDIpO1xuICpcbiAqICAgICAgZGVmYXVsdFRvNDIobnVsbCk7ICAvLz0+IDQyXG4gKiAgICAgIGRlZmF1bHRUbzQyKHVuZGVmaW5lZCk7ICAvLz0+IDQyXG4gKiAgICAgIGRlZmF1bHRUbzQyKCdSYW1kYScpOyAgLy89PiAnUmFtZGEnXG4gKiAgICAgIC8vIHBhcnNlSW50KCdzdHJpbmcnKSByZXN1bHRzIGluIE5hTlxuICogICAgICBkZWZhdWx0VG80MihwYXJzZUludCgnc3RyaW5nJykpOyAvLz0+IDQyXG4gKi9cbnZhciBkZWZhdWx0VG8gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBkZWZhdWx0VG8oZCwgdikge1xuICByZXR1cm4gdiA9PSBudWxsIHx8IHYgIT09IHYgPyBkIDogdjtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdFRvOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8qKlxuICogTWFrZXMgYSBkZXNjZW5kaW5nIGNvbXBhcmF0b3IgZnVuY3Rpb24gb3V0IG9mIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdmFsdWVcbiAqIHRoYXQgY2FuIGJlIGNvbXBhcmVkIHdpdGggYDxgIGFuZCBgPmAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjMuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE9yZCBiID0+IChhIC0+IGIpIC0+IGEgLT4gYSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gb2YgYXJpdHkgb25lIHRoYXQgcmV0dXJucyBhIHZhbHVlIHRoYXQgY2FuIGJlIGNvbXBhcmVkXG4gKiBAcGFyYW0geyp9IGEgVGhlIGZpcnN0IGl0ZW0gdG8gYmUgY29tcGFyZWQuXG4gKiBAcGFyYW0geyp9IGIgVGhlIHNlY29uZCBpdGVtIHRvIGJlIGNvbXBhcmVkLlxuICogQHJldHVybiB7TnVtYmVyfSBgLTFgIGlmIGZuKGEpID4gZm4oYiksIGAxYCBpZiBmbihiKSA+IGZuKGEpLCBvdGhlcndpc2UgYDBgXG4gKiBAc2VlIFIuYXNjZW5kXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGJ5QWdlID0gUi5kZXNjZW5kKFIucHJvcCgnYWdlJykpO1xuICogICAgICB2YXIgcGVvcGxlID0gW1xuICogICAgICAgIC8vIC4uLlxuICogICAgICBdO1xuICogICAgICB2YXIgcGVvcGxlQnlPbGRlc3RGaXJzdCA9IFIuc29ydChieUFnZSwgcGVvcGxlKTtcbiAqL1xudmFyIGRlc2NlbmQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBkZXNjZW5kKGZuLCBhLCBiKSB7XG4gIHZhciBhYSA9IGZuKGEpO1xuICB2YXIgYmIgPSBmbihiKTtcbiAgcmV0dXJuIGFhID4gYmIgPyAtMSA6IGFhIDwgYmIgPyAxIDogMDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgZGVzY2VuZDsiLCJpbXBvcnQgX2NvbnRhaW5zIGZyb20gJy4vaW50ZXJuYWwvX2NvbnRhaW5zJztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogRmluZHMgdGhlIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBvZiBhbGwgZWxlbWVudHMgaW4gdGhlIGZpcnN0IGxpc3Qgbm90XG4gKiBjb250YWluZWQgaW4gdGhlIHNlY29uZCBsaXN0LiBPYmplY3RzIGFuZCBBcnJheXMgYXJlIGNvbXBhcmVkIGluIHRlcm1zIG9mXG4gKiB2YWx1ZSBlcXVhbGl0eSwgbm90IHJlZmVyZW5jZSBlcXVhbGl0eS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBbKl0gLT4gWypdIC0+IFsqXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIGZpcnN0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGVsZW1lbnRzIGluIGBsaXN0MWAgdGhhdCBhcmUgbm90IGluIGBsaXN0MmAuXG4gKiBAc2VlIFIuZGlmZmVyZW5jZVdpdGgsIFIuc3ltbWV0cmljRGlmZmVyZW5jZSwgUi5zeW1tZXRyaWNEaWZmZXJlbmNlV2l0aCwgUi53aXRob3V0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5kaWZmZXJlbmNlKFsxLDIsMyw0XSwgWzcsNiw1LDQsM10pOyAvLz0+IFsxLDJdXG4gKiAgICAgIFIuZGlmZmVyZW5jZShbNyw2LDUsNCwzXSwgWzEsMiwzLDRdKTsgLy89PiBbNyw2LDVdXG4gKiAgICAgIFIuZGlmZmVyZW5jZShbe2E6IDF9LCB7YjogMn1dLCBbe2E6IDF9LCB7YzogM31dKSAvLz0+IFt7YjogMn1dXG4gKi9cbnZhciBkaWZmZXJlbmNlID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gZGlmZmVyZW5jZShmaXJzdCwgc2Vjb25kKSB7XG4gIHZhciBvdXQgPSBbXTtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBmaXJzdExlbiA9IGZpcnN0Lmxlbmd0aDtcbiAgd2hpbGUgKGlkeCA8IGZpcnN0TGVuKSB7XG4gICAgaWYgKCFfY29udGFpbnMoZmlyc3RbaWR4XSwgc2Vjb25kKSAmJiAhX2NvbnRhaW5zKGZpcnN0W2lkeF0sIG91dCkpIHtcbiAgICAgIG91dFtvdXQubGVuZ3RoXSA9IGZpcnN0W2lkeF07XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBvdXQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGRpZmZlcmVuY2U7IiwiaW1wb3J0IF9jb250YWluc1dpdGggZnJvbSAnLi9pbnRlcm5hbC9fY29udGFpbnNXaXRoJztcbmltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8qKlxuICogRmluZHMgdGhlIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBvZiBhbGwgZWxlbWVudHMgaW4gdGhlIGZpcnN0IGxpc3Qgbm90XG4gKiBjb250YWluZWQgaW4gdGhlIHNlY29uZCBsaXN0LiBEdXBsaWNhdGlvbiBpcyBkZXRlcm1pbmVkIGFjY29yZGluZyB0byB0aGVcbiAqIHZhbHVlIHJldHVybmVkIGJ5IGFwcGx5aW5nIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgdG8gdHdvIGxpc3QgZWxlbWVudHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgKChhLCBhKSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB1c2VkIHRvIHRlc3Qgd2hldGhlciB0d28gaXRlbXMgYXJlIGVxdWFsLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIGZpcnN0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGVsZW1lbnRzIGluIGBsaXN0MWAgdGhhdCBhcmUgbm90IGluIGBsaXN0MmAuXG4gKiBAc2VlIFIuZGlmZmVyZW5jZSwgUi5zeW1tZXRyaWNEaWZmZXJlbmNlLCBSLnN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGNtcCA9ICh4LCB5KSA9PiB4LmEgPT09IHkuYTtcbiAqICAgICAgdmFyIGwxID0gW3thOiAxfSwge2E6IDJ9LCB7YTogM31dO1xuICogICAgICB2YXIgbDIgPSBbe2E6IDN9LCB7YTogNH1dO1xuICogICAgICBSLmRpZmZlcmVuY2VXaXRoKGNtcCwgbDEsIGwyKTsgLy89PiBbe2E6IDF9LCB7YTogMn1dXG4gKi9cbnZhciBkaWZmZXJlbmNlV2l0aCA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIGRpZmZlcmVuY2VXaXRoKHByZWQsIGZpcnN0LCBzZWNvbmQpIHtcbiAgdmFyIG91dCA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGZpcnN0TGVuID0gZmlyc3QubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgZmlyc3RMZW4pIHtcbiAgICBpZiAoIV9jb250YWluc1dpdGgocHJlZCwgZmlyc3RbaWR4XSwgc2Vjb25kKSAmJiAhX2NvbnRhaW5zV2l0aChwcmVkLCBmaXJzdFtpZHhdLCBvdXQpKSB7XG4gICAgICBvdXQucHVzaChmaXJzdFtpZHhdKTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgZGlmZmVyZW5jZVdpdGg7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB0aGF0IGRvZXMgbm90IGNvbnRhaW4gYSBgcHJvcGAgcHJvcGVydHkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBTdHJpbmcgLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGRpc3NvY2lhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjbG9uZVxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBvYmplY3QgZXF1aXZhbGVudCB0byB0aGUgb3JpZ2luYWwgYnV0IHdpdGhvdXQgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eVxuICogQHNlZSBSLmFzc29jXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5kaXNzb2MoJ2InLCB7YTogMSwgYjogMiwgYzogM30pOyAvLz0+IHthOiAxLCBjOiAzfVxuICovXG52YXIgZGlzc29jID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gZGlzc29jKHByb3AsIG9iaikge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZvciAodmFyIHAgaW4gb2JqKSB7XG4gICAgcmVzdWx0W3BdID0gb2JqW3BdO1xuICB9XG4gIGRlbGV0ZSByZXN1bHRbcHJvcF07XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGRpc3NvYzsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9pc0ludGVnZXIgZnJvbSAnLi9pbnRlcm5hbC9faXNJbnRlZ2VyJztcbmltcG9ydCBhc3NvYyBmcm9tICcuL2Fzc29jJztcbmltcG9ydCBkaXNzb2MgZnJvbSAnLi9kaXNzb2MnO1xuaW1wb3J0IHJlbW92ZSBmcm9tICcuL3JlbW92ZSc7XG5pbXBvcnQgdXBkYXRlIGZyb20gJy4vdXBkYXRlJztcblxuLyoqXG4gKiBNYWtlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYW4gb2JqZWN0LCBvbWl0dGluZyB0aGUgcHJvcGVydHkgYXQgdGhlIGdpdmVuIHBhdGguXG4gKiBOb3RlIHRoYXQgdGhpcyBjb3BpZXMgYW5kIGZsYXR0ZW5zIHByb3RvdHlwZSBwcm9wZXJ0aWVzIG9udG8gdGhlIG5ldyBvYmplY3RcbiAqIGFzIHdlbGwuIEFsbCBub24tcHJpbWl0aXZlIHByb3BlcnRpZXMgYXJlIGNvcGllZCBieSByZWZlcmVuY2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIElkeCA9IFN0cmluZyB8IEludFxuICogQHNpZyBbSWR4XSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIHRoZSB2YWx1ZSB0byBvbWl0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IHdpdGhvdXQgdGhlIHByb3BlcnR5IGF0IHBhdGhcbiAqIEBzZWUgUi5hc3NvY1BhdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmRpc3NvY1BhdGgoWydhJywgJ2InLCAnYyddLCB7YToge2I6IHtjOiA0Mn19fSk7IC8vPT4ge2E6IHtiOiB7fX19XG4gKi9cbnZhciBkaXNzb2NQYXRoID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gZGlzc29jUGF0aChwYXRoLCBvYmopIHtcbiAgc3dpdGNoIChwYXRoLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBvYmo7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIF9pc0ludGVnZXIocGF0aFswXSkgPyByZW1vdmUocGF0aFswXSwgMSwgb2JqKSA6IGRpc3NvYyhwYXRoWzBdLCBvYmopO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgaGVhZCA9IHBhdGhbMF07XG4gICAgICB2YXIgdGFpbCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHBhdGgsIDEpO1xuICAgICAgaWYgKG9ialtoZWFkXSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9IGVsc2UgaWYgKF9pc0ludGVnZXIocGF0aFswXSkpIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZShoZWFkLCBkaXNzb2NQYXRoKHRhaWwsIG9ialtoZWFkXSksIG9iaik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXNzb2MoaGVhZCwgZGlzc29jUGF0aCh0YWlsLCBvYmpbaGVhZF0pLCBvYmopO1xuICAgICAgfVxuICB9XG59KTtcbmV4cG9ydCBkZWZhdWx0IGRpc3NvY1BhdGg7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBEaXZpZGVzIHR3byBudW1iZXJzLiBFcXVpdmFsZW50IHRvIGBhIC8gYmAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCB2YWx1ZS5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc3VsdCBvZiBgYSAvIGJgLlxuICogQHNlZSBSLm11bHRpcGx5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5kaXZpZGUoNzEsIDEwMCk7IC8vPT4gMC43MVxuICpcbiAqICAgICAgdmFyIGhhbGYgPSBSLmRpdmlkZShSLl9fLCAyKTtcbiAqICAgICAgaGFsZig0Mik7IC8vPT4gMjFcbiAqXG4gKiAgICAgIHZhciByZWNpcHJvY2FsID0gUi5kaXZpZGUoMSk7XG4gKiAgICAgIHJlY2lwcm9jYWwoNCk7ICAgLy89PiAwLjI1XG4gKi9cbnZhciBkaXZpZGUgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBkaXZpZGUoYSwgYikge1xuICByZXR1cm4gYSAvIGI7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGRpdmlkZTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfeGRyb3AgZnJvbSAnLi9pbnRlcm5hbC9feGRyb3AnO1xuaW1wb3J0IHNsaWNlIGZyb20gJy4vc2xpY2UnO1xuXG4vKipcbiAqIFJldHVybnMgYWxsIGJ1dCB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBsaXN0LCBzdHJpbmcsIG9yXG4gKiB0cmFuc2R1Y2VyL3RyYW5zZm9ybWVyIChvciBvYmplY3Qgd2l0aCBhIGBkcm9wYCBtZXRob2QpLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBkcm9wYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfSBBIGNvcHkgb2YgbGlzdCB3aXRob3V0IHRoZSBmaXJzdCBgbmAgZWxlbWVudHNcbiAqIEBzZWUgUi50YWtlLCBSLnRyYW5zZHVjZSwgUi5kcm9wTGFzdCwgUi5kcm9wV2hpbGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmRyb3AoMSwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2JhcicsICdiYXonXVxuICogICAgICBSLmRyb3AoMiwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2JheiddXG4gKiAgICAgIFIuZHJvcCgzLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFtdXG4gKiAgICAgIFIuZHJvcCg0LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFtdXG4gKiAgICAgIFIuZHJvcCgzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAvLz0+ICdkYSdcbiAqL1xudmFyIGRyb3AgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoWydkcm9wJ10sIF94ZHJvcCwgZnVuY3Rpb24gZHJvcChuLCB4cykge1xuICByZXR1cm4gc2xpY2UoTWF0aC5tYXgoMCwgbiksIEluZmluaXR5LCB4cyk7XG59KSk7XG5leHBvcnQgZGVmYXVsdCBkcm9wOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tICcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnO1xuaW1wb3J0IF9kcm9wTGFzdCBmcm9tICcuL2ludGVybmFsL19kcm9wTGFzdCc7XG5pbXBvcnQgX3hkcm9wTGFzdCBmcm9tICcuL2ludGVybmFsL194ZHJvcExhc3QnO1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IGNvbnRhaW5pbmcgYWxsIGJ1dCB0aGUgbGFzdCBgbmAgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGBsaXN0YC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBgbGlzdGAgdG8gc2tpcC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3Qgb2YgZWxlbWVudHMgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBjb3B5IG9mIHRoZSBsaXN0IHdpdGggb25seSB0aGUgZmlyc3QgYGxpc3QubGVuZ3RoIC0gbmAgZWxlbWVudHNcbiAqIEBzZWUgUi50YWtlTGFzdCwgUi5kcm9wLCBSLmRyb3BXaGlsZSwgUi5kcm9wTGFzdFdoaWxlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5kcm9wTGFzdCgxLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhciddXG4gKiAgICAgIFIuZHJvcExhc3QoMiwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbyddXG4gKiAgICAgIFIuZHJvcExhc3QoMywgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbXVxuICogICAgICBSLmRyb3BMYXN0KDQsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gW11cbiAqICAgICAgUi5kcm9wTGFzdCgzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAvLz0+ICdyYSdcbiAqL1xudmFyIGRyb3BMYXN0ID0gLyojX19QVVJFX18qL19jdXJyeTIoIC8qI19fUFVSRV9fKi9fZGlzcGF0Y2hhYmxlKFtdLCBfeGRyb3BMYXN0LCBfZHJvcExhc3QpKTtcbmV4cG9ydCBkZWZhdWx0IGRyb3BMYXN0OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tICcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnO1xuaW1wb3J0IF9kcm9wTGFzdFdoaWxlIGZyb20gJy4vaW50ZXJuYWwvX2Ryb3BMYXN0V2hpbGUnO1xuaW1wb3J0IF94ZHJvcExhc3RXaGlsZSBmcm9tICcuL2ludGVybmFsL194ZHJvcExhc3RXaGlsZSc7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGV4Y2x1ZGluZyBhbGwgdGhlIHRhaWxpbmcgZWxlbWVudHMgb2YgYSBnaXZlbiBsaXN0IHdoaWNoXG4gKiBzYXRpc2Z5IHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgZnVuY3Rpb24uIEl0IHBhc3NlcyBlYWNoIHZhbHVlIGZyb20gdGhlIHJpZ2h0XG4gKiB0byB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIGZ1bmN0aW9uLCBza2lwcGluZyBlbGVtZW50cyB1bnRpbCB0aGUgcHJlZGljYXRlXG4gKiBmdW5jdGlvbiByZXR1cm5zIGEgYGZhbHN5YCB2YWx1ZS4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIG9uZSBhcmd1bWVudDpcbiAqICoodmFsdWUpKi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGVhY2ggZWxlbWVudFxuICogQHBhcmFtIHtBcnJheX0geHMgVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5IHdpdGhvdXQgYW55IHRyYWlsaW5nIGVsZW1lbnRzIHRoYXQgcmV0dXJuIGBmYWxzeWAgdmFsdWVzIGZyb20gdGhlIGBwcmVkaWNhdGVgLlxuICogQHNlZSBSLnRha2VMYXN0V2hpbGUsIFIuYWRkSW5kZXgsIFIuZHJvcCwgUi5kcm9wV2hpbGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbHRlVGhyZWUgPSB4ID0+IHggPD0gMztcbiAqXG4gKiAgICAgIFIuZHJvcExhc3RXaGlsZShsdGVUaHJlZSwgWzEsIDIsIDMsIDQsIDMsIDIsIDFdKTsgLy89PiBbMSwgMiwgMywgNF1cbiAqXG4gKiAgICAgIFIuZHJvcExhc3RXaGlsZSh4ID0+IHggIT09ICdkJyAsICdSYW1kYScpOyAvLz0+ICdSYW1kJ1xuICovXG52YXIgZHJvcExhc3RXaGlsZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovX2Rpc3BhdGNoYWJsZShbXSwgX3hkcm9wTGFzdFdoaWxlLCBfZHJvcExhc3RXaGlsZSkpO1xuZXhwb3J0IGRlZmF1bHQgZHJvcExhc3RXaGlsZTsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfeGRyb3BSZXBlYXRzV2l0aCBmcm9tICcuL2ludGVybmFsL194ZHJvcFJlcGVhdHNXaXRoJztcbmltcG9ydCBkcm9wUmVwZWF0c1dpdGggZnJvbSAnLi9kcm9wUmVwZWF0c1dpdGgnO1xuaW1wb3J0IGVxdWFscyBmcm9tICcuL2VxdWFscyc7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IHdpdGhvdXQgYW55IGNvbnNlY3V0aXZlbHkgcmVwZWF0aW5nIGVsZW1lbnRzLlxuICogW2BSLmVxdWFsc2BdKCNlcXVhbHMpIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBgbGlzdGAgd2l0aG91dCByZXBlYXRpbmcgZWxlbWVudHMuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICBSLmRyb3BSZXBlYXRzKFsxLCAxLCAxLCAyLCAzLCA0LCA0LCAyLCAyXSk7IC8vPT4gWzEsIDIsIDMsIDQsIDJdXG4gKi9cbnZhciBkcm9wUmVwZWF0cyA9IC8qI19fUFVSRV9fKi9fY3VycnkxKCAvKiNfX1BVUkVfXyovX2Rpc3BhdGNoYWJsZShbXSwgLyojX19QVVJFX18qL194ZHJvcFJlcGVhdHNXaXRoKGVxdWFscyksIC8qI19fUFVSRV9fKi9kcm9wUmVwZWF0c1dpdGgoZXF1YWxzKSkpO1xuZXhwb3J0IGRlZmF1bHQgZHJvcFJlcGVhdHM7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZSc7XG5pbXBvcnQgX3hkcm9wUmVwZWF0c1dpdGggZnJvbSAnLi9pbnRlcm5hbC9feGRyb3BSZXBlYXRzV2l0aCc7XG5pbXBvcnQgbGFzdCBmcm9tICcuL2xhc3QnO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCB3aXRob3V0IGFueSBjb25zZWN1dGl2ZWx5IHJlcGVhdGluZyBlbGVtZW50cy4gRXF1YWxpdHkgaXNcbiAqIGRldGVybWluZWQgYnkgYXBwbHlpbmcgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSB0byBlYWNoIHBhaXIgb2YgY29uc2VjdXRpdmUgZWxlbWVudHMuIFRoZVxuICogZmlyc3QgZWxlbWVudCBpbiBhIHNlcmllcyBvZiBlcXVhbCBlbGVtZW50cyB3aWxsIGJlIHByZXNlcnZlZC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhLCBhKSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHVzZWQgdG8gdGVzdCB3aGV0aGVyIHR3byBpdGVtcyBhcmUgZXF1YWwuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBgbGlzdGAgd2l0aG91dCByZXBlYXRpbmcgZWxlbWVudHMuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGwgPSBbMSwgLTEsIDEsIDMsIDQsIC00LCAtNCwgLTUsIDUsIDMsIDNdO1xuICogICAgICBSLmRyb3BSZXBlYXRzV2l0aChSLmVxQnkoTWF0aC5hYnMpLCBsKTsgLy89PiBbMSwgMywgNCwgLTUsIDNdXG4gKi9cbnZhciBkcm9wUmVwZWF0c1dpdGggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoW10sIF94ZHJvcFJlcGVhdHNXaXRoLCBmdW5jdGlvbiBkcm9wUmVwZWF0c1dpdGgocHJlZCwgbGlzdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpZHggPSAxO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIGlmIChsZW4gIT09IDApIHtcbiAgICByZXN1bHRbMF0gPSBsaXN0WzBdO1xuICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgIGlmICghcHJlZChsYXN0KHJlc3VsdCksIGxpc3RbaWR4XSkpIHtcbiAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gbGlzdFtpZHhdO1xuICAgICAgfVxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KSk7XG5leHBvcnQgZGVmYXVsdCBkcm9wUmVwZWF0c1dpdGg7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZSc7XG5pbXBvcnQgX3hkcm9wV2hpbGUgZnJvbSAnLi9pbnRlcm5hbC9feGRyb3BXaGlsZSc7XG5pbXBvcnQgc2xpY2UgZnJvbSAnLi9zbGljZSc7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGV4Y2x1ZGluZyB0aGUgbGVhZGluZyBlbGVtZW50cyBvZiBhIGdpdmVuIGxpc3Qgd2hpY2hcbiAqIHNhdGlzZnkgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbi4gSXQgcGFzc2VzIGVhY2ggdmFsdWUgdG8gdGhlIHN1cHBsaWVkXG4gKiBwcmVkaWNhdGUgZnVuY3Rpb24sIHNraXBwaW5nIGVsZW1lbnRzIHdoaWxlIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gcmV0dXJuc1xuICogYHRydWVgLiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIGlzIGFwcGxpZWQgdG8gb25lIGFyZ3VtZW50OiAqKHZhbHVlKSouXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGRyb3BXaGlsZWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkuXG4gKiBAc2VlIFIudGFrZVdoaWxlLCBSLnRyYW5zZHVjZSwgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBsdGVUd28gPSB4ID0+IHggPD0gMjtcbiAqXG4gKiAgICAgIFIuZHJvcFdoaWxlKGx0ZVR3bywgWzEsIDIsIDMsIDQsIDMsIDIsIDFdKTsgLy89PiBbMywgNCwgMywgMiwgMV1cbiAqXG4gKiAgICAgIFIuZHJvcFdoaWxlKHggPT4geCAhPT0gJ2QnICwgJ1JhbWRhJyk7IC8vPT4gJ2RhJ1xuICovXG52YXIgZHJvcFdoaWxlID0gLyojX19QVVJFX18qL19jdXJyeTIoIC8qI19fUFVSRV9fKi9fZGlzcGF0Y2hhYmxlKFsnZHJvcFdoaWxlJ10sIF94ZHJvcFdoaWxlLCBmdW5jdGlvbiBkcm9wV2hpbGUocHJlZCwgeHMpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSB4cy5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW4gJiYgcHJlZCh4c1tpZHhdKSkge1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBzbGljZShpZHgsIEluZmluaXR5LCB4cyk7XG59KSk7XG5leHBvcnQgZGVmYXVsdCBkcm9wV2hpbGU7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfaXNGdW5jdGlvbiBmcm9tICcuL2ludGVybmFsL19pc0Z1bmN0aW9uJztcbmltcG9ydCBsaWZ0IGZyb20gJy4vbGlmdCc7XG5pbXBvcnQgb3IgZnJvbSAnLi9vcic7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB3cmFwcGluZyBjYWxscyB0byB0aGUgdHdvIGZ1bmN0aW9ucyBpbiBhbiBgfHxgIG9wZXJhdGlvbixcbiAqIHJldHVybmluZyB0aGUgcmVzdWx0IG9mIHRoZSBmaXJzdCBmdW5jdGlvbiBpZiBpdCBpcyB0cnV0aC15IGFuZCB0aGUgcmVzdWx0XG4gKiBvZiB0aGUgc2Vjb25kIGZ1bmN0aW9uIG90aGVyd2lzZS4gTm90ZSB0aGF0IHRoaXMgaXMgc2hvcnQtY2lyY3VpdGVkLFxuICogbWVhbmluZyB0aGF0IHRoZSBzZWNvbmQgZnVuY3Rpb24gd2lsbCBub3QgYmUgaW52b2tlZCBpZiB0aGUgZmlyc3QgcmV0dXJucyBhXG4gKiB0cnV0aC15IHZhbHVlLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIGZ1bmN0aW9ucywgYFIuZWl0aGVyYCBhbHNvIGFjY2VwdHMgYW55IGZhbnRhc3ktbGFuZCBjb21wYXRpYmxlXG4gKiBhcHBsaWNhdGl2ZSBmdW5jdG9yLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEyLjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyAoKi4uLiAtPiBCb29sZWFuKSAtPiAoKi4uLiAtPiBCb29sZWFuKSAtPiAoKi4uLiAtPiBCb29sZWFuKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZiBhIHByZWRpY2F0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZyBhbm90aGVyIHByZWRpY2F0ZVxuICogQHJldHVybiB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBhcHBsaWVzIGl0cyBhcmd1bWVudHMgdG8gYGZgIGFuZCBgZ2AgYW5kIGB8fGBzIHRoZWlyIG91dHB1dHMgdG9nZXRoZXIuXG4gKiBAc2VlIFIub3JcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZ3QxMCA9IHggPT4geCA+IDEwO1xuICogICAgICB2YXIgZXZlbiA9IHggPT4geCAlIDIgPT09IDA7XG4gKiAgICAgIHZhciBmID0gUi5laXRoZXIoZ3QxMCwgZXZlbik7XG4gKiAgICAgIGYoMTAxKTsgLy89PiB0cnVlXG4gKiAgICAgIGYoOCk7IC8vPT4gdHJ1ZVxuICovXG52YXIgZWl0aGVyID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gZWl0aGVyKGYsIGcpIHtcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKGYpID8gZnVuY3Rpb24gX2VpdGhlcigpIHtcbiAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IGcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSA6IGxpZnQob3IpKGYsIGcpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBlaXRoZXI7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBfaXNBcmd1bWVudHMgZnJvbSAnLi9pbnRlcm5hbC9faXNBcmd1bWVudHMnO1xuaW1wb3J0IF9pc0FycmF5IGZyb20gJy4vaW50ZXJuYWwvX2lzQXJyYXknO1xuaW1wb3J0IF9pc09iamVjdCBmcm9tICcuL2ludGVybmFsL19pc09iamVjdCc7XG5pbXBvcnQgX2lzU3RyaW5nIGZyb20gJy4vaW50ZXJuYWwvX2lzU3RyaW5nJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbXB0eSB2YWx1ZSBvZiBpdHMgYXJndW1lbnQncyB0eXBlLiBSYW1kYSBkZWZpbmVzIHRoZSBlbXB0eVxuICogdmFsdWUgb2YgQXJyYXkgKGBbXWApLCBPYmplY3QgKGB7fWApLCBTdHJpbmcgKGAnJ2ApLCBhbmQgQXJndW1lbnRzLiBPdGhlclxuICogdHlwZXMgYXJlIHN1cHBvcnRlZCBpZiB0aGV5IGRlZmluZSBgPFR5cGU+LmVtcHR5YCxcbiAqIGA8VHlwZT4ucHJvdG90eXBlLmVtcHR5YCBvciBpbXBsZW1lbnQgdGhlXG4gKiBbRmFudGFzeUxhbmQgTW9ub2lkIHNwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjbW9ub2lkKS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgZW1wdHlgIG1ldGhvZCBvZiB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMy4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgYSAtPiBhXG4gKiBAcGFyYW0geyp9IHhcbiAqIEByZXR1cm4geyp9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5lbXB0eShKdXN0KDQyKSk7ICAgICAgLy89PiBOb3RoaW5nKClcbiAqICAgICAgUi5lbXB0eShbMSwgMiwgM10pOyAgICAgLy89PiBbXVxuICogICAgICBSLmVtcHR5KCd1bmljb3JucycpOyAgICAvLz0+ICcnXG4gKiAgICAgIFIuZW1wdHkoe3g6IDEsIHk6IDJ9KTsgIC8vPT4ge31cbiAqL1xudmFyIGVtcHR5ID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gZW1wdHkoeCkge1xuICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4WydmYW50YXN5LWxhbmQvZW1wdHknXSA9PT0gJ2Z1bmN0aW9uJyA/IHhbJ2ZhbnRhc3ktbGFuZC9lbXB0eSddKCkgOiB4ICE9IG51bGwgJiYgeC5jb25zdHJ1Y3RvciAhPSBudWxsICYmIHR5cGVvZiB4LmNvbnN0cnVjdG9yWydmYW50YXN5LWxhbmQvZW1wdHknXSA9PT0gJ2Z1bmN0aW9uJyA/IHguY29uc3RydWN0b3JbJ2ZhbnRhc3ktbGFuZC9lbXB0eSddKCkgOiB4ICE9IG51bGwgJiYgdHlwZW9mIHguZW1wdHkgPT09ICdmdW5jdGlvbicgPyB4LmVtcHR5KCkgOiB4ICE9IG51bGwgJiYgeC5jb25zdHJ1Y3RvciAhPSBudWxsICYmIHR5cGVvZiB4LmNvbnN0cnVjdG9yLmVtcHR5ID09PSAnZnVuY3Rpb24nID8geC5jb25zdHJ1Y3Rvci5lbXB0eSgpIDogX2lzQXJyYXkoeCkgPyBbXSA6IF9pc1N0cmluZyh4KSA/ICcnIDogX2lzT2JqZWN0KHgpID8ge30gOiBfaXNBcmd1bWVudHMoeCkgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cztcbiAgfSgpIDpcbiAgLy8gZWxzZVxuICB2b2lkIDA7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGVtcHR5OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgZXF1YWxzIGZyb20gJy4vZXF1YWxzJztcbmltcG9ydCB0YWtlTGFzdCBmcm9tICcuL3Rha2VMYXN0JztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGVuZHMgd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWVzXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjQuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IEJvb2xlYW5cbiAqIEBzaWcgU3RyaW5nIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0gc3VmZml4XG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5lbmRzV2l0aCgnYycsICdhYmMnKSAgICAgICAgICAgICAgICAvLz0+IHRydWVcbiAqICAgICAgUi5lbmRzV2l0aCgnYicsICdhYmMnKSAgICAgICAgICAgICAgICAvLz0+IGZhbHNlXG4gKiAgICAgIFIuZW5kc1dpdGgoWydjJ10sIFsnYScsICdiJywgJ2MnXSkgICAgLy89PiB0cnVlXG4gKiAgICAgIFIuZW5kc1dpdGgoWydiJ10sIFsnYScsICdiJywgJ2MnXSkgICAgLy89PiBmYWxzZVxuICovXG52YXIgZW5kc1dpdGggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiAoc3VmZml4LCBsaXN0KSB7XG4gIHJldHVybiBlcXVhbHModGFrZUxhc3Qoc3VmZml4Lmxlbmd0aCwgbGlzdCksIHN1ZmZpeCk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGVuZHNXaXRoOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgZXF1YWxzIGZyb20gJy4vZXF1YWxzJztcblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCB0d28gdmFsdWVzIGluIGl0cyBkb21haW4gYW5kIHJldHVybnMgYHRydWVgIGlmIHRoZVxuICogdmFsdWVzIG1hcCB0byB0aGUgc2FtZSB2YWx1ZSBpbiB0aGUgY29kb21haW47IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE4LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyAoYSAtPiBiKSAtPiBhIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHsqfSB4XG4gKiBAcGFyYW0geyp9IHlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5lcUJ5KE1hdGguYWJzLCA1LCAtNSk7IC8vPT4gdHJ1ZVxuICovXG52YXIgZXFCeSA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIGVxQnkoZiwgeCwgeSkge1xuICByZXR1cm4gZXF1YWxzKGYoeCksIGYoeSkpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBlcUJ5OyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgZXF1YWxzIGZyb20gJy4vZXF1YWxzJztcblxuLyoqXG4gKiBSZXBvcnRzIHdoZXRoZXIgdHdvIG9iamVjdHMgaGF2ZSB0aGUgc2FtZSB2YWx1ZSwgaW4gW2BSLmVxdWFsc2BdKCNlcXVhbHMpXG4gKiB0ZXJtcywgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkuIFVzZWZ1bCBhcyBhIGN1cnJpZWQgcHJlZGljYXRlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBrIC0+IHtrOiB2fSAtPiB7azogdn0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG8xID0geyBhOiAxLCBiOiAyLCBjOiAzLCBkOiA0IH07XG4gKiAgICAgIHZhciBvMiA9IHsgYTogMTAsIGI6IDIwLCBjOiAzLCBkOiA0MCB9O1xuICogICAgICBSLmVxUHJvcHMoJ2EnLCBvMSwgbzIpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuZXFQcm9wcygnYycsIG8xLCBvMik7IC8vPT4gdHJ1ZVxuICovXG52YXIgZXFQcm9wcyA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIGVxUHJvcHMocHJvcCwgb2JqMSwgb2JqMikge1xuICByZXR1cm4gZXF1YWxzKG9iajFbcHJvcF0sIG9iajJbcHJvcF0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBlcVByb3BzOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2VxdWFscyBmcm9tICcuL2ludGVybmFsL19lcXVhbHMnO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGl0cyBhcmd1bWVudHMgYXJlIGVxdWl2YWxlbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBIYW5kbGVzXG4gKiBjeWNsaWNhbCBkYXRhIHN0cnVjdHVyZXMuXG4gKlxuICogRGlzcGF0Y2hlcyBzeW1tZXRyaWNhbGx5IHRvIHRoZSBgZXF1YWxzYCBtZXRob2RzIG9mIGJvdGggYXJndW1lbnRzLCBpZlxuICogcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgYSAtPiBiIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZXF1YWxzKDEsIDEpOyAvLz0+IHRydWVcbiAqICAgICAgUi5lcXVhbHMoMSwgJzEnKTsgLy89PiBmYWxzZVxuICogICAgICBSLmVxdWFscyhbMSwgMiwgM10sIFsxLCAyLCAzXSk7IC8vPT4gdHJ1ZVxuICpcbiAqICAgICAgdmFyIGEgPSB7fTsgYS52ID0gYTtcbiAqICAgICAgdmFyIGIgPSB7fTsgYi52ID0gYjtcbiAqICAgICAgUi5lcXVhbHMoYSwgYik7IC8vPT4gdHJ1ZVxuICovXG52YXIgZXF1YWxzID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIF9lcXVhbHMoYSwgYiwgW10sIFtdKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgZXF1YWxzOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgYnkgcmVjdXJzaXZlbHkgZXZvbHZpbmcgYSBzaGFsbG93IGNvcHkgb2YgYG9iamVjdGAsXG4gKiBhY2NvcmRpbmcgdG8gdGhlIGB0cmFuc2Zvcm1hdGlvbmAgZnVuY3Rpb25zLiBBbGwgbm9uLXByaW1pdGl2ZSBwcm9wZXJ0aWVzXG4gKiBhcmUgY29waWVkIGJ5IHJlZmVyZW5jZS5cbiAqXG4gKiBBIGB0cmFuc2Zvcm1hdGlvbmAgZnVuY3Rpb24gd2lsbCBub3QgYmUgaW52b2tlZCBpZiBpdHMgY29ycmVzcG9uZGluZyBrZXlcbiAqIGRvZXMgbm90IGV4aXN0IGluIHRoZSBldm9sdmVkIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge2s6ICh2IC0+IHYpfSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtYXRpb25zIFRoZSBvYmplY3Qgc3BlY2lmeWluZyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gYXBwbHlcbiAqICAgICAgICB0byB0aGUgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIHRyYW5zZm9ybWVkLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgdHJhbnNmb3JtZWQgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB0b21hdG8gID0ge2ZpcnN0TmFtZTogJyAgVG9tYXRvICcsIGRhdGE6IHtlbGFwc2VkOiAxMDAsIHJlbWFpbmluZzogMTQwMH0sIGlkOjEyM307XG4gKiAgICAgIHZhciB0cmFuc2Zvcm1hdGlvbnMgPSB7XG4gKiAgICAgICAgZmlyc3ROYW1lOiBSLnRyaW0sXG4gKiAgICAgICAgbGFzdE5hbWU6IFIudHJpbSwgLy8gV2lsbCBub3QgZ2V0IGludm9rZWQuXG4gKiAgICAgICAgZGF0YToge2VsYXBzZWQ6IFIuYWRkKDEpLCByZW1haW5pbmc6IFIuYWRkKC0xKX1cbiAqICAgICAgfTtcbiAqICAgICAgUi5ldm9sdmUodHJhbnNmb3JtYXRpb25zLCB0b21hdG8pOyAvLz0+IHtmaXJzdE5hbWU6ICdUb21hdG8nLCBkYXRhOiB7ZWxhcHNlZDogMTAxLCByZW1haW5pbmc6IDEzOTl9LCBpZDoxMjN9XG4gKi9cbnZhciBldm9sdmUgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBldm9sdmUodHJhbnNmb3JtYXRpb25zLCBvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgdHJhbnNmb3JtYXRpb24sIGtleSwgdHlwZTtcbiAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgdHJhbnNmb3JtYXRpb24gPSB0cmFuc2Zvcm1hdGlvbnNba2V5XTtcbiAgICB0eXBlID0gdHlwZW9mIHRyYW5zZm9ybWF0aW9uO1xuICAgIHJlc3VsdFtrZXldID0gdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHRyYW5zZm9ybWF0aW9uKG9iamVjdFtrZXldKSA6IHRyYW5zZm9ybWF0aW9uICYmIHR5cGUgPT09ICdvYmplY3QnID8gZXZvbHZlKHRyYW5zZm9ybWF0aW9uLCBvYmplY3Rba2V5XSkgOiBvYmplY3Rba2V5XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5leHBvcnQgZGVmYXVsdCBldm9sdmU7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZSc7XG5pbXBvcnQgX2ZpbHRlciBmcm9tICcuL2ludGVybmFsL19maWx0ZXInO1xuaW1wb3J0IF9pc09iamVjdCBmcm9tICcuL2ludGVybmFsL19pc09iamVjdCc7XG5pbXBvcnQgX3JlZHVjZSBmcm9tICcuL2ludGVybmFsL19yZWR1Y2UnO1xuaW1wb3J0IF94ZmlsdGVyIGZyb20gJy4vaW50ZXJuYWwvX3hmaWx0ZXInO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzJztcblxuLyoqXG4gKiBUYWtlcyBhIHByZWRpY2F0ZSBhbmQgYSBgRmlsdGVyYWJsZWAsIGFuZCByZXR1cm5zIGEgbmV3IGZpbHRlcmFibGUgb2YgdGhlXG4gKiBzYW1lIHR5cGUgY29udGFpbmluZyB0aGUgbWVtYmVycyBvZiB0aGUgZ2l2ZW4gZmlsdGVyYWJsZSB3aGljaCBzYXRpc2Z5IHRoZVxuICogZ2l2ZW4gcHJlZGljYXRlLiBGaWx0ZXJhYmxlIG9iamVjdHMgaW5jbHVkZSBwbGFpbiBvYmplY3RzIG9yIGFueSBvYmplY3RcbiAqIHRoYXQgaGFzIGEgZmlsdGVyIG1ldGhvZCBzdWNoIGFzIGBBcnJheWAuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGZpbHRlcmAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBmIGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcmFibGVcbiAqIEByZXR1cm4ge0FycmF5fSBGaWx0ZXJhYmxlXG4gKiBAc2VlIFIucmVqZWN0LCBSLnRyYW5zZHVjZSwgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc0V2ZW4gPSBuID0+IG4gJSAyID09PSAwO1xuICpcbiAqICAgICAgUi5maWx0ZXIoaXNFdmVuLCBbMSwgMiwgMywgNF0pOyAvLz0+IFsyLCA0XVxuICpcbiAqICAgICAgUi5maWx0ZXIoaXNFdmVuLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHtiOiAyLCBkOiA0fVxuICovXG52YXIgZmlsdGVyID0gLyojX19QVVJFX18qL19jdXJyeTIoIC8qI19fUFVSRV9fKi9fZGlzcGF0Y2hhYmxlKFsnZmlsdGVyJ10sIF94ZmlsdGVyLCBmdW5jdGlvbiAocHJlZCwgZmlsdGVyYWJsZSkge1xuICByZXR1cm4gX2lzT2JqZWN0KGZpbHRlcmFibGUpID8gX3JlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICBpZiAocHJlZChmaWx0ZXJhYmxlW2tleV0pKSB7XG4gICAgICBhY2Nba2V5XSA9IGZpbHRlcmFibGVba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30sIGtleXMoZmlsdGVyYWJsZSkpIDpcbiAgLy8gZWxzZVxuICBfZmlsdGVyKHByZWQsIGZpbHRlcmFibGUpO1xufSkpO1xuZXhwb3J0IGRlZmF1bHQgZmlsdGVyOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tICcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnO1xuaW1wb3J0IF94ZmluZCBmcm9tICcuL2ludGVybmFsL194ZmluZCc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgbGlzdCB3aGljaCBtYXRjaGVzIHRoZSBwcmVkaWNhdGUsIG9yXG4gKiBgdW5kZWZpbmVkYCBpZiBubyBlbGVtZW50IG1hdGNoZXMuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGZpbmRgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBhIHwgdW5kZWZpbmVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBlbGVtZW50IGlzIHRoZVxuICogICAgICAgIGRlc2lyZWQgb25lLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBlbGVtZW50IGZvdW5kLCBvciBgdW5kZWZpbmVkYC5cbiAqIEBzZWUgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgeHMgPSBbe2E6IDF9LCB7YTogMn0sIHthOiAzfV07XG4gKiAgICAgIFIuZmluZChSLnByb3BFcSgnYScsIDIpKSh4cyk7IC8vPT4ge2E6IDJ9XG4gKiAgICAgIFIuZmluZChSLnByb3BFcSgnYScsIDQpKSh4cyk7IC8vPT4gdW5kZWZpbmVkXG4gKi9cbnZhciBmaW5kID0gLyojX19QVVJFX18qL19jdXJyeTIoIC8qI19fUFVSRV9fKi9fZGlzcGF0Y2hhYmxlKFsnZmluZCddLCBfeGZpbmQsIGZ1bmN0aW9uIGZpbmQoZm4sIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICByZXR1cm4gbGlzdFtpZHhdO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxufSkpO1xuZXhwb3J0IGRlZmF1bHQgZmluZDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfeGZpbmRJbmRleCBmcm9tICcuL2ludGVybmFsL194ZmluZEluZGV4JztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgbGlzdCB3aGljaCBtYXRjaGVzIHRoZVxuICogcHJlZGljYXRlLCBvciBgLTFgIGlmIG5vIGVsZW1lbnQgbWF0Y2hlcy5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4xXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gTnVtYmVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBlbGVtZW50IGlzIHRoZVxuICogZGVzaXJlZCBvbmUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGZvdW5kLCBvciBgLTFgLlxuICogQHNlZSBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB4cyA9IFt7YTogMX0sIHthOiAyfSwge2E6IDN9XTtcbiAqICAgICAgUi5maW5kSW5kZXgoUi5wcm9wRXEoJ2EnLCAyKSkoeHMpOyAvLz0+IDFcbiAqICAgICAgUi5maW5kSW5kZXgoUi5wcm9wRXEoJ2EnLCA0KSkoeHMpOyAvLz0+IC0xXG4gKi9cbnZhciBmaW5kSW5kZXggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoW10sIF94ZmluZEluZGV4LCBmdW5jdGlvbiBmaW5kSW5kZXgoZm4sIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICByZXR1cm4gaWR4O1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gLTE7XG59KSk7XG5leHBvcnQgZGVmYXVsdCBmaW5kSW5kZXg7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZSc7XG5pbXBvcnQgX3hmaW5kTGFzdCBmcm9tICcuL2ludGVybmFsL194ZmluZExhc3QnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbGlzdCB3aGljaCBtYXRjaGVzIHRoZSBwcmVkaWNhdGUsIG9yXG4gKiBgdW5kZWZpbmVkYCBpZiBubyBlbGVtZW50IG1hdGNoZXMuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMVxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IGEgfCB1bmRlZmluZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGVsZW1lbnQgaXMgdGhlXG4gKiBkZXNpcmVkIG9uZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZWxlbWVudCBmb3VuZCwgb3IgYHVuZGVmaW5lZGAuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHhzID0gW3thOiAxLCBiOiAwfSwge2E6MSwgYjogMX1dO1xuICogICAgICBSLmZpbmRMYXN0KFIucHJvcEVxKCdhJywgMSkpKHhzKTsgLy89PiB7YTogMSwgYjogMX1cbiAqICAgICAgUi5maW5kTGFzdChSLnByb3BFcSgnYScsIDQpKSh4cyk7IC8vPT4gdW5kZWZpbmVkXG4gKi9cbnZhciBmaW5kTGFzdCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovX2Rpc3BhdGNoYWJsZShbXSwgX3hmaW5kTGFzdCwgZnVuY3Rpb24gZmluZExhc3QoZm4sIGxpc3QpIHtcbiAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiBsaXN0W2lkeF07XG4gICAgfVxuICAgIGlkeCAtPSAxO1xuICB9XG59KSk7XG5leHBvcnQgZGVmYXVsdCBmaW5kTGFzdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfeGZpbmRMYXN0SW5kZXggZnJvbSAnLi9pbnRlcm5hbC9feGZpbmRMYXN0SW5kZXgnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGVcbiAqIHByZWRpY2F0ZSwgb3IgYC0xYCBpZiBubyBlbGVtZW50IG1hdGNoZXMuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMVxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IE51bWJlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyB0aGVcbiAqIGRlc2lyZWQgb25lLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBmb3VuZCwgb3IgYC0xYC5cbiAqIEBzZWUgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgeHMgPSBbe2E6IDEsIGI6IDB9LCB7YToxLCBiOiAxfV07XG4gKiAgICAgIFIuZmluZExhc3RJbmRleChSLnByb3BFcSgnYScsIDEpKSh4cyk7IC8vPT4gMVxuICogICAgICBSLmZpbmRMYXN0SW5kZXgoUi5wcm9wRXEoJ2EnLCA0KSkoeHMpOyAvLz0+IC0xXG4gKi9cbnZhciBmaW5kTGFzdEluZGV4ID0gLyojX19QVVJFX18qL19jdXJyeTIoIC8qI19fUFVSRV9fKi9fZGlzcGF0Y2hhYmxlKFtdLCBfeGZpbmRMYXN0SW5kZXgsIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoZm4sIGxpc3QpIHtcbiAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICAgIGlkeCAtPSAxO1xuICB9XG4gIHJldHVybiAtMTtcbn0pKTtcbmV4cG9ydCBkZWZhdWx0IGZpbmRMYXN0SW5kZXg7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBfbWFrZUZsYXQgZnJvbSAnLi9pbnRlcm5hbC9fbWFrZUZsYXQnO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBieSBwdWxsaW5nIGV2ZXJ5IGl0ZW0gb3V0IG9mIGl0IChhbmQgYWxsIGl0cyBzdWItYXJyYXlzKVxuICogYW5kIHB1dHRpbmcgdGhlbSBpbiBhIG5ldyBhcnJheSwgZGVwdGgtZmlyc3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2JdXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZmxhdHRlbmVkIGxpc3QuXG4gKiBAc2VlIFIudW5uZXN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5mbGF0dGVuKFsxLCAyLCBbMywgNF0sIDUsIFs2LCBbNywgOCwgWzksIFsxMCwgMTFdLCAxMl1dXV0pO1xuICogICAgICAvLz0+IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyXVxuICovXG52YXIgZmxhdHRlbiA9IC8qI19fUFVSRV9fKi9fY3VycnkxKCAvKiNfX1BVUkVfXyovX21ha2VGbGF0KHRydWUpKTtcbmV4cG9ydCBkZWZhdWx0IGZsYXR0ZW47IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBjdXJyeU4gZnJvbSAnLi9jdXJyeU4nO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gbXVjaCBsaWtlIHRoZSBzdXBwbGllZCBvbmUsIGV4Y2VwdCB0aGF0IHRoZSBmaXJzdCB0d29cbiAqIGFyZ3VtZW50cycgb3JkZXIgaXMgcmV2ZXJzZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKChhLCBiLCBjLCAuLi4pIC0+IHopIC0+IChiIC0+IGEgLT4gYyAtPiAuLi4gLT4geilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugd2l0aCBpdHMgZmlyc3QgdHdvIHBhcmFtZXRlcnMgcmV2ZXJzZWQuXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmVzdWx0IG9mIGludm9raW5nIGBmbmAgd2l0aCBpdHMgZmlyc3QgdHdvIHBhcmFtZXRlcnMnIG9yZGVyIHJldmVyc2VkLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBtZXJnZVRocmVlID0gKGEsIGIsIGMpID0+IFtdLmNvbmNhdChhLCBiLCBjKTtcbiAqXG4gKiAgICAgIG1lcmdlVGhyZWUoMSwgMiwgMyk7IC8vPT4gWzEsIDIsIDNdXG4gKlxuICogICAgICBSLmZsaXAobWVyZ2VUaHJlZSkoMSwgMiwgMyk7IC8vPT4gWzIsIDEsIDNdXG4gKiBAc3ltYiBSLmZsaXAoZikoYSwgYiwgYykgPSBmKGIsIGEsIGMpXG4gKi9cbnZhciBmbGlwID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gZmxpcChmbikge1xuICByZXR1cm4gY3VycnlOKGZuLmxlbmd0aCwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgYXJnc1swXSA9IGI7XG4gICAgYXJnc1sxXSA9IGE7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgZmxpcDsiLCJpbXBvcnQgX2NoZWNrRm9yTWV0aG9kIGZyb20gJy4vaW50ZXJuYWwvX2NoZWNrRm9yTWV0aG9kJztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIGlucHV0IGBsaXN0YCwgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIGBmbmAgZm9yIGVhY2hcbiAqIGVsZW1lbnQgaW4gdGhlIGxpc3QuXG4gKlxuICogYGZuYCByZWNlaXZlcyBvbmUgYXJndW1lbnQ6ICoodmFsdWUpKi5cbiAqXG4gKiBOb3RlOiBgUi5mb3JFYWNoYCBkb2VzIG5vdCBza2lwIGRlbGV0ZWQgb3IgdW5hc3NpZ25lZCBpbmRpY2VzIChzcGFyc2VcbiAqIGFycmF5cyksIHVubGlrZSB0aGUgbmF0aXZlIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kLiBGb3IgbW9yZVxuICogZGV0YWlscyBvbiB0aGlzIGJlaGF2aW9yLCBzZWU6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoI0Rlc2NyaXB0aW9uXG4gKlxuICogQWxzbyBub3RlIHRoYXQsIHVubGlrZSBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgLCBSYW1kYSdzIGBmb3JFYWNoYCByZXR1cm5zXG4gKiB0aGUgb3JpZ2luYWwgYXJyYXkuIEluIHNvbWUgbGlicmFyaWVzIHRoaXMgZnVuY3Rpb24gaXMgbmFtZWQgYGVhY2hgLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBmb3JFYWNoYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjFcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+ICopIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuIFJlY2VpdmVzIG9uZSBhcmd1bWVudCwgYHZhbHVlYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBvcmlnaW5hbCBsaXN0LlxuICogQHNlZSBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHByaW50WFBsdXNGaXZlID0geCA9PiBjb25zb2xlLmxvZyh4ICsgNSk7XG4gKiAgICAgIFIuZm9yRWFjaChwcmludFhQbHVzRml2ZSwgWzEsIDIsIDNdKTsgLy89PiBbMSwgMiwgM11cbiAqICAgICAgLy8gbG9ncyA2XG4gKiAgICAgIC8vIGxvZ3MgN1xuICogICAgICAvLyBsb2dzIDhcbiAqIEBzeW1iIFIuZm9yRWFjaChmLCBbYSwgYiwgY10pID0gW2EsIGIsIGNdXG4gKi9cbnZhciBmb3JFYWNoID0gLyojX19QVVJFX18qL19jdXJyeTIoIC8qI19fUFVSRV9fKi9fY2hlY2tGb3JNZXRob2QoJ2ZvckVhY2gnLCBmdW5jdGlvbiBmb3JFYWNoKGZuLCBsaXN0KSB7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBmbihsaXN0W2lkeF0pO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBsaXN0O1xufSkpO1xuZXhwb3J0IGRlZmF1bHQgZm9yRWFjaDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzJztcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gaW5wdXQgYG9iamVjdGAsIGNhbGxpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiBgZm5gIGZvciBlYWNoXG4gKiBrZXkgYW5kIHZhbHVlIGluIHRoZSBvYmplY3QuXG4gKlxuICogYGZuYCByZWNlaXZlcyB0aHJlZSBhcmd1bWVudDogKih2YWx1ZSwga2V5LCBvYmopKi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgoYSwgU3RyaW5nLCBTdHJNYXAgYSkgLT4gQW55KSAtPiBTdHJNYXAgYSAtPiBTdHJNYXAgYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGludm9rZS4gUmVjZWl2ZXMgdGhyZWUgYXJndW1lbnQsIGB2YWx1ZWAsIGBrZXlgLCBgb2JqYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvcmlnaW5hbCBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHByaW50S2V5Q29uY2F0VmFsdWUgPSAodmFsdWUsIGtleSkgPT4gY29uc29sZS5sb2coa2V5ICsgJzonICsgdmFsdWUpO1xuICogICAgICBSLmZvckVhY2hPYmpJbmRleGVkKHByaW50S2V5Q29uY2F0VmFsdWUsIHt4OiAxLCB5OiAyfSk7IC8vPT4ge3g6IDEsIHk6IDJ9XG4gKiAgICAgIC8vIGxvZ3MgeDoxXG4gKiAgICAgIC8vIGxvZ3MgeToyXG4gKiBAc3ltYiBSLmZvckVhY2hPYmpJbmRleGVkKGYsIHt4OiBhLCB5OiBifSkgPSB7eDogYSwgeTogYn1cbiAqL1xudmFyIGZvckVhY2hPYmpJbmRleGVkID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gZm9yRWFjaE9iakluZGV4ZWQoZm4sIG9iaikge1xuICB2YXIga2V5TGlzdCA9IGtleXMob2JqKTtcbiAgdmFyIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBrZXlMaXN0Lmxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBrZXlMaXN0W2lkeF07XG4gICAgZm4ob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gb2JqO1xufSk7XG5leHBvcnQgZGVmYXVsdCBmb3JFYWNoT2JqSW5kZXhlZDsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IGZyb20gYSBsaXN0IGtleS12YWx1ZSBwYWlycy4gSWYgYSBrZXkgYXBwZWFycyBpblxuICogbXVsdGlwbGUgcGFpcnMsIHRoZSByaWdodG1vc3QgcGFpciBpcyBpbmNsdWRlZCBpbiB0aGUgb2JqZWN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW1trLHZdXSAtPiB7azogdn1cbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIEFuIGFycmF5IG9mIHR3by1lbGVtZW50IGFycmF5cyB0aGF0IHdpbGwgYmUgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiB0aGUgb3V0cHV0IG9iamVjdC5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIG9iamVjdCBtYWRlIGJ5IHBhaXJpbmcgdXAgYGtleXNgIGFuZCBgdmFsdWVzYC5cbiAqIEBzZWUgUi50b1BhaXJzLCBSLnBhaXJcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmZyb21QYWlycyhbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV0pOyAvLz0+IHthOiAxLCBiOiAyLCBjOiAzfVxuICovXG52YXIgZnJvbVBhaXJzID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gZnJvbVBhaXJzKHBhaXJzKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBwYWlycy5sZW5ndGgpIHtcbiAgICByZXN1bHRbcGFpcnNbaWR4XVswXV0gPSBwYWlyc1tpZHhdWzFdO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGZyb21QYWlyczsiLCJpbXBvcnQgX2NoZWNrRm9yTWV0aG9kIGZyb20gJy4vaW50ZXJuYWwvX2NoZWNrRm9yTWV0aG9kJztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgcmVkdWNlQnkgZnJvbSAnLi9yZWR1Y2VCeSc7XG5cbi8qKlxuICogU3BsaXRzIGEgbGlzdCBpbnRvIHN1Yi1saXN0cyBzdG9yZWQgaW4gYW4gb2JqZWN0LCBiYXNlZCBvbiB0aGUgcmVzdWx0IG9mXG4gKiBjYWxsaW5nIGEgU3RyaW5nLXJldHVybmluZyBmdW5jdGlvbiBvbiBlYWNoIGVsZW1lbnQsIGFuZCBncm91cGluZyB0aGVcbiAqIHJlc3VsdHMgYWNjb3JkaW5nIHRvIHZhbHVlcyByZXR1cm5lZC5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgZ3JvdXBCeWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gU3RyaW5nKSAtPiBbYV0gLT4ge1N0cmluZzogW2FdfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gOjogYSAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGdyb3VwXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBvdXRwdXQgb2YgYGZuYCBmb3Iga2V5cywgbWFwcGVkIHRvIGFycmF5cyBvZiBlbGVtZW50c1xuICogICAgICAgICB0aGF0IHByb2R1Y2VkIHRoYXQga2V5IHdoZW4gcGFzc2VkIHRvIGBmbmAuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGJ5R3JhZGUgPSBSLmdyb3VwQnkoZnVuY3Rpb24oc3R1ZGVudCkge1xuICogICAgICAgIHZhciBzY29yZSA9IHN0dWRlbnQuc2NvcmU7XG4gKiAgICAgICAgcmV0dXJuIHNjb3JlIDwgNjUgPyAnRicgOlxuICogICAgICAgICAgICAgICBzY29yZSA8IDcwID8gJ0QnIDpcbiAqICAgICAgICAgICAgICAgc2NvcmUgPCA4MCA/ICdDJyA6XG4gKiAgICAgICAgICAgICAgIHNjb3JlIDwgOTAgPyAnQicgOiAnQSc7XG4gKiAgICAgIH0pO1xuICogICAgICB2YXIgc3R1ZGVudHMgPSBbe25hbWU6ICdBYmJ5Jywgc2NvcmU6IDg0fSxcbiAqICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnRWRkeScsIHNjb3JlOiA1OH0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5cbiAqICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnSmFjaycsIHNjb3JlOiA2OX1dO1xuICogICAgICBieUdyYWRlKHN0dWRlbnRzKTtcbiAqICAgICAgLy8ge1xuICogICAgICAvLyAgICdBJzogW3tuYW1lOiAnRGlhbm5lJywgc2NvcmU6IDk5fV0sXG4gKiAgICAgIC8vICAgJ0InOiBbe25hbWU6ICdBYmJ5Jywgc2NvcmU6IDg0fV1cbiAqICAgICAgLy8gICAvLyAuLi4sXG4gKiAgICAgIC8vICAgJ0YnOiBbe25hbWU6ICdFZGR5Jywgc2NvcmU6IDU4fV1cbiAqICAgICAgLy8gfVxuICovXG52YXIgZ3JvdXBCeSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovX2NoZWNrRm9yTWV0aG9kKCdncm91cEJ5JywgLyojX19QVVJFX18qL3JlZHVjZUJ5KGZ1bmN0aW9uIChhY2MsIGl0ZW0pIHtcbiAgaWYgKGFjYyA9PSBudWxsKSB7XG4gICAgYWNjID0gW107XG4gIH1cbiAgYWNjLnB1c2goaXRlbSk7XG4gIHJldHVybiBhY2M7XG59LCBudWxsKSkpO1xuZXhwb3J0IGRlZmF1bHQgZ3JvdXBCeTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFRha2VzIGEgbGlzdCBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgbGlzdHMgd2hlcmUgZWFjaCBzdWJsaXN0J3MgZWxlbWVudHMgYXJlXG4gKiBhbGwgc2F0aXNmaWVkIHBhaXJ3aXNlIGNvbXBhcmlzb24gYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqIE9ubHkgYWRqYWNlbnQgZWxlbWVudHMgYXJlIHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGEpIOKGkiBCb29sZWFuKSDihpIgW2FdIOKGkiBbW2FdXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdHdvIGdpdmVuIChhZGphY2VudClcbiAqICAgICAgICBlbGVtZW50cyBzaG91bGQgYmUgaW4gdGhlIHNhbWUgZ3JvdXBcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGdyb3VwLiBBbHNvIGFjY2VwdHMgYSBzdHJpbmcsIHdoaWNoIHdpbGwgYmVcbiAqICAgICAgICB0cmVhdGVkIGFzIGEgbGlzdCBvZiBjaGFyYWN0ZXJzLlxuICogQHJldHVybiB7TGlzdH0gQSBsaXN0IHRoYXQgY29udGFpbnMgc3VibGlzdHMgb2YgZWxlbWVudHMsXG4gKiAgICAgICAgIHdob3NlIGNvbmNhdGVuYXRpb25zIGFyZSBlcXVhbCB0byB0aGUgb3JpZ2luYWwgbGlzdC5cbiAqIEBleGFtcGxlXG4gKlxuICogUi5ncm91cFdpdGgoUi5lcXVhbHMsIFswLCAxLCAxLCAyLCAzLCA1LCA4LCAxMywgMjFdKVxuICogLy89PiBbWzBdLCBbMSwgMV0sIFsyXSwgWzNdLCBbNV0sIFs4XSwgWzEzXSwgWzIxXV1cbiAqXG4gKiBSLmdyb3VwV2l0aCgoYSwgYikgPT4gYSArIDEgPT09IGIsIFswLCAxLCAxLCAyLCAzLCA1LCA4LCAxMywgMjFdKVxuICogLy89PiBbWzAsIDFdLCBbMSwgMiwgM10sIFs1XSwgWzhdLCBbMTNdLCBbMjFdXVxuICpcbiAqIFIuZ3JvdXBXaXRoKChhLCBiKSA9PiBhICUgMiA9PT0gYiAlIDIsIFswLCAxLCAxLCAyLCAzLCA1LCA4LCAxMywgMjFdKVxuICogLy89PiBbWzBdLCBbMSwgMV0sIFsyXSwgWzMsIDVdLCBbOF0sIFsxMywgMjFdXVxuICpcbiAqIFIuZ3JvdXBXaXRoKFIuZXFCeShpc1Zvd2VsKSwgJ2Flc3Rpb3UnKVxuICogLy89PiBbJ2FlJywgJ3N0JywgJ2lvdSddXG4gKi9cbnZhciBncm91cFdpdGggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiAoZm4sIGxpc3QpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgdmFyIG5leHRpZHggPSBpZHggKyAxO1xuICAgIHdoaWxlIChuZXh0aWR4IDwgbGVuICYmIGZuKGxpc3RbbmV4dGlkeCAtIDFdLCBsaXN0W25leHRpZHhdKSkge1xuICAgICAgbmV4dGlkeCArPSAxO1xuICAgIH1cbiAgICByZXMucHVzaChsaXN0LnNsaWNlKGlkeCwgbmV4dGlkeCkpO1xuICAgIGlkeCA9IG5leHRpZHg7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn0pO1xuZXhwb3J0IGRlZmF1bHQgZ3JvdXBXaXRoOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGdyZWF0ZXIgdGhhbiB0aGUgc2Vjb25kOyBgZmFsc2VgXG4gKiBvdGhlcndpc2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmx0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5ndCgyLCAxKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuZ3QoMiwgMik7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5ndCgyLCAzKTsgLy89PiBmYWxzZVxuICogICAgICBSLmd0KCdhJywgJ3onKTsgLy89PiBmYWxzZVxuICogICAgICBSLmd0KCd6JywgJ2EnKTsgLy89PiB0cnVlXG4gKi9cbnZhciBndCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGd0KGEsIGIpIHtcbiAgcmV0dXJuIGEgPiBiO1xufSk7XG5leHBvcnQgZGVmYXVsdCBndDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNlY29uZDtcbiAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge051bWJlcn0gYVxuICogQHBhcmFtIHtOdW1iZXJ9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIubHRlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5ndGUoMiwgMSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmd0ZSgyLCAyKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuZ3RlKDIsIDMpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuZ3RlKCdhJywgJ3onKTsgLy89PiBmYWxzZVxuICogICAgICBSLmd0ZSgneicsICdhJyk7IC8vPT4gdHJ1ZVxuICovXG52YXIgZ3RlID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gZ3RlKGEsIGIpIHtcbiAgcmV0dXJuIGEgPj0gYjtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgZ3RlOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2hhcyBmcm9tICcuL2ludGVybmFsL19oYXMnO1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgcyAtPiB7czogeH0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNoZWNrIGZvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IGV4aXN0cy5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaGFzTmFtZSA9IFIuaGFzKCduYW1lJyk7XG4gKiAgICAgIGhhc05hbWUoe25hbWU6ICdhbGljZSd9KTsgICAvLz0+IHRydWVcbiAqICAgICAgaGFzTmFtZSh7bmFtZTogJ2JvYid9KTsgICAgIC8vPT4gdHJ1ZVxuICogICAgICBoYXNOYW1lKHt9KTsgICAgICAgICAgICAgICAgLy89PiBmYWxzZVxuICpcbiAqICAgICAgdmFyIHBvaW50ID0ge3g6IDAsIHk6IDB9O1xuICogICAgICB2YXIgcG9pbnRIYXMgPSBSLmhhcyhSLl9fLCBwb2ludCk7XG4gKiAgICAgIHBvaW50SGFzKCd4Jyk7ICAvLz0+IHRydWVcbiAqICAgICAgcG9pbnRIYXMoJ3knKTsgIC8vPT4gdHJ1ZVxuICogICAgICBwb2ludEhhcygneicpOyAgLy89PiBmYWxzZVxuICovXG52YXIgaGFzID0gLyojX19QVVJFX18qL19jdXJyeTIoX2hhcyk7XG5leHBvcnQgZGVmYXVsdCBoYXM7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluIGhhcyBhIHByb3BlcnR5IHdpdGhcbiAqIHRoZSBzcGVjaWZpZWQgbmFtZVxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBzIC0+IHtzOiB4fSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2sgZm9yLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgZXhpc3RzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGZ1bmN0aW9uIFJlY3RhbmdsZSh3aWR0aCwgaGVpZ2h0KSB7XG4gKiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICogICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICogICAgICB9XG4gKiAgICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uKCkge1xuICogICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gKiAgICAgIH07XG4gKlxuICogICAgICB2YXIgc3F1YXJlID0gbmV3IFJlY3RhbmdsZSgyLCAyKTtcbiAqICAgICAgUi5oYXNJbignd2lkdGgnLCBzcXVhcmUpOyAgLy89PiB0cnVlXG4gKiAgICAgIFIuaGFzSW4oJ2FyZWEnLCBzcXVhcmUpOyAgLy89PiB0cnVlXG4gKi9cbnZhciBoYXNJbiA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGhhc0luKHByb3AsIG9iaikge1xuICByZXR1cm4gcHJvcCBpbiBvYmo7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGhhc0luOyIsImltcG9ydCBudGggZnJvbSAnLi9udGgnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nLiBJbiBzb21lIGxpYnJhcmllc1xuICogdGhpcyBmdW5jdGlvbiBpcyBuYW1lZCBgZmlyc3RgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IGEgfCBVbmRlZmluZWRcbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIudGFpbCwgUi5pbml0LCBSLmxhc3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmhlYWQoWydmaScsICdmbycsICdmdW0nXSk7IC8vPT4gJ2ZpJ1xuICogICAgICBSLmhlYWQoW10pOyAvLz0+IHVuZGVmaW5lZFxuICpcbiAqICAgICAgUi5oZWFkKCdhYmMnKTsgLy89PiAnYSdcbiAqICAgICAgUi5oZWFkKCcnKTsgLy89PiAnJ1xuICovXG52YXIgaGVhZCA9IC8qI19fUFVSRV9fKi9udGgoMCk7XG5leHBvcnQgZGVmYXVsdCBoZWFkOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGl0cyBhcmd1bWVudHMgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlLiBWYWx1ZXMgYXJlXG4gKiBpZGVudGljYWwgaWYgdGhleSByZWZlcmVuY2UgdGhlIHNhbWUgbWVtb3J5LiBgTmFOYCBpcyBpZGVudGljYWwgdG8gYE5hTmA7XG4gKiBgMGAgYW5kIGAtMGAgYXJlIG5vdCBpZGVudGljYWwuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTUuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIGEgLT4gYSAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbyA9IHt9O1xuICogICAgICBSLmlkZW50aWNhbChvLCBvKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaWRlbnRpY2FsKDEsIDEpOyAvLz0+IHRydWVcbiAqICAgICAgUi5pZGVudGljYWwoMSwgJzEnKTsgLy89PiBmYWxzZVxuICogICAgICBSLmlkZW50aWNhbChbXSwgW10pOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaWRlbnRpY2FsKDAsIC0wKTsgLy89PiBmYWxzZVxuICogICAgICBSLmlkZW50aWNhbChOYU4sIE5hTik7IC8vPT4gdHJ1ZVxuICovXG52YXIgaWRlbnRpY2FsID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gaWRlbnRpY2FsKGEsIGIpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoYSA9PT0gYikge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbiAgfVxufSk7XG5leHBvcnQgZGVmYXVsdCBpZGVudGljYWw7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBfaWRlbnRpdHkgZnJvbSAnLi9pbnRlcm5hbC9faWRlbnRpdHknO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHJldHVybiB0aGUgcGFyYW1ldGVyIHN1cHBsaWVkIHRvIGl0LiBHb29kXG4gKiBhcyBhIGRlZmF1bHQgb3IgcGxhY2Vob2xkZXIgZnVuY3Rpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgYSAtPiBhXG4gKiBAcGFyYW0geyp9IHggVGhlIHZhbHVlIHRvIHJldHVybi5cbiAqIEByZXR1cm4geyp9IFRoZSBpbnB1dCB2YWx1ZSwgYHhgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaWRlbnRpdHkoMSk7IC8vPT4gMVxuICpcbiAqICAgICAgdmFyIG9iaiA9IHt9O1xuICogICAgICBSLmlkZW50aXR5KG9iaikgPT09IG9iajsgLy89PiB0cnVlXG4gKiBAc3ltYiBSLmlkZW50aXR5KGEpID0gYVxuICovXG52YXIgaWRlbnRpdHkgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShfaWRlbnRpdHkpO1xuZXhwb3J0IGRlZmF1bHQgaWRlbnRpdHk7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcbmltcG9ydCBjdXJyeU4gZnJvbSAnLi9jdXJyeU4nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvY2VzcyBlaXRoZXIgdGhlIGBvblRydWVgIG9yIHRoZSBgb25GYWxzZWBcbiAqIGZ1bmN0aW9uIGRlcGVuZGluZyB1cG9uIHRoZSByZXN1bHQgb2YgdGhlIGBjb25kaXRpb25gIHByZWRpY2F0ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyAoKi4uLiAtPiBCb29sZWFuKSAtPiAoKi4uLiAtPiAqKSAtPiAoKi4uLiAtPiAqKSAtPiAoKi4uLiAtPiAqKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIEEgcHJlZGljYXRlIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblRydWUgQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYGNvbmRpdGlvbmAgZXZhbHVhdGVzIHRvIGEgdHJ1dGh5IHZhbHVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb25GYWxzZSBBIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIHRoZSBgY29uZGl0aW9uYCBldmFsdWF0ZXMgdG8gYSBmYWxzeSB2YWx1ZS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyB1bmFyeSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvY2VzcyBlaXRoZXIgdGhlIGBvblRydWVgIG9yIHRoZSBgb25GYWxzZWBcbiAqICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZXBlbmRpbmcgdXBvbiB0aGUgcmVzdWx0IG9mIHRoZSBgY29uZGl0aW9uYCBwcmVkaWNhdGUuXG4gKiBAc2VlIFIudW5sZXNzLCBSLndoZW5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaW5jQ291bnQgPSBSLmlmRWxzZShcbiAqICAgICAgICBSLmhhcygnY291bnQnKSxcbiAqICAgICAgICBSLm92ZXIoUi5sZW5zUHJvcCgnY291bnQnKSwgUi5pbmMpLFxuICogICAgICAgIFIuYXNzb2MoJ2NvdW50JywgMSlcbiAqICAgICAgKTtcbiAqICAgICAgaW5jQ291bnQoe30pOyAgICAgICAgICAgLy89PiB7IGNvdW50OiAxIH1cbiAqICAgICAgaW5jQ291bnQoeyBjb3VudDogMSB9KTsgLy89PiB7IGNvdW50OiAyIH1cbiAqL1xudmFyIGlmRWxzZSA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIGlmRWxzZShjb25kaXRpb24sIG9uVHJ1ZSwgb25GYWxzZSkge1xuICByZXR1cm4gY3VycnlOKE1hdGgubWF4KGNvbmRpdGlvbi5sZW5ndGgsIG9uVHJ1ZS5sZW5ndGgsIG9uRmFsc2UubGVuZ3RoKSwgZnVuY3Rpb24gX2lmRWxzZSgpIHtcbiAgICByZXR1cm4gY29uZGl0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPyBvblRydWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IG9uRmFsc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGlmRWxzZTsiLCJpbXBvcnQgYWRkIGZyb20gJy4vYWRkJztcblxuLyoqXG4gKiBJbmNyZW1lbnRzIGl0cyBhcmd1bWVudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IG4gKyAxXG4gKiBAc2VlIFIuZGVjXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pbmMoNDIpOyAvLz0+IDQzXG4gKi9cbnZhciBpbmMgPSAvKiNfX1BVUkVfXyovYWRkKDEpO1xuZXhwb3J0IGRlZmF1bHQgaW5jOyIsImV4cG9ydCB7IGRlZmF1bHQgYXMgRiB9IGZyb20gJy4vRic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFQgfSBmcm9tICcuL1QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBfXyB9IGZyb20gJy4vX18nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhZGQgfSBmcm9tICcuL2FkZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFkZEluZGV4IH0gZnJvbSAnLi9hZGRJbmRleCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFkanVzdCB9IGZyb20gJy4vYWRqdXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYWxsIH0gZnJvbSAnLi9hbGwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhbGxQYXNzIH0gZnJvbSAnLi9hbGxQYXNzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYWx3YXlzIH0gZnJvbSAnLi9hbHdheXMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhbmQgfSBmcm9tICcuL2FuZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFueSB9IGZyb20gJy4vYW55JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYW55UGFzcyB9IGZyb20gJy4vYW55UGFzcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFwIH0gZnJvbSAnLi9hcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFwZXJ0dXJlIH0gZnJvbSAnLi9hcGVydHVyZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFwcGVuZCB9IGZyb20gJy4vYXBwZW5kJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXBwbHkgfSBmcm9tICcuL2FwcGx5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXBwbHlTcGVjIH0gZnJvbSAnLi9hcHBseVNwZWMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhcHBseVRvIH0gZnJvbSAnLi9hcHBseVRvJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXNjZW5kIH0gZnJvbSAnLi9hc2NlbmQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhc3NvYyB9IGZyb20gJy4vYXNzb2MnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhc3NvY1BhdGggfSBmcm9tICcuL2Fzc29jUGF0aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGJpbmFyeSB9IGZyb20gJy4vYmluYXJ5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYmluZCB9IGZyb20gJy4vYmluZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGJvdGggfSBmcm9tICcuL2JvdGgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjYWxsIH0gZnJvbSAnLi9jYWxsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY2hhaW4gfSBmcm9tICcuL2NoYWluJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY2xhbXAgfSBmcm9tICcuL2NsYW1wJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY2xvbmUgfSBmcm9tICcuL2Nsb25lJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29tcGFyYXRvciB9IGZyb20gJy4vY29tcGFyYXRvcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbXBsZW1lbnQgfSBmcm9tICcuL2NvbXBsZW1lbnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb21wb3NlIH0gZnJvbSAnLi9jb21wb3NlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29tcG9zZUsgfSBmcm9tICcuL2NvbXBvc2VLJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29tcG9zZVAgfSBmcm9tICcuL2NvbXBvc2VQJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29uY2F0IH0gZnJvbSAnLi9jb25jYXQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb25kIH0gZnJvbSAnLi9jb25kJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29uc3RydWN0IH0gZnJvbSAnLi9jb25zdHJ1Y3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb25zdHJ1Y3ROIH0gZnJvbSAnLi9jb25zdHJ1Y3ROJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29udGFpbnMgfSBmcm9tICcuL2NvbnRhaW5zJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29udmVyZ2UgfSBmcm9tICcuL2NvbnZlcmdlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY291bnRCeSB9IGZyb20gJy4vY291bnRCeSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGN1cnJ5IH0gZnJvbSAnLi9jdXJyeSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGN1cnJ5TiB9IGZyb20gJy4vY3VycnlOJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZGVjIH0gZnJvbSAnLi9kZWMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBkZWZhdWx0VG8gfSBmcm9tICcuL2RlZmF1bHRUbyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRlc2NlbmQgfSBmcm9tICcuL2Rlc2NlbmQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBkaWZmZXJlbmNlIH0gZnJvbSAnLi9kaWZmZXJlbmNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZGlmZmVyZW5jZVdpdGggfSBmcm9tICcuL2RpZmZlcmVuY2VXaXRoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZGlzc29jIH0gZnJvbSAnLi9kaXNzb2MnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBkaXNzb2NQYXRoIH0gZnJvbSAnLi9kaXNzb2NQYXRoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZGl2aWRlIH0gZnJvbSAnLi9kaXZpZGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBkcm9wIH0gZnJvbSAnLi9kcm9wJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZHJvcExhc3QgfSBmcm9tICcuL2Ryb3BMYXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZHJvcExhc3RXaGlsZSB9IGZyb20gJy4vZHJvcExhc3RXaGlsZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRyb3BSZXBlYXRzIH0gZnJvbSAnLi9kcm9wUmVwZWF0cyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRyb3BSZXBlYXRzV2l0aCB9IGZyb20gJy4vZHJvcFJlcGVhdHNXaXRoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZHJvcFdoaWxlIH0gZnJvbSAnLi9kcm9wV2hpbGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBlaXRoZXIgfSBmcm9tICcuL2VpdGhlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGVtcHR5IH0gZnJvbSAnLi9lbXB0eSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGVuZHNXaXRoIH0gZnJvbSAnLi9lbmRzV2l0aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGVxQnkgfSBmcm9tICcuL2VxQnknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBlcVByb3BzIH0gZnJvbSAnLi9lcVByb3BzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZXF1YWxzIH0gZnJvbSAnLi9lcXVhbHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBldm9sdmUgfSBmcm9tICcuL2V2b2x2ZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpbHRlciB9IGZyb20gJy4vZmlsdGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZmluZCB9IGZyb20gJy4vZmluZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpbmRJbmRleCB9IGZyb20gJy4vZmluZEluZGV4JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZmluZExhc3QgfSBmcm9tICcuL2ZpbmRMYXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZmluZExhc3RJbmRleCB9IGZyb20gJy4vZmluZExhc3RJbmRleCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZsYXR0ZW4gfSBmcm9tICcuL2ZsYXR0ZW4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmbGlwIH0gZnJvbSAnLi9mbGlwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZm9yRWFjaCB9IGZyb20gJy4vZm9yRWFjaCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZvckVhY2hPYmpJbmRleGVkIH0gZnJvbSAnLi9mb3JFYWNoT2JqSW5kZXhlZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZyb21QYWlycyB9IGZyb20gJy4vZnJvbVBhaXJzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZ3JvdXBCeSB9IGZyb20gJy4vZ3JvdXBCeSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGdyb3VwV2l0aCB9IGZyb20gJy4vZ3JvdXBXaXRoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZ3QgfSBmcm9tICcuL2d0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZ3RlIH0gZnJvbSAnLi9ndGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBoYXMgfSBmcm9tICcuL2hhcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGhhc0luIH0gZnJvbSAnLi9oYXNJbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGhlYWQgfSBmcm9tICcuL2hlYWQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpZGVudGljYWwgfSBmcm9tICcuL2lkZW50aWNhbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGlkZW50aXR5IH0gZnJvbSAnLi9pZGVudGl0eSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGlmRWxzZSB9IGZyb20gJy4vaWZFbHNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaW5jIH0gZnJvbSAnLi9pbmMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpbmRleEJ5IH0gZnJvbSAnLi9pbmRleEJ5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaW5kZXhPZiB9IGZyb20gJy4vaW5kZXhPZic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGluaXQgfSBmcm9tICcuL2luaXQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpbm5lckpvaW4gfSBmcm9tICcuL2lubmVySm9pbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGluc2VydCB9IGZyb20gJy4vaW5zZXJ0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaW5zZXJ0QWxsIH0gZnJvbSAnLi9pbnNlcnRBbGwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpbnRlcnNlY3Rpb24gfSBmcm9tICcuL2ludGVyc2VjdGlvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGludGVyc3BlcnNlIH0gZnJvbSAnLi9pbnRlcnNwZXJzZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGludG8gfSBmcm9tICcuL2ludG8nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpbnZlcnQgfSBmcm9tICcuL2ludmVydCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGludmVydE9iaiB9IGZyb20gJy4vaW52ZXJ0T2JqJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaW52b2tlciB9IGZyb20gJy4vaW52b2tlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGlzIH0gZnJvbSAnLi9pcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGlzRW1wdHkgfSBmcm9tICcuL2lzRW1wdHknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpc05pbCB9IGZyb20gJy4vaXNOaWwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBqb2luIH0gZnJvbSAnLi9qb2luJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMganV4dCB9IGZyb20gJy4vanV4dCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGtleXMgfSBmcm9tICcuL2tleXMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBrZXlzSW4gfSBmcm9tICcuL2tleXNJbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGxhc3QgfSBmcm9tICcuL2xhc3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsYXN0SW5kZXhPZiB9IGZyb20gJy4vbGFzdEluZGV4T2YnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsZW5ndGggfSBmcm9tICcuL2xlbmd0aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGxlbnMgfSBmcm9tICcuL2xlbnMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsZW5zSW5kZXggfSBmcm9tICcuL2xlbnNJbmRleCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGxlbnNQYXRoIH0gZnJvbSAnLi9sZW5zUGF0aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGxlbnNQcm9wIH0gZnJvbSAnLi9sZW5zUHJvcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGxpZnQgfSBmcm9tICcuL2xpZnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsaWZ0TiB9IGZyb20gJy4vbGlmdE4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsdCB9IGZyb20gJy4vbHQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsdGUgfSBmcm9tICcuL2x0ZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1hcCB9IGZyb20gJy4vbWFwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWFwQWNjdW0gfSBmcm9tICcuL21hcEFjY3VtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWFwQWNjdW1SaWdodCB9IGZyb20gJy4vbWFwQWNjdW1SaWdodCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1hcE9iakluZGV4ZWQgfSBmcm9tICcuL21hcE9iakluZGV4ZWQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtYXRjaCB9IGZyb20gJy4vbWF0Y2gnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtYXRoTW9kIH0gZnJvbSAnLi9tYXRoTW9kJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWF4IH0gZnJvbSAnLi9tYXgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtYXhCeSB9IGZyb20gJy4vbWF4QnknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtZWFuIH0gZnJvbSAnLi9tZWFuJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWVkaWFuIH0gZnJvbSAnLi9tZWRpYW4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtZW1vaXplIH0gZnJvbSAnLi9tZW1vaXplJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWVtb2l6ZVdpdGggfSBmcm9tICcuL21lbW9pemVXaXRoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWVyZ2UgfSBmcm9tICcuL21lcmdlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWVyZ2VBbGwgfSBmcm9tICcuL21lcmdlQWxsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWVyZ2VEZWVwTGVmdCB9IGZyb20gJy4vbWVyZ2VEZWVwTGVmdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1lcmdlRGVlcFJpZ2h0IH0gZnJvbSAnLi9tZXJnZURlZXBSaWdodCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1lcmdlRGVlcFdpdGggfSBmcm9tICcuL21lcmdlRGVlcFdpdGgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtZXJnZURlZXBXaXRoS2V5IH0gZnJvbSAnLi9tZXJnZURlZXBXaXRoS2V5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWVyZ2VXaXRoIH0gZnJvbSAnLi9tZXJnZVdpdGgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtZXJnZVdpdGhLZXkgfSBmcm9tICcuL21lcmdlV2l0aEtleSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1pbiB9IGZyb20gJy4vbWluJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWluQnkgfSBmcm9tICcuL21pbkJ5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbW9kdWxvIH0gZnJvbSAnLi9tb2R1bG8nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtdWx0aXBseSB9IGZyb20gJy4vbXVsdGlwbHknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBuQXJ5IH0gZnJvbSAnLi9uQXJ5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbmVnYXRlIH0gZnJvbSAnLi9uZWdhdGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBub25lIH0gZnJvbSAnLi9ub25lJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbm90IH0gZnJvbSAnLi9ub3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBudGggfSBmcm9tICcuL250aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG50aEFyZyB9IGZyb20gJy4vbnRoQXJnJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbyB9IGZyb20gJy4vbyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG9iak9mIH0gZnJvbSAnLi9vYmpPZic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG9mIH0gZnJvbSAnLi9vZic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG9taXQgfSBmcm9tICcuL29taXQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBvbmNlIH0gZnJvbSAnLi9vbmNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgb3IgfSBmcm9tICcuL29yJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgb3ZlciB9IGZyb20gJy4vb3Zlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhaXIgfSBmcm9tICcuL3BhaXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJ0aWFsIH0gZnJvbSAnLi9wYXJ0aWFsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFydGlhbFJpZ2h0IH0gZnJvbSAnLi9wYXJ0aWFsUmlnaHQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJ0aXRpb24gfSBmcm9tICcuL3BhcnRpdGlvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhdGggfSBmcm9tICcuL3BhdGgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXRoRXEgfSBmcm9tICcuL3BhdGhFcSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhdGhPciB9IGZyb20gJy4vcGF0aE9yJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGF0aFNhdGlzZmllcyB9IGZyb20gJy4vcGF0aFNhdGlzZmllcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBpY2sgfSBmcm9tICcuL3BpY2snO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwaWNrQWxsIH0gZnJvbSAnLi9waWNrQWxsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGlja0J5IH0gZnJvbSAnLi9waWNrQnknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwaXBlIH0gZnJvbSAnLi9waXBlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGlwZUsgfSBmcm9tICcuL3BpcGVLJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGlwZVAgfSBmcm9tICcuL3BpcGVQJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGx1Y2sgfSBmcm9tICcuL3BsdWNrJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcHJlcGVuZCB9IGZyb20gJy4vcHJlcGVuZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHByb2R1Y3QgfSBmcm9tICcuL3Byb2R1Y3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwcm9qZWN0IH0gZnJvbSAnLi9wcm9qZWN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcHJvcCB9IGZyb20gJy4vcHJvcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHByb3BFcSB9IGZyb20gJy4vcHJvcEVxJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcHJvcElzIH0gZnJvbSAnLi9wcm9wSXMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwcm9wT3IgfSBmcm9tICcuL3Byb3BPcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHByb3BTYXRpc2ZpZXMgfSBmcm9tICcuL3Byb3BTYXRpc2ZpZXMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwcm9wcyB9IGZyb20gJy4vcHJvcHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByYW5nZSB9IGZyb20gJy4vcmFuZ2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByZWR1Y2UgfSBmcm9tICcuL3JlZHVjZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHJlZHVjZUJ5IH0gZnJvbSAnLi9yZWR1Y2VCeSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHJlZHVjZVJpZ2h0IH0gZnJvbSAnLi9yZWR1Y2VSaWdodCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHJlZHVjZVdoaWxlIH0gZnJvbSAnLi9yZWR1Y2VXaGlsZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHJlZHVjZWQgfSBmcm9tICcuL3JlZHVjZWQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByZWplY3QgfSBmcm9tICcuL3JlamVjdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHJlbW92ZSB9IGZyb20gJy4vcmVtb3ZlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcmVwZWF0IH0gZnJvbSAnLi9yZXBlYXQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByZXBsYWNlIH0gZnJvbSAnLi9yZXBsYWNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcmV2ZXJzZSB9IGZyb20gJy4vcmV2ZXJzZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNjYW4gfSBmcm9tICcuL3NjYW4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzZXF1ZW5jZSB9IGZyb20gJy4vc2VxdWVuY2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzZXQgfSBmcm9tICcuL3NldCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNsaWNlIH0gZnJvbSAnLi9zbGljZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNvcnQgfSBmcm9tICcuL3NvcnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzb3J0QnkgfSBmcm9tICcuL3NvcnRCeSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNvcnRXaXRoIH0gZnJvbSAnLi9zb3J0V2l0aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNwbGl0IH0gZnJvbSAnLi9zcGxpdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNwbGl0QXQgfSBmcm9tICcuL3NwbGl0QXQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzcGxpdEV2ZXJ5IH0gZnJvbSAnLi9zcGxpdEV2ZXJ5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3BsaXRXaGVuIH0gZnJvbSAnLi9zcGxpdFdoZW4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzdGFydHNXaXRoIH0gZnJvbSAnLi9zdGFydHNXaXRoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3VidHJhY3QgfSBmcm9tICcuL3N1YnRyYWN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3VtIH0gZnJvbSAnLi9zdW0nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzeW1tZXRyaWNEaWZmZXJlbmNlIH0gZnJvbSAnLi9zeW1tZXRyaWNEaWZmZXJlbmNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3ltbWV0cmljRGlmZmVyZW5jZVdpdGggfSBmcm9tICcuL3N5bW1ldHJpY0RpZmZlcmVuY2VXaXRoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdGFpbCB9IGZyb20gJy4vdGFpbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRha2UgfSBmcm9tICcuL3Rha2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0YWtlTGFzdCB9IGZyb20gJy4vdGFrZUxhc3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0YWtlTGFzdFdoaWxlIH0gZnJvbSAnLi90YWtlTGFzdFdoaWxlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdGFrZVdoaWxlIH0gZnJvbSAnLi90YWtlV2hpbGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0YXAgfSBmcm9tICcuL3RhcCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRlc3QgfSBmcm9tICcuL3Rlc3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0aW1lcyB9IGZyb20gJy4vdGltZXMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0b0xvd2VyIH0gZnJvbSAnLi90b0xvd2VyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdG9QYWlycyB9IGZyb20gJy4vdG9QYWlycyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRvUGFpcnNJbiB9IGZyb20gJy4vdG9QYWlyc0luJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdG9TdHJpbmcgfSBmcm9tICcuL3RvU3RyaW5nJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdG9VcHBlciB9IGZyb20gJy4vdG9VcHBlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRyYW5zZHVjZSB9IGZyb20gJy4vdHJhbnNkdWNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdHJhbnNwb3NlIH0gZnJvbSAnLi90cmFuc3Bvc2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0cmF2ZXJzZSB9IGZyb20gJy4vdHJhdmVyc2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0cmltIH0gZnJvbSAnLi90cmltJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdHJ5Q2F0Y2ggfSBmcm9tICcuL3RyeUNhdGNoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdHlwZSB9IGZyb20gJy4vdHlwZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuYXBwbHkgfSBmcm9tICcuL3VuYXBwbHknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bmFyeSB9IGZyb20gJy4vdW5hcnknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bmN1cnJ5TiB9IGZyb20gJy4vdW5jdXJyeU4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bmZvbGQgfSBmcm9tICcuL3VuZm9sZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuaW9uIH0gZnJvbSAnLi91bmlvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuaW9uV2l0aCB9IGZyb20gJy4vdW5pb25XaXRoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdW5pcSB9IGZyb20gJy4vdW5pcSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVuaXFCeSB9IGZyb20gJy4vdW5pcUJ5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdW5pcVdpdGggfSBmcm9tICcuL3VuaXFXaXRoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdW5sZXNzIH0gZnJvbSAnLi91bmxlc3MnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1bm5lc3QgfSBmcm9tICcuL3VubmVzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVudGlsIH0gZnJvbSAnLi91bnRpbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVwZGF0ZSB9IGZyb20gJy4vdXBkYXRlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdXNlV2l0aCB9IGZyb20gJy4vdXNlV2l0aCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZhbHVlcyB9IGZyb20gJy4vdmFsdWVzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmFsdWVzSW4gfSBmcm9tICcuL3ZhbHVlc0luJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmlldyB9IGZyb20gJy4vdmlldyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHdoZW4gfSBmcm9tICcuL3doZW4nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB3aGVyZSB9IGZyb20gJy4vd2hlcmUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB3aGVyZUVxIH0gZnJvbSAnLi93aGVyZUVxJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgd2l0aG91dCB9IGZyb20gJy4vd2l0aG91dCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHhwcm9kIH0gZnJvbSAnLi94cHJvZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHppcCB9IGZyb20gJy4vemlwJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgemlwT2JqIH0gZnJvbSAnLi96aXBPYmonO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB6aXBXaXRoIH0gZnJvbSAnLi96aXBXaXRoJzsiLCJpbXBvcnQgcmVkdWNlQnkgZnJvbSAnLi9yZWR1Y2VCeSc7XG5cbi8qKlxuICogR2l2ZW4gYSBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBhIGtleSwgdHVybnMgYSBsaXN0IG9mIG9iamVjdHMgaW50byBhblxuICogb2JqZWN0IGluZGV4aW5nIHRoZSBvYmplY3RzIGJ5IHRoZSBnaXZlbiBrZXkuIE5vdGUgdGhhdCBpZiBtdWx0aXBsZVxuICogb2JqZWN0cyBnZW5lcmF0ZSB0aGUgc2FtZSB2YWx1ZSBmb3IgdGhlIGluZGV4aW5nIGtleSBvbmx5IHRoZSBsYXN0IHZhbHVlXG4gKiB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBnZW5lcmF0ZWQgb2JqZWN0LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBTdHJpbmcpIC0+IFt7azogdn1dIC0+IHtrOiB7azogdn19XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiA6OiBhIC0+IFN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIG9iamVjdHMgdG8gaW5kZXhcbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGluZGV4aW5nIGVhY2ggYXJyYXkgZWxlbWVudCBieSB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGxpc3QgPSBbe2lkOiAneHl6JywgdGl0bGU6ICdBJ30sIHtpZDogJ2FiYycsIHRpdGxlOiAnQid9XTtcbiAqICAgICAgUi5pbmRleEJ5KFIucHJvcCgnaWQnKSwgbGlzdCk7XG4gKiAgICAgIC8vPT4ge2FiYzoge2lkOiAnYWJjJywgdGl0bGU6ICdCJ30sIHh5ejoge2lkOiAneHl6JywgdGl0bGU6ICdBJ319XG4gKi9cbnZhciBpbmRleEJ5ID0gLyojX19QVVJFX18qL3JlZHVjZUJ5KGZ1bmN0aW9uIChhY2MsIGVsZW0pIHtcbiAgcmV0dXJuIGVsZW07XG59LCBudWxsKTtcbmV4cG9ydCBkZWZhdWx0IGluZGV4Qnk7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfaW5kZXhPZiBmcm9tICcuL2ludGVybmFsL19pbmRleE9mJztcbmltcG9ydCBfaXNBcnJheSBmcm9tICcuL2ludGVybmFsL19pc0FycmF5JztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LCBvciAtMVxuICogaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS4gW2BSLmVxdWFsc2BdKCNlcXVhbHMpIGlzIHVzZWQgdG9cbiAqIGRldGVybWluZSBlcXVhbGl0eS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gW2FdIC0+IE51bWJlclxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIGl0ZW0gdG8gZmluZC5cbiAqIEBwYXJhbSB7QXJyYXl9IHhzIFRoZSBhcnJheSB0byBzZWFyY2ggaW4uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgdGFyZ2V0LCBvciAtMSBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBmb3VuZC5cbiAqIEBzZWUgUi5sYXN0SW5kZXhPZlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaW5kZXhPZigzLCBbMSwyLDMsNF0pOyAvLz0+IDJcbiAqICAgICAgUi5pbmRleE9mKDEwLCBbMSwyLDMsNF0pOyAvLz0+IC0xXG4gKi9cbnZhciBpbmRleE9mID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gaW5kZXhPZih0YXJnZXQsIHhzKSB7XG4gIHJldHVybiB0eXBlb2YgeHMuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJyAmJiAhX2lzQXJyYXkoeHMpID8geHMuaW5kZXhPZih0YXJnZXQpIDogX2luZGV4T2YoeHMsIHRhcmdldCwgMCk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGluZGV4T2Y7IiwiaW1wb3J0IHNsaWNlIGZyb20gJy4vc2xpY2UnO1xuXG4vKipcbiAqIFJldHVybnMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV1cbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLmxhc3QsIFIuaGVhZCwgUi50YWlsXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pbml0KFsxLCAyLCAzXSk7ICAvLz0+IFsxLCAyXVxuICogICAgICBSLmluaXQoWzEsIDJdKTsgICAgIC8vPT4gWzFdXG4gKiAgICAgIFIuaW5pdChbMV0pOyAgICAgICAgLy89PiBbXVxuICogICAgICBSLmluaXQoW10pOyAgICAgICAgIC8vPT4gW11cbiAqXG4gKiAgICAgIFIuaW5pdCgnYWJjJyk7ICAvLz0+ICdhYidcbiAqICAgICAgUi5pbml0KCdhYicpOyAgIC8vPT4gJ2EnXG4gKiAgICAgIFIuaW5pdCgnYScpOyAgICAvLz0+ICcnXG4gKiAgICAgIFIuaW5pdCgnJyk7ICAgICAvLz0+ICcnXG4gKi9cbnZhciBpbml0ID0gLyojX19QVVJFX18qL3NsaWNlKDAsIC0xKTtcbmV4cG9ydCBkZWZhdWx0IGluaXQ7IiwiaW1wb3J0IF9jb250YWluc1dpdGggZnJvbSAnLi9pbnRlcm5hbC9fY29udGFpbnNXaXRoJztcbmltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgX2ZpbHRlciBmcm9tICcuL2ludGVybmFsL19maWx0ZXInO1xuXG4vKipcbiAqIFRha2VzIGEgcHJlZGljYXRlIGBwcmVkYCwgYSBsaXN0IGB4c2AsIGFuZCBhIGxpc3QgYHlzYCwgYW5kIHJldHVybnMgYSBsaXN0XG4gKiBgeHMnYCBjb21wcmlzaW5nIGVhY2ggb2YgdGhlIGVsZW1lbnRzIG9mIGB4c2Agd2hpY2ggaXMgZXF1YWwgdG8gb25lIG9yIG1vcmVcbiAqIGVsZW1lbnRzIG9mIGB5c2AgYWNjb3JkaW5nIHRvIGBwcmVkYC5cbiAqXG4gKiBgcHJlZGAgbXVzdCBiZSBhIGJpbmFyeSBmdW5jdGlvbiBleHBlY3RpbmcgYW4gZWxlbWVudCBmcm9tIGVhY2ggbGlzdC5cbiAqXG4gKiBgeHNgLCBgeXNgLCBhbmQgYHhzJ2AgYXJlIHRyZWF0ZWQgYXMgc2V0cywgc2VtYW50aWNhbGx5LCBzbyBvcmRlcmluZyBzaG91bGRcbiAqIG5vdCBiZSBzaWduaWZpY2FudCwgYnV0IHNpbmNlIGB4cydgIGlzIG9yZGVyZWQgdGhlIGltcGxlbWVudGF0aW9uIGd1YXJhbnRlZXNcbiAqIHRoYXQgaXRzIHZhbHVlcyBhcmUgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhleSBhcHBlYXIgaW4gYHhzYC4gRHVwbGljYXRlcyBhcmVcbiAqIG5vdCByZW1vdmVkLCBzbyBgeHMnYCBtYXkgY29udGFpbiBkdXBsaWNhdGVzIGlmIGB4c2AgY29udGFpbnMgZHVwbGljYXRlcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNC4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgKChhLCBiKSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2JdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZFxuICogQHBhcmFtIHtBcnJheX0geHNcbiAqIEBwYXJhbSB7QXJyYXl9IHlzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBzZWUgUi5pbnRlcnNlY3Rpb25cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmlubmVySm9pbihcbiAqICAgICAgICAocmVjb3JkLCBpZCkgPT4gcmVjb3JkLmlkID09PSBpZCxcbiAqICAgICAgICBbe2lkOiA4MjQsIG5hbWU6ICdSaWNoaWUgRnVyYXknfSxcbiAqICAgICAgICAge2lkOiA5NTYsIG5hbWU6ICdEZXdleSBNYXJ0aW4nfSxcbiAqICAgICAgICAge2lkOiAzMTMsIG5hbWU6ICdCcnVjZSBQYWxtZXInfSxcbiAqICAgICAgICAge2lkOiA0NTYsIG5hbWU6ICdTdGVwaGVuIFN0aWxscyd9LFxuICogICAgICAgICB7aWQ6IDE3NywgbmFtZTogJ05laWwgWW91bmcnfV0sXG4gKiAgICAgICAgWzE3NywgNDU2LCA5OTldXG4gKiAgICAgICk7XG4gKiAgICAgIC8vPT4gW3tpZDogNDU2LCBuYW1lOiAnU3RlcGhlbiBTdGlsbHMnfSwge2lkOiAxNzcsIG5hbWU6ICdOZWlsIFlvdW5nJ31dXG4gKi9cbnZhciBpbm5lckpvaW4gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBpbm5lckpvaW4ocHJlZCwgeHMsIHlzKSB7XG4gIHJldHVybiBfZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIF9jb250YWluc1dpdGgocHJlZCwgeCwgeXMpO1xuICB9LCB4cyk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGlubmVySm9pbjsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIEluc2VydHMgdGhlIHN1cHBsaWVkIGVsZW1lbnQgaW50byB0aGUgbGlzdCwgYXQgdGhlIHNwZWNpZmllZCBgaW5kZXhgLiBfTm90ZSB0aGF0XG5cbiAqIHRoaXMgaXMgbm90IGRlc3RydWN0aXZlXzogaXQgcmV0dXJucyBhIGNvcHkgb2YgdGhlIGxpc3Qgd2l0aCB0aGUgY2hhbmdlcy5cbiAqIDxzbWFsbD5ObyBsaXN0cyBoYXZlIGJlZW4gaGFybWVkIGluIHRoZSBhcHBsaWNhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLjwvc21hbGw+XG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMi4yXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gYSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgZWxlbWVudFxuICogQHBhcmFtIHsqfSBlbHQgVGhlIGVsZW1lbnQgdG8gaW5zZXJ0IGludG8gdGhlIEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGluc2VydCBpbnRvXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgQXJyYXkgd2l0aCBgZWx0YCBpbnNlcnRlZCBhdCBgaW5kZXhgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaW5zZXJ0KDIsICd4JywgWzEsMiwzLDRdKTsgLy89PiBbMSwyLCd4JywzLDRdXG4gKi9cbnZhciBpbnNlcnQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBpbnNlcnQoaWR4LCBlbHQsIGxpc3QpIHtcbiAgaWR4ID0gaWR4IDwgbGlzdC5sZW5ndGggJiYgaWR4ID49IDAgPyBpZHggOiBsaXN0Lmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIDApO1xuICByZXN1bHQuc3BsaWNlKGlkeCwgMCwgZWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgaW5zZXJ0OyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8qKlxuICogSW5zZXJ0cyB0aGUgc3ViLWxpc3QgaW50byB0aGUgbGlzdCwgYXQgdGhlIHNwZWNpZmllZCBgaW5kZXhgLiBfTm90ZSB0aGF0IHRoaXMgaXMgbm90XG4gKiBkZXN0cnVjdGl2ZV86IGl0IHJldHVybnMgYSBjb3B5IG9mIHRoZSBsaXN0IHdpdGggdGhlIGNoYW5nZXMuXG4gKiA8c21hbGw+Tm8gbGlzdHMgaGF2ZSBiZWVuIGhhcm1lZCBpbiB0aGUgYXBwbGljYXRpb24gb2YgdGhpcyBmdW5jdGlvbi48L3NtYWxsPlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgc3ViLWxpc3RcbiAqIEBwYXJhbSB7QXJyYXl9IGVsdHMgVGhlIHN1Yi1saXN0IHRvIGluc2VydCBpbnRvIHRoZSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpbnNlcnQgdGhlIHN1Yi1saXN0IGludG9cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBBcnJheSB3aXRoIGBlbHRzYCBpbnNlcnRlZCBzdGFydGluZyBhdCBgaW5kZXhgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaW5zZXJ0QWxsKDIsIFsneCcsJ3knLCd6J10sIFsxLDIsMyw0XSk7IC8vPT4gWzEsMiwneCcsJ3knLCd6JywzLDRdXG4gKi9cbnZhciBpbnNlcnRBbGwgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBpbnNlcnRBbGwoaWR4LCBlbHRzLCBsaXN0KSB7XG4gIGlkeCA9IGlkeCA8IGxpc3QubGVuZ3RoICYmIGlkeCA+PSAwID8gaWR4IDogbGlzdC5sZW5ndGg7XG4gIHJldHVybiBbXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCwgaWR4KSwgZWx0cywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgaWR4KSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGluc2VydEFsbDsiLCJpbXBvcnQgX2NvbnRhaW5zIGZyb20gJy4vX2NvbnRhaW5zJztcblxudmFyIF9TZXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfU2V0KCkge1xuICAgIC8qIGdsb2JhbHMgU2V0ICovXG4gICAgdGhpcy5fbmF0aXZlU2V0ID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBTZXQoKSA6IG51bGw7XG4gICAgdGhpcy5faXRlbXMgPSB7fTtcbiAgfVxuXG4gIC8vIHVudGlsIHdlIGZpZ3VyZSBvdXQgd2h5IGpzZG9jIGNob2tlcyBvbiB0aGlzXG4gIC8vIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgU2V0XG4gIC8vIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBpdGVtIGRpZCBub3QgZXhpc3QgcHJpb3IsIG90aGVyd2lzZSBmYWxzZVxuICAvL1xuICBfU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiAhaGFzT3JBZGQoaXRlbSwgdHJ1ZSwgdGhpcyk7XG4gIH07XG5cbiAgLy9cbiAgLy8gQHBhcmFtIGl0ZW0gVGhlIGl0ZW0gdG8gY2hlY2sgZm9yIGV4aXN0ZW5jZSBpbiB0aGUgU2V0XG4gIC8vIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBpdGVtIGV4aXN0cyBpbiB0aGUgU2V0LCBvdGhlcndpc2UgZmFsc2VcbiAgLy9cbiAgX1NldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaGFzT3JBZGQoaXRlbSwgZmFsc2UsIHRoaXMpO1xuICB9O1xuXG4gIC8vXG4gIC8vIENvbWJpbmVzIHRoZSBsb2dpYyBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBpdGVtIGlzIGEgbWVtYmVyIG9mIHRoZSBzZXQgYW5kXG4gIC8vIGZvciBhZGRpbmcgYSBuZXcgaXRlbSB0byB0aGUgc2V0LlxuICAvL1xuICAvLyBAcGFyYW0gaXRlbSAgICAgICBUaGUgaXRlbSB0byBjaGVjayBvciBhZGQgdG8gdGhlIFNldCBpbnN0YW5jZS5cbiAgLy8gQHBhcmFtIHNob3VsZEFkZCAgSWYgdHJ1ZSwgdGhlIGl0ZW0gd2lsbCBiZSBhZGRlZCB0byB0aGUgc2V0IGlmIGl0IGRvZXNuJ3RcbiAgLy8gICAgICAgICAgICAgICAgICAgYWxyZWFkeSBleGlzdC5cbiAgLy8gQHBhcmFtIHNldCAgICAgICAgVGhlIHNldCBpbnN0YW5jZSB0byBjaGVjayBvciBhZGQgdG8uXG4gIC8vIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGl0ZW0gYWxyZWFkeSBleGlzdGVkLCBvdGhlcndpc2UgZmFsc2UuXG4gIC8vXG4gIHJldHVybiBfU2V0O1xufSgpO1xuXG5mdW5jdGlvbiBoYXNPckFkZChpdGVtLCBzaG91bGRBZGQsIHNldCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBpdGVtO1xuICB2YXIgcHJldlNpemUsIG5ld1NpemU7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIC8vIGRpc3Rpbmd1aXNoIGJldHdlZW4gKzAgYW5kIC0wXG4gICAgICBpZiAoaXRlbSA9PT0gMCAmJiAxIC8gaXRlbSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIGlmIChzZXQuX2l0ZW1zWyctMCddKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgc2V0Ll9pdGVtc1snLTAnXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gdGhlc2UgdHlwZXMgY2FuIGFsbCB1dGlsaXNlIHRoZSBuYXRpdmUgU2V0XG4gICAgICBpZiAoc2V0Ll9uYXRpdmVTZXQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgIHByZXZTaXplID0gc2V0Ll9uYXRpdmVTZXQuc2l6ZTtcbiAgICAgICAgICBzZXQuX25hdGl2ZVNldC5hZGQoaXRlbSk7XG4gICAgICAgICAgbmV3U2l6ZSA9IHNldC5fbmF0aXZlU2V0LnNpemU7XG4gICAgICAgICAgcmV0dXJuIG5ld1NpemUgPT09IHByZXZTaXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZXQuX25hdGl2ZVNldC5oYXMoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKHR5cGUgaW4gc2V0Ll9pdGVtcykpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdID0ge307XG4gICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdW2l0ZW1dID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gaW4gc2V0Ll9pdGVtc1t0eXBlXSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV1baXRlbV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgLy8gc2V0Ll9pdGVtc1snYm9vbGVhbiddIGhvbGRzIGEgdHdvIGVsZW1lbnQgYXJyYXlcbiAgICAgIC8vIHJlcHJlc2VudGluZyBbIGZhbHNlRXhpc3RzLCB0cnVlRXhpc3RzIF1cbiAgICAgIGlmICh0eXBlIGluIHNldC5faXRlbXMpIHtcbiAgICAgICAgdmFyIGJJZHggPSBpdGVtID8gMSA6IDA7XG4gICAgICAgIGlmIChzZXQuX2l0ZW1zW3R5cGVdW2JJZHhdKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXVtiSWR4XSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0gPSBpdGVtID8gW2ZhbHNlLCB0cnVlXSA6IFt0cnVlLCBmYWxzZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgLy8gY29tcGFyZSBmdW5jdGlvbnMgZm9yIHJlZmVyZW5jZSBlcXVhbGl0eVxuICAgICAgaWYgKHNldC5fbmF0aXZlU2V0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICBwcmV2U2l6ZSA9IHNldC5fbmF0aXZlU2V0LnNpemU7XG4gICAgICAgICAgc2V0Ll9uYXRpdmVTZXQuYWRkKGl0ZW0pO1xuICAgICAgICAgIG5ld1NpemUgPSBzZXQuX25hdGl2ZVNldC5zaXplO1xuICAgICAgICAgIHJldHVybiBuZXdTaXplID09PSBwcmV2U2l6ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2V0Ll9uYXRpdmVTZXQuaGFzKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoISh0eXBlIGluIHNldC5faXRlbXMpKSB7XG4gICAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXSA9IFtpdGVtXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX2NvbnRhaW5zKGl0ZW0sIHNldC5faXRlbXNbdHlwZV0pKSB7XG4gICAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXS5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgaWYgKHNldC5faXRlbXNbdHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChpdGVtID09PSBudWxsKSB7XG4gICAgICAgIGlmICghc2V0Ll9pdGVtc1snbnVsbCddKSB7XG4gICAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgc2V0Ll9pdGVtc1snbnVsbCddID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gcmVkdWNlIHRoZSBzZWFyY2ggc2l6ZSBvZiBoZXRlcm9nZW5lb3VzIHNldHMgYnkgY3JlYXRpbmcgYnVja2V0c1xuICAgICAgLy8gZm9yIGVhY2ggdHlwZS5cbiAgICAgIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlbSk7XG4gICAgICBpZiAoISh0eXBlIGluIHNldC5faXRlbXMpKSB7XG4gICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdID0gW2l0ZW1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIHNjYW4gdGhyb3VnaCBhbGwgcHJldmlvdXNseSBhcHBsaWVkIGl0ZW1zXG4gICAgICBpZiAoIV9jb250YWlucyhpdGVtLCBzZXQuX2l0ZW1zW3R5cGVdKSkge1xuICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXS5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8vIEEgc2ltcGxlIFNldCB0eXBlIHRoYXQgaG9ub3VycyBSLmVxdWFscyBzZW1hbnRpY3NcbmV4cG9ydCBkZWZhdWx0IF9TZXQ7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FwZXJ0dXJlKG4sIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsaW1pdCA9IGxpc3QubGVuZ3RoIC0gKG4gLSAxKTtcbiAgdmFyIGFjYyA9IG5ldyBBcnJheShsaW1pdCA+PSAwID8gbGltaXQgOiAwKTtcbiAgd2hpbGUgKGlkeCA8IGxpbWl0KSB7XG4gICAgYWNjW2lkeF0gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCBpZHgsIGlkeCArIG4pO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBhY2M7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FyaXR5KG4sIGZuKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gIHN3aXRjaCAobikge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2KSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNykge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgY2FzZSA5OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4KSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDEwOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gX2FyaXR5IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciBubyBncmVhdGVyIHRoYW4gdGVuJyk7XG4gIH1cbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlGcm9tSXRlcmF0b3IoaXRlcikge1xuICB2YXIgbGlzdCA9IFtdO1xuICB2YXIgbmV4dDtcbiAgd2hpbGUgKCEobmV4dCA9IGl0ZXIubmV4dCgpKS5kb25lKSB7XG4gICAgbGlzdC5wdXNoKG5leHQudmFsdWUpO1xuICB9XG4gIHJldHVybiBsaXN0O1xufSIsImltcG9ydCBfb2JqZWN0QXNzaWduIGZyb20gJy4vX29iamVjdEFzc2lnbic7XG5cbmV4cG9ydCBkZWZhdWx0IHR5cGVvZiBPYmplY3QuYXNzaWduID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmFzc2lnbiA6IF9vYmplY3RBc3NpZ247IiwiaW1wb3J0IF9pc0FycmF5IGZyb20gJy4vX2lzQXJyYXknO1xuXG4vKipcbiAqIFRoaXMgY2hlY2tzIHdoZXRoZXIgYSBmdW5jdGlvbiBoYXMgYSBbbWV0aG9kbmFtZV0gZnVuY3Rpb24uIElmIGl0IGlzbid0IGFuXG4gKiBhcnJheSBpdCB3aWxsIGV4ZWN1dGUgdGhhdCBmdW5jdGlvbiBvdGhlcndpc2UgaXQgd2lsbCBkZWZhdWx0IHRvIHRoZSByYW1kYVxuICogaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHJhbWRhIGltcGxlbXRhdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZG5hbWUgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uXG4gKiBAcmV0dXJuIHtPYmplY3R9IFdoYXRldmVyIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIG1ldGhvZCBpcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NoZWNrRm9yTWV0aG9kKG1ldGhvZG5hbWUsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIHZhciBvYmogPSBhcmd1bWVudHNbbGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIF9pc0FycmF5KG9iaikgfHwgdHlwZW9mIG9ialttZXRob2RuYW1lXSAhPT0gJ2Z1bmN0aW9uJyA/IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBvYmpbbWV0aG9kbmFtZV0uYXBwbHkob2JqLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIGxlbmd0aCAtIDEpKTtcbiAgfTtcbn0iLCJpbXBvcnQgX2Nsb25lUmVnRXhwIGZyb20gJy4vX2Nsb25lUmVnRXhwJztcbmltcG9ydCB0eXBlIGZyb20gJy4uL3R5cGUnO1xuXG4vKipcbiAqIENvcGllcyBhbiBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNvcGllZFxuICogQHBhcmFtIHtBcnJheX0gcmVmRnJvbSBBcnJheSBjb250YWluaW5nIHRoZSBzb3VyY2UgcmVmZXJlbmNlc1xuICogQHBhcmFtIHtBcnJheX0gcmVmVG8gQXJyYXkgY29udGFpbmluZyB0aGUgY29waWVkIHNvdXJjZSByZWZlcmVuY2VzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRlZXAgV2hldGhlciBvciBub3QgdG8gcGVyZm9ybSBkZWVwIGNsb25pbmcuXG4gKiBAcmV0dXJuIHsqfSBUaGUgY29waWVkIHZhbHVlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY2xvbmUodmFsdWUsIHJlZkZyb20sIHJlZlRvLCBkZWVwKSB7XG4gIHZhciBjb3B5ID0gZnVuY3Rpb24gY29weShjb3BpZWRWYWx1ZSkge1xuICAgIHZhciBsZW4gPSByZWZGcm9tLmxlbmd0aDtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHJlZkZyb21baWR4XSkge1xuICAgICAgICByZXR1cm4gcmVmVG9baWR4XTtcbiAgICAgIH1cbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgICByZWZGcm9tW2lkeCArIDFdID0gdmFsdWU7XG4gICAgcmVmVG9baWR4ICsgMV0gPSBjb3BpZWRWYWx1ZTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGNvcGllZFZhbHVlW2tleV0gPSBkZWVwID8gX2Nsb25lKHZhbHVlW2tleV0sIHJlZkZyb20sIHJlZlRvLCB0cnVlKSA6IHZhbHVlW2tleV07XG4gICAgfVxuICAgIHJldHVybiBjb3BpZWRWYWx1ZTtcbiAgfTtcbiAgc3dpdGNoICh0eXBlKHZhbHVlKSkge1xuICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICByZXR1cm4gY29weSh7fSk7XG4gICAgY2FzZSAnQXJyYXknOlxuICAgICAgcmV0dXJuIGNvcHkoW10pO1xuICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlLnZhbHVlT2YoKSk7XG4gICAgY2FzZSAnUmVnRXhwJzpcbiAgICAgIHJldHVybiBfY2xvbmVSZWdFeHAodmFsdWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY2xvbmVSZWdFeHAocGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCAocGF0dGVybi5nbG9iYWwgPyAnZycgOiAnJykgKyAocGF0dGVybi5pZ25vcmVDYXNlID8gJ2knIDogJycpICsgKHBhdHRlcm4ubXVsdGlsaW5lID8gJ20nIDogJycpICsgKHBhdHRlcm4uc3RpY2t5ID8gJ3knIDogJycpICsgKHBhdHRlcm4udW5pY29kZSA/ICd1JyA6ICcnKSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NvbXBsZW1lbnQoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSIsIi8qKlxuICogUHJpdmF0ZSBgY29uY2F0YCBmdW5jdGlvbiB0byBtZXJnZSB0d28gYXJyYXktbGlrZSBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c30gW3NldDE9W11dIEFuIGFycmF5LWxpa2Ugb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheXxBcmd1bWVudHN9IFtzZXQyPVtdXSBBbiBhcnJheS1saWtlIG9iamVjdC5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldywgbWVyZ2VkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIF9jb25jYXQoWzQsIDUsIDZdLCBbMSwgMiwgM10pOyAvLz0+IFs0LCA1LCA2LCAxLCAyLCAzXVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY29uY2F0KHNldDEsIHNldDIpIHtcbiAgc2V0MSA9IHNldDEgfHwgW107XG4gIHNldDIgPSBzZXQyIHx8IFtdO1xuICB2YXIgaWR4O1xuICB2YXIgbGVuMSA9IHNldDEubGVuZ3RoO1xuICB2YXIgbGVuMiA9IHNldDIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IGxlbjEpIHtcbiAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBzZXQxW2lkeF07XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IGxlbjIpIHtcbiAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBzZXQyW2lkeF07XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0iLCJpbXBvcnQgX2luZGV4T2YgZnJvbSAnLi9faW5kZXhPZic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jb250YWlucyhhLCBsaXN0KSB7XG4gIHJldHVybiBfaW5kZXhPZihsaXN0LCBhLCAwKSA+PSAwO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jb250YWluc1dpdGgocHJlZCwgeCwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpZiAocHJlZCh4LCBsaXN0W2lkeF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSIsImltcG9ydCBfYXJpdHkgZnJvbSAnLi9fYXJpdHknO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9fY3VycnkyJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yKGNvbmNhdCkge1xuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiAoZm4sIGFyZ3MpIHtcbiAgICByZXR1cm4gX2FyaXR5KE1hdGgubWF4KDAsIGZuLmxlbmd0aCAtIGFyZ3MubGVuZ3RoKSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGNvbmNhdChhcmdzLCBhcmd1bWVudHMpKTtcbiAgICB9KTtcbiAgfSk7XG59IiwiaW1wb3J0IF9pc1BsYWNlaG9sZGVyIGZyb20gJy4vX2lzUGxhY2Vob2xkZXInO1xuXG4vKipcbiAqIE9wdGltaXplZCBpbnRlcm5hbCBvbmUtYXJpdHkgY3VycnkgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY3VycnkxKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmMShhKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgX2lzUGxhY2Vob2xkZXIoYSkpIHtcbiAgICAgIHJldHVybiBmMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufSIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vX2N1cnJ5MSc7XG5pbXBvcnQgX2lzUGxhY2Vob2xkZXIgZnJvbSAnLi9faXNQbGFjZWhvbGRlcic7XG5cbi8qKlxuICogT3B0aW1pemVkIGludGVybmFsIHR3by1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jdXJyeTIoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGYyKGEsIGIpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgPyBmMiA6IF9jdXJyeTEoZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKGEsIF9iKTtcbiAgICAgICAgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgPyBmMiA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICByZXR1cm4gZm4oX2EsIGIpO1xuICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGIpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgX2IpO1xuICAgICAgICB9KSA6IGZuKGEsIGIpO1xuICAgIH1cbiAgfTtcbn0iLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL19jdXJyeTEnO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9fY3VycnkyJztcbmltcG9ydCBfaXNQbGFjZWhvbGRlciBmcm9tICcuL19pc1BsYWNlaG9sZGVyJztcblxuLyoqXG4gKiBPcHRpbWl6ZWQgaW50ZXJuYWwgdGhyZWUtYXJpdHkgY3VycnkgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY3VycnkzKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmMyhhLCBiLCBjKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBmMztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpID8gZjMgOiBfY3VycnkyKGZ1bmN0aW9uIChfYiwgX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgX2IsIF9jKTtcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihiKSA/IGYzIDogX2lzUGxhY2Vob2xkZXIoYSkgPyBfY3VycnkyKGZ1bmN0aW9uIChfYSwgX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4oX2EsIGIsIF9jKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTIoZnVuY3Rpb24gKF9iLCBfYykge1xuICAgICAgICAgIHJldHVybiBmbihhLCBfYiwgX2MpO1xuICAgICAgICB9KSA6IF9jdXJyeTEoZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKGEsIGIsIF9jKTtcbiAgICAgICAgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgJiYgX2lzUGxhY2Vob2xkZXIoYykgPyBmMyA6IF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGIpID8gX2N1cnJ5MihmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKF9hLCBfYiwgYyk7XG4gICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYykgPyBfY3VycnkyKGZ1bmN0aW9uIChfYSwgX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4oX2EsIGIsIF9jKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihiKSAmJiBfaXNQbGFjZWhvbGRlcihjKSA/IF9jdXJyeTIoZnVuY3Rpb24gKF9iLCBfYykge1xuICAgICAgICAgIHJldHVybiBmbihhLCBfYiwgX2MpO1xuICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICByZXR1cm4gZm4oX2EsIGIsIGMpO1xuICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGIpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgX2IsIGMpO1xuICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGMpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgYiwgX2MpO1xuICAgICAgICB9KSA6IGZuKGEsIGIsIGMpO1xuICAgIH1cbiAgfTtcbn0iLCJpbXBvcnQgX2FyaXR5IGZyb20gJy4vX2FyaXR5JztcbmltcG9ydCBfaXNQbGFjZWhvbGRlciBmcm9tICcuL19pc1BsYWNlaG9sZGVyJztcblxuLyoqXG4gKiBJbnRlcm5hbCBjdXJyeU4gZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgYXJpdHkgb2YgdGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSByZWNlaXZlZCBBbiBhcnJheSBvZiBhcmd1bWVudHMgcmVjZWl2ZWQgdGh1cyBmYXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jdXJyeU4obGVuZ3RoLCByZWNlaXZlZCwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29tYmluZWQgPSBbXTtcbiAgICB2YXIgYXJnc0lkeCA9IDA7XG4gICAgdmFyIGxlZnQgPSBsZW5ndGg7XG4gICAgdmFyIGNvbWJpbmVkSWR4ID0gMDtcbiAgICB3aGlsZSAoY29tYmluZWRJZHggPCByZWNlaXZlZC5sZW5ndGggfHwgYXJnc0lkeCA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAoY29tYmluZWRJZHggPCByZWNlaXZlZC5sZW5ndGggJiYgKCFfaXNQbGFjZWhvbGRlcihyZWNlaXZlZFtjb21iaW5lZElkeF0pIHx8IGFyZ3NJZHggPj0gYXJndW1lbnRzLmxlbmd0aCkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZWRbY29tYmluZWRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzW2FyZ3NJZHhdO1xuICAgICAgICBhcmdzSWR4ICs9IDE7XG4gICAgICB9XG4gICAgICBjb21iaW5lZFtjb21iaW5lZElkeF0gPSByZXN1bHQ7XG4gICAgICBpZiAoIV9pc1BsYWNlaG9sZGVyKHJlc3VsdCkpIHtcbiAgICAgICAgbGVmdCAtPSAxO1xuICAgICAgfVxuICAgICAgY29tYmluZWRJZHggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQgPD0gMCA/IGZuLmFwcGx5KHRoaXMsIGNvbWJpbmVkKSA6IF9hcml0eShsZWZ0LCBfY3VycnlOKGxlbmd0aCwgY29tYmluZWQsIGZuKSk7XG4gIH07XG59IiwiaW1wb3J0IF9pc0FycmF5IGZyb20gJy4vX2lzQXJyYXknO1xuaW1wb3J0IF9pc1RyYW5zZm9ybWVyIGZyb20gJy4vX2lzVHJhbnNmb3JtZXInO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGRpc3BhdGNoZXMgd2l0aCBkaWZmZXJlbnQgc3RyYXRlZ2llcyBiYXNlZCBvbiB0aGVcbiAqIG9iamVjdCBpbiBsaXN0IHBvc2l0aW9uIChsYXN0IGFyZ3VtZW50KS4gSWYgaXQgaXMgYW4gYXJyYXksIGV4ZWN1dGVzIFtmbl0uXG4gKiBPdGhlcndpc2UsIGlmIGl0IGhhcyBhIGZ1bmN0aW9uIHdpdGggb25lIG9mIHRoZSBnaXZlbiBtZXRob2QgbmFtZXMsIGl0IHdpbGxcbiAqIGV4ZWN1dGUgdGhhdCBmdW5jdGlvbiAoZnVuY3RvciBjYXNlKS4gT3RoZXJ3aXNlLCBpZiBpdCBpcyBhIHRyYW5zZm9ybWVyLFxuICogdXNlcyB0cmFuc2R1Y2VyIFt4Zl0gdG8gcmV0dXJuIGEgbmV3IHRyYW5zZm9ybWVyICh0cmFuc2R1Y2VyIGNhc2UpLlxuICogT3RoZXJ3aXNlLCBpdCB3aWxsIGRlZmF1bHQgdG8gZXhlY3V0aW5nIFtmbl0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IG1ldGhvZE5hbWVzIHByb3BlcnRpZXMgdG8gY2hlY2sgZm9yIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB4ZiB0cmFuc2R1Y2VyIHRvIGluaXRpYWxpemUgaWYgb2JqZWN0IGlzIHRyYW5zZm9ybWVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBkZWZhdWx0IHJhbWRhIGltcGxlbWVudGF0aW9uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IGRpc3BhdGNoZXMgb24gb2JqZWN0IGluIGxpc3QgcG9zaXRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Rpc3BhdGNoYWJsZShtZXRob2ROYW1lcywgeGYsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgdmFyIG9iaiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKCFfaXNBcnJheShvYmopKSB7XG4gICAgICB2YXIgaWR4ID0gMDtcbiAgICAgIHdoaWxlIChpZHggPCBtZXRob2ROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmpbbWV0aG9kTmFtZXNbaWR4XV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gb2JqW21ldGhvZE5hbWVzW2lkeF1dLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWR4ICs9IDE7XG4gICAgICB9XG4gICAgICBpZiAoX2lzVHJhbnNmb3JtZXIob2JqKSkge1xuICAgICAgICB2YXIgdHJhbnNkdWNlciA9IHhmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdHJhbnNkdWNlcihvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0iLCJpbXBvcnQgdGFrZSBmcm9tICcuLi90YWtlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZHJvcExhc3QobiwgeHMpIHtcbiAgcmV0dXJuIHRha2UobiA8IHhzLmxlbmd0aCA/IHhzLmxlbmd0aCAtIG4gOiAwLCB4cyk7XG59IiwiaW1wb3J0IHNsaWNlIGZyb20gJy4uL3NsaWNlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZHJvcExhc3RXaGlsZShwcmVkLCB4cykge1xuICB2YXIgaWR4ID0geHMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGlkeCA+PSAwICYmIHByZWQoeHNbaWR4XSkpIHtcbiAgICBpZHggLT0gMTtcbiAgfVxuICByZXR1cm4gc2xpY2UoMCwgaWR4ICsgMSwgeHMpO1xufSIsImltcG9ydCBfYXJyYXlGcm9tSXRlcmF0b3IgZnJvbSAnLi9fYXJyYXlGcm9tSXRlcmF0b3InO1xuaW1wb3J0IF9jb250YWluc1dpdGggZnJvbSAnLi9fY29udGFpbnNXaXRoJztcbmltcG9ydCBfZnVuY3Rpb25OYW1lIGZyb20gJy4vX2Z1bmN0aW9uTmFtZSc7XG5pbXBvcnQgX2hhcyBmcm9tICcuL19oYXMnO1xuaW1wb3J0IGlkZW50aWNhbCBmcm9tICcuLi9pZGVudGljYWwnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi4va2V5cyc7XG5pbXBvcnQgdHlwZSBmcm9tICcuLi90eXBlJztcblxuLyoqXG4gKiBwcml2YXRlIF91bmlxQ29udGVudEVxdWFscyBmdW5jdGlvbi5cbiAqIFRoYXQgZnVuY3Rpb24gaXMgY2hlY2tpbmcgZXF1YWxpdHkgb2YgMiBpdGVyYXRvciBjb250ZW50cyB3aXRoIDIgYXNzdW1wdGlvbnNcbiAqIC0gaXRlcmF0b3JzIGxlbmd0aHMgYXJlIHRoZSBzYW1lXG4gKiAtIGl0ZXJhdG9ycyB2YWx1ZXMgYXJlIHVuaXF1ZVxuICpcbiAqIGZhbHNlLXBvc2l0aXZlIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIGZvciBjb21wYXJpc2lvbiBvZiwgZS5nLlxuICogLSBbMSwyLDNdIGFuZCBbMSwyLDMsNF1cbiAqIC0gWzEsMSwxXSBhbmQgWzEsMiwzXVxuICogKi9cblxuZnVuY3Rpb24gX3VuaXFDb250ZW50RXF1YWxzKGFJdGVyYXRvciwgYkl0ZXJhdG9yLCBzdGFja0EsIHN0YWNrQikge1xuICB2YXIgYSA9IF9hcnJheUZyb21JdGVyYXRvcihhSXRlcmF0b3IpO1xuICB2YXIgYiA9IF9hcnJheUZyb21JdGVyYXRvcihiSXRlcmF0b3IpO1xuXG4gIGZ1bmN0aW9uIGVxKF9hLCBfYikge1xuICAgIHJldHVybiBfZXF1YWxzKF9hLCBfYiwgc3RhY2tBLnNsaWNlKCksIHN0YWNrQi5zbGljZSgpKTtcbiAgfVxuXG4gIC8vIGlmICphKiBhcnJheSBjb250YWlucyBhbnkgZWxlbWVudCB0aGF0IGlzIG5vdCBpbmNsdWRlZCBpbiAqYipcbiAgcmV0dXJuICFfY29udGFpbnNXaXRoKGZ1bmN0aW9uIChiLCBhSXRlbSkge1xuICAgIHJldHVybiAhX2NvbnRhaW5zV2l0aChlcSwgYUl0ZW0sIGIpO1xuICB9LCBiLCBhKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2VxdWFscyhhLCBiLCBzdGFja0EsIHN0YWNrQikge1xuICBpZiAoaWRlbnRpY2FsKGEsIGIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgdHlwZUEgPSB0eXBlKGEpO1xuXG4gIGlmICh0eXBlQSAhPT0gdHlwZShiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhWydmYW50YXN5LWxhbmQvZXF1YWxzJ10gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGJbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlb2YgYVsnZmFudGFzeS1sYW5kL2VxdWFscyddID09PSAnZnVuY3Rpb24nICYmIGFbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXShiKSAmJiB0eXBlb2YgYlsnZmFudGFzeS1sYW5kL2VxdWFscyddID09PSAnZnVuY3Rpb24nICYmIGJbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXShhKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYS5lcXVhbHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGIuZXF1YWxzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJyAmJiBhLmVxdWFscyhiKSAmJiB0eXBlb2YgYi5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiYgYi5lcXVhbHMoYSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVBKSB7XG4gICAgY2FzZSAnQXJndW1lbnRzJzpcbiAgICBjYXNlICdBcnJheSc6XG4gICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgIGlmICh0eXBlb2YgYS5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiBfZnVuY3Rpb25OYW1lKGEuY29uc3RydWN0b3IpID09PSAnUHJvbWlzZScpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdCb29sZWFuJzpcbiAgICBjYXNlICdOdW1iZXInOlxuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICBpZiAoISh0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgaWRlbnRpY2FsKGEudmFsdWVPZigpLCBiLnZhbHVlT2YoKSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgaWYgKCFpZGVudGljYWwoYS52YWx1ZU9mKCksIGIudmFsdWVPZigpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdFcnJvcic6XG4gICAgICByZXR1cm4gYS5uYW1lID09PSBiLm5hbWUgJiYgYS5tZXNzYWdlID09PSBiLm1lc3NhZ2U7XG4gICAgY2FzZSAnUmVnRXhwJzpcbiAgICAgIGlmICghKGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmdsb2JhbCA9PT0gYi5nbG9iYWwgJiYgYS5pZ25vcmVDYXNlID09PSBiLmlnbm9yZUNhc2UgJiYgYS5tdWx0aWxpbmUgPT09IGIubXVsdGlsaW5lICYmIGEuc3RpY2t5ID09PSBiLnN0aWNreSAmJiBhLnVuaWNvZGUgPT09IGIudW5pY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgaWR4ID0gc3RhY2tBLmxlbmd0aCAtIDE7XG4gIHdoaWxlIChpZHggPj0gMCkge1xuICAgIGlmIChzdGFja0FbaWR4XSA9PT0gYSkge1xuICAgICAgcmV0dXJuIHN0YWNrQltpZHhdID09PSBiO1xuICAgIH1cbiAgICBpZHggLT0gMTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZUEpIHtcbiAgICBjYXNlICdNYXAnOlxuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF91bmlxQ29udGVudEVxdWFscyhhLmVudHJpZXMoKSwgYi5lbnRyaWVzKCksIHN0YWNrQS5jb25jYXQoW2FdKSwgc3RhY2tCLmNvbmNhdChbYl0pKTtcbiAgICBjYXNlICdTZXQnOlxuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF91bmlxQ29udGVudEVxdWFscyhhLnZhbHVlcygpLCBiLnZhbHVlcygpLCBzdGFja0EuY29uY2F0KFthXSksIHN0YWNrQi5jb25jYXQoW2JdKSk7XG4gICAgY2FzZSAnQXJndW1lbnRzJzpcbiAgICBjYXNlICdBcnJheSc6XG4gICAgY2FzZSAnT2JqZWN0JzpcbiAgICBjYXNlICdCb29sZWFuJzpcbiAgICBjYXNlICdOdW1iZXInOlxuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgY2FzZSAnRXJyb3InOlxuICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgY2FzZSAnSW50OEFycmF5JzpcbiAgICBjYXNlICdVaW50OEFycmF5JzpcbiAgICBjYXNlICdVaW50OENsYW1wZWRBcnJheSc6XG4gICAgY2FzZSAnSW50MTZBcnJheSc6XG4gICAgY2FzZSAnVWludDE2QXJyYXknOlxuICAgIGNhc2UgJ0ludDMyQXJyYXknOlxuICAgIGNhc2UgJ1VpbnQzMkFycmF5JzpcbiAgICBjYXNlICdGbG9hdDMyQXJyYXknOlxuICAgIGNhc2UgJ0Zsb2F0NjRBcnJheSc6XG4gICAgY2FzZSAnQXJyYXlCdWZmZXInOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFZhbHVlcyBvZiBvdGhlciB0eXBlcyBhcmUgb25seSBlcXVhbCBpZiBpZGVudGljYWwuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBrZXlzKGEpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzKGIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBleHRlbmRlZFN0YWNrQSA9IHN0YWNrQS5jb25jYXQoW2FdKTtcbiAgdmFyIGV4dGVuZGVkU3RhY2tCID0gc3RhY2tCLmNvbmNhdChbYl0pO1xuXG4gIGlkeCA9IGtleXNBLmxlbmd0aCAtIDE7XG4gIHdoaWxlIChpZHggPj0gMCkge1xuICAgIHZhciBrZXkgPSBrZXlzQVtpZHhdO1xuICAgIGlmICghKF9oYXMoa2V5LCBiKSAmJiBfZXF1YWxzKGJba2V5XSwgYVtrZXldLCBleHRlbmRlZFN0YWNrQSwgZXh0ZW5kZWRTdGFja0IpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZHggLT0gMTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZmlsdGVyKGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGxpc3RbaWR4XTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0iLCJpbXBvcnQgX2ZvcmNlUmVkdWNlZCBmcm9tICcuL19mb3JjZVJlZHVjZWQnO1xuaW1wb3J0IF9pc0FycmF5TGlrZSBmcm9tICcuL19pc0FycmF5TGlrZSc7XG5pbXBvcnQgX3JlZHVjZSBmcm9tICcuL19yZWR1Y2UnO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSAnLi9feGZCYXNlJztcblxudmFyIHByZXNlcnZpbmdSZWR1Y2VkID0gZnVuY3Rpb24gKHhmKSB7XG4gIHJldHVybiB7XG4gICAgJ0BAdHJhbnNkdWNlci9pbml0JzogX3hmQmFzZS5pbml0LFxuICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgICB9LFxuICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICB2YXIgcmV0ID0geGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gICAgICByZXR1cm4gcmV0WydAQHRyYW5zZHVjZXIvcmVkdWNlZCddID8gX2ZvcmNlUmVkdWNlZChyZXQpIDogcmV0O1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBfZmxhdENhdCA9IGZ1bmN0aW9uIF94Y2F0KHhmKSB7XG4gIHZhciByeGYgPSBwcmVzZXJ2aW5nUmVkdWNlZCh4Zik7XG4gIHJldHVybiB7XG4gICAgJ0BAdHJhbnNkdWNlci9pbml0JzogX3hmQmFzZS5pbml0LFxuICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJ4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgfSxcbiAgICAnQEB0cmFuc2R1Y2VyL3N0ZXAnOiBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgcmV0dXJuICFfaXNBcnJheUxpa2UoaW5wdXQpID8gX3JlZHVjZShyeGYsIHJlc3VsdCwgW2lucHV0XSkgOiBfcmVkdWNlKHJ4ZiwgcmVzdWx0LCBpbnB1dCk7XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgX2ZsYXRDYXQ7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2ZvcmNlUmVkdWNlZCh4KSB7XG4gIHJldHVybiB7XG4gICAgJ0BAdHJhbnNkdWNlci92YWx1ZSc6IHgsXG4gICAgJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJzogdHJ1ZVxuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9mdW5jdGlvbk5hbWUoZikge1xuICAvLyBTdHJpbmcoeCA9PiB4KSBldmFsdWF0ZXMgdG8gXCJ4ID0+IHhcIiwgc28gdGhlIHBhdHRlcm4gbWF5IG5vdCBtYXRjaC5cbiAgdmFyIG1hdGNoID0gU3RyaW5nKGYpLm1hdGNoKC9eZnVuY3Rpb24gKFxcdyopLyk7XG4gIHJldHVybiBtYXRjaCA9PSBudWxsID8gJycgOiBtYXRjaFsxXTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaGFzKHByb3AsIG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2lkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59IiwiaW1wb3J0IGVxdWFscyBmcm9tICcuLi9lcXVhbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaW5kZXhPZihsaXN0LCBhLCBpZHgpIHtcbiAgdmFyIGluZiwgaXRlbTtcbiAgLy8gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgZG9lc24ndCBleGlzdCBiZWxvdyBJRTlcbiAgaWYgKHR5cGVvZiBsaXN0LmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBhKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgIC8vIG1hbnVhbGx5IGNyYXdsIHRoZSBsaXN0IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gKzAgYW5kIC0wXG4gICAgICAgICAgaW5mID0gMSAvIGE7XG4gICAgICAgICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpZHhdO1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IDAgJiYgMSAvIGl0ZW0gPT09IGluZikge1xuICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChhICE9PSBhKSB7XG4gICAgICAgICAgLy8gTmFOXG4gICAgICAgICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpZHhdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyAmJiBpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vbi16ZXJvIG51bWJlcnMgY2FuIHV0aWxpc2UgU2V0XG4gICAgICAgIHJldHVybiBsaXN0LmluZGV4T2YoYSwgaWR4KTtcblxuICAgICAgLy8gYWxsIHRoZXNlIHR5cGVzIGNhbiB1dGlsaXNlIFNldFxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIGxpc3QuaW5kZXhPZihhLCBpZHgpO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoYSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIG51bGwgY2FuIHV0aWxpc2UgU2V0XG4gICAgICAgICAgcmV0dXJuIGxpc3QuaW5kZXhPZihhLCBpZHgpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGFueXRoaW5nIGVsc2Ugbm90IGNvdmVyZWQgYWJvdmUsIGRlZmVyIHRvIFIuZXF1YWxzXG4gIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgIGlmIChlcXVhbHMobGlzdFtpZHhdLCBhKSkge1xuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsImltcG9ydCBfaGFzIGZyb20gJy4vX2hhcyc7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgX2lzQXJndW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcmd1bWVudHMpID09PSAnW29iamVjdCBBcmd1bWVudHNdJyA/IGZ1bmN0aW9uIF9pc0FyZ3VtZW50cyh4KSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuICB9IDogZnVuY3Rpb24gX2lzQXJndW1lbnRzKHgpIHtcbiAgICByZXR1cm4gX2hhcygnY2FsbGVlJywgeCk7XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBfaXNBcmd1bWVudHM7IiwiLyoqXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaXMgYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgdmFsYCBpcyBhbiBhcnJheSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgX2lzQXJyYXkoW10pOyAvLz0+IHRydWVcbiAqICAgICAgX2lzQXJyYXkobnVsbCk7IC8vPT4gZmFsc2VcbiAqICAgICAgX2lzQXJyYXkoe30pOyAvLz0+IGZhbHNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gX2lzQXJyYXkodmFsKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoID49IDAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59OyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vX2N1cnJ5MSc7XG5pbXBvcnQgX2lzQXJyYXkgZnJvbSAnLi9faXNBcnJheSc7XG5pbXBvcnQgX2lzU3RyaW5nIGZyb20gJy4vX2lzU3RyaW5nJztcblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaXMgc2ltaWxhciB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IFR5cGVcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICogLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSB4IFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgeGAgaGFzIGEgbnVtZXJpYyBsZW5ndGggcHJvcGVydHkgYW5kIGV4dHJlbWUgaW5kaWNlcyBkZWZpbmVkOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBfaXNBcnJheUxpa2UoW10pOyAvLz0+IHRydWVcbiAqICAgICAgX2lzQXJyYXlMaWtlKHRydWUpOyAvLz0+IGZhbHNlXG4gKiAgICAgIF9pc0FycmF5TGlrZSh7fSk7IC8vPT4gZmFsc2VcbiAqICAgICAgX2lzQXJyYXlMaWtlKHtsZW5ndGg6IDEwfSk7IC8vPT4gZmFsc2VcbiAqICAgICAgX2lzQXJyYXlMaWtlKHswOiAnemVybycsIDk6ICduaW5lJywgbGVuZ3RoOiAxMH0pOyAvLz0+IHRydWVcbiAqL1xudmFyIF9pc0FycmF5TGlrZSA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHgpIHtcbiAgaWYgKF9pc0FycmF5KHgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCF4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKF9pc1N0cmluZyh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoeC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIHJldHVybiAhIXgubGVuZ3RoO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4geC5oYXNPd25Qcm9wZXJ0eSgwKSAmJiB4Lmhhc093blByb3BlcnR5KHgubGVuZ3RoIC0gMSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSk7XG5leHBvcnQgZGVmYXVsdCBfaXNBcnJheUxpa2U7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2lzRnVuY3Rpb24oeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufSIsIi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBwYXNzZWQgYXJndW1lbnQgaXMgYW4gaW50ZWdlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBuXG4gKiBAY2F0ZWdvcnkgVHlwZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbiBfaXNJbnRlZ2VyKG4pIHtcbiAgcmV0dXJuIG4gPDwgMCA9PT0gbjtcbn07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2lzTnVtYmVyKHgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2lzT2JqZWN0KHgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2lzUGxhY2Vob2xkZXIoYSkge1xuICAgICAgIHJldHVybiBhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGFbJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlciddID09PSB0cnVlO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pc1JlZ0V4cCh4KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pc1N0cmluZyh4KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pc1RyYW5zZm9ybWVyKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9ialsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9PT0gJ2Z1bmN0aW9uJztcbn0iLCJpbXBvcnQgX2lzQXJyYXlMaWtlIGZyb20gJy4vX2lzQXJyYXlMaWtlJztcblxuLyoqXG4gKiBgX21ha2VGbGF0YCBpcyBhIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBvbmUtbGV2ZWwgb3IgZnVsbHkgcmVjdXJzaXZlXG4gKiBmdW5jdGlvbiBiYXNlZCBvbiB0aGUgZmxhZyBwYXNzZWQgaW4uXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX21ha2VGbGF0KHJlY3Vyc2l2ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZmxhdHQobGlzdCkge1xuICAgIHZhciB2YWx1ZSwgamxlbiwgajtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIGlsZW4gPSBsaXN0Lmxlbmd0aDtcblxuICAgIHdoaWxlIChpZHggPCBpbGVuKSB7XG4gICAgICBpZiAoX2lzQXJyYXlMaWtlKGxpc3RbaWR4XSkpIHtcbiAgICAgICAgdmFsdWUgPSByZWN1cnNpdmUgPyBmbGF0dChsaXN0W2lkeF0pIDogbGlzdFtpZHhdO1xuICAgICAgICBqID0gMDtcbiAgICAgICAgamxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGogPCBqbGVuKSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWVbal07XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBsaXN0W2lkeF07XG4gICAgICB9XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbWFwKGZuLCBmdW5jdG9yKSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gZnVuY3Rvci5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBBcnJheShsZW4pO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgcmVzdWx0W2lkeF0gPSBmbihmdW5jdG9yW2lkeF0pO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59IiwiaW1wb3J0IF9oYXMgZnJvbSAnLi9faGFzJztcblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdEFzc2lnbih0YXJnZXQpIHtcbiAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gIH1cblxuICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG4gIHZhciBpZHggPSAxO1xuICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKGlkeCA8IGxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaWR4XTtcbiAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChfaGFzKG5leHRLZXksIHNvdXJjZSkpIHtcbiAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2YoeCkge1xuICByZXR1cm4gW3hdO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9waXBlKGYsIGcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZy5jYWxsKHRoaXMsIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3BpcGVQKGYsIGcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3R4ID0gdGhpcztcbiAgICByZXR1cm4gZi5hcHBseShjdHgsIGFyZ3VtZW50cykudGhlbihmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGcuY2FsbChjdHgsIHgpO1xuICAgIH0pO1xuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9xdW90ZShzKSB7XG4gIHZhciBlc2NhcGVkID0gcy5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL1tcXGJdL2csICdcXFxcYicpIC8vIFxcYiBtYXRjaGVzIHdvcmQgYm91bmRhcnk7IFtcXGJdIG1hdGNoZXMgYmFja3NwYWNlXG4gIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKS5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykucmVwbGFjZSgvXFx2L2csICdcXFxcdicpLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKTtcblxuICByZXR1cm4gJ1wiJyArIGVzY2FwZWQucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICsgJ1wiJztcbn0iLCJpbXBvcnQgX2lzQXJyYXlMaWtlIGZyb20gJy4vX2lzQXJyYXlMaWtlJztcbmltcG9ydCBfeHdyYXAgZnJvbSAnLi9feHdyYXAnO1xuaW1wb3J0IGJpbmQgZnJvbSAnLi4vYmluZCc7XG5cbmZ1bmN0aW9uIF9hcnJheVJlZHVjZSh4ZiwgYWNjLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBhY2MgPSB4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShhY2MsIGxpc3RbaWR4XSk7XG4gICAgaWYgKGFjYyAmJiBhY2NbJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJ10pIHtcbiAgICAgIGFjYyA9IGFjY1snQEB0cmFuc2R1Y2VyL3ZhbHVlJ107XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10oYWNjKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlUmVkdWNlKHhmLCBhY2MsIGl0ZXIpIHtcbiAgdmFyIHN0ZXAgPSBpdGVyLm5leHQoKTtcbiAgd2hpbGUgKCFzdGVwLmRvbmUpIHtcbiAgICBhY2MgPSB4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShhY2MsIHN0ZXAudmFsdWUpO1xuICAgIGlmIChhY2MgJiYgYWNjWydAQHRyYW5zZHVjZXIvcmVkdWNlZCddKSB7XG4gICAgICBhY2MgPSBhY2NbJ0BAdHJhbnNkdWNlci92YWx1ZSddO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN0ZXAgPSBpdGVyLm5leHQoKTtcbiAgfVxuICByZXR1cm4geGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShhY2MpO1xufVxuXG5mdW5jdGlvbiBfbWV0aG9kUmVkdWNlKHhmLCBhY2MsIG9iaiwgbWV0aG9kTmFtZSkge1xuICByZXR1cm4geGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShvYmpbbWV0aG9kTmFtZV0oYmluZCh4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSwgeGYpLCBhY2MpKTtcbn1cblxudmFyIHN5bUl0ZXJhdG9yID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2wuaXRlcmF0b3IgOiAnQEBpdGVyYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9yZWR1Y2UoZm4sIGFjYywgbGlzdCkge1xuICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBfeHdyYXAoZm4pO1xuICB9XG4gIGlmIChfaXNBcnJheUxpa2UobGlzdCkpIHtcbiAgICByZXR1cm4gX2FycmF5UmVkdWNlKGZuLCBhY2MsIGxpc3QpO1xuICB9XG4gIGlmICh0eXBlb2YgbGlzdFsnZmFudGFzeS1sYW5kL3JlZHVjZSddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIF9tZXRob2RSZWR1Y2UoZm4sIGFjYywgbGlzdCwgJ2ZhbnRhc3ktbGFuZC9yZWR1Y2UnKTtcbiAgfVxuICBpZiAobGlzdFtzeW1JdGVyYXRvcl0gIT0gbnVsbCkge1xuICAgIHJldHVybiBfaXRlcmFibGVSZWR1Y2UoZm4sIGFjYywgbGlzdFtzeW1JdGVyYXRvcl0oKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBsaXN0Lm5leHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gX2l0ZXJhYmxlUmVkdWNlKGZuLCBhY2MsIGxpc3QpO1xuICB9XG4gIGlmICh0eXBlb2YgbGlzdC5yZWR1Y2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gX21ldGhvZFJlZHVjZShmbiwgYWNjLCBsaXN0LCAncmVkdWNlJyk7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2U6IGxpc3QgbXVzdCBiZSBhcnJheSBvciBpdGVyYWJsZScpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9yZWR1Y2VkKHgpIHtcbiAgcmV0dXJuIHggJiYgeFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSA/IHggOiB7XG4gICAgJ0BAdHJhbnNkdWNlci92YWx1ZSc6IHgsXG4gICAgJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJzogdHJ1ZVxuICB9O1xufSIsImltcG9ydCBfYXNzaWduIGZyb20gJy4vX2Fzc2lnbic7XG5pbXBvcnQgX2lkZW50aXR5IGZyb20gJy4vX2lkZW50aXR5JztcbmltcG9ydCBfaXNBcnJheUxpa2UgZnJvbSAnLi9faXNBcnJheUxpa2UnO1xuaW1wb3J0IF9pc1RyYW5zZm9ybWVyIGZyb20gJy4vX2lzVHJhbnNmb3JtZXInO1xuaW1wb3J0IG9iak9mIGZyb20gJy4uL29iak9mJztcblxudmFyIF9zdGVwQ2F0QXJyYXkgPSB7XG4gICdAQHRyYW5zZHVjZXIvaW5pdCc6IEFycmF5LFxuICAnQEB0cmFuc2R1Y2VyL3N0ZXAnOiBmdW5jdGlvbiAoeHMsIHgpIHtcbiAgICB4cy5wdXNoKHgpO1xuICAgIHJldHVybiB4cztcbiAgfSxcbiAgJ0BAdHJhbnNkdWNlci9yZXN1bHQnOiBfaWRlbnRpdHlcbn07XG52YXIgX3N0ZXBDYXRTdHJpbmcgPSB7XG4gICdAQHRyYW5zZHVjZXIvaW5pdCc6IFN0cmluZyxcbiAgJ0BAdHJhbnNkdWNlci9zdGVwJzogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSArIGI7XG4gIH0sXG4gICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogX2lkZW50aXR5XG59O1xudmFyIF9zdGVwQ2F0T2JqZWN0ID0ge1xuICAnQEB0cmFuc2R1Y2VyL2luaXQnOiBPYmplY3QsXG4gICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgcmV0dXJuIF9hc3NpZ24ocmVzdWx0LCBfaXNBcnJheUxpa2UoaW5wdXQpID8gb2JqT2YoaW5wdXRbMF0sIGlucHV0WzFdKSA6IGlucHV0KTtcbiAgfSxcbiAgJ0BAdHJhbnNkdWNlci9yZXN1bHQnOiBfaWRlbnRpdHlcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9zdGVwQ2F0KG9iaikge1xuICBpZiAoX2lzVHJhbnNmb3JtZXIob2JqKSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgaWYgKF9pc0FycmF5TGlrZShvYmopKSB7XG4gICAgcmV0dXJuIF9zdGVwQ2F0QXJyYXk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIF9zdGVwQ2F0U3RyaW5nO1xuICB9XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBfc3RlcENhdE9iamVjdDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgdHJhbnNmb3JtZXIgZm9yICcgKyBvYmopO1xufSIsIi8qKlxuICogUG9seWZpbGwgZnJvbSA8aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS90b0lTT1N0cmluZz4uXG4gKi9cbnZhciBwYWQgPSBmdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gKG4gPCAxMCA/ICcwJyA6ICcnKSArIG47XG59O1xuXG52YXIgX3RvSVNPU3RyaW5nID0gdHlwZW9mIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nID09PSAnZnVuY3Rpb24nID8gZnVuY3Rpb24gX3RvSVNPU3RyaW5nKGQpIHtcbiAgcmV0dXJuIGQudG9JU09TdHJpbmcoKTtcbn0gOiBmdW5jdGlvbiBfdG9JU09TdHJpbmcoZCkge1xuICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpICsgJy0nICsgcGFkKGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICsgcGFkKGQuZ2V0VVRDRGF0ZSgpKSArICdUJyArIHBhZChkLmdldFVUQ0hvdXJzKCkpICsgJzonICsgcGFkKGQuZ2V0VVRDTWludXRlcygpKSArICc6JyArIHBhZChkLmdldFVUQ1NlY29uZHMoKSkgKyAnLicgKyAoZC5nZXRVVENNaWxsaXNlY29uZHMoKSAvIDEwMDApLnRvRml4ZWQoMykuc2xpY2UoMiwgNSkgKyAnWic7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBfdG9JU09TdHJpbmc7IiwiaW1wb3J0IF9jb250YWlucyBmcm9tICcuL19jb250YWlucyc7XG5pbXBvcnQgX21hcCBmcm9tICcuL19tYXAnO1xuaW1wb3J0IF9xdW90ZSBmcm9tICcuL19xdW90ZSc7XG5pbXBvcnQgX3RvSVNPU3RyaW5nIGZyb20gJy4vX3RvSVNPU3RyaW5nJztcbmltcG9ydCBrZXlzIGZyb20gJy4uL2tleXMnO1xuaW1wb3J0IHJlamVjdCBmcm9tICcuLi9yZWplY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdG9TdHJpbmcoeCwgc2Vlbikge1xuICB2YXIgcmVjdXIgPSBmdW5jdGlvbiByZWN1cih5KSB7XG4gICAgdmFyIHhzID0gc2Vlbi5jb25jYXQoW3hdKTtcbiAgICByZXR1cm4gX2NvbnRhaW5zKHksIHhzKSA/ICc8Q2lyY3VsYXI+JyA6IF90b1N0cmluZyh5LCB4cyk7XG4gIH07XG5cbiAgLy8gIG1hcFBhaXJzIDo6IChPYmplY3QsIFtTdHJpbmddKSAtPiBbU3RyaW5nXVxuICB2YXIgbWFwUGFpcnMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gICAgcmV0dXJuIF9tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgIHJldHVybiBfcXVvdGUoaykgKyAnOiAnICsgcmVjdXIob2JqW2tdKTtcbiAgICB9LCBrZXlzLnNsaWNlKCkuc29ydCgpKTtcbiAgfTtcblxuICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSkge1xuICAgIGNhc2UgJ1tvYmplY3QgQXJndW1lbnRzXSc6XG4gICAgICByZXR1cm4gJyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgnICsgX21hcChyZWN1ciwgeCkuam9pbignLCAnKSArICcpKSc7XG4gICAgY2FzZSAnW29iamVjdCBBcnJheV0nOlxuICAgICAgcmV0dXJuICdbJyArIF9tYXAocmVjdXIsIHgpLmNvbmNhdChtYXBQYWlycyh4LCByZWplY3QoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuICgvXlxcZCskLy50ZXN0KGspXG4gICAgICAgICk7XG4gICAgICB9LCBrZXlzKHgpKSkpLmpvaW4oJywgJykgKyAnXSc7XG4gICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnID8gJ25ldyBCb29sZWFuKCcgKyByZWN1cih4LnZhbHVlT2YoKSkgKyAnKScgOiB4LnRvU3RyaW5nKCk7XG4gICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICByZXR1cm4gJ25ldyBEYXRlKCcgKyAoaXNOYU4oeC52YWx1ZU9mKCkpID8gcmVjdXIoTmFOKSA6IF9xdW90ZShfdG9JU09TdHJpbmcoeCkpKSArICcpJztcbiAgICBjYXNlICdbb2JqZWN0IE51bGxdJzpcbiAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgPyAnbmV3IE51bWJlcignICsgcmVjdXIoeC52YWx1ZU9mKCkpICsgJyknIDogMSAvIHggPT09IC1JbmZpbml0eSA/ICctMCcgOiB4LnRvU3RyaW5nKDEwKTtcbiAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/ICduZXcgU3RyaW5nKCcgKyByZWN1cih4LnZhbHVlT2YoKSkgKyAnKScgOiBfcXVvdGUoeCk7XG4gICAgY2FzZSAnW29iamVjdCBVbmRlZmluZWRdJzpcbiAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiB4LnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciByZXByID0geC50b1N0cmluZygpO1xuICAgICAgICBpZiAocmVwciAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICByZXR1cm4gcmVwcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICd7JyArIG1hcFBhaXJzKHgsIGtleXMoeCkpLmpvaW4oJywgJykgKyAnfSc7XG4gIH1cbn0iLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL19jdXJyeTInO1xuaW1wb3J0IF9yZWR1Y2VkIGZyb20gJy4vX3JlZHVjZWQnO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSAnLi9feGZCYXNlJztcblxudmFyIFhBbGwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYQWxsKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gICAgdGhpcy5hbGwgPSB0cnVlO1xuICB9XG4gIFhBbGwucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYQWxsLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGlmICh0aGlzLmFsbCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gIH07XG4gIFhBbGwucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuZihpbnB1dCkpIHtcbiAgICAgIHRoaXMuYWxsID0gZmFsc2U7XG4gICAgICByZXN1bHQgPSBfcmVkdWNlZCh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgZmFsc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gWEFsbDtcbn0oKTtcblxudmFyIF94YWxsID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gX3hhbGwoZiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYQWxsKGYsIHhmKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgX3hhbGw7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9fY3VycnkyJztcbmltcG9ydCBfcmVkdWNlZCBmcm9tICcuL19yZWR1Y2VkJztcbmltcG9ydCBfeGZCYXNlIGZyb20gJy4vX3hmQmFzZSc7XG5cbnZhciBYQW55ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWEFueShmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMuYW55ID0gZmFsc2U7XG4gIH1cbiAgWEFueS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhBbnkucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgaWYgKCF0aGlzLmFueSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuICBYQW55LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgIHRoaXMuYW55ID0gdHJ1ZTtcbiAgICAgIHJlc3VsdCA9IF9yZWR1Y2VkKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFhBbnk7XG59KCk7XG5cbnZhciBfeGFueSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF94YW55KGYsIHhmKSB7XG4gIHJldHVybiBuZXcgWEFueShmLCB4Zik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IF94YW55OyIsImltcG9ydCBfY29uY2F0IGZyb20gJy4vX2NvbmNhdCc7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL19jdXJyeTInO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSAnLi9feGZCYXNlJztcblxudmFyIFhBcGVydHVyZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhBcGVydHVyZShuLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5mdWxsID0gZmFsc2U7XG4gICAgdGhpcy5hY2MgPSBuZXcgQXJyYXkobik7XG4gIH1cbiAgWEFwZXJ0dXJlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWEFwZXJ0dXJlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHRoaXMuYWNjID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gIH07XG4gIFhBcGVydHVyZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHRoaXMuc3RvcmUoaW5wdXQpO1xuICAgIHJldHVybiB0aGlzLmZ1bGwgPyB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5nZXRDb3B5KCkpIDogcmVzdWx0O1xuICB9O1xuICBYQXBlcnR1cmUucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdGhpcy5hY2NbdGhpcy5wb3NdID0gaW5wdXQ7XG4gICAgdGhpcy5wb3MgKz0gMTtcbiAgICBpZiAodGhpcy5wb3MgPT09IHRoaXMuYWNjLmxlbmd0aCkge1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgdGhpcy5mdWxsID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIFhBcGVydHVyZS5wcm90b3R5cGUuZ2V0Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2NvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmFjYywgdGhpcy5wb3MpLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmFjYywgMCwgdGhpcy5wb3MpKTtcbiAgfTtcblxuICByZXR1cm4gWEFwZXJ0dXJlO1xufSgpO1xuXG52YXIgX3hhcGVydHVyZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF94YXBlcnR1cmUobiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYQXBlcnR1cmUobiwgeGYpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBfeGFwZXJ0dXJlOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vX2N1cnJ5Mic7XG5pbXBvcnQgX2ZsYXRDYXQgZnJvbSAnLi9fZmxhdENhdCc7XG5pbXBvcnQgbWFwIGZyb20gJy4uL21hcCc7XG5cbnZhciBfeGNoYWluID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gX3hjaGFpbihmLCB4Zikge1xuICByZXR1cm4gbWFwKGYsIF9mbGF0Q2F0KHhmKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IF94Y2hhaW47IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9fY3VycnkyJztcbmltcG9ydCBfeGZCYXNlIGZyb20gJy4vX3hmQmFzZSc7XG5cbnZhciBYRHJvcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhEcm9wKG4sIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMubiA9IG47XG4gIH1cbiAgWERyb3AucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRHJvcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICBYRHJvcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIGlmICh0aGlzLm4gPiAwKSB7XG4gICAgICB0aGlzLm4gLT0gMTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpO1xuICB9O1xuXG4gIHJldHVybiBYRHJvcDtcbn0oKTtcblxudmFyIF94ZHJvcCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF94ZHJvcChuLCB4Zikge1xuICByZXR1cm4gbmV3IFhEcm9wKG4sIHhmKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgX3hkcm9wOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vX2N1cnJ5Mic7XG5pbXBvcnQgX3hmQmFzZSBmcm9tICcuL194ZkJhc2UnO1xuXG52YXIgWERyb3BMYXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWERyb3BMYXN0KG4sIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmZ1bGwgPSBmYWxzZTtcbiAgICB0aGlzLmFjYyA9IG5ldyBBcnJheShuKTtcbiAgfVxuICBYRHJvcExhc3QucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRHJvcExhc3QucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdGhpcy5hY2MgPSBudWxsO1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfTtcbiAgWERyb3BMYXN0LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgaWYgKHRoaXMuZnVsbCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMuYWNjW3RoaXMucG9zXSk7XG4gICAgfVxuICAgIHRoaXMuc3RvcmUoaW5wdXQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIFhEcm9wTGFzdC5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB0aGlzLmFjY1t0aGlzLnBvc10gPSBpbnB1dDtcbiAgICB0aGlzLnBvcyArPSAxO1xuICAgIGlmICh0aGlzLnBvcyA9PT0gdGhpcy5hY2MubGVuZ3RoKSB7XG4gICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICB0aGlzLmZ1bGwgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gWERyb3BMYXN0O1xufSgpO1xuXG52YXIgX3hkcm9wTGFzdCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF94ZHJvcExhc3QobiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYRHJvcExhc3QobiwgeGYpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBfeGRyb3BMYXN0OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vX2N1cnJ5Mic7XG5pbXBvcnQgX3JlZHVjZSBmcm9tICcuL19yZWR1Y2UnO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSAnLi9feGZCYXNlJztcblxudmFyIFhEcm9wTGFzdFdoaWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWERyb3BMYXN0V2hpbGUoZm4sIHhmKSB7XG4gICAgdGhpcy5mID0gZm47XG4gICAgdGhpcy5yZXRhaW5lZCA9IFtdO1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgfVxuICBYRHJvcExhc3RXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhEcm9wTGFzdFdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHRoaXMucmV0YWluZWQgPSBudWxsO1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfTtcbiAgWERyb3BMYXN0V2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICByZXR1cm4gdGhpcy5mKGlucHV0KSA/IHRoaXMucmV0YWluKHJlc3VsdCwgaW5wdXQpIDogdGhpcy5mbHVzaChyZXN1bHQsIGlucHV0KTtcbiAgfTtcbiAgWERyb3BMYXN0V2hpbGUucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICByZXN1bHQgPSBfcmVkdWNlKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10sIHJlc3VsdCwgdGhpcy5yZXRhaW5lZCk7XG4gICAgdGhpcy5yZXRhaW5lZCA9IFtdO1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpO1xuICB9O1xuICBYRHJvcExhc3RXaGlsZS5wcm90b3R5cGUucmV0YWluID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB0aGlzLnJldGFpbmVkLnB1c2goaW5wdXQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFhEcm9wTGFzdFdoaWxlO1xufSgpO1xuXG52YXIgX3hkcm9wTGFzdFdoaWxlID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gX3hkcm9wTGFzdFdoaWxlKGZuLCB4Zikge1xuICByZXR1cm4gbmV3IFhEcm9wTGFzdFdoaWxlKGZuLCB4Zik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IF94ZHJvcExhc3RXaGlsZTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL19jdXJyeTInO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSAnLi9feGZCYXNlJztcblxudmFyIFhEcm9wUmVwZWF0c1dpdGggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYRHJvcFJlcGVhdHNXaXRoKHByZWQsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMucHJlZCA9IHByZWQ7XG4gICAgdGhpcy5sYXN0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zZWVuRmlyc3RWYWx1ZSA9IGZhbHNlO1xuICB9XG5cbiAgWERyb3BSZXBlYXRzV2l0aC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhEcm9wUmVwZWF0c1dpdGgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWERyb3BSZXBlYXRzV2l0aC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHZhciBzYW1lQXNMYXN0ID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLnNlZW5GaXJzdFZhbHVlKSB7XG4gICAgICB0aGlzLnNlZW5GaXJzdFZhbHVlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJlZCh0aGlzLmxhc3RWYWx1ZSwgaW5wdXQpKSB7XG4gICAgICBzYW1lQXNMYXN0ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0VmFsdWUgPSBpbnB1dDtcbiAgICByZXR1cm4gc2FtZUFzTGFzdCA/IHJlc3VsdCA6IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gIH07XG5cbiAgcmV0dXJuIFhEcm9wUmVwZWF0c1dpdGg7XG59KCk7XG5cbnZhciBfeGRyb3BSZXBlYXRzV2l0aCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF94ZHJvcFJlcGVhdHNXaXRoKHByZWQsIHhmKSB7XG4gIHJldHVybiBuZXcgWERyb3BSZXBlYXRzV2l0aChwcmVkLCB4Zik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IF94ZHJvcFJlcGVhdHNXaXRoOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vX2N1cnJ5Mic7XG5pbXBvcnQgX3hmQmFzZSBmcm9tICcuL194ZkJhc2UnO1xuXG52YXIgWERyb3BXaGlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhEcm9wV2hpbGUoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgfVxuICBYRHJvcFdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWERyb3BXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICBYRHJvcFdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgaWYgKHRoaXMuZikge1xuICAgICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZiA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpO1xuICB9O1xuXG4gIHJldHVybiBYRHJvcFdoaWxlO1xufSgpO1xuXG52YXIgX3hkcm9wV2hpbGUgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBfeGRyb3BXaGlsZShmLCB4Zikge1xuICByZXR1cm4gbmV3IFhEcm9wV2hpbGUoZiwgeGYpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBfeGRyb3BXaGlsZTsiLCJleHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL2luaXQnXSgpO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gIH1cbn07IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9fY3VycnkyJztcbmltcG9ydCBfeGZCYXNlIGZyb20gJy4vX3hmQmFzZSc7XG5cbnZhciBYRmlsdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWEZpbHRlcihmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICB9XG4gIFhGaWx0ZXIucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG4gIFhGaWx0ZXIucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICByZXR1cm4gdGhpcy5mKGlucHV0KSA/IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCkgOiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFhGaWx0ZXI7XG59KCk7XG5cbnZhciBfeGZpbHRlciA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF94ZmlsdGVyKGYsIHhmKSB7XG4gIHJldHVybiBuZXcgWEZpbHRlcihmLCB4Zik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IF94ZmlsdGVyOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vX2N1cnJ5Mic7XG5pbXBvcnQgX3JlZHVjZWQgZnJvbSAnLi9fcmVkdWNlZCc7XG5pbXBvcnQgX3hmQmFzZSBmcm9tICcuL194ZkJhc2UnO1xuXG52YXIgWEZpbmQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYRmluZChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMuZm91bmQgPSBmYWxzZTtcbiAgfVxuICBYRmluZC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhGaW5kLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGlmICghdGhpcy5mb3VuZCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHZvaWQgMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfTtcbiAgWEZpbmQucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICBpZiAodGhpcy5mKGlucHV0KSkge1xuICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICByZXN1bHQgPSBfcmVkdWNlZCh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gWEZpbmQ7XG59KCk7XG5cbnZhciBfeGZpbmQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBfeGZpbmQoZiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYRmluZChmLCB4Zik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IF94ZmluZDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL19jdXJyeTInO1xuaW1wb3J0IF9yZWR1Y2VkIGZyb20gJy4vX3JlZHVjZWQnO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSAnLi9feGZCYXNlJztcblxudmFyIFhGaW5kSW5kZXggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYRmluZEluZGV4KGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gICAgdGhpcy5pZHggPSAtMTtcbiAgICB0aGlzLmZvdW5kID0gZmFsc2U7XG4gIH1cbiAgWEZpbmRJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhGaW5kSW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgaWYgKCF0aGlzLmZvdW5kKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gIH07XG4gIFhGaW5kSW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB0aGlzLmlkeCArPSAxO1xuICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgIHJlc3VsdCA9IF9yZWR1Y2VkKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmlkeCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBYRmluZEluZGV4O1xufSgpO1xuXG52YXIgX3hmaW5kSW5kZXggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBfeGZpbmRJbmRleChmLCB4Zikge1xuICByZXR1cm4gbmV3IFhGaW5kSW5kZXgoZiwgeGYpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBfeGZpbmRJbmRleDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL19jdXJyeTInO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSAnLi9feGZCYXNlJztcblxudmFyIFhGaW5kTGFzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhGaW5kTGFzdChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICB9XG4gIFhGaW5kTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhGaW5kTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmxhc3QpKTtcbiAgfTtcbiAgWEZpbmRMYXN0LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgIHRoaXMubGFzdCA9IGlucHV0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBYRmluZExhc3Q7XG59KCk7XG5cbnZhciBfeGZpbmRMYXN0ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gX3hmaW5kTGFzdChmLCB4Zikge1xuICByZXR1cm4gbmV3IFhGaW5kTGFzdChmLCB4Zik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IF94ZmluZExhc3Q7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9fY3VycnkyJztcbmltcG9ydCBfeGZCYXNlIGZyb20gJy4vX3hmQmFzZSc7XG5cbnZhciBYRmluZExhc3RJbmRleCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhGaW5kTGFzdEluZGV4KGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gICAgdGhpcy5pZHggPSAtMTtcbiAgICB0aGlzLmxhc3RJZHggPSAtMTtcbiAgfVxuICBYRmluZExhc3RJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhGaW5kTGFzdEluZGV4LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10odGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMubGFzdElkeCkpO1xuICB9O1xuICBYRmluZExhc3RJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHRoaXMuaWR4ICs9IDE7XG4gICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgIHRoaXMubGFzdElkeCA9IHRoaXMuaWR4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBYRmluZExhc3RJbmRleDtcbn0oKTtcblxudmFyIF94ZmluZExhc3RJbmRleCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF94ZmluZExhc3RJbmRleChmLCB4Zikge1xuICByZXR1cm4gbmV3IFhGaW5kTGFzdEluZGV4KGYsIHhmKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgX3hmaW5kTGFzdEluZGV4OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vX2N1cnJ5Mic7XG5pbXBvcnQgX3hmQmFzZSBmcm9tICcuL194ZkJhc2UnO1xuXG52YXIgWE1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhNYXAoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgfVxuICBYTWFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWE1hcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICBYTWFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmYoaW5wdXQpKTtcbiAgfTtcblxuICByZXR1cm4gWE1hcDtcbn0oKTtcblxudmFyIF94bWFwID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gX3htYXAoZiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYTWFwKGYsIHhmKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgX3htYXA7IiwiaW1wb3J0IF9jdXJyeU4gZnJvbSAnLi9fY3VycnlOJztcbmltcG9ydCBfaGFzIGZyb20gJy4vX2hhcyc7XG5pbXBvcnQgX3hmQmFzZSBmcm9tICcuL194ZkJhc2UnO1xuXG52YXIgWFJlZHVjZUJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWFJlZHVjZUJ5KHZhbHVlRm4sIHZhbHVlQWNjLCBrZXlGbiwgeGYpIHtcbiAgICB0aGlzLnZhbHVlRm4gPSB2YWx1ZUZuO1xuICAgIHRoaXMudmFsdWVBY2MgPSB2YWx1ZUFjYztcbiAgICB0aGlzLmtleUZuID0ga2V5Rm47XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuaW5wdXRzID0ge307XG4gIH1cbiAgWFJlZHVjZUJ5LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWFJlZHVjZUJ5LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHZhciBrZXk7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5pbnB1dHMpIHtcbiAgICAgIGlmIChfaGFzKGtleSwgdGhpcy5pbnB1dHMpKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmlucHV0c1trZXldKTtcbiAgICAgICAgaWYgKHJlc3VsdFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFsnQEB0cmFuc2R1Y2VyL3ZhbHVlJ107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pbnB1dHMgPSBudWxsO1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfTtcbiAgWFJlZHVjZUJ5LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgdmFyIGtleSA9IHRoaXMua2V5Rm4oaW5wdXQpO1xuICAgIHRoaXMuaW5wdXRzW2tleV0gPSB0aGlzLmlucHV0c1trZXldIHx8IFtrZXksIHRoaXMudmFsdWVBY2NdO1xuICAgIHRoaXMuaW5wdXRzW2tleV1bMV0gPSB0aGlzLnZhbHVlRm4odGhpcy5pbnB1dHNba2V5XVsxXSwgaW5wdXQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFhSZWR1Y2VCeTtcbn0oKTtcblxudmFyIF94cmVkdWNlQnkgPSAvKiNfX1BVUkVfXyovX2N1cnJ5Tig0LCBbXSwgZnVuY3Rpb24gX3hyZWR1Y2VCeSh2YWx1ZUZuLCB2YWx1ZUFjYywga2V5Rm4sIHhmKSB7XG4gIHJldHVybiBuZXcgWFJlZHVjZUJ5KHZhbHVlRm4sIHZhbHVlQWNjLCBrZXlGbiwgeGYpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBfeHJlZHVjZUJ5OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vX2N1cnJ5Mic7XG5pbXBvcnQgX3JlZHVjZWQgZnJvbSAnLi9fcmVkdWNlZCc7XG5pbXBvcnQgX3hmQmFzZSBmcm9tICcuL194ZkJhc2UnO1xuXG52YXIgWFRha2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYVGFrZShuLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLm4gPSBuO1xuICAgIHRoaXMuaSA9IDA7XG4gIH1cbiAgWFRha2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYVGFrZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICBYVGFrZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHRoaXMuaSArPSAxO1xuICAgIHZhciByZXQgPSB0aGlzLm4gPT09IDAgPyByZXN1bHQgOiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpO1xuICAgIHJldHVybiB0aGlzLm4gPj0gMCAmJiB0aGlzLmkgPj0gdGhpcy5uID8gX3JlZHVjZWQocmV0KSA6IHJldDtcbiAgfTtcblxuICByZXR1cm4gWFRha2U7XG59KCk7XG5cbnZhciBfeHRha2UgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBfeHRha2UobiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYVGFrZShuLCB4Zik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IF94dGFrZTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL19jdXJyeTInO1xuaW1wb3J0IF9yZWR1Y2VkIGZyb20gJy4vX3JlZHVjZWQnO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSAnLi9feGZCYXNlJztcblxudmFyIFhUYWtlV2hpbGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYVGFrZVdoaWxlKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cbiAgWFRha2VXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhUYWtlV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWFRha2VXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmYoaW5wdXQpID8gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KSA6IF9yZWR1Y2VkKHJlc3VsdCk7XG4gIH07XG5cbiAgcmV0dXJuIFhUYWtlV2hpbGU7XG59KCk7XG5cbnZhciBfeHRha2VXaGlsZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF94dGFrZVdoaWxlKGYsIHhmKSB7XG4gIHJldHVybiBuZXcgWFRha2VXaGlsZShmLCB4Zik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IF94dGFrZVdoaWxlOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vX2N1cnJ5Mic7XG5pbXBvcnQgX3hmQmFzZSBmcm9tICcuL194ZkJhc2UnO1xuXG52YXIgWFRhcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhUYXAoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgfVxuICBYVGFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWFRhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICBYVGFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgdGhpcy5mKGlucHV0KTtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gWFRhcDtcbn0oKTtcblxudmFyIF94dGFwID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gX3h0YXAoZiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYVGFwKGYsIHhmKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgX3h0YXA7IiwidmFyIFhXcmFwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWFdyYXAoZm4pIHtcbiAgICB0aGlzLmYgPSBmbjtcbiAgfVxuICBYV3JhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbml0IG5vdCBpbXBsZW1lbnRlZCBvbiBYV3JhcCcpO1xuICB9O1xuICBYV3JhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChhY2MpIHtcbiAgICByZXR1cm4gYWNjO1xuICB9O1xuICBYV3JhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAoYWNjLCB4KSB7XG4gICAgcmV0dXJuIHRoaXMuZihhY2MsIHgpO1xuICB9O1xuXG4gIHJldHVybiBYV3JhcDtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3h3cmFwKGZuKSB7XG4gIHJldHVybiBuZXcgWFdyYXAoZm4pO1xufSIsImltcG9ydCBfY29udGFpbnMgZnJvbSAnLi9pbnRlcm5hbC9fY29udGFpbnMnO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfZmlsdGVyIGZyb20gJy4vaW50ZXJuYWwvX2ZpbHRlcic7XG5pbXBvcnQgZmxpcCBmcm9tICcuL2ZsaXAnO1xuaW1wb3J0IHVuaXEgZnJvbSAnLi91bmlxJztcblxuLyoqXG4gKiBDb21iaW5lcyB0d28gbGlzdHMgaW50byBhIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBjb21wb3NlZCBvZiB0aG9zZVxuICogZWxlbWVudHMgY29tbW9uIHRvIGJvdGggbGlzdHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgWypdIC0+IFsqXSAtPiBbKl1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIGVsZW1lbnRzIGZvdW5kIGluIGJvdGggYGxpc3QxYCBhbmQgYGxpc3QyYC5cbiAqIEBzZWUgUi5pbm5lckpvaW5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmludGVyc2VjdGlvbihbMSwyLDMsNF0sIFs3LDYsNSw0LDNdKTsgLy89PiBbNCwgM11cbiAqL1xudmFyIGludGVyc2VjdGlvbiA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGludGVyc2VjdGlvbihsaXN0MSwgbGlzdDIpIHtcbiAgdmFyIGxvb2t1cExpc3QsIGZpbHRlcmVkTGlzdDtcbiAgaWYgKGxpc3QxLmxlbmd0aCA+IGxpc3QyLmxlbmd0aCkge1xuICAgIGxvb2t1cExpc3QgPSBsaXN0MTtcbiAgICBmaWx0ZXJlZExpc3QgPSBsaXN0MjtcbiAgfSBlbHNlIHtcbiAgICBsb29rdXBMaXN0ID0gbGlzdDI7XG4gICAgZmlsdGVyZWRMaXN0ID0gbGlzdDE7XG4gIH1cbiAgcmV0dXJuIHVuaXEoX2ZpbHRlcihmbGlwKF9jb250YWlucykobG9va3VwTGlzdCksIGZpbHRlcmVkTGlzdCkpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBpbnRlcnNlY3Rpb247IiwiaW1wb3J0IF9jaGVja0Zvck1ldGhvZCBmcm9tICcuL2ludGVybmFsL19jaGVja0Zvck1ldGhvZCc7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbGlzdCB3aXRoIHRoZSBzZXBhcmF0b3IgaW50ZXJwb3NlZCBiZXR3ZWVuIGVsZW1lbnRzLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBpbnRlcnNwZXJzZWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0geyp9IHNlcGFyYXRvciBUaGUgZWxlbWVudCB0byBhZGQgdG8gdGhlIGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGJlIGludGVycG9zZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIG5ldyBsaXN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaW50ZXJzcGVyc2UoJ24nLCBbJ2JhJywgJ2EnLCAnYSddKTsgLy89PiBbJ2JhJywgJ24nLCAnYScsICduJywgJ2EnXVxuICovXG52YXIgaW50ZXJzcGVyc2UgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19jaGVja0Zvck1ldGhvZCgnaW50ZXJzcGVyc2UnLCBmdW5jdGlvbiBpbnRlcnNwZXJzZShzZXBhcmF0b3IsIGxpc3QpIHtcbiAgdmFyIG91dCA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGlkeCA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgb3V0LnB1c2gobGlzdFtpZHhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0LnB1c2gobGlzdFtpZHhdLCBzZXBhcmF0b3IpO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gb3V0O1xufSkpO1xuZXhwb3J0IGRlZmF1bHQgaW50ZXJzcGVyc2U7IiwiaW1wb3J0IF9jbG9uZSBmcm9tICcuL2ludGVybmFsL19jbG9uZSc7XG5pbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuaW1wb3J0IF9pc1RyYW5zZm9ybWVyIGZyb20gJy4vaW50ZXJuYWwvX2lzVHJhbnNmb3JtZXInO1xuaW1wb3J0IF9yZWR1Y2UgZnJvbSAnLi9pbnRlcm5hbC9fcmVkdWNlJztcbmltcG9ydCBfc3RlcENhdCBmcm9tICcuL2ludGVybmFsL19zdGVwQ2F0JztcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBpdGVtcyBvZiB0aGUgbGlzdCB3aXRoIHRoZSB0cmFuc2R1Y2VyIGFuZCBhcHBlbmRzIHRoZVxuICogdHJhbnNmb3JtZWQgaXRlbXMgdG8gdGhlIGFjY3VtdWxhdG9yIHVzaW5nIGFuIGFwcHJvcHJpYXRlIGl0ZXJhdG9yIGZ1bmN0aW9uXG4gKiBiYXNlZCBvbiB0aGUgYWNjdW11bGF0b3IgdHlwZS5cbiAqXG4gKiBUaGUgYWNjdW11bGF0b3IgY2FuIGJlIGFuIGFycmF5LCBzdHJpbmcsIG9iamVjdCBvciBhIHRyYW5zZm9ybWVyLiBJdGVyYXRlZFxuICogaXRlbXMgd2lsbCBiZSBhcHBlbmRlZCB0byBhcnJheXMgYW5kIGNvbmNhdGVuYXRlZCB0byBzdHJpbmdzLiBPYmplY3RzIHdpbGxcbiAqIGJlIG1lcmdlZCBkaXJlY3RseSBvciAyLWl0ZW0gYXJyYXlzIHdpbGwgYmUgbWVyZ2VkIGFzIGtleSwgdmFsdWUgcGFpcnMuXG4gKlxuICogVGhlIGFjY3VtdWxhdG9yIGNhbiBhbHNvIGJlIGEgdHJhbnNmb3JtZXIgb2JqZWN0IHRoYXQgcHJvdmlkZXMgYSAyLWFyaXR5XG4gKiByZWR1Y2luZyBpdGVyYXRvciBmdW5jdGlvbiwgc3RlcCwgMC1hcml0eSBpbml0aWFsIHZhbHVlIGZ1bmN0aW9uLCBpbml0LCBhbmRcbiAqIDEtYXJpdHkgcmVzdWx0IGV4dHJhY3Rpb24gZnVuY3Rpb24gcmVzdWx0LiBUaGUgc3RlcCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZVxuICogaXRlcmF0b3IgZnVuY3Rpb24gaW4gcmVkdWNlLiBUaGUgcmVzdWx0IGZ1bmN0aW9uIGlzIHVzZWQgdG8gY29udmVydCB0aGVcbiAqIGZpbmFsIGFjY3VtdWxhdG9yIGludG8gdGhlIHJldHVybiB0eXBlIGFuZCBpbiBtb3N0IGNhc2VzIGlzIFIuaWRlbnRpdHkuIFRoZVxuICogaW5pdCBmdW5jdGlvbiBpcyB1c2VkIHRvIHByb3ZpZGUgdGhlIGluaXRpYWwgYWNjdW11bGF0b3IuXG4gKlxuICogVGhlIGl0ZXJhdGlvbiBpcyBwZXJmb3JtZWQgd2l0aCBbYFIucmVkdWNlYF0oI3JlZHVjZSkgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZVxuICogdHJhbnNkdWNlci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IChiIC0+IGIpIC0+IFtjXSAtPiBhXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgaW5pdGlhbCBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHhmIFRoZSB0cmFuc2R1Y2VyIGZ1bmN0aW9uLiBSZWNlaXZlcyBhIHRyYW5zZm9ybWVyIGFuZCByZXR1cm5zIGEgdHJhbnNmb3JtZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG51bWJlcnMgPSBbMSwgMiwgMywgNF07XG4gKiAgICAgIHZhciB0cmFuc2R1Y2VyID0gUi5jb21wb3NlKFIubWFwKFIuYWRkKDEpKSwgUi50YWtlKDIpKTtcbiAqXG4gKiAgICAgIFIuaW50byhbXSwgdHJhbnNkdWNlciwgbnVtYmVycyk7IC8vPT4gWzIsIDNdXG4gKlxuICogICAgICB2YXIgaW50b0FycmF5ID0gUi5pbnRvKFtdKTtcbiAqICAgICAgaW50b0FycmF5KHRyYW5zZHVjZXIsIG51bWJlcnMpOyAvLz0+IFsyLCAzXVxuICovXG52YXIgaW50byA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIGludG8oYWNjLCB4ZiwgbGlzdCkge1xuICByZXR1cm4gX2lzVHJhbnNmb3JtZXIoYWNjKSA/IF9yZWR1Y2UoeGYoYWNjKSwgYWNjWydAQHRyYW5zZHVjZXIvaW5pdCddKCksIGxpc3QpIDogX3JlZHVjZSh4Zihfc3RlcENhdChhY2MpKSwgX2Nsb25lKGFjYywgW10sIFtdLCBmYWxzZSksIGxpc3QpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBpbnRvOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgX2hhcyBmcm9tICcuL2ludGVybmFsL19oYXMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzJztcblxuLyoqXG4gKiBTYW1lIGFzIFtgUi5pbnZlcnRPYmpgXSgjaW52ZXJ0T2JqKSwgaG93ZXZlciB0aGlzIGFjY291bnRzIGZvciBvYmplY3RzIHdpdGhcbiAqIGR1cGxpY2F0ZSB2YWx1ZXMgYnkgcHV0dGluZyB0aGUgdmFsdWVzIGludG8gYW4gYXJyYXkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtzOiB4fSAtPiB7eDogWyBzLCAuLi4gXX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCBvciBhcnJheSB0byBpbnZlcnRcbiAqIEByZXR1cm4ge09iamVjdH0gb3V0IEEgbmV3IG9iamVjdCB3aXRoIGtleXMgaW4gYW4gYXJyYXkuXG4gKiBAc2VlIFIuaW52ZXJ0T2JqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHJhY2VSZXN1bHRzQnlGaXJzdE5hbWUgPSB7XG4gKiAgICAgICAgZmlyc3Q6ICdhbGljZScsXG4gKiAgICAgICAgc2Vjb25kOiAnamFrZScsXG4gKiAgICAgICAgdGhpcmQ6ICdhbGljZScsXG4gKiAgICAgIH07XG4gKiAgICAgIFIuaW52ZXJ0KHJhY2VSZXN1bHRzQnlGaXJzdE5hbWUpO1xuICogICAgICAvLz0+IHsgJ2FsaWNlJzogWydmaXJzdCcsICd0aGlyZCddLCAnamFrZSc6WydzZWNvbmQnXSB9XG4gKi9cbnZhciBpbnZlcnQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBpbnZlcnQob2JqKSB7XG4gIHZhciBwcm9wcyA9IGtleXMob2JqKTtcbiAgdmFyIGxlbiA9IHByb3BzLmxlbmd0aDtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBvdXQgPSB7fTtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2lkeF07XG4gICAgdmFyIHZhbCA9IG9ialtrZXldO1xuICAgIHZhciBsaXN0ID0gX2hhcyh2YWwsIG91dCkgPyBvdXRbdmFsXSA6IG91dFt2YWxdID0gW107XG4gICAgbGlzdFtsaXN0Lmxlbmd0aF0gPSBrZXk7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgaW52ZXJ0OyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMnO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIGtleXMgb2YgdGhlIGdpdmVuIG9iamVjdCBhcyB2YWx1ZXMsIGFuZCB0aGVcbiAqIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LCB3aGljaCBhcmUgY29lcmNlZCB0byBzdHJpbmdzLCBhcyBrZXlzLiBOb3RlXG4gKiB0aGF0IHRoZSBsYXN0IGtleSBmb3VuZCBpcyBwcmVmZXJyZWQgd2hlbiBoYW5kbGluZyB0aGUgc2FtZSB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge3M6IHh9IC0+IHt4OiBzfVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGludmVydFxuICogQHJldHVybiB7T2JqZWN0fSBvdXQgQSBuZXcgb2JqZWN0XG4gKiBAc2VlIFIuaW52ZXJ0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHJhY2VSZXN1bHRzID0ge1xuICogICAgICAgIGZpcnN0OiAnYWxpY2UnLFxuICogICAgICAgIHNlY29uZDogJ2pha2UnXG4gKiAgICAgIH07XG4gKiAgICAgIFIuaW52ZXJ0T2JqKHJhY2VSZXN1bHRzKTtcbiAqICAgICAgLy89PiB7ICdhbGljZSc6ICdmaXJzdCcsICdqYWtlJzonc2Vjb25kJyB9XG4gKlxuICogICAgICAvLyBBbHRlcm5hdGl2ZWx5OlxuICogICAgICB2YXIgcmFjZVJlc3VsdHMgPSBbJ2FsaWNlJywgJ2pha2UnXTtcbiAqICAgICAgUi5pbnZlcnRPYmoocmFjZVJlc3VsdHMpO1xuICogICAgICAvLz0+IHsgJ2FsaWNlJzogJzAnLCAnamFrZSc6JzEnIH1cbiAqL1xudmFyIGludmVydE9iaiA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGludmVydE9iaihvYmopIHtcbiAgdmFyIHByb3BzID0ga2V5cyhvYmopO1xuICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIG91dCA9IHt9O1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaWR4XTtcbiAgICBvdXRbb2JqW2tleV1dID0ga2V5O1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBvdXQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGludmVydE9iajsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9pc0Z1bmN0aW9uIGZyb20gJy4vaW50ZXJuYWwvX2lzRnVuY3Rpb24nO1xuaW1wb3J0IGN1cnJ5TiBmcm9tICcuL2N1cnJ5Tic7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZyc7XG5cbi8qKlxuICogVHVybnMgYSBuYW1lZCBtZXRob2Qgd2l0aCBhIHNwZWNpZmllZCBhcml0eSBpbnRvIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmVcbiAqIGNhbGxlZCBkaXJlY3RseSBzdXBwbGllZCB3aXRoIGFyZ3VtZW50cyBhbmQgYSB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIFRoZSByZXR1cm5lZCBmdW5jdGlvbiBpcyBjdXJyaWVkIGFuZCBhY2NlcHRzIGBhcml0eSArIDFgIHBhcmFtZXRlcnMgd2hlcmVcbiAqIHRoZSBmaW5hbCBwYXJhbWV0ZXIgaXMgdGhlIHRhcmdldCBvYmplY3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiAoYSAtPiBiIC0+IC4uLiAtPiBuIC0+IE9iamVjdCAtPiAqKVxuICogQHBhcmFtIHtOdW1iZXJ9IGFyaXR5IE51bWJlciBvZiBhcmd1bWVudHMgdGhlIHJldHVybmVkIGZ1bmN0aW9uIHNob3VsZCB0YWtlXG4gKiAgICAgICAgYmVmb3JlIHRoZSB0YXJnZXQgb2JqZWN0LlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBOYW1lIG9mIHRoZSBtZXRob2QgdG8gY2FsbC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICogQHNlZSBSLmNvbnN0cnVjdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBzbGljZUZyb20gPSBSLmludm9rZXIoMSwgJ3NsaWNlJyk7XG4gKiAgICAgIHNsaWNlRnJvbSg2LCAnYWJjZGVmZ2hpamtsbScpOyAvLz0+ICdnaGlqa2xtJ1xuICogICAgICB2YXIgc2xpY2VGcm9tNiA9IFIuaW52b2tlcigyLCAnc2xpY2UnKSg2KTtcbiAqICAgICAgc2xpY2VGcm9tNig4LCAnYWJjZGVmZ2hpamtsbScpOyAvLz0+ICdnaCdcbiAqIEBzeW1iIFIuaW52b2tlcigwLCAnbWV0aG9kJykobykgPSBvWydtZXRob2QnXSgpXG4gKiBAc3ltYiBSLmludm9rZXIoMSwgJ21ldGhvZCcpKGEsIG8pID0gb1snbWV0aG9kJ10oYSlcbiAqIEBzeW1iIFIuaW52b2tlcigyLCAnbWV0aG9kJykoYSwgYiwgbykgPSBvWydtZXRob2QnXShhLCBiKVxuICovXG52YXIgaW52b2tlciA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGludm9rZXIoYXJpdHksIG1ldGhvZCkge1xuICByZXR1cm4gY3VycnlOKGFyaXR5ICsgMSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHNbYXJpdHldO1xuICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiBfaXNGdW5jdGlvbih0YXJnZXRbbWV0aG9kXSkpIHtcbiAgICAgIHJldHVybiB0YXJnZXRbbWV0aG9kXS5hcHBseSh0YXJnZXQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgYXJpdHkpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0b1N0cmluZyh0YXJnZXQpICsgJyBkb2VzIG5vdCBoYXZlIGEgbWV0aG9kIG5hbWVkIFwiJyArIG1ldGhvZCArICdcIicpO1xuICB9KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgaW52b2tlcjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFNlZSBpZiBhbiBvYmplY3QgKGB2YWxgKSBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgc3VwcGxpZWQgY29uc3RydWN0b3IuIFRoaXNcbiAqIGZ1bmN0aW9uIHdpbGwgY2hlY2sgdXAgdGhlIGluaGVyaXRhbmNlIGNoYWluLCBpZiBhbnkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMy4wXG4gKiBAY2F0ZWdvcnkgVHlwZVxuICogQHNpZyAoKiAtPiB7Kn0pIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHtPYmplY3R9IGN0b3IgQSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pcyhPYmplY3QsIHt9KTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaXMoTnVtYmVyLCAxKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaXMoT2JqZWN0LCAxKTsgLy89PiBmYWxzZVxuICogICAgICBSLmlzKFN0cmluZywgJ3MnKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaXMoU3RyaW5nLCBuZXcgU3RyaW5nKCcnKSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzKE9iamVjdCwgbmV3IFN0cmluZygnJykpOyAvLz0+IHRydWVcbiAqICAgICAgUi5pcyhPYmplY3QsICdzJyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5pcyhOdW1iZXIsIHt9KTsgLy89PiBmYWxzZVxuICovXG52YXIgaXMgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBpcyhDdG9yLCB2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHZhbC5jb25zdHJ1Y3RvciA9PT0gQ3RvciB8fCB2YWwgaW5zdGFuY2VvZiBDdG9yO1xufSk7XG5leHBvcnQgZGVmYXVsdCBpczsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IGVtcHR5IGZyb20gJy4vZW1wdHknO1xuaW1wb3J0IGVxdWFscyBmcm9tICcuL2VxdWFscyc7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGl0cyB0eXBlJ3MgZW1wdHkgdmFsdWU7IGBmYWxzZWBcbiAqIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyBhIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5lbXB0eVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaXNFbXB0eShbMSwgMiwgM10pOyAgIC8vPT4gZmFsc2VcbiAqICAgICAgUi5pc0VtcHR5KFtdKTsgICAgICAgICAgLy89PiB0cnVlXG4gKiAgICAgIFIuaXNFbXB0eSgnJyk7ICAgICAgICAgIC8vPT4gdHJ1ZVxuICogICAgICBSLmlzRW1wdHkobnVsbCk7ICAgICAgICAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXNFbXB0eSh7fSk7ICAgICAgICAgIC8vPT4gdHJ1ZVxuICogICAgICBSLmlzRW1wdHkoe2xlbmd0aDogMH0pOyAvLz0+IGZhbHNlXG4gKi9cbnZhciBpc0VtcHR5ID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gaXNFbXB0eSh4KSB7XG4gIHJldHVybiB4ICE9IG51bGwgJiYgZXF1YWxzKHgsIGVtcHR5KHgpKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgaXNFbXB0eTsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgaW5wdXQgdmFsdWUgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IFR5cGVcbiAqIEBzaWcgKiAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IHggVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHhgIGlzIGB1bmRlZmluZWRgIG9yIGBudWxsYCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pc05pbChudWxsKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaXNOaWwodW5kZWZpbmVkKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaXNOaWwoMCk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5pc05pbChbXSk7IC8vPT4gZmFsc2VcbiAqL1xudmFyIGlzTmlsID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gaXNOaWwoeCkge1xuICByZXR1cm4geCA9PSBudWxsO1xufSk7XG5leHBvcnQgZGVmYXVsdCBpc05pbDsiLCJpbXBvcnQgaW52b2tlciBmcm9tICcuL2ludm9rZXInO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgbWFkZSBieSBpbnNlcnRpbmcgdGhlIGBzZXBhcmF0b3JgIGJldHdlZW4gZWFjaCBlbGVtZW50IGFuZFxuICogY29uY2F0ZW5hdGluZyBhbGwgdGhlIGVsZW1lbnRzIGludG8gYSBzaW5nbGUgc3RyaW5nLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgU3RyaW5nIC0+IFthXSAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gc2VwYXJhdG9yIFRoZSBzdHJpbmcgdXNlZCB0byBzZXBhcmF0ZSB0aGUgZWxlbWVudHMuXG4gKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgZWxlbWVudHMgdG8gam9pbiBpbnRvIGEgc3RyaW5nLlxuICogQHJldHVybiB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyBtYWRlIGJ5IGNvbmNhdGVuYXRpbmcgYHhzYCB3aXRoIGBzZXBhcmF0b3JgLlxuICogQHNlZSBSLnNwbGl0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHNwYWNlciA9IFIuam9pbignICcpO1xuICogICAgICBzcGFjZXIoWydhJywgMiwgMy40XSk7ICAgLy89PiAnYSAyIDMuNCdcbiAqICAgICAgUi5qb2luKCd8JywgWzEsIDIsIDNdKTsgICAgLy89PiAnMXwyfDMnXG4gKi9cbnZhciBqb2luID0gLyojX19QVVJFX18qL2ludm9rZXIoMSwgJ2pvaW4nKTtcbmV4cG9ydCBkZWZhdWx0IGpvaW47IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBjb252ZXJnZSBmcm9tICcuL2NvbnZlcmdlJztcblxuLyoqXG4gKiBqdXh0IGFwcGxpZXMgYSBsaXN0IG9mIGZ1bmN0aW9ucyB0byBhIGxpc3Qgb2YgdmFsdWVzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBbKGEsIGIsIC4uLiwgbSkgLT4gbl0gLT4gKChhLCBiLCAuLi4sIG0pIC0+IFtuXSlcbiAqIEBwYXJhbSB7QXJyYXl9IGZucyBBbiBhcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGxpc3Qgb2YgdmFsdWVzIGFmdGVyIGFwcGx5aW5nIGVhY2ggb2YgdGhlIG9yaWdpbmFsIGBmbnNgIHRvIGl0cyBwYXJhbWV0ZXJzLlxuICogQHNlZSBSLmFwcGx5U3BlY1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBnZXRSYW5nZSA9IFIuanV4dChbTWF0aC5taW4sIE1hdGgubWF4XSk7XG4gKiAgICAgIGdldFJhbmdlKDMsIDQsIDksIC0zKTsgLy89PiBbLTMsIDldXG4gKiBAc3ltYiBSLmp1eHQoW2YsIGcsIGhdKShhLCBiKSA9IFtmKGEsIGIpLCBnKGEsIGIpLCBoKGEsIGIpXVxuICovXG52YXIganV4dCA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGp1eHQoZm5zKSB7XG4gIHJldHVybiBjb252ZXJnZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIH0sIGZucyk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGp1eHQ7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBfaGFzIGZyb20gJy4vaW50ZXJuYWwvX2hhcyc7XG5pbXBvcnQgX2lzQXJndW1lbnRzIGZyb20gJy4vaW50ZXJuYWwvX2lzQXJndW1lbnRzJztcblxuLy8gY292ZXIgSUUgPCA5IGtleXMgaXNzdWVzXG52YXIgaGFzRW51bUJ1ZyA9ICEgLyojX19QVVJFX18qL3sgdG9TdHJpbmc6IG51bGwgfS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcbnZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ2NvbnN0cnVjdG9yJywgJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuLy8gU2FmYXJpIGJ1Z1xudmFyIGhhc0FyZ3NFbnVtQnVnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHJldHVybiBhcmd1bWVudHMucHJvcGVydHlJc0VudW1lcmFibGUoJ2xlbmd0aCcpO1xufSgpO1xuXG52YXIgY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhsaXN0LCBpdGVtKSB7XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICBpZiAobGlzdFtpZHhdID09PSBpdGVtKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgdGhlIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgb2ZcbiAqIHRoZSBzdXBwbGllZCBvYmplY3QuXG4gKiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBvdXRwdXQgYXJyYXkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgY29uc2lzdGVudFxuICogYWNyb3NzIGRpZmZlcmVudCBKUyBwbGF0Zm9ybXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtrOiB2fSAtPiBba11cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAqIEBzZWUgUi5rZXlzSW4sIFIudmFsdWVzXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5rZXlzKHthOiAxLCBiOiAyLCBjOiAzfSk7IC8vPT4gWydhJywgJ2InLCAnYyddXG4gKi9cbnZhciBfa2V5cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiAhaGFzQXJnc0VudW1CdWcgPyBmdW5jdGlvbiBrZXlzKG9iaikge1xuICByZXR1cm4gT2JqZWN0KG9iaikgIT09IG9iaiA/IFtdIDogT2JqZWN0LmtleXMob2JqKTtcbn0gOiBmdW5jdGlvbiBrZXlzKG9iaikge1xuICBpZiAoT2JqZWN0KG9iaikgIT09IG9iaikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgcHJvcCwgbklkeDtcbiAgdmFyIGtzID0gW107XG4gIHZhciBjaGVja0FyZ3NMZW5ndGggPSBoYXNBcmdzRW51bUJ1ZyAmJiBfaXNBcmd1bWVudHMob2JqKTtcbiAgZm9yIChwcm9wIGluIG9iaikge1xuICAgIGlmIChfaGFzKHByb3AsIG9iaikgJiYgKCFjaGVja0FyZ3NMZW5ndGggfHwgcHJvcCAhPT0gJ2xlbmd0aCcpKSB7XG4gICAgICBrc1trcy5sZW5ndGhdID0gcHJvcDtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc0VudW1CdWcpIHtcbiAgICBuSWR4ID0gbm9uRW51bWVyYWJsZVByb3BzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKG5JZHggPj0gMCkge1xuICAgICAgcHJvcCA9IG5vbkVudW1lcmFibGVQcm9wc1tuSWR4XTtcbiAgICAgIGlmIChfaGFzKHByb3AsIG9iaikgJiYgIWNvbnRhaW5zKGtzLCBwcm9wKSkge1xuICAgICAgICBrc1trcy5sZW5ndGhdID0gcHJvcDtcbiAgICAgIH1cbiAgICAgIG5JZHggLT0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtzO1xufTtcbnZhciBrZXlzID0gLyojX19QVVJFX18qL19jdXJyeTEoX2tleXMpO1xuZXhwb3J0IGRlZmF1bHQga2V5czsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCB0aGUgcHJvcGVydGllcyBvZiB0aGUgc3VwcGxpZWRcbiAqIG9iamVjdCwgaW5jbHVkaW5nIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnRcbiAqIGFjcm9zcyBkaWZmZXJlbnQgSlMgcGxhdGZvcm1zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7azogdn0gLT4gW2tdXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgb2JqZWN0J3Mgb3duIGFuZCBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqIEBzZWUgUi5rZXlzLCBSLnZhbHVlc0luXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIEYgPSBmdW5jdGlvbigpIHsgdGhpcy54ID0gJ1gnOyB9O1xuICogICAgICBGLnByb3RvdHlwZS55ID0gJ1knO1xuICogICAgICB2YXIgZiA9IG5ldyBGKCk7XG4gKiAgICAgIFIua2V5c0luKGYpOyAvLz0+IFsneCcsICd5J11cbiAqL1xudmFyIGtleXNJbiA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGtleXNJbihvYmopIHtcbiAgdmFyIHByb3A7XG4gIHZhciBrcyA9IFtdO1xuICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAga3Nba3MubGVuZ3RoXSA9IHByb3A7XG4gIH1cbiAgcmV0dXJuIGtzO1xufSk7XG5leHBvcnQgZGVmYXVsdCBrZXlzSW47IiwiaW1wb3J0IG50aCBmcm9tICcuL250aCc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjRcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBhIHwgVW5kZWZpbmVkXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7Kn0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5pbml0LCBSLmhlYWQsIFIudGFpbFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubGFzdChbJ2ZpJywgJ2ZvJywgJ2Z1bSddKTsgLy89PiAnZnVtJ1xuICogICAgICBSLmxhc3QoW10pOyAvLz0+IHVuZGVmaW5lZFxuICpcbiAqICAgICAgUi5sYXN0KCdhYmMnKTsgLy89PiAnYydcbiAqICAgICAgUi5sYXN0KCcnKTsgLy89PiAnJ1xuICovXG52YXIgbGFzdCA9IC8qI19fUFVSRV9fKi9udGgoLTEpO1xuZXhwb3J0IGRlZmF1bHQgbGFzdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9pc0FycmF5IGZyb20gJy4vaW50ZXJuYWwvX2lzQXJyYXknO1xuaW1wb3J0IGVxdWFscyBmcm9tICcuL2VxdWFscyc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LCBvciAtMSBpZlxuICogdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS4gW2BSLmVxdWFsc2BdKCNlcXVhbHMpIGlzIHVzZWQgdG9cbiAqIGRldGVybWluZSBlcXVhbGl0eS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gW2FdIC0+IE51bWJlclxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIGl0ZW0gdG8gZmluZC5cbiAqIEBwYXJhbSB7QXJyYXl9IHhzIFRoZSBhcnJheSB0byBzZWFyY2ggaW4uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgdGFyZ2V0LCBvciAtMSBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBmb3VuZC5cbiAqIEBzZWUgUi5pbmRleE9mXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5sYXN0SW5kZXhPZigzLCBbLTEsMywzLDAsMSwyLDMsNF0pOyAvLz0+IDZcbiAqICAgICAgUi5sYXN0SW5kZXhPZigxMCwgWzEsMiwzLDRdKTsgLy89PiAtMVxuICovXG52YXIgbGFzdEluZGV4T2YgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBsYXN0SW5kZXhPZih0YXJnZXQsIHhzKSB7XG4gIGlmICh0eXBlb2YgeHMubGFzdEluZGV4T2YgPT09ICdmdW5jdGlvbicgJiYgIV9pc0FycmF5KHhzKSkge1xuICAgIHJldHVybiB4cy5sYXN0SW5kZXhPZih0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBpZHggPSB4cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChpZHggPj0gMCkge1xuICAgICAgaWYgKGVxdWFscyh4c1tpZHhdLCB0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICBpZHggLT0gMTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTtcbmV4cG9ydCBkZWZhdWx0IGxhc3RJbmRleE9mOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgX2lzTnVtYmVyIGZyb20gJy4vaW50ZXJuYWwvX2lzTnVtYmVyJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5IGJ5IHJldHVybmluZyBgbGlzdC5sZW5ndGhgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IE51bWJlclxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5sZW5ndGgoW10pOyAvLz0+IDBcbiAqICAgICAgUi5sZW5ndGgoWzEsIDIsIDNdKTsgLy89PiAzXG4gKi9cbnZhciBsZW5ndGggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBsZW5ndGgobGlzdCkge1xuICByZXR1cm4gbGlzdCAhPSBudWxsICYmIF9pc051bWJlcihsaXN0Lmxlbmd0aCkgPyBsaXN0Lmxlbmd0aCA6IE5hTjtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbGVuZ3RoOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgbWFwIGZyb20gJy4vbWFwJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGVucyBmb3IgdGhlIGdpdmVuIGdldHRlciBhbmQgc2V0dGVyIGZ1bmN0aW9ucy4gVGhlIGdldHRlciBcImdldHNcIlxuICogdGhlIHZhbHVlIG9mIHRoZSBmb2N1czsgdGhlIHNldHRlciBcInNldHNcIiB0aGUgdmFsdWUgb2YgdGhlIGZvY3VzLiBUaGUgc2V0dGVyXG4gKiBzaG91bGQgbm90IG11dGF0ZSB0aGUgZGF0YSBzdHJ1Y3R1cmUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICogQHNpZyAocyAtPiBhKSAtPiAoKGEsIHMpIC0+IHMpIC0+IExlbnMgcyBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlclxuICogQHJldHVybiB7TGVuc31cbiAqIEBzZWUgUi52aWV3LCBSLnNldCwgUi5vdmVyLCBSLmxlbnNJbmRleCwgUi5sZW5zUHJvcFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB4TGVucyA9IFIubGVucyhSLnByb3AoJ3gnKSwgUi5hc3NvYygneCcpKTtcbiAqXG4gKiAgICAgIFIudmlldyh4TGVucywge3g6IDEsIHk6IDJ9KTsgICAgICAgICAgICAvLz0+IDFcbiAqICAgICAgUi5zZXQoeExlbnMsIDQsIHt4OiAxLCB5OiAyfSk7ICAgICAgICAgIC8vPT4ge3g6IDQsIHk6IDJ9XG4gKiAgICAgIFIub3Zlcih4TGVucywgUi5uZWdhdGUsIHt4OiAxLCB5OiAyfSk7ICAvLz0+IHt4OiAtMSwgeTogMn1cbiAqL1xudmFyIGxlbnMgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBsZW5zKGdldHRlciwgc2V0dGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodG9GdW5jdG9yRm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgcmV0dXJuIG1hcChmdW5jdGlvbiAoZm9jdXMpIHtcbiAgICAgICAgcmV0dXJuIHNldHRlcihmb2N1cywgdGFyZ2V0KTtcbiAgICAgIH0sIHRvRnVuY3RvckZuKGdldHRlcih0YXJnZXQpKSk7XG4gICAgfTtcbiAgfTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbGVuczsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IGxlbnMgZnJvbSAnLi9sZW5zJztcbmltcG9ydCBudGggZnJvbSAnLi9udGgnO1xuaW1wb3J0IHVwZGF0ZSBmcm9tICcuL3VwZGF0ZSc7XG5cbi8qKlxuICogUmV0dXJucyBhIGxlbnMgd2hvc2UgZm9jdXMgaXMgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICogQHNpZyBOdW1iZXIgLT4gTGVucyBzIGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtMZW5zfVxuICogQHNlZSBSLnZpZXcsIFIuc2V0LCBSLm92ZXJcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaGVhZExlbnMgPSBSLmxlbnNJbmRleCgwKTtcbiAqXG4gKiAgICAgIFIudmlldyhoZWFkTGVucywgWydhJywgJ2InLCAnYyddKTsgICAgICAgICAgICAvLz0+ICdhJ1xuICogICAgICBSLnNldChoZWFkTGVucywgJ3gnLCBbJ2EnLCAnYicsICdjJ10pOyAgICAgICAgLy89PiBbJ3gnLCAnYicsICdjJ11cbiAqICAgICAgUi5vdmVyKGhlYWRMZW5zLCBSLnRvVXBwZXIsIFsnYScsICdiJywgJ2MnXSk7IC8vPT4gWydBJywgJ2InLCAnYyddXG4gKi9cbnZhciBsZW5zSW5kZXggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBsZW5zSW5kZXgobikge1xuICByZXR1cm4gbGVucyhudGgobiksIHVwZGF0ZShuKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGxlbnNJbmRleDsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IGFzc29jUGF0aCBmcm9tICcuL2Fzc29jUGF0aCc7XG5pbXBvcnQgbGVucyBmcm9tICcuL2xlbnMnO1xuaW1wb3J0IHBhdGggZnJvbSAnLi9wYXRoJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGVucyB3aG9zZSBmb2N1cyBpcyB0aGUgc3BlY2lmaWVkIHBhdGguXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIElkeCA9IFN0cmluZyB8IEludFxuICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAqIEBzaWcgW0lkeF0gLT4gTGVucyBzIGFcbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gdXNlLlxuICogQHJldHVybiB7TGVuc31cbiAqIEBzZWUgUi52aWV3LCBSLnNldCwgUi5vdmVyXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHhIZWFkWUxlbnMgPSBSLmxlbnNQYXRoKFsneCcsIDAsICd5J10pO1xuICpcbiAqICAgICAgUi52aWV3KHhIZWFkWUxlbnMsIHt4OiBbe3k6IDIsIHo6IDN9LCB7eTogNCwgejogNX1dfSk7XG4gKiAgICAgIC8vPT4gMlxuICogICAgICBSLnNldCh4SGVhZFlMZW5zLCAxLCB7eDogW3t5OiAyLCB6OiAzfSwge3k6IDQsIHo6IDV9XX0pO1xuICogICAgICAvLz0+IHt4OiBbe3k6IDEsIHo6IDN9LCB7eTogNCwgejogNX1dfVxuICogICAgICBSLm92ZXIoeEhlYWRZTGVucywgUi5uZWdhdGUsIHt4OiBbe3k6IDIsIHo6IDN9LCB7eTogNCwgejogNX1dfSk7XG4gKiAgICAgIC8vPT4ge3g6IFt7eTogLTIsIHo6IDN9LCB7eTogNCwgejogNX1dfVxuICovXG52YXIgbGVuc1BhdGggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBsZW5zUGF0aChwKSB7XG4gIHJldHVybiBsZW5zKHBhdGgocCksIGFzc29jUGF0aChwKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGxlbnNQYXRoOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgYXNzb2MgZnJvbSAnLi9hc3NvYyc7XG5pbXBvcnQgbGVucyBmcm9tICcuL2xlbnMnO1xuaW1wb3J0IHByb3AgZnJvbSAnLi9wcm9wJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGVucyB3aG9zZSBmb2N1cyBpcyB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gKiBAc2lnIFN0cmluZyAtPiBMZW5zIHMgYVxuICogQHBhcmFtIHtTdHJpbmd9IGtcbiAqIEByZXR1cm4ge0xlbnN9XG4gKiBAc2VlIFIudmlldywgUi5zZXQsIFIub3ZlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB4TGVucyA9IFIubGVuc1Byb3AoJ3gnKTtcbiAqXG4gKiAgICAgIFIudmlldyh4TGVucywge3g6IDEsIHk6IDJ9KTsgICAgICAgICAgICAvLz0+IDFcbiAqICAgICAgUi5zZXQoeExlbnMsIDQsIHt4OiAxLCB5OiAyfSk7ICAgICAgICAgIC8vPT4ge3g6IDQsIHk6IDJ9XG4gKiAgICAgIFIub3Zlcih4TGVucywgUi5uZWdhdGUsIHt4OiAxLCB5OiAyfSk7ICAvLz0+IHt4OiAtMSwgeTogMn1cbiAqL1xudmFyIGxlbnNQcm9wID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gbGVuc1Byb3Aoaykge1xuICByZXR1cm4gbGVucyhwcm9wKGspLCBhc3NvYyhrKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGxlbnNQcm9wOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgbGlmdE4gZnJvbSAnLi9saWZ0Tic7XG5cbi8qKlxuICogXCJsaWZ0c1wiIGEgZnVuY3Rpb24gb2YgYXJpdHkgPiAxIHNvIHRoYXQgaXQgbWF5IFwibWFwIG92ZXJcIiBhIGxpc3QsIEZ1bmN0aW9uIG9yIG90aGVyXG4gKiBvYmplY3QgdGhhdCBzYXRpc2ZpZXMgdGhlIFtGYW50YXN5TGFuZCBBcHBseSBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwcGx5KS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC43LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKi4uLiAtPiAqKSAtPiAoWypdLi4uIC0+IFsqXSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBsaWZ0IGludG8gaGlnaGVyIGNvbnRleHRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgbGlmdGVkIGZ1bmN0aW9uLlxuICogQHNlZSBSLmxpZnROXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG1hZGQzID0gUi5saWZ0KChhLCBiLCBjKSA9PiBhICsgYiArIGMpO1xuICpcbiAqICAgICAgbWFkZDMoWzEsMiwzXSwgWzEsMiwzXSwgWzFdKTsgLy89PiBbMywgNCwgNSwgNCwgNSwgNiwgNSwgNiwgN11cbiAqXG4gKiAgICAgIHZhciBtYWRkNSA9IFIubGlmdCgoYSwgYiwgYywgZCwgZSkgPT4gYSArIGIgKyBjICsgZCArIGUpO1xuICpcbiAqICAgICAgbWFkZDUoWzEsMl0sIFszXSwgWzQsIDVdLCBbNl0sIFs3LCA4XSk7IC8vPT4gWzIxLCAyMiwgMjIsIDIzLCAyMiwgMjMsIDIzLCAyNF1cbiAqL1xudmFyIGxpZnQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBsaWZ0KGZuKSB7XG4gIHJldHVybiBsaWZ0Tihmbi5sZW5ndGgsIGZuKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbGlmdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9yZWR1Y2UgZnJvbSAnLi9pbnRlcm5hbC9fcmVkdWNlJztcbmltcG9ydCBhcCBmcm9tICcuL2FwJztcbmltcG9ydCBjdXJyeU4gZnJvbSAnLi9jdXJyeU4nO1xuaW1wb3J0IG1hcCBmcm9tICcuL21hcCc7XG5cbi8qKlxuICogXCJsaWZ0c1wiIGEgZnVuY3Rpb24gdG8gYmUgdGhlIHNwZWNpZmllZCBhcml0eSwgc28gdGhhdCBpdCBtYXkgXCJtYXAgb3ZlclwiIHRoYXRcbiAqIG1hbnkgbGlzdHMsIEZ1bmN0aW9ucyBvciBvdGhlciBvYmplY3RzIHRoYXQgc2F0aXNmeSB0aGUgW0ZhbnRhc3lMYW5kIEFwcGx5IHNwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXBwbHkpLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjcuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE51bWJlciAtPiAoKi4uLiAtPiAqKSAtPiAoWypdLi4uIC0+IFsqXSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBsaWZ0IGludG8gaGlnaGVyIGNvbnRleHRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgbGlmdGVkIGZ1bmN0aW9uLlxuICogQHNlZSBSLmxpZnQsIFIuYXBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbWFkZDMgPSBSLmxpZnROKDMsICguLi5hcmdzKSA9PiBSLnN1bShhcmdzKSk7XG4gKiAgICAgIG1hZGQzKFsxLDIsM10sIFsxLDIsM10sIFsxXSk7IC8vPT4gWzMsIDQsIDUsIDQsIDUsIDYsIDUsIDYsIDddXG4gKi9cbnZhciBsaWZ0TiA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGxpZnROKGFyaXR5LCBmbikge1xuICB2YXIgbGlmdGVkID0gY3VycnlOKGFyaXR5LCBmbik7XG4gIHJldHVybiBjdXJyeU4oYXJpdHksIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3JlZHVjZShhcCwgbWFwKGxpZnRlZCwgYXJndW1lbnRzWzBdKSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBsaWZ0TjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZDsgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5ndFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubHQoMiwgMSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5sdCgyLCAyKTsgLy89PiBmYWxzZVxuICogICAgICBSLmx0KDIsIDMpOyAvLz0+IHRydWVcbiAqICAgICAgUi5sdCgnYScsICd6Jyk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmx0KCd6JywgJ2EnKTsgLy89PiBmYWxzZVxuICovXG52YXIgbHQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBsdChhLCBiKSB7XG4gIHJldHVybiBhIDwgYjtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbHQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQ7XG4gKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmd0ZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubHRlKDIsIDEpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIubHRlKDIsIDIpOyAvLz0+IHRydWVcbiAqICAgICAgUi5sdGUoMiwgMyk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmx0ZSgnYScsICd6Jyk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmx0ZSgneicsICdhJyk7IC8vPT4gZmFsc2VcbiAqL1xudmFyIGx0ZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIGx0ZShhLCBiKSB7XG4gIHJldHVybiBhIDw9IGI7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGx0ZTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfbWFwIGZyb20gJy4vaW50ZXJuYWwvX21hcCc7XG5pbXBvcnQgX3JlZHVjZSBmcm9tICcuL2ludGVybmFsL19yZWR1Y2UnO1xuaW1wb3J0IF94bWFwIGZyb20gJy4vaW50ZXJuYWwvX3htYXAnO1xuaW1wb3J0IGN1cnJ5TiBmcm9tICcuL2N1cnJ5Tic7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMnO1xuXG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYW5kXG4gKiBhIFtmdW5jdG9yXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2Z1bmN0b3IpLFxuICogYXBwbGllcyB0aGUgZnVuY3Rpb24gdG8gZWFjaCBvZiB0aGUgZnVuY3RvcidzIHZhbHVlcywgYW5kIHJldHVybnNcbiAqIGEgZnVuY3RvciBvZiB0aGUgc2FtZSBzaGFwZS5cbiAqXG4gKiBSYW1kYSBwcm92aWRlcyBzdWl0YWJsZSBgbWFwYCBpbXBsZW1lbnRhdGlvbnMgZm9yIGBBcnJheWAgYW5kIGBPYmplY3RgLFxuICogc28gdGhpcyBmdW5jdGlvbiBtYXkgYmUgYXBwbGllZCB0byBgWzEsIDIsIDNdYCBvciBge3g6IDEsIHk6IDIsIHo6IDN9YC5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgbWFwYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQWxzbyB0cmVhdHMgZnVuY3Rpb25zIGFzIGZ1bmN0b3JzIGFuZCB3aWxsIGNvbXBvc2UgdGhlbSB0b2dldGhlci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIEZ1bmN0b3IgZiA9PiAoYSAtPiBiKSAtPiBmIGEgLT4gZiBiXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGlucHV0IGBsaXN0YC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gYmUgaXRlcmF0ZWQgb3Zlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbmV3IGxpc3QuXG4gKiBAc2VlIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGRvdWJsZSA9IHggPT4geCAqIDI7XG4gKlxuICogICAgICBSLm1hcChkb3VibGUsIFsxLCAyLCAzXSk7IC8vPT4gWzIsIDQsIDZdXG4gKlxuICogICAgICBSLm1hcChkb3VibGUsIHt4OiAxLCB5OiAyLCB6OiAzfSk7IC8vPT4ge3g6IDIsIHk6IDQsIHo6IDZ9XG4gKiBAc3ltYiBSLm1hcChmLCBbYSwgYl0pID0gW2YoYSksIGYoYildXG4gKiBAc3ltYiBSLm1hcChmLCB7IHg6IGEsIHk6IGIgfSkgPSB7IHg6IGYoYSksIHk6IGYoYikgfVxuICogQHN5bWIgUi5tYXAoZiwgZnVuY3Rvcl9vKSA9IGZ1bmN0b3Jfby5tYXAoZilcbiAqL1xudmFyIG1hcCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovX2Rpc3BhdGNoYWJsZShbJ2ZhbnRhc3ktbGFuZC9tYXAnLCAnbWFwJ10sIF94bWFwLCBmdW5jdGlvbiBtYXAoZm4sIGZ1bmN0b3IpIHtcbiAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZnVuY3RvcikpIHtcbiAgICBjYXNlICdbb2JqZWN0IEZ1bmN0aW9uXSc6XG4gICAgICByZXR1cm4gY3VycnlOKGZ1bmN0b3IubGVuZ3RoLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGZ1bmN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICB9KTtcbiAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOlxuICAgICAgcmV0dXJuIF9yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIGFjY1trZXldID0gZm4oZnVuY3RvcltrZXldKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9LCBrZXlzKGZ1bmN0b3IpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIF9tYXAoZm4sIGZ1bmN0b3IpO1xuICB9XG59KSk7XG5leHBvcnQgZGVmYXVsdCBtYXA7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLyoqXG4gKiBUaGUgYG1hcEFjY3VtYCBmdW5jdGlvbiBiZWhhdmVzIGxpa2UgYSBjb21iaW5hdGlvbiBvZiBtYXAgYW5kIHJlZHVjZTsgaXRcbiAqIGFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIGVsZW1lbnQgb2YgYSBsaXN0LCBwYXNzaW5nIGFuIGFjY3VtdWxhdGluZ1xuICogcGFyYW1ldGVyIGZyb20gbGVmdCB0byByaWdodCwgYW5kIHJldHVybmluZyBhIGZpbmFsIHZhbHVlIG9mIHRoaXNcbiAqIGFjY3VtdWxhdG9yIHRvZ2V0aGVyIHdpdGggdGhlIG5ldyBsaXN0LlxuICpcbiAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyB0d28gYXJndW1lbnRzLCAqYWNjKiBhbmQgKnZhbHVlKiwgYW5kIHNob3VsZFxuICogcmV0dXJuIGEgdHVwbGUgKlthY2MsIHZhbHVlXSouXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTAuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhY2MsIHgpIC0+IChhY2MsIHkpKSAtPiBhY2MgLT4gW3hdIC0+IChhY2MsIFt5XSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gZXZlcnkgZWxlbWVudCBvZiB0aGUgaW5wdXQgYGxpc3RgLlxuICogQHBhcmFtIHsqfSBhY2MgVGhlIGFjY3VtdWxhdG9yIHZhbHVlLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQHNlZSBSLmFkZEluZGV4LCBSLm1hcEFjY3VtUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZGlnaXRzID0gWycxJywgJzInLCAnMycsICc0J107XG4gKiAgICAgIHZhciBhcHBlbmRlciA9IChhLCBiKSA9PiBbYSArIGIsIGEgKyBiXTtcbiAqXG4gKiAgICAgIFIubWFwQWNjdW0oYXBwZW5kZXIsIDAsIGRpZ2l0cyk7IC8vPT4gWycwMTIzNCcsIFsnMDEnLCAnMDEyJywgJzAxMjMnLCAnMDEyMzQnXV1cbiAqIEBzeW1iIFIubWFwQWNjdW0oZiwgYSwgW2IsIGMsIGRdKSA9IFtcbiAqICAgZihmKGYoYSwgYilbMF0sIGMpWzBdLCBkKVswXSxcbiAqICAgW1xuICogICAgIGYoYSwgYilbMV0sXG4gKiAgICAgZihmKGEsIGIpWzBdLCBjKVsxXSxcbiAqICAgICBmKGYoZihhLCBiKVswXSwgYylbMF0sIGQpWzFdXG4gKiAgIF1cbiAqIF1cbiAqL1xudmFyIG1hcEFjY3VtID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gbWFwQWNjdW0oZm4sIGFjYywgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciB0dXBsZSA9IFthY2NdO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgdHVwbGUgPSBmbih0dXBsZVswXSwgbGlzdFtpZHhdKTtcbiAgICByZXN1bHRbaWR4XSA9IHR1cGxlWzFdO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBbdHVwbGVbMF0sIHJlc3VsdF07XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1hcEFjY3VtOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8qKlxuICogVGhlIGBtYXBBY2N1bVJpZ2h0YCBmdW5jdGlvbiBiZWhhdmVzIGxpa2UgYSBjb21iaW5hdGlvbiBvZiBtYXAgYW5kIHJlZHVjZTsgaXRcbiAqIGFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIGVsZW1lbnQgb2YgYSBsaXN0LCBwYXNzaW5nIGFuIGFjY3VtdWxhdGluZ1xuICogcGFyYW1ldGVyIGZyb20gcmlnaHQgdG8gbGVmdCwgYW5kIHJldHVybmluZyBhIGZpbmFsIHZhbHVlIG9mIHRoaXNcbiAqIGFjY3VtdWxhdG9yIHRvZ2V0aGVyIHdpdGggdGhlIG5ldyBsaXN0LlxuICpcbiAqIFNpbWlsYXIgdG8gW2BtYXBBY2N1bWBdKCNtYXBBY2N1bSksIGV4Y2VwdCBtb3ZlcyB0aHJvdWdoIHRoZSBpbnB1dCBsaXN0IGZyb21cbiAqIHRoZSByaWdodCB0byB0aGUgbGVmdC5cbiAqXG4gKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIGFyZ3VtZW50cywgKnZhbHVlKiBhbmQgKmFjYyosIGFuZCBzaG91bGRcbiAqIHJldHVybiBhIHR1cGxlICpbdmFsdWUsIGFjY10qLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoeCwgYWNjKSAtPiAoeSwgYWNjKSkgLT4gYWNjIC0+IFt4XSAtPiAoW3ldLCBhY2MpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGlucHV0IGBsaXN0YC5cbiAqIEBwYXJhbSB7Kn0gYWNjIFRoZSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgUi5hZGRJbmRleCwgUi5tYXBBY2N1bVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBkaWdpdHMgPSBbJzEnLCAnMicsICczJywgJzQnXTtcbiAqICAgICAgdmFyIGFwcGVuZCA9IChhLCBiKSA9PiBbYSArIGIsIGEgKyBiXTtcbiAqXG4gKiAgICAgIFIubWFwQWNjdW1SaWdodChhcHBlbmQsIDUsIGRpZ2l0cyk7IC8vPT4gW1snMTIzNDUnLCAnMjM0NScsICczNDUnLCAnNDUnXSwgJzEyMzQ1J11cbiAqIEBzeW1iIFIubWFwQWNjdW1SaWdodChmLCBhLCBbYiwgYywgZF0pID0gW1xuICogICBbXG4gKiAgICAgZihiLCBmKGMsIGYoZCwgYSlbMF0pWzBdKVsxXSxcbiAqICAgICBmKGMsIGYoZCwgYSlbMF0pWzFdLFxuICogICAgIGYoZCwgYSlbMV0sXG4gKiAgIF1cbiAqICAgZihiLCBmKGMsIGYoZCwgYSlbMF0pWzBdKVswXSxcbiAqIF1cbiAqL1xudmFyIG1hcEFjY3VtUmlnaHQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBtYXBBY2N1bVJpZ2h0KGZuLCBhY2MsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgdHVwbGUgPSBbYWNjXTtcbiAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgdHVwbGUgPSBmbihsaXN0W2lkeF0sIHR1cGxlWzBdKTtcbiAgICByZXN1bHRbaWR4XSA9IHR1cGxlWzFdO1xuICAgIGlkeCAtPSAxO1xuICB9XG4gIHJldHVybiBbcmVzdWx0LCB0dXBsZVswXV07XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1hcEFjY3VtUmlnaHQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfcmVkdWNlIGZyb20gJy4vaW50ZXJuYWwvX3JlZHVjZSc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMnO1xuXG4vKipcbiAqIEFuIE9iamVjdC1zcGVjaWZpYyB2ZXJzaW9uIG9mIFtgbWFwYF0oI21hcCkuIFRoZSBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRocmVlXG4gKiBhcmd1bWVudHM6ICoodmFsdWUsIGtleSwgb2JqKSouIElmIG9ubHkgdGhlIHZhbHVlIGlzIHNpZ25pZmljYW50LCB1c2VcbiAqIFtgbWFwYF0oI21hcCkgaW5zdGVhZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgKCgqLCBTdHJpbmcsIE9iamVjdCkgLT4gKikgLT4gT2JqZWN0IC0+IE9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgUi5tYXBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgdmFsdWVzID0geyB4OiAxLCB5OiAyLCB6OiAzIH07XG4gKiAgICAgIHZhciBwcmVwZW5kS2V5QW5kRG91YmxlID0gKG51bSwga2V5LCBvYmopID0+IGtleSArIChudW0gKiAyKTtcbiAqXG4gKiAgICAgIFIubWFwT2JqSW5kZXhlZChwcmVwZW5kS2V5QW5kRG91YmxlLCB2YWx1ZXMpOyAvLz0+IHsgeDogJ3gyJywgeTogJ3k0JywgejogJ3o2JyB9XG4gKi9cbnZhciBtYXBPYmpJbmRleGVkID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gbWFwT2JqSW5kZXhlZChmbiwgb2JqKSB7XG4gIHJldHVybiBfcmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgIGFjY1trZXldID0gZm4ob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSwga2V5cyhvYmopKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbWFwT2JqSW5kZXhlZDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFRlc3RzIGEgcmVndWxhciBleHByZXNzaW9uIGFnYWluc3QgYSBTdHJpbmcuIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAqIHJldHVybiBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZXJlIGFyZSBubyBtYXRjaGVzLiBUaGlzIGRpZmZlcnMgZnJvbVxuICogW2BTdHJpbmcucHJvdG90eXBlLm1hdGNoYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL21hdGNoKVxuICogd2hpY2ggcmV0dXJucyBgbnVsbGAgd2hlbiB0aGVyZSBhcmUgbm8gbWF0Y2hlcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgUmVnRXhwIC0+IFN0cmluZyAtPiBbU3RyaW5nIHwgVW5kZWZpbmVkXVxuICogQHBhcmFtIHtSZWdFeHB9IHJ4IEEgcmVndWxhciBleHByZXNzaW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIG1hdGNoIGFnYWluc3RcbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBtYXRjaGVzIG9yIGVtcHR5IGFycmF5LlxuICogQHNlZSBSLnRlc3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1hdGNoKC8oW2Etel1hKS9nLCAnYmFuYW5hcycpOyAvLz0+IFsnYmEnLCAnbmEnLCAnbmEnXVxuICogICAgICBSLm1hdGNoKC9hLywgJ2InKTsgLy89PiBbXVxuICogICAgICBSLm1hdGNoKC9hLywgbnVsbCk7IC8vPT4gVHlwZUVycm9yOiBudWxsIGRvZXMgbm90IGhhdmUgYSBtZXRob2QgbmFtZWQgXCJtYXRjaFwiXG4gKi9cbnZhciBtYXRjaCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIG1hdGNoKHJ4LCBzdHIpIHtcbiAgcmV0dXJuIHN0ci5tYXRjaChyeCkgfHwgW107XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1hdGNoOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2lzSW50ZWdlciBmcm9tICcuL2ludGVybmFsL19pc0ludGVnZXInO1xuXG4vKipcbiAqIGBtYXRoTW9kYCBiZWhhdmVzIGxpa2UgdGhlIG1vZHVsbyBvcGVyYXRvciBzaG91bGQgbWF0aGVtYXRpY2FsbHksIHVubGlrZSB0aGVcbiAqIGAlYCBvcGVyYXRvciAoYW5kIGJ5IGV4dGVuc2lvbiwgW2BSLm1vZHVsb2BdKCNtb2R1bG8pKS4gU28gd2hpbGVcbiAqIGAtMTcgJSA1YCBpcyBgLTJgLCBgbWF0aE1vZCgtMTcsIDUpYCBpcyBgM2AuIGBtYXRoTW9kYCByZXF1aXJlcyBJbnRlZ2VyXG4gKiBhcmd1bWVudHMsIGFuZCByZXR1cm5zIE5hTiB3aGVuIHRoZSBtb2R1bHVzIGlzIHplcm8gb3IgbmVnYXRpdmUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMy4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IG0gVGhlIGRpdmlkZW5kLlxuICogQHBhcmFtIHtOdW1iZXJ9IHAgdGhlIG1vZHVsdXMuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGIgbW9kIGFgLlxuICogQHNlZSBSLm1vZHVsb1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWF0aE1vZCgtMTcsIDUpOyAgLy89PiAzXG4gKiAgICAgIFIubWF0aE1vZCgxNywgNSk7ICAgLy89PiAyXG4gKiAgICAgIFIubWF0aE1vZCgxNywgLTUpOyAgLy89PiBOYU5cbiAqICAgICAgUi5tYXRoTW9kKDE3LCAwKTsgICAvLz0+IE5hTlxuICogICAgICBSLm1hdGhNb2QoMTcuMiwgNSk7IC8vPT4gTmFOXG4gKiAgICAgIFIubWF0aE1vZCgxNywgNS4zKTsgLy89PiBOYU5cbiAqXG4gKiAgICAgIHZhciBjbG9jayA9IFIubWF0aE1vZChSLl9fLCAxMik7XG4gKiAgICAgIGNsb2NrKDE1KTsgLy89PiAzXG4gKiAgICAgIGNsb2NrKDI0KTsgLy89PiAwXG4gKlxuICogICAgICB2YXIgc2V2ZW50ZWVuTW9kID0gUi5tYXRoTW9kKDE3KTtcbiAqICAgICAgc2V2ZW50ZWVuTW9kKDMpOyAgLy89PiAyXG4gKiAgICAgIHNldmVudGVlbk1vZCg0KTsgIC8vPT4gMVxuICogICAgICBzZXZlbnRlZW5Nb2QoMTApOyAvLz0+IDdcbiAqL1xudmFyIG1hdGhNb2QgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBtYXRoTW9kKG0sIHApIHtcbiAgaWYgKCFfaXNJbnRlZ2VyKG0pKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuICBpZiAoIV9pc0ludGVnZXIocCkgfHwgcCA8IDEpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIHJldHVybiAobSAlIHAgKyBwKSAlIHA7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1hdGhNb2Q7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXJnZXIgb2YgaXRzIHR3byBhcmd1bWVudHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IGFcbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLm1heEJ5LCBSLm1pblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWF4KDc4OSwgMTIzKTsgLy89PiA3ODlcbiAqICAgICAgUi5tYXgoJ2EnLCAnYicpOyAvLz0+ICdiJ1xuICovXG52YXIgbWF4ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gbWF4KGEsIGIpIHtcbiAgcmV0dXJuIGIgPiBhID8gYiA6IGE7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1heDsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYW5kIHR3byB2YWx1ZXMsIGFuZCByZXR1cm5zIHdoaWNoZXZlciB2YWx1ZSBwcm9kdWNlcyB0aGVcbiAqIGxhcmdlciByZXN1bHQgd2hlbiBwYXNzZWQgdG8gdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjguMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBiID0+IChhIC0+IGIpIC0+IGEgLT4gYSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5tYXgsIFIubWluQnlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyAgc3F1YXJlIDo6IE51bWJlciAtPiBOdW1iZXJcbiAqICAgICAgdmFyIHNxdWFyZSA9IG4gPT4gbiAqIG47XG4gKlxuICogICAgICBSLm1heEJ5KHNxdWFyZSwgLTMsIDIpOyAvLz0+IC0zXG4gKlxuICogICAgICBSLnJlZHVjZShSLm1heEJ5KHNxdWFyZSksIDAsIFszLCAtNSwgNCwgMSwgLTJdKTsgLy89PiAtNVxuICogICAgICBSLnJlZHVjZShSLm1heEJ5KHNxdWFyZSksIDAsIFtdKTsgLy89PiAwXG4gKi9cbnZhciBtYXhCeSA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIG1heEJ5KGYsIGEsIGIpIHtcbiAgcmV0dXJuIGYoYikgPiBmKGEpID8gYiA6IGE7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1heEJ5OyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgc3VtIGZyb20gJy4vc3VtJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtZWFuIG9mIHRoZSBnaXZlbiBsaXN0IG9mIG51bWJlcnMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgW051bWJlcl0gLT4gTnVtYmVyXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAc2VlIFIubWVkaWFuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tZWFuKFsyLCA3LCA5XSk7IC8vPT4gNlxuICogICAgICBSLm1lYW4oW10pOyAvLz0+IE5hTlxuICovXG52YXIgbWVhbiA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIG1lYW4obGlzdCkge1xuICByZXR1cm4gc3VtKGxpc3QpIC8gbGlzdC5sZW5ndGg7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1lYW47IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBtZWFuIGZyb20gJy4vbWVhbic7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWVkaWFuIG9mIHRoZSBnaXZlbiBsaXN0IG9mIG51bWJlcnMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgW051bWJlcl0gLT4gTnVtYmVyXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAc2VlIFIubWVhblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWVkaWFuKFsyLCA5LCA3XSk7IC8vPT4gN1xuICogICAgICBSLm1lZGlhbihbNywgMiwgMTAsIDldKTsgLy89PiA4XG4gKiAgICAgIFIubWVkaWFuKFtdKTsgLy89PiBOYU5cbiAqL1xudmFyIG1lZGlhbiA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIG1lZGlhbihsaXN0KSB7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgdmFyIHdpZHRoID0gMiAtIGxlbiAlIDI7XG4gIHZhciBpZHggPSAobGVuIC0gd2lkdGgpIC8gMjtcbiAgcmV0dXJuIG1lYW4oQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgfSkuc2xpY2UoaWR4LCBpZHggKyB3aWR0aCkpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBtZWRpYW47IiwiaW1wb3J0IG1lbW9pemVXaXRoIGZyb20gJy4vbWVtb2l6ZVdpdGgnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZnVuY3Rpb24gdGhhdCwgd2hlbiBpbnZva2VkLCBjYWNoZXMgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmbmBcbiAqIGZvciBhIGdpdmVuIGFyZ3VtZW50IHNldCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZVxuICogbWVtb2l6ZWQgYGZuYCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50IHNldCB3aWxsIG5vdCByZXN1bHQgaW4gYW4gYWRkaXRpb25hbFxuICogY2FsbCB0byBgZm5gOyBpbnN0ZWFkLCB0aGUgY2FjaGVkIHJlc3VsdCBmb3IgdGhhdCBzZXQgb2YgYXJndW1lbnRzIHdpbGwgYmVcbiAqIHJldHVybmVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgqLi4uIC0+IGEpIC0+ICgqLi4uIC0+IGEpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWVtb2l6ZS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBNZW1vaXplZCB2ZXJzaW9uIG9mIGBmbmAuXG4gKiBAc2VlIFIubWVtb2l6ZVdpdGhcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHYwLjI1LjBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBsZXQgY291bnQgPSAwO1xuICogICAgICBjb25zdCBmYWN0b3JpYWwgPSBSLm1lbW9pemUobiA9PiB7XG4gKiAgICAgICAgY291bnQgKz0gMTtcbiAqICAgICAgICByZXR1cm4gUi5wcm9kdWN0KFIucmFuZ2UoMSwgbiArIDEpKTtcbiAqICAgICAgfSk7XG4gKiAgICAgIGZhY3RvcmlhbCg1KTsgLy89PiAxMjBcbiAqICAgICAgZmFjdG9yaWFsKDUpOyAvLz0+IDEyMFxuICogICAgICBmYWN0b3JpYWwoNSk7IC8vPT4gMTIwXG4gKiAgICAgIGNvdW50OyAvLz0+IDFcbiAqL1xudmFyIG1lbW9pemUgPSAvKiNfX1BVUkVfXyovbWVtb2l6ZVdpdGgoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdG9TdHJpbmcoYXJndW1lbnRzKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZTsiLCJpbXBvcnQgX2FyaXR5IGZyb20gJy4vaW50ZXJuYWwvX2FyaXR5JztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2hhcyBmcm9tICcuL2ludGVybmFsL19oYXMnO1xuXG4vKipcbiAqIEEgY3VzdG9taXNhYmxlIHZlcnNpb24gb2YgW2BSLm1lbW9pemVgXSgjbWVtb2l6ZSkuIGBtZW1vaXplV2l0aGAgdGFrZXMgYW5cbiAqIGFkZGl0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBnaXZlbiBhcmd1bWVudCBzZXQgYW5kIHVzZWQgdG9cbiAqIGNyZWF0ZSB0aGUgY2FjaGUga2V5IHVuZGVyIHdoaWNoIHRoZSByZXN1bHRzIG9mIHRoZSBmdW5jdGlvbiB0byBiZSBtZW1vaXplZFxuICogd2lsbCBiZSBzdG9yZWQuIENhcmUgbXVzdCBiZSB0YWtlbiB3aGVuIGltcGxlbWVudGluZyBrZXkgZ2VuZXJhdGlvbiB0byBhdm9pZFxuICogY2xhc2hlcyB0aGF0IG1heSBvdmVyd3JpdGUgcHJldmlvdXMgZW50cmllcyBlcnJvbmVvdXNseS5cbiAqXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjQuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgqLi4uIC0+IFN0cmluZykgLT4gKCouLi4gLT4gYSkgLT4gKCouLi4gLT4gYSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgY2FjaGUga2V5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1lbW9pemUuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gTWVtb2l6ZWQgdmVyc2lvbiBvZiBgZm5gLlxuICogQHNlZSBSLm1lbW9pemVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBsZXQgY291bnQgPSAwO1xuICogICAgICBjb25zdCBmYWN0b3JpYWwgPSBSLm1lbW9pemVXaXRoKFIuaWRlbnRpdHksIG4gPT4ge1xuICogICAgICAgIGNvdW50ICs9IDE7XG4gKiAgICAgICAgcmV0dXJuIFIucHJvZHVjdChSLnJhbmdlKDEsIG4gKyAxKSk7XG4gKiAgICAgIH0pO1xuICogICAgICBmYWN0b3JpYWwoNSk7IC8vPT4gMTIwXG4gKiAgICAgIGZhY3RvcmlhbCg1KTsgLy89PiAxMjBcbiAqICAgICAgZmFjdG9yaWFsKDUpOyAvLz0+IDEyMFxuICogICAgICBjb3VudDsgLy89PiAxXG4gKi9cbnZhciBtZW1vaXplV2l0aCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIG1lbW9pemVXaXRoKG1GbiwgZm4pIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBfYXJpdHkoZm4ubGVuZ3RoLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGtleSA9IG1Gbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICghX2hhcyhrZXksIGNhY2hlKSkge1xuICAgICAgY2FjaGVba2V5XSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZVtrZXldO1xuICB9KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZVdpdGg7IiwiaW1wb3J0IF9hc3NpZ24gZnJvbSAnLi9pbnRlcm5hbC9fYXNzaWduJztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgZmlyc3Qgb2JqZWN0IG1lcmdlZCB3aXRoXG4gKiB0aGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIHNlY29uZCBvYmplY3QuIElmIGEga2V5IGV4aXN0cyBpbiBib3RoIG9iamVjdHMsXG4gKiB0aGUgdmFsdWUgZnJvbSB0aGUgc2Vjb25kIG9iamVjdCB3aWxsIGJlIHVzZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtrOiB2fSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge09iamVjdH0gbFxuICogQHBhcmFtIHtPYmplY3R9IHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgUi5tZXJnZURlZXBSaWdodCwgUi5tZXJnZVdpdGgsIFIubWVyZ2VXaXRoS2V5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tZXJnZSh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogMTAgfSwgeyAnYWdlJzogNDAgfSk7XG4gKiAgICAgIC8vPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAqXG4gKiAgICAgIHZhciByZXNldFRvRGVmYXVsdCA9IFIubWVyZ2UoUi5fXywge3g6IDB9KTtcbiAqICAgICAgcmVzZXRUb0RlZmF1bHQoe3g6IDUsIHk6IDJ9KTsgLy89PiB7eDogMCwgeTogMn1cbiAqIEBzeW1iIFIubWVyZ2UoeyB4OiAxLCB5OiAyIH0sIHsgeTogNSwgejogMyB9KSA9IHsgeDogMSwgeTogNSwgejogMyB9XG4gKi9cbnZhciBtZXJnZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIG1lcmdlKGwsIHIpIHtcbiAgcmV0dXJuIF9hc3NpZ24oe30sIGwsIHIpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBtZXJnZTsiLCJpbXBvcnQgX2Fzc2lnbiBmcm9tICcuL2ludGVybmFsL19hc3NpZ24nO1xuaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcblxuLyoqXG4gKiBNZXJnZXMgYSBsaXN0IG9mIG9iamVjdHMgdG9nZXRoZXIgaW50byBvbmUgb2JqZWN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFt7azogdn1dIC0+IHtrOiB2fVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBBbiBhcnJheSBvZiBvYmplY3RzXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbWVyZ2VkIG9iamVjdC5cbiAqIEBzZWUgUi5yZWR1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1lcmdlQWxsKFt7Zm9vOjF9LHtiYXI6Mn0se2JhejozfV0pOyAvLz0+IHtmb286MSxiYXI6MixiYXo6M31cbiAqICAgICAgUi5tZXJnZUFsbChbe2ZvbzoxfSx7Zm9vOjJ9LHtiYXI6Mn1dKTsgLy89PiB7Zm9vOjIsYmFyOjJ9XG4gKiBAc3ltYiBSLm1lcmdlQWxsKFt7IHg6IDEgfSwgeyB5OiAyIH0sIHsgejogMyB9XSkgPSB7IHg6IDEsIHk6IDIsIHo6IDMgfVxuICovXG52YXIgbWVyZ2VBbGwgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBtZXJnZUFsbChsaXN0KSB7XG4gIHJldHVybiBfYXNzaWduLmFwcGx5KG51bGwsIFt7fV0uY29uY2F0KGxpc3QpKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbWVyZ2VBbGw7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBtZXJnZURlZXBXaXRoS2V5IGZyb20gJy4vbWVyZ2VEZWVwV2l0aEtleSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIGZpcnN0IG9iamVjdCBtZXJnZWQgd2l0aFxuICogdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBzZWNvbmQgb2JqZWN0LiBJZiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzOlxuICogLSBhbmQgYm90aCB2YWx1ZXMgYXJlIG9iamVjdHMsIHRoZSB0d28gdmFsdWVzIHdpbGwgYmUgcmVjdXJzaXZlbHkgbWVyZ2VkXG4gKiAtIG90aGVyd2lzZSB0aGUgdmFsdWUgZnJvbSB0aGUgZmlyc3Qgb2JqZWN0IHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHthfSAtPiB7YX0gLT4ge2F9XG4gKiBAcGFyYW0ge09iamVjdH0gbE9ialxuICogQHBhcmFtIHtPYmplY3R9IHJPYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgUi5tZXJnZSwgUi5tZXJnZURlZXBSaWdodCwgUi5tZXJnZURlZXBXaXRoLCBSLm1lcmdlRGVlcFdpdGhLZXlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1lcmdlRGVlcExlZnQoeyBuYW1lOiAnZnJlZCcsIGFnZTogMTAsIGNvbnRhY3Q6IHsgZW1haWw6ICdtb29AZXhhbXBsZS5jb20nIH19LFxuICogICAgICAgICAgICAgICAgICAgICAgeyBhZ2U6IDQwLCBjb250YWN0OiB7IGVtYWlsOiAnYmFhQGV4YW1wbGUuY29tJyB9fSk7XG4gKiAgICAgIC8vPT4geyBuYW1lOiAnZnJlZCcsIGFnZTogMTAsIGNvbnRhY3Q6IHsgZW1haWw6ICdtb29AZXhhbXBsZS5jb20nIH19XG4gKi9cbnZhciBtZXJnZURlZXBMZWZ0ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gbWVyZ2VEZWVwTGVmdChsT2JqLCByT2JqKSB7XG4gIHJldHVybiBtZXJnZURlZXBXaXRoS2V5KGZ1bmN0aW9uIChrLCBsVmFsLCByVmFsKSB7XG4gICAgcmV0dXJuIGxWYWw7XG4gIH0sIGxPYmosIHJPYmopO1xufSk7XG5leHBvcnQgZGVmYXVsdCBtZXJnZURlZXBMZWZ0OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgbWVyZ2VEZWVwV2l0aEtleSBmcm9tICcuL21lcmdlRGVlcFdpdGhLZXknO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBmaXJzdCBvYmplY3QgbWVyZ2VkIHdpdGhcbiAqIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgc2Vjb25kIG9iamVjdC4gSWYgYSBrZXkgZXhpc3RzIGluIGJvdGggb2JqZWN0czpcbiAqIC0gYW5kIGJvdGggdmFsdWVzIGFyZSBvYmplY3RzLCB0aGUgdHdvIHZhbHVlcyB3aWxsIGJlIHJlY3Vyc2l2ZWx5IG1lcmdlZFxuICogLSBvdGhlcndpc2UgdGhlIHZhbHVlIGZyb20gdGhlIHNlY29uZCBvYmplY3Qgd2lsbCBiZSB1c2VkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI0LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge2F9IC0+IHthfSAtPiB7YX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBsT2JqXG4gKiBAcGFyYW0ge09iamVjdH0gck9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBSLm1lcmdlLCBSLm1lcmdlRGVlcExlZnQsIFIubWVyZ2VEZWVwV2l0aCwgUi5tZXJnZURlZXBXaXRoS2V5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tZXJnZURlZXBSaWdodCh7IG5hbWU6ICdmcmVkJywgYWdlOiAxMCwgY29udGFjdDogeyBlbWFpbDogJ21vb0BleGFtcGxlLmNvbScgfX0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgeyBhZ2U6IDQwLCBjb250YWN0OiB7IGVtYWlsOiAnYmFhQGV4YW1wbGUuY29tJyB9fSk7XG4gKiAgICAgIC8vPT4geyBuYW1lOiAnZnJlZCcsIGFnZTogNDAsIGNvbnRhY3Q6IHsgZW1haWw6ICdiYWFAZXhhbXBsZS5jb20nIH19XG4gKi9cbnZhciBtZXJnZURlZXBSaWdodCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIG1lcmdlRGVlcFJpZ2h0KGxPYmosIHJPYmopIHtcbiAgcmV0dXJuIG1lcmdlRGVlcFdpdGhLZXkoZnVuY3Rpb24gKGssIGxWYWwsIHJWYWwpIHtcbiAgICByZXR1cm4gclZhbDtcbiAgfSwgbE9iaiwgck9iaik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1lcmdlRGVlcFJpZ2h0OyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgbWVyZ2VEZWVwV2l0aEtleSBmcm9tICcuL21lcmdlRGVlcFdpdGhLZXknO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSB0d28gcHJvdmlkZWQgb2JqZWN0cy5cbiAqIElmIGEga2V5IGV4aXN0cyBpbiBib3RoIG9iamVjdHM6XG4gKiAtIGFuZCBib3RoIGFzc29jaWF0ZWQgdmFsdWVzIGFyZSBhbHNvIG9iamVjdHMgdGhlbiB0aGUgdmFsdWVzIHdpbGwgYmVcbiAqICAgcmVjdXJzaXZlbHkgbWVyZ2VkLlxuICogLSBvdGhlcndpc2UgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGlzIGFwcGxpZWQgdG8gYXNzb2NpYXRlZCB2YWx1ZXMgdXNpbmcgdGhlXG4gKiAgIHJlc3VsdGluZyB2YWx1ZSBhcyB0aGUgbmV3IHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5LlxuICogSWYgYSBrZXkgb25seSBleGlzdHMgaW4gb25lIG9iamVjdCwgdGhlIHZhbHVlIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXlcbiAqIG9mIHRoZSByZXN1bHRpbmcgb2JqZWN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI0LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgKChhLCBhKSAtPiBhKSAtPiB7YX0gLT4ge2F9IC0+IHthfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsT2JqXG4gKiBAcGFyYW0ge09iamVjdH0gck9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBSLm1lcmdlV2l0aCwgUi5tZXJnZURlZXAsIFIubWVyZ2VEZWVwV2l0aEtleVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWVyZ2VEZWVwV2l0aChSLmNvbmNhdCxcbiAqICAgICAgICAgICAgICAgICAgICAgIHsgYTogdHJ1ZSwgYzogeyB2YWx1ZXM6IFsxMCwgMjBdIH19LFxuICogICAgICAgICAgICAgICAgICAgICAgeyBiOiB0cnVlLCBjOiB7IHZhbHVlczogWzE1LCAzNV0gfX0pO1xuICogICAgICAvLz0+IHsgYTogdHJ1ZSwgYjogdHJ1ZSwgYzogeyB2YWx1ZXM6IFsxMCwgMjAsIDE1LCAzNV0gfX1cbiAqL1xudmFyIG1lcmdlRGVlcFdpdGggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBtZXJnZURlZXBXaXRoKGZuLCBsT2JqLCByT2JqKSB7XG4gIHJldHVybiBtZXJnZURlZXBXaXRoS2V5KGZ1bmN0aW9uIChrLCBsVmFsLCByVmFsKSB7XG4gICAgcmV0dXJuIGZuKGxWYWwsIHJWYWwpO1xuICB9LCBsT2JqLCByT2JqKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbWVyZ2VEZWVwV2l0aDsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuaW1wb3J0IF9pc09iamVjdCBmcm9tICcuL2ludGVybmFsL19pc09iamVjdCc7XG5pbXBvcnQgbWVyZ2VXaXRoS2V5IGZyb20gJy4vbWVyZ2VXaXRoS2V5JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgdHdvIHByb3ZpZGVkIG9iamVjdHMuXG4gKiBJZiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzOlxuICogLSBhbmQgYm90aCBhc3NvY2lhdGVkIHZhbHVlcyBhcmUgYWxzbyBvYmplY3RzIHRoZW4gdGhlIHZhbHVlcyB3aWxsIGJlXG4gKiAgIHJlY3Vyc2l2ZWx5IG1lcmdlZC5cbiAqIC0gb3RoZXJ3aXNlIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSBrZXkgYW5kIGFzc29jaWF0ZWQgdmFsdWVzXG4gKiAgIHVzaW5nIHRoZSByZXN1bHRpbmcgdmFsdWUgYXMgdGhlIG5ldyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleS5cbiAqIElmIGEga2V5IG9ubHkgZXhpc3RzIGluIG9uZSBvYmplY3QsIHRoZSB2YWx1ZSB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5XG4gKiBvZiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgoU3RyaW5nLCBhLCBhKSAtPiBhKSAtPiB7YX0gLT4ge2F9IC0+IHthfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsT2JqXG4gKiBAcGFyYW0ge09iamVjdH0gck9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBSLm1lcmdlV2l0aEtleSwgUi5tZXJnZURlZXAsIFIubWVyZ2VEZWVwV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGxldCBjb25jYXRWYWx1ZXMgPSAoaywgbCwgcikgPT4gayA9PSAndmFsdWVzJyA/IFIuY29uY2F0KGwsIHIpIDogclxuICogICAgICBSLm1lcmdlRGVlcFdpdGhLZXkoY29uY2F0VmFsdWVzLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgeyBhOiB0cnVlLCBjOiB7IHRoaW5nOiAnZm9vJywgdmFsdWVzOiBbMTAsIDIwXSB9fSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHsgYjogdHJ1ZSwgYzogeyB0aGluZzogJ2JhcicsIHZhbHVlczogWzE1LCAzNV0gfX0pO1xuICogICAgICAvLz0+IHsgYTogdHJ1ZSwgYjogdHJ1ZSwgYzogeyB0aGluZzogJ2JhcicsIHZhbHVlczogWzEwLCAyMCwgMTUsIDM1XSB9fVxuICovXG52YXIgbWVyZ2VEZWVwV2l0aEtleSA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIG1lcmdlRGVlcFdpdGhLZXkoZm4sIGxPYmosIHJPYmopIHtcbiAgcmV0dXJuIG1lcmdlV2l0aEtleShmdW5jdGlvbiAoaywgbFZhbCwgclZhbCkge1xuICAgIGlmIChfaXNPYmplY3QobFZhbCkgJiYgX2lzT2JqZWN0KHJWYWwpKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEZWVwV2l0aEtleShmbiwgbFZhbCwgclZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmbihrLCBsVmFsLCByVmFsKTtcbiAgICB9XG4gIH0sIGxPYmosIHJPYmopO1xufSk7XG5leHBvcnQgZGVmYXVsdCBtZXJnZURlZXBXaXRoS2V5OyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgbWVyZ2VXaXRoS2V5IGZyb20gJy4vbWVyZ2VXaXRoS2V5JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgdHdvIHByb3ZpZGVkIG9iamVjdHMuIElmXG4gKiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aGUgdmFsdWVzXG4gKiBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSBpbiBlYWNoIG9iamVjdCwgd2l0aCB0aGUgcmVzdWx0IGJlaW5nIHVzZWQgYXMgdGhlXG4gKiB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSBpbiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgKChhLCBhKSAtPiBhKSAtPiB7YX0gLT4ge2F9IC0+IHthfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsXG4gKiBAcGFyYW0ge09iamVjdH0gclxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBSLm1lcmdlRGVlcFdpdGgsIFIubWVyZ2UsIFIubWVyZ2VXaXRoS2V5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tZXJnZVdpdGgoUi5jb25jYXQsXG4gKiAgICAgICAgICAgICAgICAgIHsgYTogdHJ1ZSwgdmFsdWVzOiBbMTAsIDIwXSB9LFxuICogICAgICAgICAgICAgICAgICB7IGI6IHRydWUsIHZhbHVlczogWzE1LCAzNV0gfSk7XG4gKiAgICAgIC8vPT4geyBhOiB0cnVlLCBiOiB0cnVlLCB2YWx1ZXM6IFsxMCwgMjAsIDE1LCAzNV0gfVxuICovXG52YXIgbWVyZ2VXaXRoID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gbWVyZ2VXaXRoKGZuLCBsLCByKSB7XG4gIHJldHVybiBtZXJnZVdpdGhLZXkoZnVuY3Rpb24gKF8sIF9sLCBfcikge1xuICAgIHJldHVybiBmbihfbCwgX3IpO1xuICB9LCBsLCByKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbWVyZ2VXaXRoOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgX2hhcyBmcm9tICcuL2ludGVybmFsL19oYXMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSB0d28gcHJvdmlkZWQgb2JqZWN0cy4gSWZcbiAqIGEga2V5IGV4aXN0cyBpbiBib3RoIG9iamVjdHMsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSBrZXlcbiAqIGFuZCB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5IGluIGVhY2ggb2JqZWN0LCB3aXRoIHRoZSByZXN1bHQgYmVpbmdcbiAqIHVzZWQgYXMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5IGluIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyAoKFN0cmluZywgYSwgYSkgLT4gYSkgLT4ge2F9IC0+IHthfSAtPiB7YX1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gbFxuICogQHBhcmFtIHtPYmplY3R9IHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgUi5tZXJnZURlZXBXaXRoS2V5LCBSLm1lcmdlLCBSLm1lcmdlV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGxldCBjb25jYXRWYWx1ZXMgPSAoaywgbCwgcikgPT4gayA9PSAndmFsdWVzJyA/IFIuY29uY2F0KGwsIHIpIDogclxuICogICAgICBSLm1lcmdlV2l0aEtleShjb25jYXRWYWx1ZXMsXG4gKiAgICAgICAgICAgICAgICAgICAgIHsgYTogdHJ1ZSwgdGhpbmc6ICdmb28nLCB2YWx1ZXM6IFsxMCwgMjBdIH0sXG4gKiAgICAgICAgICAgICAgICAgICAgIHsgYjogdHJ1ZSwgdGhpbmc6ICdiYXInLCB2YWx1ZXM6IFsxNSwgMzVdIH0pO1xuICogICAgICAvLz0+IHsgYTogdHJ1ZSwgYjogdHJ1ZSwgdGhpbmc6ICdiYXInLCB2YWx1ZXM6IFsxMCwgMjAsIDE1LCAzNV0gfVxuICogQHN5bWIgUi5tZXJnZVdpdGhLZXkoZiwgeyB4OiAxLCB5OiAyIH0sIHsgeTogNSwgejogMyB9KSA9IHsgeDogMSwgeTogZigneScsIDIsIDUpLCB6OiAzIH1cbiAqL1xudmFyIG1lcmdlV2l0aEtleSA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIG1lcmdlV2l0aEtleShmbiwgbCwgcikge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBrO1xuXG4gIGZvciAoayBpbiBsKSB7XG4gICAgaWYgKF9oYXMoaywgbCkpIHtcbiAgICAgIHJlc3VsdFtrXSA9IF9oYXMoaywgcikgPyBmbihrLCBsW2tdLCByW2tdKSA6IGxba107XG4gICAgfVxuICB9XG5cbiAgZm9yIChrIGluIHIpIHtcbiAgICBpZiAoX2hhcyhrLCByKSAmJiAhX2hhcyhrLCByZXN1bHQpKSB7XG4gICAgICByZXN1bHRba10gPSByW2tdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1lcmdlV2l0aEtleTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHNtYWxsZXIgb2YgaXRzIHR3byBhcmd1bWVudHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IGFcbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLm1pbkJ5LCBSLm1heFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWluKDc4OSwgMTIzKTsgLy89PiAxMjNcbiAqICAgICAgUi5taW4oJ2EnLCAnYicpOyAvLz0+ICdhJ1xuICovXG52YXIgbWluID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gbWluKGEsIGIpIHtcbiAgcmV0dXJuIGIgPCBhID8gYiA6IGE7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG1pbjsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYW5kIHR3byB2YWx1ZXMsIGFuZCByZXR1cm5zIHdoaWNoZXZlciB2YWx1ZSBwcm9kdWNlcyB0aGVcbiAqIHNtYWxsZXIgcmVzdWx0IHdoZW4gcGFzc2VkIHRvIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYiA9PiAoYSAtPiBiKSAtPiBhIC0+IGEgLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIubWluLCBSLm1heEJ5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gIHNxdWFyZSA6OiBOdW1iZXIgLT4gTnVtYmVyXG4gKiAgICAgIHZhciBzcXVhcmUgPSBuID0+IG4gKiBuO1xuICpcbiAqICAgICAgUi5taW5CeShzcXVhcmUsIC0zLCAyKTsgLy89PiAyXG4gKlxuICogICAgICBSLnJlZHVjZShSLm1pbkJ5KHNxdWFyZSksIEluZmluaXR5LCBbMywgLTUsIDQsIDEsIC0yXSk7IC8vPT4gMVxuICogICAgICBSLnJlZHVjZShSLm1pbkJ5KHNxdWFyZSksIEluZmluaXR5LCBbXSk7IC8vPT4gSW5maW5pdHlcbiAqL1xudmFyIG1pbkJ5ID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gbWluQnkoZiwgYSwgYikge1xuICByZXR1cm4gZihiKSA8IGYoYSkgPyBiIDogYTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbWluQnk7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBEaXZpZGVzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgYnkgdGhlIHNlY29uZCBhbmQgcmV0dXJucyB0aGUgcmVtYWluZGVyLiBOb3RlXG4gKiB0aGF0IHRoaXMgZnVuY3Rpb24gcHJlc2VydmVzIHRoZSBKYXZhU2NyaXB0LXN0eWxlIGJlaGF2aW9yIGZvciBtb2R1bG8uIEZvclxuICogbWF0aGVtYXRpY2FsIG1vZHVsbyBzZWUgW2BtYXRoTW9kYF0oI21hdGhNb2QpLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMVxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSB2YWx1ZSB0byB0aGUgZGl2aWRlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHBzZXVkby1tb2R1bHVzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGIgJSBhYC5cbiAqIEBzZWUgUi5tYXRoTW9kXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tb2R1bG8oMTcsIDMpOyAvLz0+IDJcbiAqICAgICAgLy8gSlMgYmVoYXZpb3I6XG4gKiAgICAgIFIubW9kdWxvKC0xNywgMyk7IC8vPT4gLTJcbiAqICAgICAgUi5tb2R1bG8oMTcsIC0zKTsgLy89PiAyXG4gKlxuICogICAgICB2YXIgaXNPZGQgPSBSLm1vZHVsbyhSLl9fLCAyKTtcbiAqICAgICAgaXNPZGQoNDIpOyAvLz0+IDBcbiAqICAgICAgaXNPZGQoMjEpOyAvLz0+IDFcbiAqL1xudmFyIG1vZHVsbyA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIG1vZHVsbyhhLCBiKSB7XG4gIHJldHVybiBhICUgYjtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbW9kdWxvOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbnVtYmVycy4gRXF1aXZhbGVudCB0byBgYSAqIGJgIGJ1dCBjdXJyaWVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgdmFsdWUuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGEgKiBiYC5cbiAqIEBzZWUgUi5kaXZpZGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZG91YmxlID0gUi5tdWx0aXBseSgyKTtcbiAqICAgICAgdmFyIHRyaXBsZSA9IFIubXVsdGlwbHkoMyk7XG4gKiAgICAgIGRvdWJsZSgzKTsgICAgICAgLy89PiAgNlxuICogICAgICB0cmlwbGUoNCk7ICAgICAgIC8vPT4gMTJcbiAqICAgICAgUi5tdWx0aXBseSgyLCA1KTsgIC8vPT4gMTBcbiAqL1xudmFyIG11bHRpcGx5ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikge1xuICByZXR1cm4gYSAqIGI7XG59KTtcbmV4cG9ydCBkZWZhdWx0IG11bHRpcGx5OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiBvZiBhbnkgYXJpdHkgKGluY2x1ZGluZyBudWxsYXJ5KSBpbiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0c1xuICogZXhhY3RseSBgbmAgcGFyYW1ldGVycy4gQW55IGV4dHJhbmVvdXMgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlXG4gKiBzdXBwbGllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBOdW1iZXIgLT4gKCogLT4gYSkgLT4gKCogLT4gYSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBkZXNpcmVkIGFyaXR5IG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyBgZm5gLiBUaGUgbmV3IGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgb2ZcbiAqICAgICAgICAgYXJpdHkgYG5gLlxuICogQHNlZSBSLmJpbmFyeSwgUi51bmFyeVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB0YWtlc1R3b0FyZ3MgPSAoYSwgYikgPT4gW2EsIGJdO1xuICpcbiAqICAgICAgdGFrZXNUd29BcmdzLmxlbmd0aDsgLy89PiAyXG4gKiAgICAgIHRha2VzVHdvQXJncygxLCAyKTsgLy89PiBbMSwgMl1cbiAqXG4gKiAgICAgIHZhciB0YWtlc09uZUFyZyA9IFIubkFyeSgxLCB0YWtlc1R3b0FyZ3MpO1xuICogICAgICB0YWtlc09uZUFyZy5sZW5ndGg7IC8vPT4gMVxuICogICAgICAvLyBPbmx5IGBuYCBhcmd1bWVudHMgYXJlIHBhc3NlZCB0byB0aGUgd3JhcHBlZCBmdW5jdGlvblxuICogICAgICB0YWtlc09uZUFyZygxLCAyKTsgLy89PiBbMSwgdW5kZWZpbmVkXVxuICogQHN5bWIgUi5uQXJ5KDAsIGYpKGEsIGIpID0gZigpXG4gKiBAc3ltYiBSLm5BcnkoMSwgZikoYSwgYikgPSBmKGEpXG4gKiBAc3ltYiBSLm5BcnkoMiwgZikoYSwgYikgPSBmKGEsIGIpXG4gKi9cbnZhciBuQXJ5ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gbkFyeShuLCBmbikge1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzKTtcbiAgICAgIH07XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCk7XG4gICAgICB9O1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSk7XG4gICAgICB9O1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMikge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyKTtcbiAgICAgIH07XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMykge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMyk7XG4gICAgICB9O1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgICB9O1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgICAgIH07XG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNikge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNik7XG4gICAgICB9O1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNyk7XG4gICAgICB9O1xuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4KTtcbiAgICAgIH07XG4gICAgY2FzZSAxMDpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpO1xuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBuQXJ5IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciBubyBncmVhdGVyIHRoYW4gdGVuJyk7XG4gIH1cbn0pO1xuZXhwb3J0IGRlZmF1bHQgbkFyeTsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuXG4vKipcbiAqIE5lZ2F0ZXMgaXRzIGFyZ3VtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm5lZ2F0ZSg0Mik7IC8vPT4gLTQyXG4gKi9cbnZhciBuZWdhdGUgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBuZWdhdGUobikge1xuICByZXR1cm4gLW47XG59KTtcbmV4cG9ydCBkZWZhdWx0IG5lZ2F0ZTsiLCJpbXBvcnQgX2NvbXBsZW1lbnQgZnJvbSAnLi9pbnRlcm5hbC9fY29tcGxlbWVudCc7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfeGFueSBmcm9tICcuL2ludGVybmFsL194YW55JztcbmltcG9ydCBhbnkgZnJvbSAnLi9hbnknO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIG5vIGVsZW1lbnRzIG9mIHRoZSBsaXN0IG1hdGNoIHRoZSBwcmVkaWNhdGUsIGBmYWxzZWBcbiAqIG90aGVyd2lzZS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgYW55YCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcmVkaWNhdGUgaXMgbm90IHNhdGlzZmllZCBieSBldmVyeSBlbGVtZW50LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIEBzZWUgUi5hbGwsIFIuYW55XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGlzRXZlbiA9IG4gPT4gbiAlIDIgPT09IDA7XG4gKiAgICAgIHZhciBpc09kZCA9IG4gPT4gbiAlIDIgPT09IDE7XG4gKlxuICogICAgICBSLm5vbmUoaXNFdmVuLCBbMSwgMywgNSwgNywgOSwgMTFdKTsgLy89PiB0cnVlXG4gKiAgICAgIFIubm9uZShpc09kZCwgWzEsIDMsIDUsIDcsIDgsIDExXSk7IC8vPT4gZmFsc2VcbiAqL1xudmFyIG5vbmUgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19jb21wbGVtZW50KCAvKiNfX1BVUkVfXyovX2Rpc3BhdGNoYWJsZShbJ2FueSddLCBfeGFueSwgYW55KSkpO1xuZXhwb3J0IGRlZmF1bHQgbm9uZTsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBgIWAgb2YgaXRzIGFyZ3VtZW50LiBJdCB3aWxsIHJldHVybiBgdHJ1ZWAgd2hlblxuICogcGFzc2VkIGZhbHNlLXkgdmFsdWUsIGFuZCBgZmFsc2VgIHdoZW4gcGFzc2VkIGEgdHJ1dGgteSBvbmUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKiAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IGEgYW55IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0aGUgbG9naWNhbCBpbnZlcnNlIG9mIHBhc3NlZCBhcmd1bWVudC5cbiAqIEBzZWUgUi5jb21wbGVtZW50XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5ub3QodHJ1ZSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5ub3QoZmFsc2UpOyAvLz0+IHRydWVcbiAqICAgICAgUi5ub3QoMCk7IC8vPT4gdHJ1ZVxuICogICAgICBSLm5vdCgxKTsgLy89PiBmYWxzZVxuICovXG52YXIgbm90ID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gbm90KGEpIHtcbiAgcmV0dXJuICFhO1xufSk7XG5leHBvcnQgZGVmYXVsdCBub3Q7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBfaXNTdHJpbmcgZnJvbSAnLi9pbnRlcm5hbC9faXNTdHJpbmcnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZy4gSWYgbiBpcyBuZWdhdGl2ZSB0aGVcbiAqIGVsZW1lbnQgYXQgaW5kZXggbGVuZ3RoICsgbiBpcyByZXR1cm5lZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gYSB8IFVuZGVmaW5lZFxuICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBsaXN0ID0gWydmb28nLCAnYmFyJywgJ2JheicsICdxdXV4J107XG4gKiAgICAgIFIubnRoKDEsIGxpc3QpOyAvLz0+ICdiYXInXG4gKiAgICAgIFIubnRoKC0xLCBsaXN0KTsgLy89PiAncXV1eCdcbiAqICAgICAgUi5udGgoLTk5LCBsaXN0KTsgLy89PiB1bmRlZmluZWRcbiAqXG4gKiAgICAgIFIubnRoKDIsICdhYmMnKTsgLy89PiAnYydcbiAqICAgICAgUi5udGgoMywgJ2FiYycpOyAvLz0+ICcnXG4gKiBAc3ltYiBSLm50aCgtMSwgW2EsIGIsIGNdKSA9IGNcbiAqIEBzeW1iIFIubnRoKDAsIFthLCBiLCBjXSkgPSBhXG4gKiBAc3ltYiBSLm50aCgxLCBbYSwgYiwgY10pID0gYlxuICovXG52YXIgbnRoID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gbnRoKG9mZnNldCwgbGlzdCkge1xuICB2YXIgaWR4ID0gb2Zmc2V0IDwgMCA/IGxpc3QubGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0O1xuICByZXR1cm4gX2lzU3RyaW5nKGxpc3QpID8gbGlzdC5jaGFyQXQoaWR4KSA6IGxpc3RbaWR4XTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgbnRoOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgY3VycnlOIGZyb20gJy4vY3VycnlOJztcbmltcG9ydCBudGggZnJvbSAnLi9udGgnO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGl0cyBudGggYXJndW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgTnVtYmVyIC0+ICouLi4gLT4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubnRoQXJnKDEpKCdhJywgJ2InLCAnYycpOyAvLz0+ICdiJ1xuICogICAgICBSLm50aEFyZygtMSkoJ2EnLCAnYicsICdjJyk7IC8vPT4gJ2MnXG4gKiBAc3ltYiBSLm50aEFyZygtMSkoYSwgYiwgYykgPSBjXG4gKiBAc3ltYiBSLm50aEFyZygwKShhLCBiLCBjKSA9IGFcbiAqIEBzeW1iIFIubnRoQXJnKDEpKGEsIGIsIGMpID0gYlxuICovXG52YXIgbnRoQXJnID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gbnRoQXJnKG4pIHtcbiAgdmFyIGFyaXR5ID0gbiA8IDAgPyAxIDogbiArIDE7XG4gIHJldHVybiBjdXJyeU4oYXJpdHksIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnRoKG4sIGFyZ3VtZW50cyk7XG4gIH0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBudGhBcmc7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLyoqXG4gKiBgb2AgaXMgYSBjdXJyaWVkIGNvbXBvc2l0aW9uIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHVuYXJ5IGZ1bmN0aW9uLlxuICogTGlrZSBbYGNvbXBvc2VgXSgjY29tcG9zZSksIGBvYCBwZXJmb3JtcyByaWdodC10by1sZWZ0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLlxuICogVW5saWtlIFtgY29tcG9zZWBdKCNjb21wb3NlKSwgdGhlIHJpZ2h0bW9zdCBmdW5jdGlvbiBwYXNzZWQgdG8gYG9gIHdpbGwgYmVcbiAqIGludm9rZWQgd2l0aCBvbmx5IG9uZSBhcmd1bWVudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKGIgLT4gYykgLT4gKGEgLT4gYikgLT4gYSAtPiBjXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5jb21wb3NlLCBSLnBpcGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgY2xhc3N5R3JlZXRpbmcgPSBuYW1lID0+IFwiVGhlIG5hbWUncyBcIiArIG5hbWUubGFzdCArIFwiLCBcIiArIG5hbWUuZmlyc3QgKyBcIiBcIiArIG5hbWUubGFzdFxuICogICAgICB2YXIgeWVsbEdyZWV0aW5nID0gUi5vKFIudG9VcHBlciwgY2xhc3N5R3JlZXRpbmcpO1xuICogICAgICB5ZWxsR3JlZXRpbmcoe2ZpcnN0OiAnSmFtZXMnLCBsYXN0OiAnQm9uZCd9KTsgLy89PiBcIlRIRSBOQU1FJ1MgQk9ORCwgSkFNRVMgQk9ORFwiXG4gKlxuICogICAgICBSLm8oUi5tdWx0aXBseSgxMCksIFIuYWRkKDEwKSkoLTQpIC8vPT4gNjBcbiAqXG4gKiBAc3ltYiBSLm8oZiwgZywgeCkgPSBmKGcoeCkpXG4gKi9cbnZhciBvID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gbyhmLCBnLCB4KSB7XG4gIHJldHVybiBmKGcoeCkpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBvOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29udGFpbmluZyBhIHNpbmdsZSBrZXk6dmFsdWUgcGFpci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIFN0cmluZyAtPiBhIC0+IHtTdHJpbmc6YX1cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc2VlIFIucGFpclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBtYXRjaFBocmFzZXMgPSBSLmNvbXBvc2UoXG4gKiAgICAgICAgUi5vYmpPZignbXVzdCcpLFxuICogICAgICAgIFIubWFwKFIub2JqT2YoJ21hdGNoX3BocmFzZScpKVxuICogICAgICApO1xuICogICAgICBtYXRjaFBocmFzZXMoWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiB7bXVzdDogW3ttYXRjaF9waHJhc2U6ICdmb28nfSwge21hdGNoX3BocmFzZTogJ2Jhcid9LCB7bWF0Y2hfcGhyYXNlOiAnYmF6J31dfVxuICovXG52YXIgb2JqT2YgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBvYmpPZihrZXksIHZhbCkge1xuICB2YXIgb2JqID0ge307XG4gIG9ialtrZXldID0gdmFsO1xuICByZXR1cm4gb2JqO1xufSk7XG5leHBvcnQgZGVmYXVsdCBvYmpPZjsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IF9vZiBmcm9tICcuL2ludGVybmFsL19vZic7XG5cbi8qKlxuICogUmV0dXJucyBhIHNpbmdsZXRvbiBhcnJheSBjb250YWluaW5nIHRoZSB2YWx1ZSBwcm92aWRlZC5cbiAqXG4gKiBOb3RlIHRoaXMgYG9mYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgRVM2IGBvZmA7IFNlZVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvb2ZcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBhIC0+IFthXVxuICogQHBhcmFtIHsqfSB4IGFueSB2YWx1ZVxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IHdyYXBwaW5nIGB4YC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm9mKG51bGwpOyAvLz0+IFtudWxsXVxuICogICAgICBSLm9mKFs0Ml0pOyAvLz0+IFtbNDJdXVxuICovXG52YXIgb2YgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShfb2YpO1xuZXhwb3J0IGRlZmF1bHQgb2Y7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgcGFydGlhbCBjb3B5IG9mIGFuIG9iamVjdCBvbWl0dGluZyB0aGUga2V5cyBzcGVjaWZpZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIFtTdHJpbmddIC0+IHtTdHJpbmc6ICp9IC0+IHtTdHJpbmc6ICp9XG4gKiBAcGFyYW0ge0FycmF5fSBuYW1lcyBhbiBhcnJheSBvZiBTdHJpbmcgcHJvcGVydHkgbmFtZXMgdG8gb21pdCBmcm9tIHRoZSBuZXcgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY29weSBmcm9tXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZnJvbSBgbmFtZXNgIG5vdCBvbiBpdC5cbiAqIEBzZWUgUi5waWNrXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5vbWl0KFsnYScsICdkJ10sIHthOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSk7IC8vPT4ge2I6IDIsIGM6IDN9XG4gKi9cbnZhciBvbWl0ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gb21pdChuYW1lcywgb2JqKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGluZGV4ID0ge307XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbmFtZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpbmRleFtuYW1lc1tpZHhdXSA9IDE7XG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIGlmICghaW5kZXguaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgb21pdDsiLCJpbXBvcnQgX2FyaXR5IGZyb20gJy4vaW50ZXJuYWwvX2FyaXR5JztcbmltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5cbi8qKlxuICogQWNjZXB0cyBhIGZ1bmN0aW9uIGBmbmAgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGd1YXJkcyBpbnZvY2F0aW9uIG9mXG4gKiBgZm5gIHN1Y2ggdGhhdCBgZm5gIGNhbiBvbmx5IGV2ZXIgYmUgY2FsbGVkIG9uY2UsIG5vIG1hdHRlciBob3cgbWFueSB0aW1lc1xuICogdGhlIHJldHVybmVkIGZ1bmN0aW9uIGlzIGludm9rZWQuIFRoZSBmaXJzdCB2YWx1ZSBjYWxjdWxhdGVkIGlzIHJldHVybmVkIGluXG4gKiBzdWJzZXF1ZW50IGludm9jYXRpb25zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIChhLi4uIC0+IGIpIC0+IChhLi4uIC0+IGIpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcCBpbiBhIGNhbGwtb25seS1vbmNlIHdyYXBwZXIuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHdyYXBwZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGFkZE9uZU9uY2UgPSBSLm9uY2UoeCA9PiB4ICsgMSk7XG4gKiAgICAgIGFkZE9uZU9uY2UoMTApOyAvLz0+IDExXG4gKiAgICAgIGFkZE9uZU9uY2UoYWRkT25lT25jZSg1MCkpOyAvLz0+IDExXG4gKi9cbnZhciBvbmNlID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gb25jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHZhciByZXN1bHQ7XG4gIHJldHVybiBfYXJpdHkoZm4ubGVuZ3RoLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBvbmNlOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgb25lIG9yIGJvdGggb2YgaXRzIGFyZ3VtZW50cyBhcmUgYHRydWVgLiBSZXR1cm5zIGBmYWxzZWBcbiAqIGlmIGJvdGggYXJndW1lbnRzIGFyZSBgZmFsc2VgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIGEgLT4gYiAtPiBhIHwgYlxuICogQHBhcmFtIHtBbnl9IGFcbiAqIEBwYXJhbSB7QW55fSBiXG4gKiBAcmV0dXJuIHtBbnl9IHRoZSBmaXJzdCBhcmd1bWVudCBpZiB0cnV0aHksIG90aGVyd2lzZSB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICogQHNlZSBSLmVpdGhlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIub3IodHJ1ZSwgdHJ1ZSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLm9yKHRydWUsIGZhbHNlKTsgLy89PiB0cnVlXG4gKiAgICAgIFIub3IoZmFsc2UsIHRydWUpOyAvLz0+IHRydWVcbiAqICAgICAgUi5vcihmYWxzZSwgZmFsc2UpOyAvLz0+IGZhbHNlXG4gKi9cbnZhciBvciA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIG9yKGEsIGIpIHtcbiAgcmV0dXJuIGEgfHwgYjtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgb3I7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLy8gYElkZW50aXR5YCBpcyBhIGZ1bmN0b3IgdGhhdCBob2xkcyBhIHNpbmdsZSB2YWx1ZSwgd2hlcmUgYG1hcGAgc2ltcGx5XG4vLyB0cmFuc2Zvcm1zIHRoZSBoZWxkIHZhbHVlIHdpdGggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxudmFyIElkZW50aXR5ID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHgsIG1hcDogZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBJZGVudGl0eShmKHgpKTtcbiAgICB9IH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBcInNldHRpbmdcIiB0aGUgcG9ydGlvbiBvZiB0aGUgZ2l2ZW4gZGF0YSBzdHJ1Y3R1cmVcbiAqIGZvY3VzZWQgYnkgdGhlIGdpdmVuIGxlbnMgdG8gdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG9cbiAqIHRoZSBmb2N1c2VkIHZhbHVlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gKiBAc2lnIExlbnMgcyBhIC0+IChhIC0+IGEpIC0+IHMgLT4gc1xuICogQHBhcmFtIHtMZW5zfSBsZW5zXG4gKiBAcGFyYW0geyp9IHZcbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5wcm9wLCBSLmxlbnNJbmRleCwgUi5sZW5zUHJvcFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBoZWFkTGVucyA9IFIubGVuc0luZGV4KDApO1xuICpcbiAqICAgICAgUi5vdmVyKGhlYWRMZW5zLCBSLnRvVXBwZXIsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydGT08nLCAnYmFyJywgJ2JheiddXG4gKi9cbnZhciBvdmVyID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gb3ZlcihsZW5zLCBmLCB4KSB7XG4gIC8vIFRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgZ2V0dGVyIGZ1bmN0aW9uIGlzIGZpcnN0IHRyYW5zZm9ybWVkIHdpdGggYGZgLFxuICAvLyB0aGVuIHNldCBhcyB0aGUgdmFsdWUgb2YgYW4gYElkZW50aXR5YC4gVGhpcyBpcyB0aGVuIG1hcHBlZCBvdmVyIHdpdGggdGhlXG4gIC8vIHNldHRlciBmdW5jdGlvbiBvZiB0aGUgbGVucy5cbiAgcmV0dXJuIGxlbnMoZnVuY3Rpb24gKHkpIHtcbiAgICByZXR1cm4gSWRlbnRpdHkoZih5KSk7XG4gIH0pKHgpLnZhbHVlO1xufSk7XG5leHBvcnQgZGVmYXVsdCBvdmVyOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogVGFrZXMgdHdvIGFyZ3VtZW50cywgYGZzdGAgYW5kIGBzbmRgLCBhbmQgcmV0dXJucyBgW2ZzdCwgc25kXWAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTguMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiBiIC0+IChhLGIpXG4gKiBAcGFyYW0geyp9IGZzdFxuICogQHBhcmFtIHsqfSBzbmRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHNlZSBSLm9iak9mLCBSLm9mXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wYWlyKCdmb28nLCAnYmFyJyk7IC8vPT4gWydmb28nLCAnYmFyJ11cbiAqL1xudmFyIHBhaXIgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBwYWlyKGZzdCwgc25kKSB7XG4gIHJldHVybiBbZnN0LCBzbmRdO1xufSk7XG5leHBvcnQgZGVmYXVsdCBwYWlyOyIsImltcG9ydCBfY29uY2F0IGZyb20gJy4vaW50ZXJuYWwvX2NvbmNhdCc7XG5pbXBvcnQgX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yIGZyb20gJy4vaW50ZXJuYWwvX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yJztcblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGBmYCBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cywgYW5kIHJldHVybnMgYSBmdW5jdGlvbiBgZ2AuXG4gKiBXaGVuIGFwcGxpZWQsIGBnYCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYGZgIHRvIHRoZSBhcmd1bWVudHNcbiAqIHByb3ZpZGVkIGluaXRpYWxseSBmb2xsb3dlZCBieSB0aGUgYXJndW1lbnRzIHByb3ZpZGVkIHRvIGBnYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKChhLCBiLCBjLCAuLi4sIG4pIC0+IHgpIC0+IFthLCBiLCBjLCAuLi5dIC0+ICgoZCwgZSwgZiwgLi4uLCBuKSAtPiB4KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIucGFydGlhbFJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG11bHRpcGx5MiA9IChhLCBiKSA9PiBhICogYjtcbiAqICAgICAgdmFyIGRvdWJsZSA9IFIucGFydGlhbChtdWx0aXBseTIsIFsyXSk7XG4gKiAgICAgIGRvdWJsZSgyKTsgLy89PiA0XG4gKlxuICogICAgICB2YXIgZ3JlZXQgPSAoc2FsdXRhdGlvbiwgdGl0bGUsIGZpcnN0TmFtZSwgbGFzdE5hbWUpID0+XG4gKiAgICAgICAgc2FsdXRhdGlvbiArICcsICcgKyB0aXRsZSArICcgJyArIGZpcnN0TmFtZSArICcgJyArIGxhc3ROYW1lICsgJyEnO1xuICpcbiAqICAgICAgdmFyIHNheUhlbGxvID0gUi5wYXJ0aWFsKGdyZWV0LCBbJ0hlbGxvJ10pO1xuICogICAgICB2YXIgc2F5SGVsbG9Ub01zID0gUi5wYXJ0aWFsKHNheUhlbGxvLCBbJ01zLiddKTtcbiAqICAgICAgc2F5SGVsbG9Ub01zKCdKYW5lJywgJ0pvbmVzJyk7IC8vPT4gJ0hlbGxvLCBNcy4gSmFuZSBKb25lcyEnXG4gKiBAc3ltYiBSLnBhcnRpYWwoZiwgW2EsIGJdKShjLCBkKSA9IGYoYSwgYiwgYywgZClcbiAqL1xudmFyIHBhcnRpYWwgPSAvKiNfX1BVUkVfXyovX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yKF9jb25jYXQpO1xuZXhwb3J0IGRlZmF1bHQgcGFydGlhbDsiLCJpbXBvcnQgX2NvbmNhdCBmcm9tICcuL2ludGVybmFsL19jb25jYXQnO1xuaW1wb3J0IF9jcmVhdGVQYXJ0aWFsQXBwbGljYXRvciBmcm9tICcuL2ludGVybmFsL19jcmVhdGVQYXJ0aWFsQXBwbGljYXRvcic7XG5pbXBvcnQgZmxpcCBmcm9tICcuL2ZsaXAnO1xuXG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYGZgIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzLCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIGBnYC5cbiAqIFdoZW4gYXBwbGllZCwgYGdgIHJldHVybnMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgZmAgdG8gdGhlIGFyZ3VtZW50c1xuICogcHJvdmlkZWQgdG8gYGdgIGZvbGxvd2VkIGJ5IHRoZSBhcmd1bWVudHMgcHJvdmlkZWQgaW5pdGlhbGx5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKGEsIGIsIGMsIC4uLiwgbikgLT4geCkgLT4gW2QsIGUsIGYsIC4uLiwgbl0gLT4gKChhLCBiLCBjLCAuLi4pIC0+IHgpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5wYXJ0aWFsXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGdyZWV0ID0gKHNhbHV0YXRpb24sIHRpdGxlLCBmaXJzdE5hbWUsIGxhc3ROYW1lKSA9PlxuICogICAgICAgIHNhbHV0YXRpb24gKyAnLCAnICsgdGl0bGUgKyAnICcgKyBmaXJzdE5hbWUgKyAnICcgKyBsYXN0TmFtZSArICchJztcbiAqXG4gKiAgICAgIHZhciBncmVldE1zSmFuZUpvbmVzID0gUi5wYXJ0aWFsUmlnaHQoZ3JlZXQsIFsnTXMuJywgJ0phbmUnLCAnSm9uZXMnXSk7XG4gKlxuICogICAgICBncmVldE1zSmFuZUpvbmVzKCdIZWxsbycpOyAvLz0+ICdIZWxsbywgTXMuIEphbmUgSm9uZXMhJ1xuICogQHN5bWIgUi5wYXJ0aWFsUmlnaHQoZiwgW2EsIGJdKShjLCBkKSA9IGYoYywgZCwgYSwgYilcbiAqL1xudmFyIHBhcnRpYWxSaWdodCA9IC8qI19fUFVSRV9fKi9fY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IoIC8qI19fUFVSRV9fKi9mbGlwKF9jb25jYXQpKTtcbmV4cG9ydCBkZWZhdWx0IHBhcnRpYWxSaWdodDsiLCJpbXBvcnQgZmlsdGVyIGZyb20gJy4vZmlsdGVyJztcbmltcG9ydCBqdXh0IGZyb20gJy4vanV4dCc7XG5pbXBvcnQgcmVqZWN0IGZyb20gJy4vcmVqZWN0JztcblxuLyoqXG4gKiBUYWtlcyBhIHByZWRpY2F0ZSBhbmQgYSBsaXN0IG9yIG90aGVyIGBGaWx0ZXJhYmxlYCBvYmplY3QgYW5kIHJldHVybnMgdGhlXG4gKiBwYWlyIG9mIGZpbHRlcmFibGUgb2JqZWN0cyBvZiB0aGUgc2FtZSB0eXBlIG9mIGVsZW1lbnRzIHdoaWNoIGRvIGFuZCBkbyBub3RcbiAqIHNhdGlzZnksIHRoZSBwcmVkaWNhdGUsIHJlc3BlY3RpdmVseS4gRmlsdGVyYWJsZSBvYmplY3RzIGluY2x1ZGUgcGxhaW4gb2JqZWN0cyBvciBhbnkgb2JqZWN0XG4gKiB0aGF0IGhhcyBhIGZpbHRlciBtZXRob2Qgc3VjaCBhcyBgQXJyYXlgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuNFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBbZiBhLCBmIGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHRvIGRldGVybWluZSB3aGljaCBzaWRlIHRoZSBlbGVtZW50IGJlbG9uZ3MgdG8uXG4gKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJhYmxlIHRoZSBsaXN0IChvciBvdGhlciBmaWx0ZXJhYmxlKSB0byBwYXJ0aXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXksIGNvbnRhaW5pbmcgZmlyc3QgdGhlIHN1YnNldCBvZiBlbGVtZW50cyB0aGF0IHNhdGlzZnkgdGhlXG4gKiAgICAgICAgIHByZWRpY2F0ZSwgYW5kIHNlY29uZCB0aGUgc3Vic2V0IG9mIGVsZW1lbnRzIHRoYXQgZG8gbm90IHNhdGlzZnkuXG4gKiBAc2VlIFIuZmlsdGVyLCBSLnJlamVjdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGFydGl0aW9uKFIuY29udGFpbnMoJ3MnKSwgWydzc3MnLCAndHR0JywgJ2ZvbycsICdiYXJzJ10pO1xuICogICAgICAvLyA9PiBbIFsgJ3NzcycsICdiYXJzJyBdLCAgWyAndHR0JywgJ2ZvbycgXSBdXG4gKlxuICogICAgICBSLnBhcnRpdGlvbihSLmNvbnRhaW5zKCdzJyksIHsgYTogJ3NzcycsIGI6ICd0dHQnLCBmb286ICdiYXJzJyB9KTtcbiAqICAgICAgLy8gPT4gWyB7IGE6ICdzc3MnLCBmb286ICdiYXJzJyB9LCB7IGI6ICd0dHQnIH0gIF1cbiAqL1xudmFyIHBhcnRpdGlvbiA9IC8qI19fUFVSRV9fKi9qdXh0KFtmaWx0ZXIsIHJlamVjdF0pO1xuZXhwb3J0IGRlZmF1bHQgcGFydGl0aW9uOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBJZHggPSBTdHJpbmcgfCBJbnRcbiAqIEBzaWcgW0lkeF0gLT4ge2F9IC0+IGEgfCBVbmRlZmluZWRcbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHJldHJpZXZlIHRoZSBuZXN0ZWQgcHJvcGVydHkgZnJvbS5cbiAqIEByZXR1cm4geyp9IFRoZSBkYXRhIGF0IGBwYXRoYC5cbiAqIEBzZWUgUi5wcm9wXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wYXRoKFsnYScsICdiJ10sIHthOiB7YjogMn19KTsgLy89PiAyXG4gKiAgICAgIFIucGF0aChbJ2EnLCAnYiddLCB7Yzoge2I6IDJ9fSk7IC8vPT4gdW5kZWZpbmVkXG4gKi9cbnZhciBwYXRoID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gcGF0aChwYXRocywgb2JqKSB7XG4gIHZhciB2YWwgPSBvYmo7XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgcGF0aHMubGVuZ3RoKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhbCA9IHZhbFtwYXRoc1tpZHhdXTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsO1xufSk7XG5leHBvcnQgZGVmYXVsdCBwYXRoOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgZXF1YWxzIGZyb20gJy4vZXF1YWxzJztcbmltcG9ydCBwYXRoIGZyb20gJy4vcGF0aCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgbmVzdGVkIHBhdGggb24gYW4gb2JqZWN0IGhhcyBhIHNwZWNpZmljIHZhbHVlLCBpblxuICogW2BSLmVxdWFsc2BdKCNlcXVhbHMpIHRlcm1zLiBNb3N0IGxpa2VseSB1c2VkIHRvIGZpbHRlciBhIGxpc3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNy4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEB0eXBlZGVmbiBJZHggPSBTdHJpbmcgfCBJbnRcbiAqIEBzaWcgW0lkeF0gLT4gYSAtPiB7YX0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbmVzdGVkIHByb3BlcnR5IHRvIHVzZVxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIGNvbXBhcmUgdGhlIG5lc3RlZCBwcm9wZXJ0eSB3aXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2sgdGhlIG5lc3RlZCBwcm9wZXJ0eSBpblxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBlcXVhbHMgdGhlIG5lc3RlZCBvYmplY3QgcHJvcGVydHksXG4gKiAgICAgICAgIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB1c2VyMSA9IHsgYWRkcmVzczogeyB6aXBDb2RlOiA5MDIxMCB9IH07XG4gKiAgICAgIHZhciB1c2VyMiA9IHsgYWRkcmVzczogeyB6aXBDb2RlOiA1NTU1NSB9IH07XG4gKiAgICAgIHZhciB1c2VyMyA9IHsgbmFtZTogJ0JvYicgfTtcbiAqICAgICAgdmFyIHVzZXJzID0gWyB1c2VyMSwgdXNlcjIsIHVzZXIzIF07XG4gKiAgICAgIHZhciBpc0ZhbW91cyA9IFIucGF0aEVxKFsnYWRkcmVzcycsICd6aXBDb2RlJ10sIDkwMjEwKTtcbiAqICAgICAgUi5maWx0ZXIoaXNGYW1vdXMsIHVzZXJzKTsgLy89PiBbIHVzZXIxIF1cbiAqL1xudmFyIHBhdGhFcSA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIHBhdGhFcShfcGF0aCwgdmFsLCBvYmopIHtcbiAgcmV0dXJuIGVxdWFscyhwYXRoKF9wYXRoLCBvYmopLCB2YWwpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBwYXRoRXE7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcbmltcG9ydCBkZWZhdWx0VG8gZnJvbSAnLi9kZWZhdWx0VG8nO1xuaW1wb3J0IHBhdGggZnJvbSAnLi9wYXRoJztcblxuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4sIG5vbi1udWxsIG9iamVjdCBoYXMgYSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGF0aCwgcmV0dXJucyB0aGVcbiAqIHZhbHVlIGF0IHRoYXQgcGF0aC4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHByb3ZpZGVkIGRlZmF1bHQgdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTguMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIElkeCA9IFN0cmluZyB8IEludFxuICogQHNpZyBhIC0+IFtJZHhdIC0+IHthfSAtPiBhXG4gKiBAcGFyYW0geyp9IGQgVGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBwIFRoZSBwYXRoIHRvIHVzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byByZXRyaWV2ZSB0aGUgbmVzdGVkIHByb3BlcnR5IGZyb20uXG4gKiBAcmV0dXJuIHsqfSBUaGUgZGF0YSBhdCBgcGF0aGAgb2YgdGhlIHN1cHBsaWVkIG9iamVjdCBvciB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBhdGhPcignTi9BJywgWydhJywgJ2InXSwge2E6IHtiOiAyfX0pOyAvLz0+IDJcbiAqICAgICAgUi5wYXRoT3IoJ04vQScsIFsnYScsICdiJ10sIHtjOiB7YjogMn19KTsgLy89PiBcIk4vQVwiXG4gKi9cbnZhciBwYXRoT3IgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBwYXRoT3IoZCwgcCwgb2JqKSB7XG4gIHJldHVybiBkZWZhdWx0VG8oZCwgcGF0aChwLCBvYmopKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcGF0aE9yOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgcGF0aCBmcm9tICcuL3BhdGgnO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHByb3BlcnR5IGF0IGdpdmVuIHBhdGggc2F0aXNmaWVzIHRoZVxuICogZ2l2ZW4gcHJlZGljYXRlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEB0eXBlZGVmbiBJZHggPSBTdHJpbmcgfCBJbnRcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW0lkeF0gLT4ge2F9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BQYXRoXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5wcm9wU2F0aXNmaWVzLCBSLnBhdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBhdGhTYXRpc2ZpZXMoeSA9PiB5ID4gMCwgWyd4JywgJ3knXSwge3g6IHt5OiAyfX0pOyAvLz0+IHRydWVcbiAqL1xudmFyIHBhdGhTYXRpc2ZpZXMgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBwYXRoU2F0aXNmaWVzKHByZWQsIHByb3BQYXRoLCBvYmopIHtcbiAgcmV0dXJuIHByb3BQYXRoLmxlbmd0aCA+IDAgJiYgcHJlZChwYXRoKHByb3BQYXRoLCBvYmopKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcGF0aFNhdGlzZmllczsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFJldHVybnMgYSBwYXJ0aWFsIGNvcHkgb2YgYW4gb2JqZWN0IGNvbnRhaW5pbmcgb25seSB0aGUga2V5cyBzcGVjaWZpZWQuIElmXG4gKiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LCB0aGUgcHJvcGVydHkgaXMgaWdub3JlZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgW2tdIC0+IHtrOiB2fSAtPiB7azogdn1cbiAqIEBwYXJhbSB7QXJyYXl9IG5hbWVzIGFuIGFycmF5IG9mIFN0cmluZyBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5IG9udG8gYSBuZXcgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY29weSBmcm9tXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRoIG9ubHkgcHJvcGVydGllcyBmcm9tIGBuYW1lc2Agb24gaXQuXG4gKiBAc2VlIFIub21pdCwgUi5wcm9wc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGljayhbJ2EnLCAnZCddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHthOiAxLCBkOiA0fVxuICogICAgICBSLnBpY2soWydhJywgJ2UnLCAnZiddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHthOiAxfVxuICovXG52YXIgcGljayA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHBpY2sobmFtZXMsIG9iaikge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgaWYgKG5hbWVzW2lkeF0gaW4gb2JqKSB7XG4gICAgICByZXN1bHRbbmFtZXNbaWR4XV0gPSBvYmpbbmFtZXNbaWR4XV07XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHBpY2s7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGBwaWNrYCBleGNlcHQgdGhhdCB0aGlzIG9uZSBpbmNsdWRlcyBhIGBrZXk6IHVuZGVmaW5lZGAgcGFpciBmb3JcbiAqIHByb3BlcnRpZXMgdGhhdCBkb24ndCBleGlzdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgW2tdIC0+IHtrOiB2fSAtPiB7azogdn1cbiAqIEBwYXJhbSB7QXJyYXl9IG5hbWVzIGFuIGFycmF5IG9mIFN0cmluZyBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5IG9udG8gYSBuZXcgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY29weSBmcm9tXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRoIG9ubHkgcHJvcGVydGllcyBmcm9tIGBuYW1lc2Agb24gaXQuXG4gKiBAc2VlIFIucGlja1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGlja0FsbChbJ2EnLCAnZCddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHthOiAxLCBkOiA0fVxuICogICAgICBSLnBpY2tBbGwoWydhJywgJ2UnLCAnZiddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHthOiAxLCBlOiB1bmRlZmluZWQsIGY6IHVuZGVmaW5lZH1cbiAqL1xudmFyIHBpY2tBbGwgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBwaWNrQWxsKG5hbWVzLCBvYmopIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHZhciBuYW1lID0gbmFtZXNbaWR4XTtcbiAgICByZXN1bHRbbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcGlja0FsbDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFJldHVybnMgYSBwYXJ0aWFsIGNvcHkgb2YgYW4gb2JqZWN0IGNvbnRhaW5pbmcgb25seSB0aGUga2V5cyB0aGF0IHNhdGlzZnlcbiAqIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgodiwgaykgLT4gQm9vbGVhbikgLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBrZXlcbiAqICAgICAgICBzaG91bGQgYmUgaW5jbHVkZWQgb24gdGhlIG91dHB1dCBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY29weSBmcm9tXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRoIG9ubHkgcHJvcGVydGllcyB0aGF0IHNhdGlzZnkgYHByZWRgXG4gKiAgICAgICAgIG9uIGl0LlxuICogQHNlZSBSLnBpY2ssIFIuZmlsdGVyXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGlzVXBwZXJDYXNlID0gKHZhbCwga2V5KSA9PiBrZXkudG9VcHBlckNhc2UoKSA9PT0ga2V5O1xuICogICAgICBSLnBpY2tCeShpc1VwcGVyQ2FzZSwge2E6IDEsIGI6IDIsIEE6IDMsIEI6IDR9KTsgLy89PiB7QTogMywgQjogNH1cbiAqL1xudmFyIHBpY2tCeSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHBpY2tCeSh0ZXN0LCBvYmopIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIGlmICh0ZXN0KG9ialtwcm9wXSwgcHJvcCwgb2JqKSkge1xuICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5leHBvcnQgZGVmYXVsdCBwaWNrQnk7IiwiaW1wb3J0IF9hcml0eSBmcm9tICcuL2ludGVybmFsL19hcml0eSc7XG5pbXBvcnQgX3BpcGUgZnJvbSAnLi9pbnRlcm5hbC9fcGlwZSc7XG5pbXBvcnQgcmVkdWNlIGZyb20gJy4vcmVkdWNlJztcbmltcG9ydCB0YWlsIGZyb20gJy4vdGFpbCc7XG5cbi8qKlxuICogUGVyZm9ybXMgbGVmdC10by1yaWdodCBmdW5jdGlvbiBjb21wb3NpdGlvbi4gVGhlIGxlZnRtb3N0IGZ1bmN0aW9uIG1heSBoYXZlXG4gKiBhbnkgYXJpdHk7IHRoZSByZW1haW5pbmcgZnVuY3Rpb25zIG11c3QgYmUgdW5hcnkuXG4gKlxuICogSW4gc29tZSBsaWJyYXJpZXMgdGhpcyBmdW5jdGlvbiBpcyBuYW1lZCBgc2VxdWVuY2VgLlxuICpcbiAqICoqTm90ZToqKiBUaGUgcmVzdWx0IG9mIHBpcGUgaXMgbm90IGF1dG9tYXRpY2FsbHkgY3VycmllZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKChhLCBiLCAuLi4sIG4pIC0+IG8pLCAobyAtPiBwKSwgLi4uLCAoeCAtPiB5KSwgKHkgLT4geikpIC0+ICgoYSwgYiwgLi4uLCBuKSAtPiB6KVxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3Rpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5jb21wb3NlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGYgPSBSLnBpcGUoTWF0aC5wb3csIFIubmVnYXRlLCBSLmluYyk7XG4gKlxuICogICAgICBmKDMsIDQpOyAvLyAtKDNeNCkgKyAxXG4gKiBAc3ltYiBSLnBpcGUoZiwgZywgaCkoYSwgYikgPSBoKGcoZihhLCBiKSkpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBpcGUoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwaXBlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuICB9XG4gIHJldHVybiBfYXJpdHkoYXJndW1lbnRzWzBdLmxlbmd0aCwgcmVkdWNlKF9waXBlLCBhcmd1bWVudHNbMF0sIHRhaWwoYXJndW1lbnRzKSkpO1xufSIsImltcG9ydCBjb21wb3NlSyBmcm9tICcuL2NvbXBvc2VLJztcbmltcG9ydCByZXZlcnNlIGZyb20gJy4vcmV2ZXJzZSc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGVmdC10by1yaWdodCBLbGVpc2xpIGNvbXBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMsXG4gKiBlYWNoIG9mIHdoaWNoIG11c3QgcmV0dXJuIGEgdmFsdWUgb2YgYSB0eXBlIHN1cHBvcnRlZCBieSBbYGNoYWluYF0oI2NoYWluKS5cbiAqXG4gKiBgUi5waXBlSyhmLCBnLCBoKWAgaXMgZXF1aXZhbGVudCB0byBgUi5waXBlKGYsIFIuY2hhaW4oZyksIFIuY2hhaW4oaCkpYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgQ2hhaW4gbSA9PiAoKGEgLT4gbSBiKSwgKGIgLT4gbSBjKSwgLi4uLCAoeSAtPiBtIHopKSAtPiAoYSAtPiBtIHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIuY29tcG9zZUtcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyAgcGFyc2VKc29uIDo6IFN0cmluZyAtPiBNYXliZSAqXG4gKiAgICAgIC8vICBnZXQgOjogU3RyaW5nIC0+IE9iamVjdCAtPiBNYXliZSAqXG4gKlxuICogICAgICAvLyAgZ2V0U3RhdGVDb2RlIDo6IE1heWJlIFN0cmluZyAtPiBNYXliZSBTdHJpbmdcbiAqICAgICAgdmFyIGdldFN0YXRlQ29kZSA9IFIucGlwZUsoXG4gKiAgICAgICAgcGFyc2VKc29uLFxuICogICAgICAgIGdldCgndXNlcicpLFxuICogICAgICAgIGdldCgnYWRkcmVzcycpLFxuICogICAgICAgIGdldCgnc3RhdGUnKSxcbiAqICAgICAgICBSLmNvbXBvc2UoTWF5YmUub2YsIFIudG9VcHBlcilcbiAqICAgICAgKTtcbiAqXG4gKiAgICAgIGdldFN0YXRlQ29kZSgne1widXNlclwiOntcImFkZHJlc3NcIjp7XCJzdGF0ZVwiOlwibnlcIn19fScpO1xuICogICAgICAvLz0+IEp1c3QoJ05ZJylcbiAqICAgICAgZ2V0U3RhdGVDb2RlKCdbSW52YWxpZCBKU09OXScpO1xuICogICAgICAvLz0+IE5vdGhpbmcoKVxuICogQHN5bWIgUi5waXBlSyhmLCBnLCBoKShhKSA9IFIuY2hhaW4oaCwgUi5jaGFpbihnLCBmKGEpKSlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGlwZUsoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwaXBlSyByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgfVxuICByZXR1cm4gY29tcG9zZUsuYXBwbHkodGhpcywgcmV2ZXJzZShhcmd1bWVudHMpKTtcbn0iLCJpbXBvcnQgX2FyaXR5IGZyb20gJy4vaW50ZXJuYWwvX2FyaXR5JztcbmltcG9ydCBfcGlwZVAgZnJvbSAnLi9pbnRlcm5hbC9fcGlwZVAnO1xuaW1wb3J0IHJlZHVjZSBmcm9tICcuL3JlZHVjZSc7XG5pbXBvcnQgdGFpbCBmcm9tICcuL3RhaWwnO1xuXG4vKipcbiAqIFBlcmZvcm1zIGxlZnQtdG8tcmlnaHQgY29tcG9zaXRpb24gb2Ygb25lIG9yIG1vcmUgUHJvbWlzZS1yZXR1cm5pbmdcbiAqIGZ1bmN0aW9ucy4gVGhlIGxlZnRtb3N0IGZ1bmN0aW9uIG1heSBoYXZlIGFueSBhcml0eTsgdGhlIHJlbWFpbmluZyBmdW5jdGlvbnNcbiAqIG11c3QgYmUgdW5hcnkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTAuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgoYSAtPiBQcm9taXNlIGIpLCAoYiAtPiBQcm9taXNlIGMpLCAuLi4sICh5IC0+IFByb21pc2UgeikpIC0+IChhIC0+IFByb21pc2UgeilcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmN0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIuY29tcG9zZVBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyAgZm9sbG93ZXJzRm9yVXNlciA6OiBTdHJpbmcgLT4gUHJvbWlzZSBbVXNlcl1cbiAqICAgICAgdmFyIGZvbGxvd2Vyc0ZvclVzZXIgPSBSLnBpcGVQKGRiLmdldFVzZXJCeUlkLCBkYi5nZXRGb2xsb3dlcnMpO1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwaXBlUCgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BpcGVQIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuICB9XG4gIHJldHVybiBfYXJpdHkoYXJndW1lbnRzWzBdLmxlbmd0aCwgcmVkdWNlKF9waXBlUCwgYXJndW1lbnRzWzBdLCB0YWlsKGFyZ3VtZW50cykpKTtcbn0iLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IG1hcCBmcm9tICcuL21hcCc7XG5pbXBvcnQgcHJvcCBmcm9tICcuL3Byb3AnO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBieSBwbHVja2luZyB0aGUgc2FtZSBuYW1lZCBwcm9wZXJ0eSBvZmYgYWxsIG9iamVjdHMgaW5cbiAqIHRoZSBsaXN0IHN1cHBsaWVkLlxuICpcbiAqIGBwbHVja2Agd2lsbCB3b3JrIG9uXG4gKiBhbnkgW2Z1bmN0b3JdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZnVuY3RvcikgaW5cbiAqIGFkZGl0aW9uIHRvIGFycmF5cywgYXMgaXQgaXMgZXF1aXZhbGVudCB0byBgUi5tYXAoUi5wcm9wKGspLCBmKWAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBGdW5jdG9yIGYgPT4gayAtPiBmIHtrOiB2fSAtPiBmIHZcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5IFRoZSBrZXkgbmFtZSB0byBwbHVjayBvZmYgb2YgZWFjaCBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5fSBmIFRoZSBhcnJheSBvciBmdW5jdG9yIHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGtleS5cbiAqIEBzZWUgUi5wcm9wc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGx1Y2soJ2EnKShbe2E6IDF9LCB7YTogMn1dKTsgLy89PiBbMSwgMl1cbiAqICAgICAgUi5wbHVjaygwKShbWzEsIDJdLCBbMywgNF1dKTsgICAvLz0+IFsxLCAzXVxuICogICAgICBSLnBsdWNrKCd2YWwnLCB7YToge3ZhbDogM30sIGI6IHt2YWw6IDV9fSk7IC8vPT4ge2E6IDMsIGI6IDV9XG4gKiBAc3ltYiBSLnBsdWNrKCd4JywgW3t4OiAxLCB5OiAyfSwge3g6IDMsIHk6IDR9LCB7eDogNSwgeTogNn1dKSA9IFsxLCAzLCA1XVxuICogQHN5bWIgUi5wbHVjaygwLCBbWzEsIDJdLCBbMywgNF0sIFs1LCA2XV0pID0gWzEsIDMsIDVdXG4gKi9cbnZhciBwbHVjayA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHBsdWNrKHAsIGxpc3QpIHtcbiAgcmV0dXJuIG1hcChwcm9wKHApLCBsaXN0KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcGx1Y2s7IiwiaW1wb3J0IF9jb25jYXQgZnJvbSAnLi9pbnRlcm5hbC9fY29uY2F0JztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IHdpdGggdGhlIGdpdmVuIGVsZW1lbnQgYXQgdGhlIGZyb250LCBmb2xsb3dlZCBieSB0aGVcbiAqIGNvbnRlbnRzIG9mIHRoZSBsaXN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0geyp9IGVsIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgaGVhZCBvZiB0aGUgb3V0cHV0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBhZGQgdG8gdGhlIHRhaWwgb2YgdGhlIG91dHB1dCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICogQHNlZSBSLmFwcGVuZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucHJlcGVuZCgnZmVlJywgWydmaScsICdmbycsICdmdW0nXSk7IC8vPT4gWydmZWUnLCAnZmknLCAnZm8nLCAnZnVtJ11cbiAqL1xudmFyIHByZXBlbmQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBwcmVwZW5kKGVsLCBsaXN0KSB7XG4gIHJldHVybiBfY29uY2F0KFtlbF0sIGxpc3QpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBwcmVwZW5kOyIsImltcG9ydCBtdWx0aXBseSBmcm9tICcuL211bHRpcGx5JztcbmltcG9ydCByZWR1Y2UgZnJvbSAnLi9yZWR1Y2UnO1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdG9nZXRoZXIgYWxsIHRoZSBlbGVtZW50cyBvZiBhIGxpc3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBbTnVtYmVyXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgQW4gYXJyYXkgb2YgbnVtYmVyc1xuICogQHJldHVybiB7TnVtYmVyfSBUaGUgcHJvZHVjdCBvZiBhbGwgdGhlIG51bWJlcnMgaW4gdGhlIGxpc3QuXG4gKiBAc2VlIFIucmVkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wcm9kdWN0KFsyLDQsNiw4LDEwMCwxXSk7IC8vPT4gMzg0MDBcbiAqL1xudmFyIHByb2R1Y3QgPSAvKiNfX1BVUkVfXyovcmVkdWNlKG11bHRpcGx5LCAxKTtcbmV4cG9ydCBkZWZhdWx0IHByb2R1Y3Q7IiwiaW1wb3J0IF9tYXAgZnJvbSAnLi9pbnRlcm5hbC9fbWFwJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5JztcbmltcG9ydCBwaWNrQWxsIGZyb20gJy4vcGlja0FsbCc7XG5pbXBvcnQgdXNlV2l0aCBmcm9tICcuL3VzZVdpdGgnO1xuXG4vKipcbiAqIFJlYXNvbmFibGUgYW5hbG9nIHRvIFNRTCBgc2VsZWN0YCBzdGF0ZW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgW2tdIC0+IFt7azogdn1dIC0+IFt7azogdn1dXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gcHJvamVjdFxuICogQHBhcmFtIHtBcnJheX0gb2JqcyBUaGUgb2JqZWN0cyB0byBxdWVyeVxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBqdXN0IHRoZSBgcHJvcHNgIHByb3BlcnRpZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGFiYnkgPSB7bmFtZTogJ0FiYnknLCBhZ2U6IDcsIGhhaXI6ICdibG9uZCcsIGdyYWRlOiAyfTtcbiAqICAgICAgdmFyIGZyZWQgPSB7bmFtZTogJ0ZyZWQnLCBhZ2U6IDEyLCBoYWlyOiAnYnJvd24nLCBncmFkZTogN307XG4gKiAgICAgIHZhciBraWRzID0gW2FiYnksIGZyZWRdO1xuICogICAgICBSLnByb2plY3QoWyduYW1lJywgJ2dyYWRlJ10sIGtpZHMpOyAvLz0+IFt7bmFtZTogJ0FiYnknLCBncmFkZTogMn0sIHtuYW1lOiAnRnJlZCcsIGdyYWRlOiA3fV1cbiAqL1xudmFyIHByb2plY3QgPSAvKiNfX1BVUkVfXyovdXNlV2l0aChfbWFwLCBbcGlja0FsbCwgaWRlbnRpdHldKTsgLy8gcGFzc2luZyBgaWRlbnRpdHlgIGdpdmVzIGNvcnJlY3QgYXJpdHlcbmV4cG9ydCBkZWZhdWx0IHByb2plY3Q7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBwYXRoIGZyb20gJy4vcGF0aCc7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2hlbiBzdXBwbGllZCBhbiBvYmplY3QgcmV0dXJucyB0aGUgaW5kaWNhdGVkXG4gKiBwcm9wZXJ0eSBvZiB0aGF0IG9iamVjdCwgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBzIC0+IHtzOiBhfSAtPiBhIHwgVW5kZWZpbmVkXG4gKiBAcGFyYW0ge1N0cmluZ30gcCBUaGUgcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHF1ZXJ5XG4gKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgYXQgYG9iai5wYC5cbiAqIEBzZWUgUi5wYXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wcm9wKCd4Jywge3g6IDEwMH0pOyAvLz0+IDEwMFxuICogICAgICBSLnByb3AoJ3gnLCB7fSk7IC8vPT4gdW5kZWZpbmVkXG4gKi9cblxudmFyIHByb3AgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBwcm9wKHAsIG9iaikge1xuICByZXR1cm4gcGF0aChbcF0sIG9iaik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHByb3A7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcbmltcG9ydCBlcXVhbHMgZnJvbSAnLi9lcXVhbHMnO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHByb3BlcnR5IGlzIGVxdWFsLCBpblxuICogW2BSLmVxdWFsc2BdKCNlcXVhbHMpIHRlcm1zLCB0byB0aGUgZ2l2ZW4gdmFsdWU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogWW91IGNhbiB0ZXN0IG11bHRpcGxlIHByb3BlcnRpZXMgd2l0aCBbYFIud2hlcmVgXSgjd2hlcmUpLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIFN0cmluZyAtPiBhIC0+IE9iamVjdCAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLndoZXJlRXEsIFIucHJvcFNhdGlzZmllcywgUi5lcXVhbHNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYWJieSA9IHtuYW1lOiAnQWJieScsIGFnZTogNywgaGFpcjogJ2Jsb25kJ307XG4gKiAgICAgIHZhciBmcmVkID0ge25hbWU6ICdGcmVkJywgYWdlOiAxMiwgaGFpcjogJ2Jyb3duJ307XG4gKiAgICAgIHZhciBydXN0eSA9IHtuYW1lOiAnUnVzdHknLCBhZ2U6IDEwLCBoYWlyOiAnYnJvd24nfTtcbiAqICAgICAgdmFyIGFsb2lzID0ge25hbWU6ICdBbG9pcycsIGFnZTogMTUsIGRpc3Bvc2l0aW9uOiAnc3VybHknfTtcbiAqICAgICAgdmFyIGtpZHMgPSBbYWJieSwgZnJlZCwgcnVzdHksIGFsb2lzXTtcbiAqICAgICAgdmFyIGhhc0Jyb3duSGFpciA9IFIucHJvcEVxKCdoYWlyJywgJ2Jyb3duJyk7XG4gKiAgICAgIFIuZmlsdGVyKGhhc0Jyb3duSGFpciwga2lkcyk7IC8vPT4gW2ZyZWQsIHJ1c3R5XVxuICovXG52YXIgcHJvcEVxID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gcHJvcEVxKG5hbWUsIHZhbCwgb2JqKSB7XG4gIHJldHVybiBlcXVhbHModmFsLCBvYmpbbmFtZV0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCBwcm9wRXE7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcbmltcG9ydCBpcyBmcm9tICcuL2lzJztcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBwcm9wZXJ0eSBpcyBvZiB0aGUgZ2l2ZW4gdHlwZTtcbiAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAc2lnIFR5cGUgLT4gU3RyaW5nIC0+IE9iamVjdCAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIuaXMsIFIucHJvcFNhdGlzZmllc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucHJvcElzKE51bWJlciwgJ3gnLCB7eDogMSwgeTogMn0pOyAgLy89PiB0cnVlXG4gKiAgICAgIFIucHJvcElzKE51bWJlciwgJ3gnLCB7eDogJ2Zvbyd9KTsgICAgLy89PiBmYWxzZVxuICogICAgICBSLnByb3BJcyhOdW1iZXIsICd4Jywge30pOyAgICAgICAgICAgIC8vPT4gZmFsc2VcbiAqL1xudmFyIHByb3BJcyA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIHByb3BJcyh0eXBlLCBuYW1lLCBvYmopIHtcbiAgcmV0dXJuIGlzKHR5cGUsIG9ialtuYW1lXSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHByb3BJczsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuaW1wb3J0IF9oYXMgZnJvbSAnLi9pbnRlcm5hbC9faGFzJztcblxuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4sIG5vbi1udWxsIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLFxuICogcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhhdCBwcm9wZXJ0eS4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHByb3ZpZGVkIGRlZmF1bHRcbiAqIHZhbHVlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjYuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBhIC0+IFN0cmluZyAtPiBPYmplY3QgLT4gYVxuICogQHBhcmFtIHsqfSB2YWwgVGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0ge1N0cmluZ30gcCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmV0dXJuLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybiB7Kn0gVGhlIHZhbHVlIG9mIGdpdmVuIHByb3BlcnR5IG9mIHRoZSBzdXBwbGllZCBvYmplY3Qgb3IgdGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGFsaWNlID0ge1xuICogICAgICAgIG5hbWU6ICdBTElDRScsXG4gKiAgICAgICAgYWdlOiAxMDFcbiAqICAgICAgfTtcbiAqICAgICAgdmFyIGZhdm9yaXRlID0gUi5wcm9wKCdmYXZvcml0ZUxpYnJhcnknKTtcbiAqICAgICAgdmFyIGZhdm9yaXRlV2l0aERlZmF1bHQgPSBSLnByb3BPcignUmFtZGEnLCAnZmF2b3JpdGVMaWJyYXJ5Jyk7XG4gKlxuICogICAgICBmYXZvcml0ZShhbGljZSk7ICAvLz0+IHVuZGVmaW5lZFxuICogICAgICBmYXZvcml0ZVdpdGhEZWZhdWx0KGFsaWNlKTsgIC8vPT4gJ1JhbWRhJ1xuICovXG52YXIgcHJvcE9yID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gcHJvcE9yKHZhbCwgcCwgb2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfaGFzKHAsIG9iaikgPyBvYmpbcF0gOiB2YWw7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHByb3BPcjsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHByb3BlcnR5IHNhdGlzZmllcyB0aGUgZ2l2ZW5cbiAqIHByZWRpY2F0ZTsgYGZhbHNlYCBvdGhlcndpc2UuIFlvdSBjYW4gdGVzdCBtdWx0aXBsZSBwcm9wZXJ0aWVzIHdpdGhcbiAqIFtgUi53aGVyZWBdKCN3aGVyZSkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFN0cmluZyAtPiB7U3RyaW5nOiBhfSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIud2hlcmUsIFIucHJvcEVxLCBSLnByb3BJc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucHJvcFNhdGlzZmllcyh4ID0+IHggPiAwLCAneCcsIHt4OiAxLCB5OiAyfSk7IC8vPT4gdHJ1ZVxuICovXG52YXIgcHJvcFNhdGlzZmllcyA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIHByb3BTYXRpc2ZpZXMocHJlZCwgbmFtZSwgb2JqKSB7XG4gIHJldHVybiBwcmVkKG9ialtuYW1lXSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHByb3BTYXRpc2ZpZXM7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBBY3RzIGFzIG11bHRpcGxlIGBwcm9wYDogYXJyYXkgb2Yga2V5cyBpbiwgYXJyYXkgb2YgdmFsdWVzIG91dC4gUHJlc2VydmVzXG4gKiBvcmRlci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgW2tdIC0+IHtrOiB2fSAtPiBbdl1cbiAqIEBwYXJhbSB7QXJyYXl9IHBzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBmZXRjaFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHF1ZXJ5XG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzIG9yIHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucHJvcHMoWyd4JywgJ3knXSwge3g6IDEsIHk6IDJ9KTsgLy89PiBbMSwgMl1cbiAqICAgICAgUi5wcm9wcyhbJ2MnLCAnYScsICdiJ10sIHtiOiAyLCBhOiAxfSk7IC8vPT4gW3VuZGVmaW5lZCwgMSwgMl1cbiAqXG4gKiAgICAgIHZhciBmdWxsTmFtZSA9IFIuY29tcG9zZShSLmpvaW4oJyAnKSwgUi5wcm9wcyhbJ2ZpcnN0JywgJ2xhc3QnXSkpO1xuICogICAgICBmdWxsTmFtZSh7bGFzdDogJ0J1bGxldC1Ub290aCcsIGFnZTogMzMsIGZpcnN0OiAnVG9ueSd9KTsgLy89PiAnVG9ueSBCdWxsZXQtVG9vdGgnXG4gKi9cbnZhciBwcm9wcyA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHByb3BzKHBzLCBvYmopIHtcbiAgdmFyIGxlbiA9IHBzLmxlbmd0aDtcbiAgdmFyIG91dCA9IFtdO1xuICB2YXIgaWR4ID0gMDtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgb3V0W2lkeF0gPSBvYmpbcHNbaWR4XV07XG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufSk7XG5leHBvcnQgZGVmYXVsdCBwcm9wczsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9pc051bWJlciBmcm9tICcuL2ludGVybmFsL19pc051bWJlcic7XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgbnVtYmVycyBmcm9tIGBmcm9tYCAoaW5jbHVzaXZlKSB0byBgdG9gIChleGNsdXNpdmUpLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBbTnVtYmVyXVxuICogQHBhcmFtIHtOdW1iZXJ9IGZyb20gVGhlIGZpcnN0IG51bWJlciBpbiB0aGUgbGlzdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0byBPbmUgbW9yZSB0aGFuIHRoZSBsYXN0IG51bWJlciBpbiB0aGUgbGlzdC5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBudW1iZXJzIGluIHR0aGUgc2V0IGBbYSwgYilgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucmFuZ2UoMSwgNSk7ICAgIC8vPT4gWzEsIDIsIDMsIDRdXG4gKiAgICAgIFIucmFuZ2UoNTAsIDUzKTsgIC8vPT4gWzUwLCA1MSwgNTJdXG4gKi9cbnZhciByYW5nZSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHJhbmdlKGZyb20sIHRvKSB7XG4gIGlmICghKF9pc051bWJlcihmcm9tKSAmJiBfaXNOdW1iZXIodG8pKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvdGggYXJndW1lbnRzIHRvIHJhbmdlIG11c3QgYmUgbnVtYmVycycpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIG4gPSBmcm9tO1xuICB3aGlsZSAobiA8IHRvKSB7XG4gICAgcmVzdWx0LnB1c2gobik7XG4gICAgbiArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHJhbmdlOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgX3JlZHVjZSBmcm9tICcuL2ludGVybmFsL19yZWR1Y2UnO1xuXG4vKipcbiAqIFJldHVybnMgYSBzaW5nbGUgaXRlbSBieSBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgbGlzdCwgc3VjY2Vzc2l2ZWx5IGNhbGxpbmdcbiAqIHRoZSBpdGVyYXRvciBmdW5jdGlvbiBhbmQgcGFzc2luZyBpdCBhbiBhY2N1bXVsYXRvciB2YWx1ZSBhbmQgdGhlIGN1cnJlbnRcbiAqIHZhbHVlIGZyb20gdGhlIGFycmF5LCBhbmQgdGhlbiBwYXNzaW5nIHRoZSByZXN1bHQgdG8gdGhlIG5leHQgY2FsbC5cbiAqXG4gKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHZhbHVlczogKihhY2MsIHZhbHVlKSouIEl0IG1heSB1c2VcbiAqIFtgUi5yZWR1Y2VkYF0oI3JlZHVjZWQpIHRvIHNob3J0Y3V0IHRoZSBpdGVyYXRpb24uXG4gKlxuICogVGhlIGFyZ3VtZW50cycgb3JkZXIgb2YgW2ByZWR1Y2VSaWdodGBdKCNyZWR1Y2VSaWdodCkncyBpdGVyYXRvciBmdW5jdGlvblxuICogaXMgKih2YWx1ZSwgYWNjKSouXG4gKlxuICogTm90ZTogYFIucmVkdWNlYCBkb2VzIG5vdCBza2lwIGRlbGV0ZWQgb3IgdW5hc3NpZ25lZCBpbmRpY2VzIChzcGFyc2VcbiAqIGFycmF5cyksIHVubGlrZSB0aGUgbmF0aXZlIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2QuIEZvciBtb3JlIGRldGFpbHNcbiAqIG9uIHRoaXMgYmVoYXZpb3IsIHNlZTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JlZHVjZSNEZXNjcmlwdGlvblxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGByZWR1Y2VgIG1ldGhvZCBvZiB0aGUgdGhpcmQgYXJndW1lbnQsIGlmIHByZXNlbnQuIFdoZW5cbiAqIGRvaW5nIHNvLCBpdCBpcyB1cCB0byB0aGUgdXNlciB0byBoYW5kbGUgdGhlIFtgUi5yZWR1Y2VkYF0oI3JlZHVjZWQpXG4gKiBzaG9ydGN1dGluZywgYXMgdGhpcyBpcyBub3QgaW1wbGVtZW50ZWQgYnkgYHJlZHVjZWAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGIpIC0+IGEpIC0+IGEgLT4gW2JdIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAqICAgICAgICBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkuXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIFIucmVkdWNlZCwgUi5hZGRJbmRleCwgUi5yZWR1Y2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucmVkdWNlKFIuc3VidHJhY3QsIDAsIFsxLCAyLCAzLCA0XSkgLy8gPT4gKCgoKDAgLSAxKSAtIDIpIC0gMykgLSA0KSA9IC0xMFxuICogICAgICAvLyAgICAgICAgICAtICAgICAgICAgICAgICAgLTEwXG4gKiAgICAgIC8vICAgICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAvLyAgICAgICAgLSAgIDQgICAgICAgICAgIC02ICAgNFxuICogICAgICAvLyAgICAgICAvIFxcICAgICAgICAgICAgICAvIFxcXG4gKiAgICAgIC8vICAgICAgLSAgIDMgICA9PT4gICAgIC0zICAgM1xuICogICAgICAvLyAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAvLyAgICAtICAgMiAgICAgICAgICAgLTEgICAyXG4gKiAgICAgIC8vICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAvLyAgMCAgIDEgICAgICAgICAgICAwICAgMVxuICpcbiAqIEBzeW1iIFIucmVkdWNlKGYsIGEsIFtiLCBjLCBkXSkgPSBmKGYoZihhLCBiKSwgYyksIGQpXG4gKi9cbnZhciByZWR1Y2UgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhfcmVkdWNlKTtcbmV4cG9ydCBkZWZhdWx0IHJlZHVjZTsiLCJpbXBvcnQgX2N1cnJ5TiBmcm9tICcuL2ludGVybmFsL19jdXJyeU4nO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfaGFzIGZyb20gJy4vaW50ZXJuYWwvX2hhcyc7XG5pbXBvcnQgX3JlZHVjZSBmcm9tICcuL2ludGVybmFsL19yZWR1Y2UnO1xuaW1wb3J0IF94cmVkdWNlQnkgZnJvbSAnLi9pbnRlcm5hbC9feHJlZHVjZUJ5JztcblxuLyoqXG4gKiBHcm91cHMgdGhlIGVsZW1lbnRzIG9mIHRoZSBsaXN0IGFjY29yZGluZyB0byB0aGUgcmVzdWx0IG9mIGNhbGxpbmdcbiAqIHRoZSBTdHJpbmctcmV0dXJuaW5nIGZ1bmN0aW9uIGBrZXlGbmAgb24gZWFjaCBlbGVtZW50IGFuZCByZWR1Y2VzIHRoZSBlbGVtZW50c1xuICogb2YgZWFjaCBncm91cCB0byBhIHNpbmdsZSB2YWx1ZSB2aWEgdGhlIHJlZHVjZXIgZnVuY3Rpb24gYHZhbHVlRm5gLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYmFzaWNhbGx5IGEgbW9yZSBnZW5lcmFsIFtgZ3JvdXBCeWBdKCNncm91cEJ5KSBmdW5jdGlvbi5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjAuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhLCBiKSAtPiBhKSAtPiBhIC0+IChiIC0+IFN0cmluZykgLT4gW2JdIC0+IHtTdHJpbmc6IGF9XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB2YWx1ZUZuIFRoZSBmdW5jdGlvbiB0aGF0IHJlZHVjZXMgdGhlIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXAgdG8gYSBzaW5nbGVcbiAqICAgICAgICB2YWx1ZS4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgYWNjdW11bGF0b3IgZm9yIGEgcGFydGljdWxhciBncm91cCBhbmQgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAqIEBwYXJhbSB7Kn0gYWNjIFRoZSAoaW5pdGlhbCkgYWNjdW11bGF0b3IgdmFsdWUgZm9yIGVhY2ggZ3JvdXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlGbiBUaGUgZnVuY3Rpb24gdGhhdCBtYXBzIHRoZSBsaXN0J3MgZWxlbWVudCBpbnRvIGEga2V5LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gZ3JvdXAuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBvdXRwdXQgb2YgYGtleUZuYCBmb3Iga2V5cywgbWFwcGVkIHRvIHRoZSBvdXRwdXQgb2ZcbiAqICAgICAgICAgYHZhbHVlRm5gIGZvciBlbGVtZW50cyB3aGljaCBwcm9kdWNlZCB0aGF0IGtleSB3aGVuIHBhc3NlZCB0byBga2V5Rm5gLlxuICogQHNlZSBSLmdyb3VwQnksIFIucmVkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHJlZHVjZVRvTmFtZXNCeSA9IFIucmVkdWNlQnkoKGFjYywgc3R1ZGVudCkgPT4gYWNjLmNvbmNhdChzdHVkZW50Lm5hbWUpLCBbXSk7XG4gKiAgICAgIHZhciBuYW1lc0J5R3JhZGUgPSByZWR1Y2VUb05hbWVzQnkoZnVuY3Rpb24oc3R1ZGVudCkge1xuICogICAgICAgIHZhciBzY29yZSA9IHN0dWRlbnQuc2NvcmU7XG4gKiAgICAgICAgcmV0dXJuIHNjb3JlIDwgNjUgPyAnRicgOlxuICogICAgICAgICAgICAgICBzY29yZSA8IDcwID8gJ0QnIDpcbiAqICAgICAgICAgICAgICAgc2NvcmUgPCA4MCA/ICdDJyA6XG4gKiAgICAgICAgICAgICAgIHNjb3JlIDwgOTAgPyAnQicgOiAnQSc7XG4gKiAgICAgIH0pO1xuICogICAgICB2YXIgc3R1ZGVudHMgPSBbe25hbWU6ICdMdWN5Jywgc2NvcmU6IDkyfSxcbiAqICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnRHJldycsIHNjb3JlOiA4NX0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5cbiAqICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnQmFydCcsIHNjb3JlOiA2Mn1dO1xuICogICAgICBuYW1lc0J5R3JhZGUoc3R1ZGVudHMpO1xuICogICAgICAvLyB7XG4gKiAgICAgIC8vICAgJ0EnOiBbJ0x1Y3knXSxcbiAqICAgICAgLy8gICAnQic6IFsnRHJldyddXG4gKiAgICAgIC8vICAgLy8gLi4uLFxuICogICAgICAvLyAgICdGJzogWydCYXJ0J11cbiAqICAgICAgLy8gfVxuICovXG52YXIgcmVkdWNlQnkgPSAvKiNfX1BVUkVfXyovX2N1cnJ5Tig0LCBbXSwgLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoW10sIF94cmVkdWNlQnksIGZ1bmN0aW9uIHJlZHVjZUJ5KHZhbHVlRm4sIHZhbHVlQWNjLCBrZXlGbiwgbGlzdCkge1xuICByZXR1cm4gX3JlZHVjZShmdW5jdGlvbiAoYWNjLCBlbHQpIHtcbiAgICB2YXIga2V5ID0ga2V5Rm4oZWx0KTtcbiAgICBhY2Nba2V5XSA9IHZhbHVlRm4oX2hhcyhrZXksIGFjYykgPyBhY2Nba2V5XSA6IHZhbHVlQWNjLCBlbHQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9LCBsaXN0KTtcbn0pKTtcbmV4cG9ydCBkZWZhdWx0IHJlZHVjZUJ5OyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8qKlxuICogUmV0dXJucyBhIHNpbmdsZSBpdGVtIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBsaXN0LCBzdWNjZXNzaXZlbHkgY2FsbGluZ1xuICogdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIGFuZCBwYXNzaW5nIGl0IGFuIGFjY3VtdWxhdG9yIHZhbHVlIGFuZCB0aGUgY3VycmVudFxuICogdmFsdWUgZnJvbSB0aGUgYXJyYXksIGFuZCB0aGVuIHBhc3NpbmcgdGhlIHJlc3VsdCB0byB0aGUgbmV4dCBjYWxsLlxuICpcbiAqIFNpbWlsYXIgdG8gW2ByZWR1Y2VgXSgjcmVkdWNlKSwgZXhjZXB0IG1vdmVzIHRocm91Z2ggdGhlIGlucHV0IGxpc3QgZnJvbSB0aGVcbiAqIHJpZ2h0IHRvIHRoZSBsZWZ0LlxuICpcbiAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyB0d28gdmFsdWVzOiAqKHZhbHVlLCBhY2MpKiwgd2hpbGUgdGhlIGFyZ3VtZW50cydcbiAqIG9yZGVyIG9mIGByZWR1Y2VgJ3MgaXRlcmF0b3IgZnVuY3Rpb24gaXMgKihhY2MsIHZhbHVlKSouXG4gKlxuICogTm90ZTogYFIucmVkdWNlUmlnaHRgIGRvZXMgbm90IHNraXAgZGVsZXRlZCBvciB1bmFzc2lnbmVkIGluZGljZXMgKHNwYXJzZVxuICogYXJyYXlzKSwgdW5saWtlIHRoZSBuYXRpdmUgYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodGAgbWV0aG9kLiBGb3IgbW9yZSBkZXRhaWxzXG4gKiBvbiB0aGlzIGJlaGF2aW9yLCBzZWU6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9yZWR1Y2VSaWdodCNEZXNjcmlwdGlvblxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhLCBiKSAtPiBiKSAtPiBiIC0+IFthXSAtPiBiXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIFJlY2VpdmVzIHR3byB2YWx1ZXMsIHRoZSBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcbiAqICAgICAgICBhbmQgdGhlIGFjY3VtdWxhdG9yLlxuICogQHBhcmFtIHsqfSBhY2MgVGhlIGFjY3VtdWxhdG9yIHZhbHVlLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQHNlZSBSLnJlZHVjZSwgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucmVkdWNlUmlnaHQoUi5zdWJ0cmFjdCwgMCwgWzEsIDIsIDMsIDRdKSAvLyA9PiAoMSAtICgyIC0gKDMgLSAoNCAtIDApKSkpID0gLTJcbiAqICAgICAgLy8gICAgLSAgICAgICAgICAgICAgIC0yXG4gKiAgICAgIC8vICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAvLyAgMSAgIC0gICAgICAgICAgICAxICAgM1xuICogICAgICAvLyAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAvLyAgICAyICAgLSAgICAgPT0+ICAgIDIgIC0xXG4gKiAgICAgIC8vICAgICAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgLy8gICAgICAzICAgLSAgICAgICAgICAgIDMgICA0XG4gKiAgICAgIC8vICAgICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAvLyAgICAgICAgNCAgIDAgICAgICAgICAgICA0ICAgMFxuICpcbiAqIEBzeW1iIFIucmVkdWNlUmlnaHQoZiwgYSwgW2IsIGMsIGRdKSA9IGYoYiwgZihjLCBmKGQsIGEpKSlcbiAqL1xudmFyIHJlZHVjZVJpZ2h0ID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gcmVkdWNlUmlnaHQoZm4sIGFjYywgbGlzdCkge1xuICB2YXIgaWR4ID0gbGlzdC5sZW5ndGggLSAxO1xuICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICBhY2MgPSBmbihsaXN0W2lkeF0sIGFjYyk7XG4gICAgaWR4IC09IDE7XG4gIH1cbiAgcmV0dXJuIGFjYztcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcmVkdWNlUmlnaHQ7IiwiaW1wb3J0IF9jdXJyeU4gZnJvbSAnLi9pbnRlcm5hbC9fY3VycnlOJztcbmltcG9ydCBfcmVkdWNlIGZyb20gJy4vaW50ZXJuYWwvX3JlZHVjZSc7XG5pbXBvcnQgX3JlZHVjZWQgZnJvbSAnLi9pbnRlcm5hbC9fcmVkdWNlZCc7XG5cbi8qKlxuICogTGlrZSBbYHJlZHVjZWBdKCNyZWR1Y2UpLCBgcmVkdWNlV2hpbGVgIHJldHVybnMgYSBzaW5nbGUgaXRlbSBieSBpdGVyYXRpbmdcbiAqIHRocm91Z2ggdGhlIGxpc3QsIHN1Y2Nlc3NpdmVseSBjYWxsaW5nIHRoZSBpdGVyYXRvciBmdW5jdGlvbi4gYHJlZHVjZVdoaWxlYFxuICogYWxzbyB0YWtlcyBhIHByZWRpY2F0ZSB0aGF0IGlzIGV2YWx1YXRlZCBiZWZvcmUgZWFjaCBzdGVwLiBJZiB0aGUgcHJlZGljYXRlXG4gKiByZXR1cm5zIGBmYWxzZWAsIGl0IFwic2hvcnQtY2lyY3VpdHNcIiB0aGUgaXRlcmF0aW9uIGFuZCByZXR1cm5zIHRoZSBjdXJyZW50XG4gKiB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjIuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhLCBiKSAtPiBCb29sZWFuKSAtPiAoKGEsIGIpIC0+IGEpIC0+IGEgLT4gW2JdIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgVGhlIHByZWRpY2F0ZS4gSXQgaXMgcGFzc2VkIHRoZSBhY2N1bXVsYXRvciBhbmQgdGhlXG4gKiAgICAgICAgY3VycmVudCBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLiBSZWNlaXZlcyB0d28gdmFsdWVzLCB0aGVcbiAqICAgICAgICBhY2N1bXVsYXRvciBhbmQgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAqIEBwYXJhbSB7Kn0gYSBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIFIucmVkdWNlLCBSLnJlZHVjZWRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaXNPZGQgPSAoYWNjLCB4KSA9PiB4ICUgMiA9PT0gMTtcbiAqICAgICAgdmFyIHhzID0gWzEsIDMsIDUsIDYwLCA3NzcsIDgwMF07XG4gKiAgICAgIFIucmVkdWNlV2hpbGUoaXNPZGQsIFIuYWRkLCAwLCB4cyk7IC8vPT4gOVxuICpcbiAqICAgICAgdmFyIHlzID0gWzIsIDQsIDZdXG4gKiAgICAgIFIucmVkdWNlV2hpbGUoaXNPZGQsIFIuYWRkLCAxMTEsIHlzKTsgLy89PiAxMTFcbiAqL1xudmFyIHJlZHVjZVdoaWxlID0gLyojX19QVVJFX18qL19jdXJyeU4oNCwgW10sIGZ1bmN0aW9uIF9yZWR1Y2VXaGlsZShwcmVkLCBmbiwgYSwgbGlzdCkge1xuICByZXR1cm4gX3JlZHVjZShmdW5jdGlvbiAoYWNjLCB4KSB7XG4gICAgcmV0dXJuIHByZWQoYWNjLCB4KSA/IGZuKGFjYywgeCkgOiBfcmVkdWNlZChhY2MpO1xuICB9LCBhLCBsaXN0KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcmVkdWNlV2hpbGU7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBfcmVkdWNlZCBmcm9tICcuL2ludGVybmFsL19yZWR1Y2VkJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgd3JhcHBlZCB0byBpbmRpY2F0ZSB0aGF0IGl0IGlzIHRoZSBmaW5hbCB2YWx1ZSBvZiB0aGUgcmVkdWNlXG4gKiBhbmQgdHJhbnNkdWNlIGZ1bmN0aW9ucy4gVGhlIHJldHVybmVkIHZhbHVlIHNob3VsZCBiZSBjb25zaWRlcmVkIGEgYmxhY2tcbiAqIGJveDogdGhlIGludGVybmFsIHN0cnVjdHVyZSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBzdGFibGUuXG4gKlxuICogTm90ZTogdGhpcyBvcHRpbWl6YXRpb24gaXMgdW5hdmFpbGFibGUgdG8gZnVuY3Rpb25zIG5vdCBleHBsaWNpdGx5IGxpc3RlZFxuICogYWJvdmUuIEZvciBpbnN0YW5jZSwgaXQgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnlcbiAqIFtgcmVkdWNlUmlnaHRgXSgjcmVkdWNlUmlnaHQpLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE1LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gKlxuICogQHBhcmFtIHsqfSB4IFRoZSBmaW5hbCB2YWx1ZSBvZiB0aGUgcmVkdWNlLlxuICogQHJldHVybiB7Kn0gVGhlIHdyYXBwZWQgdmFsdWUuXG4gKiBAc2VlIFIucmVkdWNlLCBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgUi5yZWR1Y2UoXG4gKiAgICAgICAoYWNjLCBpdGVtKSA9PiBpdGVtID4gMyA/IFIucmVkdWNlZChhY2MpIDogYWNjLmNvbmNhdChpdGVtKSxcbiAqICAgICAgIFtdLFxuICogICAgICAgWzEsIDIsIDMsIDQsIDVdKSAvLyBbMSwgMiwgM11cbiAqL1xudmFyIHJlZHVjZWQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShfcmVkdWNlZCk7XG5leHBvcnQgZGVmYXVsdCByZWR1Y2VkOyIsImltcG9ydCBfY29tcGxlbWVudCBmcm9tICcuL2ludGVybmFsL19jb21wbGVtZW50JztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgZmlsdGVyIGZyb20gJy4vZmlsdGVyJztcblxuLyoqXG4gKiBUaGUgY29tcGxlbWVudCBvZiBbYGZpbHRlcmBdKCNmaWx0ZXIpLlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi4gRmlsdGVyYWJsZVxuICogb2JqZWN0cyBpbmNsdWRlIHBsYWluIG9iamVjdHMgb3IgYW55IG9iamVjdCB0aGF0IGhhcyBhIGZpbHRlciBtZXRob2Qgc3VjaFxuICogYXMgYEFycmF5YC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIEZpbHRlcmFibGUgZiA9PiAoYSAtPiBCb29sZWFuKSAtPiBmIGEgLT4gZiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJhYmxlXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBzZWUgUi5maWx0ZXIsIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGlzT2RkID0gKG4pID0+IG4gJSAyID09PSAxO1xuICpcbiAqICAgICAgUi5yZWplY3QoaXNPZGQsIFsxLCAyLCAzLCA0XSk7IC8vPT4gWzIsIDRdXG4gKlxuICogICAgICBSLnJlamVjdChpc09kZCwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YjogMiwgZDogNH1cbiAqL1xudmFyIHJlamVjdCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHJlamVjdChwcmVkLCBmaWx0ZXJhYmxlKSB7XG4gIHJldHVybiBmaWx0ZXIoX2NvbXBsZW1lbnQocHJlZCksIGZpbHRlcmFibGUpO1xufSk7XG5leHBvcnQgZGVmYXVsdCByZWplY3Q7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBzdWItbGlzdCBvZiBgbGlzdGAgc3RhcnRpbmcgYXQgaW5kZXggYHN0YXJ0YCBhbmQgY29udGFpbmluZ1xuICogYGNvdW50YCBlbGVtZW50cy4gX05vdGUgdGhhdCB0aGlzIGlzIG5vdCBkZXN0cnVjdGl2ZV86IGl0IHJldHVybnMgYSBjb3B5IG9mXG4gKiB0aGUgbGlzdCB3aXRoIHRoZSBjaGFuZ2VzLlxuICogPHNtYWxsPk5vIGxpc3RzIGhhdmUgYmVlbiBoYXJtZWQgaW4gdGhlIGFwcGxpY2F0aW9uIG9mIHRoaXMgZnVuY3Rpb24uPC9zbWFsbD5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjJcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFRoZSBwb3NpdGlvbiB0byBzdGFydCByZW1vdmluZyBlbGVtZW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIHJlbW92ZSBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgQXJyYXkgd2l0aCBgY291bnRgIGVsZW1lbnRzIGZyb20gYHN0YXJ0YCByZW1vdmVkLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucmVtb3ZlKDIsIDMsIFsxLDIsMyw0LDUsNiw3LDhdKTsgLy89PiBbMSwyLDYsNyw4XVxuICovXG52YXIgcmVtb3ZlID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gcmVtb3ZlKHN0YXJ0LCBjb3VudCwgbGlzdCkge1xuICB2YXIgcmVzdWx0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCk7XG4gIHJlc3VsdC5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcmVtb3ZlOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgYWx3YXlzIGZyb20gJy4vYWx3YXlzJztcbmltcG9ydCB0aW1lcyBmcm9tICcuL3RpbWVzJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgZml4ZWQgbGlzdCBvZiBzaXplIGBuYCBjb250YWluaW5nIGEgc3BlY2lmaWVkIGlkZW50aWNhbCB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjFcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gbiAtPiBbYV1cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlcGVhdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBkZXNpcmVkIHNpemUgb2YgdGhlIG91dHB1dCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5IGNvbnRhaW5pbmcgYG5gIGB2YWx1ZWBzLlxuICogQHNlZSBSLnRpbWVzXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5yZXBlYXQoJ2hpJywgNSk7IC8vPT4gWydoaScsICdoaScsICdoaScsICdoaScsICdoaSddXG4gKlxuICogICAgICB2YXIgb2JqID0ge307XG4gKiAgICAgIHZhciByZXBlYXRlZE9ianMgPSBSLnJlcGVhdChvYmosIDUpOyAvLz0+IFt7fSwge30sIHt9LCB7fSwge31dXG4gKiAgICAgIHJlcGVhdGVkT2Jqc1swXSA9PT0gcmVwZWF0ZWRPYmpzWzFdOyAvLz0+IHRydWVcbiAqIEBzeW1iIFIucmVwZWF0KGEsIDApID0gW11cbiAqIEBzeW1iIFIucmVwZWF0KGEsIDEpID0gW2FdXG4gKiBAc3ltYiBSLnJlcGVhdChhLCAyKSA9IFthLCBhXVxuICovXG52YXIgcmVwZWF0ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gcmVwZWF0KHZhbHVlLCBuKSB7XG4gIHJldHVybiB0aW1lcyhhbHdheXModmFsdWUpLCBuKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcmVwZWF0OyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8qKlxuICogUmVwbGFjZSBhIHN1YnN0cmluZyBvciByZWdleCBtYXRjaCBpbiBhIHN0cmluZyB3aXRoIGEgcmVwbGFjZW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNy4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIFJlZ0V4cHxTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gcGF0dGVybiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBhIHN1YnN0cmluZyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfSByZXBsYWNlbWVudCBUaGUgc3RyaW5nIHRvIHJlcGxhY2UgdGhlIG1hdGNoZXMgd2l0aC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byBkbyB0aGUgc2VhcmNoIGFuZCByZXBsYWNlbWVudCBpbi5cbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlc3VsdC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJlcGxhY2UoJ2ZvbycsICdiYXInLCAnZm9vIGZvbyBmb28nKTsgLy89PiAnYmFyIGZvbyBmb28nXG4gKiAgICAgIFIucmVwbGFjZSgvZm9vLywgJ2JhcicsICdmb28gZm9vIGZvbycpOyAvLz0+ICdiYXIgZm9vIGZvbydcbiAqXG4gKiAgICAgIC8vIFVzZSB0aGUgXCJnXCIgKGdsb2JhbCkgZmxhZyB0byByZXBsYWNlIGFsbCBvY2N1cnJlbmNlczpcbiAqICAgICAgUi5yZXBsYWNlKC9mb28vZywgJ2JhcicsICdmb28gZm9vIGZvbycpOyAvLz0+ICdiYXIgYmFyIGJhcidcbiAqL1xudmFyIHJlcGxhY2UgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiByZXBsYWNlKHJlZ2V4LCByZXBsYWNlbWVudCwgc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShyZWdleCwgcmVwbGFjZW1lbnQpO1xufSk7XG5leHBvcnQgZGVmYXVsdCByZXBsYWNlOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgX2lzU3RyaW5nIGZyb20gJy4vaW50ZXJuYWwvX2lzU3RyaW5nJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3Qgb3Igc3RyaW5nIHdpdGggdGhlIGVsZW1lbnRzIG9yIGNoYXJhY3RlcnMgaW4gcmV2ZXJzZVxuICogb3JkZXIuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2FdXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBsaXN0XG4gKiBAcmV0dXJuIHtBcnJheXxTdHJpbmd9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5yZXZlcnNlKFsxLCAyLCAzXSk7ICAvLz0+IFszLCAyLCAxXVxuICogICAgICBSLnJldmVyc2UoWzEsIDJdKTsgICAgIC8vPT4gWzIsIDFdXG4gKiAgICAgIFIucmV2ZXJzZShbMV0pOyAgICAgICAgLy89PiBbMV1cbiAqICAgICAgUi5yZXZlcnNlKFtdKTsgICAgICAgICAvLz0+IFtdXG4gKlxuICogICAgICBSLnJldmVyc2UoJ2FiYycpOyAgICAgIC8vPT4gJ2NiYSdcbiAqICAgICAgUi5yZXZlcnNlKCdhYicpOyAgICAgICAvLz0+ICdiYSdcbiAqICAgICAgUi5yZXZlcnNlKCdhJyk7ICAgICAgICAvLz0+ICdhJ1xuICogICAgICBSLnJldmVyc2UoJycpOyAgICAgICAgIC8vPT4gJydcbiAqL1xudmFyIHJldmVyc2UgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiByZXZlcnNlKGxpc3QpIHtcbiAgcmV0dXJuIF9pc1N0cmluZyhsaXN0KSA/IGxpc3Quc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIDApLnJldmVyc2UoKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgcmV2ZXJzZTsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIFNjYW4gaXMgc2ltaWxhciB0byBbYHJlZHVjZWBdKCNyZWR1Y2UpLCBidXQgcmV0dXJucyBhIGxpc3Qgb2Ygc3VjY2Vzc2l2ZWx5XG4gKiByZWR1Y2VkIHZhbHVlcyBmcm9tIHRoZSBsZWZ0XG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTAuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhLCBiKSAtPiBhKSAtPiBhIC0+IFtiXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAqICAgICAgICBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7Kn0gYWNjIFRoZSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7QXJyYXl9IEEgbGlzdCBvZiBhbGwgaW50ZXJtZWRpYXRlbHkgcmVkdWNlZCB2YWx1ZXMuXG4gKiBAc2VlIFIucmVkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG51bWJlcnMgPSBbMSwgMiwgMywgNF07XG4gKiAgICAgIHZhciBmYWN0b3JpYWxzID0gUi5zY2FuKFIubXVsdGlwbHksIDEsIG51bWJlcnMpOyAvLz0+IFsxLCAxLCAyLCA2LCAyNF1cbiAqIEBzeW1iIFIuc2NhbihmLCBhLCBbYiwgY10pID0gW2EsIGYoYSwgYiksIGYoZihhLCBiKSwgYyldXG4gKi9cbnZhciBzY2FuID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gc2NhbihmbiwgYWNjLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBbYWNjXTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGFjYyA9IGZuKGFjYywgbGlzdFtpZHhdKTtcbiAgICByZXN1bHRbaWR4ICsgMV0gPSBhY2M7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgc2NhbjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IGFwIGZyb20gJy4vYXAnO1xuaW1wb3J0IG1hcCBmcm9tICcuL21hcCc7XG5pbXBvcnQgcHJlcGVuZCBmcm9tICcuL3ByZXBlbmQnO1xuaW1wb3J0IHJlZHVjZVJpZ2h0IGZyb20gJy4vcmVkdWNlUmlnaHQnO1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBbVHJhdmVyc2FibGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjdHJhdmVyc2FibGUpXG4gKiBvZiBbQXBwbGljYXRpdmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXBwbGljYXRpdmUpIGludG8gYW5cbiAqIEFwcGxpY2F0aXZlIG9mIFRyYXZlcnNhYmxlLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBzZXF1ZW5jZWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKEFwcGxpY2F0aXZlIGYsIFRyYXZlcnNhYmxlIHQpID0+IChhIC0+IGYgYSkgLT4gdCAoZiBhKSAtPiBmICh0IGEpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvZlxuICogQHBhcmFtIHsqfSB0cmF2ZXJzYWJsZVxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi50cmF2ZXJzZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc2VxdWVuY2UoTWF5YmUub2YsIFtKdXN0KDEpLCBKdXN0KDIpLCBKdXN0KDMpXSk7ICAgLy89PiBKdXN0KFsxLCAyLCAzXSlcbiAqICAgICAgUi5zZXF1ZW5jZShNYXliZS5vZiwgW0p1c3QoMSksIEp1c3QoMiksIE5vdGhpbmcoKV0pOyAvLz0+IE5vdGhpbmcoKVxuICpcbiAqICAgICAgUi5zZXF1ZW5jZShSLm9mLCBKdXN0KFsxLCAyLCAzXSkpOyAvLz0+IFtKdXN0KDEpLCBKdXN0KDIpLCBKdXN0KDMpXVxuICogICAgICBSLnNlcXVlbmNlKFIub2YsIE5vdGhpbmcoKSk7ICAgICAgIC8vPT4gW05vdGhpbmcoKV1cbiAqL1xudmFyIHNlcXVlbmNlID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gc2VxdWVuY2Uob2YsIHRyYXZlcnNhYmxlKSB7XG4gIHJldHVybiB0eXBlb2YgdHJhdmVyc2FibGUuc2VxdWVuY2UgPT09ICdmdW5jdGlvbicgPyB0cmF2ZXJzYWJsZS5zZXF1ZW5jZShvZikgOiByZWR1Y2VSaWdodChmdW5jdGlvbiAoeCwgYWNjKSB7XG4gICAgcmV0dXJuIGFwKG1hcChwcmVwZW5kLCB4KSwgYWNjKTtcbiAgfSwgb2YoW10pLCB0cmF2ZXJzYWJsZSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHNlcXVlbmNlOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgYWx3YXlzIGZyb20gJy4vYWx3YXlzJztcbmltcG9ydCBvdmVyIGZyb20gJy4vb3Zlcic7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIFwic2V0dGluZ1wiIHRoZSBwb3J0aW9uIG9mIHRoZSBnaXZlbiBkYXRhIHN0cnVjdHVyZVxuICogZm9jdXNlZCBieSB0aGUgZ2l2ZW4gbGVucyB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAqIEBzaWcgTGVucyBzIGEgLT4gYSAtPiBzIC0+IHNcbiAqIEBwYXJhbSB7TGVuc30gbGVuc1xuICogQHBhcmFtIHsqfSB2XG4gKiBAcGFyYW0geyp9IHhcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIucHJvcCwgUi5sZW5zSW5kZXgsIFIubGVuc1Byb3BcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgeExlbnMgPSBSLmxlbnNQcm9wKCd4Jyk7XG4gKlxuICogICAgICBSLnNldCh4TGVucywgNCwge3g6IDEsIHk6IDJ9KTsgIC8vPT4ge3g6IDQsIHk6IDJ9XG4gKiAgICAgIFIuc2V0KHhMZW5zLCA4LCB7eDogMSwgeTogMn0pOyAgLy89PiB7eDogOCwgeTogMn1cbiAqL1xudmFyIHNldCA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIHNldChsZW5zLCB2LCB4KSB7XG4gIHJldHVybiBvdmVyKGxlbnMsIGFsd2F5cyh2KSwgeCk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHNldDsiLCJpbXBvcnQgX2NoZWNrRm9yTWV0aG9kIGZyb20gJy4vaW50ZXJuYWwvX2NoZWNrRm9yTWV0aG9kJztcbmltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nIChvciBvYmplY3Qgd2l0aCBhIGBzbGljZWBcbiAqIG1ldGhvZCkgZnJvbSBgZnJvbUluZGV4YCAoaW5jbHVzaXZlKSB0byBgdG9JbmRleGAgKGV4Y2x1c2l2ZSkuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHNsaWNlYCBtZXRob2Qgb2YgdGhlIHRoaXJkIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuNFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleCBUaGUgc3RhcnQgaW5kZXggKGluY2x1c2l2ZSkuXG4gKiBAcGFyYW0ge051bWJlcn0gdG9JbmRleCBUaGUgZW5kIGluZGV4IChleGNsdXNpdmUpLlxuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc2xpY2UoMSwgMywgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgICAgLy89PiBbJ2InLCAnYyddXG4gKiAgICAgIFIuc2xpY2UoMSwgSW5maW5pdHksIFsnYScsICdiJywgJ2MnLCAnZCddKTsgLy89PiBbJ2InLCAnYycsICdkJ11cbiAqICAgICAgUi5zbGljZSgwLCAtMSwgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgICAvLz0+IFsnYScsICdiJywgJ2MnXVxuICogICAgICBSLnNsaWNlKC0zLCAtMSwgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgIC8vPT4gWydiJywgJ2MnXVxuICogICAgICBSLnNsaWNlKDAsIDMsICdyYW1kYScpOyAgICAgICAgICAgICAgICAgICAgIC8vPT4gJ3JhbSdcbiAqL1xudmFyIHNsaWNlID0gLyojX19QVVJFX18qL19jdXJyeTMoIC8qI19fUFVSRV9fKi9fY2hlY2tGb3JNZXRob2QoJ3NsaWNlJywgZnVuY3Rpb24gc2xpY2UoZnJvbUluZGV4LCB0b0luZGV4LCBsaXN0KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCBmcm9tSW5kZXgsIHRvSW5kZXgpO1xufSkpO1xuZXhwb3J0IGRlZmF1bHQgc2xpY2U7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgbGlzdCwgc29ydGVkIGFjY29yZGluZyB0byB0aGUgY29tcGFyYXRvciBmdW5jdGlvbixcbiAqIHdoaWNoIHNob3VsZCBhY2NlcHQgdHdvIHZhbHVlcyBhdCBhIHRpbWUgYW5kIHJldHVybiBhIG5lZ2F0aXZlIG51bWJlciBpZiB0aGVcbiAqIGZpcnN0IHZhbHVlIGlzIHNtYWxsZXIsIGEgcG9zaXRpdmUgbnVtYmVyIGlmIGl0J3MgbGFyZ2VyLCBhbmQgemVybyBpZiB0aGV5XG4gKiBhcmUgZXF1YWwuIFBsZWFzZSBub3RlIHRoYXQgdGhpcyBpcyBhICoqY29weSoqIG9mIHRoZSBsaXN0LiBJdCBkb2VzIG5vdFxuICogbW9kaWZ5IHRoZSBvcmlnaW5hbC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSwgYSkgLT4gTnVtYmVyKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIEEgc29ydGluZyBmdW5jdGlvbiA6OiBhIC0+IGIgLT4gSW50XG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIHNvcnRcbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyBhcnJheSB3aXRoIGl0cyBlbGVtZW50cyBzb3J0ZWQgYnkgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGRpZmYgPSBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfTtcbiAqICAgICAgUi5zb3J0KGRpZmYsIFs0LDIsNyw1XSk7IC8vPT4gWzIsIDQsIDUsIDddXG4gKi9cbnZhciBzb3J0ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gc29ydChjb21wYXJhdG9yLCBsaXN0KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCAwKS5zb3J0KGNvbXBhcmF0b3IpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBzb3J0OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogU29ydHMgdGhlIGxpc3QgYWNjb3JkaW5nIHRvIHRoZSBzdXBwbGllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYiA9PiAoYSAtPiBiKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBzb3J0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGxpc3Qgc29ydGVkIGJ5IHRoZSBrZXlzIGdlbmVyYXRlZCBieSBgZm5gLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBzb3J0QnlGaXJzdEl0ZW0gPSBSLnNvcnRCeShSLnByb3AoMCkpO1xuICogICAgICB2YXIgc29ydEJ5TmFtZUNhc2VJbnNlbnNpdGl2ZSA9IFIuc29ydEJ5KFIuY29tcG9zZShSLnRvTG93ZXIsIFIucHJvcCgnbmFtZScpKSk7XG4gKiAgICAgIHZhciBwYWlycyA9IFtbLTEsIDFdLCBbLTIsIDJdLCBbLTMsIDNdXTtcbiAqICAgICAgc29ydEJ5Rmlyc3RJdGVtKHBhaXJzKTsgLy89PiBbWy0zLCAzXSwgWy0yLCAyXSwgWy0xLCAxXV1cbiAqICAgICAgdmFyIGFsaWNlID0ge1xuICogICAgICAgIG5hbWU6ICdBTElDRScsXG4gKiAgICAgICAgYWdlOiAxMDFcbiAqICAgICAgfTtcbiAqICAgICAgdmFyIGJvYiA9IHtcbiAqICAgICAgICBuYW1lOiAnQm9iJyxcbiAqICAgICAgICBhZ2U6IC0xMFxuICogICAgICB9O1xuICogICAgICB2YXIgY2xhcmEgPSB7XG4gKiAgICAgICAgbmFtZTogJ2NsYXJhJyxcbiAqICAgICAgICBhZ2U6IDMxNC4xNTlcbiAqICAgICAgfTtcbiAqICAgICAgdmFyIHBlb3BsZSA9IFtjbGFyYSwgYm9iLCBhbGljZV07XG4gKiAgICAgIHNvcnRCeU5hbWVDYXNlSW5zZW5zaXRpdmUocGVvcGxlKTsgLy89PiBbYWxpY2UsIGJvYiwgY2xhcmFdXG4gKi9cbnZhciBzb3J0QnkgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBzb3J0QnkoZm4sIGxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIDApLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYWEgPSBmbihhKTtcbiAgICB2YXIgYmIgPSBmbihiKTtcbiAgICByZXR1cm4gYWEgPCBiYiA/IC0xIDogYWEgPiBiYiA/IDEgOiAwO1xuICB9KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgc29ydEJ5OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogU29ydHMgYSBsaXN0IGFjY29yZGluZyB0byBhIGxpc3Qgb2YgY29tcGFyYXRvcnMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjMuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIFsoYSwgYSkgLT4gTnVtYmVyXSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0FycmF5fSBmdW5jdGlvbnMgQSBsaXN0IG9mIGNvbXBhcmF0b3IgZnVuY3Rpb25zLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBzb3J0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGxpc3Qgc29ydGVkIGFjY29yZGluZyB0byB0aGUgY29tYXJhdG9yIGZ1bmN0aW9ucy5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYWxpY2UgPSB7XG4gKiAgICAgICAgbmFtZTogJ2FsaWNlJyxcbiAqICAgICAgICBhZ2U6IDQwXG4gKiAgICAgIH07XG4gKiAgICAgIHZhciBib2IgPSB7XG4gKiAgICAgICAgbmFtZTogJ2JvYicsXG4gKiAgICAgICAgYWdlOiAzMFxuICogICAgICB9O1xuICogICAgICB2YXIgY2xhcmEgPSB7XG4gKiAgICAgICAgbmFtZTogJ2NsYXJhJyxcbiAqICAgICAgICBhZ2U6IDQwXG4gKiAgICAgIH07XG4gKiAgICAgIHZhciBwZW9wbGUgPSBbY2xhcmEsIGJvYiwgYWxpY2VdO1xuICogICAgICB2YXIgYWdlTmFtZVNvcnQgPSBSLnNvcnRXaXRoKFtcbiAqICAgICAgICBSLmRlc2NlbmQoUi5wcm9wKCdhZ2UnKSksXG4gKiAgICAgICAgUi5hc2NlbmQoUi5wcm9wKCduYW1lJykpXG4gKiAgICAgIF0pO1xuICogICAgICBhZ2VOYW1lU29ydChwZW9wbGUpOyAvLz0+IFthbGljZSwgY2xhcmEsIGJvYl1cbiAqL1xudmFyIHNvcnRXaXRoID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gc29ydFdpdGgoZm5zLCBsaXN0KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCAwKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChyZXN1bHQgPT09IDAgJiYgaSA8IGZucy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IGZuc1tpXShhLCBiKTtcbiAgICAgIGkgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHNvcnRXaXRoOyIsImltcG9ydCBpbnZva2VyIGZyb20gJy4vaW52b2tlcic7XG5cbi8qKlxuICogU3BsaXRzIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncyBiYXNlZCBvbiB0aGUgZ2l2ZW5cbiAqIHNlcGFyYXRvci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgKFN0cmluZyB8IFJlZ0V4cCkgLT4gU3RyaW5nIC0+IFtTdHJpbmddXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IHNlcCBUaGUgcGF0dGVybi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBzZXBhcmF0ZSBpbnRvIGFuIGFycmF5LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBhcnJheSBvZiBzdHJpbmdzIGZyb20gYHN0cmAgc2VwYXJhdGVkIGJ5IGBzdHJgLlxuICogQHNlZSBSLmpvaW5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgcGF0aENvbXBvbmVudHMgPSBSLnNwbGl0KCcvJyk7XG4gKiAgICAgIFIudGFpbChwYXRoQ29tcG9uZW50cygnL3Vzci9sb2NhbC9iaW4vbm9kZScpKTsgLy89PiBbJ3VzcicsICdsb2NhbCcsICdiaW4nLCAnbm9kZSddXG4gKlxuICogICAgICBSLnNwbGl0KCcuJywgJ2EuYi5jLnh5ei5kJyk7IC8vPT4gWydhJywgJ2InLCAnYycsICd4eXonLCAnZCddXG4gKi9cbnZhciBzcGxpdCA9IC8qI19fUFVSRV9fKi9pbnZva2VyKDEsICdzcGxpdCcpO1xuZXhwb3J0IGRlZmF1bHQgc3BsaXQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBsZW5ndGggZnJvbSAnLi9sZW5ndGgnO1xuaW1wb3J0IHNsaWNlIGZyb20gJy4vc2xpY2UnO1xuXG4vKipcbiAqIFNwbGl0cyBhIGdpdmVuIGxpc3Qgb3Igc3RyaW5nIGF0IGEgZ2l2ZW4gaW5kZXguXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbW2FdLCBbYV1dXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gW1N0cmluZywgU3RyaW5nXVxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCB3aGVyZSB0aGUgYXJyYXkvc3RyaW5nIGlzIHNwbGl0LlxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGFycmF5IFRoZSBhcnJheS9zdHJpbmcgdG8gYmUgc3BsaXQuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnNwbGl0QXQoMSwgWzEsIDIsIDNdKTsgICAgICAgICAgLy89PiBbWzFdLCBbMiwgM11dXG4gKiAgICAgIFIuc3BsaXRBdCg1LCAnaGVsbG8gd29ybGQnKTsgICAgICAvLz0+IFsnaGVsbG8nLCAnIHdvcmxkJ11cbiAqICAgICAgUi5zcGxpdEF0KC0xLCAnZm9vYmFyJyk7ICAgICAgICAgIC8vPT4gWydmb29iYScsICdyJ11cbiAqL1xudmFyIHNwbGl0QXQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBzcGxpdEF0KGluZGV4LCBhcnJheSkge1xuICByZXR1cm4gW3NsaWNlKDAsIGluZGV4LCBhcnJheSksIHNsaWNlKGluZGV4LCBsZW5ndGgoYXJyYXkpLCBhcnJheSldO1xufSk7XG5leHBvcnQgZGVmYXVsdCBzcGxpdEF0OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgc2xpY2UgZnJvbSAnLi9zbGljZSc7XG5cbi8qKlxuICogU3BsaXRzIGEgY29sbGVjdGlvbiBpbnRvIHNsaWNlcyBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFtbYV1dXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gW1N0cmluZ11cbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnNwbGl0RXZlcnkoMywgWzEsIDIsIDMsIDQsIDUsIDYsIDddKTsgLy89PiBbWzEsIDIsIDNdLCBbNCwgNSwgNl0sIFs3XV1cbiAqICAgICAgUi5zcGxpdEV2ZXJ5KDMsICdmb29iYXJiYXonKTsgLy89PiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAqL1xudmFyIHNwbGl0RXZlcnkgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBzcGxpdEV2ZXJ5KG4sIGxpc3QpIHtcbiAgaWYgKG4gPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gc3BsaXRFdmVyeSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgIHJlc3VsdC5wdXNoKHNsaWNlKGlkeCwgaWR4ICs9IG4sIGxpc3QpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5leHBvcnQgZGVmYXVsdCBzcGxpdEV2ZXJ5OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogVGFrZXMgYSBsaXN0IGFuZCBhIHByZWRpY2F0ZSBhbmQgcmV0dXJucyBhIHBhaXIgb2YgbGlzdHMgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogIC0gdGhlIHJlc3VsdCBvZiBjb25jYXRlbmF0aW5nIHRoZSB0d28gb3V0cHV0IGxpc3RzIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGlucHV0IGxpc3Q7XG4gKiAgLSBub25lIG9mIHRoZSBlbGVtZW50cyBvZiB0aGUgZmlyc3Qgb3V0cHV0IGxpc3Qgc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGU7IGFuZFxuICogIC0gaWYgdGhlIHNlY29uZCBvdXRwdXQgbGlzdCBpcyBub24tZW1wdHksIGl0cyBmaXJzdCBlbGVtZW50IHNhdGlzZmllcyB0aGUgcHJlZGljYXRlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbW2FdLCBbYV1dXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIFRoZSBwcmVkaWNhdGUgdGhhdCBkZXRlcm1pbmVzIHdoZXJlIHRoZSBhcnJheSBpcyBzcGxpdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGJlIHNwbGl0LlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5zcGxpdFdoZW4oUi5lcXVhbHMoMiksIFsxLCAyLCAzLCAxLCAyLCAzXSk7ICAgLy89PiBbWzFdLCBbMiwgMywgMSwgMiwgM11dXG4gKi9cbnZhciBzcGxpdFdoZW4gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBzcGxpdFdoZW4ocHJlZCwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcHJlZml4ID0gW107XG5cbiAgd2hpbGUgKGlkeCA8IGxlbiAmJiAhcHJlZChsaXN0W2lkeF0pKSB7XG4gICAgcHJlZml4LnB1c2gobGlzdFtpZHhdKTtcbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIHJldHVybiBbcHJlZml4LCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCBpZHgpXTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgc3BsaXRXaGVuOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgZXF1YWxzIGZyb20gJy4vZXF1YWxzJztcbmltcG9ydCB0YWtlIGZyb20gJy4vdGFrZSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBzdGFydHMgd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWVzXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjQuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IEJvb2xlYW5cbiAqIEBzaWcgU3RyaW5nIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0gcHJlZml4XG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5zdGFydHNXaXRoKCdhJywgJ2FiYycpICAgICAgICAgICAgICAgIC8vPT4gdHJ1ZVxuICogICAgICBSLnN0YXJ0c1dpdGgoJ2InLCAnYWJjJykgICAgICAgICAgICAgICAgLy89PiBmYWxzZVxuICogICAgICBSLnN0YXJ0c1dpdGgoWydhJ10sIFsnYScsICdiJywgJ2MnXSkgICAgLy89PiB0cnVlXG4gKiAgICAgIFIuc3RhcnRzV2l0aChbJ2InXSwgWydhJywgJ2InLCAnYyddKSAgICAvLz0+IGZhbHNlXG4gKi9cbnZhciBzdGFydHNXaXRoID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gKHByZWZpeCwgbGlzdCkge1xuICByZXR1cm4gZXF1YWxzKHRha2UocHJlZml4Lmxlbmd0aCwgbGlzdCksIHByZWZpeCk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHN0YXJ0c1dpdGg7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBTdWJ0cmFjdHMgaXRzIHNlY29uZCBhcmd1bWVudCBmcm9tIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIHZhbHVlLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzdWx0IG9mIGBhIC0gYmAuXG4gKiBAc2VlIFIuYWRkXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5zdWJ0cmFjdCgxMCwgOCk7IC8vPT4gMlxuICpcbiAqICAgICAgdmFyIG1pbnVzNSA9IFIuc3VidHJhY3QoUi5fXywgNSk7XG4gKiAgICAgIG1pbnVzNSgxNyk7IC8vPT4gMTJcbiAqXG4gKiAgICAgIHZhciBjb21wbGVtZW50YXJ5QW5nbGUgPSBSLnN1YnRyYWN0KDkwKTtcbiAqICAgICAgY29tcGxlbWVudGFyeUFuZ2xlKDMwKTsgLy89PiA2MFxuICogICAgICBjb21wbGVtZW50YXJ5QW5nbGUoNzIpOyAvLz0+IDE4XG4gKi9cbnZhciBzdWJ0cmFjdCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIpIHtcbiAgcmV0dXJuIE51bWJlcihhKSAtIE51bWJlcihiKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgc3VidHJhY3Q7IiwiaW1wb3J0IGFkZCBmcm9tICcuL2FkZCc7XG5pbXBvcnQgcmVkdWNlIGZyb20gJy4vcmVkdWNlJztcblxuLyoqXG4gKiBBZGRzIHRvZ2V0aGVyIGFsbCB0aGUgZWxlbWVudHMgb2YgYSBsaXN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgW051bWJlcl0gLT4gTnVtYmVyXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IEFuIGFycmF5IG9mIG51bWJlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIHN1bSBvZiBhbGwgdGhlIG51bWJlcnMgaW4gdGhlIGxpc3QuXG4gKiBAc2VlIFIucmVkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5zdW0oWzIsNCw2LDgsMTAwLDFdKTsgLy89PiAxMjFcbiAqL1xudmFyIHN1bSA9IC8qI19fUFVSRV9fKi9yZWR1Y2UoYWRkLCAwKTtcbmV4cG9ydCBkZWZhdWx0IHN1bTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IGNvbmNhdCBmcm9tICcuL2NvbmNhdCc7XG5pbXBvcnQgZGlmZmVyZW5jZSBmcm9tICcuL2RpZmZlcmVuY2UnO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgb2YgYWxsIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgZmlyc3Qgb3JcbiAqIHNlY29uZCBsaXN0LCBidXQgbm90IGJvdGguXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIFsqXSAtPiBbKl0gLT4gWypdXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgbGlzdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgbGlzdC5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZWxlbWVudHMgaW4gYGxpc3QxYCBvciBgbGlzdDJgLCBidXQgbm90IGJvdGguXG4gKiBAc2VlIFIuc3ltbWV0cmljRGlmZmVyZW5jZVdpdGgsIFIuZGlmZmVyZW5jZSwgUi5kaWZmZXJlbmNlV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc3ltbWV0cmljRGlmZmVyZW5jZShbMSwyLDMsNF0sIFs3LDYsNSw0LDNdKTsgLy89PiBbMSwyLDcsNiw1XVxuICogICAgICBSLnN5bW1ldHJpY0RpZmZlcmVuY2UoWzcsNiw1LDQsM10sIFsxLDIsMyw0XSk7IC8vPT4gWzcsNiw1LDEsMl1cbiAqL1xudmFyIHN5bW1ldHJpY0RpZmZlcmVuY2UgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBzeW1tZXRyaWNEaWZmZXJlbmNlKGxpc3QxLCBsaXN0Mikge1xuICByZXR1cm4gY29uY2F0KGRpZmZlcmVuY2UobGlzdDEsIGxpc3QyKSwgZGlmZmVyZW5jZShsaXN0MiwgbGlzdDEpKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgc3ltbWV0cmljRGlmZmVyZW5jZTsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuaW1wb3J0IGNvbmNhdCBmcm9tICcuL2NvbmNhdCc7XG5pbXBvcnQgZGlmZmVyZW5jZVdpdGggZnJvbSAnLi9kaWZmZXJlbmNlV2l0aCc7XG5cbi8qKlxuICogRmluZHMgdGhlIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBvZiBhbGwgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBmaXJzdCBvclxuICogc2Vjb25kIGxpc3QsIGJ1dCBub3QgYm90aC4gRHVwbGljYXRpb24gaXMgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlXG4gKiByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIHR3byBsaXN0IGVsZW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyAoKGEsIGEpIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHVzZWQgdG8gdGVzdCB3aGV0aGVyIHR3byBpdGVtcyBhcmUgZXF1YWwuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgbGlzdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgbGlzdC5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZWxlbWVudHMgaW4gYGxpc3QxYCBvciBgbGlzdDJgLCBidXQgbm90IGJvdGguXG4gKiBAc2VlIFIuc3ltbWV0cmljRGlmZmVyZW5jZSwgUi5kaWZmZXJlbmNlLCBSLmRpZmZlcmVuY2VXaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGVxQSA9IFIuZXFCeShSLnByb3AoJ2EnKSk7XG4gKiAgICAgIHZhciBsMSA9IFt7YTogMX0sIHthOiAyfSwge2E6IDN9LCB7YTogNH1dO1xuICogICAgICB2YXIgbDIgPSBbe2E6IDN9LCB7YTogNH0sIHthOiA1fSwge2E6IDZ9XTtcbiAqICAgICAgUi5zeW1tZXRyaWNEaWZmZXJlbmNlV2l0aChlcUEsIGwxLCBsMik7IC8vPT4gW3thOiAxfSwge2E6IDJ9LCB7YTogNX0sIHthOiA2fV1cbiAqL1xudmFyIHN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gc3ltbWV0cmljRGlmZmVyZW5jZVdpdGgocHJlZCwgbGlzdDEsIGxpc3QyKSB7XG4gIHJldHVybiBjb25jYXQoZGlmZmVyZW5jZVdpdGgocHJlZCwgbGlzdDEsIGxpc3QyKSwgZGlmZmVyZW5jZVdpdGgocHJlZCwgbGlzdDIsIGxpc3QxKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoOyIsImltcG9ydCBfY2hlY2tGb3JNZXRob2QgZnJvbSAnLi9pbnRlcm5hbC9fY2hlY2tGb3JNZXRob2QnO1xuaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBzbGljZSBmcm9tICcuL3NsaWNlJztcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nIChvciBvYmplY3RcbiAqIHdpdGggYSBgdGFpbGAgbWV0aG9kKS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgc2xpY2VgIG1ldGhvZCBvZiB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2FdXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7Kn0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5oZWFkLCBSLmluaXQsIFIubGFzdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudGFpbChbMSwgMiwgM10pOyAgLy89PiBbMiwgM11cbiAqICAgICAgUi50YWlsKFsxLCAyXSk7ICAgICAvLz0+IFsyXVxuICogICAgICBSLnRhaWwoWzFdKTsgICAgICAgIC8vPT4gW11cbiAqICAgICAgUi50YWlsKFtdKTsgICAgICAgICAvLz0+IFtdXG4gKlxuICogICAgICBSLnRhaWwoJ2FiYycpOyAgLy89PiAnYmMnXG4gKiAgICAgIFIudGFpbCgnYWInKTsgICAvLz0+ICdiJ1xuICogICAgICBSLnRhaWwoJ2EnKTsgICAgLy89PiAnJ1xuICogICAgICBSLnRhaWwoJycpOyAgICAgLy89PiAnJ1xuICovXG52YXIgdGFpbCA9IC8qI19fUFVSRV9fKi9fY3VycnkxKCAvKiNfX1BVUkVfXyovX2NoZWNrRm9yTWV0aG9kKCd0YWlsJywgLyojX19QVVJFX18qL3NsaWNlKDEsIEluZmluaXR5KSkpO1xuZXhwb3J0IGRlZmF1bHQgdGFpbDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSAnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJztcbmltcG9ydCBfeHRha2UgZnJvbSAnLi9pbnRlcm5hbC9feHRha2UnO1xuaW1wb3J0IHNsaWNlIGZyb20gJy4vc2xpY2UnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGBuYCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gbGlzdCwgc3RyaW5nLCBvclxuICogdHJhbnNkdWNlci90cmFuc2Zvcm1lciAob3Igb2JqZWN0IHdpdGggYSBgdGFrZWAgbWV0aG9kKS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgdGFrZWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEBwYXJhbSB7Kn0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5kcm9wXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50YWtlKDEsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nXVxuICogICAgICBSLnRha2UoMiwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbycsICdiYXInXVxuICogICAgICBSLnRha2UoMywgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAqICAgICAgUi50YWtlKDQsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gKiAgICAgIFIudGFrZSgzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAvLz0+ICdyYW0nXG4gKlxuICogICAgICB2YXIgcGVyc29ubmVsID0gW1xuICogICAgICAgICdEYXZlIEJydWJlY2snLFxuICogICAgICAgICdQYXVsIERlc21vbmQnLFxuICogICAgICAgICdFdWdlbmUgV3JpZ2h0JyxcbiAqICAgICAgICAnSm9lIE1vcmVsbG8nLFxuICogICAgICAgICdHZXJyeSBNdWxsaWdhbicsXG4gKiAgICAgICAgJ0JvYiBCYXRlcycsXG4gKiAgICAgICAgJ0pvZSBEb2RnZScsXG4gKiAgICAgICAgJ1JvbiBDcm90dHknXG4gKiAgICAgIF07XG4gKlxuICogICAgICB2YXIgdGFrZUZpdmUgPSBSLnRha2UoNSk7XG4gKiAgICAgIHRha2VGaXZlKHBlcnNvbm5lbCk7XG4gKiAgICAgIC8vPT4gWydEYXZlIEJydWJlY2snLCAnUGF1bCBEZXNtb25kJywgJ0V1Z2VuZSBXcmlnaHQnLCAnSm9lIE1vcmVsbG8nLCAnR2VycnkgTXVsbGlnYW4nXVxuICogQHN5bWIgUi50YWtlKC0xLCBbYSwgYl0pID0gW2EsIGJdXG4gKiBAc3ltYiBSLnRha2UoMCwgW2EsIGJdKSA9IFtdXG4gKiBAc3ltYiBSLnRha2UoMSwgW2EsIGJdKSA9IFthXVxuICogQHN5bWIgUi50YWtlKDIsIFthLCBiXSkgPSBbYSwgYl1cbiAqL1xudmFyIHRha2UgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoWyd0YWtlJ10sIF94dGFrZSwgZnVuY3Rpb24gdGFrZShuLCB4cykge1xuICByZXR1cm4gc2xpY2UoMCwgbiA8IDAgPyBJbmZpbml0eSA6IG4sIHhzKTtcbn0pKTtcbmV4cG9ydCBkZWZhdWx0IHRha2U7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBkcm9wIGZyb20gJy4vZHJvcCc7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIGxhc3QgYG5gIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBsaXN0LlxuICogSWYgYG4gPiBsaXN0Lmxlbmd0aGAsIHJldHVybnMgYSBsaXN0IG9mIGBsaXN0Lmxlbmd0aGAgZWxlbWVudHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLlxuICogQHBhcmFtIHtBcnJheX0geHMgVGhlIGNvbGxlY3Rpb24gdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBzZWUgUi5kcm9wTGFzdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudGFrZUxhc3QoMSwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2JheiddXG4gKiAgICAgIFIudGFrZUxhc3QoMiwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2JhcicsICdiYXonXVxuICogICAgICBSLnRha2VMYXN0KDMsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gKiAgICAgIFIudGFrZUxhc3QoNCwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAqICAgICAgUi50YWtlTGFzdCgzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAvLz0+ICdtZGEnXG4gKi9cbnZhciB0YWtlTGFzdCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHRha2VMYXN0KG4sIHhzKSB7XG4gIHJldHVybiBkcm9wKG4gPj0gMCA/IHhzLmxlbmd0aCAtIG4gOiAwLCB4cyk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHRha2VMYXN0OyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgc2xpY2UgZnJvbSAnLi9zbGljZSc7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gbGlzdCwgcGFzc2luZ1xuICogZWFjaCB2YWx1ZSB0byB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIGZ1bmN0aW9uLCBhbmQgdGVybWluYXRpbmcgd2hlbiB0aGVcbiAqIHByZWRpY2F0ZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAuIEV4Y2x1ZGVzIHRoZSBlbGVtZW50IHRoYXQgY2F1c2VkIHRoZVxuICogcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGZhaWwuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gaXMgcGFzc2VkIG9uZSBhcmd1bWVudDpcbiAqICoodmFsdWUpKi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IHhzIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBhcnJheS5cbiAqIEBzZWUgUi5kcm9wTGFzdFdoaWxlLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGlzTm90T25lID0geCA9PiB4ICE9PSAxO1xuICpcbiAqICAgICAgUi50YWtlTGFzdFdoaWxlKGlzTm90T25lLCBbMSwgMiwgMywgNF0pOyAvLz0+IFsyLCAzLCA0XVxuICpcbiAqICAgICAgUi50YWtlTGFzdFdoaWxlKHggPT4geCAhPT0gJ1InICwgJ1JhbWRhJyk7IC8vPT4gJ2FtZGEnXG4gKi9cbnZhciB0YWtlTGFzdFdoaWxlID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gdGFrZUxhc3RXaGlsZShmbiwgeHMpIHtcbiAgdmFyIGlkeCA9IHhzLmxlbmd0aCAtIDE7XG4gIHdoaWxlIChpZHggPj0gMCAmJiBmbih4c1tpZHhdKSkge1xuICAgIGlkeCAtPSAxO1xuICB9XG4gIHJldHVybiBzbGljZShpZHggKyAxLCBJbmZpbml0eSwgeHMpO1xufSk7XG5leHBvcnQgZGVmYXVsdCB0YWtlTGFzdFdoaWxlOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tICcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnO1xuaW1wb3J0IF94dGFrZVdoaWxlIGZyb20gJy4vaW50ZXJuYWwvX3h0YWtlV2hpbGUnO1xuaW1wb3J0IHNsaWNlIGZyb20gJy4vc2xpY2UnO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBmaXJzdCBgbmAgZWxlbWVudHMgb2YgYSBnaXZlbiBsaXN0LFxuICogcGFzc2luZyBlYWNoIHZhbHVlIHRvIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgZnVuY3Rpb24sIGFuZCB0ZXJtaW5hdGluZyB3aGVuXG4gKiB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC4gRXhjbHVkZXMgdGhlIGVsZW1lbnQgdGhhdCBjYXVzZWQgdGhlXG4gKiBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gZmFpbC4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiBpcyBwYXNzZWQgb25lIGFyZ3VtZW50OlxuICogKih2YWx1ZSkqLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGB0YWtlV2hpbGVgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtBcnJheX0geHMgVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICogQHNlZSBSLmRyb3BXaGlsZSwgUi50cmFuc2R1Y2UsIFIuYWRkSW5kZXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaXNOb3RGb3VyID0geCA9PiB4ICE9PSA0O1xuICpcbiAqICAgICAgUi50YWtlV2hpbGUoaXNOb3RGb3VyLCBbMSwgMiwgMywgNCwgMywgMiwgMV0pOyAvLz0+IFsxLCAyLCAzXVxuICpcbiAqICAgICAgUi50YWtlV2hpbGUoeCA9PiB4ICE9PSAnZCcgLCAnUmFtZGEnKTsgLy89PiAnUmFtJ1xuICovXG52YXIgdGFrZVdoaWxlID0gLyojX19QVVJFX18qL19jdXJyeTIoIC8qI19fUFVSRV9fKi9fZGlzcGF0Y2hhYmxlKFsndGFrZVdoaWxlJ10sIF94dGFrZVdoaWxlLCBmdW5jdGlvbiB0YWtlV2hpbGUoZm4sIHhzKSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0geHMubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgbGVuICYmIGZuKHhzW2lkeF0pKSB7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHNsaWNlKDAsIGlkeCwgeHMpO1xufSkpO1xuZXhwb3J0IGRlZmF1bHQgdGFrZVdoaWxlOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tICcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnO1xuaW1wb3J0IF94dGFwIGZyb20gJy4vaW50ZXJuYWwvX3h0YXAnO1xuXG4vKipcbiAqIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIG9iamVjdCwgdGhlbiByZXR1cm5zIHRoZSBvYmplY3QuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBhcyBzZWNvbmQgcGFyYW1ldGVyLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIChhIC0+ICopIC0+IGEgLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBgeGAuIFRoZSByZXR1cm4gdmFsdWUgb2YgYGZuYCB3aWxsIGJlIHRocm93biBhd2F5LlxuICogQHBhcmFtIHsqfSB4XG4gKiBAcmV0dXJuIHsqfSBgeGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHNheVggPSB4ID0+IGNvbnNvbGUubG9nKCd4IGlzICcgKyB4KTtcbiAqICAgICAgUi50YXAoc2F5WCwgMTAwKTsgLy89PiAxMDBcbiAqICAgICAgLy8gbG9ncyAneCBpcyAxMDAnXG4gKiBAc3ltYiBSLnRhcChmLCBhKSA9IGFcbiAqL1xudmFyIHRhcCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovX2Rpc3BhdGNoYWJsZShbXSwgX3h0YXAsIGZ1bmN0aW9uIHRhcChmbiwgeCkge1xuICBmbih4KTtcbiAgcmV0dXJuIHg7XG59KSk7XG5leHBvcnQgZGVmYXVsdCB0YXA7IiwiaW1wb3J0IF9jbG9uZVJlZ0V4cCBmcm9tICcuL2ludGVybmFsL19jbG9uZVJlZ0V4cCc7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IF9pc1JlZ0V4cCBmcm9tICcuL2ludGVybmFsL19pc1JlZ0V4cCc7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZyc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgZ2l2ZW4gc3RyaW5nIG1hdGNoZXMgYSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTIuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHNpZyBSZWdFeHAgLT4gU3RyaW5nIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7UmVnRXhwfSBwYXR0ZXJuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLm1hdGNoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50ZXN0KC9eeC8sICd4eXonKTsgLy89PiB0cnVlXG4gKiAgICAgIFIudGVzdCgvXnkvLCAneHl6Jyk7IC8vPT4gZmFsc2VcbiAqL1xudmFyIHRlc3QgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiB0ZXN0KHBhdHRlcm4sIHN0cikge1xuICBpZiAoIV9pc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ+KAmHRlc3TigJkgcmVxdWlyZXMgYSB2YWx1ZSBvZiB0eXBlIFJlZ0V4cCBhcyBpdHMgZmlyc3QgYXJndW1lbnQ7IHJlY2VpdmVkICcgKyB0b1N0cmluZyhwYXR0ZXJuKSk7XG4gIH1cbiAgcmV0dXJuIF9jbG9uZVJlZ0V4cChwYXR0ZXJuKS50ZXN0KHN0cik7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHRlc3Q7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBDYWxscyBhbiBpbnB1dCBmdW5jdGlvbiBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBjb250YWluaW5nIHRoZSByZXN1bHRzXG4gKiBvZiB0aG9zZSBmdW5jdGlvbiBjYWxscy5cbiAqXG4gKiBgZm5gIGlzIHBhc3NlZCBvbmUgYXJndW1lbnQ6IFRoZSBjdXJyZW50IHZhbHVlIG9mIGBuYCwgd2hpY2ggYmVnaW5zIGF0IGAwYFxuICogYW5kIGlzIGdyYWR1YWxseSBpbmNyZW1lbnRlZCB0byBgbiAtIDFgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuM1xuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKE51bWJlciAtPiBhKSAtPiBOdW1iZXIgLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLiBQYXNzZWQgb25lIGFyZ3VtZW50LCB0aGUgY3VycmVudCB2YWx1ZSBvZiBgbmAuXG4gKiBAcGFyYW0ge051bWJlcn0gbiBBIHZhbHVlIGJldHdlZW4gYDBgIGFuZCBgbiAtIDFgLiBJbmNyZW1lbnRzIGFmdGVyIGVhY2ggZnVuY3Rpb24gY2FsbC5cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBjb250YWluaW5nIHRoZSByZXR1cm4gdmFsdWVzIG9mIGFsbCBjYWxscyB0byBgZm5gLlxuICogQHNlZSBSLnJlcGVhdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudGltZXMoUi5pZGVudGl0eSwgNSk7IC8vPT4gWzAsIDEsIDIsIDMsIDRdXG4gKiBAc3ltYiBSLnRpbWVzKGYsIDApID0gW11cbiAqIEBzeW1iIFIudGltZXMoZiwgMSkgPSBbZigwKV1cbiAqIEBzeW1iIFIudGltZXMoZiwgMikgPSBbZigwKSwgZigxKV1cbiAqL1xudmFyIHRpbWVzID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gdGltZXMoZm4sIG4pIHtcbiAgdmFyIGxlbiA9IE51bWJlcihuKTtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsaXN0O1xuXG4gIGlmIChsZW4gPCAwIHx8IGlzTmFOKGxlbikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbiBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpO1xuICB9XG4gIGxpc3QgPSBuZXcgQXJyYXkobGVuKTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGxpc3RbaWR4XSA9IGZuKGlkeCk7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHRpbWVzOyIsImltcG9ydCBpbnZva2VyIGZyb20gJy4vaW52b2tlcic7XG5cbi8qKlxuICogVGhlIGxvd2VyIGNhc2UgdmVyc2lvbiBvZiBhIHN0cmluZy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGxvd2VyIGNhc2UuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBsb3dlciBjYXNlIHZlcnNpb24gb2YgYHN0cmAuXG4gKiBAc2VlIFIudG9VcHBlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudG9Mb3dlcignWFlaJyk7IC8vPT4gJ3h5eidcbiAqL1xudmFyIHRvTG93ZXIgPSAvKiNfX1BVUkVfXyovaW52b2tlcigwLCAndG9Mb3dlckNhc2UnKTtcbmV4cG9ydCBkZWZhdWx0IHRvTG93ZXI7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBfaGFzIGZyb20gJy4vaW50ZXJuYWwvX2hhcyc7XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYW4gYXJyYXkgb2Yga2V5LCB2YWx1ZSBhcnJheXMuIE9ubHkgdGhlIG9iamVjdCdzXG4gKiBvd24gcHJvcGVydGllcyBhcmUgdXNlZC5cbiAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBjb25zaXN0ZW50XG4gKiBhY3Jvc3MgZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC40LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge1N0cmluZzogKn0gLT4gW1tTdHJpbmcsKl1dXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2Yga2V5LCB2YWx1ZSBhcnJheXMgZnJvbSB0aGUgb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gKiBAc2VlIFIuZnJvbVBhaXJzXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50b1BhaXJzKHthOiAxLCBiOiAyLCBjOiAzfSk7IC8vPT4gW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dXG4gKi9cbnZhciB0b1BhaXJzID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gdG9QYWlycyhvYmopIHtcbiAgdmFyIHBhaXJzID0gW107XG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYgKF9oYXMocHJvcCwgb2JqKSkge1xuICAgICAgcGFpcnNbcGFpcnMubGVuZ3RoXSA9IFtwcm9wLCBvYmpbcHJvcF1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFpcnM7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHRvUGFpcnM7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cy4gVGhlIG9iamVjdCdzIG93blxuICogcHJvcGVydGllcyBhbmQgcHJvdG90eXBlIHByb3BlcnRpZXMgYXJlIHVzZWQuIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlXG4gKiBvdXRwdXQgYXJyYXkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgY29uc2lzdGVudCBhY3Jvc3MgZGlmZmVyZW50IEpTXG4gKiBwbGF0Zm9ybXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtTdHJpbmc6ICp9IC0+IFtbU3RyaW5nLCpdXVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIGtleSwgdmFsdWUgYXJyYXlzIGZyb20gdGhlIG9iamVjdCdzIG93blxuICogICAgICAgICBhbmQgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIEYgPSBmdW5jdGlvbigpIHsgdGhpcy54ID0gJ1gnOyB9O1xuICogICAgICBGLnByb3RvdHlwZS55ID0gJ1knO1xuICogICAgICB2YXIgZiA9IG5ldyBGKCk7XG4gKiAgICAgIFIudG9QYWlyc0luKGYpOyAvLz0+IFtbJ3gnLCdYJ10sIFsneScsJ1knXV1cbiAqL1xudmFyIHRvUGFpcnNJbiA9IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIHRvUGFpcnNJbihvYmopIHtcbiAgdmFyIHBhaXJzID0gW107XG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgcGFpcnNbcGFpcnMubGVuZ3RoXSA9IFtwcm9wLCBvYmpbcHJvcF1dO1xuICB9XG4gIHJldHVybiBwYWlycztcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdG9QYWlyc0luOyIsImltcG9ydCBfY3VycnkxIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5MSc7XG5pbXBvcnQgX3RvU3RyaW5nIGZyb20gJy4vaW50ZXJuYWwvX3RvU3RyaW5nJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHZhbHVlLiBgZXZhbGAnaW5nIHRoZSBvdXRwdXRcbiAqIHNob3VsZCByZXN1bHQgaW4gYSB2YWx1ZSBlcXVpdmFsZW50IHRvIHRoZSBpbnB1dCB2YWx1ZS4gTWFueSBvZiB0aGUgYnVpbHQtaW5cbiAqIGB0b1N0cmluZ2AgbWV0aG9kcyBkbyBub3Qgc2F0aXNmeSB0aGlzIHJlcXVpcmVtZW50LlxuICpcbiAqIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBgW29iamVjdCBPYmplY3RdYCB3aXRoIGEgYHRvU3RyaW5nYCBtZXRob2Qgb3RoZXJcbiAqIHRoYW4gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLCB0aGlzIG1ldGhvZCBpcyBpbnZva2VkIHdpdGggbm8gYXJndW1lbnRzXG4gKiB0byBwcm9kdWNlIHRoZSByZXR1cm4gdmFsdWUuIFRoaXMgbWVhbnMgdXNlci1kZWZpbmVkIGNvbnN0cnVjdG9yIGZ1bmN0aW9uc1xuICogY2FuIHByb3ZpZGUgYSBzdWl0YWJsZSBgdG9TdHJpbmdgIG1ldGhvZC4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAqICAgICAgIHRoaXMueCA9IHg7XG4gKiAgICAgICB0aGlzLnkgPSB5O1xuICogICAgIH1cbiAqXG4gKiAgICAgUG9pbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gJ25ldyBQb2ludCgnICsgdGhpcy54ICsgJywgJyArIHRoaXMueSArICcpJztcbiAqICAgICB9O1xuICpcbiAqICAgICBSLnRvU3RyaW5nKG5ldyBQb2ludCgxLCAyKSk7IC8vPT4gJ25ldyBQb2ludCgxLCAyKSdcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnICogLT4gU3RyaW5nXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudG9TdHJpbmcoNDIpOyAvLz0+ICc0MidcbiAqICAgICAgUi50b1N0cmluZygnYWJjJyk7IC8vPT4gJ1wiYWJjXCInXG4gKiAgICAgIFIudG9TdHJpbmcoWzEsIDIsIDNdKTsgLy89PiAnWzEsIDIsIDNdJ1xuICogICAgICBSLnRvU3RyaW5nKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSk7IC8vPT4gJ3tcImJhclwiOiAyLCBcImJhelwiOiAzLCBcImZvb1wiOiAxfSdcbiAqICAgICAgUi50b1N0cmluZyhuZXcgRGF0ZSgnMjAwMS0wMi0wM1QwNDowNTowNlonKSk7IC8vPT4gJ25ldyBEYXRlKFwiMjAwMS0wMi0wM1QwNDowNTowNi4wMDBaXCIpJ1xuICovXG52YXIgdG9TdHJpbmcgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiB0b1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIF90b1N0cmluZyh2YWwsIFtdKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdG9TdHJpbmc7IiwiaW1wb3J0IGludm9rZXIgZnJvbSAnLi9pbnZva2VyJztcblxuLyoqXG4gKiBUaGUgdXBwZXIgY2FzZSB2ZXJzaW9uIG9mIGEgc3RyaW5nLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdXBwZXIgY2FzZS5cbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHVwcGVyIGNhc2UgdmVyc2lvbiBvZiBgc3RyYC5cbiAqIEBzZWUgUi50b0xvd2VyXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50b1VwcGVyKCdhYmMnKTsgLy89PiAnQUJDJ1xuICovXG52YXIgdG9VcHBlciA9IC8qI19fUFVSRV9fKi9pbnZva2VyKDAsICd0b1VwcGVyQ2FzZScpO1xuZXhwb3J0IGRlZmF1bHQgdG9VcHBlcjsiLCJpbXBvcnQgX3JlZHVjZSBmcm9tICcuL2ludGVybmFsL19yZWR1Y2UnO1xuaW1wb3J0IF94d3JhcCBmcm9tICcuL2ludGVybmFsL194d3JhcCc7XG5pbXBvcnQgY3VycnlOIGZyb20gJy4vY3VycnlOJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIHRyYW5zZHVjZXIgdXNpbmcgc3VwcGxpZWQgaXRlcmF0b3IgZnVuY3Rpb24uIFJldHVybnMgYSBzaW5nbGVcbiAqIGl0ZW0gYnkgaXRlcmF0aW5nIHRocm91Z2ggdGhlIGxpc3QsIHN1Y2Nlc3NpdmVseSBjYWxsaW5nIHRoZSB0cmFuc2Zvcm1lZFxuICogaXRlcmF0b3IgZnVuY3Rpb24gYW5kIHBhc3NpbmcgaXQgYW4gYWNjdW11bGF0b3IgdmFsdWUgYW5kIHRoZSBjdXJyZW50IHZhbHVlXG4gKiBmcm9tIHRoZSBhcnJheSwgYW5kIHRoZW4gcGFzc2luZyB0aGUgcmVzdWx0IHRvIHRoZSBuZXh0IGNhbGwuXG4gKlxuICogVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byB2YWx1ZXM6ICooYWNjLCB2YWx1ZSkqLiBJdCB3aWxsIGJlXG4gKiB3cmFwcGVkIGFzIGEgdHJhbnNmb3JtZXIgdG8gaW5pdGlhbGl6ZSB0aGUgdHJhbnNkdWNlci4gQSB0cmFuc2Zvcm1lciBjYW4gYmVcbiAqIHBhc3NlZCBkaXJlY3RseSBpbiBwbGFjZSBvZiBhbiBpdGVyYXRvciBmdW5jdGlvbi4gSW4gYm90aCBjYXNlcywgaXRlcmF0aW9uXG4gKiBtYXkgYmUgc3RvcHBlZCBlYXJseSB3aXRoIHRoZSBbYFIucmVkdWNlZGBdKCNyZWR1Y2VkKSBmdW5jdGlvbi5cbiAqXG4gKiBBIHRyYW5zZHVjZXIgaXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYSB0cmFuc2Zvcm1lciBhbmQgcmV0dXJucyBhXG4gKiB0cmFuc2Zvcm1lciBhbmQgY2FuIGJlIGNvbXBvc2VkIGRpcmVjdGx5LlxuICpcbiAqIEEgdHJhbnNmb3JtZXIgaXMgYW4gYW4gb2JqZWN0IHRoYXQgcHJvdmlkZXMgYSAyLWFyaXR5IHJlZHVjaW5nIGl0ZXJhdG9yXG4gKiBmdW5jdGlvbiwgc3RlcCwgMC1hcml0eSBpbml0aWFsIHZhbHVlIGZ1bmN0aW9uLCBpbml0LCBhbmQgMS1hcml0eSByZXN1bHRcbiAqIGV4dHJhY3Rpb24gZnVuY3Rpb24sIHJlc3VsdC4gVGhlIHN0ZXAgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgaXRlcmF0b3JcbiAqIGZ1bmN0aW9uIGluIHJlZHVjZS4gVGhlIHJlc3VsdCBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbnZlcnQgdGhlIGZpbmFsXG4gKiBhY2N1bXVsYXRvciBpbnRvIHRoZSByZXR1cm4gdHlwZSBhbmQgaW4gbW9zdCBjYXNlcyBpc1xuICogW2BSLmlkZW50aXR5YF0oI2lkZW50aXR5KS4gVGhlIGluaXQgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gcHJvdmlkZSBhblxuICogaW5pdGlhbCBhY2N1bXVsYXRvciwgYnV0IGlzIGlnbm9yZWQgYnkgdHJhbnNkdWNlLlxuICpcbiAqIFRoZSBpdGVyYXRpb24gaXMgcGVyZm9ybWVkIHdpdGggW2BSLnJlZHVjZWBdKCNyZWR1Y2UpIGFmdGVyIGluaXRpYWxpemluZyB0aGUgdHJhbnNkdWNlci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYyAtPiBjKSAtPiAoKGEsIGIpIC0+IGEpIC0+IGEgLT4gW2JdIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHhmIFRoZSB0cmFuc2R1Y2VyIGZ1bmN0aW9uLiBSZWNlaXZlcyBhIHRyYW5zZm9ybWVyIGFuZCByZXR1cm5zIGEgdHJhbnNmb3JtZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIFJlY2VpdmVzIHR3byB2YWx1ZXMsIHRoZSBhY2N1bXVsYXRvciBhbmQgdGhlXG4gKiAgICAgICAgY3VycmVudCBlbGVtZW50IGZyb20gdGhlIGFycmF5LiBXcmFwcGVkIGFzIHRyYW5zZm9ybWVyLCBpZiBuZWNlc3NhcnksIGFuZCB1c2VkIHRvXG4gKiAgICAgICAgaW5pdGlhbGl6ZSB0aGUgdHJhbnNkdWNlclxuICogQHBhcmFtIHsqfSBhY2MgVGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIFIucmVkdWNlLCBSLnJlZHVjZWQsIFIuaW50b1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBudW1iZXJzID0gWzEsIDIsIDMsIDRdO1xuICogICAgICB2YXIgdHJhbnNkdWNlciA9IFIuY29tcG9zZShSLm1hcChSLmFkZCgxKSksIFIudGFrZSgyKSk7XG4gKiAgICAgIFIudHJhbnNkdWNlKHRyYW5zZHVjZXIsIFIuZmxpcChSLmFwcGVuZCksIFtdLCBudW1iZXJzKTsgLy89PiBbMiwgM11cbiAqXG4gKiAgICAgIHZhciBpc09kZCA9ICh4KSA9PiB4ICUgMiA9PT0gMTtcbiAqICAgICAgdmFyIGZpcnN0T2RkVHJhbnNkdWNlciA9IFIuY29tcG9zZShSLmZpbHRlcihpc09kZCksIFIudGFrZSgxKSk7XG4gKiAgICAgIFIudHJhbnNkdWNlKGZpcnN0T2RkVHJhbnNkdWNlciwgUi5mbGlwKFIuYXBwZW5kKSwgW10sIFIucmFuZ2UoMCwgMTAwKSk7IC8vPT4gWzFdXG4gKi9cbnZhciB0cmFuc2R1Y2UgPSAvKiNfX1BVUkVfXyovY3VycnlOKDQsIGZ1bmN0aW9uIHRyYW5zZHVjZSh4ZiwgZm4sIGFjYywgbGlzdCkge1xuICByZXR1cm4gX3JlZHVjZSh4Zih0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBfeHdyYXAoZm4pIDogZm4pLCBhY2MsIGxpc3QpO1xufSk7XG5leHBvcnQgZGVmYXVsdCB0cmFuc2R1Y2U7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcblxuLyoqXG4gKiBUcmFuc3Bvc2VzIHRoZSByb3dzIGFuZCBjb2x1bW5zIG9mIGEgMkQgbGlzdC5cbiAqIFdoZW4gcGFzc2VkIGEgbGlzdCBvZiBgbmAgbGlzdHMgb2YgbGVuZ3RoIGB4YCxcbiAqIHJldHVybnMgYSBsaXN0IG9mIGB4YCBsaXN0cyBvZiBsZW5ndGggYG5gLlxuICpcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbW2FdXSAtPiBbW2FdXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBBIDJEIGxpc3RcbiAqIEByZXR1cm4ge0FycmF5fSBBIDJEIGxpc3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRyYW5zcG9zZShbWzEsICdhJ10sIFsyLCAnYiddLCBbMywgJ2MnXV0pIC8vPT4gW1sxLCAyLCAzXSwgWydhJywgJ2InLCAnYyddXVxuICogICAgICBSLnRyYW5zcG9zZShbWzEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ11dKSAvLz0+IFtbMSwgJ2EnXSwgWzIsICdiJ10sIFszLCAnYyddXVxuICpcbiAqICAgICAgLy8gSWYgc29tZSBvZiB0aGUgcm93cyBhcmUgc2hvcnRlciB0aGFuIHRoZSBmb2xsb3dpbmcgcm93cywgdGhlaXIgZWxlbWVudHMgYXJlIHNraXBwZWQ6XG4gKiAgICAgIFIudHJhbnNwb3NlKFtbMTAsIDExXSwgWzIwXSwgW10sIFszMCwgMzEsIDMyXV0pIC8vPT4gW1sxMCwgMjAsIDMwXSwgWzExLCAzMV0sIFszMl1dXG4gKiBAc3ltYiBSLnRyYW5zcG9zZShbW2FdLCBbYl0sIFtjXV0pID0gW2EsIGIsIGNdXG4gKiBAc3ltYiBSLnRyYW5zcG9zZShbW2EsIGJdLCBbYywgZF1dKSA9IFtbYSwgY10sIFtiLCBkXV1cbiAqIEBzeW1iIFIudHJhbnNwb3NlKFtbYSwgYl0sIFtjXV0pID0gW1thLCBjXSwgW2JdXVxuICovXG52YXIgdHJhbnNwb3NlID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gdHJhbnNwb3NlKG91dGVybGlzdCkge1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKGkgPCBvdXRlcmxpc3QubGVuZ3RoKSB7XG4gICAgdmFyIGlubmVybGlzdCA9IG91dGVybGlzdFtpXTtcbiAgICB2YXIgaiA9IDA7XG4gICAgd2hpbGUgKGogPCBpbm5lcmxpc3QubGVuZ3RoKSB7XG4gICAgICBpZiAodHlwZW9mIHJlc3VsdFtqXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmVzdWx0W2pdID0gW107XG4gICAgICB9XG4gICAgICByZXN1bHRbal0ucHVzaChpbm5lcmxpc3Rbal0pO1xuICAgICAgaiArPSAxO1xuICAgIH1cbiAgICBpICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdHJhbnNwb3NlOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5pbXBvcnQgbWFwIGZyb20gJy4vbWFwJztcbmltcG9ydCBzZXF1ZW5jZSBmcm9tICcuL3NlcXVlbmNlJztcblxuLyoqXG4gKiBNYXBzIGFuIFtBcHBsaWNhdGl2ZV0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhcHBsaWNhdGl2ZSktcmV0dXJuaW5nXG4gKiBmdW5jdGlvbiBvdmVyIGEgW1RyYXZlcnNhYmxlXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3RyYXZlcnNhYmxlKSxcbiAqIHRoZW4gdXNlcyBbYHNlcXVlbmNlYF0oI3NlcXVlbmNlKSB0byB0cmFuc2Zvcm0gdGhlIHJlc3VsdGluZyBUcmF2ZXJzYWJsZSBvZiBBcHBsaWNhdGl2ZVxuICogaW50byBhbiBBcHBsaWNhdGl2ZSBvZiBUcmF2ZXJzYWJsZS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgdHJhdmVyc2VgIG1ldGhvZCBvZiB0aGUgdGhpcmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKEFwcGxpY2F0aXZlIGYsIFRyYXZlcnNhYmxlIHQpID0+IChhIC0+IGYgYSkgLT4gKGEgLT4gZiBiKSAtPiB0IGEgLT4gZiAodCBiKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb2ZcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEBwYXJhbSB7Kn0gdHJhdmVyc2FibGVcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIuc2VxdWVuY2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyBSZXR1cm5zIGBOb3RoaW5nYCBpZiB0aGUgZ2l2ZW4gZGl2aXNvciBpcyBgMGBcbiAqICAgICAgc2FmZURpdiA9IG4gPT4gZCA9PiBkID09PSAwID8gTm90aGluZygpIDogSnVzdChuIC8gZClcbiAqXG4gKiAgICAgIFIudHJhdmVyc2UoTWF5YmUub2YsIHNhZmVEaXYoMTApLCBbMiwgNCwgNV0pOyAvLz0+IEp1c3QoWzUsIDIuNSwgMl0pXG4gKiAgICAgIFIudHJhdmVyc2UoTWF5YmUub2YsIHNhZmVEaXYoMTApLCBbMiwgMCwgNV0pOyAvLz0+IE5vdGhpbmdcbiAqL1xudmFyIHRyYXZlcnNlID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gdHJhdmVyc2Uob2YsIGYsIHRyYXZlcnNhYmxlKSB7XG4gIHJldHVybiB0eXBlb2YgdHJhdmVyc2FibGVbJ2ZhbnRhc3ktbGFuZC90cmF2ZXJzZSddID09PSAnZnVuY3Rpb24nID8gdHJhdmVyc2FibGVbJ2ZhbnRhc3ktbGFuZC90cmF2ZXJzZSddKGYsIG9mKSA6IHNlcXVlbmNlKG9mLCBtYXAoZiwgdHJhdmVyc2FibGUpKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdHJhdmVyc2U7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcblxudmFyIHdzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOCcgKyAnXFx1MjAyOVxcdUZFRkYnO1xudmFyIHplcm9XaWR0aCA9ICdcXHUyMDBiJztcbnZhciBoYXNQcm90b1RyaW0gPSB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS50cmltID09PSAnZnVuY3Rpb24nO1xuLyoqXG4gKiBSZW1vdmVzIChzdHJpcHMpIHdoaXRlc3BhY2UgZnJvbSBib3RoIGVuZHMgb2YgdGhlIHN0cmluZy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC42LjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRyaW1tZWQgdmVyc2lvbiBvZiBgc3RyYC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRyaW0oJyAgIHh5eiAgJyk7IC8vPT4gJ3h5eidcbiAqICAgICAgUi5tYXAoUi50cmltLCBSLnNwbGl0KCcsJywgJ3gsIHksIHonKSk7IC8vPT4gWyd4JywgJ3knLCAneiddXG4gKi9cbnZhciBfdHJpbSA9ICFoYXNQcm90b1RyaW0gfHwgLyojX19QVVJFX18qL3dzLnRyaW0oKSB8fCAhIC8qI19fUFVSRV9fKi96ZXJvV2lkdGgudHJpbSgpID8gZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgdmFyIGJlZ2luUnggPSBuZXcgUmVnRXhwKCdeWycgKyB3cyArICddWycgKyB3cyArICddKicpO1xuICB2YXIgZW5kUnggPSBuZXcgUmVnRXhwKCdbJyArIHdzICsgJ11bJyArIHdzICsgJ10qJCcpO1xuICByZXR1cm4gc3RyLnJlcGxhY2UoYmVnaW5SeCwgJycpLnJlcGxhY2UoZW5kUngsICcnKTtcbn0gOiBmdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0oKTtcbn07XG52YXIgdHJpbSA9IC8qI19fUFVSRV9fKi9fY3VycnkxKF90cmltKTtcbmV4cG9ydCBkZWZhdWx0IHRyaW07IiwiaW1wb3J0IF9hcml0eSBmcm9tICcuL2ludGVybmFsL19hcml0eSc7XG5pbXBvcnQgX2NvbmNhdCBmcm9tICcuL2ludGVybmFsL19jb25jYXQnO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBgdHJ5Q2F0Y2hgIHRha2VzIHR3byBmdW5jdGlvbnMsIGEgYHRyeWVyYCBhbmQgYSBgY2F0Y2hlcmAuIFRoZSByZXR1cm5lZFxuICogZnVuY3Rpb24gZXZhbHVhdGVzIHRoZSBgdHJ5ZXJgOyBpZiBpdCBkb2VzIG5vdCB0aHJvdywgaXQgc2ltcGx5IHJldHVybnMgdGhlXG4gKiByZXN1bHQuIElmIHRoZSBgdHJ5ZXJgICpkb2VzKiB0aHJvdywgdGhlIHJldHVybmVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0aGVcbiAqIGBjYXRjaGVyYCBmdW5jdGlvbiBhbmQgcmV0dXJucyBpdHMgcmVzdWx0LiBOb3RlIHRoYXQgZm9yIGVmZmVjdGl2ZVxuICogY29tcG9zaXRpb24gd2l0aCB0aGlzIGZ1bmN0aW9uLCBib3RoIHRoZSBgdHJ5ZXJgIGFuZCBgY2F0Y2hlcmAgZnVuY3Rpb25zXG4gKiBtdXN0IHJldHVybiB0aGUgc2FtZSB0eXBlIG9mIHJlc3VsdHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjAuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICguLi54IC0+IGEpIC0+ICgoZSwgLi4ueCkgLT4gYSkgLT4gKC4uLnggLT4gYSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyeWVyIFRoZSBmdW5jdGlvbiB0aGF0IG1heSB0aHJvdy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhdGNoZXIgVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBldmFsdWF0ZWQgaWYgYHRyeWVyYCB0aHJvd3MuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gdGhhdCB3aWxsIGNhdGNoIGV4Y2VwdGlvbnMgYW5kIHNlbmQgdGhlbiB0byB0aGUgY2F0Y2hlci5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRyeUNhdGNoKFIucHJvcCgneCcpLCBSLkYpKHt4OiB0cnVlfSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLnRyeUNhdGNoKFIucHJvcCgneCcpLCBSLkYpKG51bGwpOyAgICAgIC8vPT4gZmFsc2VcbiAqL1xudmFyIHRyeUNhdGNoID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gX3RyeUNhdGNoKHRyeWVyLCBjYXRjaGVyKSB7XG4gIHJldHVybiBfYXJpdHkodHJ5ZXIubGVuZ3RoLCBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0cnllci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBjYXRjaGVyLmFwcGx5KHRoaXMsIF9jb25jYXQoW2VdLCBhcmd1bWVudHMpKTtcbiAgICB9XG4gIH0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCB0cnlDYXRjaDsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuXG4vKipcbiAqIEdpdmVzIGEgc2luZ2xlLXdvcmQgc3RyaW5nIGRlc2NyaXB0aW9uIG9mIHRoZSAobmF0aXZlKSB0eXBlIG9mIGEgdmFsdWUsXG4gKiByZXR1cm5pbmcgc3VjaCBhbnN3ZXJzIGFzICdPYmplY3QnLCAnTnVtYmVyJywgJ0FycmF5Jywgb3IgJ051bGwnLiBEb2VzIG5vdFxuICogYXR0ZW1wdCB0byBkaXN0aW5ndWlzaCB1c2VyIE9iamVjdCB0eXBlcyBhbnkgZnVydGhlciwgcmVwb3J0aW5nIHRoZW0gYWxsIGFzXG4gKiAnT2JqZWN0Jy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAc2lnICgqIC0+IHsqfSkgLT4gU3RyaW5nXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudHlwZSh7fSk7IC8vPT4gXCJPYmplY3RcIlxuICogICAgICBSLnR5cGUoMSk7IC8vPT4gXCJOdW1iZXJcIlxuICogICAgICBSLnR5cGUoZmFsc2UpOyAvLz0+IFwiQm9vbGVhblwiXG4gKiAgICAgIFIudHlwZSgncycpOyAvLz0+IFwiU3RyaW5nXCJcbiAqICAgICAgUi50eXBlKG51bGwpOyAvLz0+IFwiTnVsbFwiXG4gKiAgICAgIFIudHlwZShbXSk7IC8vPT4gXCJBcnJheVwiXG4gKiAgICAgIFIudHlwZSgvW0Etel0vKTsgLy89PiBcIlJlZ0V4cFwiXG4gKiAgICAgIFIudHlwZSgoKSA9PiB7fSk7IC8vPT4gXCJGdW5jdGlvblwiXG4gKiAgICAgIFIudHlwZSh1bmRlZmluZWQpOyAvLz0+IFwiVW5kZWZpbmVkXCJcbiAqL1xudmFyIHR5cGUgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiB0eXBlKHZhbCkge1xuICByZXR1cm4gdmFsID09PSBudWxsID8gJ051bGwnIDogdmFsID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpLnNsaWNlKDgsIC0xKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdHlwZTsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuXG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYGZuYCwgd2hpY2ggdGFrZXMgYSBzaW5nbGUgYXJyYXkgYXJndW1lbnQsIGFuZCByZXR1cm5zIGFcbiAqIGZ1bmN0aW9uIHdoaWNoOlxuICpcbiAqICAgLSB0YWtlcyBhbnkgbnVtYmVyIG9mIHBvc2l0aW9uYWwgYXJndW1lbnRzO1xuICogICAtIHBhc3NlcyB0aGVzZSBhcmd1bWVudHMgdG8gYGZuYCBhcyBhbiBhcnJheTsgYW5kXG4gKiAgIC0gcmV0dXJucyB0aGUgcmVzdWx0LlxuICpcbiAqIEluIG90aGVyIHdvcmRzLCBgUi51bmFwcGx5YCBkZXJpdmVzIGEgdmFyaWFkaWMgZnVuY3Rpb24gZnJvbSBhIGZ1bmN0aW9uIHdoaWNoXG4gKiB0YWtlcyBhbiBhcnJheS4gYFIudW5hcHBseWAgaXMgdGhlIGludmVyc2Ugb2YgW2BSLmFwcGx5YF0oI2FwcGx5KS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoWyouLi5dIC0+IGEpIC0+ICgqLi4uIC0+IGEpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIuYXBwbHlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnVuYXBwbHkoSlNPTi5zdHJpbmdpZnkpKDEsIDIsIDMpOyAvLz0+ICdbMSwyLDNdJ1xuICogQHN5bWIgUi51bmFwcGx5KGYpKGEsIGIpID0gZihbYSwgYl0pXG4gKi9cbnZhciB1bmFwcGx5ID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gdW5hcHBseShmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbihBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgfTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdW5hcHBseTsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tICcuL2ludGVybmFsL19jdXJyeTEnO1xuaW1wb3J0IG5BcnkgZnJvbSAnLi9uQXJ5JztcblxuLyoqXG4gKiBXcmFwcyBhIGZ1bmN0aW9uIG9mIGFueSBhcml0eSAoaW5jbHVkaW5nIG51bGxhcnkpIGluIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzXG4gKiBleGFjdGx5IDEgcGFyYW1ldGVyLiBBbnkgZXh0cmFuZW91cyBwYXJhbWV0ZXJzIHdpbGwgbm90IGJlIHBhc3NlZCB0byB0aGVcbiAqIHN1cHBsaWVkIGZ1bmN0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgqIC0+IGIpIC0+IChhIC0+IGIpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyBgZm5gLiBUaGUgbmV3IGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgb2ZcbiAqICAgICAgICAgYXJpdHkgMS5cbiAqIEBzZWUgUi5iaW5hcnksIFIubkFyeVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB0YWtlc1R3b0FyZ3MgPSBmdW5jdGlvbihhLCBiKSB7XG4gKiAgICAgICAgcmV0dXJuIFthLCBiXTtcbiAqICAgICAgfTtcbiAqICAgICAgdGFrZXNUd29BcmdzLmxlbmd0aDsgLy89PiAyXG4gKiAgICAgIHRha2VzVHdvQXJncygxLCAyKTsgLy89PiBbMSwgMl1cbiAqXG4gKiAgICAgIHZhciB0YWtlc09uZUFyZyA9IFIudW5hcnkodGFrZXNUd29BcmdzKTtcbiAqICAgICAgdGFrZXNPbmVBcmcubGVuZ3RoOyAvLz0+IDFcbiAqICAgICAgLy8gT25seSAxIGFyZ3VtZW50IGlzIHBhc3NlZCB0byB0aGUgd3JhcHBlZCBmdW5jdGlvblxuICogICAgICB0YWtlc09uZUFyZygxLCAyKTsgLy89PiBbMSwgdW5kZWZpbmVkXVxuICogQHN5bWIgUi51bmFyeShmKShhLCBiLCBjKSA9IGYoYSlcbiAqL1xudmFyIHVuYXJ5ID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gdW5hcnkoZm4pIHtcbiAgcmV0dXJuIG5BcnkoMSwgZm4pO1xufSk7XG5leHBvcnQgZGVmYXVsdCB1bmFyeTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IGN1cnJ5TiBmcm9tICcuL2N1cnJ5Tic7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIG9mIGFyaXR5IGBuYCBmcm9tIGEgKG1hbnVhbGx5KSBjdXJyaWVkIGZ1bmN0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBOdW1iZXIgLT4gKGEgLT4gYikgLT4gKGEgLT4gYylcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGFyaXR5IGZvciB0aGUgcmV0dXJuZWQgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gdW5jdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbi5cbiAqIEBzZWUgUi5jdXJyeVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBhZGRGb3VyID0gYSA9PiBiID0+IGMgPT4gZCA9PiBhICsgYiArIGMgKyBkO1xuICpcbiAqICAgICAgdmFyIHVuY3VycmllZEFkZEZvdXIgPSBSLnVuY3VycnlOKDQsIGFkZEZvdXIpO1xuICogICAgICB1bmN1cnJpZWRBZGRGb3VyKDEsIDIsIDMsIDQpOyAvLz0+IDEwXG4gKi9cbnZhciB1bmN1cnJ5TiA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHVuY3VycnlOKGRlcHRoLCBmbikge1xuICByZXR1cm4gY3VycnlOKGRlcHRoLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnREZXB0aCA9IDE7XG4gICAgdmFyIHZhbHVlID0gZm47XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIGVuZElkeDtcbiAgICB3aGlsZSAoY3VycmVudERlcHRoIDw9IGRlcHRoICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZW5kSWR4ID0gY3VycmVudERlcHRoID09PSBkZXB0aCA/IGFyZ3VtZW50cy5sZW5ndGggOiBpZHggKyB2YWx1ZS5sZW5ndGg7XG4gICAgICB2YWx1ZSA9IHZhbHVlLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgaWR4LCBlbmRJZHgpKTtcbiAgICAgIGN1cnJlbnREZXB0aCArPSAxO1xuICAgICAgaWR4ID0gZW5kSWR4O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pO1xufSk7XG5leHBvcnQgZGVmYXVsdCB1bmN1cnJ5TjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIEJ1aWxkcyBhIGxpc3QgZnJvbSBhIHNlZWQgdmFsdWUuIEFjY2VwdHMgYW4gaXRlcmF0b3IgZnVuY3Rpb24sIHdoaWNoIHJldHVybnNcbiAqIGVpdGhlciBmYWxzZSB0byBzdG9wIGl0ZXJhdGlvbiBvciBhbiBhcnJheSBvZiBsZW5ndGggMiBjb250YWluaW5nIHRoZSB2YWx1ZVxuICogdG8gYWRkIHRvIHRoZSByZXN1bHRpbmcgbGlzdCBhbmQgdGhlIHNlZWQgdG8gYmUgdXNlZCBpbiB0aGUgbmV4dCBjYWxsIHRvIHRoZVxuICogaXRlcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHJlY2VpdmVzIG9uZSBhcmd1bWVudDogKihzZWVkKSouXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTAuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gW2JdKSAtPiAqIC0+IFtiXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLiByZWNlaXZlcyBvbmUgYXJndW1lbnQsIGBzZWVkYCwgYW5kIHJldHVybnNcbiAqICAgICAgICBlaXRoZXIgZmFsc2UgdG8gcXVpdCBpdGVyYXRpb24gb3IgYW4gYXJyYXkgb2YgbGVuZ3RoIHR3byB0byBwcm9jZWVkLiBUaGUgZWxlbWVudFxuICogICAgICAgIGF0IGluZGV4IDAgb2YgdGhpcyBhcnJheSB3aWxsIGJlIGFkZGVkIHRvIHRoZSByZXN1bHRpbmcgYXJyYXksIGFuZCB0aGUgZWxlbWVudFxuICogICAgICAgIGF0IGluZGV4IDEgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIG5leHQgY2FsbCB0byBgZm5gLlxuICogQHBhcmFtIHsqfSBzZWVkIFRoZSBzZWVkIHZhbHVlLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBmaW5hbCBsaXN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBmID0gbiA9PiBuID4gNTAgPyBmYWxzZSA6IFstbiwgbiArIDEwXTtcbiAqICAgICAgUi51bmZvbGQoZiwgMTApOyAvLz0+IFstMTAsIC0yMCwgLTMwLCAtNDAsIC01MF1cbiAqIEBzeW1iIFIudW5mb2xkKGYsIHgpID0gW2YoeClbMF0sIGYoZih4KVsxXSlbMF0sIGYoZihmKHgpWzFdKVsxXSlbMF0sIC4uLl1cbiAqL1xudmFyIHVuZm9sZCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHVuZm9sZChmbiwgc2VlZCkge1xuICB2YXIgcGFpciA9IGZuKHNlZWQpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChwYWlyICYmIHBhaXIubGVuZ3RoKSB7XG4gICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcGFpclswXTtcbiAgICBwYWlyID0gZm4ocGFpclsxXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdW5mb2xkOyIsImltcG9ydCBfY29uY2F0IGZyb20gJy4vaW50ZXJuYWwvX2NvbmNhdCc7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuaW1wb3J0IGNvbXBvc2UgZnJvbSAnLi9jb21wb3NlJztcbmltcG9ydCB1bmlxIGZyb20gJy4vdW5pcSc7XG5cbi8qKlxuICogQ29tYmluZXMgdHdvIGxpc3RzIGludG8gYSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgY29tcG9zZWQgb2YgdGhlIGVsZW1lbnRzXG4gKiBvZiBlYWNoIGxpc3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgWypdIC0+IFsqXSAtPiBbKl1cbiAqIEBwYXJhbSB7QXJyYXl9IGFzIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gYnMgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBmaXJzdCBhbmQgc2Vjb25kIGxpc3RzIGNvbmNhdGVuYXRlZCwgd2l0aFxuICogICAgICAgICBkdXBsaWNhdGVzIHJlbW92ZWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51bmlvbihbMSwgMiwgM10sIFsyLCAzLCA0XSk7IC8vPT4gWzEsIDIsIDMsIDRdXG4gKi9cbnZhciB1bmlvbiA9IC8qI19fUFVSRV9fKi9fY3VycnkyKCAvKiNfX1BVUkVfXyovY29tcG9zZSh1bmlxLCBfY29uY2F0KSk7XG5leHBvcnQgZGVmYXVsdCB1bmlvbjsiLCJpbXBvcnQgX2NvbmNhdCBmcm9tICcuL2ludGVybmFsL19jb25jYXQnO1xuaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcbmltcG9ydCB1bmlxV2l0aCBmcm9tICcuL3VuaXFXaXRoJztcblxuLyoqXG4gKiBDb21iaW5lcyB0d28gbGlzdHMgaW50byBhIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBjb21wb3NlZCBvZiB0aGUgZWxlbWVudHNcbiAqIG9mIGVhY2ggbGlzdC4gRHVwbGljYXRpb24gaXMgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlIHJldHVybmVkIGJ5XG4gKiBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIHR3byBsaXN0IGVsZW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnICgoYSwgYSkgLT4gQm9vbGVhbikgLT4gWypdIC0+IFsqXSAtPiBbKl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdXNlZCB0byB0ZXN0IHdoZXRoZXIgdHdvIGl0ZW1zIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBmaXJzdCBhbmQgc2Vjb25kIGxpc3RzIGNvbmNhdGVuYXRlZCwgd2l0aFxuICogICAgICAgICBkdXBsaWNhdGVzIHJlbW92ZWQuXG4gKiBAc2VlIFIudW5pb25cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbDEgPSBbe2E6IDF9LCB7YTogMn1dO1xuICogICAgICB2YXIgbDIgPSBbe2E6IDF9LCB7YTogNH1dO1xuICogICAgICBSLnVuaW9uV2l0aChSLmVxQnkoUi5wcm9wKCdhJykpLCBsMSwgbDIpOyAvLz0+IFt7YTogMX0sIHthOiAyfSwge2E6IDR9XVxuICovXG52YXIgdW5pb25XaXRoID0gLyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gdW5pb25XaXRoKHByZWQsIGxpc3QxLCBsaXN0Mikge1xuICByZXR1cm4gdW5pcVdpdGgocHJlZCwgX2NvbmNhdChsaXN0MSwgbGlzdDIpKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdW5pb25XaXRoOyIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5JztcbmltcG9ydCB1bmlxQnkgZnJvbSAnLi91bmlxQnknO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIG9ubHkgb25lIGNvcHkgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBvcmlnaW5hbFxuICogbGlzdC4gW2BSLmVxdWFsc2BdKCNlcXVhbHMpIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFthXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgdW5pcXVlIGl0ZW1zLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudW5pcShbMSwgMSwgMiwgMV0pOyAvLz0+IFsxLCAyXVxuICogICAgICBSLnVuaXEoWzEsICcxJ10pOyAgICAgLy89PiBbMSwgJzEnXVxuICogICAgICBSLnVuaXEoW1s0Ml0sIFs0Ml1dKTsgLy89PiBbWzQyXV1cbiAqL1xudmFyIHVuaXEgPSAvKiNfX1BVUkVfXyovdW5pcUJ5KGlkZW50aXR5KTtcbmV4cG9ydCBkZWZhdWx0IHVuaXE7IiwiaW1wb3J0IF9TZXQgZnJvbSAnLi9pbnRlcm5hbC9fU2V0JztcbmltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgb25seSBvbmUgY29weSBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsXG4gKiBsaXN0LCBiYXNlZCB1cG9uIHRoZSB2YWx1ZSByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gdG9cbiAqIGVhY2ggbGlzdCBlbGVtZW50LiBQcmVmZXJzIHRoZSBmaXJzdCBpdGVtIGlmIHRoZSBzdXBwbGllZCBmdW5jdGlvbiBwcm9kdWNlc1xuICogdGhlIHNhbWUgdmFsdWUgb24gdHdvIGl0ZW1zLiBbYFIuZXF1YWxzYF0oI2VxdWFscykgaXMgdXNlZCBmb3IgY29tcGFyaXNvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBiKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBBIGZ1bmN0aW9uIHVzZWQgdG8gcHJvZHVjZSBhIHZhbHVlIHRvIHVzZSBkdXJpbmcgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiB1bmlxdWUgaXRlbXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51bmlxQnkoTWF0aC5hYnMsIFstMSwgLTUsIDIsIDEwLCAxLCAyXSk7IC8vPT4gWy0xLCAtNSwgMiwgMTBdXG4gKi9cbnZhciB1bmlxQnkgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiB1bmlxQnkoZm4sIGxpc3QpIHtcbiAgdmFyIHNldCA9IG5ldyBfU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBhcHBsaWVkSXRlbSwgaXRlbTtcblxuICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICBpdGVtID0gbGlzdFtpZHhdO1xuICAgIGFwcGxpZWRJdGVtID0gZm4oaXRlbSk7XG4gICAgaWYgKHNldC5hZGQoYXBwbGllZEl0ZW0pKSB7XG4gICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdW5pcUJ5OyIsImltcG9ydCBfY29udGFpbnNXaXRoIGZyb20gJy4vaW50ZXJuYWwvX2NvbnRhaW5zV2l0aCc7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIG9ubHkgb25lIGNvcHkgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBvcmlnaW5hbFxuICogbGlzdCwgYmFzZWQgdXBvbiB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgYXBwbHlpbmcgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSB0b1xuICogdHdvIGxpc3QgZWxlbWVudHMuIFByZWZlcnMgdGhlIGZpcnN0IGl0ZW0gaWYgdHdvIGl0ZW1zIGNvbXBhcmUgZXF1YWwgYmFzZWRcbiAqIG9uIHRoZSBwcmVkaWNhdGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGEpIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdXNlZCB0byB0ZXN0IHdoZXRoZXIgdHdvIGl0ZW1zIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIHVuaXF1ZSBpdGVtcy5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgc3RyRXEgPSBSLmVxQnkoU3RyaW5nKTtcbiAqICAgICAgUi51bmlxV2l0aChzdHJFcSkoWzEsICcxJywgMiwgMV0pOyAvLz0+IFsxLCAyXVxuICogICAgICBSLnVuaXFXaXRoKHN0ckVxKShbe30sIHt9XSk7ICAgICAgIC8vPT4gW3t9XVxuICogICAgICBSLnVuaXFXaXRoKHN0ckVxKShbMSwgJzEnLCAxXSk7ICAgIC8vPT4gWzFdXG4gKiAgICAgIFIudW5pcVdpdGgoc3RyRXEpKFsnMScsIDEsIDFdKTsgICAgLy89PiBbJzEnXVxuICovXG52YXIgdW5pcVdpdGggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiB1bmlxV2l0aChwcmVkLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGl0ZW07XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpdGVtID0gbGlzdFtpZHhdO1xuICAgIGlmICghX2NvbnRhaW5zV2l0aChwcmVkLCBpdGVtLCByZXN1bHQpKSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBpdGVtO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5leHBvcnQgZGVmYXVsdCB1bmlxV2l0aDsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIFRlc3RzIHRoZSBmaW5hbCBhcmd1bWVudCBieSBwYXNzaW5nIGl0IHRvIHRoZSBnaXZlbiBwcmVkaWNhdGUgZnVuY3Rpb24uIElmXG4gKiB0aGUgcHJlZGljYXRlIGlzIG5vdCBzYXRpc2ZpZWQsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mXG4gKiBjYWxsaW5nIHRoZSBgd2hlbkZhbHNlRm5gIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgYXJndW1lbnQuIElmIHRoZSBwcmVkaWNhdGVcbiAqIGlzIHNhdGlzZmllZCwgdGhlIGFyZ3VtZW50IGlzIHJldHVybmVkIGFzIGlzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE4LjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiAoYSAtPiBhKSAtPiBhIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgICAgICAgIEEgcHJlZGljYXRlIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB3aGVuRmFsc2VGbiBBIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIHRoZSBgcHJlZGAgZXZhbHVhdGVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIGZhbHN5IHZhbHVlLlxuICogQHBhcmFtIHsqfSAgICAgICAgeCAgICAgICAgICAgQW4gb2JqZWN0IHRvIHRlc3Qgd2l0aCB0aGUgYHByZWRgIGZ1bmN0aW9uIGFuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcyB0byBgd2hlbkZhbHNlRm5gIGlmIG5lY2Vzc2FyeS5cbiAqIEByZXR1cm4geyp9IEVpdGhlciBgeGAgb3IgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgeGAgdG8gYHdoZW5GYWxzZUZuYC5cbiAqIEBzZWUgUi5pZkVsc2UsIFIud2hlblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGxldCBzYWZlSW5jID0gUi51bmxlc3MoUi5pc05pbCwgUi5pbmMpO1xuICogICAgICBzYWZlSW5jKG51bGwpOyAvLz0+IG51bGxcbiAqICAgICAgc2FmZUluYygxKTsgLy89PiAyXG4gKi9cbnZhciB1bmxlc3MgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiB1bmxlc3MocHJlZCwgd2hlbkZhbHNlRm4sIHgpIHtcbiAgcmV0dXJuIHByZWQoeCkgPyB4IDogd2hlbkZhbHNlRm4oeCk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHVubGVzczsiLCJpbXBvcnQgX2lkZW50aXR5IGZyb20gJy4vaW50ZXJuYWwvX2lkZW50aXR5JztcbmltcG9ydCBjaGFpbiBmcm9tICcuL2NoYWluJztcblxuLyoqXG4gKiBTaG9ydGhhbmQgZm9yIGBSLmNoYWluKFIuaWRlbnRpdHkpYCwgd2hpY2ggcmVtb3ZlcyBvbmUgbGV2ZWwgb2YgbmVzdGluZyBmcm9tXG4gKiBhbnkgW0NoYWluXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NoYWluKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIENoYWluIGMgPT4gYyAoYyBhKSAtPiBjIGFcbiAqIEBwYXJhbSB7Kn0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5mbGF0dGVuLCBSLmNoYWluXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51bm5lc3QoWzEsIFsyXSwgW1szXV1dKTsgLy89PiBbMSwgMiwgWzNdXVxuICogICAgICBSLnVubmVzdChbWzEsIDJdLCBbMywgNF0sIFs1LCA2XV0pOyAvLz0+IFsxLCAyLCAzLCA0LCA1LCA2XVxuICovXG52YXIgdW5uZXN0ID0gLyojX19QVVJFX18qL2NoYWluKF9pZGVudGl0eSk7XG5leHBvcnQgZGVmYXVsdCB1bm5lc3Q7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcblxuLyoqXG4gKiBUYWtlcyBhIHByZWRpY2F0ZSwgYSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiwgYW5kIGFuIGluaXRpYWwgdmFsdWUsXG4gKiBhbmQgcmV0dXJucyBhIHZhbHVlIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBJdCBkb2VzIHNvIGJ5IGFwcGx5aW5nIHRoZSB0cmFuc2Zvcm1hdGlvbiB1bnRpbCB0aGUgcHJlZGljYXRlIGlzIHNhdGlzZmllZCxcbiAqIGF0IHdoaWNoIHBvaW50IGl0IHJldHVybnMgdGhlIHNhdGlzZmFjdG9yeSB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMC4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gKGEgLT4gYSkgLT4gYSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gaW5pdCBJbml0aWFsIHZhbHVlXG4gKiBAcmV0dXJuIHsqfSBGaW5hbCB2YWx1ZSB0aGF0IHNhdGlzZmllcyBwcmVkaWNhdGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnVudGlsKFIuZ3QoUi5fXywgMTAwKSwgUi5tdWx0aXBseSgyKSkoMSkgLy8gPT4gMTI4XG4gKi9cbnZhciB1bnRpbCA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIHVudGlsKHByZWQsIGZuLCBpbml0KSB7XG4gIHZhciB2YWwgPSBpbml0O1xuICB3aGlsZSAoIXByZWQodmFsKSkge1xuICAgIHZhbCA9IGZuKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdW50aWw7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkzJztcbmltcG9ydCBhZGp1c3QgZnJvbSAnLi9hZGp1c3QnO1xuaW1wb3J0IGFsd2F5cyBmcm9tICcuL2Fsd2F5cyc7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjb3B5IG9mIHRoZSBhcnJheSB3aXRoIHRoZSBlbGVtZW50IGF0IHRoZSBwcm92aWRlZCBpbmRleFxuICogcmVwbGFjZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IGEgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtOdW1iZXJ9IGlkeCBUaGUgaW5kZXggdG8gdXBkYXRlLlxuICogQHBhcmFtIHsqfSB4IFRoZSB2YWx1ZSB0byBleGlzdCBhdCB0aGUgZ2l2ZW4gaW5kZXggb2YgdGhlIHJldHVybmVkIGFycmF5LlxuICogQHBhcmFtIHtBcnJheXxBcmd1bWVudHN9IGxpc3QgVGhlIHNvdXJjZSBhcnJheS1saWtlIG9iamVjdCB0byBiZSB1cGRhdGVkLlxuICogQHJldHVybiB7QXJyYXl9IEEgY29weSBvZiBgbGlzdGAgd2l0aCB0aGUgdmFsdWUgYXQgaW5kZXggYGlkeGAgcmVwbGFjZWQgd2l0aCBgeGAuXG4gKiBAc2VlIFIuYWRqdXN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51cGRhdGUoMSwgMTEsIFswLCAxLCAyXSk7ICAgICAvLz0+IFswLCAxMSwgMl1cbiAqICAgICAgUi51cGRhdGUoMSkoMTEpKFswLCAxLCAyXSk7ICAgICAvLz0+IFswLCAxMSwgMl1cbiAqIEBzeW1iIFIudXBkYXRlKC0xLCBhLCBbYiwgY10pID0gW2IsIGFdXG4gKiBAc3ltYiBSLnVwZGF0ZSgwLCBhLCBbYiwgY10pID0gW2EsIGNdXG4gKiBAc3ltYiBSLnVwZGF0ZSgxLCBhLCBbYiwgY10pID0gW2IsIGFdXG4gKi9cbnZhciB1cGRhdGUgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiB1cGRhdGUoaWR4LCB4LCBsaXN0KSB7XG4gIHJldHVybiBhZGp1c3QoYWx3YXlzKHgpLCBpZHgsIGxpc3QpO1xufSk7XG5leHBvcnQgZGVmYXVsdCB1cGRhdGU7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBjdXJyeU4gZnJvbSAnLi9jdXJyeU4nO1xuXG4vKipcbiAqIEFjY2VwdHMgYSBmdW5jdGlvbiBgZm5gIGFuZCBhIGxpc3Qgb2YgdHJhbnNmb3JtZXIgZnVuY3Rpb25zIGFuZCByZXR1cm5zIGFcbiAqIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLiBXaGVuIHRoZSBuZXcgZnVuY3Rpb24gaXMgaW52b2tlZCwgaXQgY2FsbHMgdGhlXG4gKiBmdW5jdGlvbiBgZm5gIHdpdGggcGFyYW1ldGVycyBjb25zaXN0aW5nIG9mIHRoZSByZXN1bHQgb2YgY2FsbGluZyBlYWNoXG4gKiBzdXBwbGllZCBoYW5kbGVyIG9uIHN1Y2Nlc3NpdmUgYXJndW1lbnRzIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gKlxuICogSWYgbW9yZSBhcmd1bWVudHMgYXJlIHBhc3NlZCB0byB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gdGhhbiB0cmFuc2Zvcm1lclxuICogZnVuY3Rpb25zLCB0aG9zZSBhcmd1bWVudHMgYXJlIHBhc3NlZCBkaXJlY3RseSB0byBgZm5gIGFzIGFkZGl0aW9uYWxcbiAqIHBhcmFtZXRlcnMuIElmIHlvdSBleHBlY3QgYWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCBkb24ndCBuZWVkIHRvIGJlXG4gKiB0cmFuc2Zvcm1lZCwgYWx0aG91Z2ggeW91IGNhbiBpZ25vcmUgdGhlbSwgaXQncyBiZXN0IHRvIHBhc3MgYW4gaWRlbnRpdHlcbiAqIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIG5ldyBmdW5jdGlvbiByZXBvcnRzIHRoZSBjb3JyZWN0IGFyaXR5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgoeDEsIHgyLCAuLi4pIC0+IHopIC0+IFsoYSAtPiB4MSksIChiIC0+IHgyKSwgLi4uXSAtPiAoYSAtPiBiIC0+IC4uLiAtPiB6KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm1lcnMgQSBsaXN0IG9mIHRyYW5zZm9ybWVyIGZ1bmN0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuICogQHNlZSBSLmNvbnZlcmdlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51c2VXaXRoKE1hdGgucG93LCBbUi5pZGVudGl0eSwgUi5pZGVudGl0eV0pKDMsIDQpOyAvLz0+IDgxXG4gKiAgICAgIFIudXNlV2l0aChNYXRoLnBvdywgW1IuaWRlbnRpdHksIFIuaWRlbnRpdHldKSgzKSg0KTsgLy89PiA4MVxuICogICAgICBSLnVzZVdpdGgoTWF0aC5wb3csIFtSLmRlYywgUi5pbmNdKSgzLCA0KTsgLy89PiAzMlxuICogICAgICBSLnVzZVdpdGgoTWF0aC5wb3csIFtSLmRlYywgUi5pbmNdKSgzKSg0KTsgLy89PiAzMlxuICogQHN5bWIgUi51c2VXaXRoKGYsIFtnLCBoXSkoYSwgYikgPSBmKGcoYSksIGgoYikpXG4gKi9cbnZhciB1c2VXaXRoID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gdXNlV2l0aChmbiwgdHJhbnNmb3JtZXJzKSB7XG4gIHJldHVybiBjdXJyeU4odHJhbnNmb3JtZXJzLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgd2hpbGUgKGlkeCA8IHRyYW5zZm9ybWVycy5sZW5ndGgpIHtcbiAgICAgIGFyZ3MucHVzaCh0cmFuc2Zvcm1lcnNbaWR4XS5jYWxsKHRoaXMsIGFyZ3VtZW50c1tpZHhdKSk7XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgdHJhbnNmb3JtZXJzLmxlbmd0aCkpKTtcbiAgfSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHVzZVdpdGg7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cyc7XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRoZSBlbnVtZXJhYmxlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBzdXBwbGllZCBvYmplY3QuXG4gKiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBvdXRwdXQgYXJyYXkgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGRpZmZlcmVudFxuICogSlMgcGxhdGZvcm1zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7azogdn0gLT4gW3ZdXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZXh0cmFjdCB2YWx1ZXMgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgb2YgdGhlIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICogQHNlZSBSLnZhbHVlc0luLCBSLmtleXNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnZhbHVlcyh7YTogMSwgYjogMiwgYzogM30pOyAvLz0+IFsxLCAyLCAzXVxuICovXG52YXIgdmFsdWVzID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gdmFsdWVzKG9iaikge1xuICB2YXIgcHJvcHMgPSBrZXlzKG9iaik7XG4gIHZhciBsZW4gPSBwcm9wcy5sZW5ndGg7XG4gIHZhciB2YWxzID0gW107XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgdmFsc1tpZHhdID0gb2JqW3Byb3BzW2lkeF1dO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiB2YWxzO1xufSk7XG5leHBvcnQgZGVmYXVsdCB2YWx1ZXM7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkxJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdGhlIHByb3BlcnRpZXMsIGluY2x1ZGluZyBwcm90b3R5cGUgcHJvcGVydGllcywgb2YgdGhlXG4gKiBzdXBwbGllZCBvYmplY3QuXG4gKiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBvdXRwdXQgYXJyYXkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgY29uc2lzdGVudFxuICogYWNyb3NzIGRpZmZlcmVudCBKUyBwbGF0Zm9ybXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMi4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtrOiB2fSAtPiBbdl1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IHZhbHVlcyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIHZhbHVlcyBvZiB0aGUgb2JqZWN0J3Mgb3duIGFuZCBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqIEBzZWUgUi52YWx1ZXMsIFIua2V5c0luXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIEYgPSBmdW5jdGlvbigpIHsgdGhpcy54ID0gJ1gnOyB9O1xuICogICAgICBGLnByb3RvdHlwZS55ID0gJ1knO1xuICogICAgICB2YXIgZiA9IG5ldyBGKCk7XG4gKiAgICAgIFIudmFsdWVzSW4oZik7IC8vPT4gWydYJywgJ1knXVxuICovXG52YXIgdmFsdWVzSW4gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiB2YWx1ZXNJbihvYmopIHtcbiAgdmFyIHByb3A7XG4gIHZhciB2cyA9IFtdO1xuICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgdnNbdnMubGVuZ3RoXSA9IG9ialtwcm9wXTtcbiAgfVxuICByZXR1cm4gdnM7XG59KTtcbmV4cG9ydCBkZWZhdWx0IHZhbHVlc0luOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5cbi8vIGBDb25zdGAgaXMgYSBmdW5jdG9yIHRoYXQgZWZmZWN0aXZlbHkgaWdub3JlcyB0aGUgZnVuY3Rpb24gZ2l2ZW4gdG8gYG1hcGAuXG52YXIgQ29uc3QgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geyB2YWx1ZTogeCwgJ2ZhbnRhc3ktbGFuZC9tYXAnOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBcInZpZXdcIiBvZiB0aGUgZ2l2ZW4gZGF0YSBzdHJ1Y3R1cmUsIGRldGVybWluZWQgYnkgdGhlIGdpdmVuIGxlbnMuXG4gKiBUaGUgbGVucydzIGZvY3VzIGRldGVybWluZXMgd2hpY2ggcG9ydGlvbiBvZiB0aGUgZGF0YSBzdHJ1Y3R1cmUgaXMgdmlzaWJsZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICogQHNpZyBMZW5zIHMgYSAtPiBzIC0+IGFcbiAqIEBwYXJhbSB7TGVuc30gbGVuc1xuICogQHBhcmFtIHsqfSB4XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLnByb3AsIFIubGVuc0luZGV4LCBSLmxlbnNQcm9wXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHhMZW5zID0gUi5sZW5zUHJvcCgneCcpO1xuICpcbiAqICAgICAgUi52aWV3KHhMZW5zLCB7eDogMSwgeTogMn0pOyAgLy89PiAxXG4gKiAgICAgIFIudmlldyh4TGVucywge3g6IDQsIHk6IDJ9KTsgIC8vPT4gNFxuICovXG52YXIgdmlldyA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHZpZXcobGVucywgeCkge1xuICAvLyBVc2luZyBgQ29uc3RgIGVmZmVjdGl2ZWx5IGlnbm9yZXMgdGhlIHNldHRlciBmdW5jdGlvbiBvZiB0aGUgYGxlbnNgLFxuICAvLyBsZWF2aW5nIHRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgZ2V0dGVyIGZ1bmN0aW9uIHVubW9kaWZpZWQuXG4gIHJldHVybiBsZW5zKENvbnN0KSh4KS52YWx1ZTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdmlldzsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tICcuL2ludGVybmFsL19jdXJyeTMnO1xuXG4vKipcbiAqIFRlc3RzIHRoZSBmaW5hbCBhcmd1bWVudCBieSBwYXNzaW5nIGl0IHRvIHRoZSBnaXZlbiBwcmVkaWNhdGUgZnVuY3Rpb24uIElmXG4gKiB0aGUgcHJlZGljYXRlIGlzIHNhdGlzZmllZCwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZ1xuICogdGhlIGB3aGVuVHJ1ZUZuYCBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50LiBJZiB0aGUgcHJlZGljYXRlIGlzIG5vdFxuICogc2F0aXNmaWVkLCB0aGUgYXJndW1lbnQgaXMgcmV0dXJuZWQgYXMgaXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTguMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IChhIC0+IGEpIC0+IGEgLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCAgICAgICBBIHByZWRpY2F0ZSBmdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gd2hlblRydWVGbiBBIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIHRoZSBgY29uZGl0aW9uYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmFsdWF0ZXMgdG8gYSB0cnV0aHkgdmFsdWUuXG4gKiBAcGFyYW0geyp9ICAgICAgICB4ICAgICAgICAgIEFuIG9iamVjdCB0byB0ZXN0IHdpdGggdGhlIGBwcmVkYCBmdW5jdGlvbiBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcyB0byBgd2hlblRydWVGbmAgaWYgbmVjZXNzYXJ5LlxuICogQHJldHVybiB7Kn0gRWl0aGVyIGB4YCBvciB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGB4YCB0byBgd2hlblRydWVGbmAuXG4gKiBAc2VlIFIuaWZFbHNlLCBSLnVubGVzc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIC8vIHRydW5jYXRlIDo6IFN0cmluZyAtPiBTdHJpbmdcbiAqICAgICAgdmFyIHRydW5jYXRlID0gUi53aGVuKFxuICogICAgICAgIFIucHJvcFNhdGlzZmllcyhSLmd0KFIuX18sIDEwKSwgJ2xlbmd0aCcpLFxuICogICAgICAgIFIucGlwZShSLnRha2UoMTApLCBSLmFwcGVuZCgn4oCmJyksIFIuam9pbignJykpXG4gKiAgICAgICk7XG4gKiAgICAgIHRydW5jYXRlKCcxMjM0NScpOyAgICAgICAgIC8vPT4gJzEyMzQ1J1xuICogICAgICB0cnVuY2F0ZSgnMDEyMzQ1Njc4OUFCQycpOyAvLz0+ICcwMTIzNDU2Nzg54oCmJ1xuICovXG52YXIgd2hlbiA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIHdoZW4ocHJlZCwgd2hlblRydWVGbiwgeCkge1xuICByZXR1cm4gcHJlZCh4KSA/IHdoZW5UcnVlRm4oeCkgOiB4O1xufSk7XG5leHBvcnQgZGVmYXVsdCB3aGVuOyIsImltcG9ydCBfY3VycnkyIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Mic7XG5pbXBvcnQgX2hhcyBmcm9tICcuL2ludGVybmFsL19oYXMnO1xuXG4vKipcbiAqIFRha2VzIGEgc3BlYyBvYmplY3QgYW5kIGEgdGVzdCBvYmplY3Q7IHJldHVybnMgdHJ1ZSBpZiB0aGUgdGVzdCBzYXRpc2ZpZXNcbiAqIHRoZSBzcGVjLiBFYWNoIG9mIHRoZSBzcGVjJ3Mgb3duIHByb3BlcnRpZXMgbXVzdCBiZSBhIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAqIEVhY2ggcHJlZGljYXRlIGlzIGFwcGxpZWQgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG9mIHRoZVxuICogdGVzdCBvYmplY3QuIGB3aGVyZWAgcmV0dXJucyB0cnVlIGlmIGFsbCB0aGUgcHJlZGljYXRlcyByZXR1cm4gdHJ1ZSwgZmFsc2VcbiAqIG90aGVyd2lzZS5cbiAqXG4gKiBgd2hlcmVgIGlzIHdlbGwgc3VpdGVkIHRvIGRlY2xhcmF0aXZlbHkgZXhwcmVzc2luZyBjb25zdHJhaW50cyBmb3Igb3RoZXJcbiAqIGZ1bmN0aW9ucyBzdWNoIGFzIFtgZmlsdGVyYF0oI2ZpbHRlcikgYW5kIFtgZmluZGBdKCNmaW5kKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjFcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge1N0cmluZzogKCogLT4gQm9vbGVhbil9IC0+IHtTdHJpbmc6ICp9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjXG4gKiBAcGFyYW0ge09iamVjdH0gdGVzdE9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5wcm9wU2F0aXNmaWVzLCBSLndoZXJlRXFcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyBwcmVkIDo6IE9iamVjdCAtPiBCb29sZWFuXG4gKiAgICAgIHZhciBwcmVkID0gUi53aGVyZSh7XG4gKiAgICAgICAgYTogUi5lcXVhbHMoJ2ZvbycpLFxuICogICAgICAgIGI6IFIuY29tcGxlbWVudChSLmVxdWFscygnYmFyJykpLFxuICogICAgICAgIHg6IFIuZ3QoUi5fXywgMTApLFxuICogICAgICAgIHk6IFIubHQoUi5fXywgMjApXG4gKiAgICAgIH0pO1xuICpcbiAqICAgICAgcHJlZCh7YTogJ2ZvbycsIGI6ICd4eHgnLCB4OiAxMSwgeTogMTl9KTsgLy89PiB0cnVlXG4gKiAgICAgIHByZWQoe2E6ICd4eHgnLCBiOiAneHh4JywgeDogMTEsIHk6IDE5fSk7IC8vPT4gZmFsc2VcbiAqICAgICAgcHJlZCh7YTogJ2ZvbycsIGI6ICdiYXInLCB4OiAxMSwgeTogMTl9KTsgLy89PiBmYWxzZVxuICogICAgICBwcmVkKHthOiAnZm9vJywgYjogJ3h4eCcsIHg6IDEwLCB5OiAxOX0pOyAvLz0+IGZhbHNlXG4gKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAneHh4JywgeDogMTEsIHk6IDIwfSk7IC8vPT4gZmFsc2VcbiAqL1xudmFyIHdoZXJlID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gd2hlcmUoc3BlYywgdGVzdE9iaikge1xuICBmb3IgKHZhciBwcm9wIGluIHNwZWMpIHtcbiAgICBpZiAoX2hhcyhwcm9wLCBzcGVjKSAmJiAhc3BlY1twcm9wXSh0ZXN0T2JqW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgd2hlcmU7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBlcXVhbHMgZnJvbSAnLi9lcXVhbHMnO1xuaW1wb3J0IG1hcCBmcm9tICcuL21hcCc7XG5pbXBvcnQgd2hlcmUgZnJvbSAnLi93aGVyZSc7XG5cbi8qKlxuICogVGFrZXMgYSBzcGVjIG9iamVjdCBhbmQgYSB0ZXN0IG9iamVjdDsgcmV0dXJucyB0cnVlIGlmIHRoZSB0ZXN0IHNhdGlzZmllc1xuICogdGhlIHNwZWMsIGZhbHNlIG90aGVyd2lzZS4gQW4gb2JqZWN0IHNhdGlzZmllcyB0aGUgc3BlYyBpZiwgZm9yIGVhY2ggb2YgdGhlXG4gKiBzcGVjJ3Mgb3duIHByb3BlcnRpZXMsIGFjY2Vzc2luZyB0aGF0IHByb3BlcnR5IG9mIHRoZSBvYmplY3QgZ2l2ZXMgdGhlIHNhbWVcbiAqIHZhbHVlIChpbiBbYFIuZXF1YWxzYF0oI2VxdWFscykgdGVybXMpIGFzIGFjY2Vzc2luZyB0aGF0IHByb3BlcnR5IG9mIHRoZVxuICogc3BlYy5cbiAqXG4gKiBgd2hlcmVFcWAgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBbYHdoZXJlYF0oI3doZXJlKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtTdHJpbmc6ICp9IC0+IHtTdHJpbmc6ICp9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjXG4gKiBAcGFyYW0ge09iamVjdH0gdGVzdE9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5wcm9wRXEsIFIud2hlcmVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyBwcmVkIDo6IE9iamVjdCAtPiBCb29sZWFuXG4gKiAgICAgIHZhciBwcmVkID0gUi53aGVyZUVxKHthOiAxLCBiOiAyfSk7XG4gKlxuICogICAgICBwcmVkKHthOiAxfSk7ICAgICAgICAgICAgICAvLz0+IGZhbHNlXG4gKiAgICAgIHByZWQoe2E6IDEsIGI6IDJ9KTsgICAgICAgIC8vPT4gdHJ1ZVxuICogICAgICBwcmVkKHthOiAxLCBiOiAyLCBjOiAzfSk7ICAvLz0+IHRydWVcbiAqICAgICAgcHJlZCh7YTogMSwgYjogMX0pOyAgICAgICAgLy89PiBmYWxzZVxuICovXG52YXIgd2hlcmVFcSA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHdoZXJlRXEoc3BlYywgdGVzdE9iaikge1xuICByZXR1cm4gd2hlcmUobWFwKGVxdWFscywgc3BlYyksIHRlc3RPYmopO1xufSk7XG5leHBvcnQgZGVmYXVsdCB3aGVyZUVxOyIsImltcG9ydCBfY29udGFpbnMgZnJvbSAnLi9pbnRlcm5hbC9fY29udGFpbnMnO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcbmltcG9ydCBmbGlwIGZyb20gJy4vZmxpcCc7XG5pbXBvcnQgcmVqZWN0IGZyb20gJy4vcmVqZWN0JztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3Qgd2l0aG91dCB2YWx1ZXMgaW4gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICogW2BSLmVxdWFsc2BdKCNlcXVhbHMpIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIHZhbHVlcyB0byBiZSByZW1vdmVkIGZyb20gYGxpc3QyYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBhcnJheSB0byByZW1vdmUgdmFsdWVzIGZyb20uXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIG5ldyBhcnJheSB3aXRob3V0IHZhbHVlcyBpbiBgbGlzdDFgLlxuICogQHNlZSBSLnRyYW5zZHVjZSwgUi5kaWZmZXJlbmNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi53aXRob3V0KFsxLCAyXSwgWzEsIDIsIDEsIDMsIDRdKTsgLy89PiBbMywgNF1cbiAqL1xudmFyIHdpdGhvdXQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiAoeHMsIGxpc3QpIHtcbiAgcmV0dXJuIHJlamVjdChmbGlwKF9jb250YWlucykoeHMpLCBsaXN0KTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgd2l0aG91dDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbGlzdCBvdXQgb2YgdGhlIHR3byBzdXBwbGllZCBieSBjcmVhdGluZyBlYWNoIHBvc3NpYmxlIHBhaXJcbiAqIGZyb20gdGhlIGxpc3RzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFtiXSAtPiBbW2EsYl1dXG4gKiBAcGFyYW0ge0FycmF5fSBhcyBUaGUgZmlyc3QgbGlzdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGJzIFRoZSBzZWNvbmQgbGlzdC5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBtYWRlIGJ5IGNvbWJpbmluZyBlYWNoIHBvc3NpYmxlIHBhaXIgZnJvbVxuICogICAgICAgICBgYXNgIGFuZCBgYnNgIGludG8gcGFpcnMgKGBbYSwgYl1gKS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnhwcm9kKFsxLCAyXSwgWydhJywgJ2InXSk7IC8vPT4gW1sxLCAnYSddLCBbMSwgJ2InXSwgWzIsICdhJ10sIFsyLCAnYiddXVxuICogQHN5bWIgUi54cHJvZChbYSwgYl0sIFtjLCBkXSkgPSBbW2EsIGNdLCBbYSwgZF0sIFtiLCBjXSwgW2IsIGRdXVxuICovXG52YXIgeHByb2QgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiB4cHJvZChhLCBiKSB7XG4gIC8vID0geHByb2RXaXRoKHByZXBlbmQpOyAodGFrZXMgYWJvdXQgMyB0aW1lcyBhcyBsb25nLi4uKVxuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGlsZW4gPSBhLmxlbmd0aDtcbiAgdmFyIGo7XG4gIHZhciBqbGVuID0gYi5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKGlkeCA8IGlsZW4pIHtcbiAgICBqID0gMDtcbiAgICB3aGlsZSAoaiA8IGpsZW4pIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IFthW2lkeF0sIGJbal1dO1xuICAgICAgaiArPSAxO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5leHBvcnQgZGVmYXVsdCB4cHJvZDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tICcuL2ludGVybmFsL19jdXJyeTInO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbGlzdCBvdXQgb2YgdGhlIHR3byBzdXBwbGllZCBieSBwYWlyaW5nIHVwIGVxdWFsbHktcG9zaXRpb25lZFxuICogaXRlbXMgZnJvbSBib3RoIGxpc3RzLiBUaGUgcmV0dXJuZWQgbGlzdCBpcyB0cnVuY2F0ZWQgdG8gdGhlIGxlbmd0aCBvZiB0aGVcbiAqIHNob3J0ZXIgb2YgdGhlIHR3byBpbnB1dCBsaXN0cy5cbiAqIE5vdGU6IGB6aXBgIGlzIGVxdWl2YWxlbnQgdG8gYHppcFdpdGgoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gW2EsIGJdIH0pYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYl0gLT4gW1thLGJdXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIGZpcnN0IGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBtYWRlIGJ5IHBhaXJpbmcgdXAgc2FtZS1pbmRleGVkIGVsZW1lbnRzIG9mIGBsaXN0MWAgYW5kIGBsaXN0MmAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi56aXAoWzEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ10pOyAvLz0+IFtbMSwgJ2EnXSwgWzIsICdiJ10sIFszLCAnYyddXVxuICogQHN5bWIgUi56aXAoW2EsIGIsIGNdLCBbZCwgZSwgZl0pID0gW1thLCBkXSwgW2IsIGVdLCBbYywgZl1dXG4gKi9cbnZhciB6aXAgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiB6aXAoYSwgYikge1xuICB2YXIgcnYgPSBbXTtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgcnZbaWR4XSA9IFthW2lkeF0sIGJbaWR4XV07XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJ2O1xufSk7XG5leHBvcnQgZGVmYXVsdCB6aXA7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSAnLi9pbnRlcm5hbC9fY3VycnkyJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCBvdXQgb2YgYSBsaXN0IG9mIGtleXMgYW5kIGEgbGlzdCBvZiB2YWx1ZXMuXG4gKiBLZXkvdmFsdWUgcGFpcmluZyBpcyB0cnVuY2F0ZWQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgc2hvcnRlciBvZiB0aGUgdHdvIGxpc3RzLlxuICogTm90ZTogYHppcE9iamAgaXMgZXF1aXZhbGVudCB0byBgcGlwZSh6aXAsIGZyb21QYWlycylgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW1N0cmluZ10gLT4gWypdIC0+IHtTdHJpbmc6ICp9XG4gKiBAcGFyYW0ge0FycmF5fSBrZXlzIFRoZSBhcnJheSB0aGF0IHdpbGwgYmUgcHJvcGVydGllcyBvbiB0aGUgb3V0cHV0IG9iamVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgbGlzdCBvZiB2YWx1ZXMgb24gdGhlIG91dHB1dCBvYmplY3QuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvYmplY3QgbWFkZSBieSBwYWlyaW5nIHVwIHNhbWUtaW5kZXhlZCBlbGVtZW50cyBvZiBga2V5c2AgYW5kIGB2YWx1ZXNgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuemlwT2JqKFsnYScsICdiJywgJ2MnXSwgWzEsIDIsIDNdKTsgLy89PiB7YTogMSwgYjogMiwgYzogM31cbiAqL1xudmFyIHppcE9iaiA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHppcE9iaihrZXlzLCB2YWx1ZXMpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBNYXRoLm1pbihrZXlzLmxlbmd0aCwgdmFsdWVzLmxlbmd0aCk7XG4gIHZhciBvdXQgPSB7fTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIG91dFtrZXlzW2lkeF1dID0gdmFsdWVzW2lkeF07XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgemlwT2JqOyIsImltcG9ydCBfY3VycnkzIGZyb20gJy4vaW50ZXJuYWwvX2N1cnJ5Myc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBsaXN0IG91dCBvZiB0aGUgdHdvIHN1cHBsaWVkIGJ5IGFwcGx5aW5nIHRoZSBmdW5jdGlvbiB0byBlYWNoXG4gKiBlcXVhbGx5LXBvc2l0aW9uZWQgcGFpciBpbiB0aGUgbGlzdHMuIFRoZSByZXR1cm5lZCBsaXN0IGlzIHRydW5jYXRlZCB0byB0aGVcbiAqIGxlbmd0aCBvZiB0aGUgc2hvcnRlciBvZiB0aGUgdHdvIGlucHV0IGxpc3RzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSwgYikgLT4gYykgLT4gW2FdIC0+IFtiXSAtPiBbY11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNvbWJpbmUgdGhlIHR3byBlbGVtZW50cyBpbnRvIG9uZSB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBhcnJheSB0byBjb25zaWRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3QgbWFkZSBieSBjb21iaW5pbmcgc2FtZS1pbmRleGVkIGVsZW1lbnRzIG9mIGBsaXN0MWAgYW5kIGBsaXN0MmBcbiAqICAgICAgICAgdXNpbmcgYGZuYC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZiA9ICh4LCB5KSA9PiB7XG4gKiAgICAgICAgLy8gLi4uXG4gKiAgICAgIH07XG4gKiAgICAgIFIuemlwV2l0aChmLCBbMSwgMiwgM10sIFsnYScsICdiJywgJ2MnXSk7XG4gKiAgICAgIC8vPT4gW2YoMSwgJ2EnKSwgZigyLCAnYicpLCBmKDMsICdjJyldXG4gKiBAc3ltYiBSLnppcFdpdGgoZm4sIFthLCBiLCBjXSwgW2QsIGUsIGZdKSA9IFtmbihhLCBkKSwgZm4oYiwgZSksIGZuKGMsIGYpXVxuICovXG52YXIgemlwV2l0aCA9IC8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIHppcFdpdGgoZm4sIGEsIGIpIHtcbiAgdmFyIHJ2ID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHJ2W2lkeF0gPSBmbihhW2lkeF0sIGJbaWR4XSk7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJ2O1xufSk7XG5leHBvcnQgZGVmYXVsdCB6aXBXaXRoOyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi8nKTtcbiIsIi8vIExpc3Qgb2YgdmFsaWQgZW50aXRpZXNcbi8vXG4vLyBHZW5lcmF0ZSB3aXRoIC4vc3VwcG9ydC9lbnRpdGllcy5qcyBzY3JpcHRcbi8vXG4ndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50IHF1b3RlczowKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBcIkFhY3V0ZVwiOlwiXFx1MDBDMVwiLFxuICBcImFhY3V0ZVwiOlwiXFx1MDBFMVwiLFxuICBcIkFicmV2ZVwiOlwiXFx1MDEwMlwiLFxuICBcImFicmV2ZVwiOlwiXFx1MDEwM1wiLFxuICBcImFjXCI6XCJcXHUyMjNFXCIsXG4gIFwiYWNkXCI6XCJcXHUyMjNGXCIsXG4gIFwiYWNFXCI6XCJcXHUyMjNFXFx1MDMzM1wiLFxuICBcIkFjaXJjXCI6XCJcXHUwMEMyXCIsXG4gIFwiYWNpcmNcIjpcIlxcdTAwRTJcIixcbiAgXCJhY3V0ZVwiOlwiXFx1MDBCNFwiLFxuICBcIkFjeVwiOlwiXFx1MDQxMFwiLFxuICBcImFjeVwiOlwiXFx1MDQzMFwiLFxuICBcIkFFbGlnXCI6XCJcXHUwMEM2XCIsXG4gIFwiYWVsaWdcIjpcIlxcdTAwRTZcIixcbiAgXCJhZlwiOlwiXFx1MjA2MVwiLFxuICBcIkFmclwiOlwiXFx1RDgzNVxcdUREMDRcIixcbiAgXCJhZnJcIjpcIlxcdUQ4MzVcXHVERDFFXCIsXG4gIFwiQWdyYXZlXCI6XCJcXHUwMEMwXCIsXG4gIFwiYWdyYXZlXCI6XCJcXHUwMEUwXCIsXG4gIFwiYWxlZnN5bVwiOlwiXFx1MjEzNVwiLFxuICBcImFsZXBoXCI6XCJcXHUyMTM1XCIsXG4gIFwiQWxwaGFcIjpcIlxcdTAzOTFcIixcbiAgXCJhbHBoYVwiOlwiXFx1MDNCMVwiLFxuICBcIkFtYWNyXCI6XCJcXHUwMTAwXCIsXG4gIFwiYW1hY3JcIjpcIlxcdTAxMDFcIixcbiAgXCJhbWFsZ1wiOlwiXFx1MkEzRlwiLFxuICBcIkFNUFwiOlwiXFx1MDAyNlwiLFxuICBcImFtcFwiOlwiXFx1MDAyNlwiLFxuICBcIkFuZFwiOlwiXFx1MkE1M1wiLFxuICBcImFuZFwiOlwiXFx1MjIyN1wiLFxuICBcImFuZGFuZFwiOlwiXFx1MkE1NVwiLFxuICBcImFuZGRcIjpcIlxcdTJBNUNcIixcbiAgXCJhbmRzbG9wZVwiOlwiXFx1MkE1OFwiLFxuICBcImFuZHZcIjpcIlxcdTJBNUFcIixcbiAgXCJhbmdcIjpcIlxcdTIyMjBcIixcbiAgXCJhbmdlXCI6XCJcXHUyOUE0XCIsXG4gIFwiYW5nbGVcIjpcIlxcdTIyMjBcIixcbiAgXCJhbmdtc2RcIjpcIlxcdTIyMjFcIixcbiAgXCJhbmdtc2RhYVwiOlwiXFx1MjlBOFwiLFxuICBcImFuZ21zZGFiXCI6XCJcXHUyOUE5XCIsXG4gIFwiYW5nbXNkYWNcIjpcIlxcdTI5QUFcIixcbiAgXCJhbmdtc2RhZFwiOlwiXFx1MjlBQlwiLFxuICBcImFuZ21zZGFlXCI6XCJcXHUyOUFDXCIsXG4gIFwiYW5nbXNkYWZcIjpcIlxcdTI5QURcIixcbiAgXCJhbmdtc2RhZ1wiOlwiXFx1MjlBRVwiLFxuICBcImFuZ21zZGFoXCI6XCJcXHUyOUFGXCIsXG4gIFwiYW5ncnRcIjpcIlxcdTIyMUZcIixcbiAgXCJhbmdydHZiXCI6XCJcXHUyMkJFXCIsXG4gIFwiYW5ncnR2YmRcIjpcIlxcdTI5OURcIixcbiAgXCJhbmdzcGhcIjpcIlxcdTIyMjJcIixcbiAgXCJhbmdzdFwiOlwiXFx1MDBDNVwiLFxuICBcImFuZ3phcnJcIjpcIlxcdTIzN0NcIixcbiAgXCJBb2dvblwiOlwiXFx1MDEwNFwiLFxuICBcImFvZ29uXCI6XCJcXHUwMTA1XCIsXG4gIFwiQW9wZlwiOlwiXFx1RDgzNVxcdUREMzhcIixcbiAgXCJhb3BmXCI6XCJcXHVEODM1XFx1REQ1MlwiLFxuICBcImFwXCI6XCJcXHUyMjQ4XCIsXG4gIFwiYXBhY2lyXCI6XCJcXHUyQTZGXCIsXG4gIFwiYXBFXCI6XCJcXHUyQTcwXCIsXG4gIFwiYXBlXCI6XCJcXHUyMjRBXCIsXG4gIFwiYXBpZFwiOlwiXFx1MjI0QlwiLFxuICBcImFwb3NcIjpcIlxcdTAwMjdcIixcbiAgXCJBcHBseUZ1bmN0aW9uXCI6XCJcXHUyMDYxXCIsXG4gIFwiYXBwcm94XCI6XCJcXHUyMjQ4XCIsXG4gIFwiYXBwcm94ZXFcIjpcIlxcdTIyNEFcIixcbiAgXCJBcmluZ1wiOlwiXFx1MDBDNVwiLFxuICBcImFyaW5nXCI6XCJcXHUwMEU1XCIsXG4gIFwiQXNjclwiOlwiXFx1RDgzNVxcdURDOUNcIixcbiAgXCJhc2NyXCI6XCJcXHVEODM1XFx1RENCNlwiLFxuICBcIkFzc2lnblwiOlwiXFx1MjI1NFwiLFxuICBcImFzdFwiOlwiXFx1MDAyQVwiLFxuICBcImFzeW1wXCI6XCJcXHUyMjQ4XCIsXG4gIFwiYXN5bXBlcVwiOlwiXFx1MjI0RFwiLFxuICBcIkF0aWxkZVwiOlwiXFx1MDBDM1wiLFxuICBcImF0aWxkZVwiOlwiXFx1MDBFM1wiLFxuICBcIkF1bWxcIjpcIlxcdTAwQzRcIixcbiAgXCJhdW1sXCI6XCJcXHUwMEU0XCIsXG4gIFwiYXdjb25pbnRcIjpcIlxcdTIyMzNcIixcbiAgXCJhd2ludFwiOlwiXFx1MkExMVwiLFxuICBcImJhY2tjb25nXCI6XCJcXHUyMjRDXCIsXG4gIFwiYmFja2Vwc2lsb25cIjpcIlxcdTAzRjZcIixcbiAgXCJiYWNrcHJpbWVcIjpcIlxcdTIwMzVcIixcbiAgXCJiYWNrc2ltXCI6XCJcXHUyMjNEXCIsXG4gIFwiYmFja3NpbWVxXCI6XCJcXHUyMkNEXCIsXG4gIFwiQmFja3NsYXNoXCI6XCJcXHUyMjE2XCIsXG4gIFwiQmFydlwiOlwiXFx1MkFFN1wiLFxuICBcImJhcnZlZVwiOlwiXFx1MjJCRFwiLFxuICBcIkJhcndlZFwiOlwiXFx1MjMwNlwiLFxuICBcImJhcndlZFwiOlwiXFx1MjMwNVwiLFxuICBcImJhcndlZGdlXCI6XCJcXHUyMzA1XCIsXG4gIFwiYmJya1wiOlwiXFx1MjNCNVwiLFxuICBcImJicmt0YnJrXCI6XCJcXHUyM0I2XCIsXG4gIFwiYmNvbmdcIjpcIlxcdTIyNENcIixcbiAgXCJCY3lcIjpcIlxcdTA0MTFcIixcbiAgXCJiY3lcIjpcIlxcdTA0MzFcIixcbiAgXCJiZHF1b1wiOlwiXFx1MjAxRVwiLFxuICBcImJlY2F1c1wiOlwiXFx1MjIzNVwiLFxuICBcIkJlY2F1c2VcIjpcIlxcdTIyMzVcIixcbiAgXCJiZWNhdXNlXCI6XCJcXHUyMjM1XCIsXG4gIFwiYmVtcHR5dlwiOlwiXFx1MjlCMFwiLFxuICBcImJlcHNpXCI6XCJcXHUwM0Y2XCIsXG4gIFwiYmVybm91XCI6XCJcXHUyMTJDXCIsXG4gIFwiQmVybm91bGxpc1wiOlwiXFx1MjEyQ1wiLFxuICBcIkJldGFcIjpcIlxcdTAzOTJcIixcbiAgXCJiZXRhXCI6XCJcXHUwM0IyXCIsXG4gIFwiYmV0aFwiOlwiXFx1MjEzNlwiLFxuICBcImJldHdlZW5cIjpcIlxcdTIyNkNcIixcbiAgXCJCZnJcIjpcIlxcdUQ4MzVcXHVERDA1XCIsXG4gIFwiYmZyXCI6XCJcXHVEODM1XFx1REQxRlwiLFxuICBcImJpZ2NhcFwiOlwiXFx1MjJDMlwiLFxuICBcImJpZ2NpcmNcIjpcIlxcdTI1RUZcIixcbiAgXCJiaWdjdXBcIjpcIlxcdTIyQzNcIixcbiAgXCJiaWdvZG90XCI6XCJcXHUyQTAwXCIsXG4gIFwiYmlnb3BsdXNcIjpcIlxcdTJBMDFcIixcbiAgXCJiaWdvdGltZXNcIjpcIlxcdTJBMDJcIixcbiAgXCJiaWdzcWN1cFwiOlwiXFx1MkEwNlwiLFxuICBcImJpZ3N0YXJcIjpcIlxcdTI2MDVcIixcbiAgXCJiaWd0cmlhbmdsZWRvd25cIjpcIlxcdTI1QkRcIixcbiAgXCJiaWd0cmlhbmdsZXVwXCI6XCJcXHUyNUIzXCIsXG4gIFwiYmlndXBsdXNcIjpcIlxcdTJBMDRcIixcbiAgXCJiaWd2ZWVcIjpcIlxcdTIyQzFcIixcbiAgXCJiaWd3ZWRnZVwiOlwiXFx1MjJDMFwiLFxuICBcImJrYXJvd1wiOlwiXFx1MjkwRFwiLFxuICBcImJsYWNrbG96ZW5nZVwiOlwiXFx1MjlFQlwiLFxuICBcImJsYWNrc3F1YXJlXCI6XCJcXHUyNUFBXCIsXG4gIFwiYmxhY2t0cmlhbmdsZVwiOlwiXFx1MjVCNFwiLFxuICBcImJsYWNrdHJpYW5nbGVkb3duXCI6XCJcXHUyNUJFXCIsXG4gIFwiYmxhY2t0cmlhbmdsZWxlZnRcIjpcIlxcdTI1QzJcIixcbiAgXCJibGFja3RyaWFuZ2xlcmlnaHRcIjpcIlxcdTI1QjhcIixcbiAgXCJibGFua1wiOlwiXFx1MjQyM1wiLFxuICBcImJsazEyXCI6XCJcXHUyNTkyXCIsXG4gIFwiYmxrMTRcIjpcIlxcdTI1OTFcIixcbiAgXCJibGszNFwiOlwiXFx1MjU5M1wiLFxuICBcImJsb2NrXCI6XCJcXHUyNTg4XCIsXG4gIFwiYm5lXCI6XCJcXHUwMDNEXFx1MjBFNVwiLFxuICBcImJuZXF1aXZcIjpcIlxcdTIyNjFcXHUyMEU1XCIsXG4gIFwiYk5vdFwiOlwiXFx1MkFFRFwiLFxuICBcImJub3RcIjpcIlxcdTIzMTBcIixcbiAgXCJCb3BmXCI6XCJcXHVEODM1XFx1REQzOVwiLFxuICBcImJvcGZcIjpcIlxcdUQ4MzVcXHVERDUzXCIsXG4gIFwiYm90XCI6XCJcXHUyMkE1XCIsXG4gIFwiYm90dG9tXCI6XCJcXHUyMkE1XCIsXG4gIFwiYm93dGllXCI6XCJcXHUyMkM4XCIsXG4gIFwiYm94Ym94XCI6XCJcXHUyOUM5XCIsXG4gIFwiYm94RExcIjpcIlxcdTI1NTdcIixcbiAgXCJib3hEbFwiOlwiXFx1MjU1NlwiLFxuICBcImJveGRMXCI6XCJcXHUyNTU1XCIsXG4gIFwiYm94ZGxcIjpcIlxcdTI1MTBcIixcbiAgXCJib3hEUlwiOlwiXFx1MjU1NFwiLFxuICBcImJveERyXCI6XCJcXHUyNTUzXCIsXG4gIFwiYm94ZFJcIjpcIlxcdTI1NTJcIixcbiAgXCJib3hkclwiOlwiXFx1MjUwQ1wiLFxuICBcImJveEhcIjpcIlxcdTI1NTBcIixcbiAgXCJib3hoXCI6XCJcXHUyNTAwXCIsXG4gIFwiYm94SERcIjpcIlxcdTI1NjZcIixcbiAgXCJib3hIZFwiOlwiXFx1MjU2NFwiLFxuICBcImJveGhEXCI6XCJcXHUyNTY1XCIsXG4gIFwiYm94aGRcIjpcIlxcdTI1MkNcIixcbiAgXCJib3hIVVwiOlwiXFx1MjU2OVwiLFxuICBcImJveEh1XCI6XCJcXHUyNTY3XCIsXG4gIFwiYm94aFVcIjpcIlxcdTI1NjhcIixcbiAgXCJib3hodVwiOlwiXFx1MjUzNFwiLFxuICBcImJveG1pbnVzXCI6XCJcXHUyMjlGXCIsXG4gIFwiYm94cGx1c1wiOlwiXFx1MjI5RVwiLFxuICBcImJveHRpbWVzXCI6XCJcXHUyMkEwXCIsXG4gIFwiYm94VUxcIjpcIlxcdTI1NURcIixcbiAgXCJib3hVbFwiOlwiXFx1MjU1Q1wiLFxuICBcImJveHVMXCI6XCJcXHUyNTVCXCIsXG4gIFwiYm94dWxcIjpcIlxcdTI1MThcIixcbiAgXCJib3hVUlwiOlwiXFx1MjU1QVwiLFxuICBcImJveFVyXCI6XCJcXHUyNTU5XCIsXG4gIFwiYm94dVJcIjpcIlxcdTI1NThcIixcbiAgXCJib3h1clwiOlwiXFx1MjUxNFwiLFxuICBcImJveFZcIjpcIlxcdTI1NTFcIixcbiAgXCJib3h2XCI6XCJcXHUyNTAyXCIsXG4gIFwiYm94VkhcIjpcIlxcdTI1NkNcIixcbiAgXCJib3hWaFwiOlwiXFx1MjU2QlwiLFxuICBcImJveHZIXCI6XCJcXHUyNTZBXCIsXG4gIFwiYm94dmhcIjpcIlxcdTI1M0NcIixcbiAgXCJib3hWTFwiOlwiXFx1MjU2M1wiLFxuICBcImJveFZsXCI6XCJcXHUyNTYyXCIsXG4gIFwiYm94dkxcIjpcIlxcdTI1NjFcIixcbiAgXCJib3h2bFwiOlwiXFx1MjUyNFwiLFxuICBcImJveFZSXCI6XCJcXHUyNTYwXCIsXG4gIFwiYm94VnJcIjpcIlxcdTI1NUZcIixcbiAgXCJib3h2UlwiOlwiXFx1MjU1RVwiLFxuICBcImJveHZyXCI6XCJcXHUyNTFDXCIsXG4gIFwiYnByaW1lXCI6XCJcXHUyMDM1XCIsXG4gIFwiQnJldmVcIjpcIlxcdTAyRDhcIixcbiAgXCJicmV2ZVwiOlwiXFx1MDJEOFwiLFxuICBcImJydmJhclwiOlwiXFx1MDBBNlwiLFxuICBcIkJzY3JcIjpcIlxcdTIxMkNcIixcbiAgXCJic2NyXCI6XCJcXHVEODM1XFx1RENCN1wiLFxuICBcImJzZW1pXCI6XCJcXHUyMDRGXCIsXG4gIFwiYnNpbVwiOlwiXFx1MjIzRFwiLFxuICBcImJzaW1lXCI6XCJcXHUyMkNEXCIsXG4gIFwiYnNvbFwiOlwiXFx1MDA1Q1wiLFxuICBcImJzb2xiXCI6XCJcXHUyOUM1XCIsXG4gIFwiYnNvbGhzdWJcIjpcIlxcdTI3QzhcIixcbiAgXCJidWxsXCI6XCJcXHUyMDIyXCIsXG4gIFwiYnVsbGV0XCI6XCJcXHUyMDIyXCIsXG4gIFwiYnVtcFwiOlwiXFx1MjI0RVwiLFxuICBcImJ1bXBFXCI6XCJcXHUyQUFFXCIsXG4gIFwiYnVtcGVcIjpcIlxcdTIyNEZcIixcbiAgXCJCdW1wZXFcIjpcIlxcdTIyNEVcIixcbiAgXCJidW1wZXFcIjpcIlxcdTIyNEZcIixcbiAgXCJDYWN1dGVcIjpcIlxcdTAxMDZcIixcbiAgXCJjYWN1dGVcIjpcIlxcdTAxMDdcIixcbiAgXCJDYXBcIjpcIlxcdTIyRDJcIixcbiAgXCJjYXBcIjpcIlxcdTIyMjlcIixcbiAgXCJjYXBhbmRcIjpcIlxcdTJBNDRcIixcbiAgXCJjYXBicmN1cFwiOlwiXFx1MkE0OVwiLFxuICBcImNhcGNhcFwiOlwiXFx1MkE0QlwiLFxuICBcImNhcGN1cFwiOlwiXFx1MkE0N1wiLFxuICBcImNhcGRvdFwiOlwiXFx1MkE0MFwiLFxuICBcIkNhcGl0YWxEaWZmZXJlbnRpYWxEXCI6XCJcXHUyMTQ1XCIsXG4gIFwiY2Fwc1wiOlwiXFx1MjIyOVxcdUZFMDBcIixcbiAgXCJjYXJldFwiOlwiXFx1MjA0MVwiLFxuICBcImNhcm9uXCI6XCJcXHUwMkM3XCIsXG4gIFwiQ2F5bGV5c1wiOlwiXFx1MjEyRFwiLFxuICBcImNjYXBzXCI6XCJcXHUyQTREXCIsXG4gIFwiQ2Nhcm9uXCI6XCJcXHUwMTBDXCIsXG4gIFwiY2Nhcm9uXCI6XCJcXHUwMTBEXCIsXG4gIFwiQ2NlZGlsXCI6XCJcXHUwMEM3XCIsXG4gIFwiY2NlZGlsXCI6XCJcXHUwMEU3XCIsXG4gIFwiQ2NpcmNcIjpcIlxcdTAxMDhcIixcbiAgXCJjY2lyY1wiOlwiXFx1MDEwOVwiLFxuICBcIkNjb25pbnRcIjpcIlxcdTIyMzBcIixcbiAgXCJjY3Vwc1wiOlwiXFx1MkE0Q1wiLFxuICBcImNjdXBzc21cIjpcIlxcdTJBNTBcIixcbiAgXCJDZG90XCI6XCJcXHUwMTBBXCIsXG4gIFwiY2RvdFwiOlwiXFx1MDEwQlwiLFxuICBcImNlZGlsXCI6XCJcXHUwMEI4XCIsXG4gIFwiQ2VkaWxsYVwiOlwiXFx1MDBCOFwiLFxuICBcImNlbXB0eXZcIjpcIlxcdTI5QjJcIixcbiAgXCJjZW50XCI6XCJcXHUwMEEyXCIsXG4gIFwiQ2VudGVyRG90XCI6XCJcXHUwMEI3XCIsXG4gIFwiY2VudGVyZG90XCI6XCJcXHUwMEI3XCIsXG4gIFwiQ2ZyXCI6XCJcXHUyMTJEXCIsXG4gIFwiY2ZyXCI6XCJcXHVEODM1XFx1REQyMFwiLFxuICBcIkNIY3lcIjpcIlxcdTA0MjdcIixcbiAgXCJjaGN5XCI6XCJcXHUwNDQ3XCIsXG4gIFwiY2hlY2tcIjpcIlxcdTI3MTNcIixcbiAgXCJjaGVja21hcmtcIjpcIlxcdTI3MTNcIixcbiAgXCJDaGlcIjpcIlxcdTAzQTdcIixcbiAgXCJjaGlcIjpcIlxcdTAzQzdcIixcbiAgXCJjaXJcIjpcIlxcdTI1Q0JcIixcbiAgXCJjaXJjXCI6XCJcXHUwMkM2XCIsXG4gIFwiY2lyY2VxXCI6XCJcXHUyMjU3XCIsXG4gIFwiY2lyY2xlYXJyb3dsZWZ0XCI6XCJcXHUyMUJBXCIsXG4gIFwiY2lyY2xlYXJyb3dyaWdodFwiOlwiXFx1MjFCQlwiLFxuICBcImNpcmNsZWRhc3RcIjpcIlxcdTIyOUJcIixcbiAgXCJjaXJjbGVkY2lyY1wiOlwiXFx1MjI5QVwiLFxuICBcImNpcmNsZWRkYXNoXCI6XCJcXHUyMjlEXCIsXG4gIFwiQ2lyY2xlRG90XCI6XCJcXHUyMjk5XCIsXG4gIFwiY2lyY2xlZFJcIjpcIlxcdTAwQUVcIixcbiAgXCJjaXJjbGVkU1wiOlwiXFx1MjRDOFwiLFxuICBcIkNpcmNsZU1pbnVzXCI6XCJcXHUyMjk2XCIsXG4gIFwiQ2lyY2xlUGx1c1wiOlwiXFx1MjI5NVwiLFxuICBcIkNpcmNsZVRpbWVzXCI6XCJcXHUyMjk3XCIsXG4gIFwiY2lyRVwiOlwiXFx1MjlDM1wiLFxuICBcImNpcmVcIjpcIlxcdTIyNTdcIixcbiAgXCJjaXJmbmludFwiOlwiXFx1MkExMFwiLFxuICBcImNpcm1pZFwiOlwiXFx1MkFFRlwiLFxuICBcImNpcnNjaXJcIjpcIlxcdTI5QzJcIixcbiAgXCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjpcIlxcdTIyMzJcIixcbiAgXCJDbG9zZUN1cmx5RG91YmxlUXVvdGVcIjpcIlxcdTIwMURcIixcbiAgXCJDbG9zZUN1cmx5UXVvdGVcIjpcIlxcdTIwMTlcIixcbiAgXCJjbHVic1wiOlwiXFx1MjY2M1wiLFxuICBcImNsdWJzdWl0XCI6XCJcXHUyNjYzXCIsXG4gIFwiQ29sb25cIjpcIlxcdTIyMzdcIixcbiAgXCJjb2xvblwiOlwiXFx1MDAzQVwiLFxuICBcIkNvbG9uZVwiOlwiXFx1MkE3NFwiLFxuICBcImNvbG9uZVwiOlwiXFx1MjI1NFwiLFxuICBcImNvbG9uZXFcIjpcIlxcdTIyNTRcIixcbiAgXCJjb21tYVwiOlwiXFx1MDAyQ1wiLFxuICBcImNvbW1hdFwiOlwiXFx1MDA0MFwiLFxuICBcImNvbXBcIjpcIlxcdTIyMDFcIixcbiAgXCJjb21wZm5cIjpcIlxcdTIyMThcIixcbiAgXCJjb21wbGVtZW50XCI6XCJcXHUyMjAxXCIsXG4gIFwiY29tcGxleGVzXCI6XCJcXHUyMTAyXCIsXG4gIFwiY29uZ1wiOlwiXFx1MjI0NVwiLFxuICBcImNvbmdkb3RcIjpcIlxcdTJBNkRcIixcbiAgXCJDb25ncnVlbnRcIjpcIlxcdTIyNjFcIixcbiAgXCJDb25pbnRcIjpcIlxcdTIyMkZcIixcbiAgXCJjb25pbnRcIjpcIlxcdTIyMkVcIixcbiAgXCJDb250b3VySW50ZWdyYWxcIjpcIlxcdTIyMkVcIixcbiAgXCJDb3BmXCI6XCJcXHUyMTAyXCIsXG4gIFwiY29wZlwiOlwiXFx1RDgzNVxcdURENTRcIixcbiAgXCJjb3Byb2RcIjpcIlxcdTIyMTBcIixcbiAgXCJDb3Byb2R1Y3RcIjpcIlxcdTIyMTBcIixcbiAgXCJDT1BZXCI6XCJcXHUwMEE5XCIsXG4gIFwiY29weVwiOlwiXFx1MDBBOVwiLFxuICBcImNvcHlzclwiOlwiXFx1MjExN1wiLFxuICBcIkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjpcIlxcdTIyMzNcIixcbiAgXCJjcmFyclwiOlwiXFx1MjFCNVwiLFxuICBcIkNyb3NzXCI6XCJcXHUyQTJGXCIsXG4gIFwiY3Jvc3NcIjpcIlxcdTI3MTdcIixcbiAgXCJDc2NyXCI6XCJcXHVEODM1XFx1REM5RVwiLFxuICBcImNzY3JcIjpcIlxcdUQ4MzVcXHVEQ0I4XCIsXG4gIFwiY3N1YlwiOlwiXFx1MkFDRlwiLFxuICBcImNzdWJlXCI6XCJcXHUyQUQxXCIsXG4gIFwiY3N1cFwiOlwiXFx1MkFEMFwiLFxuICBcImNzdXBlXCI6XCJcXHUyQUQyXCIsXG4gIFwiY3Rkb3RcIjpcIlxcdTIyRUZcIixcbiAgXCJjdWRhcnJsXCI6XCJcXHUyOTM4XCIsXG4gIFwiY3VkYXJyclwiOlwiXFx1MjkzNVwiLFxuICBcImN1ZXByXCI6XCJcXHUyMkRFXCIsXG4gIFwiY3Vlc2NcIjpcIlxcdTIyREZcIixcbiAgXCJjdWxhcnJcIjpcIlxcdTIxQjZcIixcbiAgXCJjdWxhcnJwXCI6XCJcXHUyOTNEXCIsXG4gIFwiQ3VwXCI6XCJcXHUyMkQzXCIsXG4gIFwiY3VwXCI6XCJcXHUyMjJBXCIsXG4gIFwiY3VwYnJjYXBcIjpcIlxcdTJBNDhcIixcbiAgXCJDdXBDYXBcIjpcIlxcdTIyNERcIixcbiAgXCJjdXBjYXBcIjpcIlxcdTJBNDZcIixcbiAgXCJjdXBjdXBcIjpcIlxcdTJBNEFcIixcbiAgXCJjdXBkb3RcIjpcIlxcdTIyOERcIixcbiAgXCJjdXBvclwiOlwiXFx1MkE0NVwiLFxuICBcImN1cHNcIjpcIlxcdTIyMkFcXHVGRTAwXCIsXG4gIFwiY3VyYXJyXCI6XCJcXHUyMUI3XCIsXG4gIFwiY3VyYXJybVwiOlwiXFx1MjkzQ1wiLFxuICBcImN1cmx5ZXFwcmVjXCI6XCJcXHUyMkRFXCIsXG4gIFwiY3VybHllcXN1Y2NcIjpcIlxcdTIyREZcIixcbiAgXCJjdXJseXZlZVwiOlwiXFx1MjJDRVwiLFxuICBcImN1cmx5d2VkZ2VcIjpcIlxcdTIyQ0ZcIixcbiAgXCJjdXJyZW5cIjpcIlxcdTAwQTRcIixcbiAgXCJjdXJ2ZWFycm93bGVmdFwiOlwiXFx1MjFCNlwiLFxuICBcImN1cnZlYXJyb3dyaWdodFwiOlwiXFx1MjFCN1wiLFxuICBcImN1dmVlXCI6XCJcXHUyMkNFXCIsXG4gIFwiY3V3ZWRcIjpcIlxcdTIyQ0ZcIixcbiAgXCJjd2NvbmludFwiOlwiXFx1MjIzMlwiLFxuICBcImN3aW50XCI6XCJcXHUyMjMxXCIsXG4gIFwiY3lsY3R5XCI6XCJcXHUyMzJEXCIsXG4gIFwiRGFnZ2VyXCI6XCJcXHUyMDIxXCIsXG4gIFwiZGFnZ2VyXCI6XCJcXHUyMDIwXCIsXG4gIFwiZGFsZXRoXCI6XCJcXHUyMTM4XCIsXG4gIFwiRGFyclwiOlwiXFx1MjFBMVwiLFxuICBcImRBcnJcIjpcIlxcdTIxRDNcIixcbiAgXCJkYXJyXCI6XCJcXHUyMTkzXCIsXG4gIFwiZGFzaFwiOlwiXFx1MjAxMFwiLFxuICBcIkRhc2h2XCI6XCJcXHUyQUU0XCIsXG4gIFwiZGFzaHZcIjpcIlxcdTIyQTNcIixcbiAgXCJkYmthcm93XCI6XCJcXHUyOTBGXCIsXG4gIFwiZGJsYWNcIjpcIlxcdTAyRERcIixcbiAgXCJEY2Fyb25cIjpcIlxcdTAxMEVcIixcbiAgXCJkY2Fyb25cIjpcIlxcdTAxMEZcIixcbiAgXCJEY3lcIjpcIlxcdTA0MTRcIixcbiAgXCJkY3lcIjpcIlxcdTA0MzRcIixcbiAgXCJERFwiOlwiXFx1MjE0NVwiLFxuICBcImRkXCI6XCJcXHUyMTQ2XCIsXG4gIFwiZGRhZ2dlclwiOlwiXFx1MjAyMVwiLFxuICBcImRkYXJyXCI6XCJcXHUyMUNBXCIsXG4gIFwiRERvdHJhaGRcIjpcIlxcdTI5MTFcIixcbiAgXCJkZG90c2VxXCI6XCJcXHUyQTc3XCIsXG4gIFwiZGVnXCI6XCJcXHUwMEIwXCIsXG4gIFwiRGVsXCI6XCJcXHUyMjA3XCIsXG4gIFwiRGVsdGFcIjpcIlxcdTAzOTRcIixcbiAgXCJkZWx0YVwiOlwiXFx1MDNCNFwiLFxuICBcImRlbXB0eXZcIjpcIlxcdTI5QjFcIixcbiAgXCJkZmlzaHRcIjpcIlxcdTI5N0ZcIixcbiAgXCJEZnJcIjpcIlxcdUQ4MzVcXHVERDA3XCIsXG4gIFwiZGZyXCI6XCJcXHVEODM1XFx1REQyMVwiLFxuICBcImRIYXJcIjpcIlxcdTI5NjVcIixcbiAgXCJkaGFybFwiOlwiXFx1MjFDM1wiLFxuICBcImRoYXJyXCI6XCJcXHUyMUMyXCIsXG4gIFwiRGlhY3JpdGljYWxBY3V0ZVwiOlwiXFx1MDBCNFwiLFxuICBcIkRpYWNyaXRpY2FsRG90XCI6XCJcXHUwMkQ5XCIsXG4gIFwiRGlhY3JpdGljYWxEb3VibGVBY3V0ZVwiOlwiXFx1MDJERFwiLFxuICBcIkRpYWNyaXRpY2FsR3JhdmVcIjpcIlxcdTAwNjBcIixcbiAgXCJEaWFjcml0aWNhbFRpbGRlXCI6XCJcXHUwMkRDXCIsXG4gIFwiZGlhbVwiOlwiXFx1MjJDNFwiLFxuICBcIkRpYW1vbmRcIjpcIlxcdTIyQzRcIixcbiAgXCJkaWFtb25kXCI6XCJcXHUyMkM0XCIsXG4gIFwiZGlhbW9uZHN1aXRcIjpcIlxcdTI2NjZcIixcbiAgXCJkaWFtc1wiOlwiXFx1MjY2NlwiLFxuICBcImRpZVwiOlwiXFx1MDBBOFwiLFxuICBcIkRpZmZlcmVudGlhbERcIjpcIlxcdTIxNDZcIixcbiAgXCJkaWdhbW1hXCI6XCJcXHUwM0REXCIsXG4gIFwiZGlzaW5cIjpcIlxcdTIyRjJcIixcbiAgXCJkaXZcIjpcIlxcdTAwRjdcIixcbiAgXCJkaXZpZGVcIjpcIlxcdTAwRjdcIixcbiAgXCJkaXZpZGVvbnRpbWVzXCI6XCJcXHUyMkM3XCIsXG4gIFwiZGl2b254XCI6XCJcXHUyMkM3XCIsXG4gIFwiREpjeVwiOlwiXFx1MDQwMlwiLFxuICBcImRqY3lcIjpcIlxcdTA0NTJcIixcbiAgXCJkbGNvcm5cIjpcIlxcdTIzMUVcIixcbiAgXCJkbGNyb3BcIjpcIlxcdTIzMERcIixcbiAgXCJkb2xsYXJcIjpcIlxcdTAwMjRcIixcbiAgXCJEb3BmXCI6XCJcXHVEODM1XFx1REQzQlwiLFxuICBcImRvcGZcIjpcIlxcdUQ4MzVcXHVERDU1XCIsXG4gIFwiRG90XCI6XCJcXHUwMEE4XCIsXG4gIFwiZG90XCI6XCJcXHUwMkQ5XCIsXG4gIFwiRG90RG90XCI6XCJcXHUyMERDXCIsXG4gIFwiZG90ZXFcIjpcIlxcdTIyNTBcIixcbiAgXCJkb3RlcWRvdFwiOlwiXFx1MjI1MVwiLFxuICBcIkRvdEVxdWFsXCI6XCJcXHUyMjUwXCIsXG4gIFwiZG90bWludXNcIjpcIlxcdTIyMzhcIixcbiAgXCJkb3RwbHVzXCI6XCJcXHUyMjE0XCIsXG4gIFwiZG90c3F1YXJlXCI6XCJcXHUyMkExXCIsXG4gIFwiZG91YmxlYmFyd2VkZ2VcIjpcIlxcdTIzMDZcIixcbiAgXCJEb3VibGVDb250b3VySW50ZWdyYWxcIjpcIlxcdTIyMkZcIixcbiAgXCJEb3VibGVEb3RcIjpcIlxcdTAwQThcIixcbiAgXCJEb3VibGVEb3duQXJyb3dcIjpcIlxcdTIxRDNcIixcbiAgXCJEb3VibGVMZWZ0QXJyb3dcIjpcIlxcdTIxRDBcIixcbiAgXCJEb3VibGVMZWZ0UmlnaHRBcnJvd1wiOlwiXFx1MjFENFwiLFxuICBcIkRvdWJsZUxlZnRUZWVcIjpcIlxcdTJBRTRcIixcbiAgXCJEb3VibGVMb25nTGVmdEFycm93XCI6XCJcXHUyN0Y4XCIsXG4gIFwiRG91YmxlTG9uZ0xlZnRSaWdodEFycm93XCI6XCJcXHUyN0ZBXCIsXG4gIFwiRG91YmxlTG9uZ1JpZ2h0QXJyb3dcIjpcIlxcdTI3RjlcIixcbiAgXCJEb3VibGVSaWdodEFycm93XCI6XCJcXHUyMUQyXCIsXG4gIFwiRG91YmxlUmlnaHRUZWVcIjpcIlxcdTIyQThcIixcbiAgXCJEb3VibGVVcEFycm93XCI6XCJcXHUyMUQxXCIsXG4gIFwiRG91YmxlVXBEb3duQXJyb3dcIjpcIlxcdTIxRDVcIixcbiAgXCJEb3VibGVWZXJ0aWNhbEJhclwiOlwiXFx1MjIyNVwiLFxuICBcIkRvd25BcnJvd1wiOlwiXFx1MjE5M1wiLFxuICBcIkRvd25hcnJvd1wiOlwiXFx1MjFEM1wiLFxuICBcImRvd25hcnJvd1wiOlwiXFx1MjE5M1wiLFxuICBcIkRvd25BcnJvd0JhclwiOlwiXFx1MjkxM1wiLFxuICBcIkRvd25BcnJvd1VwQXJyb3dcIjpcIlxcdTIxRjVcIixcbiAgXCJEb3duQnJldmVcIjpcIlxcdTAzMTFcIixcbiAgXCJkb3duZG93bmFycm93c1wiOlwiXFx1MjFDQVwiLFxuICBcImRvd25oYXJwb29ubGVmdFwiOlwiXFx1MjFDM1wiLFxuICBcImRvd25oYXJwb29ucmlnaHRcIjpcIlxcdTIxQzJcIixcbiAgXCJEb3duTGVmdFJpZ2h0VmVjdG9yXCI6XCJcXHUyOTUwXCIsXG4gIFwiRG93bkxlZnRUZWVWZWN0b3JcIjpcIlxcdTI5NUVcIixcbiAgXCJEb3duTGVmdFZlY3RvclwiOlwiXFx1MjFCRFwiLFxuICBcIkRvd25MZWZ0VmVjdG9yQmFyXCI6XCJcXHUyOTU2XCIsXG4gIFwiRG93blJpZ2h0VGVlVmVjdG9yXCI6XCJcXHUyOTVGXCIsXG4gIFwiRG93blJpZ2h0VmVjdG9yXCI6XCJcXHUyMUMxXCIsXG4gIFwiRG93blJpZ2h0VmVjdG9yQmFyXCI6XCJcXHUyOTU3XCIsXG4gIFwiRG93blRlZVwiOlwiXFx1MjJBNFwiLFxuICBcIkRvd25UZWVBcnJvd1wiOlwiXFx1MjFBN1wiLFxuICBcImRyYmthcm93XCI6XCJcXHUyOTEwXCIsXG4gIFwiZHJjb3JuXCI6XCJcXHUyMzFGXCIsXG4gIFwiZHJjcm9wXCI6XCJcXHUyMzBDXCIsXG4gIFwiRHNjclwiOlwiXFx1RDgzNVxcdURDOUZcIixcbiAgXCJkc2NyXCI6XCJcXHVEODM1XFx1RENCOVwiLFxuICBcIkRTY3lcIjpcIlxcdTA0MDVcIixcbiAgXCJkc2N5XCI6XCJcXHUwNDU1XCIsXG4gIFwiZHNvbFwiOlwiXFx1MjlGNlwiLFxuICBcIkRzdHJva1wiOlwiXFx1MDExMFwiLFxuICBcImRzdHJva1wiOlwiXFx1MDExMVwiLFxuICBcImR0ZG90XCI6XCJcXHUyMkYxXCIsXG4gIFwiZHRyaVwiOlwiXFx1MjVCRlwiLFxuICBcImR0cmlmXCI6XCJcXHUyNUJFXCIsXG4gIFwiZHVhcnJcIjpcIlxcdTIxRjVcIixcbiAgXCJkdWhhclwiOlwiXFx1Mjk2RlwiLFxuICBcImR3YW5nbGVcIjpcIlxcdTI5QTZcIixcbiAgXCJEWmN5XCI6XCJcXHUwNDBGXCIsXG4gIFwiZHpjeVwiOlwiXFx1MDQ1RlwiLFxuICBcImR6aWdyYXJyXCI6XCJcXHUyN0ZGXCIsXG4gIFwiRWFjdXRlXCI6XCJcXHUwMEM5XCIsXG4gIFwiZWFjdXRlXCI6XCJcXHUwMEU5XCIsXG4gIFwiZWFzdGVyXCI6XCJcXHUyQTZFXCIsXG4gIFwiRWNhcm9uXCI6XCJcXHUwMTFBXCIsXG4gIFwiZWNhcm9uXCI6XCJcXHUwMTFCXCIsXG4gIFwiZWNpclwiOlwiXFx1MjI1NlwiLFxuICBcIkVjaXJjXCI6XCJcXHUwMENBXCIsXG4gIFwiZWNpcmNcIjpcIlxcdTAwRUFcIixcbiAgXCJlY29sb25cIjpcIlxcdTIyNTVcIixcbiAgXCJFY3lcIjpcIlxcdTA0MkRcIixcbiAgXCJlY3lcIjpcIlxcdTA0NERcIixcbiAgXCJlRERvdFwiOlwiXFx1MkE3N1wiLFxuICBcIkVkb3RcIjpcIlxcdTAxMTZcIixcbiAgXCJlRG90XCI6XCJcXHUyMjUxXCIsXG4gIFwiZWRvdFwiOlwiXFx1MDExN1wiLFxuICBcImVlXCI6XCJcXHUyMTQ3XCIsXG4gIFwiZWZEb3RcIjpcIlxcdTIyNTJcIixcbiAgXCJFZnJcIjpcIlxcdUQ4MzVcXHVERDA4XCIsXG4gIFwiZWZyXCI6XCJcXHVEODM1XFx1REQyMlwiLFxuICBcImVnXCI6XCJcXHUyQTlBXCIsXG4gIFwiRWdyYXZlXCI6XCJcXHUwMEM4XCIsXG4gIFwiZWdyYXZlXCI6XCJcXHUwMEU4XCIsXG4gIFwiZWdzXCI6XCJcXHUyQTk2XCIsXG4gIFwiZWdzZG90XCI6XCJcXHUyQTk4XCIsXG4gIFwiZWxcIjpcIlxcdTJBOTlcIixcbiAgXCJFbGVtZW50XCI6XCJcXHUyMjA4XCIsXG4gIFwiZWxpbnRlcnNcIjpcIlxcdTIzRTdcIixcbiAgXCJlbGxcIjpcIlxcdTIxMTNcIixcbiAgXCJlbHNcIjpcIlxcdTJBOTVcIixcbiAgXCJlbHNkb3RcIjpcIlxcdTJBOTdcIixcbiAgXCJFbWFjclwiOlwiXFx1MDExMlwiLFxuICBcImVtYWNyXCI6XCJcXHUwMTEzXCIsXG4gIFwiZW1wdHlcIjpcIlxcdTIyMDVcIixcbiAgXCJlbXB0eXNldFwiOlwiXFx1MjIwNVwiLFxuICBcIkVtcHR5U21hbGxTcXVhcmVcIjpcIlxcdTI1RkJcIixcbiAgXCJlbXB0eXZcIjpcIlxcdTIyMDVcIixcbiAgXCJFbXB0eVZlcnlTbWFsbFNxdWFyZVwiOlwiXFx1MjVBQlwiLFxuICBcImVtc3BcIjpcIlxcdTIwMDNcIixcbiAgXCJlbXNwMTNcIjpcIlxcdTIwMDRcIixcbiAgXCJlbXNwMTRcIjpcIlxcdTIwMDVcIixcbiAgXCJFTkdcIjpcIlxcdTAxNEFcIixcbiAgXCJlbmdcIjpcIlxcdTAxNEJcIixcbiAgXCJlbnNwXCI6XCJcXHUyMDAyXCIsXG4gIFwiRW9nb25cIjpcIlxcdTAxMThcIixcbiAgXCJlb2dvblwiOlwiXFx1MDExOVwiLFxuICBcIkVvcGZcIjpcIlxcdUQ4MzVcXHVERDNDXCIsXG4gIFwiZW9wZlwiOlwiXFx1RDgzNVxcdURENTZcIixcbiAgXCJlcGFyXCI6XCJcXHUyMkQ1XCIsXG4gIFwiZXBhcnNsXCI6XCJcXHUyOUUzXCIsXG4gIFwiZXBsdXNcIjpcIlxcdTJBNzFcIixcbiAgXCJlcHNpXCI6XCJcXHUwM0I1XCIsXG4gIFwiRXBzaWxvblwiOlwiXFx1MDM5NVwiLFxuICBcImVwc2lsb25cIjpcIlxcdTAzQjVcIixcbiAgXCJlcHNpdlwiOlwiXFx1MDNGNVwiLFxuICBcImVxY2lyY1wiOlwiXFx1MjI1NlwiLFxuICBcImVxY29sb25cIjpcIlxcdTIyNTVcIixcbiAgXCJlcXNpbVwiOlwiXFx1MjI0MlwiLFxuICBcImVxc2xhbnRndHJcIjpcIlxcdTJBOTZcIixcbiAgXCJlcXNsYW50bGVzc1wiOlwiXFx1MkE5NVwiLFxuICBcIkVxdWFsXCI6XCJcXHUyQTc1XCIsXG4gIFwiZXF1YWxzXCI6XCJcXHUwMDNEXCIsXG4gIFwiRXF1YWxUaWxkZVwiOlwiXFx1MjI0MlwiLFxuICBcImVxdWVzdFwiOlwiXFx1MjI1RlwiLFxuICBcIkVxdWlsaWJyaXVtXCI6XCJcXHUyMUNDXCIsXG4gIFwiZXF1aXZcIjpcIlxcdTIyNjFcIixcbiAgXCJlcXVpdkREXCI6XCJcXHUyQTc4XCIsXG4gIFwiZXF2cGFyc2xcIjpcIlxcdTI5RTVcIixcbiAgXCJlcmFyclwiOlwiXFx1Mjk3MVwiLFxuICBcImVyRG90XCI6XCJcXHUyMjUzXCIsXG4gIFwiRXNjclwiOlwiXFx1MjEzMFwiLFxuICBcImVzY3JcIjpcIlxcdTIxMkZcIixcbiAgXCJlc2RvdFwiOlwiXFx1MjI1MFwiLFxuICBcIkVzaW1cIjpcIlxcdTJBNzNcIixcbiAgXCJlc2ltXCI6XCJcXHUyMjQyXCIsXG4gIFwiRXRhXCI6XCJcXHUwMzk3XCIsXG4gIFwiZXRhXCI6XCJcXHUwM0I3XCIsXG4gIFwiRVRIXCI6XCJcXHUwMEQwXCIsXG4gIFwiZXRoXCI6XCJcXHUwMEYwXCIsXG4gIFwiRXVtbFwiOlwiXFx1MDBDQlwiLFxuICBcImV1bWxcIjpcIlxcdTAwRUJcIixcbiAgXCJldXJvXCI6XCJcXHUyMEFDXCIsXG4gIFwiZXhjbFwiOlwiXFx1MDAyMVwiLFxuICBcImV4aXN0XCI6XCJcXHUyMjAzXCIsXG4gIFwiRXhpc3RzXCI6XCJcXHUyMjAzXCIsXG4gIFwiZXhwZWN0YXRpb25cIjpcIlxcdTIxMzBcIixcbiAgXCJFeHBvbmVudGlhbEVcIjpcIlxcdTIxNDdcIixcbiAgXCJleHBvbmVudGlhbGVcIjpcIlxcdTIxNDdcIixcbiAgXCJmYWxsaW5nZG90c2VxXCI6XCJcXHUyMjUyXCIsXG4gIFwiRmN5XCI6XCJcXHUwNDI0XCIsXG4gIFwiZmN5XCI6XCJcXHUwNDQ0XCIsXG4gIFwiZmVtYWxlXCI6XCJcXHUyNjQwXCIsXG4gIFwiZmZpbGlnXCI6XCJcXHVGQjAzXCIsXG4gIFwiZmZsaWdcIjpcIlxcdUZCMDBcIixcbiAgXCJmZmxsaWdcIjpcIlxcdUZCMDRcIixcbiAgXCJGZnJcIjpcIlxcdUQ4MzVcXHVERDA5XCIsXG4gIFwiZmZyXCI6XCJcXHVEODM1XFx1REQyM1wiLFxuICBcImZpbGlnXCI6XCJcXHVGQjAxXCIsXG4gIFwiRmlsbGVkU21hbGxTcXVhcmVcIjpcIlxcdTI1RkNcIixcbiAgXCJGaWxsZWRWZXJ5U21hbGxTcXVhcmVcIjpcIlxcdTI1QUFcIixcbiAgXCJmamxpZ1wiOlwiXFx1MDA2NlxcdTAwNkFcIixcbiAgXCJmbGF0XCI6XCJcXHUyNjZEXCIsXG4gIFwiZmxsaWdcIjpcIlxcdUZCMDJcIixcbiAgXCJmbHRuc1wiOlwiXFx1MjVCMVwiLFxuICBcImZub2ZcIjpcIlxcdTAxOTJcIixcbiAgXCJGb3BmXCI6XCJcXHVEODM1XFx1REQzRFwiLFxuICBcImZvcGZcIjpcIlxcdUQ4MzVcXHVERDU3XCIsXG4gIFwiRm9yQWxsXCI6XCJcXHUyMjAwXCIsXG4gIFwiZm9yYWxsXCI6XCJcXHUyMjAwXCIsXG4gIFwiZm9ya1wiOlwiXFx1MjJENFwiLFxuICBcImZvcmt2XCI6XCJcXHUyQUQ5XCIsXG4gIFwiRm91cmllcnRyZlwiOlwiXFx1MjEzMVwiLFxuICBcImZwYXJ0aW50XCI6XCJcXHUyQTBEXCIsXG4gIFwiZnJhYzEyXCI6XCJcXHUwMEJEXCIsXG4gIFwiZnJhYzEzXCI6XCJcXHUyMTUzXCIsXG4gIFwiZnJhYzE0XCI6XCJcXHUwMEJDXCIsXG4gIFwiZnJhYzE1XCI6XCJcXHUyMTU1XCIsXG4gIFwiZnJhYzE2XCI6XCJcXHUyMTU5XCIsXG4gIFwiZnJhYzE4XCI6XCJcXHUyMTVCXCIsXG4gIFwiZnJhYzIzXCI6XCJcXHUyMTU0XCIsXG4gIFwiZnJhYzI1XCI6XCJcXHUyMTU2XCIsXG4gIFwiZnJhYzM0XCI6XCJcXHUwMEJFXCIsXG4gIFwiZnJhYzM1XCI6XCJcXHUyMTU3XCIsXG4gIFwiZnJhYzM4XCI6XCJcXHUyMTVDXCIsXG4gIFwiZnJhYzQ1XCI6XCJcXHUyMTU4XCIsXG4gIFwiZnJhYzU2XCI6XCJcXHUyMTVBXCIsXG4gIFwiZnJhYzU4XCI6XCJcXHUyMTVEXCIsXG4gIFwiZnJhYzc4XCI6XCJcXHUyMTVFXCIsXG4gIFwiZnJhc2xcIjpcIlxcdTIwNDRcIixcbiAgXCJmcm93blwiOlwiXFx1MjMyMlwiLFxuICBcIkZzY3JcIjpcIlxcdTIxMzFcIixcbiAgXCJmc2NyXCI6XCJcXHVEODM1XFx1RENCQlwiLFxuICBcImdhY3V0ZVwiOlwiXFx1MDFGNVwiLFxuICBcIkdhbW1hXCI6XCJcXHUwMzkzXCIsXG4gIFwiZ2FtbWFcIjpcIlxcdTAzQjNcIixcbiAgXCJHYW1tYWRcIjpcIlxcdTAzRENcIixcbiAgXCJnYW1tYWRcIjpcIlxcdTAzRERcIixcbiAgXCJnYXBcIjpcIlxcdTJBODZcIixcbiAgXCJHYnJldmVcIjpcIlxcdTAxMUVcIixcbiAgXCJnYnJldmVcIjpcIlxcdTAxMUZcIixcbiAgXCJHY2VkaWxcIjpcIlxcdTAxMjJcIixcbiAgXCJHY2lyY1wiOlwiXFx1MDExQ1wiLFxuICBcImdjaXJjXCI6XCJcXHUwMTFEXCIsXG4gIFwiR2N5XCI6XCJcXHUwNDEzXCIsXG4gIFwiZ2N5XCI6XCJcXHUwNDMzXCIsXG4gIFwiR2RvdFwiOlwiXFx1MDEyMFwiLFxuICBcImdkb3RcIjpcIlxcdTAxMjFcIixcbiAgXCJnRVwiOlwiXFx1MjI2N1wiLFxuICBcImdlXCI6XCJcXHUyMjY1XCIsXG4gIFwiZ0VsXCI6XCJcXHUyQThDXCIsXG4gIFwiZ2VsXCI6XCJcXHUyMkRCXCIsXG4gIFwiZ2VxXCI6XCJcXHUyMjY1XCIsXG4gIFwiZ2VxcVwiOlwiXFx1MjI2N1wiLFxuICBcImdlcXNsYW50XCI6XCJcXHUyQTdFXCIsXG4gIFwiZ2VzXCI6XCJcXHUyQTdFXCIsXG4gIFwiZ2VzY2NcIjpcIlxcdTJBQTlcIixcbiAgXCJnZXNkb3RcIjpcIlxcdTJBODBcIixcbiAgXCJnZXNkb3RvXCI6XCJcXHUyQTgyXCIsXG4gIFwiZ2VzZG90b2xcIjpcIlxcdTJBODRcIixcbiAgXCJnZXNsXCI6XCJcXHUyMkRCXFx1RkUwMFwiLFxuICBcImdlc2xlc1wiOlwiXFx1MkE5NFwiLFxuICBcIkdmclwiOlwiXFx1RDgzNVxcdUREMEFcIixcbiAgXCJnZnJcIjpcIlxcdUQ4MzVcXHVERDI0XCIsXG4gIFwiR2dcIjpcIlxcdTIyRDlcIixcbiAgXCJnZ1wiOlwiXFx1MjI2QlwiLFxuICBcImdnZ1wiOlwiXFx1MjJEOVwiLFxuICBcImdpbWVsXCI6XCJcXHUyMTM3XCIsXG4gIFwiR0pjeVwiOlwiXFx1MDQwM1wiLFxuICBcImdqY3lcIjpcIlxcdTA0NTNcIixcbiAgXCJnbFwiOlwiXFx1MjI3N1wiLFxuICBcImdsYVwiOlwiXFx1MkFBNVwiLFxuICBcImdsRVwiOlwiXFx1MkE5MlwiLFxuICBcImdsalwiOlwiXFx1MkFBNFwiLFxuICBcImduYXBcIjpcIlxcdTJBOEFcIixcbiAgXCJnbmFwcHJveFwiOlwiXFx1MkE4QVwiLFxuICBcImduRVwiOlwiXFx1MjI2OVwiLFxuICBcImduZVwiOlwiXFx1MkE4OFwiLFxuICBcImduZXFcIjpcIlxcdTJBODhcIixcbiAgXCJnbmVxcVwiOlwiXFx1MjI2OVwiLFxuICBcImduc2ltXCI6XCJcXHUyMkU3XCIsXG4gIFwiR29wZlwiOlwiXFx1RDgzNVxcdUREM0VcIixcbiAgXCJnb3BmXCI6XCJcXHVEODM1XFx1REQ1OFwiLFxuICBcImdyYXZlXCI6XCJcXHUwMDYwXCIsXG4gIFwiR3JlYXRlckVxdWFsXCI6XCJcXHUyMjY1XCIsXG4gIFwiR3JlYXRlckVxdWFsTGVzc1wiOlwiXFx1MjJEQlwiLFxuICBcIkdyZWF0ZXJGdWxsRXF1YWxcIjpcIlxcdTIyNjdcIixcbiAgXCJHcmVhdGVyR3JlYXRlclwiOlwiXFx1MkFBMlwiLFxuICBcIkdyZWF0ZXJMZXNzXCI6XCJcXHUyMjc3XCIsXG4gIFwiR3JlYXRlclNsYW50RXF1YWxcIjpcIlxcdTJBN0VcIixcbiAgXCJHcmVhdGVyVGlsZGVcIjpcIlxcdTIyNzNcIixcbiAgXCJHc2NyXCI6XCJcXHVEODM1XFx1RENBMlwiLFxuICBcImdzY3JcIjpcIlxcdTIxMEFcIixcbiAgXCJnc2ltXCI6XCJcXHUyMjczXCIsXG4gIFwiZ3NpbWVcIjpcIlxcdTJBOEVcIixcbiAgXCJnc2ltbFwiOlwiXFx1MkE5MFwiLFxuICBcIkdUXCI6XCJcXHUwMDNFXCIsXG4gIFwiR3RcIjpcIlxcdTIyNkJcIixcbiAgXCJndFwiOlwiXFx1MDAzRVwiLFxuICBcImd0Y2NcIjpcIlxcdTJBQTdcIixcbiAgXCJndGNpclwiOlwiXFx1MkE3QVwiLFxuICBcImd0ZG90XCI6XCJcXHUyMkQ3XCIsXG4gIFwiZ3RsUGFyXCI6XCJcXHUyOTk1XCIsXG4gIFwiZ3RxdWVzdFwiOlwiXFx1MkE3Q1wiLFxuICBcImd0cmFwcHJveFwiOlwiXFx1MkE4NlwiLFxuICBcImd0cmFyclwiOlwiXFx1Mjk3OFwiLFxuICBcImd0cmRvdFwiOlwiXFx1MjJEN1wiLFxuICBcImd0cmVxbGVzc1wiOlwiXFx1MjJEQlwiLFxuICBcImd0cmVxcWxlc3NcIjpcIlxcdTJBOENcIixcbiAgXCJndHJsZXNzXCI6XCJcXHUyMjc3XCIsXG4gIFwiZ3Ryc2ltXCI6XCJcXHUyMjczXCIsXG4gIFwiZ3ZlcnRuZXFxXCI6XCJcXHUyMjY5XFx1RkUwMFwiLFxuICBcImd2bkVcIjpcIlxcdTIyNjlcXHVGRTAwXCIsXG4gIFwiSGFjZWtcIjpcIlxcdTAyQzdcIixcbiAgXCJoYWlyc3BcIjpcIlxcdTIwMEFcIixcbiAgXCJoYWxmXCI6XCJcXHUwMEJEXCIsXG4gIFwiaGFtaWx0XCI6XCJcXHUyMTBCXCIsXG4gIFwiSEFSRGN5XCI6XCJcXHUwNDJBXCIsXG4gIFwiaGFyZGN5XCI6XCJcXHUwNDRBXCIsXG4gIFwiaEFyclwiOlwiXFx1MjFENFwiLFxuICBcImhhcnJcIjpcIlxcdTIxOTRcIixcbiAgXCJoYXJyY2lyXCI6XCJcXHUyOTQ4XCIsXG4gIFwiaGFycndcIjpcIlxcdTIxQURcIixcbiAgXCJIYXRcIjpcIlxcdTAwNUVcIixcbiAgXCJoYmFyXCI6XCJcXHUyMTBGXCIsXG4gIFwiSGNpcmNcIjpcIlxcdTAxMjRcIixcbiAgXCJoY2lyY1wiOlwiXFx1MDEyNVwiLFxuICBcImhlYXJ0c1wiOlwiXFx1MjY2NVwiLFxuICBcImhlYXJ0c3VpdFwiOlwiXFx1MjY2NVwiLFxuICBcImhlbGxpcFwiOlwiXFx1MjAyNlwiLFxuICBcImhlcmNvblwiOlwiXFx1MjJCOVwiLFxuICBcIkhmclwiOlwiXFx1MjEwQ1wiLFxuICBcImhmclwiOlwiXFx1RDgzNVxcdUREMjVcIixcbiAgXCJIaWxiZXJ0U3BhY2VcIjpcIlxcdTIxMEJcIixcbiAgXCJoa3NlYXJvd1wiOlwiXFx1MjkyNVwiLFxuICBcImhrc3dhcm93XCI6XCJcXHUyOTI2XCIsXG4gIFwiaG9hcnJcIjpcIlxcdTIxRkZcIixcbiAgXCJob210aHRcIjpcIlxcdTIyM0JcIixcbiAgXCJob29rbGVmdGFycm93XCI6XCJcXHUyMUE5XCIsXG4gIFwiaG9va3JpZ2h0YXJyb3dcIjpcIlxcdTIxQUFcIixcbiAgXCJIb3BmXCI6XCJcXHUyMTBEXCIsXG4gIFwiaG9wZlwiOlwiXFx1RDgzNVxcdURENTlcIixcbiAgXCJob3JiYXJcIjpcIlxcdTIwMTVcIixcbiAgXCJIb3Jpem9udGFsTGluZVwiOlwiXFx1MjUwMFwiLFxuICBcIkhzY3JcIjpcIlxcdTIxMEJcIixcbiAgXCJoc2NyXCI6XCJcXHVEODM1XFx1RENCRFwiLFxuICBcImhzbGFzaFwiOlwiXFx1MjEwRlwiLFxuICBcIkhzdHJva1wiOlwiXFx1MDEyNlwiLFxuICBcImhzdHJva1wiOlwiXFx1MDEyN1wiLFxuICBcIkh1bXBEb3duSHVtcFwiOlwiXFx1MjI0RVwiLFxuICBcIkh1bXBFcXVhbFwiOlwiXFx1MjI0RlwiLFxuICBcImh5YnVsbFwiOlwiXFx1MjA0M1wiLFxuICBcImh5cGhlblwiOlwiXFx1MjAxMFwiLFxuICBcIklhY3V0ZVwiOlwiXFx1MDBDRFwiLFxuICBcImlhY3V0ZVwiOlwiXFx1MDBFRFwiLFxuICBcImljXCI6XCJcXHUyMDYzXCIsXG4gIFwiSWNpcmNcIjpcIlxcdTAwQ0VcIixcbiAgXCJpY2lyY1wiOlwiXFx1MDBFRVwiLFxuICBcIkljeVwiOlwiXFx1MDQxOFwiLFxuICBcImljeVwiOlwiXFx1MDQzOFwiLFxuICBcIklkb3RcIjpcIlxcdTAxMzBcIixcbiAgXCJJRWN5XCI6XCJcXHUwNDE1XCIsXG4gIFwiaWVjeVwiOlwiXFx1MDQzNVwiLFxuICBcImlleGNsXCI6XCJcXHUwMEExXCIsXG4gIFwiaWZmXCI6XCJcXHUyMUQ0XCIsXG4gIFwiSWZyXCI6XCJcXHUyMTExXCIsXG4gIFwiaWZyXCI6XCJcXHVEODM1XFx1REQyNlwiLFxuICBcIklncmF2ZVwiOlwiXFx1MDBDQ1wiLFxuICBcImlncmF2ZVwiOlwiXFx1MDBFQ1wiLFxuICBcImlpXCI6XCJcXHUyMTQ4XCIsXG4gIFwiaWlpaW50XCI6XCJcXHUyQTBDXCIsXG4gIFwiaWlpbnRcIjpcIlxcdTIyMkRcIixcbiAgXCJpaW5maW5cIjpcIlxcdTI5RENcIixcbiAgXCJpaW90YVwiOlwiXFx1MjEyOVwiLFxuICBcIklKbGlnXCI6XCJcXHUwMTMyXCIsXG4gIFwiaWpsaWdcIjpcIlxcdTAxMzNcIixcbiAgXCJJbVwiOlwiXFx1MjExMVwiLFxuICBcIkltYWNyXCI6XCJcXHUwMTJBXCIsXG4gIFwiaW1hY3JcIjpcIlxcdTAxMkJcIixcbiAgXCJpbWFnZVwiOlwiXFx1MjExMVwiLFxuICBcIkltYWdpbmFyeUlcIjpcIlxcdTIxNDhcIixcbiAgXCJpbWFnbGluZVwiOlwiXFx1MjExMFwiLFxuICBcImltYWdwYXJ0XCI6XCJcXHUyMTExXCIsXG4gIFwiaW1hdGhcIjpcIlxcdTAxMzFcIixcbiAgXCJpbW9mXCI6XCJcXHUyMkI3XCIsXG4gIFwiaW1wZWRcIjpcIlxcdTAxQjVcIixcbiAgXCJJbXBsaWVzXCI6XCJcXHUyMUQyXCIsXG4gIFwiaW5cIjpcIlxcdTIyMDhcIixcbiAgXCJpbmNhcmVcIjpcIlxcdTIxMDVcIixcbiAgXCJpbmZpblwiOlwiXFx1MjIxRVwiLFxuICBcImluZmludGllXCI6XCJcXHUyOUREXCIsXG4gIFwiaW5vZG90XCI6XCJcXHUwMTMxXCIsXG4gIFwiSW50XCI6XCJcXHUyMjJDXCIsXG4gIFwiaW50XCI6XCJcXHUyMjJCXCIsXG4gIFwiaW50Y2FsXCI6XCJcXHUyMkJBXCIsXG4gIFwiaW50ZWdlcnNcIjpcIlxcdTIxMjRcIixcbiAgXCJJbnRlZ3JhbFwiOlwiXFx1MjIyQlwiLFxuICBcImludGVyY2FsXCI6XCJcXHUyMkJBXCIsXG4gIFwiSW50ZXJzZWN0aW9uXCI6XCJcXHUyMkMyXCIsXG4gIFwiaW50bGFyaGtcIjpcIlxcdTJBMTdcIixcbiAgXCJpbnRwcm9kXCI6XCJcXHUyQTNDXCIsXG4gIFwiSW52aXNpYmxlQ29tbWFcIjpcIlxcdTIwNjNcIixcbiAgXCJJbnZpc2libGVUaW1lc1wiOlwiXFx1MjA2MlwiLFxuICBcIklPY3lcIjpcIlxcdTA0MDFcIixcbiAgXCJpb2N5XCI6XCJcXHUwNDUxXCIsXG4gIFwiSW9nb25cIjpcIlxcdTAxMkVcIixcbiAgXCJpb2dvblwiOlwiXFx1MDEyRlwiLFxuICBcIklvcGZcIjpcIlxcdUQ4MzVcXHVERDQwXCIsXG4gIFwiaW9wZlwiOlwiXFx1RDgzNVxcdURENUFcIixcbiAgXCJJb3RhXCI6XCJcXHUwMzk5XCIsXG4gIFwiaW90YVwiOlwiXFx1MDNCOVwiLFxuICBcImlwcm9kXCI6XCJcXHUyQTNDXCIsXG4gIFwiaXF1ZXN0XCI6XCJcXHUwMEJGXCIsXG4gIFwiSXNjclwiOlwiXFx1MjExMFwiLFxuICBcImlzY3JcIjpcIlxcdUQ4MzVcXHVEQ0JFXCIsXG4gIFwiaXNpblwiOlwiXFx1MjIwOFwiLFxuICBcImlzaW5kb3RcIjpcIlxcdTIyRjVcIixcbiAgXCJpc2luRVwiOlwiXFx1MjJGOVwiLFxuICBcImlzaW5zXCI6XCJcXHUyMkY0XCIsXG4gIFwiaXNpbnN2XCI6XCJcXHUyMkYzXCIsXG4gIFwiaXNpbnZcIjpcIlxcdTIyMDhcIixcbiAgXCJpdFwiOlwiXFx1MjA2MlwiLFxuICBcIkl0aWxkZVwiOlwiXFx1MDEyOFwiLFxuICBcIml0aWxkZVwiOlwiXFx1MDEyOVwiLFxuICBcIkl1a2N5XCI6XCJcXHUwNDA2XCIsXG4gIFwiaXVrY3lcIjpcIlxcdTA0NTZcIixcbiAgXCJJdW1sXCI6XCJcXHUwMENGXCIsXG4gIFwiaXVtbFwiOlwiXFx1MDBFRlwiLFxuICBcIkpjaXJjXCI6XCJcXHUwMTM0XCIsXG4gIFwiamNpcmNcIjpcIlxcdTAxMzVcIixcbiAgXCJKY3lcIjpcIlxcdTA0MTlcIixcbiAgXCJqY3lcIjpcIlxcdTA0MzlcIixcbiAgXCJKZnJcIjpcIlxcdUQ4MzVcXHVERDBEXCIsXG4gIFwiamZyXCI6XCJcXHVEODM1XFx1REQyN1wiLFxuICBcImptYXRoXCI6XCJcXHUwMjM3XCIsXG4gIFwiSm9wZlwiOlwiXFx1RDgzNVxcdURENDFcIixcbiAgXCJqb3BmXCI6XCJcXHVEODM1XFx1REQ1QlwiLFxuICBcIkpzY3JcIjpcIlxcdUQ4MzVcXHVEQ0E1XCIsXG4gIFwianNjclwiOlwiXFx1RDgzNVxcdURDQkZcIixcbiAgXCJKc2VyY3lcIjpcIlxcdTA0MDhcIixcbiAgXCJqc2VyY3lcIjpcIlxcdTA0NThcIixcbiAgXCJKdWtjeVwiOlwiXFx1MDQwNFwiLFxuICBcImp1a2N5XCI6XCJcXHUwNDU0XCIsXG4gIFwiS2FwcGFcIjpcIlxcdTAzOUFcIixcbiAgXCJrYXBwYVwiOlwiXFx1MDNCQVwiLFxuICBcImthcHBhdlwiOlwiXFx1MDNGMFwiLFxuICBcIktjZWRpbFwiOlwiXFx1MDEzNlwiLFxuICBcImtjZWRpbFwiOlwiXFx1MDEzN1wiLFxuICBcIktjeVwiOlwiXFx1MDQxQVwiLFxuICBcImtjeVwiOlwiXFx1MDQzQVwiLFxuICBcIktmclwiOlwiXFx1RDgzNVxcdUREMEVcIixcbiAgXCJrZnJcIjpcIlxcdUQ4MzVcXHVERDI4XCIsXG4gIFwia2dyZWVuXCI6XCJcXHUwMTM4XCIsXG4gIFwiS0hjeVwiOlwiXFx1MDQyNVwiLFxuICBcImtoY3lcIjpcIlxcdTA0NDVcIixcbiAgXCJLSmN5XCI6XCJcXHUwNDBDXCIsXG4gIFwia2pjeVwiOlwiXFx1MDQ1Q1wiLFxuICBcIktvcGZcIjpcIlxcdUQ4MzVcXHVERDQyXCIsXG4gIFwia29wZlwiOlwiXFx1RDgzNVxcdURENUNcIixcbiAgXCJLc2NyXCI6XCJcXHVEODM1XFx1RENBNlwiLFxuICBcImtzY3JcIjpcIlxcdUQ4MzVcXHVEQ0MwXCIsXG4gIFwibEFhcnJcIjpcIlxcdTIxREFcIixcbiAgXCJMYWN1dGVcIjpcIlxcdTAxMzlcIixcbiAgXCJsYWN1dGVcIjpcIlxcdTAxM0FcIixcbiAgXCJsYWVtcHR5dlwiOlwiXFx1MjlCNFwiLFxuICBcImxhZ3JhblwiOlwiXFx1MjExMlwiLFxuICBcIkxhbWJkYVwiOlwiXFx1MDM5QlwiLFxuICBcImxhbWJkYVwiOlwiXFx1MDNCQlwiLFxuICBcIkxhbmdcIjpcIlxcdTI3RUFcIixcbiAgXCJsYW5nXCI6XCJcXHUyN0U4XCIsXG4gIFwibGFuZ2RcIjpcIlxcdTI5OTFcIixcbiAgXCJsYW5nbGVcIjpcIlxcdTI3RThcIixcbiAgXCJsYXBcIjpcIlxcdTJBODVcIixcbiAgXCJMYXBsYWNldHJmXCI6XCJcXHUyMTEyXCIsXG4gIFwibGFxdW9cIjpcIlxcdTAwQUJcIixcbiAgXCJMYXJyXCI6XCJcXHUyMTlFXCIsXG4gIFwibEFyclwiOlwiXFx1MjFEMFwiLFxuICBcImxhcnJcIjpcIlxcdTIxOTBcIixcbiAgXCJsYXJyYlwiOlwiXFx1MjFFNFwiLFxuICBcImxhcnJiZnNcIjpcIlxcdTI5MUZcIixcbiAgXCJsYXJyZnNcIjpcIlxcdTI5MURcIixcbiAgXCJsYXJyaGtcIjpcIlxcdTIxQTlcIixcbiAgXCJsYXJybHBcIjpcIlxcdTIxQUJcIixcbiAgXCJsYXJycGxcIjpcIlxcdTI5MzlcIixcbiAgXCJsYXJyc2ltXCI6XCJcXHUyOTczXCIsXG4gIFwibGFycnRsXCI6XCJcXHUyMUEyXCIsXG4gIFwibGF0XCI6XCJcXHUyQUFCXCIsXG4gIFwibEF0YWlsXCI6XCJcXHUyOTFCXCIsXG4gIFwibGF0YWlsXCI6XCJcXHUyOTE5XCIsXG4gIFwibGF0ZVwiOlwiXFx1MkFBRFwiLFxuICBcImxhdGVzXCI6XCJcXHUyQUFEXFx1RkUwMFwiLFxuICBcImxCYXJyXCI6XCJcXHUyOTBFXCIsXG4gIFwibGJhcnJcIjpcIlxcdTI5MENcIixcbiAgXCJsYmJya1wiOlwiXFx1Mjc3MlwiLFxuICBcImxicmFjZVwiOlwiXFx1MDA3QlwiLFxuICBcImxicmFja1wiOlwiXFx1MDA1QlwiLFxuICBcImxicmtlXCI6XCJcXHUyOThCXCIsXG4gIFwibGJya3NsZFwiOlwiXFx1Mjk4RlwiLFxuICBcImxicmtzbHVcIjpcIlxcdTI5OERcIixcbiAgXCJMY2Fyb25cIjpcIlxcdTAxM0RcIixcbiAgXCJsY2Fyb25cIjpcIlxcdTAxM0VcIixcbiAgXCJMY2VkaWxcIjpcIlxcdTAxM0JcIixcbiAgXCJsY2VkaWxcIjpcIlxcdTAxM0NcIixcbiAgXCJsY2VpbFwiOlwiXFx1MjMwOFwiLFxuICBcImxjdWJcIjpcIlxcdTAwN0JcIixcbiAgXCJMY3lcIjpcIlxcdTA0MUJcIixcbiAgXCJsY3lcIjpcIlxcdTA0M0JcIixcbiAgXCJsZGNhXCI6XCJcXHUyOTM2XCIsXG4gIFwibGRxdW9cIjpcIlxcdTIwMUNcIixcbiAgXCJsZHF1b3JcIjpcIlxcdTIwMUVcIixcbiAgXCJsZHJkaGFyXCI6XCJcXHUyOTY3XCIsXG4gIFwibGRydXNoYXJcIjpcIlxcdTI5NEJcIixcbiAgXCJsZHNoXCI6XCJcXHUyMUIyXCIsXG4gIFwibEVcIjpcIlxcdTIyNjZcIixcbiAgXCJsZVwiOlwiXFx1MjI2NFwiLFxuICBcIkxlZnRBbmdsZUJyYWNrZXRcIjpcIlxcdTI3RThcIixcbiAgXCJMZWZ0QXJyb3dcIjpcIlxcdTIxOTBcIixcbiAgXCJMZWZ0YXJyb3dcIjpcIlxcdTIxRDBcIixcbiAgXCJsZWZ0YXJyb3dcIjpcIlxcdTIxOTBcIixcbiAgXCJMZWZ0QXJyb3dCYXJcIjpcIlxcdTIxRTRcIixcbiAgXCJMZWZ0QXJyb3dSaWdodEFycm93XCI6XCJcXHUyMUM2XCIsXG4gIFwibGVmdGFycm93dGFpbFwiOlwiXFx1MjFBMlwiLFxuICBcIkxlZnRDZWlsaW5nXCI6XCJcXHUyMzA4XCIsXG4gIFwiTGVmdERvdWJsZUJyYWNrZXRcIjpcIlxcdTI3RTZcIixcbiAgXCJMZWZ0RG93blRlZVZlY3RvclwiOlwiXFx1Mjk2MVwiLFxuICBcIkxlZnREb3duVmVjdG9yXCI6XCJcXHUyMUMzXCIsXG4gIFwiTGVmdERvd25WZWN0b3JCYXJcIjpcIlxcdTI5NTlcIixcbiAgXCJMZWZ0Rmxvb3JcIjpcIlxcdTIzMEFcIixcbiAgXCJsZWZ0aGFycG9vbmRvd25cIjpcIlxcdTIxQkRcIixcbiAgXCJsZWZ0aGFycG9vbnVwXCI6XCJcXHUyMUJDXCIsXG4gIFwibGVmdGxlZnRhcnJvd3NcIjpcIlxcdTIxQzdcIixcbiAgXCJMZWZ0UmlnaHRBcnJvd1wiOlwiXFx1MjE5NFwiLFxuICBcIkxlZnRyaWdodGFycm93XCI6XCJcXHUyMUQ0XCIsXG4gIFwibGVmdHJpZ2h0YXJyb3dcIjpcIlxcdTIxOTRcIixcbiAgXCJsZWZ0cmlnaHRhcnJvd3NcIjpcIlxcdTIxQzZcIixcbiAgXCJsZWZ0cmlnaHRoYXJwb29uc1wiOlwiXFx1MjFDQlwiLFxuICBcImxlZnRyaWdodHNxdWlnYXJyb3dcIjpcIlxcdTIxQURcIixcbiAgXCJMZWZ0UmlnaHRWZWN0b3JcIjpcIlxcdTI5NEVcIixcbiAgXCJMZWZ0VGVlXCI6XCJcXHUyMkEzXCIsXG4gIFwiTGVmdFRlZUFycm93XCI6XCJcXHUyMUE0XCIsXG4gIFwiTGVmdFRlZVZlY3RvclwiOlwiXFx1Mjk1QVwiLFxuICBcImxlZnR0aHJlZXRpbWVzXCI6XCJcXHUyMkNCXCIsXG4gIFwiTGVmdFRyaWFuZ2xlXCI6XCJcXHUyMkIyXCIsXG4gIFwiTGVmdFRyaWFuZ2xlQmFyXCI6XCJcXHUyOUNGXCIsXG4gIFwiTGVmdFRyaWFuZ2xlRXF1YWxcIjpcIlxcdTIyQjRcIixcbiAgXCJMZWZ0VXBEb3duVmVjdG9yXCI6XCJcXHUyOTUxXCIsXG4gIFwiTGVmdFVwVGVlVmVjdG9yXCI6XCJcXHUyOTYwXCIsXG4gIFwiTGVmdFVwVmVjdG9yXCI6XCJcXHUyMUJGXCIsXG4gIFwiTGVmdFVwVmVjdG9yQmFyXCI6XCJcXHUyOTU4XCIsXG4gIFwiTGVmdFZlY3RvclwiOlwiXFx1MjFCQ1wiLFxuICBcIkxlZnRWZWN0b3JCYXJcIjpcIlxcdTI5NTJcIixcbiAgXCJsRWdcIjpcIlxcdTJBOEJcIixcbiAgXCJsZWdcIjpcIlxcdTIyREFcIixcbiAgXCJsZXFcIjpcIlxcdTIyNjRcIixcbiAgXCJsZXFxXCI6XCJcXHUyMjY2XCIsXG4gIFwibGVxc2xhbnRcIjpcIlxcdTJBN0RcIixcbiAgXCJsZXNcIjpcIlxcdTJBN0RcIixcbiAgXCJsZXNjY1wiOlwiXFx1MkFBOFwiLFxuICBcImxlc2RvdFwiOlwiXFx1MkE3RlwiLFxuICBcImxlc2RvdG9cIjpcIlxcdTJBODFcIixcbiAgXCJsZXNkb3RvclwiOlwiXFx1MkE4M1wiLFxuICBcImxlc2dcIjpcIlxcdTIyREFcXHVGRTAwXCIsXG4gIFwibGVzZ2VzXCI6XCJcXHUyQTkzXCIsXG4gIFwibGVzc2FwcHJveFwiOlwiXFx1MkE4NVwiLFxuICBcImxlc3Nkb3RcIjpcIlxcdTIyRDZcIixcbiAgXCJsZXNzZXFndHJcIjpcIlxcdTIyREFcIixcbiAgXCJsZXNzZXFxZ3RyXCI6XCJcXHUyQThCXCIsXG4gIFwiTGVzc0VxdWFsR3JlYXRlclwiOlwiXFx1MjJEQVwiLFxuICBcIkxlc3NGdWxsRXF1YWxcIjpcIlxcdTIyNjZcIixcbiAgXCJMZXNzR3JlYXRlclwiOlwiXFx1MjI3NlwiLFxuICBcImxlc3NndHJcIjpcIlxcdTIyNzZcIixcbiAgXCJMZXNzTGVzc1wiOlwiXFx1MkFBMVwiLFxuICBcImxlc3NzaW1cIjpcIlxcdTIyNzJcIixcbiAgXCJMZXNzU2xhbnRFcXVhbFwiOlwiXFx1MkE3RFwiLFxuICBcIkxlc3NUaWxkZVwiOlwiXFx1MjI3MlwiLFxuICBcImxmaXNodFwiOlwiXFx1Mjk3Q1wiLFxuICBcImxmbG9vclwiOlwiXFx1MjMwQVwiLFxuICBcIkxmclwiOlwiXFx1RDgzNVxcdUREMEZcIixcbiAgXCJsZnJcIjpcIlxcdUQ4MzVcXHVERDI5XCIsXG4gIFwibGdcIjpcIlxcdTIyNzZcIixcbiAgXCJsZ0VcIjpcIlxcdTJBOTFcIixcbiAgXCJsSGFyXCI6XCJcXHUyOTYyXCIsXG4gIFwibGhhcmRcIjpcIlxcdTIxQkRcIixcbiAgXCJsaGFydVwiOlwiXFx1MjFCQ1wiLFxuICBcImxoYXJ1bFwiOlwiXFx1Mjk2QVwiLFxuICBcImxoYmxrXCI6XCJcXHUyNTg0XCIsXG4gIFwiTEpjeVwiOlwiXFx1MDQwOVwiLFxuICBcImxqY3lcIjpcIlxcdTA0NTlcIixcbiAgXCJMbFwiOlwiXFx1MjJEOFwiLFxuICBcImxsXCI6XCJcXHUyMjZBXCIsXG4gIFwibGxhcnJcIjpcIlxcdTIxQzdcIixcbiAgXCJsbGNvcm5lclwiOlwiXFx1MjMxRVwiLFxuICBcIkxsZWZ0YXJyb3dcIjpcIlxcdTIxREFcIixcbiAgXCJsbGhhcmRcIjpcIlxcdTI5NkJcIixcbiAgXCJsbHRyaVwiOlwiXFx1MjVGQVwiLFxuICBcIkxtaWRvdFwiOlwiXFx1MDEzRlwiLFxuICBcImxtaWRvdFwiOlwiXFx1MDE0MFwiLFxuICBcImxtb3VzdFwiOlwiXFx1MjNCMFwiLFxuICBcImxtb3VzdGFjaGVcIjpcIlxcdTIzQjBcIixcbiAgXCJsbmFwXCI6XCJcXHUyQTg5XCIsXG4gIFwibG5hcHByb3hcIjpcIlxcdTJBODlcIixcbiAgXCJsbkVcIjpcIlxcdTIyNjhcIixcbiAgXCJsbmVcIjpcIlxcdTJBODdcIixcbiAgXCJsbmVxXCI6XCJcXHUyQTg3XCIsXG4gIFwibG5lcXFcIjpcIlxcdTIyNjhcIixcbiAgXCJsbnNpbVwiOlwiXFx1MjJFNlwiLFxuICBcImxvYW5nXCI6XCJcXHUyN0VDXCIsXG4gIFwibG9hcnJcIjpcIlxcdTIxRkRcIixcbiAgXCJsb2Jya1wiOlwiXFx1MjdFNlwiLFxuICBcIkxvbmdMZWZ0QXJyb3dcIjpcIlxcdTI3RjVcIixcbiAgXCJMb25nbGVmdGFycm93XCI6XCJcXHUyN0Y4XCIsXG4gIFwibG9uZ2xlZnRhcnJvd1wiOlwiXFx1MjdGNVwiLFxuICBcIkxvbmdMZWZ0UmlnaHRBcnJvd1wiOlwiXFx1MjdGN1wiLFxuICBcIkxvbmdsZWZ0cmlnaHRhcnJvd1wiOlwiXFx1MjdGQVwiLFxuICBcImxvbmdsZWZ0cmlnaHRhcnJvd1wiOlwiXFx1MjdGN1wiLFxuICBcImxvbmdtYXBzdG9cIjpcIlxcdTI3RkNcIixcbiAgXCJMb25nUmlnaHRBcnJvd1wiOlwiXFx1MjdGNlwiLFxuICBcIkxvbmdyaWdodGFycm93XCI6XCJcXHUyN0Y5XCIsXG4gIFwibG9uZ3JpZ2h0YXJyb3dcIjpcIlxcdTI3RjZcIixcbiAgXCJsb29wYXJyb3dsZWZ0XCI6XCJcXHUyMUFCXCIsXG4gIFwibG9vcGFycm93cmlnaHRcIjpcIlxcdTIxQUNcIixcbiAgXCJsb3BhclwiOlwiXFx1Mjk4NVwiLFxuICBcIkxvcGZcIjpcIlxcdUQ4MzVcXHVERDQzXCIsXG4gIFwibG9wZlwiOlwiXFx1RDgzNVxcdURENURcIixcbiAgXCJsb3BsdXNcIjpcIlxcdTJBMkRcIixcbiAgXCJsb3RpbWVzXCI6XCJcXHUyQTM0XCIsXG4gIFwibG93YXN0XCI6XCJcXHUyMjE3XCIsXG4gIFwibG93YmFyXCI6XCJcXHUwMDVGXCIsXG4gIFwiTG93ZXJMZWZ0QXJyb3dcIjpcIlxcdTIxOTlcIixcbiAgXCJMb3dlclJpZ2h0QXJyb3dcIjpcIlxcdTIxOThcIixcbiAgXCJsb3pcIjpcIlxcdTI1Q0FcIixcbiAgXCJsb3plbmdlXCI6XCJcXHUyNUNBXCIsXG4gIFwibG96ZlwiOlwiXFx1MjlFQlwiLFxuICBcImxwYXJcIjpcIlxcdTAwMjhcIixcbiAgXCJscGFybHRcIjpcIlxcdTI5OTNcIixcbiAgXCJscmFyclwiOlwiXFx1MjFDNlwiLFxuICBcImxyY29ybmVyXCI6XCJcXHUyMzFGXCIsXG4gIFwibHJoYXJcIjpcIlxcdTIxQ0JcIixcbiAgXCJscmhhcmRcIjpcIlxcdTI5NkRcIixcbiAgXCJscm1cIjpcIlxcdTIwMEVcIixcbiAgXCJscnRyaVwiOlwiXFx1MjJCRlwiLFxuICBcImxzYXF1b1wiOlwiXFx1MjAzOVwiLFxuICBcIkxzY3JcIjpcIlxcdTIxMTJcIixcbiAgXCJsc2NyXCI6XCJcXHVEODM1XFx1RENDMVwiLFxuICBcIkxzaFwiOlwiXFx1MjFCMFwiLFxuICBcImxzaFwiOlwiXFx1MjFCMFwiLFxuICBcImxzaW1cIjpcIlxcdTIyNzJcIixcbiAgXCJsc2ltZVwiOlwiXFx1MkE4RFwiLFxuICBcImxzaW1nXCI6XCJcXHUyQThGXCIsXG4gIFwibHNxYlwiOlwiXFx1MDA1QlwiLFxuICBcImxzcXVvXCI6XCJcXHUyMDE4XCIsXG4gIFwibHNxdW9yXCI6XCJcXHUyMDFBXCIsXG4gIFwiTHN0cm9rXCI6XCJcXHUwMTQxXCIsXG4gIFwibHN0cm9rXCI6XCJcXHUwMTQyXCIsXG4gIFwiTFRcIjpcIlxcdTAwM0NcIixcbiAgXCJMdFwiOlwiXFx1MjI2QVwiLFxuICBcImx0XCI6XCJcXHUwMDNDXCIsXG4gIFwibHRjY1wiOlwiXFx1MkFBNlwiLFxuICBcImx0Y2lyXCI6XCJcXHUyQTc5XCIsXG4gIFwibHRkb3RcIjpcIlxcdTIyRDZcIixcbiAgXCJsdGhyZWVcIjpcIlxcdTIyQ0JcIixcbiAgXCJsdGltZXNcIjpcIlxcdTIyQzlcIixcbiAgXCJsdGxhcnJcIjpcIlxcdTI5NzZcIixcbiAgXCJsdHF1ZXN0XCI6XCJcXHUyQTdCXCIsXG4gIFwibHRyaVwiOlwiXFx1MjVDM1wiLFxuICBcImx0cmllXCI6XCJcXHUyMkI0XCIsXG4gIFwibHRyaWZcIjpcIlxcdTI1QzJcIixcbiAgXCJsdHJQYXJcIjpcIlxcdTI5OTZcIixcbiAgXCJsdXJkc2hhclwiOlwiXFx1Mjk0QVwiLFxuICBcImx1cnVoYXJcIjpcIlxcdTI5NjZcIixcbiAgXCJsdmVydG5lcXFcIjpcIlxcdTIyNjhcXHVGRTAwXCIsXG4gIFwibHZuRVwiOlwiXFx1MjI2OFxcdUZFMDBcIixcbiAgXCJtYWNyXCI6XCJcXHUwMEFGXCIsXG4gIFwibWFsZVwiOlwiXFx1MjY0MlwiLFxuICBcIm1hbHRcIjpcIlxcdTI3MjBcIixcbiAgXCJtYWx0ZXNlXCI6XCJcXHUyNzIwXCIsXG4gIFwiTWFwXCI6XCJcXHUyOTA1XCIsXG4gIFwibWFwXCI6XCJcXHUyMUE2XCIsXG4gIFwibWFwc3RvXCI6XCJcXHUyMUE2XCIsXG4gIFwibWFwc3RvZG93blwiOlwiXFx1MjFBN1wiLFxuICBcIm1hcHN0b2xlZnRcIjpcIlxcdTIxQTRcIixcbiAgXCJtYXBzdG91cFwiOlwiXFx1MjFBNVwiLFxuICBcIm1hcmtlclwiOlwiXFx1MjVBRVwiLFxuICBcIm1jb21tYVwiOlwiXFx1MkEyOVwiLFxuICBcIk1jeVwiOlwiXFx1MDQxQ1wiLFxuICBcIm1jeVwiOlwiXFx1MDQzQ1wiLFxuICBcIm1kYXNoXCI6XCJcXHUyMDE0XCIsXG4gIFwibUREb3RcIjpcIlxcdTIyM0FcIixcbiAgXCJtZWFzdXJlZGFuZ2xlXCI6XCJcXHUyMjIxXCIsXG4gIFwiTWVkaXVtU3BhY2VcIjpcIlxcdTIwNUZcIixcbiAgXCJNZWxsaW50cmZcIjpcIlxcdTIxMzNcIixcbiAgXCJNZnJcIjpcIlxcdUQ4MzVcXHVERDEwXCIsXG4gIFwibWZyXCI6XCJcXHVEODM1XFx1REQyQVwiLFxuICBcIm1ob1wiOlwiXFx1MjEyN1wiLFxuICBcIm1pY3JvXCI6XCJcXHUwMEI1XCIsXG4gIFwibWlkXCI6XCJcXHUyMjIzXCIsXG4gIFwibWlkYXN0XCI6XCJcXHUwMDJBXCIsXG4gIFwibWlkY2lyXCI6XCJcXHUyQUYwXCIsXG4gIFwibWlkZG90XCI6XCJcXHUwMEI3XCIsXG4gIFwibWludXNcIjpcIlxcdTIyMTJcIixcbiAgXCJtaW51c2JcIjpcIlxcdTIyOUZcIixcbiAgXCJtaW51c2RcIjpcIlxcdTIyMzhcIixcbiAgXCJtaW51c2R1XCI6XCJcXHUyQTJBXCIsXG4gIFwiTWludXNQbHVzXCI6XCJcXHUyMjEzXCIsXG4gIFwibWxjcFwiOlwiXFx1MkFEQlwiLFxuICBcIm1sZHJcIjpcIlxcdTIwMjZcIixcbiAgXCJtbnBsdXNcIjpcIlxcdTIyMTNcIixcbiAgXCJtb2RlbHNcIjpcIlxcdTIyQTdcIixcbiAgXCJNb3BmXCI6XCJcXHVEODM1XFx1REQ0NFwiLFxuICBcIm1vcGZcIjpcIlxcdUQ4MzVcXHVERDVFXCIsXG4gIFwibXBcIjpcIlxcdTIyMTNcIixcbiAgXCJNc2NyXCI6XCJcXHUyMTMzXCIsXG4gIFwibXNjclwiOlwiXFx1RDgzNVxcdURDQzJcIixcbiAgXCJtc3Rwb3NcIjpcIlxcdTIyM0VcIixcbiAgXCJNdVwiOlwiXFx1MDM5Q1wiLFxuICBcIm11XCI6XCJcXHUwM0JDXCIsXG4gIFwibXVsdGltYXBcIjpcIlxcdTIyQjhcIixcbiAgXCJtdW1hcFwiOlwiXFx1MjJCOFwiLFxuICBcIm5hYmxhXCI6XCJcXHUyMjA3XCIsXG4gIFwiTmFjdXRlXCI6XCJcXHUwMTQzXCIsXG4gIFwibmFjdXRlXCI6XCJcXHUwMTQ0XCIsXG4gIFwibmFuZ1wiOlwiXFx1MjIyMFxcdTIwRDJcIixcbiAgXCJuYXBcIjpcIlxcdTIyNDlcIixcbiAgXCJuYXBFXCI6XCJcXHUyQTcwXFx1MDMzOFwiLFxuICBcIm5hcGlkXCI6XCJcXHUyMjRCXFx1MDMzOFwiLFxuICBcIm5hcG9zXCI6XCJcXHUwMTQ5XCIsXG4gIFwibmFwcHJveFwiOlwiXFx1MjI0OVwiLFxuICBcIm5hdHVyXCI6XCJcXHUyNjZFXCIsXG4gIFwibmF0dXJhbFwiOlwiXFx1MjY2RVwiLFxuICBcIm5hdHVyYWxzXCI6XCJcXHUyMTE1XCIsXG4gIFwibmJzcFwiOlwiXFx1MDBBMFwiLFxuICBcIm5idW1wXCI6XCJcXHUyMjRFXFx1MDMzOFwiLFxuICBcIm5idW1wZVwiOlwiXFx1MjI0RlxcdTAzMzhcIixcbiAgXCJuY2FwXCI6XCJcXHUyQTQzXCIsXG4gIFwiTmNhcm9uXCI6XCJcXHUwMTQ3XCIsXG4gIFwibmNhcm9uXCI6XCJcXHUwMTQ4XCIsXG4gIFwiTmNlZGlsXCI6XCJcXHUwMTQ1XCIsXG4gIFwibmNlZGlsXCI6XCJcXHUwMTQ2XCIsXG4gIFwibmNvbmdcIjpcIlxcdTIyNDdcIixcbiAgXCJuY29uZ2RvdFwiOlwiXFx1MkE2RFxcdTAzMzhcIixcbiAgXCJuY3VwXCI6XCJcXHUyQTQyXCIsXG4gIFwiTmN5XCI6XCJcXHUwNDFEXCIsXG4gIFwibmN5XCI6XCJcXHUwNDNEXCIsXG4gIFwibmRhc2hcIjpcIlxcdTIwMTNcIixcbiAgXCJuZVwiOlwiXFx1MjI2MFwiLFxuICBcIm5lYXJoa1wiOlwiXFx1MjkyNFwiLFxuICBcIm5lQXJyXCI6XCJcXHUyMUQ3XCIsXG4gIFwibmVhcnJcIjpcIlxcdTIxOTdcIixcbiAgXCJuZWFycm93XCI6XCJcXHUyMTk3XCIsXG4gIFwibmVkb3RcIjpcIlxcdTIyNTBcXHUwMzM4XCIsXG4gIFwiTmVnYXRpdmVNZWRpdW1TcGFjZVwiOlwiXFx1MjAwQlwiLFxuICBcIk5lZ2F0aXZlVGhpY2tTcGFjZVwiOlwiXFx1MjAwQlwiLFxuICBcIk5lZ2F0aXZlVGhpblNwYWNlXCI6XCJcXHUyMDBCXCIsXG4gIFwiTmVnYXRpdmVWZXJ5VGhpblNwYWNlXCI6XCJcXHUyMDBCXCIsXG4gIFwibmVxdWl2XCI6XCJcXHUyMjYyXCIsXG4gIFwibmVzZWFyXCI6XCJcXHUyOTI4XCIsXG4gIFwibmVzaW1cIjpcIlxcdTIyNDJcXHUwMzM4XCIsXG4gIFwiTmVzdGVkR3JlYXRlckdyZWF0ZXJcIjpcIlxcdTIyNkJcIixcbiAgXCJOZXN0ZWRMZXNzTGVzc1wiOlwiXFx1MjI2QVwiLFxuICBcIk5ld0xpbmVcIjpcIlxcdTAwMEFcIixcbiAgXCJuZXhpc3RcIjpcIlxcdTIyMDRcIixcbiAgXCJuZXhpc3RzXCI6XCJcXHUyMjA0XCIsXG4gIFwiTmZyXCI6XCJcXHVEODM1XFx1REQxMVwiLFxuICBcIm5mclwiOlwiXFx1RDgzNVxcdUREMkJcIixcbiAgXCJuZ0VcIjpcIlxcdTIyNjdcXHUwMzM4XCIsXG4gIFwibmdlXCI6XCJcXHUyMjcxXCIsXG4gIFwibmdlcVwiOlwiXFx1MjI3MVwiLFxuICBcIm5nZXFxXCI6XCJcXHUyMjY3XFx1MDMzOFwiLFxuICBcIm5nZXFzbGFudFwiOlwiXFx1MkE3RVxcdTAzMzhcIixcbiAgXCJuZ2VzXCI6XCJcXHUyQTdFXFx1MDMzOFwiLFxuICBcIm5HZ1wiOlwiXFx1MjJEOVxcdTAzMzhcIixcbiAgXCJuZ3NpbVwiOlwiXFx1MjI3NVwiLFxuICBcIm5HdFwiOlwiXFx1MjI2QlxcdTIwRDJcIixcbiAgXCJuZ3RcIjpcIlxcdTIyNkZcIixcbiAgXCJuZ3RyXCI6XCJcXHUyMjZGXCIsXG4gIFwibkd0dlwiOlwiXFx1MjI2QlxcdTAzMzhcIixcbiAgXCJuaEFyclwiOlwiXFx1MjFDRVwiLFxuICBcIm5oYXJyXCI6XCJcXHUyMUFFXCIsXG4gIFwibmhwYXJcIjpcIlxcdTJBRjJcIixcbiAgXCJuaVwiOlwiXFx1MjIwQlwiLFxuICBcIm5pc1wiOlwiXFx1MjJGQ1wiLFxuICBcIm5pc2RcIjpcIlxcdTIyRkFcIixcbiAgXCJuaXZcIjpcIlxcdTIyMEJcIixcbiAgXCJOSmN5XCI6XCJcXHUwNDBBXCIsXG4gIFwibmpjeVwiOlwiXFx1MDQ1QVwiLFxuICBcIm5sQXJyXCI6XCJcXHUyMUNEXCIsXG4gIFwibmxhcnJcIjpcIlxcdTIxOUFcIixcbiAgXCJubGRyXCI6XCJcXHUyMDI1XCIsXG4gIFwibmxFXCI6XCJcXHUyMjY2XFx1MDMzOFwiLFxuICBcIm5sZVwiOlwiXFx1MjI3MFwiLFxuICBcIm5MZWZ0YXJyb3dcIjpcIlxcdTIxQ0RcIixcbiAgXCJubGVmdGFycm93XCI6XCJcXHUyMTlBXCIsXG4gIFwibkxlZnRyaWdodGFycm93XCI6XCJcXHUyMUNFXCIsXG4gIFwibmxlZnRyaWdodGFycm93XCI6XCJcXHUyMUFFXCIsXG4gIFwibmxlcVwiOlwiXFx1MjI3MFwiLFxuICBcIm5sZXFxXCI6XCJcXHUyMjY2XFx1MDMzOFwiLFxuICBcIm5sZXFzbGFudFwiOlwiXFx1MkE3RFxcdTAzMzhcIixcbiAgXCJubGVzXCI6XCJcXHUyQTdEXFx1MDMzOFwiLFxuICBcIm5sZXNzXCI6XCJcXHUyMjZFXCIsXG4gIFwibkxsXCI6XCJcXHUyMkQ4XFx1MDMzOFwiLFxuICBcIm5sc2ltXCI6XCJcXHUyMjc0XCIsXG4gIFwibkx0XCI6XCJcXHUyMjZBXFx1MjBEMlwiLFxuICBcIm5sdFwiOlwiXFx1MjI2RVwiLFxuICBcIm5sdHJpXCI6XCJcXHUyMkVBXCIsXG4gIFwibmx0cmllXCI6XCJcXHUyMkVDXCIsXG4gIFwibkx0dlwiOlwiXFx1MjI2QVxcdTAzMzhcIixcbiAgXCJubWlkXCI6XCJcXHUyMjI0XCIsXG4gIFwiTm9CcmVha1wiOlwiXFx1MjA2MFwiLFxuICBcIk5vbkJyZWFraW5nU3BhY2VcIjpcIlxcdTAwQTBcIixcbiAgXCJOb3BmXCI6XCJcXHUyMTE1XCIsXG4gIFwibm9wZlwiOlwiXFx1RDgzNVxcdURENUZcIixcbiAgXCJOb3RcIjpcIlxcdTJBRUNcIixcbiAgXCJub3RcIjpcIlxcdTAwQUNcIixcbiAgXCJOb3RDb25ncnVlbnRcIjpcIlxcdTIyNjJcIixcbiAgXCJOb3RDdXBDYXBcIjpcIlxcdTIyNkRcIixcbiAgXCJOb3REb3VibGVWZXJ0aWNhbEJhclwiOlwiXFx1MjIyNlwiLFxuICBcIk5vdEVsZW1lbnRcIjpcIlxcdTIyMDlcIixcbiAgXCJOb3RFcXVhbFwiOlwiXFx1MjI2MFwiLFxuICBcIk5vdEVxdWFsVGlsZGVcIjpcIlxcdTIyNDJcXHUwMzM4XCIsXG4gIFwiTm90RXhpc3RzXCI6XCJcXHUyMjA0XCIsXG4gIFwiTm90R3JlYXRlclwiOlwiXFx1MjI2RlwiLFxuICBcIk5vdEdyZWF0ZXJFcXVhbFwiOlwiXFx1MjI3MVwiLFxuICBcIk5vdEdyZWF0ZXJGdWxsRXF1YWxcIjpcIlxcdTIyNjdcXHUwMzM4XCIsXG4gIFwiTm90R3JlYXRlckdyZWF0ZXJcIjpcIlxcdTIyNkJcXHUwMzM4XCIsXG4gIFwiTm90R3JlYXRlckxlc3NcIjpcIlxcdTIyNzlcIixcbiAgXCJOb3RHcmVhdGVyU2xhbnRFcXVhbFwiOlwiXFx1MkE3RVxcdTAzMzhcIixcbiAgXCJOb3RHcmVhdGVyVGlsZGVcIjpcIlxcdTIyNzVcIixcbiAgXCJOb3RIdW1wRG93bkh1bXBcIjpcIlxcdTIyNEVcXHUwMzM4XCIsXG4gIFwiTm90SHVtcEVxdWFsXCI6XCJcXHUyMjRGXFx1MDMzOFwiLFxuICBcIm5vdGluXCI6XCJcXHUyMjA5XCIsXG4gIFwibm90aW5kb3RcIjpcIlxcdTIyRjVcXHUwMzM4XCIsXG4gIFwibm90aW5FXCI6XCJcXHUyMkY5XFx1MDMzOFwiLFxuICBcIm5vdGludmFcIjpcIlxcdTIyMDlcIixcbiAgXCJub3RpbnZiXCI6XCJcXHUyMkY3XCIsXG4gIFwibm90aW52Y1wiOlwiXFx1MjJGNlwiLFxuICBcIk5vdExlZnRUcmlhbmdsZVwiOlwiXFx1MjJFQVwiLFxuICBcIk5vdExlZnRUcmlhbmdsZUJhclwiOlwiXFx1MjlDRlxcdTAzMzhcIixcbiAgXCJOb3RMZWZ0VHJpYW5nbGVFcXVhbFwiOlwiXFx1MjJFQ1wiLFxuICBcIk5vdExlc3NcIjpcIlxcdTIyNkVcIixcbiAgXCJOb3RMZXNzRXF1YWxcIjpcIlxcdTIyNzBcIixcbiAgXCJOb3RMZXNzR3JlYXRlclwiOlwiXFx1MjI3OFwiLFxuICBcIk5vdExlc3NMZXNzXCI6XCJcXHUyMjZBXFx1MDMzOFwiLFxuICBcIk5vdExlc3NTbGFudEVxdWFsXCI6XCJcXHUyQTdEXFx1MDMzOFwiLFxuICBcIk5vdExlc3NUaWxkZVwiOlwiXFx1MjI3NFwiLFxuICBcIk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyXCI6XCJcXHUyQUEyXFx1MDMzOFwiLFxuICBcIk5vdE5lc3RlZExlc3NMZXNzXCI6XCJcXHUyQUExXFx1MDMzOFwiLFxuICBcIm5vdG5pXCI6XCJcXHUyMjBDXCIsXG4gIFwibm90bml2YVwiOlwiXFx1MjIwQ1wiLFxuICBcIm5vdG5pdmJcIjpcIlxcdTIyRkVcIixcbiAgXCJub3RuaXZjXCI6XCJcXHUyMkZEXCIsXG4gIFwiTm90UHJlY2VkZXNcIjpcIlxcdTIyODBcIixcbiAgXCJOb3RQcmVjZWRlc0VxdWFsXCI6XCJcXHUyQUFGXFx1MDMzOFwiLFxuICBcIk5vdFByZWNlZGVzU2xhbnRFcXVhbFwiOlwiXFx1MjJFMFwiLFxuICBcIk5vdFJldmVyc2VFbGVtZW50XCI6XCJcXHUyMjBDXCIsXG4gIFwiTm90UmlnaHRUcmlhbmdsZVwiOlwiXFx1MjJFQlwiLFxuICBcIk5vdFJpZ2h0VHJpYW5nbGVCYXJcIjpcIlxcdTI5RDBcXHUwMzM4XCIsXG4gIFwiTm90UmlnaHRUcmlhbmdsZUVxdWFsXCI6XCJcXHUyMkVEXCIsXG4gIFwiTm90U3F1YXJlU3Vic2V0XCI6XCJcXHUyMjhGXFx1MDMzOFwiLFxuICBcIk5vdFNxdWFyZVN1YnNldEVxdWFsXCI6XCJcXHUyMkUyXCIsXG4gIFwiTm90U3F1YXJlU3VwZXJzZXRcIjpcIlxcdTIyOTBcXHUwMzM4XCIsXG4gIFwiTm90U3F1YXJlU3VwZXJzZXRFcXVhbFwiOlwiXFx1MjJFM1wiLFxuICBcIk5vdFN1YnNldFwiOlwiXFx1MjI4MlxcdTIwRDJcIixcbiAgXCJOb3RTdWJzZXRFcXVhbFwiOlwiXFx1MjI4OFwiLFxuICBcIk5vdFN1Y2NlZWRzXCI6XCJcXHUyMjgxXCIsXG4gIFwiTm90U3VjY2VlZHNFcXVhbFwiOlwiXFx1MkFCMFxcdTAzMzhcIixcbiAgXCJOb3RTdWNjZWVkc1NsYW50RXF1YWxcIjpcIlxcdTIyRTFcIixcbiAgXCJOb3RTdWNjZWVkc1RpbGRlXCI6XCJcXHUyMjdGXFx1MDMzOFwiLFxuICBcIk5vdFN1cGVyc2V0XCI6XCJcXHUyMjgzXFx1MjBEMlwiLFxuICBcIk5vdFN1cGVyc2V0RXF1YWxcIjpcIlxcdTIyODlcIixcbiAgXCJOb3RUaWxkZVwiOlwiXFx1MjI0MVwiLFxuICBcIk5vdFRpbGRlRXF1YWxcIjpcIlxcdTIyNDRcIixcbiAgXCJOb3RUaWxkZUZ1bGxFcXVhbFwiOlwiXFx1MjI0N1wiLFxuICBcIk5vdFRpbGRlVGlsZGVcIjpcIlxcdTIyNDlcIixcbiAgXCJOb3RWZXJ0aWNhbEJhclwiOlwiXFx1MjIyNFwiLFxuICBcIm5wYXJcIjpcIlxcdTIyMjZcIixcbiAgXCJucGFyYWxsZWxcIjpcIlxcdTIyMjZcIixcbiAgXCJucGFyc2xcIjpcIlxcdTJBRkRcXHUyMEU1XCIsXG4gIFwibnBhcnRcIjpcIlxcdTIyMDJcXHUwMzM4XCIsXG4gIFwibnBvbGludFwiOlwiXFx1MkExNFwiLFxuICBcIm5wclwiOlwiXFx1MjI4MFwiLFxuICBcIm5wcmN1ZVwiOlwiXFx1MjJFMFwiLFxuICBcIm5wcmVcIjpcIlxcdTJBQUZcXHUwMzM4XCIsXG4gIFwibnByZWNcIjpcIlxcdTIyODBcIixcbiAgXCJucHJlY2VxXCI6XCJcXHUyQUFGXFx1MDMzOFwiLFxuICBcIm5yQXJyXCI6XCJcXHUyMUNGXCIsXG4gIFwibnJhcnJcIjpcIlxcdTIxOUJcIixcbiAgXCJucmFycmNcIjpcIlxcdTI5MzNcXHUwMzM4XCIsXG4gIFwibnJhcnJ3XCI6XCJcXHUyMTlEXFx1MDMzOFwiLFxuICBcIm5SaWdodGFycm93XCI6XCJcXHUyMUNGXCIsXG4gIFwibnJpZ2h0YXJyb3dcIjpcIlxcdTIxOUJcIixcbiAgXCJucnRyaVwiOlwiXFx1MjJFQlwiLFxuICBcIm5ydHJpZVwiOlwiXFx1MjJFRFwiLFxuICBcIm5zY1wiOlwiXFx1MjI4MVwiLFxuICBcIm5zY2N1ZVwiOlwiXFx1MjJFMVwiLFxuICBcIm5zY2VcIjpcIlxcdTJBQjBcXHUwMzM4XCIsXG4gIFwiTnNjclwiOlwiXFx1RDgzNVxcdURDQTlcIixcbiAgXCJuc2NyXCI6XCJcXHVEODM1XFx1RENDM1wiLFxuICBcIm5zaG9ydG1pZFwiOlwiXFx1MjIyNFwiLFxuICBcIm5zaG9ydHBhcmFsbGVsXCI6XCJcXHUyMjI2XCIsXG4gIFwibnNpbVwiOlwiXFx1MjI0MVwiLFxuICBcIm5zaW1lXCI6XCJcXHUyMjQ0XCIsXG4gIFwibnNpbWVxXCI6XCJcXHUyMjQ0XCIsXG4gIFwibnNtaWRcIjpcIlxcdTIyMjRcIixcbiAgXCJuc3BhclwiOlwiXFx1MjIyNlwiLFxuICBcIm5zcXN1YmVcIjpcIlxcdTIyRTJcIixcbiAgXCJuc3FzdXBlXCI6XCJcXHUyMkUzXCIsXG4gIFwibnN1YlwiOlwiXFx1MjI4NFwiLFxuICBcIm5zdWJFXCI6XCJcXHUyQUM1XFx1MDMzOFwiLFxuICBcIm5zdWJlXCI6XCJcXHUyMjg4XCIsXG4gIFwibnN1YnNldFwiOlwiXFx1MjI4MlxcdTIwRDJcIixcbiAgXCJuc3Vic2V0ZXFcIjpcIlxcdTIyODhcIixcbiAgXCJuc3Vic2V0ZXFxXCI6XCJcXHUyQUM1XFx1MDMzOFwiLFxuICBcIm5zdWNjXCI6XCJcXHUyMjgxXCIsXG4gIFwibnN1Y2NlcVwiOlwiXFx1MkFCMFxcdTAzMzhcIixcbiAgXCJuc3VwXCI6XCJcXHUyMjg1XCIsXG4gIFwibnN1cEVcIjpcIlxcdTJBQzZcXHUwMzM4XCIsXG4gIFwibnN1cGVcIjpcIlxcdTIyODlcIixcbiAgXCJuc3Vwc2V0XCI6XCJcXHUyMjgzXFx1MjBEMlwiLFxuICBcIm5zdXBzZXRlcVwiOlwiXFx1MjI4OVwiLFxuICBcIm5zdXBzZXRlcXFcIjpcIlxcdTJBQzZcXHUwMzM4XCIsXG4gIFwibnRnbFwiOlwiXFx1MjI3OVwiLFxuICBcIk50aWxkZVwiOlwiXFx1MDBEMVwiLFxuICBcIm50aWxkZVwiOlwiXFx1MDBGMVwiLFxuICBcIm50bGdcIjpcIlxcdTIyNzhcIixcbiAgXCJudHJpYW5nbGVsZWZ0XCI6XCJcXHUyMkVBXCIsXG4gIFwibnRyaWFuZ2xlbGVmdGVxXCI6XCJcXHUyMkVDXCIsXG4gIFwibnRyaWFuZ2xlcmlnaHRcIjpcIlxcdTIyRUJcIixcbiAgXCJudHJpYW5nbGVyaWdodGVxXCI6XCJcXHUyMkVEXCIsXG4gIFwiTnVcIjpcIlxcdTAzOURcIixcbiAgXCJudVwiOlwiXFx1MDNCRFwiLFxuICBcIm51bVwiOlwiXFx1MDAyM1wiLFxuICBcIm51bWVyb1wiOlwiXFx1MjExNlwiLFxuICBcIm51bXNwXCI6XCJcXHUyMDA3XCIsXG4gIFwibnZhcFwiOlwiXFx1MjI0RFxcdTIwRDJcIixcbiAgXCJuVkRhc2hcIjpcIlxcdTIyQUZcIixcbiAgXCJuVmRhc2hcIjpcIlxcdTIyQUVcIixcbiAgXCJudkRhc2hcIjpcIlxcdTIyQURcIixcbiAgXCJudmRhc2hcIjpcIlxcdTIyQUNcIixcbiAgXCJudmdlXCI6XCJcXHUyMjY1XFx1MjBEMlwiLFxuICBcIm52Z3RcIjpcIlxcdTAwM0VcXHUyMEQyXCIsXG4gIFwibnZIYXJyXCI6XCJcXHUyOTA0XCIsXG4gIFwibnZpbmZpblwiOlwiXFx1MjlERVwiLFxuICBcIm52bEFyclwiOlwiXFx1MjkwMlwiLFxuICBcIm52bGVcIjpcIlxcdTIyNjRcXHUyMEQyXCIsXG4gIFwibnZsdFwiOlwiXFx1MDAzQ1xcdTIwRDJcIixcbiAgXCJudmx0cmllXCI6XCJcXHUyMkI0XFx1MjBEMlwiLFxuICBcIm52ckFyclwiOlwiXFx1MjkwM1wiLFxuICBcIm52cnRyaWVcIjpcIlxcdTIyQjVcXHUyMEQyXCIsXG4gIFwibnZzaW1cIjpcIlxcdTIyM0NcXHUyMEQyXCIsXG4gIFwibndhcmhrXCI6XCJcXHUyOTIzXCIsXG4gIFwibndBcnJcIjpcIlxcdTIxRDZcIixcbiAgXCJud2FyclwiOlwiXFx1MjE5NlwiLFxuICBcIm53YXJyb3dcIjpcIlxcdTIxOTZcIixcbiAgXCJud25lYXJcIjpcIlxcdTI5MjdcIixcbiAgXCJPYWN1dGVcIjpcIlxcdTAwRDNcIixcbiAgXCJvYWN1dGVcIjpcIlxcdTAwRjNcIixcbiAgXCJvYXN0XCI6XCJcXHUyMjlCXCIsXG4gIFwib2NpclwiOlwiXFx1MjI5QVwiLFxuICBcIk9jaXJjXCI6XCJcXHUwMEQ0XCIsXG4gIFwib2NpcmNcIjpcIlxcdTAwRjRcIixcbiAgXCJPY3lcIjpcIlxcdTA0MUVcIixcbiAgXCJvY3lcIjpcIlxcdTA0M0VcIixcbiAgXCJvZGFzaFwiOlwiXFx1MjI5RFwiLFxuICBcIk9kYmxhY1wiOlwiXFx1MDE1MFwiLFxuICBcIm9kYmxhY1wiOlwiXFx1MDE1MVwiLFxuICBcIm9kaXZcIjpcIlxcdTJBMzhcIixcbiAgXCJvZG90XCI6XCJcXHUyMjk5XCIsXG4gIFwib2Rzb2xkXCI6XCJcXHUyOUJDXCIsXG4gIFwiT0VsaWdcIjpcIlxcdTAxNTJcIixcbiAgXCJvZWxpZ1wiOlwiXFx1MDE1M1wiLFxuICBcIm9mY2lyXCI6XCJcXHUyOUJGXCIsXG4gIFwiT2ZyXCI6XCJcXHVEODM1XFx1REQxMlwiLFxuICBcIm9mclwiOlwiXFx1RDgzNVxcdUREMkNcIixcbiAgXCJvZ29uXCI6XCJcXHUwMkRCXCIsXG4gIFwiT2dyYXZlXCI6XCJcXHUwMEQyXCIsXG4gIFwib2dyYXZlXCI6XCJcXHUwMEYyXCIsXG4gIFwib2d0XCI6XCJcXHUyOUMxXCIsXG4gIFwib2hiYXJcIjpcIlxcdTI5QjVcIixcbiAgXCJvaG1cIjpcIlxcdTAzQTlcIixcbiAgXCJvaW50XCI6XCJcXHUyMjJFXCIsXG4gIFwib2xhcnJcIjpcIlxcdTIxQkFcIixcbiAgXCJvbGNpclwiOlwiXFx1MjlCRVwiLFxuICBcIm9sY3Jvc3NcIjpcIlxcdTI5QkJcIixcbiAgXCJvbGluZVwiOlwiXFx1MjAzRVwiLFxuICBcIm9sdFwiOlwiXFx1MjlDMFwiLFxuICBcIk9tYWNyXCI6XCJcXHUwMTRDXCIsXG4gIFwib21hY3JcIjpcIlxcdTAxNERcIixcbiAgXCJPbWVnYVwiOlwiXFx1MDNBOVwiLFxuICBcIm9tZWdhXCI6XCJcXHUwM0M5XCIsXG4gIFwiT21pY3JvblwiOlwiXFx1MDM5RlwiLFxuICBcIm9taWNyb25cIjpcIlxcdTAzQkZcIixcbiAgXCJvbWlkXCI6XCJcXHUyOUI2XCIsXG4gIFwib21pbnVzXCI6XCJcXHUyMjk2XCIsXG4gIFwiT29wZlwiOlwiXFx1RDgzNVxcdURENDZcIixcbiAgXCJvb3BmXCI6XCJcXHVEODM1XFx1REQ2MFwiLFxuICBcIm9wYXJcIjpcIlxcdTI5QjdcIixcbiAgXCJPcGVuQ3VybHlEb3VibGVRdW90ZVwiOlwiXFx1MjAxQ1wiLFxuICBcIk9wZW5DdXJseVF1b3RlXCI6XCJcXHUyMDE4XCIsXG4gIFwib3BlcnBcIjpcIlxcdTI5QjlcIixcbiAgXCJvcGx1c1wiOlwiXFx1MjI5NVwiLFxuICBcIk9yXCI6XCJcXHUyQTU0XCIsXG4gIFwib3JcIjpcIlxcdTIyMjhcIixcbiAgXCJvcmFyclwiOlwiXFx1MjFCQlwiLFxuICBcIm9yZFwiOlwiXFx1MkE1RFwiLFxuICBcIm9yZGVyXCI6XCJcXHUyMTM0XCIsXG4gIFwib3JkZXJvZlwiOlwiXFx1MjEzNFwiLFxuICBcIm9yZGZcIjpcIlxcdTAwQUFcIixcbiAgXCJvcmRtXCI6XCJcXHUwMEJBXCIsXG4gIFwib3JpZ29mXCI6XCJcXHUyMkI2XCIsXG4gIFwib3JvclwiOlwiXFx1MkE1NlwiLFxuICBcIm9yc2xvcGVcIjpcIlxcdTJBNTdcIixcbiAgXCJvcnZcIjpcIlxcdTJBNUJcIixcbiAgXCJvU1wiOlwiXFx1MjRDOFwiLFxuICBcIk9zY3JcIjpcIlxcdUQ4MzVcXHVEQ0FBXCIsXG4gIFwib3NjclwiOlwiXFx1MjEzNFwiLFxuICBcIk9zbGFzaFwiOlwiXFx1MDBEOFwiLFxuICBcIm9zbGFzaFwiOlwiXFx1MDBGOFwiLFxuICBcIm9zb2xcIjpcIlxcdTIyOThcIixcbiAgXCJPdGlsZGVcIjpcIlxcdTAwRDVcIixcbiAgXCJvdGlsZGVcIjpcIlxcdTAwRjVcIixcbiAgXCJPdGltZXNcIjpcIlxcdTJBMzdcIixcbiAgXCJvdGltZXNcIjpcIlxcdTIyOTdcIixcbiAgXCJvdGltZXNhc1wiOlwiXFx1MkEzNlwiLFxuICBcIk91bWxcIjpcIlxcdTAwRDZcIixcbiAgXCJvdW1sXCI6XCJcXHUwMEY2XCIsXG4gIFwib3ZiYXJcIjpcIlxcdTIzM0RcIixcbiAgXCJPdmVyQmFyXCI6XCJcXHUyMDNFXCIsXG4gIFwiT3ZlckJyYWNlXCI6XCJcXHUyM0RFXCIsXG4gIFwiT3ZlckJyYWNrZXRcIjpcIlxcdTIzQjRcIixcbiAgXCJPdmVyUGFyZW50aGVzaXNcIjpcIlxcdTIzRENcIixcbiAgXCJwYXJcIjpcIlxcdTIyMjVcIixcbiAgXCJwYXJhXCI6XCJcXHUwMEI2XCIsXG4gIFwicGFyYWxsZWxcIjpcIlxcdTIyMjVcIixcbiAgXCJwYXJzaW1cIjpcIlxcdTJBRjNcIixcbiAgXCJwYXJzbFwiOlwiXFx1MkFGRFwiLFxuICBcInBhcnRcIjpcIlxcdTIyMDJcIixcbiAgXCJQYXJ0aWFsRFwiOlwiXFx1MjIwMlwiLFxuICBcIlBjeVwiOlwiXFx1MDQxRlwiLFxuICBcInBjeVwiOlwiXFx1MDQzRlwiLFxuICBcInBlcmNudFwiOlwiXFx1MDAyNVwiLFxuICBcInBlcmlvZFwiOlwiXFx1MDAyRVwiLFxuICBcInBlcm1pbFwiOlwiXFx1MjAzMFwiLFxuICBcInBlcnBcIjpcIlxcdTIyQTVcIixcbiAgXCJwZXJ0ZW5rXCI6XCJcXHUyMDMxXCIsXG4gIFwiUGZyXCI6XCJcXHVEODM1XFx1REQxM1wiLFxuICBcInBmclwiOlwiXFx1RDgzNVxcdUREMkRcIixcbiAgXCJQaGlcIjpcIlxcdTAzQTZcIixcbiAgXCJwaGlcIjpcIlxcdTAzQzZcIixcbiAgXCJwaGl2XCI6XCJcXHUwM0Q1XCIsXG4gIFwicGhtbWF0XCI6XCJcXHUyMTMzXCIsXG4gIFwicGhvbmVcIjpcIlxcdTI2MEVcIixcbiAgXCJQaVwiOlwiXFx1MDNBMFwiLFxuICBcInBpXCI6XCJcXHUwM0MwXCIsXG4gIFwicGl0Y2hmb3JrXCI6XCJcXHUyMkQ0XCIsXG4gIFwicGl2XCI6XCJcXHUwM0Q2XCIsXG4gIFwicGxhbmNrXCI6XCJcXHUyMTBGXCIsXG4gIFwicGxhbmNraFwiOlwiXFx1MjEwRVwiLFxuICBcInBsYW5rdlwiOlwiXFx1MjEwRlwiLFxuICBcInBsdXNcIjpcIlxcdTAwMkJcIixcbiAgXCJwbHVzYWNpclwiOlwiXFx1MkEyM1wiLFxuICBcInBsdXNiXCI6XCJcXHUyMjlFXCIsXG4gIFwicGx1c2NpclwiOlwiXFx1MkEyMlwiLFxuICBcInBsdXNkb1wiOlwiXFx1MjIxNFwiLFxuICBcInBsdXNkdVwiOlwiXFx1MkEyNVwiLFxuICBcInBsdXNlXCI6XCJcXHUyQTcyXCIsXG4gIFwiUGx1c01pbnVzXCI6XCJcXHUwMEIxXCIsXG4gIFwicGx1c21uXCI6XCJcXHUwMEIxXCIsXG4gIFwicGx1c3NpbVwiOlwiXFx1MkEyNlwiLFxuICBcInBsdXN0d29cIjpcIlxcdTJBMjdcIixcbiAgXCJwbVwiOlwiXFx1MDBCMVwiLFxuICBcIlBvaW5jYXJlcGxhbmVcIjpcIlxcdTIxMENcIixcbiAgXCJwb2ludGludFwiOlwiXFx1MkExNVwiLFxuICBcIlBvcGZcIjpcIlxcdTIxMTlcIixcbiAgXCJwb3BmXCI6XCJcXHVEODM1XFx1REQ2MVwiLFxuICBcInBvdW5kXCI6XCJcXHUwMEEzXCIsXG4gIFwiUHJcIjpcIlxcdTJBQkJcIixcbiAgXCJwclwiOlwiXFx1MjI3QVwiLFxuICBcInByYXBcIjpcIlxcdTJBQjdcIixcbiAgXCJwcmN1ZVwiOlwiXFx1MjI3Q1wiLFxuICBcInByRVwiOlwiXFx1MkFCM1wiLFxuICBcInByZVwiOlwiXFx1MkFBRlwiLFxuICBcInByZWNcIjpcIlxcdTIyN0FcIixcbiAgXCJwcmVjYXBwcm94XCI6XCJcXHUyQUI3XCIsXG4gIFwicHJlY2N1cmx5ZXFcIjpcIlxcdTIyN0NcIixcbiAgXCJQcmVjZWRlc1wiOlwiXFx1MjI3QVwiLFxuICBcIlByZWNlZGVzRXF1YWxcIjpcIlxcdTJBQUZcIixcbiAgXCJQcmVjZWRlc1NsYW50RXF1YWxcIjpcIlxcdTIyN0NcIixcbiAgXCJQcmVjZWRlc1RpbGRlXCI6XCJcXHUyMjdFXCIsXG4gIFwicHJlY2VxXCI6XCJcXHUyQUFGXCIsXG4gIFwicHJlY25hcHByb3hcIjpcIlxcdTJBQjlcIixcbiAgXCJwcmVjbmVxcVwiOlwiXFx1MkFCNVwiLFxuICBcInByZWNuc2ltXCI6XCJcXHUyMkU4XCIsXG4gIFwicHJlY3NpbVwiOlwiXFx1MjI3RVwiLFxuICBcIlByaW1lXCI6XCJcXHUyMDMzXCIsXG4gIFwicHJpbWVcIjpcIlxcdTIwMzJcIixcbiAgXCJwcmltZXNcIjpcIlxcdTIxMTlcIixcbiAgXCJwcm5hcFwiOlwiXFx1MkFCOVwiLFxuICBcInBybkVcIjpcIlxcdTJBQjVcIixcbiAgXCJwcm5zaW1cIjpcIlxcdTIyRThcIixcbiAgXCJwcm9kXCI6XCJcXHUyMjBGXCIsXG4gIFwiUHJvZHVjdFwiOlwiXFx1MjIwRlwiLFxuICBcInByb2ZhbGFyXCI6XCJcXHUyMzJFXCIsXG4gIFwicHJvZmxpbmVcIjpcIlxcdTIzMTJcIixcbiAgXCJwcm9mc3VyZlwiOlwiXFx1MjMxM1wiLFxuICBcInByb3BcIjpcIlxcdTIyMURcIixcbiAgXCJQcm9wb3J0aW9uXCI6XCJcXHUyMjM3XCIsXG4gIFwiUHJvcG9ydGlvbmFsXCI6XCJcXHUyMjFEXCIsXG4gIFwicHJvcHRvXCI6XCJcXHUyMjFEXCIsXG4gIFwicHJzaW1cIjpcIlxcdTIyN0VcIixcbiAgXCJwcnVyZWxcIjpcIlxcdTIyQjBcIixcbiAgXCJQc2NyXCI6XCJcXHVEODM1XFx1RENBQlwiLFxuICBcInBzY3JcIjpcIlxcdUQ4MzVcXHVEQ0M1XCIsXG4gIFwiUHNpXCI6XCJcXHUwM0E4XCIsXG4gIFwicHNpXCI6XCJcXHUwM0M4XCIsXG4gIFwicHVuY3NwXCI6XCJcXHUyMDA4XCIsXG4gIFwiUWZyXCI6XCJcXHVEODM1XFx1REQxNFwiLFxuICBcInFmclwiOlwiXFx1RDgzNVxcdUREMkVcIixcbiAgXCJxaW50XCI6XCJcXHUyQTBDXCIsXG4gIFwiUW9wZlwiOlwiXFx1MjExQVwiLFxuICBcInFvcGZcIjpcIlxcdUQ4MzVcXHVERDYyXCIsXG4gIFwicXByaW1lXCI6XCJcXHUyMDU3XCIsXG4gIFwiUXNjclwiOlwiXFx1RDgzNVxcdURDQUNcIixcbiAgXCJxc2NyXCI6XCJcXHVEODM1XFx1RENDNlwiLFxuICBcInF1YXRlcm5pb25zXCI6XCJcXHUyMTBEXCIsXG4gIFwicXVhdGludFwiOlwiXFx1MkExNlwiLFxuICBcInF1ZXN0XCI6XCJcXHUwMDNGXCIsXG4gIFwicXVlc3RlcVwiOlwiXFx1MjI1RlwiLFxuICBcIlFVT1RcIjpcIlxcdTAwMjJcIixcbiAgXCJxdW90XCI6XCJcXHUwMDIyXCIsXG4gIFwickFhcnJcIjpcIlxcdTIxREJcIixcbiAgXCJyYWNlXCI6XCJcXHUyMjNEXFx1MDMzMVwiLFxuICBcIlJhY3V0ZVwiOlwiXFx1MDE1NFwiLFxuICBcInJhY3V0ZVwiOlwiXFx1MDE1NVwiLFxuICBcInJhZGljXCI6XCJcXHUyMjFBXCIsXG4gIFwicmFlbXB0eXZcIjpcIlxcdTI5QjNcIixcbiAgXCJSYW5nXCI6XCJcXHUyN0VCXCIsXG4gIFwicmFuZ1wiOlwiXFx1MjdFOVwiLFxuICBcInJhbmdkXCI6XCJcXHUyOTkyXCIsXG4gIFwicmFuZ2VcIjpcIlxcdTI5QTVcIixcbiAgXCJyYW5nbGVcIjpcIlxcdTI3RTlcIixcbiAgXCJyYXF1b1wiOlwiXFx1MDBCQlwiLFxuICBcIlJhcnJcIjpcIlxcdTIxQTBcIixcbiAgXCJyQXJyXCI6XCJcXHUyMUQyXCIsXG4gIFwicmFyclwiOlwiXFx1MjE5MlwiLFxuICBcInJhcnJhcFwiOlwiXFx1Mjk3NVwiLFxuICBcInJhcnJiXCI6XCJcXHUyMUU1XCIsXG4gIFwicmFycmJmc1wiOlwiXFx1MjkyMFwiLFxuICBcInJhcnJjXCI6XCJcXHUyOTMzXCIsXG4gIFwicmFycmZzXCI6XCJcXHUyOTFFXCIsXG4gIFwicmFycmhrXCI6XCJcXHUyMUFBXCIsXG4gIFwicmFycmxwXCI6XCJcXHUyMUFDXCIsXG4gIFwicmFycnBsXCI6XCJcXHUyOTQ1XCIsXG4gIFwicmFycnNpbVwiOlwiXFx1Mjk3NFwiLFxuICBcIlJhcnJ0bFwiOlwiXFx1MjkxNlwiLFxuICBcInJhcnJ0bFwiOlwiXFx1MjFBM1wiLFxuICBcInJhcnJ3XCI6XCJcXHUyMTlEXCIsXG4gIFwickF0YWlsXCI6XCJcXHUyOTFDXCIsXG4gIFwicmF0YWlsXCI6XCJcXHUyOTFBXCIsXG4gIFwicmF0aW9cIjpcIlxcdTIyMzZcIixcbiAgXCJyYXRpb25hbHNcIjpcIlxcdTIxMUFcIixcbiAgXCJSQmFyclwiOlwiXFx1MjkxMFwiLFxuICBcInJCYXJyXCI6XCJcXHUyOTBGXCIsXG4gIFwicmJhcnJcIjpcIlxcdTI5MERcIixcbiAgXCJyYmJya1wiOlwiXFx1Mjc3M1wiLFxuICBcInJicmFjZVwiOlwiXFx1MDA3RFwiLFxuICBcInJicmFja1wiOlwiXFx1MDA1RFwiLFxuICBcInJicmtlXCI6XCJcXHUyOThDXCIsXG4gIFwicmJya3NsZFwiOlwiXFx1Mjk4RVwiLFxuICBcInJicmtzbHVcIjpcIlxcdTI5OTBcIixcbiAgXCJSY2Fyb25cIjpcIlxcdTAxNThcIixcbiAgXCJyY2Fyb25cIjpcIlxcdTAxNTlcIixcbiAgXCJSY2VkaWxcIjpcIlxcdTAxNTZcIixcbiAgXCJyY2VkaWxcIjpcIlxcdTAxNTdcIixcbiAgXCJyY2VpbFwiOlwiXFx1MjMwOVwiLFxuICBcInJjdWJcIjpcIlxcdTAwN0RcIixcbiAgXCJSY3lcIjpcIlxcdTA0MjBcIixcbiAgXCJyY3lcIjpcIlxcdTA0NDBcIixcbiAgXCJyZGNhXCI6XCJcXHUyOTM3XCIsXG4gIFwicmRsZGhhclwiOlwiXFx1Mjk2OVwiLFxuICBcInJkcXVvXCI6XCJcXHUyMDFEXCIsXG4gIFwicmRxdW9yXCI6XCJcXHUyMDFEXCIsXG4gIFwicmRzaFwiOlwiXFx1MjFCM1wiLFxuICBcIlJlXCI6XCJcXHUyMTFDXCIsXG4gIFwicmVhbFwiOlwiXFx1MjExQ1wiLFxuICBcInJlYWxpbmVcIjpcIlxcdTIxMUJcIixcbiAgXCJyZWFscGFydFwiOlwiXFx1MjExQ1wiLFxuICBcInJlYWxzXCI6XCJcXHUyMTFEXCIsXG4gIFwicmVjdFwiOlwiXFx1MjVBRFwiLFxuICBcIlJFR1wiOlwiXFx1MDBBRVwiLFxuICBcInJlZ1wiOlwiXFx1MDBBRVwiLFxuICBcIlJldmVyc2VFbGVtZW50XCI6XCJcXHUyMjBCXCIsXG4gIFwiUmV2ZXJzZUVxdWlsaWJyaXVtXCI6XCJcXHUyMUNCXCIsXG4gIFwiUmV2ZXJzZVVwRXF1aWxpYnJpdW1cIjpcIlxcdTI5NkZcIixcbiAgXCJyZmlzaHRcIjpcIlxcdTI5N0RcIixcbiAgXCJyZmxvb3JcIjpcIlxcdTIzMEJcIixcbiAgXCJSZnJcIjpcIlxcdTIxMUNcIixcbiAgXCJyZnJcIjpcIlxcdUQ4MzVcXHVERDJGXCIsXG4gIFwickhhclwiOlwiXFx1Mjk2NFwiLFxuICBcInJoYXJkXCI6XCJcXHUyMUMxXCIsXG4gIFwicmhhcnVcIjpcIlxcdTIxQzBcIixcbiAgXCJyaGFydWxcIjpcIlxcdTI5NkNcIixcbiAgXCJSaG9cIjpcIlxcdTAzQTFcIixcbiAgXCJyaG9cIjpcIlxcdTAzQzFcIixcbiAgXCJyaG92XCI6XCJcXHUwM0YxXCIsXG4gIFwiUmlnaHRBbmdsZUJyYWNrZXRcIjpcIlxcdTI3RTlcIixcbiAgXCJSaWdodEFycm93XCI6XCJcXHUyMTkyXCIsXG4gIFwiUmlnaHRhcnJvd1wiOlwiXFx1MjFEMlwiLFxuICBcInJpZ2h0YXJyb3dcIjpcIlxcdTIxOTJcIixcbiAgXCJSaWdodEFycm93QmFyXCI6XCJcXHUyMUU1XCIsXG4gIFwiUmlnaHRBcnJvd0xlZnRBcnJvd1wiOlwiXFx1MjFDNFwiLFxuICBcInJpZ2h0YXJyb3d0YWlsXCI6XCJcXHUyMUEzXCIsXG4gIFwiUmlnaHRDZWlsaW5nXCI6XCJcXHUyMzA5XCIsXG4gIFwiUmlnaHREb3VibGVCcmFja2V0XCI6XCJcXHUyN0U3XCIsXG4gIFwiUmlnaHREb3duVGVlVmVjdG9yXCI6XCJcXHUyOTVEXCIsXG4gIFwiUmlnaHREb3duVmVjdG9yXCI6XCJcXHUyMUMyXCIsXG4gIFwiUmlnaHREb3duVmVjdG9yQmFyXCI6XCJcXHUyOTU1XCIsXG4gIFwiUmlnaHRGbG9vclwiOlwiXFx1MjMwQlwiLFxuICBcInJpZ2h0aGFycG9vbmRvd25cIjpcIlxcdTIxQzFcIixcbiAgXCJyaWdodGhhcnBvb251cFwiOlwiXFx1MjFDMFwiLFxuICBcInJpZ2h0bGVmdGFycm93c1wiOlwiXFx1MjFDNFwiLFxuICBcInJpZ2h0bGVmdGhhcnBvb25zXCI6XCJcXHUyMUNDXCIsXG4gIFwicmlnaHRyaWdodGFycm93c1wiOlwiXFx1MjFDOVwiLFxuICBcInJpZ2h0c3F1aWdhcnJvd1wiOlwiXFx1MjE5RFwiLFxuICBcIlJpZ2h0VGVlXCI6XCJcXHUyMkEyXCIsXG4gIFwiUmlnaHRUZWVBcnJvd1wiOlwiXFx1MjFBNlwiLFxuICBcIlJpZ2h0VGVlVmVjdG9yXCI6XCJcXHUyOTVCXCIsXG4gIFwicmlnaHR0aHJlZXRpbWVzXCI6XCJcXHUyMkNDXCIsXG4gIFwiUmlnaHRUcmlhbmdsZVwiOlwiXFx1MjJCM1wiLFxuICBcIlJpZ2h0VHJpYW5nbGVCYXJcIjpcIlxcdTI5RDBcIixcbiAgXCJSaWdodFRyaWFuZ2xlRXF1YWxcIjpcIlxcdTIyQjVcIixcbiAgXCJSaWdodFVwRG93blZlY3RvclwiOlwiXFx1Mjk0RlwiLFxuICBcIlJpZ2h0VXBUZWVWZWN0b3JcIjpcIlxcdTI5NUNcIixcbiAgXCJSaWdodFVwVmVjdG9yXCI6XCJcXHUyMUJFXCIsXG4gIFwiUmlnaHRVcFZlY3RvckJhclwiOlwiXFx1Mjk1NFwiLFxuICBcIlJpZ2h0VmVjdG9yXCI6XCJcXHUyMUMwXCIsXG4gIFwiUmlnaHRWZWN0b3JCYXJcIjpcIlxcdTI5NTNcIixcbiAgXCJyaW5nXCI6XCJcXHUwMkRBXCIsXG4gIFwicmlzaW5nZG90c2VxXCI6XCJcXHUyMjUzXCIsXG4gIFwicmxhcnJcIjpcIlxcdTIxQzRcIixcbiAgXCJybGhhclwiOlwiXFx1MjFDQ1wiLFxuICBcInJsbVwiOlwiXFx1MjAwRlwiLFxuICBcInJtb3VzdFwiOlwiXFx1MjNCMVwiLFxuICBcInJtb3VzdGFjaGVcIjpcIlxcdTIzQjFcIixcbiAgXCJybm1pZFwiOlwiXFx1MkFFRVwiLFxuICBcInJvYW5nXCI6XCJcXHUyN0VEXCIsXG4gIFwicm9hcnJcIjpcIlxcdTIxRkVcIixcbiAgXCJyb2Jya1wiOlwiXFx1MjdFN1wiLFxuICBcInJvcGFyXCI6XCJcXHUyOTg2XCIsXG4gIFwiUm9wZlwiOlwiXFx1MjExRFwiLFxuICBcInJvcGZcIjpcIlxcdUQ4MzVcXHVERDYzXCIsXG4gIFwicm9wbHVzXCI6XCJcXHUyQTJFXCIsXG4gIFwicm90aW1lc1wiOlwiXFx1MkEzNVwiLFxuICBcIlJvdW5kSW1wbGllc1wiOlwiXFx1Mjk3MFwiLFxuICBcInJwYXJcIjpcIlxcdTAwMjlcIixcbiAgXCJycGFyZ3RcIjpcIlxcdTI5OTRcIixcbiAgXCJycHBvbGludFwiOlwiXFx1MkExMlwiLFxuICBcInJyYXJyXCI6XCJcXHUyMUM5XCIsXG4gIFwiUnJpZ2h0YXJyb3dcIjpcIlxcdTIxREJcIixcbiAgXCJyc2FxdW9cIjpcIlxcdTIwM0FcIixcbiAgXCJSc2NyXCI6XCJcXHUyMTFCXCIsXG4gIFwicnNjclwiOlwiXFx1RDgzNVxcdURDQzdcIixcbiAgXCJSc2hcIjpcIlxcdTIxQjFcIixcbiAgXCJyc2hcIjpcIlxcdTIxQjFcIixcbiAgXCJyc3FiXCI6XCJcXHUwMDVEXCIsXG4gIFwicnNxdW9cIjpcIlxcdTIwMTlcIixcbiAgXCJyc3F1b3JcIjpcIlxcdTIwMTlcIixcbiAgXCJydGhyZWVcIjpcIlxcdTIyQ0NcIixcbiAgXCJydGltZXNcIjpcIlxcdTIyQ0FcIixcbiAgXCJydHJpXCI6XCJcXHUyNUI5XCIsXG4gIFwicnRyaWVcIjpcIlxcdTIyQjVcIixcbiAgXCJydHJpZlwiOlwiXFx1MjVCOFwiLFxuICBcInJ0cmlsdHJpXCI6XCJcXHUyOUNFXCIsXG4gIFwiUnVsZURlbGF5ZWRcIjpcIlxcdTI5RjRcIixcbiAgXCJydWx1aGFyXCI6XCJcXHUyOTY4XCIsXG4gIFwicnhcIjpcIlxcdTIxMUVcIixcbiAgXCJTYWN1dGVcIjpcIlxcdTAxNUFcIixcbiAgXCJzYWN1dGVcIjpcIlxcdTAxNUJcIixcbiAgXCJzYnF1b1wiOlwiXFx1MjAxQVwiLFxuICBcIlNjXCI6XCJcXHUyQUJDXCIsXG4gIFwic2NcIjpcIlxcdTIyN0JcIixcbiAgXCJzY2FwXCI6XCJcXHUyQUI4XCIsXG4gIFwiU2Nhcm9uXCI6XCJcXHUwMTYwXCIsXG4gIFwic2Nhcm9uXCI6XCJcXHUwMTYxXCIsXG4gIFwic2NjdWVcIjpcIlxcdTIyN0RcIixcbiAgXCJzY0VcIjpcIlxcdTJBQjRcIixcbiAgXCJzY2VcIjpcIlxcdTJBQjBcIixcbiAgXCJTY2VkaWxcIjpcIlxcdTAxNUVcIixcbiAgXCJzY2VkaWxcIjpcIlxcdTAxNUZcIixcbiAgXCJTY2lyY1wiOlwiXFx1MDE1Q1wiLFxuICBcInNjaXJjXCI6XCJcXHUwMTVEXCIsXG4gIFwic2NuYXBcIjpcIlxcdTJBQkFcIixcbiAgXCJzY25FXCI6XCJcXHUyQUI2XCIsXG4gIFwic2Nuc2ltXCI6XCJcXHUyMkU5XCIsXG4gIFwic2Nwb2xpbnRcIjpcIlxcdTJBMTNcIixcbiAgXCJzY3NpbVwiOlwiXFx1MjI3RlwiLFxuICBcIlNjeVwiOlwiXFx1MDQyMVwiLFxuICBcInNjeVwiOlwiXFx1MDQ0MVwiLFxuICBcInNkb3RcIjpcIlxcdTIyQzVcIixcbiAgXCJzZG90YlwiOlwiXFx1MjJBMVwiLFxuICBcInNkb3RlXCI6XCJcXHUyQTY2XCIsXG4gIFwic2VhcmhrXCI6XCJcXHUyOTI1XCIsXG4gIFwic2VBcnJcIjpcIlxcdTIxRDhcIixcbiAgXCJzZWFyclwiOlwiXFx1MjE5OFwiLFxuICBcInNlYXJyb3dcIjpcIlxcdTIxOThcIixcbiAgXCJzZWN0XCI6XCJcXHUwMEE3XCIsXG4gIFwic2VtaVwiOlwiXFx1MDAzQlwiLFxuICBcInNlc3dhclwiOlwiXFx1MjkyOVwiLFxuICBcInNldG1pbnVzXCI6XCJcXHUyMjE2XCIsXG4gIFwic2V0bW5cIjpcIlxcdTIyMTZcIixcbiAgXCJzZXh0XCI6XCJcXHUyNzM2XCIsXG4gIFwiU2ZyXCI6XCJcXHVEODM1XFx1REQxNlwiLFxuICBcInNmclwiOlwiXFx1RDgzNVxcdUREMzBcIixcbiAgXCJzZnJvd25cIjpcIlxcdTIzMjJcIixcbiAgXCJzaGFycFwiOlwiXFx1MjY2RlwiLFxuICBcIlNIQ0hjeVwiOlwiXFx1MDQyOVwiLFxuICBcInNoY2hjeVwiOlwiXFx1MDQ0OVwiLFxuICBcIlNIY3lcIjpcIlxcdTA0MjhcIixcbiAgXCJzaGN5XCI6XCJcXHUwNDQ4XCIsXG4gIFwiU2hvcnREb3duQXJyb3dcIjpcIlxcdTIxOTNcIixcbiAgXCJTaG9ydExlZnRBcnJvd1wiOlwiXFx1MjE5MFwiLFxuICBcInNob3J0bWlkXCI6XCJcXHUyMjIzXCIsXG4gIFwic2hvcnRwYXJhbGxlbFwiOlwiXFx1MjIyNVwiLFxuICBcIlNob3J0UmlnaHRBcnJvd1wiOlwiXFx1MjE5MlwiLFxuICBcIlNob3J0VXBBcnJvd1wiOlwiXFx1MjE5MVwiLFxuICBcInNoeVwiOlwiXFx1MDBBRFwiLFxuICBcIlNpZ21hXCI6XCJcXHUwM0EzXCIsXG4gIFwic2lnbWFcIjpcIlxcdTAzQzNcIixcbiAgXCJzaWdtYWZcIjpcIlxcdTAzQzJcIixcbiAgXCJzaWdtYXZcIjpcIlxcdTAzQzJcIixcbiAgXCJzaW1cIjpcIlxcdTIyM0NcIixcbiAgXCJzaW1kb3RcIjpcIlxcdTJBNkFcIixcbiAgXCJzaW1lXCI6XCJcXHUyMjQzXCIsXG4gIFwic2ltZXFcIjpcIlxcdTIyNDNcIixcbiAgXCJzaW1nXCI6XCJcXHUyQTlFXCIsXG4gIFwic2ltZ0VcIjpcIlxcdTJBQTBcIixcbiAgXCJzaW1sXCI6XCJcXHUyQTlEXCIsXG4gIFwic2ltbEVcIjpcIlxcdTJBOUZcIixcbiAgXCJzaW1uZVwiOlwiXFx1MjI0NlwiLFxuICBcInNpbXBsdXNcIjpcIlxcdTJBMjRcIixcbiAgXCJzaW1yYXJyXCI6XCJcXHUyOTcyXCIsXG4gIFwic2xhcnJcIjpcIlxcdTIxOTBcIixcbiAgXCJTbWFsbENpcmNsZVwiOlwiXFx1MjIxOFwiLFxuICBcInNtYWxsc2V0bWludXNcIjpcIlxcdTIyMTZcIixcbiAgXCJzbWFzaHBcIjpcIlxcdTJBMzNcIixcbiAgXCJzbWVwYXJzbFwiOlwiXFx1MjlFNFwiLFxuICBcInNtaWRcIjpcIlxcdTIyMjNcIixcbiAgXCJzbWlsZVwiOlwiXFx1MjMyM1wiLFxuICBcInNtdFwiOlwiXFx1MkFBQVwiLFxuICBcInNtdGVcIjpcIlxcdTJBQUNcIixcbiAgXCJzbXRlc1wiOlwiXFx1MkFBQ1xcdUZFMDBcIixcbiAgXCJTT0ZUY3lcIjpcIlxcdTA0MkNcIixcbiAgXCJzb2Z0Y3lcIjpcIlxcdTA0NENcIixcbiAgXCJzb2xcIjpcIlxcdTAwMkZcIixcbiAgXCJzb2xiXCI6XCJcXHUyOUM0XCIsXG4gIFwic29sYmFyXCI6XCJcXHUyMzNGXCIsXG4gIFwiU29wZlwiOlwiXFx1RDgzNVxcdURENEFcIixcbiAgXCJzb3BmXCI6XCJcXHVEODM1XFx1REQ2NFwiLFxuICBcInNwYWRlc1wiOlwiXFx1MjY2MFwiLFxuICBcInNwYWRlc3VpdFwiOlwiXFx1MjY2MFwiLFxuICBcInNwYXJcIjpcIlxcdTIyMjVcIixcbiAgXCJzcWNhcFwiOlwiXFx1MjI5M1wiLFxuICBcInNxY2Fwc1wiOlwiXFx1MjI5M1xcdUZFMDBcIixcbiAgXCJzcWN1cFwiOlwiXFx1MjI5NFwiLFxuICBcInNxY3Vwc1wiOlwiXFx1MjI5NFxcdUZFMDBcIixcbiAgXCJTcXJ0XCI6XCJcXHUyMjFBXCIsXG4gIFwic3FzdWJcIjpcIlxcdTIyOEZcIixcbiAgXCJzcXN1YmVcIjpcIlxcdTIyOTFcIixcbiAgXCJzcXN1YnNldFwiOlwiXFx1MjI4RlwiLFxuICBcInNxc3Vic2V0ZXFcIjpcIlxcdTIyOTFcIixcbiAgXCJzcXN1cFwiOlwiXFx1MjI5MFwiLFxuICBcInNxc3VwZVwiOlwiXFx1MjI5MlwiLFxuICBcInNxc3Vwc2V0XCI6XCJcXHUyMjkwXCIsXG4gIFwic3FzdXBzZXRlcVwiOlwiXFx1MjI5MlwiLFxuICBcInNxdVwiOlwiXFx1MjVBMVwiLFxuICBcIlNxdWFyZVwiOlwiXFx1MjVBMVwiLFxuICBcInNxdWFyZVwiOlwiXFx1MjVBMVwiLFxuICBcIlNxdWFyZUludGVyc2VjdGlvblwiOlwiXFx1MjI5M1wiLFxuICBcIlNxdWFyZVN1YnNldFwiOlwiXFx1MjI4RlwiLFxuICBcIlNxdWFyZVN1YnNldEVxdWFsXCI6XCJcXHUyMjkxXCIsXG4gIFwiU3F1YXJlU3VwZXJzZXRcIjpcIlxcdTIyOTBcIixcbiAgXCJTcXVhcmVTdXBlcnNldEVxdWFsXCI6XCJcXHUyMjkyXCIsXG4gIFwiU3F1YXJlVW5pb25cIjpcIlxcdTIyOTRcIixcbiAgXCJzcXVhcmZcIjpcIlxcdTI1QUFcIixcbiAgXCJzcXVmXCI6XCJcXHUyNUFBXCIsXG4gIFwic3JhcnJcIjpcIlxcdTIxOTJcIixcbiAgXCJTc2NyXCI6XCJcXHVEODM1XFx1RENBRVwiLFxuICBcInNzY3JcIjpcIlxcdUQ4MzVcXHVEQ0M4XCIsXG4gIFwic3NldG1uXCI6XCJcXHUyMjE2XCIsXG4gIFwic3NtaWxlXCI6XCJcXHUyMzIzXCIsXG4gIFwic3N0YXJmXCI6XCJcXHUyMkM2XCIsXG4gIFwiU3RhclwiOlwiXFx1MjJDNlwiLFxuICBcInN0YXJcIjpcIlxcdTI2MDZcIixcbiAgXCJzdGFyZlwiOlwiXFx1MjYwNVwiLFxuICBcInN0cmFpZ2h0ZXBzaWxvblwiOlwiXFx1MDNGNVwiLFxuICBcInN0cmFpZ2h0cGhpXCI6XCJcXHUwM0Q1XCIsXG4gIFwic3RybnNcIjpcIlxcdTAwQUZcIixcbiAgXCJTdWJcIjpcIlxcdTIyRDBcIixcbiAgXCJzdWJcIjpcIlxcdTIyODJcIixcbiAgXCJzdWJkb3RcIjpcIlxcdTJBQkRcIixcbiAgXCJzdWJFXCI6XCJcXHUyQUM1XCIsXG4gIFwic3ViZVwiOlwiXFx1MjI4NlwiLFxuICBcInN1YmVkb3RcIjpcIlxcdTJBQzNcIixcbiAgXCJzdWJtdWx0XCI6XCJcXHUyQUMxXCIsXG4gIFwic3VibkVcIjpcIlxcdTJBQ0JcIixcbiAgXCJzdWJuZVwiOlwiXFx1MjI4QVwiLFxuICBcInN1YnBsdXNcIjpcIlxcdTJBQkZcIixcbiAgXCJzdWJyYXJyXCI6XCJcXHUyOTc5XCIsXG4gIFwiU3Vic2V0XCI6XCJcXHUyMkQwXCIsXG4gIFwic3Vic2V0XCI6XCJcXHUyMjgyXCIsXG4gIFwic3Vic2V0ZXFcIjpcIlxcdTIyODZcIixcbiAgXCJzdWJzZXRlcXFcIjpcIlxcdTJBQzVcIixcbiAgXCJTdWJzZXRFcXVhbFwiOlwiXFx1MjI4NlwiLFxuICBcInN1YnNldG5lcVwiOlwiXFx1MjI4QVwiLFxuICBcInN1YnNldG5lcXFcIjpcIlxcdTJBQ0JcIixcbiAgXCJzdWJzaW1cIjpcIlxcdTJBQzdcIixcbiAgXCJzdWJzdWJcIjpcIlxcdTJBRDVcIixcbiAgXCJzdWJzdXBcIjpcIlxcdTJBRDNcIixcbiAgXCJzdWNjXCI6XCJcXHUyMjdCXCIsXG4gIFwic3VjY2FwcHJveFwiOlwiXFx1MkFCOFwiLFxuICBcInN1Y2NjdXJseWVxXCI6XCJcXHUyMjdEXCIsXG4gIFwiU3VjY2VlZHNcIjpcIlxcdTIyN0JcIixcbiAgXCJTdWNjZWVkc0VxdWFsXCI6XCJcXHUyQUIwXCIsXG4gIFwiU3VjY2VlZHNTbGFudEVxdWFsXCI6XCJcXHUyMjdEXCIsXG4gIFwiU3VjY2VlZHNUaWxkZVwiOlwiXFx1MjI3RlwiLFxuICBcInN1Y2NlcVwiOlwiXFx1MkFCMFwiLFxuICBcInN1Y2NuYXBwcm94XCI6XCJcXHUyQUJBXCIsXG4gIFwic3VjY25lcXFcIjpcIlxcdTJBQjZcIixcbiAgXCJzdWNjbnNpbVwiOlwiXFx1MjJFOVwiLFxuICBcInN1Y2NzaW1cIjpcIlxcdTIyN0ZcIixcbiAgXCJTdWNoVGhhdFwiOlwiXFx1MjIwQlwiLFxuICBcIlN1bVwiOlwiXFx1MjIxMVwiLFxuICBcInN1bVwiOlwiXFx1MjIxMVwiLFxuICBcInN1bmdcIjpcIlxcdTI2NkFcIixcbiAgXCJTdXBcIjpcIlxcdTIyRDFcIixcbiAgXCJzdXBcIjpcIlxcdTIyODNcIixcbiAgXCJzdXAxXCI6XCJcXHUwMEI5XCIsXG4gIFwic3VwMlwiOlwiXFx1MDBCMlwiLFxuICBcInN1cDNcIjpcIlxcdTAwQjNcIixcbiAgXCJzdXBkb3RcIjpcIlxcdTJBQkVcIixcbiAgXCJzdXBkc3ViXCI6XCJcXHUyQUQ4XCIsXG4gIFwic3VwRVwiOlwiXFx1MkFDNlwiLFxuICBcInN1cGVcIjpcIlxcdTIyODdcIixcbiAgXCJzdXBlZG90XCI6XCJcXHUyQUM0XCIsXG4gIFwiU3VwZXJzZXRcIjpcIlxcdTIyODNcIixcbiAgXCJTdXBlcnNldEVxdWFsXCI6XCJcXHUyMjg3XCIsXG4gIFwic3VwaHNvbFwiOlwiXFx1MjdDOVwiLFxuICBcInN1cGhzdWJcIjpcIlxcdTJBRDdcIixcbiAgXCJzdXBsYXJyXCI6XCJcXHUyOTdCXCIsXG4gIFwic3VwbXVsdFwiOlwiXFx1MkFDMlwiLFxuICBcInN1cG5FXCI6XCJcXHUyQUNDXCIsXG4gIFwic3VwbmVcIjpcIlxcdTIyOEJcIixcbiAgXCJzdXBwbHVzXCI6XCJcXHUyQUMwXCIsXG4gIFwiU3Vwc2V0XCI6XCJcXHUyMkQxXCIsXG4gIFwic3Vwc2V0XCI6XCJcXHUyMjgzXCIsXG4gIFwic3Vwc2V0ZXFcIjpcIlxcdTIyODdcIixcbiAgXCJzdXBzZXRlcXFcIjpcIlxcdTJBQzZcIixcbiAgXCJzdXBzZXRuZXFcIjpcIlxcdTIyOEJcIixcbiAgXCJzdXBzZXRuZXFxXCI6XCJcXHUyQUNDXCIsXG4gIFwic3Vwc2ltXCI6XCJcXHUyQUM4XCIsXG4gIFwic3Vwc3ViXCI6XCJcXHUyQUQ0XCIsXG4gIFwic3Vwc3VwXCI6XCJcXHUyQUQ2XCIsXG4gIFwic3dhcmhrXCI6XCJcXHUyOTI2XCIsXG4gIFwic3dBcnJcIjpcIlxcdTIxRDlcIixcbiAgXCJzd2FyclwiOlwiXFx1MjE5OVwiLFxuICBcInN3YXJyb3dcIjpcIlxcdTIxOTlcIixcbiAgXCJzd253YXJcIjpcIlxcdTI5MkFcIixcbiAgXCJzemxpZ1wiOlwiXFx1MDBERlwiLFxuICBcIlRhYlwiOlwiXFx1MDAwOVwiLFxuICBcInRhcmdldFwiOlwiXFx1MjMxNlwiLFxuICBcIlRhdVwiOlwiXFx1MDNBNFwiLFxuICBcInRhdVwiOlwiXFx1MDNDNFwiLFxuICBcInRicmtcIjpcIlxcdTIzQjRcIixcbiAgXCJUY2Fyb25cIjpcIlxcdTAxNjRcIixcbiAgXCJ0Y2Fyb25cIjpcIlxcdTAxNjVcIixcbiAgXCJUY2VkaWxcIjpcIlxcdTAxNjJcIixcbiAgXCJ0Y2VkaWxcIjpcIlxcdTAxNjNcIixcbiAgXCJUY3lcIjpcIlxcdTA0MjJcIixcbiAgXCJ0Y3lcIjpcIlxcdTA0NDJcIixcbiAgXCJ0ZG90XCI6XCJcXHUyMERCXCIsXG4gIFwidGVscmVjXCI6XCJcXHUyMzE1XCIsXG4gIFwiVGZyXCI6XCJcXHVEODM1XFx1REQxN1wiLFxuICBcInRmclwiOlwiXFx1RDgzNVxcdUREMzFcIixcbiAgXCJ0aGVyZTRcIjpcIlxcdTIyMzRcIixcbiAgXCJUaGVyZWZvcmVcIjpcIlxcdTIyMzRcIixcbiAgXCJ0aGVyZWZvcmVcIjpcIlxcdTIyMzRcIixcbiAgXCJUaGV0YVwiOlwiXFx1MDM5OFwiLFxuICBcInRoZXRhXCI6XCJcXHUwM0I4XCIsXG4gIFwidGhldGFzeW1cIjpcIlxcdTAzRDFcIixcbiAgXCJ0aGV0YXZcIjpcIlxcdTAzRDFcIixcbiAgXCJ0aGlja2FwcHJveFwiOlwiXFx1MjI0OFwiLFxuICBcInRoaWNrc2ltXCI6XCJcXHUyMjNDXCIsXG4gIFwiVGhpY2tTcGFjZVwiOlwiXFx1MjA1RlxcdTIwMEFcIixcbiAgXCJ0aGluc3BcIjpcIlxcdTIwMDlcIixcbiAgXCJUaGluU3BhY2VcIjpcIlxcdTIwMDlcIixcbiAgXCJ0aGthcFwiOlwiXFx1MjI0OFwiLFxuICBcInRoa3NpbVwiOlwiXFx1MjIzQ1wiLFxuICBcIlRIT1JOXCI6XCJcXHUwMERFXCIsXG4gIFwidGhvcm5cIjpcIlxcdTAwRkVcIixcbiAgXCJUaWxkZVwiOlwiXFx1MjIzQ1wiLFxuICBcInRpbGRlXCI6XCJcXHUwMkRDXCIsXG4gIFwiVGlsZGVFcXVhbFwiOlwiXFx1MjI0M1wiLFxuICBcIlRpbGRlRnVsbEVxdWFsXCI6XCJcXHUyMjQ1XCIsXG4gIFwiVGlsZGVUaWxkZVwiOlwiXFx1MjI0OFwiLFxuICBcInRpbWVzXCI6XCJcXHUwMEQ3XCIsXG4gIFwidGltZXNiXCI6XCJcXHUyMkEwXCIsXG4gIFwidGltZXNiYXJcIjpcIlxcdTJBMzFcIixcbiAgXCJ0aW1lc2RcIjpcIlxcdTJBMzBcIixcbiAgXCJ0aW50XCI6XCJcXHUyMjJEXCIsXG4gIFwidG9lYVwiOlwiXFx1MjkyOFwiLFxuICBcInRvcFwiOlwiXFx1MjJBNFwiLFxuICBcInRvcGJvdFwiOlwiXFx1MjMzNlwiLFxuICBcInRvcGNpclwiOlwiXFx1MkFGMVwiLFxuICBcIlRvcGZcIjpcIlxcdUQ4MzVcXHVERDRCXCIsXG4gIFwidG9wZlwiOlwiXFx1RDgzNVxcdURENjVcIixcbiAgXCJ0b3Bmb3JrXCI6XCJcXHUyQURBXCIsXG4gIFwidG9zYVwiOlwiXFx1MjkyOVwiLFxuICBcInRwcmltZVwiOlwiXFx1MjAzNFwiLFxuICBcIlRSQURFXCI6XCJcXHUyMTIyXCIsXG4gIFwidHJhZGVcIjpcIlxcdTIxMjJcIixcbiAgXCJ0cmlhbmdsZVwiOlwiXFx1MjVCNVwiLFxuICBcInRyaWFuZ2xlZG93blwiOlwiXFx1MjVCRlwiLFxuICBcInRyaWFuZ2xlbGVmdFwiOlwiXFx1MjVDM1wiLFxuICBcInRyaWFuZ2xlbGVmdGVxXCI6XCJcXHUyMkI0XCIsXG4gIFwidHJpYW5nbGVxXCI6XCJcXHUyMjVDXCIsXG4gIFwidHJpYW5nbGVyaWdodFwiOlwiXFx1MjVCOVwiLFxuICBcInRyaWFuZ2xlcmlnaHRlcVwiOlwiXFx1MjJCNVwiLFxuICBcInRyaWRvdFwiOlwiXFx1MjVFQ1wiLFxuICBcInRyaWVcIjpcIlxcdTIyNUNcIixcbiAgXCJ0cmltaW51c1wiOlwiXFx1MkEzQVwiLFxuICBcIlRyaXBsZURvdFwiOlwiXFx1MjBEQlwiLFxuICBcInRyaXBsdXNcIjpcIlxcdTJBMzlcIixcbiAgXCJ0cmlzYlwiOlwiXFx1MjlDRFwiLFxuICBcInRyaXRpbWVcIjpcIlxcdTJBM0JcIixcbiAgXCJ0cnBleml1bVwiOlwiXFx1MjNFMlwiLFxuICBcIlRzY3JcIjpcIlxcdUQ4MzVcXHVEQ0FGXCIsXG4gIFwidHNjclwiOlwiXFx1RDgzNVxcdURDQzlcIixcbiAgXCJUU2N5XCI6XCJcXHUwNDI2XCIsXG4gIFwidHNjeVwiOlwiXFx1MDQ0NlwiLFxuICBcIlRTSGN5XCI6XCJcXHUwNDBCXCIsXG4gIFwidHNoY3lcIjpcIlxcdTA0NUJcIixcbiAgXCJUc3Ryb2tcIjpcIlxcdTAxNjZcIixcbiAgXCJ0c3Ryb2tcIjpcIlxcdTAxNjdcIixcbiAgXCJ0d2l4dFwiOlwiXFx1MjI2Q1wiLFxuICBcInR3b2hlYWRsZWZ0YXJyb3dcIjpcIlxcdTIxOUVcIixcbiAgXCJ0d29oZWFkcmlnaHRhcnJvd1wiOlwiXFx1MjFBMFwiLFxuICBcIlVhY3V0ZVwiOlwiXFx1MDBEQVwiLFxuICBcInVhY3V0ZVwiOlwiXFx1MDBGQVwiLFxuICBcIlVhcnJcIjpcIlxcdTIxOUZcIixcbiAgXCJ1QXJyXCI6XCJcXHUyMUQxXCIsXG4gIFwidWFyclwiOlwiXFx1MjE5MVwiLFxuICBcIlVhcnJvY2lyXCI6XCJcXHUyOTQ5XCIsXG4gIFwiVWJyY3lcIjpcIlxcdTA0MEVcIixcbiAgXCJ1YnJjeVwiOlwiXFx1MDQ1RVwiLFxuICBcIlVicmV2ZVwiOlwiXFx1MDE2Q1wiLFxuICBcInVicmV2ZVwiOlwiXFx1MDE2RFwiLFxuICBcIlVjaXJjXCI6XCJcXHUwMERCXCIsXG4gIFwidWNpcmNcIjpcIlxcdTAwRkJcIixcbiAgXCJVY3lcIjpcIlxcdTA0MjNcIixcbiAgXCJ1Y3lcIjpcIlxcdTA0NDNcIixcbiAgXCJ1ZGFyclwiOlwiXFx1MjFDNVwiLFxuICBcIlVkYmxhY1wiOlwiXFx1MDE3MFwiLFxuICBcInVkYmxhY1wiOlwiXFx1MDE3MVwiLFxuICBcInVkaGFyXCI6XCJcXHUyOTZFXCIsXG4gIFwidWZpc2h0XCI6XCJcXHUyOTdFXCIsXG4gIFwiVWZyXCI6XCJcXHVEODM1XFx1REQxOFwiLFxuICBcInVmclwiOlwiXFx1RDgzNVxcdUREMzJcIixcbiAgXCJVZ3JhdmVcIjpcIlxcdTAwRDlcIixcbiAgXCJ1Z3JhdmVcIjpcIlxcdTAwRjlcIixcbiAgXCJ1SGFyXCI6XCJcXHUyOTYzXCIsXG4gIFwidWhhcmxcIjpcIlxcdTIxQkZcIixcbiAgXCJ1aGFyclwiOlwiXFx1MjFCRVwiLFxuICBcInVoYmxrXCI6XCJcXHUyNTgwXCIsXG4gIFwidWxjb3JuXCI6XCJcXHUyMzFDXCIsXG4gIFwidWxjb3JuZXJcIjpcIlxcdTIzMUNcIixcbiAgXCJ1bGNyb3BcIjpcIlxcdTIzMEZcIixcbiAgXCJ1bHRyaVwiOlwiXFx1MjVGOFwiLFxuICBcIlVtYWNyXCI6XCJcXHUwMTZBXCIsXG4gIFwidW1hY3JcIjpcIlxcdTAxNkJcIixcbiAgXCJ1bWxcIjpcIlxcdTAwQThcIixcbiAgXCJVbmRlckJhclwiOlwiXFx1MDA1RlwiLFxuICBcIlVuZGVyQnJhY2VcIjpcIlxcdTIzREZcIixcbiAgXCJVbmRlckJyYWNrZXRcIjpcIlxcdTIzQjVcIixcbiAgXCJVbmRlclBhcmVudGhlc2lzXCI6XCJcXHUyM0REXCIsXG4gIFwiVW5pb25cIjpcIlxcdTIyQzNcIixcbiAgXCJVbmlvblBsdXNcIjpcIlxcdTIyOEVcIixcbiAgXCJVb2dvblwiOlwiXFx1MDE3MlwiLFxuICBcInVvZ29uXCI6XCJcXHUwMTczXCIsXG4gIFwiVW9wZlwiOlwiXFx1RDgzNVxcdURENENcIixcbiAgXCJ1b3BmXCI6XCJcXHVEODM1XFx1REQ2NlwiLFxuICBcIlVwQXJyb3dcIjpcIlxcdTIxOTFcIixcbiAgXCJVcGFycm93XCI6XCJcXHUyMUQxXCIsXG4gIFwidXBhcnJvd1wiOlwiXFx1MjE5MVwiLFxuICBcIlVwQXJyb3dCYXJcIjpcIlxcdTI5MTJcIixcbiAgXCJVcEFycm93RG93bkFycm93XCI6XCJcXHUyMUM1XCIsXG4gIFwiVXBEb3duQXJyb3dcIjpcIlxcdTIxOTVcIixcbiAgXCJVcGRvd25hcnJvd1wiOlwiXFx1MjFENVwiLFxuICBcInVwZG93bmFycm93XCI6XCJcXHUyMTk1XCIsXG4gIFwiVXBFcXVpbGlicml1bVwiOlwiXFx1Mjk2RVwiLFxuICBcInVwaGFycG9vbmxlZnRcIjpcIlxcdTIxQkZcIixcbiAgXCJ1cGhhcnBvb25yaWdodFwiOlwiXFx1MjFCRVwiLFxuICBcInVwbHVzXCI6XCJcXHUyMjhFXCIsXG4gIFwiVXBwZXJMZWZ0QXJyb3dcIjpcIlxcdTIxOTZcIixcbiAgXCJVcHBlclJpZ2h0QXJyb3dcIjpcIlxcdTIxOTdcIixcbiAgXCJVcHNpXCI6XCJcXHUwM0QyXCIsXG4gIFwidXBzaVwiOlwiXFx1MDNDNVwiLFxuICBcInVwc2loXCI6XCJcXHUwM0QyXCIsXG4gIFwiVXBzaWxvblwiOlwiXFx1MDNBNVwiLFxuICBcInVwc2lsb25cIjpcIlxcdTAzQzVcIixcbiAgXCJVcFRlZVwiOlwiXFx1MjJBNVwiLFxuICBcIlVwVGVlQXJyb3dcIjpcIlxcdTIxQTVcIixcbiAgXCJ1cHVwYXJyb3dzXCI6XCJcXHUyMUM4XCIsXG4gIFwidXJjb3JuXCI6XCJcXHUyMzFEXCIsXG4gIFwidXJjb3JuZXJcIjpcIlxcdTIzMURcIixcbiAgXCJ1cmNyb3BcIjpcIlxcdTIzMEVcIixcbiAgXCJVcmluZ1wiOlwiXFx1MDE2RVwiLFxuICBcInVyaW5nXCI6XCJcXHUwMTZGXCIsXG4gIFwidXJ0cmlcIjpcIlxcdTI1RjlcIixcbiAgXCJVc2NyXCI6XCJcXHVEODM1XFx1RENCMFwiLFxuICBcInVzY3JcIjpcIlxcdUQ4MzVcXHVEQ0NBXCIsXG4gIFwidXRkb3RcIjpcIlxcdTIyRjBcIixcbiAgXCJVdGlsZGVcIjpcIlxcdTAxNjhcIixcbiAgXCJ1dGlsZGVcIjpcIlxcdTAxNjlcIixcbiAgXCJ1dHJpXCI6XCJcXHUyNUI1XCIsXG4gIFwidXRyaWZcIjpcIlxcdTI1QjRcIixcbiAgXCJ1dWFyclwiOlwiXFx1MjFDOFwiLFxuICBcIlV1bWxcIjpcIlxcdTAwRENcIixcbiAgXCJ1dW1sXCI6XCJcXHUwMEZDXCIsXG4gIFwidXdhbmdsZVwiOlwiXFx1MjlBN1wiLFxuICBcInZhbmdydFwiOlwiXFx1Mjk5Q1wiLFxuICBcInZhcmVwc2lsb25cIjpcIlxcdTAzRjVcIixcbiAgXCJ2YXJrYXBwYVwiOlwiXFx1MDNGMFwiLFxuICBcInZhcm5vdGhpbmdcIjpcIlxcdTIyMDVcIixcbiAgXCJ2YXJwaGlcIjpcIlxcdTAzRDVcIixcbiAgXCJ2YXJwaVwiOlwiXFx1MDNENlwiLFxuICBcInZhcnByb3B0b1wiOlwiXFx1MjIxRFwiLFxuICBcInZBcnJcIjpcIlxcdTIxRDVcIixcbiAgXCJ2YXJyXCI6XCJcXHUyMTk1XCIsXG4gIFwidmFycmhvXCI6XCJcXHUwM0YxXCIsXG4gIFwidmFyc2lnbWFcIjpcIlxcdTAzQzJcIixcbiAgXCJ2YXJzdWJzZXRuZXFcIjpcIlxcdTIyOEFcXHVGRTAwXCIsXG4gIFwidmFyc3Vic2V0bmVxcVwiOlwiXFx1MkFDQlxcdUZFMDBcIixcbiAgXCJ2YXJzdXBzZXRuZXFcIjpcIlxcdTIyOEJcXHVGRTAwXCIsXG4gIFwidmFyc3Vwc2V0bmVxcVwiOlwiXFx1MkFDQ1xcdUZFMDBcIixcbiAgXCJ2YXJ0aGV0YVwiOlwiXFx1MDNEMVwiLFxuICBcInZhcnRyaWFuZ2xlbGVmdFwiOlwiXFx1MjJCMlwiLFxuICBcInZhcnRyaWFuZ2xlcmlnaHRcIjpcIlxcdTIyQjNcIixcbiAgXCJWYmFyXCI6XCJcXHUyQUVCXCIsXG4gIFwidkJhclwiOlwiXFx1MkFFOFwiLFxuICBcInZCYXJ2XCI6XCJcXHUyQUU5XCIsXG4gIFwiVmN5XCI6XCJcXHUwNDEyXCIsXG4gIFwidmN5XCI6XCJcXHUwNDMyXCIsXG4gIFwiVkRhc2hcIjpcIlxcdTIyQUJcIixcbiAgXCJWZGFzaFwiOlwiXFx1MjJBOVwiLFxuICBcInZEYXNoXCI6XCJcXHUyMkE4XCIsXG4gIFwidmRhc2hcIjpcIlxcdTIyQTJcIixcbiAgXCJWZGFzaGxcIjpcIlxcdTJBRTZcIixcbiAgXCJWZWVcIjpcIlxcdTIyQzFcIixcbiAgXCJ2ZWVcIjpcIlxcdTIyMjhcIixcbiAgXCJ2ZWViYXJcIjpcIlxcdTIyQkJcIixcbiAgXCJ2ZWVlcVwiOlwiXFx1MjI1QVwiLFxuICBcInZlbGxpcFwiOlwiXFx1MjJFRVwiLFxuICBcIlZlcmJhclwiOlwiXFx1MjAxNlwiLFxuICBcInZlcmJhclwiOlwiXFx1MDA3Q1wiLFxuICBcIlZlcnRcIjpcIlxcdTIwMTZcIixcbiAgXCJ2ZXJ0XCI6XCJcXHUwMDdDXCIsXG4gIFwiVmVydGljYWxCYXJcIjpcIlxcdTIyMjNcIixcbiAgXCJWZXJ0aWNhbExpbmVcIjpcIlxcdTAwN0NcIixcbiAgXCJWZXJ0aWNhbFNlcGFyYXRvclwiOlwiXFx1Mjc1OFwiLFxuICBcIlZlcnRpY2FsVGlsZGVcIjpcIlxcdTIyNDBcIixcbiAgXCJWZXJ5VGhpblNwYWNlXCI6XCJcXHUyMDBBXCIsXG4gIFwiVmZyXCI6XCJcXHVEODM1XFx1REQxOVwiLFxuICBcInZmclwiOlwiXFx1RDgzNVxcdUREMzNcIixcbiAgXCJ2bHRyaVwiOlwiXFx1MjJCMlwiLFxuICBcInZuc3ViXCI6XCJcXHUyMjgyXFx1MjBEMlwiLFxuICBcInZuc3VwXCI6XCJcXHUyMjgzXFx1MjBEMlwiLFxuICBcIlZvcGZcIjpcIlxcdUQ4MzVcXHVERDREXCIsXG4gIFwidm9wZlwiOlwiXFx1RDgzNVxcdURENjdcIixcbiAgXCJ2cHJvcFwiOlwiXFx1MjIxRFwiLFxuICBcInZydHJpXCI6XCJcXHUyMkIzXCIsXG4gIFwiVnNjclwiOlwiXFx1RDgzNVxcdURDQjFcIixcbiAgXCJ2c2NyXCI6XCJcXHVEODM1XFx1RENDQlwiLFxuICBcInZzdWJuRVwiOlwiXFx1MkFDQlxcdUZFMDBcIixcbiAgXCJ2c3VibmVcIjpcIlxcdTIyOEFcXHVGRTAwXCIsXG4gIFwidnN1cG5FXCI6XCJcXHUyQUNDXFx1RkUwMFwiLFxuICBcInZzdXBuZVwiOlwiXFx1MjI4QlxcdUZFMDBcIixcbiAgXCJWdmRhc2hcIjpcIlxcdTIyQUFcIixcbiAgXCJ2emlnemFnXCI6XCJcXHUyOTlBXCIsXG4gIFwiV2NpcmNcIjpcIlxcdTAxNzRcIixcbiAgXCJ3Y2lyY1wiOlwiXFx1MDE3NVwiLFxuICBcIndlZGJhclwiOlwiXFx1MkE1RlwiLFxuICBcIldlZGdlXCI6XCJcXHUyMkMwXCIsXG4gIFwid2VkZ2VcIjpcIlxcdTIyMjdcIixcbiAgXCJ3ZWRnZXFcIjpcIlxcdTIyNTlcIixcbiAgXCJ3ZWllcnBcIjpcIlxcdTIxMThcIixcbiAgXCJXZnJcIjpcIlxcdUQ4MzVcXHVERDFBXCIsXG4gIFwid2ZyXCI6XCJcXHVEODM1XFx1REQzNFwiLFxuICBcIldvcGZcIjpcIlxcdUQ4MzVcXHVERDRFXCIsXG4gIFwid29wZlwiOlwiXFx1RDgzNVxcdURENjhcIixcbiAgXCJ3cFwiOlwiXFx1MjExOFwiLFxuICBcIndyXCI6XCJcXHUyMjQwXCIsXG4gIFwid3JlYXRoXCI6XCJcXHUyMjQwXCIsXG4gIFwiV3NjclwiOlwiXFx1RDgzNVxcdURDQjJcIixcbiAgXCJ3c2NyXCI6XCJcXHVEODM1XFx1RENDQ1wiLFxuICBcInhjYXBcIjpcIlxcdTIyQzJcIixcbiAgXCJ4Y2lyY1wiOlwiXFx1MjVFRlwiLFxuICBcInhjdXBcIjpcIlxcdTIyQzNcIixcbiAgXCJ4ZHRyaVwiOlwiXFx1MjVCRFwiLFxuICBcIlhmclwiOlwiXFx1RDgzNVxcdUREMUJcIixcbiAgXCJ4ZnJcIjpcIlxcdUQ4MzVcXHVERDM1XCIsXG4gIFwieGhBcnJcIjpcIlxcdTI3RkFcIixcbiAgXCJ4aGFyclwiOlwiXFx1MjdGN1wiLFxuICBcIlhpXCI6XCJcXHUwMzlFXCIsXG4gIFwieGlcIjpcIlxcdTAzQkVcIixcbiAgXCJ4bEFyclwiOlwiXFx1MjdGOFwiLFxuICBcInhsYXJyXCI6XCJcXHUyN0Y1XCIsXG4gIFwieG1hcFwiOlwiXFx1MjdGQ1wiLFxuICBcInhuaXNcIjpcIlxcdTIyRkJcIixcbiAgXCJ4b2RvdFwiOlwiXFx1MkEwMFwiLFxuICBcIlhvcGZcIjpcIlxcdUQ4MzVcXHVERDRGXCIsXG4gIFwieG9wZlwiOlwiXFx1RDgzNVxcdURENjlcIixcbiAgXCJ4b3BsdXNcIjpcIlxcdTJBMDFcIixcbiAgXCJ4b3RpbWVcIjpcIlxcdTJBMDJcIixcbiAgXCJ4ckFyclwiOlwiXFx1MjdGOVwiLFxuICBcInhyYXJyXCI6XCJcXHUyN0Y2XCIsXG4gIFwiWHNjclwiOlwiXFx1RDgzNVxcdURDQjNcIixcbiAgXCJ4c2NyXCI6XCJcXHVEODM1XFx1RENDRFwiLFxuICBcInhzcWN1cFwiOlwiXFx1MkEwNlwiLFxuICBcInh1cGx1c1wiOlwiXFx1MkEwNFwiLFxuICBcInh1dHJpXCI6XCJcXHUyNUIzXCIsXG4gIFwieHZlZVwiOlwiXFx1MjJDMVwiLFxuICBcInh3ZWRnZVwiOlwiXFx1MjJDMFwiLFxuICBcIllhY3V0ZVwiOlwiXFx1MDBERFwiLFxuICBcInlhY3V0ZVwiOlwiXFx1MDBGRFwiLFxuICBcIllBY3lcIjpcIlxcdTA0MkZcIixcbiAgXCJ5YWN5XCI6XCJcXHUwNDRGXCIsXG4gIFwiWWNpcmNcIjpcIlxcdTAxNzZcIixcbiAgXCJ5Y2lyY1wiOlwiXFx1MDE3N1wiLFxuICBcIlljeVwiOlwiXFx1MDQyQlwiLFxuICBcInljeVwiOlwiXFx1MDQ0QlwiLFxuICBcInllblwiOlwiXFx1MDBBNVwiLFxuICBcIllmclwiOlwiXFx1RDgzNVxcdUREMUNcIixcbiAgXCJ5ZnJcIjpcIlxcdUQ4MzVcXHVERDM2XCIsXG4gIFwiWUljeVwiOlwiXFx1MDQwN1wiLFxuICBcInlpY3lcIjpcIlxcdTA0NTdcIixcbiAgXCJZb3BmXCI6XCJcXHVEODM1XFx1REQ1MFwiLFxuICBcInlvcGZcIjpcIlxcdUQ4MzVcXHVERDZBXCIsXG4gIFwiWXNjclwiOlwiXFx1RDgzNVxcdURDQjRcIixcbiAgXCJ5c2NyXCI6XCJcXHVEODM1XFx1RENDRVwiLFxuICBcIllVY3lcIjpcIlxcdTA0MkVcIixcbiAgXCJ5dWN5XCI6XCJcXHUwNDRFXCIsXG4gIFwiWXVtbFwiOlwiXFx1MDE3OFwiLFxuICBcInl1bWxcIjpcIlxcdTAwRkZcIixcbiAgXCJaYWN1dGVcIjpcIlxcdTAxNzlcIixcbiAgXCJ6YWN1dGVcIjpcIlxcdTAxN0FcIixcbiAgXCJaY2Fyb25cIjpcIlxcdTAxN0RcIixcbiAgXCJ6Y2Fyb25cIjpcIlxcdTAxN0VcIixcbiAgXCJaY3lcIjpcIlxcdTA0MTdcIixcbiAgXCJ6Y3lcIjpcIlxcdTA0MzdcIixcbiAgXCJaZG90XCI6XCJcXHUwMTdCXCIsXG4gIFwiemRvdFwiOlwiXFx1MDE3Q1wiLFxuICBcInplZXRyZlwiOlwiXFx1MjEyOFwiLFxuICBcIlplcm9XaWR0aFNwYWNlXCI6XCJcXHUyMDBCXCIsXG4gIFwiWmV0YVwiOlwiXFx1MDM5NlwiLFxuICBcInpldGFcIjpcIlxcdTAzQjZcIixcbiAgXCJaZnJcIjpcIlxcdTIxMjhcIixcbiAgXCJ6ZnJcIjpcIlxcdUQ4MzVcXHVERDM3XCIsXG4gIFwiWkhjeVwiOlwiXFx1MDQxNlwiLFxuICBcInpoY3lcIjpcIlxcdTA0MzZcIixcbiAgXCJ6aWdyYXJyXCI6XCJcXHUyMUREXCIsXG4gIFwiWm9wZlwiOlwiXFx1MjEyNFwiLFxuICBcInpvcGZcIjpcIlxcdUQ4MzVcXHVERDZCXCIsXG4gIFwiWnNjclwiOlwiXFx1RDgzNVxcdURDQjVcIixcbiAgXCJ6c2NyXCI6XCJcXHVEODM1XFx1RENDRlwiLFxuICBcInp3alwiOlwiXFx1MjAwRFwiLFxuICBcInp3bmpcIjpcIlxcdTIwMENcIlxufTtcbiIsIi8vIExpc3Qgb2YgdmFsaWQgaHRtbCBibG9ja3MgbmFtZXMsIGFjY29ydGluZyB0byBjb21tb25tYXJrIHNwZWNcbi8vIGh0dHA6Ly9qZ20uZ2l0aHViLmlvL0NvbW1vbk1hcmsvc3BlYy5odG1sI2h0bWwtYmxvY2tzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGh0bWxfYmxvY2tzID0ge307XG5cbltcbiAgJ2FydGljbGUnLFxuICAnYXNpZGUnLFxuICAnYnV0dG9uJyxcbiAgJ2Jsb2NrcXVvdGUnLFxuICAnYm9keScsXG4gICdjYW52YXMnLFxuICAnY2FwdGlvbicsXG4gICdjb2wnLFxuICAnY29sZ3JvdXAnLFxuICAnZGQnLFxuICAnZGl2JyxcbiAgJ2RsJyxcbiAgJ2R0JyxcbiAgJ2VtYmVkJyxcbiAgJ2ZpZWxkc2V0JyxcbiAgJ2ZpZ2NhcHRpb24nLFxuICAnZmlndXJlJyxcbiAgJ2Zvb3RlcicsXG4gICdmb3JtJyxcbiAgJ2gxJyxcbiAgJ2gyJyxcbiAgJ2gzJyxcbiAgJ2g0JyxcbiAgJ2g1JyxcbiAgJ2g2JyxcbiAgJ2hlYWRlcicsXG4gICdoZ3JvdXAnLFxuICAnaHInLFxuICAnaWZyYW1lJyxcbiAgJ2xpJyxcbiAgJ21hcCcsXG4gICdvYmplY3QnLFxuICAnb2wnLFxuICAnb3V0cHV0JyxcbiAgJ3AnLFxuICAncHJlJyxcbiAgJ3Byb2dyZXNzJyxcbiAgJ3NjcmlwdCcsXG4gICdzZWN0aW9uJyxcbiAgJ3N0eWxlJyxcbiAgJ3RhYmxlJyxcbiAgJ3Rib2R5JyxcbiAgJ3RkJyxcbiAgJ3RleHRhcmVhJyxcbiAgJ3Rmb290JyxcbiAgJ3RoJyxcbiAgJ3RyJyxcbiAgJ3RoZWFkJyxcbiAgJ3VsJyxcbiAgJ3ZpZGVvJ1xuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IGh0bWxfYmxvY2tzW25hbWVdID0gdHJ1ZTsgfSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBodG1sX2Jsb2NrcztcbiIsIi8vIFJlZ2V4cHMgdG8gbWF0Y2ggaHRtbCBlbGVtZW50c1xuXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gcmVwbGFjZShyZWdleCwgb3B0aW9ucykge1xuICByZWdleCA9IHJlZ2V4LnNvdXJjZTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgJyc7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHNlbGYobmFtZSwgdmFsKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwpO1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xufVxuXG5cbnZhciBhdHRyX25hbWUgICAgID0gL1thLXpBLVpfOl1bYS16QS1aMC05Oi5fLV0qLztcblxudmFyIHVucXVvdGVkICAgICAgPSAvW15cIic9PD5gXFx4MDAtXFx4MjBdKy87XG52YXIgc2luZ2xlX3F1b3RlZCA9IC8nW14nXSonLztcbnZhciBkb3VibGVfcXVvdGVkID0gL1wiW15cIl0qXCIvO1xuXG4vKmVzbGludCBuby1zcGFjZWQtZnVuYzowKi9cbnZhciBhdHRyX3ZhbHVlICA9IHJlcGxhY2UoLyg/OnVucXVvdGVkfHNpbmdsZV9xdW90ZWR8ZG91YmxlX3F1b3RlZCkvKVxuICAgICAgICAgICAgICAgICAgICAoJ3VucXVvdGVkJywgdW5xdW90ZWQpXG4gICAgICAgICAgICAgICAgICAgICgnc2luZ2xlX3F1b3RlZCcsIHNpbmdsZV9xdW90ZWQpXG4gICAgICAgICAgICAgICAgICAgICgnZG91YmxlX3F1b3RlZCcsIGRvdWJsZV9xdW90ZWQpXG4gICAgICAgICAgICAgICAgICAgICgpO1xuXG52YXIgYXR0cmlidXRlICAgPSByZXBsYWNlKC8oPzpcXHMrYXR0cl9uYW1lKD86XFxzKj1cXHMqYXR0cl92YWx1ZSk/KS8pXG4gICAgICAgICAgICAgICAgICAgICgnYXR0cl9uYW1lJywgYXR0cl9uYW1lKVxuICAgICAgICAgICAgICAgICAgICAoJ2F0dHJfdmFsdWUnLCBhdHRyX3ZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAoKTtcblxudmFyIG9wZW5fdGFnICAgID0gcmVwbGFjZSgvPFtBLVphLXpdW0EtWmEtejAtOV0qYXR0cmlidXRlKlxccypcXC8/Pi8pXG4gICAgICAgICAgICAgICAgICAgICgnYXR0cmlidXRlJywgYXR0cmlidXRlKVxuICAgICAgICAgICAgICAgICAgICAoKTtcblxudmFyIGNsb3NlX3RhZyAgID0gLzxcXC9bQS1aYS16XVtBLVphLXowLTldKlxccyo+LztcbnZhciBjb21tZW50ICAgICA9IC88IS0tKFteLV0rfFstXVteLV0rKSotLT4vO1xudmFyIHByb2Nlc3NpbmcgID0gLzxbP10uKj9bP10+LztcbnZhciBkZWNsYXJhdGlvbiA9IC88IVtBLVpdK1xccytbXj5dKj4vO1xudmFyIGNkYXRhICAgICAgID0gLzwhXFxbQ0RBVEFcXFsoW15cXF1dK3xcXF1bXlxcXV18XFxdXFxdW14+XSkqXFxdXFxdPi87XG5cbnZhciBIVE1MX1RBR19SRSA9IHJlcGxhY2UoL14oPzpvcGVuX3RhZ3xjbG9zZV90YWd8Y29tbWVudHxwcm9jZXNzaW5nfGRlY2xhcmF0aW9ufGNkYXRhKS8pXG4gICgnb3Blbl90YWcnLCBvcGVuX3RhZylcbiAgKCdjbG9zZV90YWcnLCBjbG9zZV90YWcpXG4gICgnY29tbWVudCcsIGNvbW1lbnQpXG4gICgncHJvY2Vzc2luZycsIHByb2Nlc3NpbmcpXG4gICgnZGVjbGFyYXRpb24nLCBkZWNsYXJhdGlvbilcbiAgKCdjZGF0YScsIGNkYXRhKVxuICAoKTtcblxuXG5tb2R1bGUuZXhwb3J0cy5IVE1MX1RBR19SRSA9IEhUTUxfVEFHX1JFO1xuIiwiLy8gTGlzdCBvZiB2YWxpZCB1cmwgc2NoZW1hcywgYWNjb3J0aW5nIHRvIGNvbW1vbm1hcmsgc3BlY1xuLy8gaHR0cDovL2pnbS5naXRodWIuaW8vQ29tbW9uTWFyay9zcGVjLmh0bWwjYXV0b2xpbmtzXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2NvYXAnLFxuICAnZG9pJyxcbiAgJ2phdmFzY3JpcHQnLFxuICAnYWFhJyxcbiAgJ2FhYXMnLFxuICAnYWJvdXQnLFxuICAnYWNhcCcsXG4gICdjYXAnLFxuICAnY2lkJyxcbiAgJ2NyaWQnLFxuICAnZGF0YScsXG4gICdkYXYnLFxuICAnZGljdCcsXG4gICdkbnMnLFxuICAnZmlsZScsXG4gICdmdHAnLFxuICAnZ2VvJyxcbiAgJ2dvJyxcbiAgJ2dvcGhlcicsXG4gICdoMzIzJyxcbiAgJ2h0dHAnLFxuICAnaHR0cHMnLFxuICAnaWF4JyxcbiAgJ2ljYXAnLFxuICAnaW0nLFxuICAnaW1hcCcsXG4gICdpbmZvJyxcbiAgJ2lwcCcsXG4gICdpcmlzJyxcbiAgJ2lyaXMuYmVlcCcsXG4gICdpcmlzLnhwYycsXG4gICdpcmlzLnhwY3MnLFxuICAnaXJpcy5sd3onLFxuICAnbGRhcCcsXG4gICdtYWlsdG8nLFxuICAnbWlkJyxcbiAgJ21zcnAnLFxuICAnbXNycHMnLFxuICAnbXRxcCcsXG4gICdtdXBkYXRlJyxcbiAgJ25ld3MnLFxuICAnbmZzJyxcbiAgJ25pJyxcbiAgJ25paCcsXG4gICdubnRwJyxcbiAgJ29wYXF1ZWxvY2t0b2tlbicsXG4gICdwb3AnLFxuICAncHJlcycsXG4gICdydHNwJyxcbiAgJ3NlcnZpY2UnLFxuICAnc2Vzc2lvbicsXG4gICdzaHR0cCcsXG4gICdzaWV2ZScsXG4gICdzaXAnLFxuICAnc2lwcycsXG4gICdzbXMnLFxuICAnc25tcCcsXG4gICdzb2FwLmJlZXAnLFxuICAnc29hcC5iZWVwcycsXG4gICd0YWcnLFxuICAndGVsJyxcbiAgJ3RlbG5ldCcsXG4gICd0ZnRwJyxcbiAgJ3RoaXNtZXNzYWdlJyxcbiAgJ3RuMzI3MCcsXG4gICd0aXAnLFxuICAndHYnLFxuICAndXJuJyxcbiAgJ3ZlbW1pJyxcbiAgJ3dzJyxcbiAgJ3dzcycsXG4gICd4Y29uJyxcbiAgJ3hjb24tdXNlcmlkJyxcbiAgJ3htbHJwYy5iZWVwJyxcbiAgJ3htbHJwYy5iZWVwcycsXG4gICd4bXBwJyxcbiAgJ3ozOS41MHInLFxuICAnejM5LjUwcycsXG4gICdhZGl1bXh0cmEnLFxuICAnYWZwJyxcbiAgJ2FmcycsXG4gICdhaW0nLFxuICAnYXB0JyxcbiAgJ2F0dGFjaG1lbnQnLFxuICAnYXcnLFxuICAnYmVzaGFyZScsXG4gICdiaXRjb2luJyxcbiAgJ2JvbG8nLFxuICAnY2FsbHRvJyxcbiAgJ2Nocm9tZScsXG4gICdjaHJvbWUtZXh0ZW5zaW9uJyxcbiAgJ2NvbS1ldmVudGJyaXRlLWF0dGVuZGVlJyxcbiAgJ2NvbnRlbnQnLFxuICAnY3ZzJyxcbiAgJ2RsbmEtcGxheXNpbmdsZScsXG4gICdkbG5hLXBsYXljb250YWluZXInLFxuICAnZHRuJyxcbiAgJ2R2YicsXG4gICdlZDJrJyxcbiAgJ2ZhY2V0aW1lJyxcbiAgJ2ZlZWQnLFxuICAnZmluZ2VyJyxcbiAgJ2Zpc2gnLFxuICAnZ2cnLFxuICAnZ2l0JyxcbiAgJ2dpem1vcHJvamVjdCcsXG4gICdndGFsaycsXG4gICdoY3AnLFxuICAnaWNvbicsXG4gICdpcG4nLFxuICAnaXJjJyxcbiAgJ2lyYzYnLFxuICAnaXJjcycsXG4gICdpdG1zJyxcbiAgJ2phcicsXG4gICdqbXMnLFxuICAna2V5cGFyYycsXG4gICdsYXN0Zm0nLFxuICAnbGRhcHMnLFxuICAnbWFnbmV0JyxcbiAgJ21hcHMnLFxuICAnbWFya2V0JyxcbiAgJ21lc3NhZ2UnLFxuICAnbW1zJyxcbiAgJ21zLWhlbHAnLFxuICAnbXNuaW0nLFxuICAnbXVtYmxlJyxcbiAgJ212bicsXG4gICdub3RlcycsXG4gICdvaWQnLFxuICAncGFsbScsXG4gICdwYXBhcmF6emknLFxuICAncGxhdGZvcm0nLFxuICAncHJveHknLFxuICAncHN5YycsXG4gICdxdWVyeScsXG4gICdyZXMnLFxuICAncmVzb3VyY2UnLFxuICAncm1pJyxcbiAgJ3JzeW5jJyxcbiAgJ3J0bXAnLFxuICAnc2Vjb25kbGlmZScsXG4gICdzZnRwJyxcbiAgJ3NnbicsXG4gICdza3lwZScsXG4gICdzbWInLFxuICAnc29sZGF0JyxcbiAgJ3Nwb3RpZnknLFxuICAnc3NoJyxcbiAgJ3N0ZWFtJyxcbiAgJ3N2bicsXG4gICd0ZWFtc3BlYWsnLFxuICAndGhpbmdzJyxcbiAgJ3VkcCcsXG4gICd1bnJlYWwnLFxuICAndXQyMDA0JyxcbiAgJ3ZlbnRyaWxvJyxcbiAgJ3ZpZXctc291cmNlJyxcbiAgJ3dlYmNhbCcsXG4gICd3dGFpJyxcbiAgJ3d5Y2l3eWcnLFxuICAneGZpcmUnLFxuICAneHJpJyxcbiAgJ3ltc2dyJ1xuXTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uc1xuICovXG5cbmZ1bmN0aW9uIHR5cGVPZihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgcmV0dXJuIHR5cGVPZihvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn1cblxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGhhcyhvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0XG4gICAgPyBoYXNPd24uY2FsbChvYmplY3QsIGtleSlcbiAgICA6IGZhbHNlO1xufVxuXG4vLyBFeHRlbmQgb2JqZWN0c1xuLy9cbmZ1bmN0aW9uIGFzc2lnbihvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG9iamVjdCcpO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgVU5FU0NBUEVfTURfUkUgPSAvXFxcXChbXFxcXCFcIiMkJSYnKCkqKywuXFwvOjs8PT4/QFtcXF1eX2B7fH1+LV0pL2c7XG5cbmZ1bmN0aW9uIHVuZXNjYXBlTWQoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignXFxcXCcpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9NRF9SRSwgJyQxJyk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbnRpdHlDb2RlKGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgLy8gYnJva2VuIHNlcXVlbmNlXG4gIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REZGRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gbmV2ZXIgdXNlZFxuICBpZiAoYyA+PSAweEZERDAgJiYgYyA8PSAweEZERUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmICgoYyAmIDB4RkZGRikgPT09IDB4RkZGRiB8fCAoYyAmIDB4RkZGRikgPT09IDB4RkZGRSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gY29udHJvbCBjb2Rlc1xuICBpZiAoYyA+PSAweDAwICYmIGMgPD0gMHgwOCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPT09IDB4MEIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID49IDB4MEUgJiYgYyA8PSAweDFGKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA+PSAweDdGICYmIGMgPD0gMHg5RikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gb3V0IG9mIHJhbmdlXG4gIGlmIChjID4gMHgxMEZGRkYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgaWYgKGMgPiAweGZmZmYpIHtcbiAgICBjIC09IDB4MTAwMDA7XG4gICAgdmFyIHN1cnJvZ2F0ZTEgPSAweGQ4MDAgKyAoYyA+PiAxMCksXG4gICAgICAgIHN1cnJvZ2F0ZTIgPSAweGRjMDAgKyAoYyAmIDB4M2ZmKTtcblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHN1cnJvZ2F0ZTEsIHN1cnJvZ2F0ZTIpO1xuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xufVxuXG52YXIgTkFNRURfRU5USVRZX1JFICAgPSAvJihbYS16I11bYS16MC05XXsxLDMxfSk7L2dpO1xudmFyIERJR0lUQUxfRU5USVRZX1RFU1RfUkUgPSAvXiMoKD86eFthLWYwLTldezEsOH18WzAtOV17MSw4fSkpL2k7XG52YXIgZW50aXRpZXMgPSByZXF1aXJlKCcuL2VudGl0aWVzJyk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBuYW1lKSB7XG4gIHZhciBjb2RlID0gMDtcblxuICBpZiAoaGFzKGVudGl0aWVzLCBuYW1lKSkge1xuICAgIHJldHVybiBlbnRpdGllc1tuYW1lXTtcbiAgfSBlbHNlIGlmIChuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDB4MjMvKiAjICovICYmIERJR0lUQUxfRU5USVRZX1RFU1RfUkUudGVzdChuYW1lKSkge1xuICAgIGNvZGUgPSBuYW1lWzFdLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDIpLCAxNilcbiAgICA6XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDEpLCAxMCk7XG4gICAgaWYgKGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlRW50aXRpZXMoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignJicpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKE5BTUVEX0VOVElUWV9SRSwgcmVwbGFjZUVudGl0eVBhdHRlcm4pO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgSFRNTF9FU0NBUEVfVEVTVF9SRSA9IC9bJjw+XCJdLztcbnZhciBIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFID0gL1smPD5cIl0vZztcbnZhciBIVE1MX1JFUExBQ0VNRU5UUyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlVW5zYWZlQ2hhcihjaCkge1xuICByZXR1cm4gSFRNTF9SRVBMQUNFTUVOVFNbY2hdO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cikge1xuICBpZiAoSFRNTF9FU0NBUEVfVEVTVF9SRS50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSwgcmVwbGFjZVVuc2FmZUNoYXIpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydHMuYXNzaWduICAgICAgICAgICAgPSBhc3NpZ247XG5leHBvcnRzLmlzU3RyaW5nICAgICAgICAgID0gaXNTdHJpbmc7XG5leHBvcnRzLmhhcyAgICAgICAgICAgICAgID0gaGFzO1xuZXhwb3J0cy51bmVzY2FwZU1kICAgICAgICA9IHVuZXNjYXBlTWQ7XG5leHBvcnRzLmlzVmFsaWRFbnRpdHlDb2RlID0gaXNWYWxpZEVudGl0eUNvZGU7XG5leHBvcnRzLmZyb21Db2RlUG9pbnQgICAgID0gZnJvbUNvZGVQb2ludDtcbmV4cG9ydHMucmVwbGFjZUVudGl0aWVzICAgPSByZXBsYWNlRW50aXRpZXM7XG5leHBvcnRzLmVzY2FwZUh0bWwgICAgICAgID0gZXNjYXBlSHRtbDtcbiIsIi8vIENvbW1vbm1hcmsgZGVmYXVsdCBvcHRpb25zXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3B0aW9uczoge1xuICAgIGh0bWw6ICAgICAgICAgdHJ1ZSwgICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxuICAgIHhodG1sT3V0OiAgICAgdHJ1ZSwgICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuICAgIGxpbmtUYXJnZXQ6ICAgJycsICAgICAgICAgICAvLyBzZXQgdGFyZ2V0IHRvIG9wZW4gbGluayBpblxuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxuXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gU2V0IGRvdWJsZXMgdG8gJ8KrwrsnIGZvciBSdXNzaWFuLCAn4oCe4oCcJyBmb3IgR2VybWFuLlxuICAgIHF1b3RlczogJ+KAnOKAneKAmOKAmScsXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgaW5wdXQgbm90IGNoYW5nZWRcbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAyMCAgICAgICAgICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcblxuICAgIGNvcmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdibG9jaycsXG4gICAgICAgICdpbmxpbmUnLFxuICAgICAgICAncmVmZXJlbmNlcycsXG4gICAgICAgICdhYmJyMidcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgYmxvY2s6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdibG9ja3F1b3RlJyxcbiAgICAgICAgJ2NvZGUnLFxuICAgICAgICAnZmVuY2VzJyxcbiAgICAgICAgJ2hlYWRpbmcnLFxuICAgICAgICAnaHInLFxuICAgICAgICAnaHRtbGJsb2NrJyxcbiAgICAgICAgJ2xoZWFkaW5nJyxcbiAgICAgICAgJ2xpc3QnLFxuICAgICAgICAncGFyYWdyYXBoJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBpbmxpbmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdhdXRvbGluaycsXG4gICAgICAgICdiYWNrdGlja3MnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAnZW50aXR5JyxcbiAgICAgICAgJ2VzY2FwZScsXG4gICAgICAgICdodG1sdGFnJyxcbiAgICAgICAgJ2xpbmtzJyxcbiAgICAgICAgJ25ld2xpbmUnLFxuICAgICAgICAndGV4dCdcbiAgICAgIF1cbiAgICB9XG4gIH1cbn07XG4iLCIvLyBSZW1hcmthYmxlIGRlZmF1bHQgb3B0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIGZhbHNlLCAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIGZhbHNlLCAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcbiAgICBsaW5rVGFyZ2V0OiAgICcnLCAgICAgICAgICAgLy8gc2V0IHRhcmdldCB0byBvcGVuIGxpbmsgaW5cblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIFNldCBkb3VibGVzIHRvICfCq8K7JyBmb3IgUnVzc2lhbiwgJ+KAnuKAnCcgZm9yIEdlcm1hbi5cbiAgICBxdW90ZXM6ICfigJzigJ3igJjigJknLFxuXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxuICAgIC8vIG9yICcnIGlmIGlucHV0IG5vdCBjaGFuZ2VkXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMjAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnYmxvY2snLFxuICAgICAgICAnaW5saW5lJyxcbiAgICAgICAgJ3JlZmVyZW5jZXMnLFxuICAgICAgICAncmVwbGFjZW1lbnRzJyxcbiAgICAgICAgJ2xpbmtpZnknLFxuICAgICAgICAnc21hcnRxdW90ZXMnLFxuICAgICAgICAncmVmZXJlbmNlcycsXG4gICAgICAgICdhYmJyMicsXG4gICAgICAgICdmb290bm90ZV90YWlsJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBibG9jazoge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAnY29kZScsXG4gICAgICAgICdmZW5jZXMnLFxuICAgICAgICAnZm9vdG5vdGUnLFxuICAgICAgICAnaGVhZGluZycsXG4gICAgICAgICdocicsXG4gICAgICAgICdodG1sYmxvY2snLFxuICAgICAgICAnbGhlYWRpbmcnLFxuICAgICAgICAnbGlzdCcsXG4gICAgICAgICdwYXJhZ3JhcGgnLFxuICAgICAgICAndGFibGUnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGlubGluZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ2F1dG9saW5rJyxcbiAgICAgICAgJ2JhY2t0aWNrcycsXG4gICAgICAgICdkZWwnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAnZW50aXR5JyxcbiAgICAgICAgJ2VzY2FwZScsXG4gICAgICAgICdmb290bm90ZV9yZWYnLFxuICAgICAgICAnaHRtbHRhZycsXG4gICAgICAgICdsaW5rcycsXG4gICAgICAgICduZXdsaW5lJyxcbiAgICAgICAgJ3RleHQnXG4gICAgICBdXG4gICAgfVxuICB9XG59O1xuIiwiLy8gUmVtYXJrYWJsZSBkZWZhdWx0IG9wdGlvbnNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICBmYWxzZSwgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICBmYWxzZSwgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG4gICAgbGlua1RhcmdldDogICAnJywgICAgICAgICAgIC8vIHNldCB0YXJnZXQgdG8gb3BlbiBsaW5rIGluXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBTZXQgZG91YmxlcyB0byAnwqvCuycgZm9yIFJ1c3NpYW4sICfigJ7igJwnIGZvciBHZXJtYW4uXG4gICAgcXVvdGVzOiAgICAgICAn4oCc4oCd4oCY4oCZJyxcblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiBpbnB1dCBub3QgY2hhbmdlZFxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XG4gICAgLy9cbiAgICBoaWdobGlnaHQ6ICAgICBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAgMjAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG4gICAgLy8gRG9uJ3QgcmVzdHJpY3QgY29yZS9ibG9jay9pbmxpbmUgcnVsZXNcbiAgICBjb3JlOiB7fSxcbiAgICBibG9jazoge30sXG4gICAgaW5saW5lOiB7fVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVwbGFjZUVudGl0aWVzID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykucmVwbGFjZUVudGl0aWVzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmsodXJsKSB7XG4gIHZhciBub3JtYWxpemVkID0gcmVwbGFjZUVudGl0aWVzKHVybCk7XG4gIC8vIFdlIHNob3VsZG4ndCBjYXJlIGFib3V0IHRoZSByZXN1bHQgb2YgbWFsZm9ybWVkIFVSSXMsXG4gIC8vIGFuZCBzaG91bGQgbm90IHRocm93IGFuIGV4Y2VwdGlvbi5cbiAgdHJ5IHtcbiAgICBub3JtYWxpemVkID0gZGVjb2RlVVJJKG5vcm1hbGl6ZWQpO1xuICB9IGNhdGNoIChlcnIpIHt9XG4gIHJldHVybiBlbmNvZGVVUkkobm9ybWFsaXplZCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIpIHtcbiAgLy8gdXNlIC50b1VwcGVyQ2FzZSgpIGluc3RlYWQgb2YgLnRvTG93ZXJDYXNlKClcbiAgLy8gaGVyZSB0byBhdm9pZCBhIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZVxuICAvLyBtZW1iZXJzIChtb3N0IG5vdGFibHksIGBfX3Byb3RvX19gKVxuICByZXR1cm4gc3RyLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJykudG9VcHBlckNhc2UoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIG5vcm1hbGl6ZUxpbmsgPSByZXF1aXJlKCcuL25vcm1hbGl6ZV9saW5rJyk7XG52YXIgdW5lc2NhcGVNZCAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLnVuZXNjYXBlTWQ7XG5cbi8qKlxuICogUGFyc2UgbGluayBkZXN0aW5hdGlvblxuICpcbiAqICAgLSBvbiBzdWNjZXNzIGl0IHJldHVybnMgYSBzdHJpbmcgYW5kIHVwZGF0ZXMgc3RhdGUucG9zO1xuICogICAtIG9uIGZhaWx1cmUgaXQgcmV0dXJucyBudWxsXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtICB7TnVtYmVyfSBwb3NcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rRGVzdGluYXRpb24oc3RhdGUsIHBvcykge1xuICB2YXIgY29kZSwgbGV2ZWwsIGxpbmssXG4gICAgICBzdGFydCA9IHBvcyxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgzQyAvKiA8ICovKSB7XG4gICAgcG9zKys7XG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoY29kZSA9PT0gMHgwQSAvKiBcXG4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBpZiAoY29kZSA9PT0gMHgzRSAvKiA+ICovKSB7XG4gICAgICAgIGxpbmsgPSBub3JtYWxpemVMaW5rKHVuZXNjYXBlTWQoc3RhdGUuc3JjLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKSkpO1xuICAgICAgICBpZiAoIXN0YXRlLnBhcnNlci52YWxpZGF0ZUxpbmsobGluaykpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHN0YXRlLnBvcyA9IHBvcyArIDE7XG4gICAgICAgIHN0YXRlLmxpbmtDb250ZW50ID0gbGluaztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICAgIHBvcyArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgLy8gbm8gY2xvc2luZyAnPidcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB0aGlzIHNob3VsZCBiZSAuLi4gfSBlbHNlIHsgLi4uIGJyYW5jaFxuXG4gIGxldmVsID0gMDtcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNvZGUgPT09IDB4MjApIHsgYnJlYWs7IH1cblxuICAgIGlmIChjb2RlID4gMHgwOCAmJiBjb2RlIDwgMHgwZSkgeyBicmVhazsgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgcG9zICs9IDI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyOCAvKiAoICovKSB7XG4gICAgICBsZXZlbCsrO1xuICAgICAgaWYgKGxldmVsID4gMSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAweDI5IC8qICkgKi8pIHtcbiAgICAgIGxldmVsLS07XG4gICAgICBpZiAobGV2ZWwgPCAwKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHBvcykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsaW5rID0gdW5lc2NhcGVNZChzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcykpO1xuICBpZiAoIXN0YXRlLnBhcnNlci52YWxpZGF0ZUxpbmsobGluaykpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc3RhdGUubGlua0NvbnRlbnQgPSBsaW5rO1xuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQYXJzZSBsaW5rIGxhYmVsc1xuICpcbiAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGZpcnN0IGNoYXJhY3RlciAoYFtgKSBhbHJlYWR5IG1hdGNoZXM7XG4gKiByZXR1cm5zIHRoZSBlbmQgb2YgdGhlIGxhYmVsLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSAge051bWJlcn0gc3RhcnRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXJ0KSB7XG4gIHZhciBsZXZlbCwgZm91bmQsIG1hcmtlcixcbiAgICAgIGxhYmVsRW5kID0gLTEsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBvbGRQb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBvbGRGbGFnID0gc3RhdGUuaXNJbkxhYmVsO1xuXG4gIGlmIChzdGF0ZS5pc0luTGFiZWwpIHsgcmV0dXJuIC0xOyB9XG5cbiAgaWYgKHN0YXRlLmxhYmVsVW5tYXRjaGVkU2NvcGVzKSB7XG4gICAgc3RhdGUubGFiZWxVbm1hdGNoZWRTY29wZXMtLTtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydCArIDE7XG4gIHN0YXRlLmlzSW5MYWJlbCA9IHRydWU7XG4gIGxldmVsID0gMTtcblxuICB3aGlsZSAoc3RhdGUucG9zIDwgbWF4KSB7XG4gICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKTtcbiAgICBpZiAobWFya2VyID09PSAweDVCIC8qIFsgKi8pIHtcbiAgICAgIGxldmVsKys7XG4gICAgfSBlbHNlIGlmIChtYXJrZXIgPT09IDB4NUQgLyogXSAqLykge1xuICAgICAgbGV2ZWwtLTtcbiAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLnBhcnNlci5za2lwVG9rZW4oc3RhdGUpO1xuICB9XG5cbiAgaWYgKGZvdW5kKSB7XG4gICAgbGFiZWxFbmQgPSBzdGF0ZS5wb3M7XG4gICAgc3RhdGUubGFiZWxVbm1hdGNoZWRTY29wZXMgPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxhYmVsVW5tYXRjaGVkU2NvcGVzID0gbGV2ZWwgLSAxO1xuICB9XG5cbiAgLy8gcmVzdG9yZSBvbGQgc3RhdGVcbiAgc3RhdGUucG9zID0gb2xkUG9zO1xuICBzdGF0ZS5pc0luTGFiZWwgPSBvbGRGbGFnO1xuXG4gIHJldHVybiBsYWJlbEVuZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHVuZXNjYXBlTWQgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS51bmVzY2FwZU1kO1xuXG4vKipcbiAqIFBhcnNlIGxpbmsgdGl0bGVcbiAqXG4gKiAgIC0gb24gc3VjY2VzcyBpdCByZXR1cm5zIGEgc3RyaW5nIGFuZCB1cGRhdGVzIHN0YXRlLnBvcztcbiAqICAgLSBvbiBmYWlsdXJlIGl0IHJldHVybnMgbnVsbFxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSAge051bWJlcn0gcG9zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua1RpdGxlKHN0YXRlLCBwb3MpIHtcbiAgdmFyIGNvZGUsXG4gICAgICBzdGFydCA9IHBvcyxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcbiAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKG1hcmtlciAhPT0gMHgyMiAvKiBcIiAqLyAmJiBtYXJrZXIgIT09IDB4MjcgLyogJyAqLyAmJiBtYXJrZXIgIT09IDB4MjggLyogKCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MrKztcblxuICAvLyBpZiBvcGVuaW5nIG1hcmtlciBpcyBcIihcIiwgc3dpdGNoIGl0IHRvIGNsb3NpbmcgbWFya2VyIFwiKVwiXG4gIGlmIChtYXJrZXIgPT09IDB4MjgpIHsgbWFya2VyID0gMHgyOTsgfVxuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY29kZSA9PT0gbWFya2VyKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBwb3MgKyAxO1xuICAgICAgc3RhdGUubGlua0NvbnRlbnQgPSB1bmVzY2FwZU1kKHN0YXRlLnNyYy5zbGljZShzdGFydCArIDEsIHBvcykpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgIHBvcyArPSAyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIExvY2FsIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBhc3NpZ24gICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLmFzc2lnbjtcbnZhciBSZW5kZXJlciAgICAgPSByZXF1aXJlKCcuL3JlbmRlcmVyJyk7XG52YXIgUGFyc2VyQ29yZSAgID0gcmVxdWlyZSgnLi9wYXJzZXJfY29yZScpO1xudmFyIFBhcnNlckJsb2NrICA9IHJlcXVpcmUoJy4vcGFyc2VyX2Jsb2NrJyk7XG52YXIgUGFyc2VySW5saW5lID0gcmVxdWlyZSgnLi9wYXJzZXJfaW5saW5lJyk7XG52YXIgUnVsZXIgICAgICAgID0gcmVxdWlyZSgnLi9ydWxlcicpO1xuXG4vKipcbiAqIFByZXNldCBjb25maWdzXG4gKi9cblxudmFyIGNvbmZpZyA9IHtcbiAgJ2RlZmF1bHQnOiAgICByZXF1aXJlKCcuL2NvbmZpZ3MvZGVmYXVsdCcpLFxuICAnZnVsbCc6ICAgICAgIHJlcXVpcmUoJy4vY29uZmlncy9mdWxsJyksXG4gICdjb21tb25tYXJrJzogcmVxdWlyZSgnLi9jb25maWdzL2NvbW1vbm1hcmsnKVxufTtcblxuLyoqXG4gKiBUaGUgYFN0YXRlQ29yZWAgY2xhc3MgbWFuYWdlcyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYGluc3RhbmNlYCBSZW1hcmthYmxlIGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmAgTWFya2Rvd24gc3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gYGVudmBcbiAqL1xuXG5mdW5jdGlvbiBTdGF0ZUNvcmUoaW5zdGFuY2UsIHN0ciwgZW52KSB7XG4gIHRoaXMuc3JjID0gc3RyO1xuICB0aGlzLmVudiA9IGVudjtcbiAgdGhpcy5vcHRpb25zID0gaW5zdGFuY2Uub3B0aW9ucztcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy5pbmxpbmVNb2RlID0gZmFsc2U7XG5cbiAgdGhpcy5pbmxpbmUgPSBpbnN0YW5jZS5pbmxpbmU7XG4gIHRoaXMuYmxvY2sgPSBpbnN0YW5jZS5ibG9jaztcbiAgdGhpcy5yZW5kZXJlciA9IGluc3RhbmNlLnJlbmRlcmVyO1xuICB0aGlzLnR5cG9ncmFwaGVyID0gaW5zdGFuY2UudHlwb2dyYXBoZXI7XG59XG5cbi8qKlxuICogVGhlIG1haW4gYFJlbWFya2FibGVgIGNsYXNzLiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2ZcbiAqIGBSZW1hcmthYmxlYCB3aXRoIGEgYHByZXNldGAgYW5kL29yIGBvcHRpb25zYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHByZXNldGAgSWYgbm8gcHJlc2V0IGlzIGdpdmVuLCBgZGVmYXVsdGAgaXMgdXNlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqL1xuXG5mdW5jdGlvbiBSZW1hcmthYmxlKHByZXNldCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHByZXNldCAhPT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0gcHJlc2V0O1xuICAgIHByZXNldCA9ICdkZWZhdWx0JztcbiAgfVxuXG4gIHRoaXMuaW5saW5lICAgPSBuZXcgUGFyc2VySW5saW5lKCk7XG4gIHRoaXMuYmxvY2sgICAgPSBuZXcgUGFyc2VyQmxvY2soKTtcbiAgdGhpcy5jb3JlICAgICA9IG5ldyBQYXJzZXJDb3JlKCk7XG4gIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcbiAgdGhpcy5ydWxlciAgICA9IG5ldyBSdWxlcigpO1xuXG4gIHRoaXMub3B0aW9ucyAgPSB7fTtcbiAgdGhpcy5jb25maWd1cmUoY29uZmlnW3ByZXNldF0pO1xuICB0aGlzLnNldChvcHRpb25zIHx8IHt9KTtcbn1cblxuLyoqXG4gKiBTZXQgb3B0aW9ucyBhcyBhbiBhbHRlcm5hdGl2ZSB0byBwYXNzaW5nIHRoZW1cbiAqIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBgYGBqc1xuICogbWQuc2V0KHt0eXBvZ3JhcGhlcjogdHJ1ZX0pO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlbWFya2FibGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBCYXRjaCBsb2FkZXIgZm9yIGNvbXBvbmVudHMgcnVsZXMgc3RhdGVzLCBhbmQgb3B0aW9uc1xuICpcbiAqIEBwYXJhbSAge09iamVjdH0gYHByZXNldHNgXG4gKi9cblxuUmVtYXJrYWJsZS5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKHByZXNldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghcHJlc2V0cykgeyB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGByZW1hcmthYmxlYCBwcmVzZXQsIGNoZWNrIG5hbWUvY29udGVudCcpOyB9XG4gIGlmIChwcmVzZXRzLm9wdGlvbnMpIHsgc2VsZi5zZXQocHJlc2V0cy5vcHRpb25zKTsgfVxuICBpZiAocHJlc2V0cy5jb21wb25lbnRzKSB7XG4gICAgT2JqZWN0LmtleXMocHJlc2V0cy5jb21wb25lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzKSB7XG4gICAgICAgIHNlbGZbbmFtZV0ucnVsZXIuZW5hYmxlKHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlcywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogVXNlIGEgcGx1Z2luLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWQgPSBuZXcgUmVtYXJrYWJsZSgpO1xuICpcbiAqIG1kLnVzZShwbHVnaW4xKVxuICogICAudXNlKHBsdWdpbjIsIG9wdHMpXG4gKiAgIC51c2UocGx1Z2luMyk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gYHBsdWdpbmBcbiAqIEBwYXJhbSAge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9IGBSZW1hcmthYmxlYCBmb3IgY2hhaW5pbmdcbiAqL1xuXG5SZW1hcmthYmxlLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luLCBvcHRpb25zKSB7XG4gIHBsdWdpbih0aGlzLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogUGFyc2UgdGhlIGlucHV0IGBzdHJpbmdgIGFuZCByZXR1cm4gYSB0b2tlbnMgYXJyYXkuXG4gKiBNb2RpZmllcyBgZW52YCB3aXRoIGRlZmluaXRpb25zIGRhdGEuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgc3RyaW5nYFxuICogQHBhcmFtICB7T2JqZWN0fSBgZW52YFxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIHRva2Vuc1xuICovXG5cblJlbWFya2FibGUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHN0ciwgZW52KSB7XG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZUNvcmUodGhpcywgc3RyLCBlbnYpO1xuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG4gIHJldHVybiBzdGF0ZS50b2tlbnM7XG59O1xuXG4vKipcbiAqIFRoZSBtYWluIGAucmVuZGVyKClgIG1ldGhvZCB0aGF0IGRvZXMgYWxsIHRoZSBtYWdpYyA6KVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gYHN0cmluZ2BcbiAqIEBwYXJhbSAge09iamVjdH0gYGVudmBcbiAqIEByZXR1cm4ge1N0cmluZ30gUmVuZGVyZWQgSFRNTC5cbiAqL1xuXG5SZW1hcmthYmxlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc3RyLCBlbnYpIHtcbiAgZW52ID0gZW52IHx8IHt9O1xuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZShzdHIsIGVudiksIHRoaXMub3B0aW9ucywgZW52KTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGNvbnRlbnQgYHN0cmluZ2AgYXMgYSBzaW5nbGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gYHN0cmluZ2BcbiAqIEBwYXJhbSAge09iamVjdH0gYGVudmBcbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiB0b2tlbnNcbiAqL1xuXG5SZW1hcmthYmxlLnByb3RvdHlwZS5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChzdHIsIGVudikge1xuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGVDb3JlKHRoaXMsIHN0ciwgZW52KTtcbiAgc3RhdGUuaW5saW5lTW9kZSA9IHRydWU7XG4gIHRoaXMuY29yZS5wcm9jZXNzKHN0YXRlKTtcbiAgcmV0dXJuIHN0YXRlLnRva2Vucztcbn07XG5cbi8qKlxuICogUmVuZGVyIGEgc2luZ2xlIGNvbnRlbnQgYHN0cmluZ2AsIHdpdGhvdXQgd3JhcHBpbmcgaXRcbiAqIHRvIHBhcmFncmFwaHNcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdHJgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBlbnZgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuUmVtYXJrYWJsZS5wcm90b3R5cGUucmVuZGVySW5saW5lID0gZnVuY3Rpb24gKHN0ciwgZW52KSB7XG4gIGVudiA9IGVudiB8fCB7fTtcbiAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMucGFyc2VJbmxpbmUoc3RyLCBlbnYpLCB0aGlzLm9wdGlvbnMsIGVudik7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgUmVtYXJrYWJsZWBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbWFya2FibGU7XG5cbi8qKlxuICogRXhwb3NlIGB1dGlsc2AsIFVzZWZ1bCBoZWxwZXIgZnVuY3Rpb25zIGZvciBjdXN0b21cbiAqIHJlbmRlcmluZy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy51dGlscyA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTG9jYWwgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFJ1bGVyICAgICAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG52YXIgU3RhdGVCbG9jayA9IHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svc3RhdGVfYmxvY2snKTtcblxuLyoqXG4gKiBQYXJzZXIgcnVsZXNcbiAqL1xuXG52YXIgX3J1bGVzID0gW1xuICBbICdjb2RlJywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9jb2RlJykgXSxcbiAgWyAnZmVuY2VzJywgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svZmVuY2VzJyksICAgICBbICdwYXJhZ3JhcGgnLCAnYmxvY2txdW90ZScsICdsaXN0JyBdIF0sXG4gIFsgJ2Jsb2NrcXVvdGUnLCByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUnKSwgWyAncGFyYWdyYXBoJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcgXSBdLFxuICBbICdocicsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9ocicpLCAgICAgICAgIFsgJ3BhcmFncmFwaCcsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcbiAgWyAnbGlzdCcsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svbGlzdCcpLCAgICAgICBbICdwYXJhZ3JhcGgnLCAnYmxvY2txdW90ZScgXSBdLFxuICBbICdmb290bm90ZScsICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9mb290bm90ZScpLCAgIFsgJ3BhcmFncmFwaCcgXSBdLFxuICBbICdoZWFkaW5nJywgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9oZWFkaW5nJyksICAgIFsgJ3BhcmFncmFwaCcsICdibG9ja3F1b3RlJyBdIF0sXG4gIFsgJ2xoZWFkaW5nJywgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2xoZWFkaW5nJykgXSxcbiAgWyAnaHRtbGJsb2NrJywgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaHRtbGJsb2NrJyksICBbICdwYXJhZ3JhcGgnLCAnYmxvY2txdW90ZScgXSBdLFxuICBbICd0YWJsZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay90YWJsZScpLCAgICAgIFsgJ3BhcmFncmFwaCcgXSBdLFxuICBbICdkZWZsaXN0JywgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9kZWZsaXN0JyksICAgIFsgJ3BhcmFncmFwaCcgXSBdLFxuICBbICdwYXJhZ3JhcGgnLCAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9wYXJhZ3JhcGgnKSBdXG5dO1xuXG4vKipcbiAqIEJsb2NrIFBhcnNlciBjbGFzc1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFBhcnNlckJsb2NrKCkge1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdLCB7XG4gICAgICBhbHQ6IChfcnVsZXNbaV1bMl0gfHwgW10pLnNsaWNlKClcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIHRva2VucyBmb3IgdGhlIGdpdmVuIGlucHV0IHJhbmdlLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gYHN0YXRlYCBIYXMgcHJvcGVydGllcyBsaWtlIGBzcmNgLCBgcGFyc2VyYCwgYG9wdGlvbnNgIGV0Y1xuICogQHBhcmFtICB7TnVtYmVyfSBgc3RhcnRMaW5lYFxuICogQHBhcmFtICB7TnVtYmVyfSBgZW5kTGluZWBcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBhcnNlckJsb2NrLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lKSB7XG4gIHZhciBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpO1xuICB2YXIgbGVuID0gcnVsZXMubGVuZ3RoO1xuICB2YXIgbGluZSA9IHN0YXJ0TGluZTtcbiAgdmFyIGhhc0VtcHR5TGluZXMgPSBmYWxzZTtcbiAgdmFyIG9rLCBpO1xuXG4gIHdoaWxlIChsaW5lIDwgZW5kTGluZSkge1xuICAgIHN0YXRlLmxpbmUgPSBsaW5lID0gc3RhdGUuc2tpcEVtcHR5TGluZXMobGluZSk7XG4gICAgaWYgKGxpbmUgPj0gZW5kTGluZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gVGVybWluYXRpb24gY29uZGl0aW9uIGZvciBuZXN0ZWQgY2FsbHMuXG4gICAgLy8gTmVzdGVkIGNhbGxzIGN1cnJlbnRseSB1c2VkIGZvciBibG9ja3F1b3RlcyAmIGxpc3RzXG4gICAgaWYgKHN0YXRlLnRTaGlmdFtsaW5lXSA8IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gVHJ5IGFsbCBwb3NzaWJsZSBydWxlcy5cbiAgICAvLyBPbiBzdWNjZXNzLCBydWxlIHNob3VsZDpcbiAgICAvL1xuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS5saW5lYFxuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS50b2tlbnNgXG4gICAgLy8gLSByZXR1cm4gdHJ1ZVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvayA9IHJ1bGVzW2ldKHN0YXRlLCBsaW5lLCBlbmRMaW5lLCBmYWxzZSk7XG4gICAgICBpZiAob2spIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2V0IHN0YXRlLnRpZ2h0IGlmZiB3ZSBoYWQgYW4gZW1wdHkgbGluZSBiZWZvcmUgY3VycmVudCB0YWdcbiAgICAvLyBpLmUuIGxhdGVzdCBlbXB0eSBsaW5lIHNob3VsZCBub3QgY291bnRcbiAgICBzdGF0ZS50aWdodCA9ICFoYXNFbXB0eUxpbmVzO1xuXG4gICAgLy8gcGFyYWdyYXBoIG1pZ2h0IFwiZWF0XCIgb25lIG5ld2xpbmUgYWZ0ZXIgaXQgaW4gbmVzdGVkIGxpc3RzXG4gICAgaWYgKHN0YXRlLmlzRW1wdHkoc3RhdGUubGluZSAtIDEpKSB7XG4gICAgICBoYXNFbXB0eUxpbmVzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsaW5lID0gc3RhdGUubGluZTtcblxuICAgIGlmIChsaW5lIDwgZW5kTGluZSAmJiBzdGF0ZS5pc0VtcHR5KGxpbmUpKSB7XG4gICAgICBoYXNFbXB0eUxpbmVzID0gdHJ1ZTtcbiAgICAgIGxpbmUrKztcblxuICAgICAgLy8gdHdvIGVtcHR5IGxpbmVzIHNob3VsZCBzdG9wIHRoZSBwYXJzZXIgaW4gbGlzdCBtb2RlXG4gICAgICBpZiAobGluZSA8IGVuZExpbmUgJiYgc3RhdGUucGFyZW50VHlwZSA9PT0gJ2xpc3QnICYmIHN0YXRlLmlzRW1wdHkobGluZSkpIHsgYnJlYWs7IH1cbiAgICAgIHN0YXRlLmxpbmUgPSBsaW5lO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFRBQlNfU0NBTl9SRSA9IC9bXFxuXFx0XS9nO1xudmFyIE5FV0xJTkVTX1JFICA9IC9cXHJbXFxuXFx1MDA4NV18W1xcdTI0MjRcXHUyMDI4XFx1MDA4NV0vZztcbnZhciBTUEFDRVNfUkUgICAgPSAvXFx1MDBhMC9nO1xuXG4vKipcbiAqIFRva2VuaXplIHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdHJgIFNvdXJjZSBzdHJpbmdcbiAqIEBwYXJhbSAge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBlbnZgXG4gKiBAcGFyYW0gIHtBcnJheX0gYG91dFRva2Vuc2BcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBhcnNlckJsb2NrLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMsIGVudiwgb3V0VG9rZW5zKSB7XG4gIHZhciBzdGF0ZSwgbGluZVN0YXJ0ID0gMCwgbGFzdFRhYlBvcyA9IDA7XG4gIGlmICghc3RyKSB7IHJldHVybiBbXTsgfVxuXG4gIC8vIE5vcm1hbGl6ZSBzcGFjZXNcbiAgc3RyID0gc3RyLnJlcGxhY2UoU1BBQ0VTX1JFLCAnICcpO1xuXG4gIC8vIE5vcm1hbGl6ZSBuZXdsaW5lc1xuICBzdHIgPSBzdHIucmVwbGFjZShORVdMSU5FU19SRSwgJ1xcbicpO1xuXG4gIC8vIFJlcGxhY2UgdGFicyB3aXRoIHByb3BlciBudW1iZXIgb2Ygc3BhY2VzICgxLi40KVxuICBpZiAoc3RyLmluZGV4T2YoJ1xcdCcpID49IDApIHtcbiAgICBzdHIgPSBzdHIucmVwbGFjZShUQUJTX1NDQU5fUkUsIGZ1bmN0aW9uIChtYXRjaCwgb2Zmc2V0KSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KG9mZnNldCkgPT09IDB4MEEpIHtcbiAgICAgICAgbGluZVN0YXJ0ID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgbGFzdFRhYlBvcyA9IDA7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9ICcgICAgJy5zbGljZSgob2Zmc2V0IC0gbGluZVN0YXJ0IC0gbGFzdFRhYlBvcykgJSA0KTtcbiAgICAgIGxhc3RUYWJQb3MgPSBvZmZzZXQgLSBsaW5lU3RhcnQgKyAxO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRlID0gbmV3IFN0YXRlQmxvY2soc3RyLCB0aGlzLCBvcHRpb25zLCBlbnYsIG91dFRva2Vucyk7XG4gIHRoaXMudG9rZW5pemUoc3RhdGUsIHN0YXRlLmxpbmUsIHN0YXRlLmxpbmVNYXgpO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFBhcnNlckJsb2NrYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VyQmxvY2s7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTG9jYWwgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFJ1bGVyID0gcmVxdWlyZSgnLi9ydWxlcicpO1xuXG4vKipcbiAqIENvcmUgcGFyc2VyIGBydWxlc2BcbiAqL1xuXG52YXIgX3J1bGVzID0gW1xuICBbICdibG9jaycsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9ibG9jaycpICAgICAgICAgIF0sXG4gIFsgJ2FiYnInLCAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2FiYnInKSAgICAgICAgICAgXSxcbiAgWyAncmVmZXJlbmNlcycsICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvcmVmZXJlbmNlcycpICAgICBdLFxuICBbICdpbmxpbmUnLCAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9pbmxpbmUnKSAgICAgICAgIF0sXG4gIFsgJ2Zvb3Rub3RlX3RhaWwnLCAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2Zvb3Rub3RlX3RhaWwnKSAgXSxcbiAgWyAnYWJicjInLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvYWJicjInKSAgICAgICAgICBdLFxuICBbICdyZXBsYWNlbWVudHMnLCAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9yZXBsYWNlbWVudHMnKSAgIF0sXG4gIFsgJ3NtYXJ0cXVvdGVzJywgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzJykgICAgXSxcbiAgWyAnbGlua2lmeScsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvbGlua2lmeScpICAgICAgICBdXG5dO1xuXG4vKipcbiAqIENsYXNzIGZvciB0b3AgbGV2ZWwgKGBjb3JlYCkgcGFyc2VyIHJ1bGVzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQ29yZSgpIHtcbiAgdGhpcy5vcHRpb25zID0ge307XG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0pO1xuICB9XG59XG5cbi8qKlxuICogUHJvY2VzcyBydWxlcyB3aXRoIHRoZSBnaXZlbiBgc3RhdGVgXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBgc3RhdGVgXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db3JlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBpLCBsLCBydWxlcztcbiAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKTtcbiAgZm9yIChpID0gMCwgbCA9IHJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHJ1bGVzW2ldKHN0YXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeHBvc2UgYENvcmVgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBDb3JlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIExvY2FsIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBSdWxlciAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcbnZhciBTdGF0ZUlubGluZSA9IHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0YXRlX2lubGluZScpO1xudmFyIHV0aWxzICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKTtcblxuLyoqXG4gKiBJbmxpbmUgUGFyc2VyIGBydWxlc2BcbiAqL1xuXG52YXIgX3J1bGVzID0gW1xuICBbICd0ZXh0JywgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS90ZXh0JykgXSxcbiAgWyAnbmV3bGluZScsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvbmV3bGluZScpIF0sXG4gIFsgJ2VzY2FwZScsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VzY2FwZScpIF0sXG4gIFsgJ2JhY2t0aWNrcycsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2JhY2t0aWNrcycpIF0sXG4gIFsgJ2RlbCcsICAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2RlbCcpIF0sXG4gIFsgJ2lucycsICAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2lucycpIF0sXG4gIFsgJ21hcmsnLCAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL21hcmsnKSBdLFxuICBbICdlbXBoYXNpcycsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbXBoYXNpcycpIF0sXG4gIFsgJ3N1YicsICAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N1YicpIF0sXG4gIFsgJ3N1cCcsICAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N1cCcpIF0sXG4gIFsgJ2xpbmtzJywgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2xpbmtzJykgXSxcbiAgWyAnZm9vdG5vdGVfaW5saW5lJywgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZm9vdG5vdGVfaW5saW5lJykgXSxcbiAgWyAnZm9vdG5vdGVfcmVmJywgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZm9vdG5vdGVfcmVmJykgXSxcbiAgWyAnYXV0b2xpbmsnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYXV0b2xpbmsnKSBdLFxuICBbICdodG1sdGFnJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9odG1sdGFnJykgXSxcbiAgWyAnZW50aXR5JywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZW50aXR5JykgXVxuXTtcblxuLyoqXG4gKiBJbmxpbmUgUGFyc2VyIGNsYXNzLiBOb3RlIHRoYXQgbGluayB2YWxpZGF0aW9uIGlzIHN0cmljdGVyXG4gKiBpbiBSZW1hcmthYmxlIHRoYW4gd2hhdCBpcyBzcGVjaWZpZWQgYnkgQ29tbW9uTWFyay4gSWYgeW91XG4gKiB3YW50IHRvIGNoYW5nZSB0aGlzIHlvdSBjYW4gdXNlIGEgY3VzdG9tIHZhbGlkYXRvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQYXJzZXJJbmxpbmUoKSB7XG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0pO1xuICB9XG5cbiAgLy8gQ2FuIGJlIG92ZXJyaWRkZW4gd2l0aCBhIGN1c3RvbSB2YWxpZGF0b3JcbiAgdGhpcy52YWxpZGF0ZUxpbmsgPSB2YWxpZGF0ZUxpbms7XG59XG5cbi8qKlxuICogU2tpcCBhIHNpbmdsZSB0b2tlbiBieSBydW5uaW5nIGFsbCBydWxlcyBpbiB2YWxpZGF0aW9uIG1vZGUuXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgcnVsZSByZXBvcnRzIHN1Y2Nlc3MuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBgc3RhdGVgXG4gKiBAYXBpIHByaXZhZ2VcbiAqL1xuXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnNraXBUb2tlbiA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKTtcbiAgdmFyIGxlbiA9IHJ1bGVzLmxlbmd0aDtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcztcbiAgdmFyIGksIGNhY2hlZF9wb3M7XG5cbiAgaWYgKChjYWNoZWRfcG9zID0gc3RhdGUuY2FjaGVHZXQocG9zKSkgPiAwKSB7XG4gICAgc3RhdGUucG9zID0gY2FjaGVkX3BvcztcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAocnVsZXNbaV0oc3RhdGUsIHRydWUpKSB7XG4gICAgICBzdGF0ZS5jYWNoZVNldChwb3MsIHN0YXRlLnBvcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgc3RhdGUucG9zKys7XG4gIHN0YXRlLmNhY2hlU2V0KHBvcywgc3RhdGUucG9zKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdG9rZW5zIGZvciB0aGUgZ2l2ZW4gaW5wdXQgcmFuZ2UuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBgc3RhdGVgXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpO1xuICB2YXIgbGVuID0gcnVsZXMubGVuZ3RoO1xuICB2YXIgZW5kID0gc3RhdGUucG9zTWF4O1xuICB2YXIgb2ssIGk7XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyA8IGVuZCkge1xuXG4gICAgLy8gVHJ5IGFsbCBwb3NzaWJsZSBydWxlcy5cbiAgICAvLyBPbiBzdWNjZXNzLCB0aGUgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUucG9zYFxuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS50b2tlbnNgXG4gICAgLy8gLSByZXR1cm4gdHJ1ZVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgZmFsc2UpO1xuXG4gICAgICBpZiAob2spIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9rKSB7XG4gICAgICBpZiAoc3RhdGUucG9zID49IGVuZCkgeyBicmVhazsgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmNbc3RhdGUucG9zKytdO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBlbmRpbmcpIHtcbiAgICBzdGF0ZS5wdXNoUGVuZGluZygpO1xuICB9XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBpbnB1dCBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgc3RyYFxuICogQHBhcmFtICB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEBwYXJhbSAge09iamVjdH0gYGVudmBcbiAqIEBwYXJhbSAge0FycmF5fSBgb3V0VG9rZW5zYFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUGFyc2VySW5saW5lLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMsIGVudiwgb3V0VG9rZW5zKSB7XG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZUlubGluZShzdHIsIHRoaXMsIG9wdGlvbnMsIGVudiwgb3V0VG9rZW5zKTtcbiAgdGhpcy50b2tlbml6ZShzdGF0ZSk7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBnaXZlbiBgdXJsYCBieSBjaGVja2luZyBmb3IgYmFkIHByb3RvY29scy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGB1cmxgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlTGluayh1cmwpIHtcbiAgdmFyIEJBRF9QUk9UT0NPTFMgPSBbICd2YnNjcmlwdCcsICdqYXZhc2NyaXB0JywgJ2ZpbGUnLCAnZGF0YScgXTtcbiAgdmFyIHN0ciA9IHVybC50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgLy8gQ2FyZSBhYm91dCBkaWdpdGFsIGVudGl0aWVzIFwiamF2YXNjcmlwdCYjeDNBO2FsZXJ0KDEpXCJcbiAgc3RyID0gdXRpbHMucmVwbGFjZUVudGl0aWVzKHN0cik7XG4gIGlmIChzdHIuaW5kZXhPZignOicpICE9PSAtMSAmJiBCQURfUFJPVE9DT0xTLmluZGV4T2Yoc3RyLnNwbGl0KCc6JylbMF0pICE9PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYFBhcnNlcklubGluZWBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlcklubGluZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpO1xudmFyIHJ1bGVzID0gcmVxdWlyZSgnLi9ydWxlcycpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVuZGVyZXJgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlcjtcblxuLyoqXG4gKiBSZW5kZXJlciBjbGFzcy4gUmVuZGVycyBIVE1MIGFuZCBleHBvc2VzIGBydWxlc2AgdG8gYWxsb3dcbiAqIGxvY2FsIG1vZGlmaWNhdGlvbnMuXG4gKi9cblxuZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG4gIHRoaXMucnVsZXMgPSB1dGlscy5hc3NpZ24oe30sIHJ1bGVzKTtcblxuICAvLyBleHBvcnRlZCBoZWxwZXIsIGZvciBjdXN0b20gcnVsZXMgb25seVxuICB0aGlzLmdldEJyZWFrID0gcnVsZXMuZ2V0QnJlYWs7XG59XG5cbi8qKlxuICogUmVuZGVyIGEgc3RyaW5nIG9mIGlubGluZSBIVE1MIHdpdGggdGhlIGdpdmVuIGB0b2tlbnNgIGFuZFxuICogYG9wdGlvbnNgLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBgdG9rZW5zYFxuICogQHBhcmFtICB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEBwYXJhbSAge09iamVjdH0gYGVudmBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgX3J1bGVzID0gdGhpcy5ydWxlcztcbiAgdmFyIGxlbiA9IHRva2Vucy5sZW5ndGgsIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAgcmVzdWx0ICs9IF9ydWxlc1t0b2tlbnNbaV0udHlwZV0odG9rZW5zLCBpKyssIG9wdGlvbnMsIGVudiwgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZW5kZXIgYSBzdHJpbmcgb2YgSFRNTCB3aXRoIHRoZSBnaXZlbiBgdG9rZW5zYCBhbmRcbiAqIGBvcHRpb25zYC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gYHRva2Vuc2BcbiAqIEBwYXJhbSAge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBlbnZgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIF9ydWxlcyA9IHRoaXMucnVsZXM7XG4gIHZhciBsZW4gPSB0b2tlbnMubGVuZ3RoLCBpID0gLTE7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgaWYgKHRva2Vuc1tpXS50eXBlID09PSAnaW5saW5lJykge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lKHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IF9ydWxlc1t0b2tlbnNbaV0udHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSdWxlciBpcyBhIGhlbHBlciBjbGFzcyBmb3IgYnVpbGRpbmcgcmVzcG9uc2liaWxpdHkgY2hhaW5zIGZyb21cbiAqIHBhcnNlIHJ1bGVzLiBJdCBhbGxvd3M6XG4gKlxuICogICAtIGVhc3kgc3RhY2sgcnVsZXMgY2hhaW5zXG4gKiAgIC0gZ2V0dGluZyBtYWluIGNoYWluIGFuZCBuYW1lZCBjaGFpbnMgY29udGVudCAoYXMgYXJyYXlzIG9mIGZ1bmN0aW9ucylcbiAqXG4gKiBIZWxwZXIgbWV0aG9kcywgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5LlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUnVsZXIoKSB7XG4gIC8vIExpc3Qgb2YgYWRkZWQgcnVsZXMuIEVhY2ggZWxlbWVudCBpczpcbiAgLy9cbiAgLy8geyBuYW1lOiBYWFgsXG4gIC8vICAgZW5hYmxlZDogQm9vbGVhbixcbiAgLy8gICBmbjogRnVuY3Rpb24oKSxcbiAgLy8gICBhbHQ6IFsgbmFtZTIsIG5hbWUzIF0gfVxuICAvL1xuICB0aGlzLl9fcnVsZXNfXyA9IFtdO1xuXG4gIC8vIENhY2hlZCBydWxlIGNoYWlucy5cbiAgLy9cbiAgLy8gRmlyc3QgbGV2ZWwgLSBjaGFpbiBuYW1lLCAnJyBmb3IgZGVmYXVsdC5cbiAgLy8gU2Vjb25kIGxldmVsIC0gZGlnaXRhbCBhbmNob3IgZm9yIGZhc3QgZmlsdGVyaW5nIGJ5IGNoYXJjb2Rlcy5cbiAgLy9cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufVxuXG4vKipcbiAqIEZpbmQgdGhlIGluZGV4IG9mIGEgcnVsZSBieSBgbmFtZWAuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgbmFtZWBcbiAqIEByZXR1cm4ge051bWJlcn0gSW5kZXggb2YgdGhlIGdpdmVuIGBuYW1lYFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUnVsZXIucHJvdG90eXBlLl9fZmluZF9fID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGxlbiA9IHRoaXMuX19ydWxlc19fLmxlbmd0aDtcbiAgdmFyIGkgPSAtMTtcblxuICB3aGlsZSAobGVuLS0pIHtcbiAgICBpZiAodGhpcy5fX3J1bGVzX19bKytpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBCdWlsZCB0aGUgcnVsZXMgbG9va3VwIGNhY2hlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUnVsZXIucHJvdG90eXBlLl9fY29tcGlsZV9fID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjaGFpbnMgPSBbICcnIF07XG5cbiAgLy8gY29sbGVjdCB1bmlxdWUgbmFtZXNcbiAgc2VsZi5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgIGlmICghcnVsZS5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcnVsZS5hbHQuZm9yRWFjaChmdW5jdGlvbiAoYWx0TmFtZSkge1xuICAgICAgaWYgKGNoYWlucy5pbmRleE9mKGFsdE5hbWUpIDwgMCkge1xuICAgICAgICBjaGFpbnMucHVzaChhbHROYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgc2VsZi5fX2NhY2hlX18gPSB7fTtcblxuICBjaGFpbnMuZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICBzZWxmLl9fY2FjaGVfX1tjaGFpbl0gPSBbXTtcbiAgICBzZWxmLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICBpZiAoIXJ1bGUuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFpbiAmJiBydWxlLmFsdC5pbmRleE9mKGNoYWluKSA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dLnB1c2gocnVsZS5mbik7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSdWxlciBwdWJsaWMgbWV0aG9kc1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBSZXBsYWNlIHJ1bGUgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBuYW1lYCBSdWxlIG5hbWVcbiAqIEBwYXJhbSAge0Z1bmN0aW9uIGBmbmBcbiAqIEBwYXJhbSAge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SdWxlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAobmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18obmFtZSk7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpZHggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBuYW1lKTtcbiAgfVxuXG4gIHRoaXMuX19ydWxlc19fW2lkeF0uZm4gPSBmbjtcbiAgdGhpcy5fX3J1bGVzX19baWR4XS5hbHQgPSBvcHQuYWx0IHx8IFtdO1xuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59O1xuXG4vKipcbiAqIEFkZCBhIHJ1bGUgdG8gdGhlIGNoYWluIGJlZm9yZSBnaXZlbiB0aGUgYHJ1bGVOYW1lYC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgYGJlZm9yZU5hbWVgXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgYHJ1bGVOYW1lYFxuICogQHBhcmFtICB7RnVuY3Rpb259IGBmbmBcbiAqIEBwYXJhbSAge09iamVjdH0gICBgb3B0aW9uc2BcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJ1bGVyLnByb3RvdHlwZS5iZWZvcmUgPSBmdW5jdGlvbiAoYmVmb3JlTmFtZSwgcnVsZU5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKGJlZm9yZU5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaWR4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYmVmb3JlTmFtZSk7XG4gIH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaWR4LCAwLCB7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbjogZm4sXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gIH0pO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cbi8qKlxuICogQWRkIGEgcnVsZSB0byB0aGUgY2hhaW4gYWZ0ZXIgdGhlIGdpdmVuIGBydWxlTmFtZWAuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSAgIGBhZnRlck5hbWVgXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgYHJ1bGVOYW1lYFxuICogQHBhcmFtICB7RnVuY3Rpb259IGBmbmBcbiAqIEBwYXJhbSAge09iamVjdH0gICBgb3B0aW9uc2BcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJ1bGVyLnByb3RvdHlwZS5hZnRlciA9IGZ1bmN0aW9uIChhZnRlck5hbWUsIHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaWR4ID0gdGhpcy5fX2ZpbmRfXyhhZnRlck5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaWR4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYWZ0ZXJOYW1lKTtcbiAgfVxuXG4gIHRoaXMuX19ydWxlc19fLnNwbGljZShpZHggKyAxLCAwLCB7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbjogZm4sXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gIH0pO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbn07XG5cbi8qKlxuICogQWRkIGEgcnVsZSB0byB0aGUgZW5kIG9mIGNoYWluLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gICBgcnVsZU5hbWVgXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gYGZuYFxuICogQHBhcmFtICB7T2JqZWN0fSAgIGBvcHRpb25zYFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cblJ1bGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLl9fcnVsZXNfXy5wdXNoKHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBFbmFibGUgYSBydWxlIG9yIGxpc3Qgb2YgcnVsZXMuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBgbGlzdGAgTmFtZSBvciBhcnJheSBvZiBydWxlIG5hbWVzIHRvIGVuYWJsZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gYHN0cmljdGAgSWYgYHRydWVgLCBhbGwgbm9uIGxpc3RlZCBydWxlcyB3aWxsIGJlIGRpc2FibGVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUnVsZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBzdHJpY3QpIHtcbiAgbGlzdCA9ICFBcnJheS5pc0FycmF5KGxpc3QpXG4gICAgPyBbIGxpc3QgXVxuICAgIDogbGlzdDtcblxuICAvLyBJbiBzdHJpY3QgbW9kZSBkaXNhYmxlIGFsbCBleGlzdGluZyBydWxlcyBmaXJzdFxuICBpZiAoc3RyaWN0KSB7XG4gICAgdGhpcy5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgcnVsZS5lbmFibGVkID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cblxuICAvLyBTZWFyY2ggYnkgbmFtZSBhbmQgZW5hYmxlXG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fX3J1bGVzX19baWR4XS5lbmFibGVkID0gdHJ1ZTtcbiAgfSwgdGhpcyk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIERpc2FibGUgYSBydWxlIG9yIGxpc3Qgb2YgcnVsZXMuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBgbGlzdGAgTmFtZSBvciBhcnJheSBvZiBydWxlIG5hbWVzIHRvIGRpc2FibGVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJ1bGVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgbGlzdCA9ICFBcnJheS5pc0FycmF5KGxpc3QpXG4gICAgPyBbIGxpc3QgXVxuICAgIDogbGlzdDtcblxuICAvLyBTZWFyY2ggYnkgbmFtZSBhbmQgZGlzYWJsZVxuICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fX2ZpbmRfXyhuYW1lKTtcbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IGZhbHNlO1xuICB9LCB0aGlzKTtcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59O1xuXG4vKipcbiAqIEdldCBhIHJ1bGVzIGxpc3QgYXMgYW4gYXJyYXkgb2YgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gYGNoYWluTmFtZWBcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJ1bGVyLnByb3RvdHlwZS5nZXRSdWxlcyA9IGZ1bmN0aW9uIChjaGFpbk5hbWUpIHtcbiAgaWYgKHRoaXMuX19jYWNoZV9fID09PSBudWxsKSB7XG4gICAgdGhpcy5fX2NvbXBpbGVfXygpO1xuICB9XG4gIHJldHVybiB0aGlzLl9fY2FjaGVfX1tjaGFpbk5hbWVdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJ1bGVyYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUnVsZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTG9jYWwgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGhhcyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykuaGFzO1xudmFyIHVuZXNjYXBlTWQgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVNZDtcbnZhciByZXBsYWNlRW50aXRpZXMgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLnJlcGxhY2VFbnRpdGllcztcbnZhciBlc2NhcGVIdG1sICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLmVzY2FwZUh0bWw7XG5cbi8qKlxuICogUmVuZGVyZXIgcnVsZXMgY2FjaGVcbiAqL1xuXG52YXIgcnVsZXMgPSB7fTtcblxuLyoqXG4gKiBCbG9ja3F1b3Rlc1xuICovXG5cbnJ1bGVzLmJsb2NrcXVvdGVfb3BlbiA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8YmxvY2txdW90ZT5cXG4nO1xufTtcblxucnVsZXMuYmxvY2txdW90ZV9jbG9zZSA9IGZ1bmN0aW9uKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8L2Jsb2NrcXVvdGU+JyArIGdldEJyZWFrKHRva2VucywgaWR4KTtcbn07XG5cbi8qKlxuICogQ29kZVxuICovXG5cbnJ1bGVzLmNvZGUgPSBmdW5jdGlvbih0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIGlmICh0b2tlbnNbaWR4XS5ibG9jaykge1xuICAgIHJldHVybiAnPHByZT48Y29kZT4nICsgZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KSArICc8L2NvZGU+PC9wcmU+JyArIGdldEJyZWFrKHRva2VucywgaWR4KTtcbiAgfVxuICByZXR1cm4gJzxjb2RlPicgKyBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpICsgJzwvY29kZT4nO1xufTtcblxuLyoqXG4gKiBGZW5jZWQgY29kZSBibG9ja3NcbiAqL1xuXG5ydWxlcy5mZW5jZSA9IGZ1bmN0aW9uKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIGluc3RhbmNlKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuICB2YXIgbGFuZ0NsYXNzID0gJyc7XG4gIHZhciBsYW5nUHJlZml4ID0gb3B0aW9ucy5sYW5nUHJlZml4O1xuICB2YXIgbGFuZ05hbWUgPSAnJywgZmVuY2VzLCBmZW5jZU5hbWU7XG4gIHZhciBoaWdobGlnaHRlZDtcblxuICBpZiAodG9rZW4ucGFyYW1zKSB7XG5cbiAgICAvL1xuICAgIC8vIGBgYGZvbyBiYXJcbiAgICAvL1xuICAgIC8vIFRyeSBjdXN0b20gcmVuZGVyZXIgXCJmb29cIiBmaXJzdC4gVGhhdCB3aWxsIHNpbXBsaWZ5IG92ZXJ3cml0ZVxuICAgIC8vIGZvciBkaWFncmFtcywgbGF0ZXgsIGFuZCBhbnkgb3RoZXIgZmVuY2VkIGJsb2NrIHdpdGggY3VzdG9tIGxvb2tcbiAgICAvL1xuXG4gICAgZmVuY2VzID0gdG9rZW4ucGFyYW1zLnNwbGl0KC9cXHMrL2cpO1xuICAgIGZlbmNlTmFtZSA9IGZlbmNlcy5qb2luKCcgJyk7XG5cbiAgICBpZiAoaGFzKGluc3RhbmNlLnJ1bGVzLmZlbmNlX2N1c3RvbSwgZmVuY2VzWzBdKSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnJ1bGVzLmZlbmNlX2N1c3RvbVtmZW5jZXNbMF1dKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBsYW5nTmFtZSA9IGVzY2FwZUh0bWwocmVwbGFjZUVudGl0aWVzKHVuZXNjYXBlTWQoZmVuY2VOYW1lKSkpO1xuICAgIGxhbmdDbGFzcyA9ICcgY2xhc3M9XCInICsgbGFuZ1ByZWZpeCArIGxhbmdOYW1lICsgJ1wiJztcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhpZ2hsaWdodCkge1xuICAgIGhpZ2hsaWdodGVkID0gb3B0aW9ucy5oaWdobGlnaHQuYXBwbHkob3B0aW9ucy5oaWdobGlnaHQsIFsgdG9rZW4uY29udGVudCBdLmNvbmNhdChmZW5jZXMpKVxuICAgICAgfHwgZXNjYXBlSHRtbCh0b2tlbi5jb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBoaWdobGlnaHRlZCA9IGVzY2FwZUh0bWwodG9rZW4uY29udGVudCk7XG4gIH1cblxuICByZXR1cm4gJzxwcmU+PGNvZGUnICsgbGFuZ0NsYXNzICsgJz4nXG4gICAgICAgICsgaGlnaGxpZ2h0ZWRcbiAgICAgICAgKyAnPC9jb2RlPjwvcHJlPidcbiAgICAgICAgKyBnZXRCcmVhayh0b2tlbnMsIGlkeCk7XG59O1xuXG5ydWxlcy5mZW5jZV9jdXN0b20gPSB7fTtcblxuLyoqXG4gKiBIZWFkaW5nc1xuICovXG5cbnJ1bGVzLmhlYWRpbmdfb3BlbiA9IGZ1bmN0aW9uKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8aCcgKyB0b2tlbnNbaWR4XS5oTGV2ZWwgKyAnPic7XG59O1xucnVsZXMuaGVhZGluZ19jbG9zZSA9IGZ1bmN0aW9uKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8L2gnICsgdG9rZW5zW2lkeF0uaExldmVsICsgJz5cXG4nO1xufTtcblxuLyoqXG4gKiBIb3Jpem9udGFsIHJ1bGVzXG4gKi9cblxucnVsZXMuaHIgPSBmdW5jdGlvbih0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHJldHVybiAob3B0aW9ucy54aHRtbE91dCA/ICc8aHIgLz4nIDogJzxocj4nKSArIGdldEJyZWFrKHRva2VucywgaWR4KTtcbn07XG5cbi8qKlxuICogQnVsbGV0c1xuICovXG5cbnJ1bGVzLmJ1bGxldF9saXN0X29wZW4gPSBmdW5jdGlvbigvKiB0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPHVsPlxcbic7XG59O1xucnVsZXMuYnVsbGV0X2xpc3RfY2xvc2UgPSBmdW5jdGlvbih0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPC91bD4nICsgZ2V0QnJlYWsodG9rZW5zLCBpZHgpO1xufTtcblxuLyoqXG4gKiBMaXN0IGl0ZW1zXG4gKi9cblxucnVsZXMubGlzdF9pdGVtX29wZW4gPSBmdW5jdGlvbigvKiB0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPGxpPic7XG59O1xucnVsZXMubGlzdF9pdGVtX2Nsb3NlID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzwvbGk+XFxuJztcbn07XG5cbi8qKlxuICogT3JkZXJlZCBsaXN0IGl0ZW1zXG4gKi9cblxucnVsZXMub3JkZXJlZF9saXN0X29wZW4gPSBmdW5jdGlvbih0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuICB2YXIgb3JkZXIgPSB0b2tlbi5vcmRlciA+IDEgPyAnIHN0YXJ0PVwiJyArIHRva2VuLm9yZGVyICsgJ1wiJyA6ICcnO1xuICByZXR1cm4gJzxvbCcgKyBvcmRlciArICc+XFxuJztcbn07XG5ydWxlcy5vcmRlcmVkX2xpc3RfY2xvc2UgPSBmdW5jdGlvbih0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPC9vbD4nICsgZ2V0QnJlYWsodG9rZW5zLCBpZHgpO1xufTtcblxuLyoqXG4gKiBQYXJhZ3JhcGhzXG4gKi9cblxucnVsZXMucGFyYWdyYXBoX29wZW4gPSBmdW5jdGlvbih0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiB0b2tlbnNbaWR4XS50aWdodCA/ICcnIDogJzxwPic7XG59O1xucnVsZXMucGFyYWdyYXBoX2Nsb3NlID0gZnVuY3Rpb24odG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICB2YXIgYWRkQnJlYWsgPSAhKHRva2Vuc1tpZHhdLnRpZ2h0ICYmIGlkeCAmJiB0b2tlbnNbaWR4IC0gMV0udHlwZSA9PT0gJ2lubGluZScgJiYgIXRva2Vuc1tpZHggLSAxXS5jb250ZW50KTtcbiAgcmV0dXJuICh0b2tlbnNbaWR4XS50aWdodCA/ICcnIDogJzwvcD4nKSArIChhZGRCcmVhayA/IGdldEJyZWFrKHRva2VucywgaWR4KSA6ICcnKTtcbn07XG5cbi8qKlxuICogTGlua3NcbiAqL1xuXG5ydWxlcy5saW5rX29wZW4gPSBmdW5jdGlvbih0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiBlbnYgKi8pIHtcbiAgdmFyIHRpdGxlID0gdG9rZW5zW2lkeF0udGl0bGUgPyAoJyB0aXRsZT1cIicgKyBlc2NhcGVIdG1sKHJlcGxhY2VFbnRpdGllcyh0b2tlbnNbaWR4XS50aXRsZSkpICsgJ1wiJykgOiAnJztcbiAgdmFyIHRhcmdldCA9IG9wdGlvbnMubGlua1RhcmdldCA/ICgnIHRhcmdldD1cIicgKyBvcHRpb25zLmxpbmtUYXJnZXQgKyAnXCInKSA6ICcnO1xuICByZXR1cm4gJzxhIGhyZWY9XCInICsgZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5ocmVmKSArICdcIicgKyB0aXRsZSArIHRhcmdldCArICc+Jztcbn07XG5ydWxlcy5saW5rX2Nsb3NlID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzwvYT4nO1xufTtcblxuLyoqXG4gKiBJbWFnZXNcbiAqL1xuXG5ydWxlcy5pbWFnZSA9IGZ1bmN0aW9uKHRva2VucywgaWR4LCBvcHRpb25zIC8qLCBlbnYgKi8pIHtcbiAgdmFyIHNyYyA9ICcgc3JjPVwiJyArIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uc3JjKSArICdcIic7XG4gIHZhciB0aXRsZSA9IHRva2Vuc1tpZHhdLnRpdGxlID8gKCcgdGl0bGU9XCInICsgZXNjYXBlSHRtbChyZXBsYWNlRW50aXRpZXModG9rZW5zW2lkeF0udGl0bGUpKSArICdcIicpIDogJyc7XG4gIHZhciBhbHQgPSAnIGFsdD1cIicgKyAodG9rZW5zW2lkeF0uYWx0ID8gZXNjYXBlSHRtbChyZXBsYWNlRW50aXRpZXModW5lc2NhcGVNZCh0b2tlbnNbaWR4XS5hbHQpKSkgOiAnJykgKyAnXCInO1xuICB2YXIgc3VmZml4ID0gb3B0aW9ucy54aHRtbE91dCA/ICcgLycgOiAnJztcbiAgcmV0dXJuICc8aW1nJyArIHNyYyArIGFsdCArIHRpdGxlICsgc3VmZml4ICsgJz4nO1xufTtcblxuLyoqXG4gKiBUYWJsZXNcbiAqL1xuXG5ydWxlcy50YWJsZV9vcGVuID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzx0YWJsZT5cXG4nO1xufTtcbnJ1bGVzLnRhYmxlX2Nsb3NlID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzwvdGFibGU+XFxuJztcbn07XG5ydWxlcy50aGVhZF9vcGVuID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzx0aGVhZD5cXG4nO1xufTtcbnJ1bGVzLnRoZWFkX2Nsb3NlID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzwvdGhlYWQ+XFxuJztcbn07XG5ydWxlcy50Ym9keV9vcGVuID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzx0Ym9keT5cXG4nO1xufTtcbnJ1bGVzLnRib2R5X2Nsb3NlID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzwvdGJvZHk+XFxuJztcbn07XG5ydWxlcy50cl9vcGVuID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzx0cj4nO1xufTtcbnJ1bGVzLnRyX2Nsb3NlID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzwvdHI+XFxuJztcbn07XG5ydWxlcy50aF9vcGVuID0gZnVuY3Rpb24odG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcbiAgcmV0dXJuICc8dGgnXG4gICAgKyAodG9rZW4uYWxpZ24gPyAnIHN0eWxlPVwidGV4dC1hbGlnbjonICsgdG9rZW4uYWxpZ24gKyAnXCInIDogJycpXG4gICAgKyAnPic7XG59O1xucnVsZXMudGhfY2xvc2UgPSBmdW5jdGlvbigvKiB0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPC90aD4nO1xufTtcbnJ1bGVzLnRkX29wZW4gPSBmdW5jdGlvbih0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuICByZXR1cm4gJzx0ZCdcbiAgICArICh0b2tlbi5hbGlnbiA/ICcgc3R5bGU9XCJ0ZXh0LWFsaWduOicgKyB0b2tlbi5hbGlnbiArICdcIicgOiAnJylcbiAgICArICc+Jztcbn07XG5ydWxlcy50ZF9jbG9zZSA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8L3RkPic7XG59O1xuXG4vKipcbiAqIEJvbGRcbiAqL1xuXG5ydWxlcy5zdHJvbmdfb3BlbiA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8c3Ryb25nPic7XG59O1xucnVsZXMuc3Ryb25nX2Nsb3NlID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzwvc3Ryb25nPic7XG59O1xuXG4vKipcbiAqIEl0YWxpY2l6ZVxuICovXG5cbnJ1bGVzLmVtX29wZW4gPSBmdW5jdGlvbigvKiB0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPGVtPic7XG59O1xucnVsZXMuZW1fY2xvc2UgPSBmdW5jdGlvbigvKiB0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPC9lbT4nO1xufTtcblxuLyoqXG4gKiBTdHJpa2V0aHJvdWdoXG4gKi9cblxucnVsZXMuZGVsX29wZW4gPSBmdW5jdGlvbigvKiB0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPGRlbD4nO1xufTtcbnJ1bGVzLmRlbF9jbG9zZSA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8L2RlbD4nO1xufTtcblxuLyoqXG4gKiBJbnNlcnRcbiAqL1xuXG5ydWxlcy5pbnNfb3BlbiA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8aW5zPic7XG59O1xucnVsZXMuaW5zX2Nsb3NlID0gZnVuY3Rpb24oLyogdG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzwvaW5zPic7XG59O1xuXG4vKipcbiAqIEhpZ2hsaWdodFxuICovXG5cbnJ1bGVzLm1hcmtfb3BlbiA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8bWFyaz4nO1xufTtcbnJ1bGVzLm1hcmtfY2xvc2UgPSBmdW5jdGlvbigvKiB0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiAnPC9tYXJrPic7XG59O1xuXG4vKipcbiAqIFN1cGVyLSBhbmQgc3ViLXNjcmlwdFxuICovXG5cbnJ1bGVzLnN1YiA9IGZ1bmN0aW9uKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8c3ViPicgKyBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpICsgJzwvc3ViPic7XG59O1xucnVsZXMuc3VwID0gZnVuY3Rpb24odG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gJzxzdXA+JyArIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgKyAnPC9zdXA+Jztcbn07XG5cbi8qKlxuICogQnJlYWtzXG4gKi9cblxucnVsZXMuaGFyZGJyZWFrID0gZnVuY3Rpb24odG9rZW5zLCBpZHgsIG9wdGlvbnMgLyosIGVudiAqLykge1xuICByZXR1cm4gb3B0aW9ucy54aHRtbE91dCA/ICc8YnIgLz5cXG4nIDogJzxicj5cXG4nO1xufTtcbnJ1bGVzLnNvZnRicmVhayA9IGZ1bmN0aW9uKHRva2VucywgaWR4LCBvcHRpb25zIC8qLCBlbnYgKi8pIHtcbiAgcmV0dXJuIG9wdGlvbnMuYnJlYWtzID8gKG9wdGlvbnMueGh0bWxPdXQgPyAnPGJyIC8+XFxuJyA6ICc8YnI+XFxuJykgOiAnXFxuJztcbn07XG5cbi8qKlxuICogVGV4dFxuICovXG5cbnJ1bGVzLnRleHQgPSBmdW5jdGlvbih0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpO1xufTtcblxuLyoqXG4gKiBDb250ZW50XG4gKi9cblxucnVsZXMuaHRtbGJsb2NrID0gZnVuY3Rpb24odG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gdG9rZW5zW2lkeF0uY29udGVudDtcbn07XG5ydWxlcy5odG1sdGFnID0gZnVuY3Rpb24odG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gdG9rZW5zW2lkeF0uY29udGVudDtcbn07XG5cbi8qKlxuICogQWJicmV2aWF0aW9ucywgaW5pdGlhbGlzbVxuICovXG5cbnJ1bGVzLmFiYnJfb3BlbiA9IGZ1bmN0aW9uKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8YWJiciB0aXRsZT1cIicgKyBlc2NhcGVIdG1sKHJlcGxhY2VFbnRpdGllcyh0b2tlbnNbaWR4XS50aXRsZSkpICsgJ1wiPic7XG59O1xucnVsZXMuYWJicl9jbG9zZSA9IGZ1bmN0aW9uKC8qIHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuICc8L2FiYnI+Jztcbn07XG5cbi8qKlxuICogRm9vdG5vdGVzXG4gKi9cblxucnVsZXMuZm9vdG5vdGVfcmVmID0gZnVuY3Rpb24odG9rZW5zLCBpZHgpIHtcbiAgdmFyIG4gPSBOdW1iZXIodG9rZW5zW2lkeF0uaWQgKyAxKS50b1N0cmluZygpO1xuICB2YXIgaWQgPSAnZm5yZWYnICsgbjtcbiAgaWYgKHRva2Vuc1tpZHhdLnN1YklkID4gMCkge1xuICAgIGlkICs9ICc6JyArIHRva2Vuc1tpZHhdLnN1YklkO1xuICB9XG4gIHJldHVybiAnPHN1cCBjbGFzcz1cImZvb3Rub3RlLXJlZlwiPjxhIGhyZWY9XCIjZm4nICsgbiArICdcIiBpZD1cIicgKyBpZCArICdcIj5bJyArIG4gKyAnXTwvYT48L3N1cD4nO1xufTtcbnJ1bGVzLmZvb3Rub3RlX2Jsb2NrX29wZW4gPSBmdW5jdGlvbih0b2tlbnMsIGlkeCwgb3B0aW9ucykge1xuICB2YXIgaHIgPSBvcHRpb25zLnhodG1sT3V0XG4gICAgPyAnPGhyIGNsYXNzPVwiZm9vdG5vdGVzLXNlcFwiIC8+XFxuJ1xuICAgIDogJzxociBjbGFzcz1cImZvb3Rub3Rlcy1zZXBcIj5cXG4nO1xuICByZXR1cm4gaHIgKyAnPHNlY3Rpb24gY2xhc3M9XCJmb290bm90ZXNcIj5cXG48b2wgY2xhc3M9XCJmb290bm90ZXMtbGlzdFwiPlxcbic7XG59O1xucnVsZXMuZm9vdG5vdGVfYmxvY2tfY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICc8L29sPlxcbjwvc2VjdGlvbj5cXG4nO1xufTtcbnJ1bGVzLmZvb3Rub3RlX29wZW4gPSBmdW5jdGlvbih0b2tlbnMsIGlkeCkge1xuICB2YXIgaWQgPSBOdW1iZXIodG9rZW5zW2lkeF0uaWQgKyAxKS50b1N0cmluZygpO1xuICByZXR1cm4gJzxsaSBpZD1cImZuJyArIGlkICsgJ1wiICBjbGFzcz1cImZvb3Rub3RlLWl0ZW1cIj4nO1xufTtcbnJ1bGVzLmZvb3Rub3RlX2Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnPC9saT5cXG4nO1xufTtcbnJ1bGVzLmZvb3Rub3RlX2FuY2hvciA9IGZ1bmN0aW9uKHRva2VucywgaWR4KSB7XG4gIHZhciBuID0gTnVtYmVyKHRva2Vuc1tpZHhdLmlkICsgMSkudG9TdHJpbmcoKTtcbiAgdmFyIGlkID0gJ2ZucmVmJyArIG47XG4gIGlmICh0b2tlbnNbaWR4XS5zdWJJZCA+IDApIHtcbiAgICBpZCArPSAnOicgKyB0b2tlbnNbaWR4XS5zdWJJZDtcbiAgfVxuICByZXR1cm4gJyA8YSBocmVmPVwiIycgKyBpZCArICdcIiBjbGFzcz1cImZvb3Rub3RlLWJhY2tyZWZcIj7ihqk8L2E+Jztcbn07XG5cbi8qKlxuICogRGVmaW5pdGlvbiBsaXN0c1xuICovXG5cbnJ1bGVzLmRsX29wZW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICc8ZGw+XFxuJztcbn07XG5ydWxlcy5kdF9vcGVuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnPGR0Pic7XG59O1xucnVsZXMuZGRfb3BlbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJzxkZD4nO1xufTtcbnJ1bGVzLmRsX2Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnPC9kbD5cXG4nO1xufTtcbnJ1bGVzLmR0X2Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnPC9kdD5cXG4nO1xufTtcbnJ1bGVzLmRkX2Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnPC9kZD5cXG4nO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb25zXG4gKi9cblxuZnVuY3Rpb24gbmV4dFRva2VuKHRva2VucywgaWR4KSB7XG4gIGlmICgrK2lkeCA+PSB0b2tlbnMubGVuZ3RoIC0gMikge1xuICAgIHJldHVybiBpZHg7XG4gIH1cbiAgaWYgKCh0b2tlbnNbaWR4XS50eXBlID09PSAncGFyYWdyYXBoX29wZW4nICYmIHRva2Vuc1tpZHhdLnRpZ2h0KSAmJlxuICAgICAgKHRva2Vuc1tpZHggKyAxXS50eXBlID09PSAnaW5saW5lJyAmJiB0b2tlbnNbaWR4ICsgMV0uY29udGVudC5sZW5ndGggPT09IDApICYmXG4gICAgICAodG9rZW5zW2lkeCArIDJdLnR5cGUgPT09ICdwYXJhZ3JhcGhfY2xvc2UnICYmIHRva2Vuc1tpZHggKyAyXS50aWdodCkpIHtcbiAgICByZXR1cm4gbmV4dFRva2VuKHRva2VucywgaWR4ICsgMik7XG4gIH1cbiAgcmV0dXJuIGlkeDtcbn1cblxuLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgYFxcbmAgaXMgbmVlZGVkIGJlZm9yZSB0aGUgbmV4dCB0b2tlbi5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gYHRva2Vuc2BcbiAqIEBwYXJhbSAge051bWJlcn0gYGlkeGBcbiAqIEByZXR1cm4ge1N0cmluZ30gRW1wdHkgc3RyaW5nIG9yIG5ld2xpbmVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBnZXRCcmVhayA9IHJ1bGVzLmdldEJyZWFrID0gZnVuY3Rpb24gZ2V0QnJlYWsodG9rZW5zLCBpZHgpIHtcbiAgaWR4ID0gbmV4dFRva2VuKHRva2VucywgaWR4KTtcbiAgaWYgKGlkeCA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2lkeF0udHlwZSA9PT0gJ2xpc3RfaXRlbV9jbG9zZScpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuICdcXG4nO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYHJ1bGVzYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcnVsZXM7XG4iLCIvLyBCbG9jayBxdW90ZXNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2txdW90ZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIG5leHRMaW5lLCBsYXN0TGluZUVtcHR5LCBvbGRUU2hpZnQsIG9sZEJNYXJrcywgb2xkSW5kZW50LCBvbGRQYXJlbnRUeXBlLCBsaW5lcyxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIGksIGwsIHRlcm1pbmF0ZSxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICBpZiAocG9zID4gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNoZWNrIHRoZSBibG9jayBxdW90ZSBtYXJrZXJcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSAhPT0gMHgzRS8qID4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHN0YXRlLmxldmVsID49IHN0YXRlLm9wdGlvbnMubWF4TmVzdGluZykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyB3ZSBrbm93IHRoYXQgaXQncyBnb2luZyB0byBiZSBhIHZhbGlkIGJsb2NrcXVvdGUsXG4gIC8vIHNvIG5vIHBvaW50IHRyeWluZyB0byBmaW5kIHRoZSBlbmQgb2YgaXQgaW4gc2lsZW50IG1vZGVcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIHNraXAgb25lIG9wdGlvbmFsIHNwYWNlIGFmdGVyICc+J1xuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCkgeyBwb3MrKzsgfVxuXG4gIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgc3RhdGUuYmxrSW5kZW50ID0gMDtcblxuICBvbGRCTWFya3MgPSBbIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdIF07XG4gIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdID0gcG9zO1xuXG4gIC8vIGNoZWNrIGlmIHdlIGhhdmUgYW4gZW1wdHkgYmxvY2txdW90ZVxuICBwb3MgPSBwb3MgPCBtYXggPyBzdGF0ZS5za2lwU3BhY2VzKHBvcykgOiBwb3M7XG4gIGxhc3RMaW5lRW1wdHkgPSBwb3MgPj0gbWF4O1xuXG4gIG9sZFRTaGlmdCA9IFsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBwb3MgLSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcblxuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5wYXJzZXIucnVsZXIuZ2V0UnVsZXMoJ2Jsb2NrcXVvdGUnKTtcblxuICAvLyBTZWFyY2ggdGhlIGVuZCBvZiB0aGUgYmxvY2tcbiAgLy9cbiAgLy8gQmxvY2sgZW5kcyB3aXRoIGVpdGhlcjpcbiAgLy8gIDEuIGFuIGVtcHR5IGxpbmUgb3V0c2lkZTpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPiB0ZXN0XG4gIC8vXG4gIC8vICAgICBgYGBcbiAgLy8gIDIuIGFuIGVtcHR5IGxpbmUgaW5zaWRlOlxuICAvLyAgICAgYGBgXG4gIC8vICAgICA+XG4gIC8vICAgICB0ZXN0XG4gIC8vICAgICBgYGBcbiAgLy8gIDMuIGFub3RoZXIgdGFnXG4gIC8vICAgICBgYGBcbiAgLy8gICAgID4gdGVzdFxuICAvLyAgICAgIC0gLSAtXG4gIC8vICAgICBgYGBcbiAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpZiAocG9zID49IG1heCkge1xuICAgICAgLy8gQ2FzZSAxOiBsaW5lIGlzIG5vdCBpbnNpZGUgdGhlIGJsb2NrcXVvdGUsIGFuZCB0aGlzIGxpbmUgaXMgZW1wdHkuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspID09PSAweDNFLyogPiAqLykge1xuICAgICAgLy8gVGhpcyBsaW5lIGlzIGluc2lkZSB0aGUgYmxvY2txdW90ZS5cblxuICAgICAgLy8gc2tpcCBvbmUgb3B0aW9uYWwgc3BhY2UgYWZ0ZXIgJz4nXG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCkgeyBwb3MrKzsgfVxuXG4gICAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gPSBwb3M7XG5cbiAgICAgIHBvcyA9IHBvcyA8IG1heCA/IHN0YXRlLnNraXBTcGFjZXMocG9zKSA6IHBvcztcbiAgICAgIGxhc3RMaW5lRW1wdHkgPSBwb3MgPj0gbWF4O1xuXG4gICAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLnRTaGlmdFtuZXh0TGluZV0gPSBwb3MgLSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQ2FzZSAyOiBsaW5lIGlzIG5vdCBpbnNpZGUgdGhlIGJsb2NrcXVvdGUsIGFuZCB0aGUgbGFzdCBsaW5lIHdhcyBlbXB0eS5cbiAgICBpZiAobGFzdExpbmVFbXB0eSkgeyBicmVhazsgfVxuXG4gICAgLy8gQ2FzZSAzOiBhbm90aGVyIHRhZyBmb3VuZC5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG5cbiAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcblxuICAgIC8vIEEgbmVnYXRpdmUgbnVtYmVyIG1lYW5zIHRoYXQgdGhpcyBpcyBhIHBhcmFncmFwaCBjb250aW51YXRpb247XG4gICAgLy9cbiAgICAvLyBBbnkgbmVnYXRpdmUgbnVtYmVyIHdpbGwgZG8gdGhlIGpvYiBoZXJlLCBidXQgaXQncyBiZXR0ZXIgZm9yIGl0XG4gICAgLy8gdG8gYmUgbGFyZ2UgZW5vdWdoIHRvIG1ha2UgYW55IGJ1Z3Mgb2J2aW91cy5cbiAgICBzdGF0ZS50U2hpZnRbbmV4dExpbmVdID0gLTEzMzc7XG4gIH1cblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdibG9ja3F1b3RlJztcbiAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgIHR5cGU6ICdibG9ja3F1b3RlX29wZW4nLFxuICAgIGxpbmVzOiBsaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF0sXG4gICAgbGV2ZWw6IHN0YXRlLmxldmVsKytcbiAgfSk7XG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBuZXh0TGluZSk7XG4gIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiAnYmxvY2txdW90ZV9jbG9zZScsXG4gICAgbGV2ZWw6IC0tc3RhdGUubGV2ZWxcbiAgfSk7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuICBsaW5lc1sxXSA9IHN0YXRlLmxpbmU7XG5cbiAgLy8gUmVzdG9yZSBvcmlnaW5hbCB0U2hpZnQ7IHRoaXMgbWlnaHQgbm90IGJlIG5lY2Vzc2FyeSBzaW5jZSB0aGUgcGFyc2VyXG4gIC8vIGhhcyBhbHJlYWR5IGJlZW4gaGVyZSwgYnV0IGp1c3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBkbyB0aGF0LlxuICBmb3IgKGkgPSAwOyBpIDwgb2xkVFNoaWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3RhdGUuYk1hcmtzW2kgKyBzdGFydExpbmVdID0gb2xkQk1hcmtzW2ldO1xuICAgIHN0YXRlLnRTaGlmdFtpICsgc3RhcnRMaW5lXSA9IG9sZFRTaGlmdFtpXTtcbiAgfVxuICBzdGF0ZS5ibGtJbmRlbnQgPSBvbGRJbmRlbnQ7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gQ29kZSBibG9jayAoNCBzcGFjZXMgcGFkZGVkKVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb2RlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUvKiwgc2lsZW50Ki8pIHtcbiAgdmFyIG5leHRMaW5lLCBsYXN0O1xuXG4gIGlmIChzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA8IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFzdCA9IG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgaWYgKHN0YXRlLmlzRW1wdHkobmV4dExpbmUpKSB7XG4gICAgICBuZXh0TGluZSsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzdGF0ZS50U2hpZnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgIG5leHRMaW5lKys7XG4gICAgICBsYXN0ID0gbmV4dExpbmU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG4gIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiAnY29kZScsXG4gICAgY29udGVudDogc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBsYXN0LCA0ICsgc3RhdGUuYmxrSW5kZW50LCB0cnVlKSxcbiAgICBibG9jazogdHJ1ZSxcbiAgICBsaW5lczogWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXSxcbiAgICBsZXZlbDogc3RhdGUubGV2ZWxcbiAgfSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gRGVmaW5pdGlvbiBsaXN0c1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gU2VhcmNoIGBbOn5dW1xcbiBdYCwgcmV0dXJucyBuZXh0IHBvcyBhZnRlciBtYXJrZXIgb24gc3VjY2Vzc1xuLy8gb3IgLTEgb24gZmFpbC5cbmZ1bmN0aW9uIHNraXBNYXJrZXIoc3RhdGUsIGxpbmUpIHtcbiAgdmFyIHBvcywgbWFya2VyLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5iTWFya3NbbGluZV0gKyBzdGF0ZS50U2hpZnRbbGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbGluZV07XG5cbiAgaWYgKHN0YXJ0ID49IG1heCkgeyByZXR1cm4gLTE7IH1cblxuICAvLyBDaGVjayBidWxsZXRcbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQrKyk7XG4gIGlmIChtYXJrZXIgIT09IDB4N0UvKiB+ICovICYmIG1hcmtlciAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIC0xOyB9XG5cbiAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhzdGFydCk7XG5cbiAgLy8gcmVxdWlyZSBzcGFjZSBhZnRlciBcIjpcIlxuICBpZiAoc3RhcnQgPT09IHBvcykgeyByZXR1cm4gLTE7IH1cblxuICAvLyBubyBlbXB0eSBkZWZpbml0aW9ucywgZS5nLiBcIiAgOiBcIlxuICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gLTE7IH1cblxuICByZXR1cm4gcG9zO1xufVxuXG5mdW5jdGlvbiBtYXJrVGlnaHRQYXJhZ3JhcGhzKHN0YXRlLCBpZHgpIHtcbiAgdmFyIGksIGwsXG4gICAgICBsZXZlbCA9IHN0YXRlLmxldmVsICsgMjtcblxuICBmb3IgKGkgPSBpZHggKyAyLCBsID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDI7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoc3RhdGUudG9rZW5zW2ldLmxldmVsID09PSBsZXZlbCAmJiBzdGF0ZS50b2tlbnNbaV0udHlwZSA9PT0gJ3BhcmFncmFwaF9vcGVuJykge1xuICAgICAgc3RhdGUudG9rZW5zW2kgKyAyXS50aWdodCA9IHRydWU7XG4gICAgICBzdGF0ZS50b2tlbnNbaV0udGlnaHQgPSB0cnVlO1xuICAgICAgaSArPSAyO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmxpc3Qoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjb250ZW50U3RhcnQsXG4gICAgICBkZExpbmUsXG4gICAgICBkdExpbmUsXG4gICAgICBpdGVtTGluZXMsXG4gICAgICBsaXN0TGluZXMsXG4gICAgICBsaXN0VG9rSWR4LFxuICAgICAgbmV4dExpbmUsXG4gICAgICBvbGRJbmRlbnQsXG4gICAgICBvbGREREluZGVudCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICBvbGRUU2hpZnQsXG4gICAgICBvbGRUaWdodCxcbiAgICAgIHByZXZFbXB0eUVuZCxcbiAgICAgIHRpZ2h0O1xuXG4gIGlmIChzaWxlbnQpIHtcbiAgICAvLyBxdWlyazogdmFsaWRhdGlvbiBtb2RlIHZhbGlkYXRlcyBhIGRkIGJsb2NrIG9ubHksIG5vdCBhIHdob2xlIGRlZmxpc3RcbiAgICBpZiAoc3RhdGUuZGRJbmRlbnQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJldHVybiBza2lwTWFya2VyKHN0YXRlLCBzdGFydExpbmUpID49IDA7XG4gIH1cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG4gIGlmIChzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKSkge1xuICAgIGlmICgrK25leHRMaW5lID4gZW5kTGluZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgfVxuXG4gIGlmIChzdGF0ZS50U2hpZnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IHJldHVybiBmYWxzZTsgfVxuICBjb250ZW50U3RhcnQgPSBza2lwTWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XG4gIGlmIChjb250ZW50U3RhcnQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzdGF0ZS5sZXZlbCA+PSBzdGF0ZS5vcHRpb25zLm1heE5lc3RpbmcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gU3RhcnQgbGlzdFxuICBsaXN0VG9rSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aDtcblxuICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJ2RsX29wZW4nLFxuICAgIGxpbmVzOiBsaXN0TGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdLFxuICAgIGxldmVsOiBzdGF0ZS5sZXZlbCsrXG4gIH0pO1xuXG4gIC8vXG4gIC8vIEl0ZXJhdGUgbGlzdCBpdGVtc1xuICAvL1xuXG4gIGR0TGluZSA9IHN0YXJ0TGluZTtcbiAgZGRMaW5lID0gbmV4dExpbmU7XG5cbiAgLy8gT25lIGRlZmluaXRpb24gbGlzdCBjYW4gY29udGFpbiBtdWx0aXBsZSBEVHMsXG4gIC8vIGFuZCBvbmUgRFQgY2FuIGJlIGZvbGxvd2VkIGJ5IG11bHRpcGxlIEREcy5cbiAgLy9cbiAgLy8gVGh1cywgdGhlcmUgaXMgdHdvIGxvb3BzIGhlcmUsIGFuZCBsYWJlbCBpc1xuICAvLyBuZWVkZWQgdG8gYnJlYWsgb3V0IG9mIHRoZSBzZWNvbmQgb25lXG4gIC8vXG4gIC8qZXNsaW50IG5vLWxhYmVsczowLGJsb2NrLXNjb3BlZC12YXI6MCovXG4gIE9VVEVSOlxuICBmb3IgKDs7KSB7XG4gICAgdGlnaHQgPSB0cnVlO1xuICAgIHByZXZFbXB0eUVuZCA9IGZhbHNlO1xuXG4gICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgdHlwZTogJ2R0X29wZW4nLFxuICAgICAgbGluZXM6IFsgZHRMaW5lLCBkdExpbmUgXSxcbiAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbCsrXG4gICAgfSk7XG4gICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgdHlwZTogJ2lubGluZScsXG4gICAgICBjb250ZW50OiBzdGF0ZS5nZXRMaW5lcyhkdExpbmUsIGR0TGluZSArIDEsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKSxcbiAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbCArIDEsXG4gICAgICBsaW5lczogWyBkdExpbmUsIGR0TGluZSBdLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSk7XG4gICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgdHlwZTogJ2R0X2Nsb3NlJyxcbiAgICAgIGxldmVsOiAtLXN0YXRlLmxldmVsXG4gICAgfSk7XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdkZF9vcGVuJyxcbiAgICAgICAgbGluZXM6IGl0ZW1MaW5lcyA9IFsgbmV4dExpbmUsIDAgXSxcbiAgICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsKytcbiAgICAgIH0pO1xuXG4gICAgICBvbGRUaWdodCA9IHN0YXRlLnRpZ2h0O1xuICAgICAgb2xkRERJbmRlbnQgPSBzdGF0ZS5kZEluZGVudDtcbiAgICAgIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgICAgIG9sZFRTaGlmdCA9IHN0YXRlLnRTaGlmdFtkZExpbmVdO1xuICAgICAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gICAgICBzdGF0ZS5ibGtJbmRlbnQgPSBzdGF0ZS5kZEluZGVudCA9IHN0YXRlLnRTaGlmdFtkZExpbmVdICsgMjtcbiAgICAgIHN0YXRlLnRTaGlmdFtkZExpbmVdID0gY29udGVudFN0YXJ0IC0gc3RhdGUuYk1hcmtzW2RkTGluZV07XG4gICAgICBzdGF0ZS50aWdodCA9IHRydWU7XG4gICAgICBzdGF0ZS5wYXJlbnRUeXBlID0gJ2RlZmxpc3QnO1xuXG4gICAgICBzdGF0ZS5wYXJzZXIudG9rZW5pemUoc3RhdGUsIGRkTGluZSwgZW5kTGluZSwgdHJ1ZSk7XG5cbiAgICAgIC8vIElmIGFueSBvZiBsaXN0IGl0ZW0gaXMgdGlnaHQsIG1hcmsgbGlzdCBhcyB0aWdodFxuICAgICAgaWYgKCFzdGF0ZS50aWdodCB8fCBwcmV2RW1wdHlFbmQpIHtcbiAgICAgICAgdGlnaHQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEl0ZW0gYmVjb21lIGxvb3NlIGlmIGZpbmlzaCB3aXRoIGVtcHR5IGxpbmUsXG4gICAgICAvLyBidXQgd2Ugc2hvdWxkIGZpbHRlciBsYXN0IGVsZW1lbnQsIGJlY2F1c2UgaXQgbWVhbnMgbGlzdCBmaW5pc2hcbiAgICAgIHByZXZFbXB0eUVuZCA9IChzdGF0ZS5saW5lIC0gZGRMaW5lKSA+IDEgJiYgc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSk7XG5cbiAgICAgIHN0YXRlLnRTaGlmdFtkZExpbmVdID0gb2xkVFNoaWZ0O1xuICAgICAgc3RhdGUudGlnaHQgPSBvbGRUaWdodDtcbiAgICAgIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuICAgICAgc3RhdGUuYmxrSW5kZW50ID0gb2xkSW5kZW50O1xuICAgICAgc3RhdGUuZGRJbmRlbnQgPSBvbGREREluZGVudDtcblxuICAgICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnZGRfY2xvc2UnLFxuICAgICAgICBsZXZlbDogLS1zdGF0ZS5sZXZlbFxuICAgICAgfSk7XG5cbiAgICAgIGl0ZW1MaW5lc1sxXSA9IG5leHRMaW5lID0gc3RhdGUubGluZTtcblxuICAgICAgaWYgKG5leHRMaW5lID49IGVuZExpbmUpIHsgYnJlYWsgT1VURVI7IH1cblxuICAgICAgaWYgKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWsgT1VURVI7IH1cbiAgICAgIGNvbnRlbnRTdGFydCA9IHNraXBNYXJrZXIoc3RhdGUsIG5leHRMaW5lKTtcbiAgICAgIGlmIChjb250ZW50U3RhcnQgPCAwKSB7IGJyZWFrOyB9XG5cbiAgICAgIGRkTGluZSA9IG5leHRMaW5lO1xuXG4gICAgICAvLyBnbyB0byB0aGUgbmV4dCBsb29wIGl0ZXJhdGlvbjpcbiAgICAgIC8vIGluc2VydCBERCB0YWcgYW5kIHJlcGVhdCBjaGVja2luZ1xuICAgIH1cblxuICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG4gICAgZHRMaW5lID0gbmV4dExpbmU7XG5cbiAgICBpZiAoc3RhdGUuaXNFbXB0eShkdExpbmUpKSB7IGJyZWFrOyB9XG4gICAgaWYgKHN0YXRlLnRTaGlmdFtkdExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICBkZExpbmUgPSBkdExpbmUgKyAxO1xuICAgIGlmIChkZExpbmUgPj0gZW5kTGluZSkgeyBicmVhazsgfVxuICAgIGlmIChzdGF0ZS5pc0VtcHR5KGRkTGluZSkpIHsgZGRMaW5lKys7IH1cbiAgICBpZiAoZGRMaW5lID49IGVuZExpbmUpIHsgYnJlYWs7IH1cblxuICAgIGlmIChzdGF0ZS50U2hpZnRbZGRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuICAgIGNvbnRlbnRTdGFydCA9IHNraXBNYXJrZXIoc3RhdGUsIGRkTGluZSk7XG4gICAgaWYgKGNvbnRlbnRTdGFydCA8IDApIHsgYnJlYWs7IH1cblxuICAgIC8vIGdvIHRvIHRoZSBuZXh0IGxvb3AgaXRlcmF0aW9uOlxuICAgIC8vIGluc2VydCBEVCBhbmQgREQgdGFncyBhbmQgcmVwZWF0IGNoZWNraW5nXG4gIH1cblxuICAvLyBGaW5pbGl6ZSBsaXN0XG4gIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiAnZGxfY2xvc2UnLFxuICAgIGxldmVsOiAtLXN0YXRlLmxldmVsXG4gIH0pO1xuICBsaXN0TGluZXNbMV0gPSBuZXh0TGluZTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgLy8gbWFyayBwYXJhZ3JhcGhzIHRpZ2h0IGlmIG5lZWRlZFxuICBpZiAodGlnaHQpIHtcbiAgICBtYXJrVGlnaHRQYXJhZ3JhcGhzKHN0YXRlLCBsaXN0VG9rSWR4KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIGZlbmNlcyAoYGBgIGxhbmcsIH5+fiBsYW5nKVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmZW5jZXMoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBtYXJrZXIsIGxlbiwgcGFyYW1zLCBuZXh0TGluZSwgbWVtLFxuICAgICAgaGF2ZUVuZE1hcmtlciA9IGZhbHNlLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIGlmIChwb3MgKyAzID4gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg3RS8qIH4gKi8gJiYgbWFya2VyICE9PSAweDYwIC8qIGAgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBzY2FuIG1hcmtlciBsZW5ndGhcbiAgbWVtID0gcG9zO1xuICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuXG4gIGxlbiA9IHBvcyAtIG1lbTtcblxuICBpZiAobGVuIDwgMykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwYXJhbXMgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpLnRyaW0oKTtcblxuICBpZiAocGFyYW1zLmluZGV4T2YoJ2AnKSA+PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFNpbmNlIHN0YXJ0IGlzIGZvdW5kLCB3ZSBjYW4gcmVwb3J0IHN1Y2Nlc3MgaGVyZSBpbiB2YWxpZGF0aW9uIG1vZGVcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIHNlYXJjaCBlbmQgb2YgYmxvY2tcbiAgbmV4dExpbmUgPSBzdGFydExpbmU7XG5cbiAgZm9yICg7Oykge1xuICAgIG5leHRMaW5lKys7XG4gICAgaWYgKG5leHRMaW5lID49IGVuZExpbmUpIHtcbiAgICAgIC8vIHVuY2xvc2VkIGJsb2NrIHNob3VsZCBiZSBhdXRvY2xvc2VkIGJ5IGVuZCBvZiBkb2N1bWVudC5cbiAgICAgIC8vIGFsc28gYmxvY2sgc2VlbXMgdG8gYmUgYXV0b2Nsb3NlZCBieSBlbmQgb2YgcGFyZW50XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwb3MgPSBtZW0gPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS50U2hpZnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICAvLyBub24tZW1wdHkgbGluZSB3aXRoIG5lZ2F0aXZlIGluZGVudCBzaG91bGQgc3RvcCB0aGUgbGlzdDpcbiAgICAgIC8vIC0gYGBgXG4gICAgICAvLyAgdGVzdFxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IG1hcmtlcikgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgLy8gY2xvc2luZyBmZW5jZSBzaG91bGQgYmUgaW5kZW50ZWQgbGVzcyB0aGFuIDQgc3BhY2VzXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuXG4gICAgLy8gY2xvc2luZyBjb2RlIGZlbmNlIG11c3QgYmUgYXQgbGVhc3QgYXMgbG9uZyBhcyB0aGUgb3BlbmluZyBvbmVcbiAgICBpZiAocG9zIC0gbWVtIDwgbGVuKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGFpbCBoYXMgc3BhY2VzIG9ubHlcbiAgICBwb3MgPSBzdGF0ZS5za2lwU3BhY2VzKHBvcyk7XG5cbiAgICBpZiAocG9zIDwgbWF4KSB7IGNvbnRpbnVlOyB9XG5cbiAgICBoYXZlRW5kTWFya2VyID0gdHJ1ZTtcbiAgICAvLyBmb3VuZCFcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIElmIGEgZmVuY2UgaGFzIGhlYWRpbmcgc3BhY2VzLCB0aGV5IHNob3VsZCBiZSByZW1vdmVkIGZyb20gaXRzIGlubmVyIGJsb2NrXG4gIGxlbiA9IHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZSArIChoYXZlRW5kTWFya2VyID8gMSA6IDApO1xuICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJ2ZlbmNlJyxcbiAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICBjb250ZW50OiBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUgKyAxLCBuZXh0TGluZSwgbGVuLCB0cnVlKSxcbiAgICBsaW5lczogWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXSxcbiAgICBsZXZlbDogc3RhdGUubGV2ZWxcbiAgfSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2VzcyBmb290bm90ZSByZWZlcmVuY2UgbGlzdFxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb290bm90ZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIG9sZEJNYXJrLCBvbGRUU2hpZnQsIG9sZFBhcmVudFR5cGUsIHBvcywgbGFiZWwsXG4gICAgICBzdGFydCA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBsaW5lIHNob3VsZCBiZSBhdCBsZWFzdCA1IGNoYXJzIC0gXCJbXnhdOlwiXG4gIGlmIChzdGFydCArIDQgPiBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCArIDEpICE9PSAweDVFLyogXiAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLmxldmVsID49IHN0YXRlLm9wdGlvbnMubWF4TmVzdGluZykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBmb3IgKHBvcyA9IHN0YXJ0ICsgMjsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVEIC8qIF0gKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwb3MgPT09IHN0YXJ0ICsgMikgeyByZXR1cm4gZmFsc2U7IH0gLy8gbm8gZW1wdHkgZm9vdG5vdGUgbGFiZWxzXG4gIGlmIChwb3MgKyAxID49IG1heCB8fCBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3BvcykgIT09IDB4M0EgLyogOiAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuICBwb3MrKztcblxuICBpZiAoIXN0YXRlLmVudi5mb290bm90ZXMpIHsgc3RhdGUuZW52LmZvb3Rub3RlcyA9IHt9OyB9XG4gIGlmICghc3RhdGUuZW52LmZvb3Rub3Rlcy5yZWZzKSB7IHN0YXRlLmVudi5mb290bm90ZXMucmVmcyA9IHt9OyB9XG4gIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0ICsgMiwgcG9zIC0gMik7XG4gIHN0YXRlLmVudi5mb290bm90ZXMucmVmc1snOicgKyBsYWJlbF0gPSAtMTtcblxuICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJ2Zvb3Rub3RlX3JlZmVyZW5jZV9vcGVuJyxcbiAgICBsYWJlbDogbGFiZWwsXG4gICAgbGV2ZWw6IHN0YXRlLmxldmVsKytcbiAgfSk7XG5cbiAgb2xkQk1hcmsgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcbiAgb2xkVFNoaWZ0ID0gc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IHN0YXRlLnNraXBTcGFjZXMocG9zKSAtIHBvcztcbiAgc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gPSBwb3M7XG4gIHN0YXRlLmJsa0luZGVudCArPSA0O1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ2Zvb3Rub3RlJztcblxuICBpZiAoc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSArPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gLT0gc3RhdGUuYmxrSW5kZW50O1xuICB9XG5cbiAgc3RhdGUucGFyc2VyLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHRydWUpO1xuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuICBzdGF0ZS5ibGtJbmRlbnQgLT0gNDtcbiAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBvbGRUU2hpZnQ7XG4gIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdID0gb2xkQk1hcms7XG5cbiAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgIHR5cGU6ICdmb290bm90ZV9yZWZlcmVuY2VfY2xvc2UnLFxuICAgIGxldmVsOiAtLXN0YXRlLmxldmVsXG4gIH0pO1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIGhlYWRpbmcgKCMsICMjLCAuLi4pXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhlYWRpbmcoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbGV2ZWwsIHRtcCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBjaCAgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChjaCAhPT0gMHgyMy8qICMgKi8gfHwgcG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjb3VudCBoZWFkaW5nIGxldmVsXG4gIGxldmVsID0gMTtcbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3Bvcyk7XG4gIHdoaWxlIChjaCA9PT0gMHgyMy8qICMgKi8gJiYgcG9zIDwgbWF4ICYmIGxldmVsIDw9IDYpIHtcbiAgICBsZXZlbCsrO1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoKytwb3MpO1xuICB9XG5cbiAgaWYgKGxldmVsID4gNiB8fCAocG9zIDwgbWF4ICYmIGNoICE9PSAweDIwLyogc3BhY2UgKi8pKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBMZXQncyBjdXQgdGFpbHMgbGlrZSAnICAgICMjIyAgJyBmcm9tIHRoZSBlbmQgb2Ygc3RyaW5nXG5cbiAgbWF4ID0gc3RhdGUuc2tpcENoYXJzQmFjayhtYXgsIDB4MjAsIHBvcyk7IC8vIHNwYWNlXG4gIHRtcCA9IHN0YXRlLnNraXBDaGFyc0JhY2sobWF4LCAweDIzLCBwb3MpOyAvLyAjXG4gIGlmICh0bXAgPiBwb3MgJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQodG1wIC0gMSkgPT09IDB4MjAvKiBzcGFjZSAqLykge1xuICAgIG1heCA9IHRtcDtcbiAgfVxuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIHN0YXRlLnRva2Vucy5wdXNoKHsgdHlwZTogJ2hlYWRpbmdfb3BlbicsXG4gICAgaExldmVsOiBsZXZlbCxcbiAgICBsaW5lczogWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXSxcbiAgICBsZXZlbDogc3RhdGUubGV2ZWxcbiAgfSk7XG5cbiAgLy8gb25seSBpZiBoZWFkZXIgaXMgbm90IGVtcHR5XG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgICB0eXBlOiAnaW5saW5lJyxcbiAgICAgIGNvbnRlbnQ6IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCkudHJpbSgpLFxuICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsICsgMSxcbiAgICAgIGxpbmVzOiBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSk7XG4gIH1cbiAgc3RhdGUudG9rZW5zLnB1c2goeyB0eXBlOiAnaGVhZGluZ19jbG9zZScsIGhMZXZlbDogbGV2ZWwsIGxldmVsOiBzdGF0ZS5sZXZlbCB9KTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBIb3Jpem9udGFsIHJ1bGVcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHIoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBtYXJrZXIsIGNudCwgY2gsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIHBvcyArPSBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcblxuICBpZiAocG9zID4gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAvLyBDaGVjayBociBtYXJrZXJcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHg1Ri8qIF8gKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBtYXJrZXJzIGNhbiBiZSBtaXhlZCB3aXRoIHNwYWNlcywgYnV0IHRoZXJlIHNob3VsZCBiZSBhdCBsZWFzdCAzIG9uZVxuXG4gIGNudCA9IDE7XG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICBpZiAoY2ggIT09IG1hcmtlciAmJiBjaCAhPT0gMHgyMC8qIHNwYWNlICovKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmIChjaCA9PT0gbWFya2VyKSB7IGNudCsrOyB9XG4gIH1cblxuICBpZiAoY250IDwgMykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIDE7XG4gIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiAnaHInLFxuICAgIGxpbmVzOiBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdLFxuICAgIGxldmVsOiBzdGF0ZS5sZXZlbFxuICB9KTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBIVE1MIGJsb2NrXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgYmxvY2tfbmFtZXMgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9ibG9ja3MnKTtcblxuXG52YXIgSFRNTF9UQUdfT1BFTl9SRSA9IC9ePChbYS16QS1aXXsxLDE1fSlbXFxzXFwvPl0vO1xudmFyIEhUTUxfVEFHX0NMT1NFX1JFID0gL148XFwvKFthLXpBLVpdezEsMTV9KVtcXHM+XS87XG5cbmZ1bmN0aW9uIGlzTGV0dGVyKGNoKSB7XG4gIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXG4gIHZhciBsYyA9IGNoIHwgMHgyMDsgLy8gdG8gbG93ZXIgY2FzZVxuICByZXR1cm4gKGxjID49IDB4NjEvKiBhICovKSAmJiAobGMgPD0gMHg3YS8qIHogKi8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGh0bWxibG9jayhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBtYXRjaCwgbmV4dExpbmUsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdLFxuICAgICAgc2hpZnQgPSBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcblxuICBwb3MgKz0gc2hpZnQ7XG5cbiAgaWYgKCFzdGF0ZS5vcHRpb25zLmh0bWwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNoaWZ0ID4gMyB8fCBwb3MgKyAyID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKTtcblxuICBpZiAoY2ggPT09IDB4MjEvKiAhICovIHx8IGNoID09PSAweDNGLyogPyAqLykge1xuICAgIC8vIERpcmVjdGl2ZSBzdGFydCAvIGNvbW1lbnQgc3RhcnQgLyBwcm9jZXNzaW5nIGluc3RydWN0aW9uIHN0YXJ0XG4gICAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4MkYvKiAvICovIHx8IGlzTGV0dGVyKGNoKSkge1xuXG4gICAgLy8gUHJvYmFibHkgc3RhcnQgb3IgZW5kIG9mIHRhZ1xuICAgIGlmIChjaCA9PT0gMHgyRi8qIFxcICovKSB7XG4gICAgICAvLyBjbG9zaW5nIHRhZ1xuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpLm1hdGNoKEhUTUxfVEFHX0NMT1NFX1JFKTtcbiAgICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9wZW5pbmcgdGFnXG4gICAgICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCkubWF0Y2goSFRNTF9UQUdfT1BFTl9SRSk7XG4gICAgICBpZiAoIW1hdGNoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgdGFnIG5hbWUgaXMgdmFsaWRcbiAgICBpZiAoYmxvY2tfbmFtZXNbbWF0Y2hbMV0udG9Mb3dlckNhc2UoKV0gIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgd2UgYXJlIGhlcmUgLSB3ZSBkZXRlY3RlZCBIVE1MIGJsb2NrLlxuICAvLyBMZXQncyByb2xsIGRvd24gdGlsbCBlbXB0eSBsaW5lIChibG9jayBlbmQpLlxuICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG4gIHdoaWxlIChuZXh0TGluZSA8IHN0YXRlLmxpbmVNYXggJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpKSB7XG4gICAgbmV4dExpbmUrKztcbiAgfVxuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcbiAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgIHR5cGU6ICdodG1sYmxvY2snLFxuICAgIGxldmVsOiBzdGF0ZS5sZXZlbCxcbiAgICBsaW5lczogWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXSxcbiAgICBjb250ZW50OiBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCAwLCB0cnVlKVxuICB9KTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBsaGVhZGluZyAoLS0tLCA9PT0pXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxoZWFkaW5nKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUvKiwgc2lsZW50Ki8pIHtcbiAgdmFyIG1hcmtlciwgcG9zLCBtYXgsXG4gICAgICBuZXh0ID0gc3RhcnRMaW5lICsgMTtcblxuICBpZiAobmV4dCA+PSBlbmRMaW5lKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUudFNoaWZ0W25leHRdIDwgc3RhdGUuYmxrSW5kZW50KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFNjYW4gbmV4dCBsaW5lXG5cbiAgaWYgKHN0YXRlLnRTaGlmdFtuZXh0XSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRdICsgc3RhdGUudFNoaWZ0W25leHRdO1xuICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dF07XG5cbiAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAobWFya2VyICE9PSAweDJELyogLSAqLyAmJiBtYXJrZXIgIT09IDB4M0QvKiA9ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG5cbiAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xuXG4gIGlmIChwb3MgPCBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcblxuICBzdGF0ZS5saW5lID0gbmV4dCArIDE7XG4gIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiAnaGVhZGluZ19vcGVuJyxcbiAgICBoTGV2ZWw6IG1hcmtlciA9PT0gMHgzRC8qID0gKi8gPyAxIDogMixcbiAgICBsaW5lczogWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXSxcbiAgICBsZXZlbDogc3RhdGUubGV2ZWxcbiAgfSk7XG4gIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiAnaW5saW5lJyxcbiAgICBjb250ZW50OiBzdGF0ZS5zcmMuc2xpY2UocG9zLCBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSkudHJpbSgpLFxuICAgIGxldmVsOiBzdGF0ZS5sZXZlbCArIDEsXG4gICAgbGluZXM6IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIC0gMSBdLFxuICAgIGNoaWxkcmVuOiBbXVxuICB9KTtcbiAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgIHR5cGU6ICdoZWFkaW5nX2Nsb3NlJyxcbiAgICBoTGV2ZWw6IG1hcmtlciA9PT0gMHgzRC8qID0gKi8gPyAxIDogMixcbiAgICBsZXZlbDogc3RhdGUubGV2ZWxcbiAgfSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gTGlzdHNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIFNlYXJjaCBgWy0rKl1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFydGVyIG1hcmtlciBvbiBzdWNjZXNzXG4vLyBvciAtMSBvbiBmYWlsLlxuZnVuY3Rpb24gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkge1xuICB2YXIgbWFya2VyLCBwb3MsIG1heDtcblxuICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gLTE7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gIC8vIENoZWNrIGJ1bGxldFxuICBpZiAobWFya2VyICE9PSAweDJBLyogKiAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJELyogLSAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJCLyogKyAqLykge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyMCkge1xuICAgIC8vIFwiIDEudGVzdCBcIiAtIGlzIG5vdCBhIGxpc3QgaXRlbVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiBwb3M7XG59XG5cbi8vIFNlYXJjaCBgXFxkK1suKV1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFydGVyIG1hcmtlciBvbiBzdWNjZXNzXG4vLyBvciAtMSBvbiBmYWlsLlxuZnVuY3Rpb24gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpIHtcbiAgdmFyIGNoLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIGlmIChwb3MgKyAxID49IG1heCkgeyByZXR1cm4gLTE7IH1cblxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICBpZiAoY2ggPCAweDMwLyogMCAqLyB8fCBjaCA+IDB4MzkvKiA5ICovKSB7IHJldHVybiAtMTsgfVxuXG4gIGZvciAoOzspIHtcbiAgICAvLyBFT0wgLT4gZmFpbFxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiAtMTsgfVxuXG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgICBpZiAoY2ggPj0gMHgzMC8qIDAgKi8gJiYgY2ggPD0gMHgzOS8qIDkgKi8pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGZvdW5kIHZhbGlkIG1hcmtlclxuICAgIGlmIChjaCA9PT0gMHgyOS8qICkgKi8gfHwgY2ggPT09IDB4MmUvKiAuICovKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuXG4gIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyMC8qIHNwYWNlICovKSB7XG4gICAgLy8gXCIgMS50ZXN0IFwiIC0gaXMgbm90IGEgbGlzdCBpdGVtXG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiBwb3M7XG59XG5cbmZ1bmN0aW9uIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGlkeCkge1xuICB2YXIgaSwgbCxcbiAgICAgIGxldmVsID0gc3RhdGUubGV2ZWwgKyAyO1xuXG4gIGZvciAoaSA9IGlkeCArIDIsIGwgPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMjsgaSA8IGw7IGkrKykge1xuICAgIGlmIChzdGF0ZS50b2tlbnNbaV0ubGV2ZWwgPT09IGxldmVsICYmIHN0YXRlLnRva2Vuc1tpXS50eXBlID09PSAncGFyYWdyYXBoX29wZW4nKSB7XG4gICAgICBzdGF0ZS50b2tlbnNbaSArIDJdLnRpZ2h0ID0gdHJ1ZTtcbiAgICAgIHN0YXRlLnRva2Vuc1tpXS50aWdodCA9IHRydWU7XG4gICAgICBpICs9IDI7XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0KHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgbmV4dExpbmUsXG4gICAgICBpbmRlbnQsXG4gICAgICBvbGRUU2hpZnQsXG4gICAgICBvbGRJbmRlbnQsXG4gICAgICBvbGRUaWdodCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICBzdGFydCxcbiAgICAgIHBvc0FmdGVyTWFya2VyLFxuICAgICAgbWF4LFxuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIsXG4gICAgICBtYXJrZXJWYWx1ZSxcbiAgICAgIG1hcmtlckNoYXJDb2RlLFxuICAgICAgaXNPcmRlcmVkLFxuICAgICAgY29udGVudFN0YXJ0LFxuICAgICAgbGlzdFRva0lkeCxcbiAgICAgIHByZXZFbXB0eUVuZCxcbiAgICAgIGxpc3RMaW5lcyxcbiAgICAgIGl0ZW1MaW5lcyxcbiAgICAgIHRpZ2h0ID0gdHJ1ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIGksIGwsIHRlcm1pbmF0ZTtcblxuICAvLyBEZXRlY3QgbGlzdCB0eXBlIGFuZCBwb3NpdGlvbiBhZnRlciBtYXJrZXJcbiAgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSkgPj0gMCkge1xuICAgIGlzT3JkZXJlZCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoKHBvc0FmdGVyTWFya2VyID0gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkpID49IDApIHtcbiAgICBpc09yZGVyZWQgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RhdGUubGV2ZWwgPj0gc3RhdGUub3B0aW9ucy5tYXhOZXN0aW5nKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFdlIHNob3VsZCB0ZXJtaW5hdGUgbGlzdCBvbiBzdHlsZSBjaGFuZ2UuIFJlbWVtYmVyIGZpcnN0IG9uZSB0byBjb21wYXJlLlxuICBtYXJrZXJDaGFyQ29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvc0FmdGVyTWFya2VyIC0gMSk7XG5cbiAgLy8gRm9yIHZhbGlkYXRpb24gbW9kZSB3ZSBjYW4gdGVybWluYXRlIGltbWVkaWF0ZWx5XG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBTdGFydCBsaXN0XG4gIGxpc3RUb2tJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoO1xuXG4gIGlmIChpc09yZGVyZWQpIHtcbiAgICBzdGFydCA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gICAgbWFya2VyVmFsdWUgPSBOdW1iZXIoc3RhdGUuc3JjLnN1YnN0cihzdGFydCwgcG9zQWZ0ZXJNYXJrZXIgLSBzdGFydCAtIDEpKTtcblxuICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgIHR5cGU6ICdvcmRlcmVkX2xpc3Rfb3BlbicsXG4gICAgICBvcmRlcjogbWFya2VyVmFsdWUsXG4gICAgICBsaW5lczogbGlzdExpbmVzID0gWyBzdGFydExpbmUsIDAgXSxcbiAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbCsrXG4gICAgfSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgICB0eXBlOiAnYnVsbGV0X2xpc3Rfb3BlbicsXG4gICAgICBsaW5lczogbGlzdExpbmVzID0gWyBzdGFydExpbmUsIDAgXSxcbiAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbCsrXG4gICAgfSk7XG4gIH1cblxuICAvL1xuICAvLyBJdGVyYXRlIGxpc3QgaXRlbXNcbiAgLy9cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZTtcbiAgcHJldkVtcHR5RW5kID0gZmFsc2U7XG4gIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLnBhcnNlci5ydWxlci5nZXRSdWxlcygnbGlzdCcpO1xuXG4gIHdoaWxlIChuZXh0TGluZSA8IGVuZExpbmUpIHtcbiAgICBjb250ZW50U3RhcnQgPSBzdGF0ZS5za2lwU3BhY2VzKHBvc0FmdGVyTWFya2VyKTtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaWYgKGNvbnRlbnRTdGFydCA+PSBtYXgpIHtcbiAgICAgIC8vIHRyaW1taW5nIHNwYWNlIGluIFwiLSAgICBcXG4gIDNcIiBjYXNlLCBpbmRlbnQgaXMgMSBoZXJlXG4gICAgICBpbmRlbnRBZnRlck1hcmtlciA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGVudEFmdGVyTWFya2VyID0gY29udGVudFN0YXJ0IC0gcG9zQWZ0ZXJNYXJrZXI7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHRoYW4gNCBzcGFjZXMsIHRoZSBpbmRlbnQgaXMgMVxuICAgIC8vICh0aGUgcmVzdCBpcyBqdXN0IGluZGVudGVkIGNvZGUgYmxvY2spXG4gICAgaWYgKGluZGVudEFmdGVyTWFya2VyID4gNCkgeyBpbmRlbnRBZnRlck1hcmtlciA9IDE7IH1cblxuICAgIC8vIElmIGluZGVudCBpcyBsZXNzIHRoYW4gMSwgYXNzdW1lIHRoYXQgaXQncyBvbmUsIGV4YW1wbGU6XG4gICAgLy8gIFwiLVxcbiAgdGVzdFwiXG4gICAgaWYgKGluZGVudEFmdGVyTWFya2VyIDwgMSkgeyBpbmRlbnRBZnRlck1hcmtlciA9IDE7IH1cblxuICAgIC8vIFwiICAtICB0ZXN0XCJcbiAgICAvLyAgXl5eXl4gLSBjYWxjdWxhdGluZyB0b3RhbCBsZW5ndGggb2YgdGhpcyB0aGluZ1xuICAgIGluZGVudCA9IChwb3NBZnRlck1hcmtlciAtIHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pICsgaW5kZW50QWZ0ZXJNYXJrZXI7XG5cbiAgICAvLyBSdW4gc3VicGFyc2VyICYgd3JpdGUgdG9rZW5zXG4gICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgdHlwZTogJ2xpc3RfaXRlbV9vcGVuJyxcbiAgICAgIGxpbmVzOiBpdGVtTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdLFxuICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsKytcbiAgICB9KTtcblxuICAgIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgICBvbGRUaWdodCA9IHN0YXRlLnRpZ2h0O1xuICAgIG9sZFRTaGlmdCA9IHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICAgIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gY29udGVudFN0YXJ0IC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG4gICAgc3RhdGUuYmxrSW5kZW50ID0gaW5kZW50O1xuICAgIHN0YXRlLnRpZ2h0ID0gdHJ1ZTtcbiAgICBzdGF0ZS5wYXJlbnRUeXBlID0gJ2xpc3QnO1xuXG4gICAgc3RhdGUucGFyc2VyLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHRydWUpO1xuXG4gICAgLy8gSWYgYW55IG9mIGxpc3QgaXRlbSBpcyB0aWdodCwgbWFyayBsaXN0IGFzIHRpZ2h0XG4gICAgaWYgKCFzdGF0ZS50aWdodCB8fCBwcmV2RW1wdHlFbmQpIHtcbiAgICAgIHRpZ2h0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIEl0ZW0gYmVjb21lIGxvb3NlIGlmIGZpbmlzaCB3aXRoIGVtcHR5IGxpbmUsXG4gICAgLy8gYnV0IHdlIHNob3VsZCBmaWx0ZXIgbGFzdCBlbGVtZW50LCBiZWNhdXNlIGl0IG1lYW5zIGxpc3QgZmluaXNoXG4gICAgcHJldkVtcHR5RW5kID0gKHN0YXRlLmxpbmUgLSBzdGFydExpbmUpID4gMSAmJiBzdGF0ZS5pc0VtcHR5KHN0YXRlLmxpbmUgLSAxKTtcblxuICAgIHN0YXRlLmJsa0luZGVudCA9IG9sZEluZGVudDtcbiAgICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IG9sZFRTaGlmdDtcbiAgICBzdGF0ZS50aWdodCA9IG9sZFRpZ2h0O1xuICAgIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgdHlwZTogJ2xpc3RfaXRlbV9jbG9zZScsXG4gICAgICBsZXZlbDogLS1zdGF0ZS5sZXZlbFxuICAgIH0pO1xuXG4gICAgbmV4dExpbmUgPSBzdGFydExpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGl0ZW1MaW5lc1sxXSA9IG5leHRMaW5lO1xuICAgIGNvbnRlbnRTdGFydCA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdO1xuXG4gICAgaWYgKG5leHRMaW5lID49IGVuZExpbmUpIHsgYnJlYWs7IH1cblxuICAgIGlmIChzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBUcnkgdG8gY2hlY2sgaWYgbGlzdCBpcyB0ZXJtaW5hdGVkIG9yIGNvbnRpbnVlZC5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS50U2hpZnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBmYWlsIGlmIHRlcm1pbmF0aW5nIGJsb2NrIGZvdW5kXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuXG4gICAgLy8gZmFpbCBpZiBsaXN0IGhhcyBhbm90aGVyIHR5cGVcbiAgICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhazsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XG4gICAgICBpZiAocG9zQWZ0ZXJNYXJrZXIgPCAwKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlckNoYXJDb2RlICE9PSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3NBZnRlck1hcmtlciAtIDEpKSB7IGJyZWFrOyB9XG4gIH1cblxuICAvLyBGaW5pbGl6ZSBsaXN0XG4gIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiBpc09yZGVyZWQgPyAnb3JkZXJlZF9saXN0X2Nsb3NlJyA6ICdidWxsZXRfbGlzdF9jbG9zZScsXG4gICAgbGV2ZWw6IC0tc3RhdGUubGV2ZWxcbiAgfSk7XG4gIGxpc3RMaW5lc1sxXSA9IG5leHRMaW5lO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcblxuICAvLyBtYXJrIHBhcmFncmFwaHMgdGlnaHQgaWYgbmVlZGVkXG4gIGlmICh0aWdodCkge1xuICAgIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGxpc3RUb2tJZHgpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUGFyYWdyYXBoXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcmFncmFwaChzdGF0ZSwgc3RhcnRMaW5lLyosIGVuZExpbmUqLykge1xuICB2YXIgZW5kTGluZSwgY29udGVudCwgdGVybWluYXRlLCBpLCBsLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxLFxuICAgICAgdGVybWluYXRvclJ1bGVzO1xuXG4gIGVuZExpbmUgPSBzdGF0ZS5saW5lTWF4O1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgaWYgKG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSkpIHtcbiAgICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5wYXJzZXIucnVsZXIuZ2V0UnVsZXMoJ3BhcmFncmFwaCcpO1xuXG4gICAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAgIC8vIHRoaXMgd291bGQgYmUgYSBjb2RlIGJsb2NrIG5vcm1hbGx5LCBidXQgYWZ0ZXIgcGFyYWdyYXBoXG4gICAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgICAgaWYgKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgICB9XG4gIH1cblxuICBjb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcbiAgaWYgKGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgdHlwZTogJ3BhcmFncmFwaF9vcGVuJyxcbiAgICAgIHRpZ2h0OiBmYWxzZSxcbiAgICAgIGxpbmVzOiBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdLFxuICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsXG4gICAgfSk7XG4gICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgdHlwZTogJ2lubGluZScsXG4gICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsICsgMSxcbiAgICAgIGxpbmVzOiBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSk7XG4gICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgdHlwZTogJ3BhcmFncmFwaF9jbG9zZScsXG4gICAgICB0aWdodDogZmFsc2UsXG4gICAgICBsZXZlbDogc3RhdGUubGV2ZWxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFBhcnNlciBzdGF0ZSBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gU3RhdGVCbG9jayhzcmMsIHBhcnNlciwgb3B0aW9ucywgZW52LCB0b2tlbnMpIHtcbiAgdmFyIGNoLCBzLCBzdGFydCwgcG9zLCBsZW4sIGluZGVudCwgaW5kZW50X2ZvdW5kO1xuXG4gIHRoaXMuc3JjID0gc3JjO1xuXG4gIC8vIFNob3J0Y3V0cyB0byBzaW1wbGlmeSBuZXN0ZWQgY2FsbHNcbiAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICB0aGlzLmVudiA9IGVudjtcblxuICAvL1xuICAvLyBJbnRlcm5hbCBzdGF0ZSB2YXJ0aWFibGVzXG4gIC8vXG5cbiAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG5cbiAgdGhpcy5iTWFya3MgPSBbXTsgIC8vIGxpbmUgYmVnaW4gb2Zmc2V0cyBmb3IgZmFzdCBqdW1wc1xuICB0aGlzLmVNYXJrcyA9IFtdOyAgLy8gbGluZSBlbmQgb2Zmc2V0cyBmb3IgZmFzdCBqdW1wc1xuICB0aGlzLnRTaGlmdCA9IFtdOyAgLy8gaW5kZW50IGZvciBlYWNoIGxpbmVcblxuICAvLyBibG9jayBwYXJzZXIgdmFyaWFibGVzXG4gIHRoaXMuYmxrSW5kZW50ICA9IDA7IC8vIHJlcXVpcmVkIGJsb2NrIGNvbnRlbnQgaW5kZW50XG4gICAgICAgICAgICAgICAgICAgICAgIC8vIChmb3IgZXhhbXBsZSwgaWYgd2UgYXJlIGluIGxpc3QpXG4gIHRoaXMubGluZSAgICAgICA9IDA7IC8vIGxpbmUgaW5kZXggaW4gc3JjXG4gIHRoaXMubGluZU1heCAgICA9IDA7IC8vIGxpbmVzIGNvdW50XG4gIHRoaXMudGlnaHQgICAgICA9IGZhbHNlOyAgLy8gbG9vc2UvdGlnaHQgbW9kZSBmb3IgbGlzdHNcbiAgdGhpcy5wYXJlbnRUeXBlID0gJ3Jvb3QnOyAvLyBpZiBgbGlzdGAsIGJsb2NrIHBhcnNlciBzdG9wcyBvbiB0d28gbmV3bGluZXNcbiAgdGhpcy5kZEluZGVudCAgID0gLTE7IC8vIGluZGVudCBvZiB0aGUgY3VycmVudCBkZCBibG9jayAoLTEgaWYgdGhlcmUgaXNuJ3QgYW55KVxuXG4gIHRoaXMubGV2ZWwgPSAwO1xuXG4gIC8vIHJlbmRlcmVyXG4gIHRoaXMucmVzdWx0ID0gJyc7XG5cbiAgLy8gQ3JlYXRlIGNhY2hlc1xuICAvLyBHZW5lcmF0ZSBtYXJrZXJzLlxuICBzID0gdGhpcy5zcmM7XG4gIGluZGVudCA9IDA7XG4gIGluZGVudF9mb3VuZCA9IGZhbHNlO1xuXG4gIGZvciAoc3RhcnQgPSBwb3MgPSBpbmRlbnQgPSAwLCBsZW4gPSBzLmxlbmd0aDsgcG9zIDwgbGVuOyBwb3MrKykge1xuICAgIGNoID0gcy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWluZGVudF9mb3VuZCkge1xuICAgICAgaWYgKGNoID09PSAweDIwLyogc3BhY2UgKi8pIHtcbiAgICAgICAgaW5kZW50Kys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZW50X2ZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4MEEgfHwgcG9zID09PSBsZW4gLSAxKSB7XG4gICAgICBpZiAoY2ggIT09IDB4MEEpIHsgcG9zKys7IH1cbiAgICAgIHRoaXMuYk1hcmtzLnB1c2goc3RhcnQpO1xuICAgICAgdGhpcy5lTWFya3MucHVzaChwb3MpO1xuICAgICAgdGhpcy50U2hpZnQucHVzaChpbmRlbnQpO1xuXG4gICAgICBpbmRlbnRfZm91bmQgPSBmYWxzZTtcbiAgICAgIGluZGVudCA9IDA7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgfVxuICB9XG5cbiAgLy8gUHVzaCBmYWtlIGVudHJ5IHRvIHNpbXBsaWZ5IGNhY2hlIGJvdW5kcyBjaGVja3NcbiAgdGhpcy5iTWFya3MucHVzaChzLmxlbmd0aCk7XG4gIHRoaXMuZU1hcmtzLnB1c2gocy5sZW5ndGgpO1xuICB0aGlzLnRTaGlmdC5wdXNoKDApO1xuXG4gIHRoaXMubGluZU1heCA9IHRoaXMuYk1hcmtzLmxlbmd0aCAtIDE7IC8vIGRvbid0IGNvdW50IGxhc3QgZmFrZSBsaW5lXG59XG5cblN0YXRlQmxvY2sucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KGxpbmUpIHtcbiAgcmV0dXJuIHRoaXMuYk1hcmtzW2xpbmVdICsgdGhpcy50U2hpZnRbbGluZV0gPj0gdGhpcy5lTWFya3NbbGluZV07XG59O1xuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwRW1wdHlMaW5lcyA9IGZ1bmN0aW9uIHNraXBFbXB0eUxpbmVzKGZyb20pIHtcbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5saW5lTWF4OyBmcm9tIDwgbWF4OyBmcm9tKyspIHtcbiAgICBpZiAodGhpcy5iTWFya3NbZnJvbV0gKyB0aGlzLnRTaGlmdFtmcm9tXSA8IHRoaXMuZU1hcmtzW2Zyb21dKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyb207XG59O1xuXG4vLyBTa2lwIHNwYWNlcyBmcm9tIGdpdmVuIHBvc2l0aW9uLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcFNwYWNlcyA9IGZ1bmN0aW9uIHNraXBTcGFjZXMocG9zKSB7XG4gIGZvciAodmFyIG1heCA9IHRoaXMuc3JjLmxlbmd0aDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGlmICh0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjAvKiBzcGFjZSAqLykgeyBicmVhazsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBTa2lwIGNoYXIgY29kZXMgZnJvbSBnaXZlbiBwb3NpdGlvblxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcENoYXJzID0gZnVuY3Rpb24gc2tpcENoYXJzKHBvcywgY29kZSkge1xuICBmb3IgKHZhciBtYXggPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBpZiAodGhpcy5zcmMuY2hhckNvZGVBdChwb3MpICE9PSBjb2RlKSB7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgY2hhciBjb2RlcyByZXZlcnNlIGZyb20gZ2l2ZW4gcG9zaXRpb24gLSAxXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnNCYWNrID0gZnVuY3Rpb24gc2tpcENoYXJzQmFjayhwb3MsIGNvZGUsIG1pbikge1xuICBpZiAocG9zIDw9IG1pbikgeyByZXR1cm4gcG9zOyB9XG5cbiAgd2hpbGUgKHBvcyA+IG1pbikge1xuICAgIGlmIChjb2RlICE9PSB0aGlzLnNyYy5jaGFyQ29kZUF0KC0tcG9zKSkgeyByZXR1cm4gcG9zICsgMTsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBjdXQgbGluZXMgcmFuZ2UgZnJvbSBzb3VyY2UuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5nZXRMaW5lcyA9IGZ1bmN0aW9uIGdldExpbmVzKGJlZ2luLCBlbmQsIGluZGVudCwga2VlcExhc3RMRikge1xuICB2YXIgaSwgZmlyc3QsIGxhc3QsIHF1ZXVlLCBzaGlmdCxcbiAgICAgIGxpbmUgPSBiZWdpbjtcblxuICBpZiAoYmVnaW4gPj0gZW5kKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLy8gT3B0OiBkb24ndCB1c2UgcHVzaCBxdWV1ZSBmb3Igc2luZ2xlIGxpbmU7XG4gIGlmIChsaW5lICsgMSA9PT0gZW5kKSB7XG4gICAgZmlyc3QgPSB0aGlzLmJNYXJrc1tsaW5lXSArIE1hdGgubWluKHRoaXMudFNoaWZ0W2xpbmVdLCBpbmRlbnQpO1xuICAgIGxhc3QgPSBrZWVwTGFzdExGID8gdGhpcy5lTWFya3NbbGluZV0gKyAxIDogdGhpcy5lTWFya3NbbGluZV07XG4gICAgcmV0dXJuIHRoaXMuc3JjLnNsaWNlKGZpcnN0LCBsYXN0KTtcbiAgfVxuXG4gIHF1ZXVlID0gbmV3IEFycmF5KGVuZCAtIGJlZ2luKTtcblxuICBmb3IgKGkgPSAwOyBsaW5lIDwgZW5kOyBsaW5lKyssIGkrKykge1xuICAgIHNoaWZ0ID0gdGhpcy50U2hpZnRbbGluZV07XG4gICAgaWYgKHNoaWZ0ID4gaW5kZW50KSB7IHNoaWZ0ID0gaW5kZW50OyB9XG4gICAgaWYgKHNoaWZ0IDwgMCkgeyBzaGlmdCA9IDA7IH1cblxuICAgIGZpcnN0ID0gdGhpcy5iTWFya3NbbGluZV0gKyBzaGlmdDtcblxuICAgIGlmIChsaW5lICsgMSA8IGVuZCB8fCBrZWVwTGFzdExGKSB7XG4gICAgICAvLyBObyBuZWVkIGZvciBib3VuZHMgY2hlY2sgYmVjYXVzZSB3ZSBoYXZlIGZha2UgZW50cnkgb24gdGFpbC5cbiAgICAgIGxhc3QgPSB0aGlzLmVNYXJrc1tsaW5lXSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSB0aGlzLmVNYXJrc1tsaW5lXTtcbiAgICB9XG5cbiAgICBxdWV1ZVtpXSA9IHRoaXMuc3JjLnNsaWNlKGZpcnN0LCBsYXN0KTtcbiAgfVxuXG4gIHJldHVybiBxdWV1ZS5qb2luKCcnKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUJsb2NrO1xuIiwiLy8gR0ZNIHRhYmxlLCBub24tc3RhbmRhcmRcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIGdldExpbmUoc3RhdGUsIGxpbmUpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLmJNYXJrc1tsaW5lXSArIHN0YXRlLmJsa0luZGVudCxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tsaW5lXTtcblxuICByZXR1cm4gc3RhdGUuc3JjLnN1YnN0cihwb3MsIG1heCAtIHBvcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGFibGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbGluZVRleHQsIHBvcywgaSwgbmV4dExpbmUsIHJvd3MsIGNlbGwsXG4gICAgICBhbGlnbnMsIHQsIHRhYmxlTGluZXMsIHRib2R5TGluZXM7XG5cbiAgLy8gc2hvdWxkIGhhdmUgYXQgbGVhc3QgdGhyZWUgbGluZXNcbiAgaWYgKHN0YXJ0TGluZSArIDIgPiBlbmRMaW5lKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICBpZiAoc3RhdGUudFNoaWZ0W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHNlY29uZCBsaW5lIHNob3VsZCBiZSAnfCcgb3IgJy0nXG5cbiAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gIGlmIChwb3MgPj0gc3RhdGUuZU1hcmtzW25leHRMaW5lXSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gIGlmIChjaCAhPT0gMHg3Qy8qIHwgKi8gJiYgY2ggIT09IDB4MkQvKiAtICovICYmIGNoICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSArIDEpO1xuICBpZiAoIS9eWy06fCBdKyQvLnRlc3QobGluZVRleHQpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHJvd3MgPSBsaW5lVGV4dC5zcGxpdCgnfCcpO1xuICBpZiAocm93cyA8PSAyKSB7IHJldHVybiBmYWxzZTsgfVxuICBhbGlnbnMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICB0ID0gcm93c1tpXS50cmltKCk7XG4gICAgaWYgKCF0KSB7XG4gICAgICAvLyBhbGxvdyBlbXB0eSBjb2x1bW5zIGJlZm9yZSBhbmQgYWZ0ZXIgdGFibGUsIGJ1dCBub3QgaW4gYmV0d2VlbiBjb2x1bW5zO1xuICAgICAgLy8gZS5nLiBhbGxvdyBgIHwtLS18IGAsIGRpc2FsbG93IGAgLS0tfHwtLS0gYFxuICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gcm93cy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL146Py0rOj8kLy50ZXN0KHQpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmICh0LmNoYXJDb2RlQXQodC5sZW5ndGggLSAxKSA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGFsaWducy5wdXNoKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8gPyAnY2VudGVyJyA6ICdyaWdodCcpO1xuICAgIH0gZWxzZSBpZiAodC5jaGFyQ29kZUF0KDApID09PSAweDNBLyogOiAqLykge1xuICAgICAgYWxpZ25zLnB1c2goJ2xlZnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpZ25zLnB1c2goJycpO1xuICAgIH1cbiAgfVxuXG4gIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgc3RhcnRMaW5lKS50cmltKCk7XG4gIGlmIChsaW5lVGV4dC5pbmRleE9mKCd8JykgPT09IC0xKSB7IHJldHVybiBmYWxzZTsgfVxuICByb3dzID0gbGluZVRleHQucmVwbGFjZSgvXlxcfHxcXHwkL2csICcnKS5zcGxpdCgnfCcpO1xuICBpZiAoYWxpZ25zLmxlbmd0aCAhPT0gcm93cy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJ3RhYmxlX29wZW4nLFxuICAgIGxpbmVzOiB0YWJsZUxpbmVzID0gWyBzdGFydExpbmUsIDAgXSxcbiAgICBsZXZlbDogc3RhdGUubGV2ZWwrK1xuICB9KTtcbiAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgIHR5cGU6ICd0aGVhZF9vcGVuJyxcbiAgICBsaW5lczogWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXSxcbiAgICBsZXZlbDogc3RhdGUubGV2ZWwrK1xuICB9KTtcblxuICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJ3RyX29wZW4nLFxuICAgIGxpbmVzOiBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdLFxuICAgIGxldmVsOiBzdGF0ZS5sZXZlbCsrXG4gIH0pO1xuICBmb3IgKGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgIHR5cGU6ICd0aF9vcGVuJyxcbiAgICAgIGFsaWduOiBhbGlnbnNbaV0sXG4gICAgICBsaW5lczogWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXSxcbiAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbCsrXG4gICAgfSk7XG4gICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgdHlwZTogJ2lubGluZScsXG4gICAgICBjb250ZW50OiByb3dzW2ldLnRyaW0oKSxcbiAgICAgIGxpbmVzOiBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdLFxuICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSk7XG4gICAgc3RhdGUudG9rZW5zLnB1c2goeyB0eXBlOiAndGhfY2xvc2UnLCBsZXZlbDogLS1zdGF0ZS5sZXZlbCB9KTtcbiAgfVxuICBzdGF0ZS50b2tlbnMucHVzaCh7IHR5cGU6ICd0cl9jbG9zZScsIGxldmVsOiAtLXN0YXRlLmxldmVsIH0pO1xuICBzdGF0ZS50b2tlbnMucHVzaCh7IHR5cGU6ICd0aGVhZF9jbG9zZScsIGxldmVsOiAtLXN0YXRlLmxldmVsIH0pO1xuXG4gIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiAndGJvZHlfb3BlbicsXG4gICAgbGluZXM6IHRib2R5TGluZXMgPSBbIHN0YXJ0TGluZSArIDIsIDAgXSxcbiAgICBsZXZlbDogc3RhdGUubGV2ZWwrK1xuICB9KTtcblxuICBmb3IgKG5leHRMaW5lID0gc3RhcnRMaW5lICsgMjsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgaWYgKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgbmV4dExpbmUpLnRyaW0oKTtcbiAgICBpZiAobGluZVRleHQuaW5kZXhPZignfCcpID09PSAtMSkgeyBicmVhazsgfVxuICAgIHJvd3MgPSBsaW5lVGV4dC5yZXBsYWNlKC9eXFx8fFxcfCQvZywgJycpLnNwbGl0KCd8Jyk7XG5cbiAgICBzdGF0ZS50b2tlbnMucHVzaCh7IHR5cGU6ICd0cl9vcGVuJywgbGV2ZWw6IHN0YXRlLmxldmVsKysgfSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YXRlLnRva2Vucy5wdXNoKHsgdHlwZTogJ3RkX29wZW4nLCBhbGlnbjogYWxpZ25zW2ldLCBsZXZlbDogc3RhdGUubGV2ZWwrKyB9KTtcbiAgICAgIC8vIDB4N2MgPT09ICd8J1xuICAgICAgY2VsbCA9IHJvd3NbaV0uc3Vic3RyaW5nKFxuICAgICAgICAgIHJvd3NbaV0uY2hhckNvZGVBdCgwKSA9PT0gMHg3YyA/IDEgOiAwLFxuICAgICAgICAgIHJvd3NbaV0uY2hhckNvZGVBdChyb3dzW2ldLmxlbmd0aCAtIDEpID09PSAweDdjID8gcm93c1tpXS5sZW5ndGggLSAxIDogcm93c1tpXS5sZW5ndGhcbiAgICAgICkudHJpbSgpO1xuICAgICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaW5saW5lJyxcbiAgICAgICAgY29udGVudDogY2VsbCxcbiAgICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsLFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgIH0pO1xuICAgICAgc3RhdGUudG9rZW5zLnB1c2goeyB0eXBlOiAndGRfY2xvc2UnLCBsZXZlbDogLS1zdGF0ZS5sZXZlbCB9KTtcbiAgICB9XG4gICAgc3RhdGUudG9rZW5zLnB1c2goeyB0eXBlOiAndHJfY2xvc2UnLCBsZXZlbDogLS1zdGF0ZS5sZXZlbCB9KTtcbiAgfVxuICBzdGF0ZS50b2tlbnMucHVzaCh7IHR5cGU6ICd0Ym9keV9jbG9zZScsIGxldmVsOiAtLXN0YXRlLmxldmVsIH0pO1xuICBzdGF0ZS50b2tlbnMucHVzaCh7IHR5cGU6ICd0YWJsZV9jbG9zZScsIGxldmVsOiAtLXN0YXRlLmxldmVsIH0pO1xuXG4gIHRhYmxlTGluZXNbMV0gPSB0Ym9keUxpbmVzWzFdID0gbmV4dExpbmU7XG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUGFyc2UgYWJicmV2aWF0aW9uIGRlZmluaXRpb25zLCBpLmUuIGAqW2FiYnJdOiBkZXNjcmlwdGlvbmBcbi8vXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU3RhdGVJbmxpbmUgICAgPSByZXF1aXJlKCcuLi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lJyk7XG52YXIgcGFyc2VMaW5rTGFiZWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWwnKTtcblxuXG5mdW5jdGlvbiBwYXJzZUFiYnIoc3RyLCBwYXJzZXJJbmxpbmUsIG9wdGlvbnMsIGVudikge1xuICB2YXIgc3RhdGUsIGxhYmVsRW5kLCBwb3MsIG1heCwgbGFiZWwsIHRpdGxlO1xuXG4gIGlmIChzdHIuY2hhckNvZGVBdCgwKSAhPT0gMHgyQS8qICogKi8pIHsgcmV0dXJuIC0xOyB9XG4gIGlmIChzdHIuY2hhckNvZGVBdCgxKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIC0xOyB9XG5cbiAgaWYgKHN0ci5pbmRleE9mKCddOicpID09PSAtMSkgeyByZXR1cm4gLTE7IH1cblxuICBzdGF0ZSA9IG5ldyBTdGF0ZUlubGluZShzdHIsIHBhcnNlcklubGluZSwgb3B0aW9ucywgZW52LCBbXSk7XG4gIGxhYmVsRW5kID0gcGFyc2VMaW5rTGFiZWwoc3RhdGUsIDEpO1xuXG4gIGlmIChsYWJlbEVuZCA8IDAgfHwgc3RyLmNoYXJDb2RlQXQobGFiZWxFbmQgKyAxKSAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIC0xOyB9XG5cbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIC8vIGFiYnIgdGl0bGUgaXMgYWx3YXlzIG9uZSBsaW5lLCBzbyBsb29raW5nIGZvciBlbmRpbmcgXCJcXG5cIiBoZXJlXG4gIGZvciAocG9zID0gbGFiZWxFbmQgKyAyOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGxhYmVsID0gc3RyLnNsaWNlKDIsIGxhYmVsRW5kKTtcbiAgdGl0bGUgPSBzdHIuc2xpY2UobGFiZWxFbmQgKyAyLCBwb3MpLnRyaW0oKTtcbiAgaWYgKHRpdGxlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gLTE7IH1cbiAgaWYgKCFlbnYuYWJicmV2aWF0aW9ucykgeyBlbnYuYWJicmV2aWF0aW9ucyA9IHt9OyB9XG4gIC8vIHByZXBlbmQgJzonIHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBtZW1iZXJzXG4gIGlmICh0eXBlb2YgZW52LmFiYnJldmlhdGlvbnNbJzonICsgbGFiZWxdID09PSAndW5kZWZpbmVkJykge1xuICAgIGVudi5hYmJyZXZpYXRpb25zWyc6JyArIGxhYmVsXSA9IHRpdGxlO1xuICB9XG5cbiAgcmV0dXJuIHBvcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhYmJyKHN0YXRlKSB7XG4gIHZhciB0b2tlbnMgPSBzdGF0ZS50b2tlbnMsIGksIGwsIGNvbnRlbnQsIHBvcztcblxuICBpZiAoc3RhdGUuaW5saW5lTW9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFBhcnNlIGlubGluZXNcbiAgZm9yIChpID0gMSwgbCA9IHRva2Vucy5sZW5ndGggLSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHRva2Vuc1tpIC0gMV0udHlwZSA9PT0gJ3BhcmFncmFwaF9vcGVuJyAmJlxuICAgICAgICB0b2tlbnNbaV0udHlwZSA9PT0gJ2lubGluZScgJiZcbiAgICAgICAgdG9rZW5zW2kgKyAxXS50eXBlID09PSAncGFyYWdyYXBoX2Nsb3NlJykge1xuXG4gICAgICBjb250ZW50ID0gdG9rZW5zW2ldLmNvbnRlbnQ7XG4gICAgICB3aGlsZSAoY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgcG9zID0gcGFyc2VBYmJyKGNvbnRlbnQsIHN0YXRlLmlubGluZSwgc3RhdGUub3B0aW9ucywgc3RhdGUuZW52KTtcbiAgICAgICAgaWYgKHBvcyA8IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UocG9zKS50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIHRva2Vuc1tpXS5jb250ZW50ID0gY29udGVudDtcbiAgICAgIGlmICghY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgdG9rZW5zW2kgLSAxXS50aWdodCA9IHRydWU7XG4gICAgICAgIHRva2Vuc1tpICsgMV0udGlnaHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbiIsIi8vIEVuY2xvc2UgYWJicmV2aWF0aW9ucyBpbiA8YWJicj4gdGFnc1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgUFVOQ1RfQ0hBUlMgPSAnIFxcbigpW11cXCdcIi4sIT8tJztcblxuXG4vLyBmcm9tIEdvb2dsZSBjbG9zdXJlIGxpYnJhcnlcbi8vIGh0dHA6Ly9jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0LWhpc3RvcnkvZG9jcy9sb2NhbF9jbG9zdXJlX2dvb2dfc3RyaW5nX3N0cmluZy5qcy5zb3VyY2UuaHRtbCNsaW5lMTAyMVxuZnVuY3Rpb24gcmVnRXNjYXBlKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvKFstKClcXFtcXF17fSs/Ki4kXFxefCw6IzwhXFxcXF0pL2csICdcXFxcJDEnKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFiYnIyKHN0YXRlKSB7XG4gIHZhciBpLCBqLCBsLCB0b2tlbnMsIHRva2VuLCB0ZXh0LCBub2RlcywgcG9zLCBsZXZlbCwgcmVnLCBtLCByZWdUZXh0LFxuICAgICAgYmxvY2tUb2tlbnMgPSBzdGF0ZS50b2tlbnM7XG5cbiAgaWYgKCFzdGF0ZS5lbnYuYWJicmV2aWF0aW9ucykgeyByZXR1cm47IH1cbiAgaWYgKCFzdGF0ZS5lbnYuYWJiclJlZ0V4cCkge1xuICAgIHJlZ1RleHQgPSAnKF58WycgKyBQVU5DVF9DSEFSUy5zcGxpdCgnJykubWFwKHJlZ0VzY2FwZSkuam9pbignJykgKyAnXSknXG4gICAgICAgICAgICArICcoJyArIE9iamVjdC5rZXlzKHN0YXRlLmVudi5hYmJyZXZpYXRpb25zKS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geC5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfSkubWFwKHJlZ0VzY2FwZSkuam9pbignfCcpICsgJyknXG4gICAgICAgICAgICArICcoJHxbJyArIFBVTkNUX0NIQVJTLnNwbGl0KCcnKS5tYXAocmVnRXNjYXBlKS5qb2luKCcnKSArICddKSc7XG4gICAgc3RhdGUuZW52LmFiYnJSZWdFeHAgPSBuZXcgUmVnRXhwKHJlZ1RleHQsICdnJyk7XG4gIH1cbiAgcmVnID0gc3RhdGUuZW52LmFiYnJSZWdFeHA7XG5cbiAgZm9yIChqID0gMCwgbCA9IGJsb2NrVG9rZW5zLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgIGlmIChibG9ja1Rva2Vuc1tqXS50eXBlICE9PSAnaW5saW5lJykgeyBjb250aW51ZTsgfVxuICAgIHRva2VucyA9IGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuO1xuXG4gICAgLy8gV2Ugc2NhbiBmcm9tIHRoZSBlbmQsIHRvIGtlZXAgcG9zaXRpb24gd2hlbiBuZXcgdGFncyBhZGRlZC5cbiAgICBmb3IgKGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgaWYgKHRva2VuLnR5cGUgIT09ICd0ZXh0JykgeyBjb250aW51ZTsgfVxuXG4gICAgICBwb3MgPSAwO1xuICAgICAgdGV4dCA9IHRva2VuLmNvbnRlbnQ7XG4gICAgICByZWcubGFzdEluZGV4ID0gMDtcbiAgICAgIGxldmVsID0gdG9rZW4ubGV2ZWw7XG4gICAgICBub2RlcyA9IFtdO1xuXG4gICAgICB3aGlsZSAoKG0gPSByZWcuZXhlYyh0ZXh0KSkpIHtcbiAgICAgICAgaWYgKHJlZy5sYXN0SW5kZXggPiBwb3MpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRleHQuc2xpY2UocG9zLCBtLmluZGV4ICsgbVsxXS5sZW5ndGgpLFxuICAgICAgICAgICAgbGV2ZWw6IGxldmVsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnYWJicl9vcGVuJyxcbiAgICAgICAgICB0aXRsZTogc3RhdGUuZW52LmFiYnJldmlhdGlvbnNbJzonICsgbVsyXV0sXG4gICAgICAgICAgbGV2ZWw6IGxldmVsKytcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICBjb250ZW50OiBtWzJdLFxuICAgICAgICAgIGxldmVsOiBsZXZlbFxuICAgICAgICB9KTtcbiAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ2FiYnJfY2xvc2UnLFxuICAgICAgICAgIGxldmVsOiAtLWxldmVsXG4gICAgICAgIH0pO1xuICAgICAgICBwb3MgPSByZWcubGFzdEluZGV4IC0gbVszXS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICghbm9kZXMubGVuZ3RoKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgY29udGVudDogdGV4dC5zbGljZShwb3MpLFxuICAgICAgICAgIGxldmVsOiBsZXZlbFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVwbGFjZSBjdXJyZW50IG5vZGVcbiAgICAgIGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuID0gdG9rZW5zID0gW10uY29uY2F0KHRva2Vucy5zbGljZSgwLCBpKSwgbm9kZXMsIHRva2Vucy5zbGljZShpICsgMSkpO1xuICAgIH1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBibG9jayhzdGF0ZSkge1xuXG4gIGlmIChzdGF0ZS5pbmxpbmVNb2RlKSB7XG4gICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgdHlwZTogJ2lubGluZScsXG4gICAgICBjb250ZW50OiBzdGF0ZS5zcmMucmVwbGFjZSgvXFxuL2csICcgJykudHJpbSgpLFxuICAgICAgbGV2ZWw6IDAsXG4gICAgICBsaW5lczogWyAwLCAxIF0sXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9KTtcblxuICB9IGVsc2Uge1xuICAgIHN0YXRlLmJsb2NrLnBhcnNlKHN0YXRlLnNyYywgc3RhdGUub3B0aW9ucywgc3RhdGUuZW52LCBzdGF0ZS50b2tlbnMpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9vdG5vdGVfYmxvY2soc3RhdGUpIHtcbiAgdmFyIGksIGwsIGosIHQsIGxhc3RQYXJhZ3JhcGgsIGxpc3QsIHRva2VucywgY3VycmVudCwgY3VycmVudExhYmVsLFxuICAgICAgbGV2ZWwgPSAwLFxuICAgICAgaW5zaWRlUmVmID0gZmFsc2UsXG4gICAgICByZWZUb2tlbnMgPSB7fTtcblxuICBpZiAoIXN0YXRlLmVudi5mb290bm90ZXMpIHsgcmV0dXJuOyB9XG5cbiAgc3RhdGUudG9rZW5zID0gc3RhdGUudG9rZW5zLmZpbHRlcihmdW5jdGlvbih0b2spIHtcbiAgICBpZiAodG9rLnR5cGUgPT09ICdmb290bm90ZV9yZWZlcmVuY2Vfb3BlbicpIHtcbiAgICAgIGluc2lkZVJlZiA9IHRydWU7XG4gICAgICBjdXJyZW50ID0gW107XG4gICAgICBjdXJyZW50TGFiZWwgPSB0b2subGFiZWw7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0b2sudHlwZSA9PT0gJ2Zvb3Rub3RlX3JlZmVyZW5jZV9jbG9zZScpIHtcbiAgICAgIGluc2lkZVJlZiA9IGZhbHNlO1xuICAgICAgLy8gcHJlcGVuZCAnOicgdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIG1lbWJlcnNcbiAgICAgIHJlZlRva2Vuc1snOicgKyBjdXJyZW50TGFiZWxdID0gY3VycmVudDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGluc2lkZVJlZikgeyBjdXJyZW50LnB1c2godG9rKTsgfVxuICAgIHJldHVybiAhaW5zaWRlUmVmO1xuICB9KTtcblxuICBpZiAoIXN0YXRlLmVudi5mb290bm90ZXMubGlzdCkgeyByZXR1cm47IH1cbiAgbGlzdCA9IHN0YXRlLmVudi5mb290bm90ZXMubGlzdDtcblxuICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJ2Zvb3Rub3RlX2Jsb2NrX29wZW4nLFxuICAgIGxldmVsOiBsZXZlbCsrXG4gIH0pO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh7XG4gICAgICB0eXBlOiAnZm9vdG5vdGVfb3BlbicsXG4gICAgICBpZDogaSxcbiAgICAgIGxldmVsOiBsZXZlbCsrXG4gICAgfSk7XG5cbiAgICBpZiAobGlzdFtpXS50b2tlbnMpIHtcbiAgICAgIHRva2VucyA9IFtdO1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAncGFyYWdyYXBoX29wZW4nLFxuICAgICAgICB0aWdodDogZmFsc2UsXG4gICAgICAgIGxldmVsOiBsZXZlbCsrXG4gICAgICB9KTtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2lubGluZScsXG4gICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgIGNoaWxkcmVuOiBsaXN0W2ldLnRva2Vuc1xuICAgICAgfSk7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdwYXJhZ3JhcGhfY2xvc2UnLFxuICAgICAgICB0aWdodDogZmFsc2UsXG4gICAgICAgIGxldmVsOiAtLWxldmVsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGxpc3RbaV0ubGFiZWwpIHtcbiAgICAgIHRva2VucyA9IHJlZlRva2Vuc1snOicgKyBsaXN0W2ldLmxhYmVsXTtcbiAgICB9XG5cbiAgICBzdGF0ZS50b2tlbnMgPSBzdGF0ZS50b2tlbnMuY29uY2F0KHRva2Vucyk7XG4gICAgaWYgKHN0YXRlLnRva2Vuc1tzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMV0udHlwZSA9PT0gJ3BhcmFncmFwaF9jbG9zZScpIHtcbiAgICAgIGxhc3RQYXJhZ3JhcGggPSBzdGF0ZS50b2tlbnMucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RQYXJhZ3JhcGggPSBudWxsO1xuICAgIH1cblxuICAgIHQgPSBsaXN0W2ldLmNvdW50ID4gMCA/IGxpc3RbaV0uY291bnQgOiAxO1xuICAgIGZvciAoaiA9IDA7IGogPCB0OyBqKyspIHtcbiAgICAgIHN0YXRlLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2Zvb3Rub3RlX2FuY2hvcicsXG4gICAgICAgIGlkOiBpLFxuICAgICAgICBzdWJJZDogaixcbiAgICAgICAgbGV2ZWw6IGxldmVsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobGFzdFBhcmFncmFwaCkge1xuICAgICAgc3RhdGUudG9rZW5zLnB1c2gobGFzdFBhcmFncmFwaCk7XG4gICAgfVxuXG4gICAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgICAgdHlwZTogJ2Zvb3Rub3RlX2Nsb3NlJyxcbiAgICAgIGxldmVsOiAtLWxldmVsXG4gICAgfSk7XG4gIH1cbiAgc3RhdGUudG9rZW5zLnB1c2goe1xuICAgIHR5cGU6ICdmb290bm90ZV9ibG9ja19jbG9zZScsXG4gICAgbGV2ZWw6IC0tbGV2ZWxcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlubGluZShzdGF0ZSkge1xuICB2YXIgdG9rZW5zID0gc3RhdGUudG9rZW5zLCB0b2ssIGksIGw7XG5cbiAgLy8gUGFyc2UgaW5saW5lc1xuICBmb3IgKGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRvayA9IHRva2Vuc1tpXTtcbiAgICBpZiAodG9rLnR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICBzdGF0ZS5pbmxpbmUucGFyc2UodG9rLmNvbnRlbnQsIHN0YXRlLm9wdGlvbnMsIHN0YXRlLmVudiwgdG9rLmNoaWxkcmVuKTtcbiAgICB9XG4gIH1cbn07XG4iLCIvLyBSZXBsYWNlIGxpbmstbGlrZSB0ZXh0cyB3aXRoIGxpbmsgbm9kZXMuXG4vL1xuLy8gQ3VycmVudGx5IHJlc3RyaWN0ZWQgYnkgYGlubGluZS52YWxpZGF0ZUxpbmsoKWAgdG8gaHR0cC9odHRwcy9mdHBcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIEF1dG9saW5rZXIgPSByZXF1aXJlKCdhdXRvbGlua2VyJyk7XG5cblxudmFyIExJTktfU0NBTl9SRSA9IC93d3d8QHxcXDpcXC9cXC8vO1xuXG5cbmZ1bmN0aW9uIGlzTGlua09wZW4oc3RyKSB7XG4gIHJldHVybiAvXjxhWz5cXHNdL2kudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gaXNMaW5rQ2xvc2Uoc3RyKSB7XG4gIHJldHVybiAvXjxcXC9hXFxzKj4vaS50ZXN0KHN0cik7XG59XG5cbi8vIFN0dXBpZCBmYWJyaWMgdG8gYXZvaWQgc2luZ2xldG9ucywgZm9yIHRocmVhZCBzYWZldHkuXG4vLyBSZXF1aXJlZCBmb3IgZW5naW5lcyBsaWtlIE5hc2hvcm4uXG4vL1xuZnVuY3Rpb24gY3JlYXRlTGlua2lmaWVyKCkge1xuICB2YXIgbGlua3MgPSBbXTtcbiAgdmFyIGF1dG9saW5rZXIgPSBuZXcgQXV0b2xpbmtlcih7XG4gICAgc3RyaXBQcmVmaXg6IGZhbHNlLFxuICAgIHVybDogdHJ1ZSxcbiAgICBlbWFpbDogdHJ1ZSxcbiAgICB0d2l0dGVyOiBmYWxzZSxcbiAgICByZXBsYWNlRm46IGZ1bmN0aW9uIChsaW5rZXIsIG1hdGNoKSB7XG4gICAgICAvLyBPbmx5IGNvbGxlY3QgbWF0Y2hlZCBzdHJpbmdzIGJ1dCBkb24ndCBjaGFuZ2UgYW55dGhpbmcuXG4gICAgICBzd2l0Y2ggKG1hdGNoLmdldFR5cGUoKSkge1xuICAgICAgICAvKmVzbGludCBkZWZhdWx0LWNhc2U6MCovXG4gICAgICAgIGNhc2UgJ3VybCc6XG4gICAgICAgICAgbGlua3MucHVzaCh7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaC5tYXRjaGVkVGV4dCxcbiAgICAgICAgICAgIHVybDogbWF0Y2guZ2V0VXJsKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZW1haWwnOlxuICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2gubWF0Y2hlZFRleHQsXG4gICAgICAgICAgICAvLyBub3JtYWxpemUgZW1haWwgcHJvdG9jb2xcbiAgICAgICAgICAgIHVybDogJ21haWx0bzonICsgbWF0Y2guZ2V0RW1haWwoKS5yZXBsYWNlKC9ebWFpbHRvOi9pLCAnJylcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgbGlua3M6IGxpbmtzLFxuICAgIGF1dG9saW5rZXI6IGF1dG9saW5rZXJcbiAgfTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmtpZnkoc3RhdGUpIHtcbiAgdmFyIGksIGosIGwsIHRva2VucywgdG9rZW4sIHRleHQsIG5vZGVzLCBsbiwgcG9zLCBsZXZlbCwgaHRtbExpbmtMZXZlbCxcbiAgICAgIGJsb2NrVG9rZW5zID0gc3RhdGUudG9rZW5zLFxuICAgICAgbGlua2lmaWVyID0gbnVsbCwgbGlua3MsIGF1dG9saW5rZXI7XG5cbiAgaWYgKCFzdGF0ZS5vcHRpb25zLmxpbmtpZnkpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChqID0gMCwgbCA9IGJsb2NrVG9rZW5zLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgIGlmIChibG9ja1Rva2Vuc1tqXS50eXBlICE9PSAnaW5saW5lJykgeyBjb250aW51ZTsgfVxuICAgIHRva2VucyA9IGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuO1xuXG4gICAgaHRtbExpbmtMZXZlbCA9IDA7XG5cbiAgICAvLyBXZSBzY2FuIGZyb20gdGhlIGVuZCwgdG8ga2VlcCBwb3NpdGlvbiB3aGVuIG5ldyB0YWdzIGFkZGVkLlxuICAgIC8vIFVzZSByZXZlcnNlZCBsb2dpYyBpbiBsaW5rcyBzdGFydC9lbmQgbWF0Y2hcbiAgICBmb3IgKGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAvLyBTa2lwIGNvbnRlbnQgb2YgbWFya2Rvd24gbGlua3NcbiAgICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19jbG9zZScpIHtcbiAgICAgICAgaS0tO1xuICAgICAgICB3aGlsZSAodG9rZW5zW2ldLmxldmVsICE9PSB0b2tlbi5sZXZlbCAmJiB0b2tlbnNbaV0udHlwZSAhPT0gJ2xpbmtfb3BlbicpIHtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFNraXAgY29udGVudCBvZiBodG1sIHRhZyBsaW5rc1xuICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdodG1sdGFnJykge1xuICAgICAgICBpZiAoaXNMaW5rT3Blbih0b2tlbi5jb250ZW50KSAmJiBodG1sTGlua0xldmVsID4gMCkge1xuICAgICAgICAgIGh0bWxMaW5rTGV2ZWwtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMaW5rQ2xvc2UodG9rZW4uY29udGVudCkpIHtcbiAgICAgICAgICBodG1sTGlua0xldmVsKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChodG1sTGlua0xldmVsID4gMCkgeyBjb250aW51ZTsgfVxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIExJTktfU0NBTl9SRS50ZXN0KHRva2VuLmNvbnRlbnQpKSB7XG5cbiAgICAgICAgLy8gSW5pdCBsaW5raWZpZXIgaW4gbGF6eSBtYW5uZXIsIG9ubHkgaWYgcmVxdWlyZWQuXG4gICAgICAgIGlmICghbGlua2lmaWVyKSB7XG4gICAgICAgICAgbGlua2lmaWVyID0gY3JlYXRlTGlua2lmaWVyKCk7XG4gICAgICAgICAgbGlua3MgPSBsaW5raWZpZXIubGlua3M7XG4gICAgICAgICAgYXV0b2xpbmtlciA9IGxpbmtpZmllci5hdXRvbGlua2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dCA9IHRva2VuLmNvbnRlbnQ7XG4gICAgICAgIGxpbmtzLmxlbmd0aCA9IDA7XG4gICAgICAgIGF1dG9saW5rZXIubGluayh0ZXh0KTtcblxuICAgICAgICBpZiAoIWxpbmtzLmxlbmd0aCkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgIC8vIE5vdyBzcGxpdCBzdHJpbmcgdG8gbm9kZXNcbiAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgbGV2ZWwgPSB0b2tlbi5sZXZlbDtcblxuICAgICAgICBmb3IgKGxuID0gMDsgbG4gPCBsaW5rcy5sZW5ndGg7IGxuKyspIHtcblxuICAgICAgICAgIGlmICghc3RhdGUuaW5saW5lLnZhbGlkYXRlTGluayhsaW5rc1tsbl0udXJsKSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgcG9zID0gdGV4dC5pbmRleE9mKGxpbmtzW2xuXS50ZXh0KTtcblxuICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgIGxldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICBjb250ZW50OiB0ZXh0LnNsaWNlKDAsIHBvcyksXG4gICAgICAgICAgICAgIGxldmVsOiBsZXZlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2xpbmtfb3BlbicsXG4gICAgICAgICAgICBocmVmOiBsaW5rc1tsbl0udXJsLFxuICAgICAgICAgICAgdGl0bGU6ICcnLFxuICAgICAgICAgICAgbGV2ZWw6IGxldmVsKytcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGxpbmtzW2xuXS50ZXh0LFxuICAgICAgICAgICAgbGV2ZWw6IGxldmVsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnbGlua19jbG9zZScsXG4gICAgICAgICAgICBsZXZlbDogLS1sZXZlbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKHBvcyArIGxpbmtzW2xuXS50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICBjb250ZW50OiB0ZXh0LFxuICAgICAgICAgICAgbGV2ZWw6IGxldmVsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNlIGN1cnJlbnQgbm9kZVxuICAgICAgICBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbiA9IHRva2VucyA9IFtdLmNvbmNhdCh0b2tlbnMuc2xpY2UoMCwgaSksIG5vZGVzLCB0b2tlbnMuc2xpY2UoaSArIDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIFN0YXRlSW5saW5lICAgICAgICAgID0gcmVxdWlyZSgnLi4vcnVsZXNfaW5saW5lL3N0YXRlX2lubGluZScpO1xudmFyIHBhcnNlTGlua0xhYmVsICAgICAgID0gcmVxdWlyZSgnLi4vaGVscGVycy9wYXJzZV9saW5rX2xhYmVsJyk7XG52YXIgcGFyc2VMaW5rRGVzdGluYXRpb24gPSByZXF1aXJlKCcuLi9oZWxwZXJzL3BhcnNlX2xpbmtfZGVzdGluYXRpb24nKTtcbnZhciBwYXJzZUxpbmtUaXRsZSAgICAgICA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcGFyc2VfbGlua190aXRsZScpO1xudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vaGVscGVycy9ub3JtYWxpemVfcmVmZXJlbmNlJyk7XG5cblxuZnVuY3Rpb24gcGFyc2VSZWZlcmVuY2Uoc3RyLCBwYXJzZXIsIG9wdGlvbnMsIGVudikge1xuICB2YXIgc3RhdGUsIGxhYmVsRW5kLCBwb3MsIG1heCwgY29kZSwgc3RhcnQsIGhyZWYsIHRpdGxlLCBsYWJlbDtcblxuICBpZiAoc3RyLmNoYXJDb2RlQXQoMCkgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiAtMTsgfVxuXG4gIGlmIChzdHIuaW5kZXhPZignXTonKSA9PT0gLTEpIHsgcmV0dXJuIC0xOyB9XG5cbiAgc3RhdGUgPSBuZXcgU3RhdGVJbmxpbmUoc3RyLCBwYXJzZXIsIG9wdGlvbnMsIGVudiwgW10pO1xuICBsYWJlbEVuZCA9IHBhcnNlTGlua0xhYmVsKHN0YXRlLCAwKTtcblxuICBpZiAobGFiZWxFbmQgPCAwIHx8IHN0ci5jaGFyQ29kZUF0KGxhYmVsRW5kICsgMSkgIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiAtMTsgfVxuXG4gIG1heCA9IHN0YXRlLnBvc01heDtcblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgIF5eXiBza2lwIG9wdGlvbmFsIHdoaXRlc3BhY2UgaGVyZVxuICBmb3IgKHBvcyA9IGxhYmVsRW5kICsgMjsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjb2RlICE9PSAweDIwICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgXl5eXl5eXl5eXl4gcGFyc2UgdGhpc1xuICBpZiAoIXBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLCBwb3MpKSB7IHJldHVybiAtMTsgfVxuICBocmVmID0gc3RhdGUubGlua0NvbnRlbnQ7XG4gIHBvcyA9IHN0YXRlLnBvcztcblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgICAgICAgICAgICAgXl5eIHNraXBwaW5nIHRob3NlIHNwYWNlc1xuICBzdGFydCA9IHBvcztcbiAgZm9yIChwb3MgPSBwb3MgKyAxOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNvZGUgIT09IDB4MjAgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl4gcGFyc2UgdGhpc1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcGFyc2VMaW5rVGl0bGUoc3RhdGUsIHBvcykpIHtcbiAgICB0aXRsZSA9IHN0YXRlLmxpbmtDb250ZW50O1xuICAgIHBvcyA9IHN0YXRlLnBvcztcbiAgfSBlbHNlIHtcbiAgICB0aXRsZSA9ICcnO1xuICAgIHBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgLy8gZW5zdXJlIHRoYXQgdGhlIGVuZCBvZiB0aGUgbGluZSBpcyBlbXB0eVxuICB3aGlsZSAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjAvKiBzcGFjZSAqLykgeyBwb3MrKzsgfVxuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEpIHsgcmV0dXJuIC0xOyB9XG5cbiAgbGFiZWwgPSBub3JtYWxpemVSZWZlcmVuY2Uoc3RyLnNsaWNlKDEsIGxhYmVsRW5kKSk7XG4gIGlmICh0eXBlb2YgZW52LnJlZmVyZW5jZXNbbGFiZWxdID09PSAndW5kZWZpbmVkJykge1xuICAgIGVudi5yZWZlcmVuY2VzW2xhYmVsXSA9IHsgdGl0bGU6IHRpdGxlLCBocmVmOiBocmVmIH07XG4gIH1cblxuICByZXR1cm4gcG9zO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVmZXJlbmNlcyhzdGF0ZSkge1xuICB2YXIgdG9rZW5zID0gc3RhdGUudG9rZW5zLCBpLCBsLCBjb250ZW50LCBwb3M7XG5cbiAgc3RhdGUuZW52LnJlZmVyZW5jZXMgPSBzdGF0ZS5lbnYucmVmZXJlbmNlcyB8fCB7fTtcblxuICBpZiAoc3RhdGUuaW5saW5lTW9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFNjYW4gZGVmaW5pdGlvbnMgaW4gcGFyYWdyYXBoIGlubGluZXNcbiAgZm9yIChpID0gMSwgbCA9IHRva2Vucy5sZW5ndGggLSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHRva2Vuc1tpXS50eXBlID09PSAnaW5saW5lJyAmJlxuICAgICAgICB0b2tlbnNbaSAtIDFdLnR5cGUgPT09ICdwYXJhZ3JhcGhfb3BlbicgJiZcbiAgICAgICAgdG9rZW5zW2kgKyAxXS50eXBlID09PSAncGFyYWdyYXBoX2Nsb3NlJykge1xuXG4gICAgICBjb250ZW50ID0gdG9rZW5zW2ldLmNvbnRlbnQ7XG4gICAgICB3aGlsZSAoY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgcG9zID0gcGFyc2VSZWZlcmVuY2UoY29udGVudCwgc3RhdGUuaW5saW5lLCBzdGF0ZS5vcHRpb25zLCBzdGF0ZS5lbnYpO1xuICAgICAgICBpZiAocG9zIDwgMCkgeyBicmVhazsgfVxuICAgICAgICBjb250ZW50ID0gY29udGVudC5zbGljZShwb3MpLnRyaW0oKTtcbiAgICAgIH1cblxuICAgICAgdG9rZW5zW2ldLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgaWYgKCFjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICB0b2tlbnNbaSAtIDFdLnRpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgdG9rZW5zW2kgKyAxXS50aWdodCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIiwiLy8gU2ltcGxlIHR5cG9ncmFwaGljYWwgcmVwbGFjZW1lbnRzXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPOlxuLy8gLSBmcmFjdGlvbmFscyAxLzIsIDEvNCwgMy80IC0+IMK9LCDCvCwgwr5cbi8vIC0gbWlsdGlwbGljYXRpb24gMiB4IDQgLT4gMiDDlyA0XG5cbnZhciBSQVJFX1JFID0gL1xcKy18XFwuXFwufFxcP1xcP1xcP1xcP3whISEhfCwsfC0tLztcblxudmFyIFNDT1BFRF9BQkJSX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaWc7XG52YXIgU0NPUEVEX0FCQlIgPSB7XG4gICdjJzogJ8KpJyxcbiAgJ3InOiAnwq4nLFxuICAncCc6ICfCpycsXG4gICd0bSc6ICfihKInXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlU2NvcGVkQWJicihzdHIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKCcoJykgPCAwKSB7IHJldHVybiBzdHI7IH1cblxuICByZXR1cm4gc3RyLnJlcGxhY2UoU0NPUEVEX0FCQlJfUkUsIGZ1bmN0aW9uKG1hdGNoLCBuYW1lKSB7XG4gICAgcmV0dXJuIFNDT1BFRF9BQkJSW25hbWUudG9Mb3dlckNhc2UoKV07XG4gIH0pO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICB2YXIgaSwgdG9rZW4sIHRleHQsIGlubGluZVRva2VucywgYmxrSWR4O1xuXG4gIGlmICghc3RhdGUub3B0aW9ucy50eXBvZ3JhcGhlcikgeyByZXR1cm47IH1cblxuICBmb3IgKGJsa0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAxOyBibGtJZHggPj0gMDsgYmxrSWR4LS0pIHtcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSAnaW5saW5lJykgeyBjb250aW51ZTsgfVxuXG4gICAgaW5saW5lVG9rZW5zID0gc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW47XG5cbiAgICBmb3IgKGkgPSBpbmxpbmVUb2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRva2VuID0gaW5saW5lVG9rZW5zW2ldO1xuICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICB0ZXh0ID0gdG9rZW4uY29udGVudDtcblxuICAgICAgICB0ZXh0ID0gcmVwbGFjZVNjb3BlZEFiYnIodGV4dCk7XG5cbiAgICAgICAgaWYgKFJBUkVfUkUudGVzdCh0ZXh0KSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvXFwrLS9nLCAnwrEnKVxuICAgICAgICAgICAgLy8gLi4sIC4uLiwgLi4uLi4uLiAtPiDigKZcbiAgICAgICAgICAgIC8vIGJ1dCA/Li4uLi4gJiAhLi4uLi4gLT4gPy4uICYgIS4uXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwuezIsfS9nLCAn4oCmJykucmVwbGFjZSgvKFs/IV0p4oCmL2csICckMS4uJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oWz8hXSl7NCx9L2csICckMSQxJDEnKS5yZXBsYWNlKC8sezIsfS9nLCAnLCcpXG4gICAgICAgICAgICAvLyBlbS1kYXNoXG4gICAgICAgICAgICAucmVwbGFjZSgvKF58W14tXSktLS0oW14tXXwkKS9tZywgJyQxXFx1MjAxNCQyJylcbiAgICAgICAgICAgIC8vIGVuLWRhc2hcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXnxcXHMpLS0oXFxzfCQpL21nLCAnJDFcXHUyMDEzJDInKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyhefFteLVxcc10pLS0oW14tXFxzXXwkKS9tZywgJyQxXFx1MjAxMyQyJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0b2tlbi5jb250ZW50ID0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4iLCIvLyBDb252ZXJ0IHN0cmFpZ2h0IHF1b3RhdGlvbiBtYXJrcyB0byB0eXBvZ3JhcGhpYyBvbmVzXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBRVU9URV9URVNUX1JFID0gL1snXCJdLztcbnZhciBRVU9URV9SRSA9IC9bJ1wiXS9nO1xudmFyIFBVTkNUX1JFID0gL1stXFxzKClcXFtcXF1dLztcbnZhciBBUE9TVFJPUEhFID0gJ+KAmSc7XG5cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgYXQgYHBvc2Bcbi8vIGNvdWxkIGJlIGluc2lkZSBhIHdvcmQuXG5mdW5jdGlvbiBpc0xldHRlcihzdHIsIHBvcykge1xuICBpZiAocG9zIDwgMCB8fCBwb3MgPj0gc3RyLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgcmV0dXJuICFQVU5DVF9SRS50ZXN0KHN0cltwb3NdKTtcbn1cblxuXG5mdW5jdGlvbiByZXBsYWNlQXQoc3RyLCBpbmRleCwgY2gpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgaW5kZXgpICsgY2ggKyBzdHIuc3Vic3RyKGluZGV4ICsgMSk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzbWFydHF1b3RlcyhzdGF0ZSkge1xuICAvKmVzbGludCBtYXgtZGVwdGg6MCovXG4gIHZhciBpLCB0b2tlbiwgdGV4dCwgdCwgcG9zLCBtYXgsIHRoaXNMZXZlbCwgbGFzdFNwYWNlLCBuZXh0U3BhY2UsIGl0ZW0sXG4gICAgICBjYW5PcGVuLCBjYW5DbG9zZSwgaiwgaXNTaW5nbGUsIGJsa0lkeCwgdG9rZW5zLFxuICAgICAgc3RhY2s7XG5cbiAgaWYgKCFzdGF0ZS5vcHRpb25zLnR5cG9ncmFwaGVyKSB7IHJldHVybjsgfVxuXG4gIHN0YWNrID0gW107XG5cbiAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gJ2lubGluZScpIHsgY29udGludWU7IH1cblxuICAgIHRva2VucyA9IHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuO1xuICAgIHN0YWNrLmxlbmd0aCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgIT09ICd0ZXh0JyB8fCBRVU9URV9URVNUX1JFLnRlc3QodG9rZW4udGV4dCkpIHsgY29udGludWU7IH1cblxuICAgICAgdGhpc0xldmVsID0gdG9rZW5zW2ldLmxldmVsO1xuXG4gICAgICBmb3IgKGogPSBzdGFjay5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICBpZiAoc3RhY2tbal0ubGV2ZWwgPD0gdGhpc0xldmVsKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgICBzdGFjay5sZW5ndGggPSBqICsgMTtcblxuICAgICAgdGV4dCA9IHRva2VuLmNvbnRlbnQ7XG4gICAgICBwb3MgPSAwO1xuICAgICAgbWF4ID0gdGV4dC5sZW5ndGg7XG5cbiAgICAgIC8qZXNsaW50IG5vLWxhYmVsczowLGJsb2NrLXNjb3BlZC12YXI6MCovXG4gICAgICBPVVRFUjpcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgUVVPVEVfUkUubGFzdEluZGV4ID0gcG9zO1xuICAgICAgICB0ID0gUVVPVEVfUkUuZXhlYyh0ZXh0KTtcbiAgICAgICAgaWYgKCF0KSB7IGJyZWFrOyB9XG5cbiAgICAgICAgbGFzdFNwYWNlID0gIWlzTGV0dGVyKHRleHQsIHQuaW5kZXggLSAxKTtcbiAgICAgICAgcG9zID0gdC5pbmRleCArIDE7XG4gICAgICAgIGlzU2luZ2xlID0gKHRbMF0gPT09IFwiJ1wiKTtcbiAgICAgICAgbmV4dFNwYWNlID0gIWlzTGV0dGVyKHRleHQsIHBvcyk7XG5cbiAgICAgICAgaWYgKCFuZXh0U3BhY2UgJiYgIWxhc3RTcGFjZSkge1xuICAgICAgICAgIC8vIG1pZGRsZSBvZiB3b3JkXG4gICAgICAgICAgaWYgKGlzU2luZ2xlKSB7XG4gICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbk9wZW4gPSAhbmV4dFNwYWNlO1xuICAgICAgICBjYW5DbG9zZSA9ICFsYXN0U3BhY2U7XG5cbiAgICAgICAgaWYgKGNhbkNsb3NlKSB7XG4gICAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBhIGNsb3NpbmcgcXVvdGUsIHJld2luZCB0aGUgc3RhY2sgdG8gZ2V0IGEgbWF0Y2hcbiAgICAgICAgICBmb3IgKGogPSBzdGFjay5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgaXRlbSA9IHN0YWNrW2pdO1xuICAgICAgICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDwgdGhpc0xldmVsKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICBpZiAoaXRlbS5zaW5nbGUgPT09IGlzU2luZ2xlICYmIHN0YWNrW2pdLmxldmVsID09PSB0aGlzTGV2ZWwpIHtcbiAgICAgICAgICAgICAgaXRlbSA9IHN0YWNrW2pdO1xuICAgICAgICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCwgaXRlbS5wb3MsIHN0YXRlLm9wdGlvbnMucXVvdGVzWzJdKTtcbiAgICAgICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIHN0YXRlLm9wdGlvbnMucXVvdGVzWzNdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCwgaXRlbS5wb3MsIHN0YXRlLm9wdGlvbnMucXVvdGVzWzBdKTtcbiAgICAgICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIHN0YXRlLm9wdGlvbnMucXVvdGVzWzFdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGFjay5sZW5ndGggPSBqO1xuICAgICAgICAgICAgICBjb250aW51ZSBPVVRFUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FuT3Blbikge1xuICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgdG9rZW46IGksXG4gICAgICAgICAgICBwb3M6IHQuaW5kZXgsXG4gICAgICAgICAgICBzaW5nbGU6IGlzU2luZ2xlLFxuICAgICAgICAgICAgbGV2ZWw6IHRoaXNMZXZlbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNhbkNsb3NlICYmIGlzU2luZ2xlKSB7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBBUE9TVFJPUEhFKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbiIsIi8vIFByb2Nlc3MgYXV0b2xpbmtzICc8cHJvdG9jb2w6Li4uPidcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXJsX3NjaGVtYXMgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91cmxfc2NoZW1hcycpO1xudmFyIG5vcm1hbGl6ZUxpbmsgPSByZXF1aXJlKCcuLi9oZWxwZXJzL25vcm1hbGl6ZV9saW5rJyk7XG5cblxuLyplc2xpbnQgbWF4LWxlbjowKi9cbnZhciBFTUFJTF9SRSAgICA9IC9ePChbYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqKT4vO1xudmFyIEFVVE9MSU5LX1JFID0gL148KFthLXpBLVouXFwtXXsxLDI1fSk6KFtePD5cXHgwMC1cXHgyMF0qKT4vO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXV0b2xpbmsoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgdGFpbCwgbGlua01hdGNoLCBlbWFpbE1hdGNoLCB1cmwsIGZ1bGxVcmwsIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgdGFpbCA9IHN0YXRlLnNyYy5zbGljZShwb3MpO1xuXG4gIGlmICh0YWlsLmluZGV4T2YoJz4nKSA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGlua01hdGNoID0gdGFpbC5tYXRjaChBVVRPTElOS19SRSk7XG5cbiAgaWYgKGxpbmtNYXRjaCkge1xuICAgIGlmICh1cmxfc2NoZW1hcy5pbmRleE9mKGxpbmtNYXRjaFsxXS50b0xvd2VyQ2FzZSgpKSA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICB1cmwgPSBsaW5rTWF0Y2hbMF0uc2xpY2UoMSwgLTEpO1xuICAgIGZ1bGxVcmwgPSBub3JtYWxpemVMaW5rKHVybCk7XG4gICAgaWYgKCFzdGF0ZS5wYXJzZXIudmFsaWRhdGVMaW5rKHVybCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgc3RhdGUucHVzaCh7XG4gICAgICAgIHR5cGU6ICdsaW5rX29wZW4nLFxuICAgICAgICBocmVmOiBmdWxsVXJsLFxuICAgICAgICBsZXZlbDogc3RhdGUubGV2ZWxcbiAgICAgIH0pO1xuICAgICAgc3RhdGUucHVzaCh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgY29udGVudDogdXJsLFxuICAgICAgICBsZXZlbDogc3RhdGUubGV2ZWwgKyAxXG4gICAgICB9KTtcbiAgICAgIHN0YXRlLnB1c2goeyB0eXBlOiAnbGlua19jbG9zZScsIGxldmVsOiBzdGF0ZS5sZXZlbCB9KTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gbGlua01hdGNoWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGVtYWlsTWF0Y2ggPSB0YWlsLm1hdGNoKEVNQUlMX1JFKTtcblxuICBpZiAoZW1haWxNYXRjaCkge1xuXG4gICAgdXJsID0gZW1haWxNYXRjaFswXS5zbGljZSgxLCAtMSk7XG5cbiAgICBmdWxsVXJsID0gbm9ybWFsaXplTGluaygnbWFpbHRvOicgKyB1cmwpO1xuICAgIGlmICghc3RhdGUucGFyc2VyLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICBzdGF0ZS5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2xpbmtfb3BlbicsXG4gICAgICAgIGhyZWY6IGZ1bGxVcmwsXG4gICAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbFxuICAgICAgfSk7XG4gICAgICBzdGF0ZS5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBjb250ZW50OiB1cmwsXG4gICAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbCArIDFcbiAgICAgIH0pO1xuICAgICAgc3RhdGUucHVzaCh7IHR5cGU6ICdsaW5rX2Nsb3NlJywgbGV2ZWw6IHN0YXRlLmxldmVsIH0pO1xuICAgIH1cblxuICAgIHN0YXRlLnBvcyArPSBlbWFpbE1hdGNoWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIvLyBQYXJzZSBiYWNrdGlja3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJhY2t0aWNrcyhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBzdGFydCwgbWF4LCBtYXJrZXIsIG1hdGNoU3RhcnQsIG1hdGNoRW5kLFxuICAgICAgcG9zID0gc3RhdGUucG9zLFxuICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChjaCAhPT0gMHg2MC8qIGAgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc3RhcnQgPSBwb3M7XG4gIHBvcysrO1xuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDYwLyogYCAqLykgeyBwb3MrKzsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKTtcblxuICBtYXRjaFN0YXJ0ID0gbWF0Y2hFbmQgPSBwb3M7XG5cbiAgd2hpbGUgKChtYXRjaFN0YXJ0ID0gc3RhdGUuc3JjLmluZGV4T2YoJ2AnLCBtYXRjaEVuZCkpICE9PSAtMSkge1xuICAgIG1hdGNoRW5kID0gbWF0Y2hTdGFydCArIDE7XG5cbiAgICB3aGlsZSAobWF0Y2hFbmQgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQobWF0Y2hFbmQpID09PSAweDYwLyogYCAqLykgeyBtYXRjaEVuZCsrOyB9XG5cbiAgICBpZiAobWF0Y2hFbmQgLSBtYXRjaFN0YXJ0ID09PSBtYXJrZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBzdGF0ZS5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgICAgY29udGVudDogc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF0Y2hTdGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bIFxcbl0rL2csICcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmltKCksXG4gICAgICAgICAgYmxvY2s6IGZhbHNlLFxuICAgICAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IG1hdGNoRW5kO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBtYXJrZXI7IH1cbiAgc3RhdGUucG9zICs9IG1hcmtlci5sZW5ndGg7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFByb2Nlc3Mgfn5kZWxldGVkIHRleHR+flxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVsKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGZvdW5kLFxuICAgICAgcG9zLFxuICAgICAgc3RhY2ssXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIGxhc3RDaGFyLFxuICAgICAgbmV4dENoYXI7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KSAhPT0gMHg3RS8qIH4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGRvbid0IHJ1biBhbnkgcGFpcnMgaW4gdmFsaWRhdGlvbiBtb2RlXG4gIGlmIChzdGFydCArIDQgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQgKyAxKSAhPT0gMHg3RS8qIH4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5sZXZlbCA+PSBzdGF0ZS5vcHRpb25zLm1heE5lc3RpbmcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFzdENoYXIgPSBzdGFydCA+IDAgPyBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCAtIDEpIDogLTE7XG4gIG5leHRDaGFyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQgKyAyKTtcblxuICBpZiAobGFzdENoYXIgPT09IDB4N0UvKiB+ICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAobmV4dENoYXIgPT09IDB4N0UvKiB+ICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAobmV4dENoYXIgPT09IDB4MjAgfHwgbmV4dENoYXIgPT09IDB4MEEpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gc3RhcnQgKyAyO1xuICB3aGlsZSAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4N0UvKiB+ICovKSB7IHBvcysrOyB9XG4gIGlmIChwb3MgPiBzdGFydCArIDMpIHtcbiAgICAvLyBzZXF1ZW5jZSBvZiA0KyBtYXJrZXJzIHRha2luZyBhcyBsaXRlcmFsLCBzYW1lIGFzIGluIGEgZW1waGFzaXNcbiAgICBzdGF0ZS5wb3MgKz0gcG9zIC0gc3RhcnQ7XG4gICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcyk7IH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgMjtcbiAgc3RhY2sgPSAxO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgKyAxIDwgbWF4KSB7XG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcykgPT09IDB4N0UvKiB+ICovKSB7XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zICsgMSkgPT09IDB4N0UvKiB+ICovKSB7XG4gICAgICAgIGxhc3RDaGFyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zIC0gMSk7XG4gICAgICAgIG5leHRDaGFyID0gc3RhdGUucG9zICsgMiA8IG1heCA/IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyArIDIpIDogLTE7XG4gICAgICAgIGlmIChuZXh0Q2hhciAhPT0gMHg3RS8qIH4gKi8gJiYgbGFzdENoYXIgIT09IDB4N0UvKiB+ICovKSB7XG4gICAgICAgICAgaWYgKGxhc3RDaGFyICE9PSAweDIwICYmIGxhc3RDaGFyICE9PSAweDBBKSB7XG4gICAgICAgICAgICAvLyBjbG9zaW5nICd+fidcbiAgICAgICAgICAgIHN0YWNrLS07XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciAhPT0gMHgyMCAmJiBuZXh0Q2hhciAhPT0gMHgwQSkge1xuICAgICAgICAgICAgLy8gb3BlbmluZyAnfn4nXG4gICAgICAgICAgICBzdGFjaysrO1xuICAgICAgICAgIH0gLy8gZWxzZSB7XG4gICAgICAgICAgICAvLyAgLy8gc3RhbmRhbG9uZSAnIH5+ICcgaW5kZW50ZWQgd2l0aCBzcGFjZXNcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICBpZiAoc3RhY2sgPD0gMCkge1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUucGFyc2VyLnNraXBUb2tlbihzdGF0ZSk7XG4gIH1cblxuICBpZiAoIWZvdW5kKSB7XG4gICAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kIGVuZGluZyB0YWcsIHNvIGl0J3Mgbm90IHZhbGlkIGVtcGhhc2lzXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZm91bmQhXG4gIHN0YXRlLnBvc01heCA9IHN0YXRlLnBvcztcbiAgc3RhdGUucG9zID0gc3RhcnQgKyAyO1xuXG4gIGlmICghc2lsZW50KSB7XG4gICAgc3RhdGUucHVzaCh7IHR5cGU6ICdkZWxfb3BlbicsIGxldmVsOiBzdGF0ZS5sZXZlbCsrIH0pO1xuICAgIHN0YXRlLnBhcnNlci50b2tlbml6ZShzdGF0ZSk7XG4gICAgc3RhdGUucHVzaCh7IHR5cGU6ICdkZWxfY2xvc2UnLCBsZXZlbDogLS1zdGF0ZS5sZXZlbCB9KTtcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXRlLnBvc01heCArIDI7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2VzcyAqdGhpcyogYW5kIF90aGF0X1xuXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gaXNBbHBoYU51bShjb2RlKSB7XG4gIHJldHVybiAoY29kZSA+PSAweDMwIC8qIDAgKi8gJiYgY29kZSA8PSAweDM5IC8qIDkgKi8pIHx8XG4gICAgICAgICAoY29kZSA+PSAweDQxIC8qIEEgKi8gJiYgY29kZSA8PSAweDVBIC8qIFogKi8pIHx8XG4gICAgICAgICAoY29kZSA+PSAweDYxIC8qIGEgKi8gJiYgY29kZSA8PSAweDdBIC8qIHogKi8pO1xufVxuXG4vLyBwYXJzZSBzZXF1ZW5jZSBvZiBlbXBoYXNpcyBtYXJrZXJzLFxuLy8gXCJzdGFydFwiIHNob3VsZCBwb2ludCBhdCBhIHZhbGlkIG1hcmtlclxuZnVuY3Rpb24gc2NhbkRlbGltcyhzdGF0ZSwgc3RhcnQpIHtcbiAgdmFyIHBvcyA9IHN0YXJ0LCBsYXN0Q2hhciwgbmV4dENoYXIsIGNvdW50LFxuICAgICAgY2FuX29wZW4gPSB0cnVlLFxuICAgICAgY2FuX2Nsb3NlID0gdHJ1ZSxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcbiAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICBsYXN0Q2hhciA9IHN0YXJ0ID4gMCA/IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0IC0gMSkgOiAtMTtcblxuICB3aGlsZSAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IG1hcmtlcikgeyBwb3MrKzsgfVxuICBpZiAocG9zID49IG1heCkgeyBjYW5fb3BlbiA9IGZhbHNlOyB9XG4gIGNvdW50ID0gcG9zIC0gc3RhcnQ7XG5cbiAgaWYgKGNvdW50ID49IDQpIHtcbiAgICAvLyBzZXF1ZW5jZSBvZiBmb3VyIG9yIG1vcmUgdW5lc2NhcGVkIG1hcmtlcnMgY2FuJ3Qgc3RhcnQvZW5kIGFuIGVtcGhhc2lzXG4gICAgY2FuX29wZW4gPSBjYW5fY2xvc2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0Q2hhciA9IHBvcyA8IG1heCA/IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgOiAtMTtcblxuICAgIC8vIGNoZWNrIHdoaXRlc3BhY2UgY29uZGl0aW9uc1xuICAgIGlmIChuZXh0Q2hhciA9PT0gMHgyMCB8fCBuZXh0Q2hhciA9PT0gMHgwQSkgeyBjYW5fb3BlbiA9IGZhbHNlOyB9XG4gICAgaWYgKGxhc3RDaGFyID09PSAweDIwIHx8IGxhc3RDaGFyID09PSAweDBBKSB7IGNhbl9jbG9zZSA9IGZhbHNlOyB9XG5cbiAgICBpZiAobWFya2VyID09PSAweDVGIC8qIF8gKi8pIHtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZW4ndCBpbnNpZGUgdGhlIHdvcmRcbiAgICAgIGlmIChpc0FscGhhTnVtKGxhc3RDaGFyKSkgeyBjYW5fb3BlbiA9IGZhbHNlOyB9XG4gICAgICBpZiAoaXNBbHBoYU51bShuZXh0Q2hhcikpIHsgY2FuX2Nsb3NlID0gZmFsc2U7IH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNhbl9vcGVuOiBjYW5fb3BlbixcbiAgICBjYW5fY2xvc2U6IGNhbl9jbG9zZSxcbiAgICBkZWxpbXM6IGNvdW50XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW1waGFzaXMoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgc3RhcnRDb3VudCxcbiAgICAgIGNvdW50LFxuICAgICAgZm91bmQsXG4gICAgICBvbGRDb3VudCxcbiAgICAgIG5ld0NvdW50LFxuICAgICAgc3RhY2ssXG4gICAgICByZXMsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICBpZiAobWFya2VyICE9PSAweDVGLyogXyAqLyAmJiBtYXJrZXIgIT09IDB4MkEgLyogKiAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gZmFsc2U7IH0gLy8gZG9uJ3QgcnVuIGFueSBwYWlycyBpbiB2YWxpZGF0aW9uIG1vZGVcblxuICByZXMgPSBzY2FuRGVsaW1zKHN0YXRlLCBzdGFydCk7XG4gIHN0YXJ0Q291bnQgPSByZXMuZGVsaW1zO1xuICBpZiAoIXJlcy5jYW5fb3Blbikge1xuICAgIHN0YXRlLnBvcyArPSBzdGFydENvdW50O1xuICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBzdGF0ZS5wb3MpOyB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc3RhdGUubGV2ZWwgPj0gc3RhdGUub3B0aW9ucy5tYXhOZXN0aW5nKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgc3RhcnRDb3VudDtcbiAgc3RhY2sgPSBbIHN0YXJ0Q291bnQgXTtcblxuICB3aGlsZSAoc3RhdGUucG9zIDwgbWF4KSB7XG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcykgPT09IG1hcmtlcikge1xuICAgICAgcmVzID0gc2NhbkRlbGltcyhzdGF0ZSwgc3RhdGUucG9zKTtcbiAgICAgIGNvdW50ID0gcmVzLmRlbGltcztcbiAgICAgIGlmIChyZXMuY2FuX2Nsb3NlKSB7XG4gICAgICAgIG9sZENvdW50ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIG5ld0NvdW50ID0gY291bnQ7XG5cbiAgICAgICAgd2hpbGUgKG9sZENvdW50ICE9PSBuZXdDb3VudCkge1xuICAgICAgICAgIGlmIChuZXdDb3VudCA8IG9sZENvdW50KSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKG9sZENvdW50IC0gbmV3Q291bnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYXNzZXJ0KG5ld0NvdW50ID4gb2xkQ291bnQpXG4gICAgICAgICAgbmV3Q291bnQgLT0gb2xkQ291bnQ7XG5cbiAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgICAgc3RhdGUucG9zICs9IG9sZENvdW50O1xuICAgICAgICAgIG9sZENvdW50ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgc3RhcnRDb3VudCA9IG9sZENvdW50O1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wb3MgKz0gY291bnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzLmNhbl9vcGVuKSB7IHN0YWNrLnB1c2goY291bnQpOyB9XG4gICAgICBzdGF0ZS5wb3MgKz0gY291bnQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wYXJzZXIuc2tpcFRva2VuKHN0YXRlKTtcbiAgfVxuXG4gIGlmICghZm91bmQpIHtcbiAgICAvLyBwYXJzZXIgZmFpbGVkIHRvIGZpbmQgZW5kaW5nIHRhZywgc28gaXQncyBub3QgdmFsaWQgZW1waGFzaXNcbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBmb3VuZCFcbiAgc3RhdGUucG9zTWF4ID0gc3RhdGUucG9zO1xuICBzdGF0ZS5wb3MgPSBzdGFydCArIHN0YXJ0Q291bnQ7XG5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBpZiAoc3RhcnRDb3VudCA9PT0gMiB8fCBzdGFydENvdW50ID09PSAzKSB7XG4gICAgICBzdGF0ZS5wdXNoKHsgdHlwZTogJ3N0cm9uZ19vcGVuJywgbGV2ZWw6IHN0YXRlLmxldmVsKysgfSk7XG4gICAgfVxuICAgIGlmIChzdGFydENvdW50ID09PSAxIHx8IHN0YXJ0Q291bnQgPT09IDMpIHtcbiAgICAgIHN0YXRlLnB1c2goeyB0eXBlOiAnZW1fb3BlbicsIGxldmVsOiBzdGF0ZS5sZXZlbCsrIH0pO1xuICAgIH1cblxuICAgIHN0YXRlLnBhcnNlci50b2tlbml6ZShzdGF0ZSk7XG5cbiAgICBpZiAoc3RhcnRDb3VudCA9PT0gMSB8fCBzdGFydENvdW50ID09PSAzKSB7XG4gICAgICBzdGF0ZS5wdXNoKHsgdHlwZTogJ2VtX2Nsb3NlJywgbGV2ZWw6IC0tc3RhdGUubGV2ZWwgfSk7XG4gICAgfVxuICAgIGlmIChzdGFydENvdW50ID09PSAyIHx8IHN0YXJ0Q291bnQgPT09IDMpIHtcbiAgICAgIHN0YXRlLnB1c2goeyB0eXBlOiAnc3Ryb25nX2Nsb3NlJywgbGV2ZWw6IC0tc3RhdGUubGV2ZWwgfSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhdGUucG9zTWF4ICsgc3RhcnRDb3VudDtcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQcm9jZXNzIGh0bWwgZW50aXR5IC0gJiMxMjM7LCAmI3hBRjssICZxdW90OywgLi4uXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVudGl0aWVzICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL2VudGl0aWVzJyk7XG52YXIgaGFzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5oYXM7XG52YXIgaXNWYWxpZEVudGl0eUNvZGUgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1ZhbGlkRW50aXR5Q29kZTtcbnZhciBmcm9tQ29kZVBvaW50ICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmZyb21Db2RlUG9pbnQ7XG5cblxudmFyIERJR0lUQUxfUkUgPSAvXiYjKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKTsvaTtcbnZhciBOQU1FRF9SRSAgID0gL14mKFthLXpdW2EtejAtOV17MSwzMX0pOy9pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW50aXR5KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBjb2RlLCBtYXRjaCwgcG9zID0gc3RhdGUucG9zLCBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjYvKiAmICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChwb3MgKyAxIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKTtcblxuICAgIGlmIChjaCA9PT0gMHgyMyAvKiAjICovKSB7XG4gICAgICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKERJR0lUQUxfUkUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgY29kZSA9IG1hdGNoWzFdWzBdLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/IHBhcnNlSW50KG1hdGNoWzFdLnNsaWNlKDEpLCAxNikgOiBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICAgIHN0YXRlLnBlbmRpbmcgKz0gaXNWYWxpZEVudGl0eUNvZGUoY29kZSkgPyBmcm9tQ29kZVBvaW50KGNvZGUpIDogZnJvbUNvZGVQb2ludCgweEZGRkQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKE5BTUVEX1JFKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoaGFzKGVudGl0aWVzLCBtYXRjaFsxXSkpIHtcbiAgICAgICAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IGVudGl0aWVzW21hdGNoWzFdXTsgfVxuICAgICAgICAgIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9ICcmJzsgfVxuICBzdGF0ZS5wb3MrKztcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2Vlc3MgZXNjYXBlZCBjaGFycyBhbmQgaGFyZGJyZWFrc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFU0NBUEVEID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHsgRVNDQVBFRC5wdXNoKDApOyB9XG5cbidcXFxcIVwiIyQlJlxcJygpKissLi86Ozw9Pj9AW11eX2B7fH1+LSdcbiAgLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGNoKSB7IEVTQ0FQRURbY2guY2hhckNvZGVBdCgwKV0gPSAxOyB9KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgcG9zID0gc3RhdGUucG9zLCBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4NUMvKiBcXCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MrKztcblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNoIDwgMjU2ICYmIEVTQ0FQRURbY2hdICE9PSAwKSB7XG4gICAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyY1twb3NdOyB9XG4gICAgICBzdGF0ZS5wb3MgKz0gMjtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgc3RhdGUucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ2hhcmRicmVhaycsXG4gICAgICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICAgIC8vIHNraXAgbGVhZGluZyB3aGl0ZXNwYWNlcyBmcm9tIG5leHQgbGluZVxuICAgICAgd2hpbGUgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwKSB7IHBvcysrOyB9XG5cbiAgICAgIHN0YXRlLnBvcyA9IHBvcztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gJ1xcXFwnOyB9XG4gIHN0YXRlLnBvcysrO1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQcm9jZXNzIGlubGluZSBmb290bm90ZXMgKF5bLi4uXSlcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2VMaW5rTGFiZWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWwnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvb3Rub3RlX2lubGluZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBsYWJlbFN0YXJ0LFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBmb290bm90ZUlkLFxuICAgICAgb2xkTGVuZ3RoLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXJ0ICsgMiA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCkgIT09IDB4NUUvKiBeICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQgKyAxKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5sZXZlbCA+PSBzdGF0ZS5vcHRpb25zLm1heE5lc3RpbmcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFiZWxTdGFydCA9IHN0YXJ0ICsgMjtcbiAgbGFiZWxFbmQgPSBwYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhcnQgKyAxKTtcblxuICAvLyBwYXJzZXIgZmFpbGVkIHRvIGZpbmQgJ10nLCBzbyBpdCdzIG5vdCBhIHZhbGlkIG5vdGVcbiAgaWYgKGxhYmVsRW5kIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXG4gIC8vXG4gIGlmICghc2lsZW50KSB7XG4gICAgaWYgKCFzdGF0ZS5lbnYuZm9vdG5vdGVzKSB7IHN0YXRlLmVudi5mb290bm90ZXMgPSB7fTsgfVxuICAgIGlmICghc3RhdGUuZW52LmZvb3Rub3Rlcy5saXN0KSB7IHN0YXRlLmVudi5mb290bm90ZXMubGlzdCA9IFtdOyB9XG4gICAgZm9vdG5vdGVJZCA9IHN0YXRlLmVudi5mb290bm90ZXMubGlzdC5sZW5ndGg7XG5cbiAgICBzdGF0ZS5wb3MgPSBsYWJlbFN0YXJ0O1xuICAgIHN0YXRlLnBvc01heCA9IGxhYmVsRW5kO1xuXG4gICAgc3RhdGUucHVzaCh7XG4gICAgICB0eXBlOiAnZm9vdG5vdGVfcmVmJyxcbiAgICAgIGlkOiBmb290bm90ZUlkLFxuICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsXG4gICAgfSk7XG4gICAgc3RhdGUubGlua0xldmVsKys7XG4gICAgb2xkTGVuZ3RoID0gc3RhdGUudG9rZW5zLmxlbmd0aDtcbiAgICBzdGF0ZS5wYXJzZXIudG9rZW5pemUoc3RhdGUpO1xuICAgIHN0YXRlLmVudi5mb290bm90ZXMubGlzdFtmb290bm90ZUlkXSA9IHsgdG9rZW5zOiBzdGF0ZS50b2tlbnMuc3BsaWNlKG9sZExlbmd0aCkgfTtcbiAgICBzdGF0ZS5saW5rTGV2ZWwtLTtcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IGxhYmVsRW5kICsgMTtcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQcm9jZXNzIGZvb3Rub3RlIHJlZmVyZW5jZXMgKFteLi4uXSlcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9vdG5vdGVfcmVmKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGxhYmVsLFxuICAgICAgcG9zLFxuICAgICAgZm9vdG5vdGVJZCxcbiAgICAgIGZvb3Rub3RlU3ViSWQsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcztcblxuICAvLyBzaG91bGQgYmUgYXQgbGVhc3QgNCBjaGFycyAtIFwiW154XVwiXG4gIGlmIChzdGFydCArIDMgPiBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzdGF0ZS5lbnYuZm9vdG5vdGVzIHx8ICFzdGF0ZS5lbnYuZm9vdG5vdGVzLnJlZnMpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCkgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQgKyAxKSAhPT0gMHg1RS8qIF4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5sZXZlbCA+PSBzdGF0ZS5vcHRpb25zLm1heE5lc3RpbmcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgZm9yIChwb3MgPSBzdGFydCArIDI7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAocG9zID09PSBzdGFydCArIDIpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIG5vIGVtcHR5IGZvb3Rub3RlIGxhYmVsc1xuICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgcG9zKys7XG5cbiAgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQgKyAyLCBwb3MgLSAxKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYuZm9vdG5vdGVzLnJlZnNbJzonICsgbGFiZWxdID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXNpbGVudCkge1xuICAgIGlmICghc3RhdGUuZW52LmZvb3Rub3Rlcy5saXN0KSB7IHN0YXRlLmVudi5mb290bm90ZXMubGlzdCA9IFtdOyB9XG5cbiAgICBpZiAoc3RhdGUuZW52LmZvb3Rub3Rlcy5yZWZzWyc6JyArIGxhYmVsXSA8IDApIHtcbiAgICAgIGZvb3Rub3RlSWQgPSBzdGF0ZS5lbnYuZm9vdG5vdGVzLmxpc3QubGVuZ3RoO1xuICAgICAgc3RhdGUuZW52LmZvb3Rub3Rlcy5saXN0W2Zvb3Rub3RlSWRdID0geyBsYWJlbDogbGFiZWwsIGNvdW50OiAwIH07XG4gICAgICBzdGF0ZS5lbnYuZm9vdG5vdGVzLnJlZnNbJzonICsgbGFiZWxdID0gZm9vdG5vdGVJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9vdG5vdGVJZCA9IHN0YXRlLmVudi5mb290bm90ZXMucmVmc1snOicgKyBsYWJlbF07XG4gICAgfVxuXG4gICAgZm9vdG5vdGVTdWJJZCA9IHN0YXRlLmVudi5mb290bm90ZXMubGlzdFtmb290bm90ZUlkXS5jb3VudDtcbiAgICBzdGF0ZS5lbnYuZm9vdG5vdGVzLmxpc3RbZm9vdG5vdGVJZF0uY291bnQrKztcblxuICAgIHN0YXRlLnB1c2goe1xuICAgICAgdHlwZTogJ2Zvb3Rub3RlX3JlZicsXG4gICAgICBpZDogZm9vdG5vdGVJZCxcbiAgICAgIHN1YklkOiBmb290bm90ZVN1YklkLFxuICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsXG4gICAgfSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2VzcyBodG1sIHRhZ3NcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBIVE1MX1RBR19SRSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX3JlJykuSFRNTF9UQUdfUkU7XG5cblxuZnVuY3Rpb24gaXNMZXR0ZXIoY2gpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgdmFyIGxjID0gY2ggfCAweDIwOyAvLyB0byBsb3dlciBjYXNlXG4gIHJldHVybiAobGMgPj0gMHg2MS8qIGEgKi8pICYmIChsYyA8PSAweDdhLyogeiAqLyk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBodG1sdGFnKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBtYXRjaCwgbWF4LCBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKCFzdGF0ZS5vcHRpb25zLmh0bWwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gQ2hlY2sgc3RhcnRcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8gfHxcbiAgICAgIHBvcyArIDIgPj0gbWF4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gUXVpY2sgZmFpbCBvbiBzZWNvbmQgY2hhclxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICBpZiAoY2ggIT09IDB4MjEvKiAhICovICYmXG4gICAgICBjaCAhPT0gMHgzRi8qID8gKi8gJiZcbiAgICAgIGNoICE9PSAweDJGLyogLyAqLyAmJlxuICAgICAgIWlzTGV0dGVyKGNoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goSFRNTF9UQUdfUkUpO1xuICBpZiAoIW1hdGNoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICghc2lsZW50KSB7XG4gICAgc3RhdGUucHVzaCh7XG4gICAgICB0eXBlOiAnaHRtbHRhZycsXG4gICAgICBjb250ZW50OiBzdGF0ZS5zcmMuc2xpY2UocG9zLCBwb3MgKyBtYXRjaFswXS5sZW5ndGgpLFxuICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsXG4gICAgfSk7XG4gIH1cbiAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2VzcyArK2luc2VydGVkIHRleHQrK1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5zKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGZvdW5kLFxuICAgICAgcG9zLFxuICAgICAgc3RhY2ssXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIGxhc3RDaGFyLFxuICAgICAgbmV4dENoYXI7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KSAhPT0gMHgyQi8qICsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGRvbid0IHJ1biBhbnkgcGFpcnMgaW4gdmFsaWRhdGlvbiBtb2RlXG4gIGlmIChzdGFydCArIDQgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQgKyAxKSAhPT0gMHgyQi8qICsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5sZXZlbCA+PSBzdGF0ZS5vcHRpb25zLm1heE5lc3RpbmcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFzdENoYXIgPSBzdGFydCA+IDAgPyBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCAtIDEpIDogLTE7XG4gIG5leHRDaGFyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQgKyAyKTtcblxuICBpZiAobGFzdENoYXIgPT09IDB4MkIvKiArICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAobmV4dENoYXIgPT09IDB4MkIvKiArICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAobmV4dENoYXIgPT09IDB4MjAgfHwgbmV4dENoYXIgPT09IDB4MEEpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gc3RhcnQgKyAyO1xuICB3aGlsZSAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MkIvKiArICovKSB7IHBvcysrOyB9XG4gIGlmIChwb3MgIT09IHN0YXJ0ICsgMikge1xuICAgIC8vIHNlcXVlbmNlIG9mIDMrIG1hcmtlcnMgdGFraW5nIGFzIGxpdGVyYWwsIHNhbWUgYXMgaW4gYSBlbXBoYXNpc1xuICAgIHN0YXRlLnBvcyArPSBwb3MgLSBzdGFydDtcbiAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKTsgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhcnQgKyAyO1xuICBzdGFjayA9IDE7XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyArIDEgPCBtYXgpIHtcbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSA9PT0gMHgyQi8qICsgKi8pIHtcbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MgKyAxKSA9PT0gMHgyQi8qICsgKi8pIHtcbiAgICAgICAgbGFzdENoYXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MgLSAxKTtcbiAgICAgICAgbmV4dENoYXIgPSBzdGF0ZS5wb3MgKyAyIDwgbWF4ID8gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zICsgMikgOiAtMTtcbiAgICAgICAgaWYgKG5leHRDaGFyICE9PSAweDJCLyogKyAqLyAmJiBsYXN0Q2hhciAhPT0gMHgyQi8qICsgKi8pIHtcbiAgICAgICAgICBpZiAobGFzdENoYXIgIT09IDB4MjAgJiYgbGFzdENoYXIgIT09IDB4MEEpIHtcbiAgICAgICAgICAgIC8vIGNsb3NpbmcgJysrJ1xuICAgICAgICAgICAgc3RhY2stLTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyICE9PSAweDIwICYmIG5leHRDaGFyICE9PSAweDBBKSB7XG4gICAgICAgICAgICAvLyBvcGVuaW5nICcrKydcbiAgICAgICAgICAgIHN0YWNrKys7XG4gICAgICAgICAgfSAvLyBlbHNlIHtcbiAgICAgICAgICAgIC8vICAvLyBzdGFuZGFsb25lICcgKysgJyBpbmRlbnRlZCB3aXRoIHNwYWNlc1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgIGlmIChzdGFjayA8PSAwKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5wYXJzZXIuc2tpcFRva2VuKHN0YXRlKTtcbiAgfVxuXG4gIGlmICghZm91bmQpIHtcbiAgICAvLyBwYXJzZXIgZmFpbGVkIHRvIGZpbmQgZW5kaW5nIHRhZywgc28gaXQncyBub3QgdmFsaWQgZW1waGFzaXNcbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBmb3VuZCFcbiAgc3RhdGUucG9zTWF4ID0gc3RhdGUucG9zO1xuICBzdGF0ZS5wb3MgPSBzdGFydCArIDI7XG5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBzdGF0ZS5wdXNoKHsgdHlwZTogJ2luc19vcGVuJywgbGV2ZWw6IHN0YXRlLmxldmVsKysgfSk7XG4gICAgc3RhdGUucGFyc2VyLnRva2VuaXplKHN0YXRlKTtcbiAgICBzdGF0ZS5wdXNoKHsgdHlwZTogJ2luc19jbG9zZScsIGxldmVsOiAtLXN0YXRlLmxldmVsIH0pO1xuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhdGUucG9zTWF4ICsgMjtcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQcm9jZXNzIFtsaW5rc10oPHRvPiBcInN0dWZmXCIpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlTGlua0xhYmVsICAgICAgID0gcmVxdWlyZSgnLi4vaGVscGVycy9wYXJzZV9saW5rX2xhYmVsJyk7XG52YXIgcGFyc2VMaW5rRGVzdGluYXRpb24gPSByZXF1aXJlKCcuLi9oZWxwZXJzL3BhcnNlX2xpbmtfZGVzdGluYXRpb24nKTtcbnZhciBwYXJzZUxpbmtUaXRsZSAgICAgICA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcGFyc2VfbGlua190aXRsZScpO1xudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vaGVscGVycy9ub3JtYWxpemVfcmVmZXJlbmNlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5rcyhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBsYWJlbFN0YXJ0LFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBsYWJlbCxcbiAgICAgIGhyZWYsXG4gICAgICB0aXRsZSxcbiAgICAgIHBvcyxcbiAgICAgIHJlZixcbiAgICAgIGNvZGUsXG4gICAgICBpc0ltYWdlID0gZmFsc2UsXG4gICAgICBvbGRQb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICBpZiAobWFya2VyID09PSAweDIxLyogISAqLykge1xuICAgIGlzSW1hZ2UgPSB0cnVlO1xuICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KCsrc3RhcnQpO1xuICB9XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5sZXZlbCA+PSBzdGF0ZS5vcHRpb25zLm1heE5lc3RpbmcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFiZWxTdGFydCA9IHN0YXJ0ICsgMTtcbiAgbGFiZWxFbmQgPSBwYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhcnQpO1xuXG4gIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCAnXScsIHNvIGl0J3Mgbm90IGEgdmFsaWQgbGlua1xuICBpZiAobGFiZWxFbmQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDI4LyogKCAqLykge1xuICAgIC8vXG4gICAgLy8gSW5saW5lIGxpbmtcbiAgICAvL1xuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgcG9zKys7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKGNvZGUgIT09IDB4MjAgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgXl5eXl5eIHBhcnNpbmcgbGluayBkZXN0aW5hdGlvblxuICAgIHN0YXJ0ID0gcG9zO1xuICAgIGlmIChwYXJzZUxpbmtEZXN0aW5hdGlvbihzdGF0ZSwgcG9zKSkge1xuICAgICAgaHJlZiA9IHN0YXRlLmxpbmtDb250ZW50O1xuICAgICAgcG9zID0gc3RhdGUucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBocmVmID0gJyc7XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBzdGFydCA9IHBvcztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoY29kZSAhPT0gMHgyMCAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICAgIF5eXl5eXl4gcGFyc2luZyBsaW5rIHRpdGxlXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHBhcnNlTGlua1RpdGxlKHN0YXRlLCBwb3MpKSB7XG4gICAgICB0aXRsZSA9IHN0YXRlLmxpbmtDb250ZW50O1xuICAgICAgcG9zID0gc3RhdGUucG9zO1xuXG4gICAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKGNvZGUgIT09IDB4MjAgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gbWF4IHx8IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjkvKiApICovKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHBvcysrO1xuICB9IGVsc2Uge1xuICAgIC8vXG4gICAgLy8gTGluayByZWZlcmVuY2VcbiAgICAvL1xuXG4gICAgLy8gZG8gbm90IGFsbG93IG5lc3RlZCByZWZlcmVuY2UgbGlua3NcbiAgICBpZiAoc3RhdGUubGlua0xldmVsID4gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIFtmb29dICBbYmFyXVxuICAgIC8vICAgICAgXl4gb3B0aW9uYWwgd2hpdGVzcGFjZSAoY2FuIGluY2x1ZGUgbmV3bGluZXMpXG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKGNvZGUgIT09IDB4MjAgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1Qi8qIFsgKi8pIHtcbiAgICAgIHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgIHBvcyA9IHBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBzdGFydCAtIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY292ZXJzIGxhYmVsID09PSAnJyBhbmQgbGFiZWwgPT09IHVuZGVmaW5lZFxuICAgIC8vIChjb2xsYXBzZWQgcmVmZXJlbmNlIGxpbmsgYW5kIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rIHJlc3BlY3RpdmVseSlcbiAgICBpZiAoIWxhYmVsKSB7XG4gICAgICBpZiAodHlwZW9mIGxhYmVsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICB9XG4gICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShsYWJlbFN0YXJ0LCBsYWJlbEVuZCk7XG4gICAgfVxuXG4gICAgcmVmID0gc3RhdGUuZW52LnJlZmVyZW5jZXNbbm9ybWFsaXplUmVmZXJlbmNlKGxhYmVsKV07XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaHJlZiA9IHJlZi5ocmVmO1xuICAgIHRpdGxlID0gcmVmLnRpdGxlO1xuICB9XG5cbiAgLy9cbiAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiB0aGUgbGluaywgYW5kIGtub3cgZm9yIGEgZmFjdCBpdCdzIGEgdmFsaWQgbGluaztcbiAgLy8gc28gYWxsIHRoYXQncyBsZWZ0IHRvIGRvIGlzIHRvIGNhbGwgdG9rZW5pemVyLlxuICAvL1xuICBpZiAoIXNpbGVudCkge1xuICAgIHN0YXRlLnBvcyA9IGxhYmVsU3RhcnQ7XG4gICAgc3RhdGUucG9zTWF4ID0gbGFiZWxFbmQ7XG5cbiAgICBpZiAoaXNJbWFnZSkge1xuICAgICAgc3RhdGUucHVzaCh7XG4gICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgIHNyYzogaHJlZixcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICBhbHQ6IHN0YXRlLnNyYy5zdWJzdHIobGFiZWxTdGFydCwgbGFiZWxFbmQgLSBsYWJlbFN0YXJ0KSxcbiAgICAgICAgbGV2ZWw6IHN0YXRlLmxldmVsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHVzaCh7XG4gICAgICAgIHR5cGU6ICdsaW5rX29wZW4nLFxuICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbCsrXG4gICAgICB9KTtcbiAgICAgIHN0YXRlLmxpbmtMZXZlbCsrO1xuICAgICAgc3RhdGUucGFyc2VyLnRva2VuaXplKHN0YXRlKTtcbiAgICAgIHN0YXRlLmxpbmtMZXZlbC0tO1xuICAgICAgc3RhdGUucHVzaCh7IHR5cGU6ICdsaW5rX2Nsb3NlJywgbGV2ZWw6IC0tc3RhdGUubGV2ZWwgfSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICBzdGF0ZS5wb3NNYXggPSBtYXg7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFByb2Nlc3MgPT1oaWdobGlnaHRlZCB0ZXh0PT1cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlbChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBmb3VuZCxcbiAgICAgIHBvcyxcbiAgICAgIHN0YWNrLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBsYXN0Q2hhcixcbiAgICAgIG5leHRDaGFyO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCkgIT09IDB4M0QvKiA9ICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc2lsZW50KSB7IHJldHVybiBmYWxzZTsgfSAvLyBkb24ndCBydW4gYW55IHBhaXJzIGluIHZhbGlkYXRpb24gbW9kZVxuICBpZiAoc3RhcnQgKyA0ID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0ICsgMSkgIT09IDB4M0QvKiA9ICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUubGV2ZWwgPj0gc3RhdGUub3B0aW9ucy5tYXhOZXN0aW5nKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxhc3RDaGFyID0gc3RhcnQgPiAwID8gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQgLSAxKSA6IC0xO1xuICBuZXh0Q2hhciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0ICsgMik7XG5cbiAgaWYgKGxhc3RDaGFyID09PSAweDNELyogPSAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKG5leHRDaGFyID09PSAweDNELyogPSAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKG5leHRDaGFyID09PSAweDIwIHx8IG5leHRDaGFyID09PSAweDBBKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IHN0YXJ0ICsgMjtcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDNELyogPSAqLykgeyBwb3MrKzsgfVxuICBpZiAocG9zICE9PSBzdGFydCArIDIpIHtcbiAgICAvLyBzZXF1ZW5jZSBvZiAzKyBtYXJrZXJzIHRha2luZyBhcyBsaXRlcmFsLCBzYW1lIGFzIGluIGEgZW1waGFzaXNcbiAgICBzdGF0ZS5wb3MgKz0gcG9zIC0gc3RhcnQ7XG4gICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcyk7IH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgMjtcbiAgc3RhY2sgPSAxO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgKyAxIDwgbWF4KSB7XG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcykgPT09IDB4M0QvKiA9ICovKSB7XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zICsgMSkgPT09IDB4M0QvKiA9ICovKSB7XG4gICAgICAgIGxhc3RDaGFyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zIC0gMSk7XG4gICAgICAgIG5leHRDaGFyID0gc3RhdGUucG9zICsgMiA8IG1heCA/IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyArIDIpIDogLTE7XG4gICAgICAgIGlmIChuZXh0Q2hhciAhPT0gMHgzRC8qID0gKi8gJiYgbGFzdENoYXIgIT09IDB4M0QvKiA9ICovKSB7XG4gICAgICAgICAgaWYgKGxhc3RDaGFyICE9PSAweDIwICYmIGxhc3RDaGFyICE9PSAweDBBKSB7XG4gICAgICAgICAgICAvLyBjbG9zaW5nICc9PSdcbiAgICAgICAgICAgIHN0YWNrLS07XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciAhPT0gMHgyMCAmJiBuZXh0Q2hhciAhPT0gMHgwQSkge1xuICAgICAgICAgICAgLy8gb3BlbmluZyAnPT0nXG4gICAgICAgICAgICBzdGFjaysrO1xuICAgICAgICAgIH0gLy8gZWxzZSB7XG4gICAgICAgICAgICAvLyAgLy8gc3RhbmRhbG9uZSAnID09ICcgaW5kZW50ZWQgd2l0aCBzcGFjZXNcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICBpZiAoc3RhY2sgPD0gMCkge1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUucGFyc2VyLnNraXBUb2tlbihzdGF0ZSk7XG4gIH1cblxuICBpZiAoIWZvdW5kKSB7XG4gICAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kIGVuZGluZyB0YWcsIHNvIGl0J3Mgbm90IHZhbGlkIGVtcGhhc2lzXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZm91bmQhXG4gIHN0YXRlLnBvc01heCA9IHN0YXRlLnBvcztcbiAgc3RhdGUucG9zID0gc3RhcnQgKyAyO1xuXG4gIGlmICghc2lsZW50KSB7XG4gICAgc3RhdGUucHVzaCh7IHR5cGU6ICdtYXJrX29wZW4nLCBsZXZlbDogc3RhdGUubGV2ZWwrKyB9KTtcbiAgICBzdGF0ZS5wYXJzZXIudG9rZW5pemUoc3RhdGUpO1xuICAgIHN0YXRlLnB1c2goeyB0eXBlOiAnbWFya19jbG9zZScsIGxldmVsOiAtLXN0YXRlLmxldmVsIH0pO1xuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhdGUucG9zTWF4ICsgMjtcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQcm9jZWVzcyAnXFxuJ1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbmV3bGluZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBwbWF4LCBtYXgsIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQS8qIFxcbiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwbWF4ID0gc3RhdGUucGVuZGluZy5sZW5ndGggLSAxO1xuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgLy8gJyAgXFxuJyAtPiBoYXJkYnJlYWtcbiAgLy8gTG9va3VwIGluIHBlbmRpbmcgY2hhcnMgaXMgYmFkIHByYWN0aWNlISBEb24ndCBjb3B5IHRvIG90aGVyIHJ1bGVzIVxuICAvLyBQZW5kaW5nIHN0cmluZyBpcyBzdG9yZWQgaW4gY29uY2F0IG1vZGUsIGluZGV4ZWQgbG9va3VwcyB3aWxsIGNhdXNlXG4gIC8vIGNvbnZlcnRpb24gdG8gZmxhdCBtb2RlLlxuICBpZiAoIXNpbGVudCkge1xuICAgIGlmIChwbWF4ID49IDAgJiYgc3RhdGUucGVuZGluZy5jaGFyQ29kZUF0KHBtYXgpID09PSAweDIwKSB7XG4gICAgICBpZiAocG1heCA+PSAxICYmIHN0YXRlLnBlbmRpbmcuY2hhckNvZGVBdChwbWF4IC0gMSkgPT09IDB4MjApIHtcbiAgICAgICAgLy8gU3RyaXAgb3V0IGFsbCB0cmFpbGluZyBzcGFjZXMgb24gdGhpcyBsaW5lLlxuICAgICAgICBmb3IgKHZhciBpID0gcG1heCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnBlbmRpbmcuY2hhckNvZGVBdChpKSAhPT0gMHgyMCkge1xuICAgICAgICAgICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcuc3Vic3RyaW5nKDAsIGkgKyAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnaGFyZGJyZWFrJyxcbiAgICAgICAgICBsZXZlbDogc3RhdGUubGV2ZWxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nID0gc3RhdGUucGVuZGluZy5zbGljZSgwLCAtMSk7XG4gICAgICAgIHN0YXRlLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdzb2Z0YnJlYWsnLFxuICAgICAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3NvZnRicmVhaycsXG4gICAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcG9zKys7XG5cbiAgLy8gc2tpcCBoZWFkaW5nIHNwYWNlcyBmb3IgbmV4dCBsaW5lXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCkgeyBwb3MrKzsgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gSW5saW5lIHBhcnNlciBzdGF0ZVxuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIFN0YXRlSW5saW5lKHNyYywgcGFyc2VySW5saW5lLCBvcHRpb25zLCBlbnYsIG91dFRva2Vucykge1xuICB0aGlzLnNyYyA9IHNyYztcbiAgdGhpcy5lbnYgPSBlbnY7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMucGFyc2VyID0gcGFyc2VySW5saW5lO1xuICB0aGlzLnRva2VucyA9IG91dFRva2VucztcbiAgdGhpcy5wb3MgPSAwO1xuICB0aGlzLnBvc01heCA9IHRoaXMuc3JjLmxlbmd0aDtcbiAgdGhpcy5sZXZlbCA9IDA7XG4gIHRoaXMucGVuZGluZyA9ICcnO1xuICB0aGlzLnBlbmRpbmdMZXZlbCA9IDA7XG5cbiAgdGhpcy5jYWNoZSA9IFtdOyAgICAgICAgLy8gU3RvcmVzIHsgc3RhcnQ6IGVuZCB9IHBhaXJzLiBVc2VmdWwgZm9yIGJhY2t0cmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpbWl6YXRpb24gb2YgcGFpcnMgcGFyc2UgKGVtcGhhc2lzLCBzdHJpa2VzKS5cblxuICAvLyBMaW5rIHBhcnNlciBzdGF0ZSB2YXJzXG5cbiAgdGhpcy5pc0luTGFiZWwgPSBmYWxzZTsgLy8gU2V0IHRydWUgd2hlbiBzZWVrIGxpbmsgbGFiZWwgLSB3ZSBzaG91bGQgZGlzYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcInBhaXJlZFwiIHJ1bGVzIChlbXBoYXNpcywgc3RyaWtlcykgdG8gbm90IHNraXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFpbGluZyBgXWBcblxuICB0aGlzLmxpbmtMZXZlbCA9IDA7ICAgICAvLyBJbmNyZW1lbnQgZm9yIGVhY2ggbmVzdGluZyBsaW5rLiBVc2VkIHRvIHByZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVzdGluZyBpbiBkZWZpbml0aW9uc1xuXG4gIHRoaXMubGlua0NvbnRlbnQgPSAnJzsgIC8vIFRlbXBvcmFyeSBzdG9yYWdlIGZvciBsaW5rIHVybFxuXG4gIHRoaXMubGFiZWxVbm1hdGNoZWRTY29wZXMgPSAwOyAvLyBUcmFjayB1bnBhaXJlZCBgW2AgZm9yIGxpbmsgbGFiZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoYmFja3RyYWNrIG9wdGltaXphdGlvbilcbn1cblxuLy8gRmx1c2ggcGVuZGluZyB0ZXh0XG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnB1c2hQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICB0eXBlOiAndGV4dCcsXG4gICAgY29udGVudDogdGhpcy5wZW5kaW5nLFxuICAgIGxldmVsOiB0aGlzLnBlbmRpbmdMZXZlbFxuICB9KTtcbiAgdGhpcy5wZW5kaW5nID0gJyc7XG59O1xuXG4vLyBQdXNoIG5ldyB0b2tlbiB0byBcInN0cmVhbVwiLlxuLy8gSWYgcGVuZGluZyB0ZXh0IGV4aXN0cyAtIGZsdXNoIGl0IGFzIHRleHQgdG9rZW5cbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICBpZiAodGhpcy5wZW5kaW5nKSB7XG4gICAgdGhpcy5wdXNoUGVuZGluZygpO1xuICB9XG5cbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHRoaXMucGVuZGluZ0xldmVsID0gdGhpcy5sZXZlbDtcbn07XG5cbi8vIFN0b3JlIHZhbHVlIHRvIGNhY2hlLlxuLy8gISEhIEltcGxlbWVudGF0aW9uIGhhcyBwYXJzZXItc3BlY2lmaWMgb3B0aW1pemF0aW9uc1xuLy8gISEhIGtleXMgTVVTVCBiZSBpbnRlZ2VyLCA+PSAwOyB2YWx1ZXMgTVVTVCBiZSBpbnRlZ2VyLCA+IDBcbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUuY2FjaGVTZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuY2FjaGUubGVuZ3RoOyBpIDw9IGtleTsgaSsrKSB7XG4gICAgdGhpcy5jYWNoZS5wdXNoKDApO1xuICB9XG5cbiAgdGhpcy5jYWNoZVtrZXldID0gdmFsO1xufTtcblxuLy8gR2V0IGNhY2hlIHZhbHVlXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLmNhY2hlR2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5IDwgdGhpcy5jYWNoZS5sZW5ndGggPyB0aGlzLmNhY2hlW2tleV0gOiAwO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUlubGluZTtcbiIsIi8vIFByb2Nlc3MgfnN1YnNjcmlwdH5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBzYW1lIGFzIFVORVNDQVBFX01EX1JFIHBsdXMgYSBzcGFjZVxudmFyIFVORVNDQVBFX1JFID0gL1xcXFwoWyBcXFxcIVwiIyQlJicoKSorLC5cXC86Ozw9Pj9AW1xcXV5fYHt8fX4tXSkvZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdWIoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgZm91bmQsXG4gICAgICBjb250ZW50LFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KSAhPT0gMHg3RS8qIH4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGRvbid0IHJ1biBhbnkgcGFpcnMgaW4gdmFsaWRhdGlvbiBtb2RlXG4gIGlmIChzdGFydCArIDIgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUubGV2ZWwgPj0gc3RhdGUub3B0aW9ucy5tYXhOZXN0aW5nKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgMTtcblxuICB3aGlsZSAoc3RhdGUucG9zIDwgbWF4KSB7XG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcykgPT09IDB4N0UvKiB+ICovKSB7XG4gICAgICBmb3VuZCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzdGF0ZS5wYXJzZXIuc2tpcFRva2VuKHN0YXRlKTtcbiAgfVxuXG4gIGlmICghZm91bmQgfHwgc3RhcnQgKyAxID09PSBzdGF0ZS5wb3MpIHtcbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0ICsgMSwgc3RhdGUucG9zKTtcblxuICAvLyBkb24ndCBhbGxvdyB1bmVzY2FwZWQgc3BhY2VzL25ld2xpbmVzIGluc2lkZVxuICBpZiAoY29udGVudC5tYXRjaCgvKF58W15cXFxcXSkoXFxcXFxcXFwpKlxccy8pKSB7XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZm91bmQhXG4gIHN0YXRlLnBvc01heCA9IHN0YXRlLnBvcztcbiAgc3RhdGUucG9zID0gc3RhcnQgKyAxO1xuXG4gIGlmICghc2lsZW50KSB7XG4gICAgc3RhdGUucHVzaCh7XG4gICAgICB0eXBlOiAnc3ViJyxcbiAgICAgIGxldmVsOiBzdGF0ZS5sZXZlbCxcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnQucmVwbGFjZShVTkVTQ0FQRV9SRSwgJyQxJylcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXRlLnBvc01heCArIDE7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2VzcyBec3VwZXJzY3JpcHReXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gc2FtZSBhcyBVTkVTQ0FQRV9NRF9SRSBwbHVzIGEgc3BhY2VcbnZhciBVTkVTQ0FQRV9SRSA9IC9cXFxcKFsgXFxcXCFcIiMkJSYnKCkqKywuXFwvOjs8PT4/QFtcXF1eX2B7fH1+LV0pL2c7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3VwKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGZvdW5kLFxuICAgICAgY29udGVudCxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCkgIT09IDB4NUUvKiBeICovKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc2lsZW50KSB7IHJldHVybiBmYWxzZTsgfSAvLyBkb24ndCBydW4gYW55IHBhaXJzIGluIHZhbGlkYXRpb24gbW9kZVxuICBpZiAoc3RhcnQgKyAyID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLmxldmVsID49IHN0YXRlLm9wdGlvbnMubWF4TmVzdGluZykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydCArIDE7XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyA8IG1heCkge1xuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpID09PSAweDVFLyogXiAqLykge1xuICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc3RhdGUucGFyc2VyLnNraXBUb2tlbihzdGF0ZSk7XG4gIH1cblxuICBpZiAoIWZvdW5kIHx8IHN0YXJ0ICsgMSA9PT0gc3RhdGUucG9zKSB7XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCArIDEsIHN0YXRlLnBvcyk7XG5cbiAgLy8gZG9uJ3QgYWxsb3cgdW5lc2NhcGVkIHNwYWNlcy9uZXdsaW5lcyBpbnNpZGVcbiAgaWYgKGNvbnRlbnQubWF0Y2goLyhefFteXFxcXF0pKFxcXFxcXFxcKSpcXHMvKSkge1xuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGZvdW5kIVxuICBzdGF0ZS5wb3NNYXggPSBzdGF0ZS5wb3M7XG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgMTtcblxuICBpZiAoIXNpbGVudCkge1xuICAgIHN0YXRlLnB1c2goe1xuICAgICAgdHlwZTogJ3N1cCcsXG4gICAgICBsZXZlbDogc3RhdGUubGV2ZWwsXG4gICAgICBjb250ZW50OiBjb250ZW50LnJlcGxhY2UoVU5FU0NBUEVfUkUsICckMScpXG4gICAgfSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGF0ZS5wb3NNYXggKyAxO1xuICBzdGF0ZS5wb3NNYXggPSBtYXg7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFNraXAgdGV4dCBjaGFyYWN0ZXJzIGZvciB0ZXh0IHRva2VuLCBwbGFjZSB0aG9zZSB0byBwZW5kaW5nIGJ1ZmZlclxuLy8gYW5kIGluY3JlbWVudCBjdXJyZW50IHBvc1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFJ1bGUgdG8gc2tpcCBwdXJlIHRleHRcbi8vICd7fSQlQH4rPTonIHJlc2VydmVkIGZvciBleHRlbnRpb25zXG5cbmZ1bmN0aW9uIGlzVGVybWluYXRvckNoYXIoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgwQS8qIFxcbiAqLzpcbiAgICBjYXNlIDB4NUMvKiBcXCAqLzpcbiAgICBjYXNlIDB4NjAvKiBgICovOlxuICAgIGNhc2UgMHgyQS8qICogKi86XG4gICAgY2FzZSAweDVGLyogXyAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4MjEvKiAhICovOlxuICAgIGNhc2UgMHgyNi8qICYgKi86XG4gICAgY2FzZSAweDNDLyogPCAqLzpcbiAgICBjYXNlIDB4M0UvKiA+ICovOlxuICAgIGNhc2UgMHg3Qi8qIHsgKi86XG4gICAgY2FzZSAweDdELyogfSAqLzpcbiAgICBjYXNlIDB4MjQvKiAkICovOlxuICAgIGNhc2UgMHgyNS8qICUgKi86XG4gICAgY2FzZSAweDQwLyogQCAqLzpcbiAgICBjYXNlIDB4N0UvKiB+ICovOlxuICAgIGNhc2UgMHgyQi8qICsgKi86XG4gICAgY2FzZSAweDNELyogPSAqLzpcbiAgICBjYXNlIDB4M0EvKiA6ICovOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleHQoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgcG9zID0gc3RhdGUucG9zO1xuXG4gIHdoaWxlIChwb3MgPCBzdGF0ZS5wb3NNYXggJiYgIWlzVGVybWluYXRvckNoYXIoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChwb3MgPT09IHN0YXRlLnBvcykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShzdGF0ZS5wb3MsIHBvcyk7IH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbn07XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIGZvciBTaGFkb3cgUm9vdCBzdHlsZSBpLmVcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1t0YXJnZXRdXG5cdH07XG59KSgpO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuICAgICAgICBpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50byArIFwiIFwiICsgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsImV4cG9ydCBjb25zdCBvbmxpbmVVcmwgPVxuICBcImh0dHBzOi8vZXUxLnByaXNtYS5zaC9ib2F6LWJsYWtlLTg5NTFlMS9taXRocmlsLXByZXNlbnRlci9kZXZcIlxuIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCdcclxuaW1wb3J0IFN0cmVhbSBmcm9tICdtaXRocmlsLXN0cmVhbSdcclxuXHJcbmltcG9ydCBQcmVzZW50YXRpb25zIGZyb20gJy4vcHJlc2VudGF0aW9ucy9jb21wb25lbnQuanMnXHJcbmltcG9ydCBTbGlkZXMgZnJvbSAnLi9zbGlkZXMvY29tcG9uZW50LmpzJ1xyXG5pbXBvcnQgRWRpdG9yIGZyb20gJy4vZWRpdG9yL2NvbXBvbmVudC5qcydcclxuaW1wb3J0IExheW91dCBmcm9tICcuL2xheW91dC9jb21wb25lbnQuanMnXHJcbmltcG9ydCBTbGlkZVNob3cgZnJvbSAnLi9zbGlkZXNob3cvY29tcG9uZW50LmpzJ1xyXG5pbXBvcnQgeyBnZXRQcmVzZW50YXRpb25zIH0gZnJvbSAnLi9wcmVzZW50YXRpb25zL21vZGVsLmpzJ1xyXG5pbXBvcnQgeyBsb2cgfSBmcm9tICcuL3NlcnZpY2VzL2luZGV4LmpzJ1xyXG5cclxuY29uc3QgbWFrZVJvdXRlcyA9IG1kbCA9PiB7XHJcbiAgbGV0IG1vZGVsID0gU3RyZWFtKG1kbClcclxuICByZXR1cm4ge1xyXG4gICAgJy9wcmVzZW50YXRpb25zJzoge1xyXG4gICAgICB2aWV3OiAoKSA9PiBtKExheW91dCwgbW9kZWwoKSwgbShQcmVzZW50YXRpb25zLCBtb2RlbCgpKSksXHJcbiAgICB9LFxyXG4gICAgJy9wcmVzZW50YXRpb24vOmlkL3NsaWRlcyc6IHtcclxuICAgICAgdmlldzogKCkgPT4gbShMYXlvdXQsIG1vZGVsKCksIG0oU2xpZGVzLCBtb2RlbCgpKSksXHJcbiAgICB9LFxyXG4gICAgJy9lZGl0LzpwaWQvc2xpZGUvOmlkJzoge1xyXG4gICAgICB2aWV3OiAoKSA9PiBtKExheW91dCwgbW9kZWwoKSwgbShFZGl0b3IsIG1vZGVsKCkpKSxcclxuICAgIH0sXHJcbiAgICAnL3NsaWRlc2hvdy86aWQnOiB7XHJcbiAgICAgIHZpZXc6ICgpID0+IG0oTGF5b3V0LCBtb2RlbCgpLCBtKFNsaWRlU2hvdywgbW9kZWwoKSkpLFxyXG4gICAgfSxcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBBcHAgPSAoeyBhdHRyczogbW9kZWwgfSkgPT4ge1xyXG4gIGNvbnN0IHN0YXRlID0ge1xyXG4gICAgZXJyb3JzOiAnJyxcclxuICB9XHJcblxyXG4gIGNvbnN0IG9uRXJyb3IgPSBlcnJvciA9PiB7XHJcbiAgICBsb2coJ2Vycm9yJykoZXJyb3IpXHJcbiAgICBzdGF0ZS5lcnJvciA9IGVycm9yXHJcbiAgfVxyXG5cclxuICBjb25zdCBvblN1Y2Nlc3MgPSBNb2RlbHMgPT4gZHRvID0+IChNb2RlbHMuUHJlc2VudGF0aW9ucyA9IGR0bylcclxuXHJcbiAgY29uc3QgZmluZFByZXNlbnRhdGlvbnMgPSAoeyBhdHRyczogeyBNb2RlbHMgfSB9KSA9PlxyXG4gICAgZ2V0UHJlc2VudGF0aW9ucygpLmZvcmsob25FcnJvciwgb25TdWNjZXNzKE1vZGVscykpXHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBvbmluaXQ6IGZpbmRQcmVzZW50YXRpb25zLFxyXG4gICAgb25jcmVhdGU6ICh7IGRvbSB9KSA9PiB7XHJcbiAgICAgIGNvbnN0IG1haW4gPSBkb20ucXVlcnlTZWxlY3RvcignLm1haW4nKVxyXG5cclxuICAgICAgbS5yb3V0ZShtYWluLCAnL3ByZXNlbnRhdGlvbnMnLCBtYWtlUm91dGVzKG1vZGVsKSlcclxuICAgIH0sXHJcbiAgICB2aWV3OiAoeyBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgICAgIHJldHVybiBtKCcuYXBwJyxbbSgnLm1haW4nLCBjaGlsZHJlbildKVxyXG4gICAgfSxcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFwcFxyXG4iLCJpbXBvcnQgU3RyZWFtIGZyb20gJ21pdGhyaWwtc3RyZWFtJ1xyXG5cclxuY29uc3QgU2xpZGVNb2RlbCA9IHtcclxuICB0aXRsZTogJycsXHJcbiAgY29udGVudHM6ICcnLFxyXG4gIG9yZGVyOiAwLFxyXG4gIHByZXNlbnRhdGlvbl9pZDogJycsXHJcbn1cclxuXHJcbmNvbnN0IFNsaWRlcyA9IFtdXHJcblxyXG5jb25zdCBQcmVzZW50YXRpb25zID0gW11cclxuXHJcbmNvbnN0IFNsaWRlU2hvd1N0cnVjdCA9IHtcclxuICBrZXlzOiBuZXcgU2V0KCksXHJcbiAgdmFsdWVzOiB7fSxcclxuICBpdGVtczogU3RyZWFtKFtdKSxcclxufVxyXG5cclxuY29uc3QgQ3VycmVudFByZXNlbnRhdGlvbiA9IHtcclxuICB0aXRsZTogJycsXHJcbiAgaWQ6ICcnLFxyXG4gIHNsaWRlU2hvdzogU3RyZWFtKFtdKSxcclxuICBTbGlkZXMsXHJcbn1cclxuXHJcbmNvbnN0IGdldFByb2ZpbGUgPSAodykgID0+IHtcclxuICBpZiAodyA8IDY2OCkgcmV0dXJuICdwaG9uZSdcclxuICBpZiAodyA8IDkyMCkgcmV0dXJuICd0YWJsZXQnXHJcbiAgcmV0dXJuICdkZXNrdG9wJ1xyXG59XHJcblxyXG5jb25zdCBNb2RlbHMgPSB7XHJcbiAgcHJvZmlsZTogIGdldFByb2ZpbGUod2luZG93LmlubmVyV2lkdGgpLFxyXG4gIFNsaWRlU2hvd1N0cnVjdCxcclxuICBQcmVzZW50YXRpb25zLFxyXG4gIEN1cnJlbnRQcmVzZW50YXRpb24sXHJcbiAgU2xpZGVNb2RlbCxcclxuICB0b2dnbGVNb2RhbDogZmFsc2UsXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1vZGVsc1xyXG4iLCJpbXBvcnQgbSBmcm9tIFwibWl0aHJpbFwiXHJcbmltcG9ydCB7IGlzRW1wdHksIGxlbmd0aCwgc3BsaXQsIHZpZXcsIGxlbnNQcm9wIH0gZnJvbSBcInJhbWRhXCJcclxuXHJcbmNvbnN0IHRvZ2dsZU1vZGFsID0gbW9kZWwgPT4ge1xyXG4gIHJldHVybiBbXHJcbiAgICBtKFxyXG4gICAgICBcImEudG9vbGJhci1pdGVtXCIsXHJcbiAgICAgIHtcclxuICAgICAgICBvbmNsaWNrOiAoKSA9PiAobW9kZWwudG9nZ2xlTW9kYWwgPSAhbW9kZWwudG9nZ2xlTW9kYWwpLFxyXG4gICAgICB9LFxyXG4gICAgICBcIkFkZCBOZXdcIlxyXG4gICAgKSxcclxuICBdXHJcbn1cclxuY29uc3QgdG9QcmVzZW50YXRpb25zID0gW1xyXG4gIG0oXHJcbiAgICBcImEudG9vbGJhci1pdGVtXCIsXHJcbiAgICB7XHJcbiAgICAgIG9uY3JlYXRlOiBtLnJvdXRlLmxpbmssXHJcbiAgICAgIGhyZWY6IFwiL3ByZXNlbnRhdGlvbnNcIixcclxuICAgIH0sXHJcbiAgICBcIlByZXNlbnRhdGlvbnNcIlxyXG4gICksXHJcbl1cclxuXHJcbmNvbnN0IHRvU2xpZGVzID0gbW9kZWwgPT4gW1xyXG4gIG0oXHJcbiAgICBcImEudG9vbGJhci1pdGVtXCIsXHJcbiAgICB7XHJcbiAgICAgIG9uY3JlYXRlOiBtLnJvdXRlLmxpbmssXHJcbiAgICAgIGhyZWY6IGAvcHJlc2VudGF0aW9uLyR7bW9kZWwuQ3VycmVudFByZXNlbnRhdGlvbi5pZH0vc2xpZGVzYCxcclxuICAgIH0sXHJcbiAgICBcInNsaWRlc1wiXHJcbiAgKSxcclxuXVxyXG5cclxuY29uc3QgdG9TbGlkZVNob3cgPSBtb2RlbCA9PiBbXHJcbiAgbShcclxuICAgIFwiYS50b29sYmFyLWl0ZW1cIixcclxuICAgIHtcclxuICAgICAgZGlzYWJsZWQ6IGlzRW1wdHkobGVuZ3RoKG1vZGVsLkN1cnJlbnRQcmVzZW50YXRpb24uc2xpZGVTaG93KSlcclxuICAgICAgICA/IHRydWVcclxuICAgICAgICA6IGZhbHNlLFxyXG4gICAgICBvbmNyZWF0ZTogbS5yb3V0ZS5saW5rLFxyXG4gICAgICBocmVmOiBgL3NsaWRlc2hvdy8ke21vZGVsLkN1cnJlbnRQcmVzZW50YXRpb24uaWR9YCxcclxuICAgIH0sXHJcbiAgICBcIlNsaWRlIFNob3dcIlxyXG4gICksXHJcbl1cclxuXHJcbmNvbnN0IG5hdlZpZXcgPSBtb2RlbCA9PiBwYWdlID0+IHtcclxuICBzd2l0Y2ggKHBhZ2UpIHtcclxuICAgIGNhc2UgXCJwcmVzZW50YXRpb25cIjpcclxuICAgICAgcmV0dXJuIFt0b1ByZXNlbnRhdGlvbnMsIHRvU2xpZGVTaG93KG1vZGVsKV1cclxuICAgICAgYnJlYWtcclxuXHJcbiAgICBjYXNlIFwic2xpZGVzaG93XCI6XHJcbiAgICAgIHJldHVybiBbdG9QcmVzZW50YXRpb25zLCB0b1NsaWRlcyhtb2RlbCldXHJcbiAgICAgIGJyZWFrXHJcblxyXG4gICAgY2FzZSBcInNsaWRlc1wiOlxyXG4gICAgICByZXR1cm4gW3RvUHJlc2VudGF0aW9ucywgdG9TbGlkZVNob3cobW9kZWwpXVxyXG4gICAgICBicmVha1xyXG5cclxuICAgIGNhc2UgXCJlZGl0XCI6XHJcbiAgICAgIHJldHVybiBbdG9QcmVzZW50YXRpb25zLCB0b1NsaWRlcyhtb2RlbCksIHRvU2xpZGVTaG93KG1vZGVsKV1cclxuICAgICAgYnJlYWtcclxuICAgIGRlZmF1bHQ6XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBhY3Rpb25WaWV3ID0gbW9kZWwgPT4gcGFnZSA9PiB7XHJcbiAgc3dpdGNoIChwYWdlKSB7XHJcbiAgICBjYXNlIFwicHJlc2VudGF0aW9uc1wiOlxyXG4gICAgICByZXR1cm4gW3RvZ2dsZU1vZGFsKG1vZGVsKV1cclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgXCJwcmVzZW50YXRpb25cIjpcclxuICAgICAgcmV0dXJuIFt0b2dnbGVNb2RhbChtb2RlbCldXHJcbiAgICAgIGJyZWFrXHJcbiAgICBkZWZhdWx0OlxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgVG9vbGJhciA9ICh7IGF0dHJzOiB7IE1vZGVscyB9IH0pID0+IHtcclxuICBjb25zdCBjdXJyZW50UGFnZSA9IHZpZXcobGVuc1Byb3AoMSksIHNwbGl0KFwiL1wiLCBtLnJvdXRlLmdldCgpKSlcclxuICByZXR1cm4ge1xyXG4gICAgdmlldzogKHsgYXR0cnM6IHsgTW9kZWxzIH0gfSkgPT5cclxuICAgICAgbShcIi50b29sYmFyXCIsIFtcclxuICAgICAgICBtKFwiLnRvb2xiYXItbGVmdFwiLCBbbmF2VmlldyhNb2RlbHMpKGN1cnJlbnRQYWdlKV0pLFxyXG4gICAgICAgIG0oXCIudG9vbGJhci1yaWdodFwiLCBbYWN0aW9uVmlldyhNb2RlbHMpKGN1cnJlbnRQYWdlKV0pLFxyXG4gICAgICBdKSxcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRvb2xiYXJcclxuIiwiaW1wb3J0IG0gZnJvbSBcIm1pdGhyaWxcIlxyXG5pbXBvcnQgeyBsb2FkU2xpZGUsIGVkaXRTbGlkZSB9IGZyb20gXCIuL21vZGVsLmpzXCJcclxuaW1wb3J0IHJlbWFya2FibGUgZnJvbSBcInJlbWFya2FibGVcIlxyXG5cclxuY29uc3QgbWQgPSBuZXcgcmVtYXJrYWJsZShcImZ1bGxcIiwge1xyXG4gIGJhc2VVcmw6IG51bGwsXHJcbiAgYnJlYWtzOiBmYWxzZSxcclxuICBnZm06IHRydWUsXHJcbiAgaGVhZGVySWRzOiB0cnVlLFxyXG4gIGhlYWRlclByZWZpeDogXCJcIixcclxuICBoaWdobGlnaHQ6IG51bGwsXHJcbiAgbGFuZ1ByZWZpeDogXCJsYW4tXCIsXHJcbiAgbWFuZ2xlOiB0cnVlLFxyXG4gIHBlZGFudGljOiBmYWxzZSxcclxuICBzYW5pdGl6ZTogZmFsc2UsXHJcbiAgc2FuaXRpemVyOiBudWxsLFxyXG4gIHNpbGVudDogdHJ1ZSxcclxuICBzbWFydExpc3RzOiB0cnVlLFxyXG4gIHNtYXJ0eXBhbnRzOiB0cnVlLFxyXG4gIHRhYmxlczogdHJ1ZSxcclxuICB4aHRtbDogdHJ1ZSxcclxuICBodG1sOiB0cnVlLFxyXG4gIGxpbmtpZnk6IHRydWUsXHJcbiAgbGlua1RhcmdldDogXCJcIixcclxuICB0eXBvZ3JhcGhlcjogdHJ1ZSxcclxuICBxdW90ZXM6IFwi4oCc4oCd4oCY4oCZXCIsXHJcbn0pXHJcblxyXG5jb25zdCBFZGl0b3IgPSAoKSA9PiB7XHJcbiAgbGV0IHN0YXRlID0geyBwcmVzZW50YXRpb25JZDogXCJcIiwgc2xpZGU6IHsgdGl0bGU6IFwiXCIsIGNvbnRlbnQ6IFwiXCIsIGlkOiBcIlwiIH0gfVxyXG5cclxuICBjb25zdCB0b1NsaWRlcyA9IF8gPT5cclxuICAgIG0ucm91dGUuc2V0KGAvcHJlc2VudGF0aW9uLyR7c3RhdGUucHJlc2VudGF0aW9uSWR9L3NsaWRlc2ApXHJcblxyXG4gIGNvbnN0IG9uRXJyb3IgPSBlcnJvciA9PiBsb2coXCJlcnJvclwiKShlcnJvcilcclxuXHJcbiAgY29uc3Qgb25TdWNjZXNzID0gc2xpZGUgPT4ge1xyXG4gICAgc3RhdGUuc2xpZGUgPSBzbGlkZVxyXG4gIH1cclxuXHJcbiAgY29uc3QgZ2V0U2xpZGUgPSAoKSA9PiB7XHJcbiAgICBzdGF0ZS5zbGlkZS5pZCA9IG0ucm91dGUucGFyYW0oXCJpZFwiKVxyXG4gICAgc3RhdGUucHJlc2VudGF0aW9uSWQgPSBtLnJvdXRlLnBhcmFtKFwicGlkXCIpXHJcbiAgICByZXR1cm4gbG9hZFNsaWRlKHN0YXRlLnNsaWRlLmlkKS5mb3JrKG9uRXJyb3IsIG9uU3VjY2VzcylcclxuICB9XHJcblxyXG4gIGNvbnN0IHVwZGF0ZUlucHV0ID0gaW5wdXQgPT4gZSA9PiAoc3RhdGUuc2xpZGVbaW5wdXRdID0gZS50YXJnZXQudmFsdWUpXHJcblxyXG4gIGNvbnN0IHNhdmUgPSBlID0+IHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKVxyXG5cclxuICAgIGVkaXRTbGlkZShzdGF0ZS5zbGlkZSkuZm9yayhvbkVycm9yLCAoKSA9PiB0b1NsaWRlcygpKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG9uY3JlYXRlOiBnZXRTbGlkZSxcclxuICAgIHZpZXc6ICh7IGF0dHJzOiB7IE1vZGVscyB9IH0pID0+XHJcbiAgICAgIG0oXCIuY29udGFpbmVyXCIsIFtcclxuICAgICAgICBtKFwiLmVkaXRvci1sZWZ0LmNhcmRcIiwgW1xyXG4gICAgICAgICAgbShcIi5jYXJkLWhlYWRlclwiLCBbXHJcbiAgICAgICAgICAgIG0oXCJpbnB1dC5lZGl0b3ItaW5wdXRcIiwge1xyXG4gICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxyXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIlNsaWRlIFRpdGxlXCIsXHJcbiAgICAgICAgICAgICAgb25pbnB1dDogdXBkYXRlSW5wdXQoXCJ0aXRsZVwiKSxcclxuICAgICAgICAgICAgICB2YWx1ZTogc3RhdGUuc2xpZGUudGl0bGUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgXSksXHJcbiAgICAgICAgICBtKFwidGV4dGFyZWEuZWRpdG9yLXRleHRcIiwge1xyXG4gICAgICAgICAgICBvbmlucHV0OiB1cGRhdGVJbnB1dChcImNvbnRlbnRcIiksXHJcbiAgICAgICAgICAgIHZhbHVlOiBzdGF0ZS5zbGlkZS5jb250ZW50LFxyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgICBtKFwiLmNhcmQtZm9vdGVyXCIsIFtcclxuICAgICAgICAgICAgbShcclxuICAgICAgICAgICAgICBcImJ1dHRvbi5jYXJkLWJ0blwiLFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG9uY2xpY2s6IHNhdmUsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBcIlNhdmVcIlxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICAgICBtKFxyXG4gICAgICAgICAgICAgIFwiYnV0dG9uLmNhcmQtYnRuXCIsXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb25jbGljazogdG9TbGlkZXMsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBcIkNhbmNlbFwiXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICBdKSxcclxuICAgICAgICBdKSxcclxuICAgICAgICBtKFwiLmVkaXRvci1yaWdodFwiLCBtLnRydXN0KG1kLnJlbmRlcihzdGF0ZS5zbGlkZS5jb250ZW50IHx8IFwiXCIpKSksXHJcbiAgICAgIF0pLFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRWRpdG9yXHJcbiIsImltcG9ydCB7IGdldFFsVGFzayB9IGZyb20gJy4uL3NlcnZpY2VzL3JlcXVlc3RzLmpzJ1xyXG5pbXBvcnQgeyBwYXRoIH0gZnJvbSAncmFtZGEnXHJcblxyXG5leHBvcnQgY29uc3QgbG9hZFNsaWRlID0gaWQgPT4ge1xyXG4gIGxldCBxID0gYHsgc2xpZGUod2hlcmU6e2lkOiR7SlNPTi5zdHJpbmdpZnkoaWQpfX0pe1xyXG4gICAgICAgICAgICAgIGlkIGNvbnRlbnQgdGl0bGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfWBcclxuICByZXR1cm4gZ2V0UWxUYXNrKHEpLm1hcChwYXRoKFsnZGF0YScsICdzbGlkZSddKSlcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGVkaXRTbGlkZSA9ICh7IGlkLCB0aXRsZSwgY29udGVudCB9KSA9PiB7XHJcbiAgbGV0IHEgPSBgbXV0YXRpb24ge1xyXG4gICAgICAgICAgICB1cGRhdGVTbGlkZShcclxuICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogJHtKU09OLnN0cmluZ2lmeSh0aXRsZSl9XHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiAke0pTT04uc3RyaW5naWZ5KGNvbnRlbnQpfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgICAgICAgaWQ6ICR7SlNPTi5zdHJpbmdpZnkoaWQpfVxyXG4gICAgICAgICAgICAgIH0pIHtcclxuICAgICAgICAgICAgICAgIGlkXHJcbiAgICAgICAgICAgICAgICB0aXRsZVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICB9YFxyXG5cclxuICByZXR1cm4gZ2V0UWxUYXNrKHEpLm1hcChwYXRoKFsnZGF0YScsICd1cGRhdGVQcmVzZW50YXRpb24nLCAnU2xpZGVzJ10pKVxyXG59XHJcbiIsIi8vIGluZGV4LmpzeFxyXG5cclxuaW1wb3J0IG0gZnJvbSBcIm1pdGhyaWxcIlxyXG5jb25zdCByb290ID0gZG9jdW1lbnQuYm9keVxyXG5cclxuaW1wb3J0IFwiLi9zdHlsZXMvaW5kZXguY3NzXCJcclxuaW1wb3J0IE1vZGVscyBmcm9tIFwiLi9Nb2RlbHMuanNcIlxyXG5pbXBvcnQgQXBwIGZyb20gXCIuL0FwcC5qc1wiXHJcblxyXG5tLnJlbmRlcihyb290LCBtKEFwcCwgeyBNb2RlbHMgfSkpXHJcbiIsImltcG9ydCBtIGZyb20gJ21pdGhyaWwnXHJcbmltcG9ydCBUb29sYmFyIGZyb20gJy4uL1Rvb2xiYXIvY29tcG9uZW50LmpzJ1xyXG5cclxuY29uc3QgTGF5b3V0ID0ge1xyXG4gIHZpZXc6ICh7IGNoaWxkcmVuLCBhdHRyczogTW9kZWxzIH0pID0+IFttKFRvb2xiYXIsIE1vZGVscyksIGNoaWxkcmVuXSxcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0XHJcbiIsImltcG9ydCBtIGZyb20gXCJtaXRocmlsXCJcclxuaW1wb3J0IHsgbG9nIH0gZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2luZGV4LmpzXCJcclxuaW1wb3J0IHsgd2l0aG91dCB9IGZyb20gXCJyYW1kYVwiXHJcbmltcG9ydCB7IGRlbGV0ZVByZXNlbnRhdGlvbnNUYXNrIH0gZnJvbSBcIi4uL21vZGVsLmpzXCJcclxuaW1wb3J0IFRhc2sgZnJvbSBcImRhdGEudGFza1wiXHJcblxyXG5jb25zdCBQcmVzZW50YXRpb24gPSAoeyBhdHRyczogeyB0aXRsZSwgaWQsIE1vZGVscyB9IH0pID0+IHtcclxuICBjb25zdCBvbkVycm9yID0gdGFzayA9PiBlcnJvciA9PiBsb2coYGVycm9yIHdpdGggJHt0YXNrfWApKGVycm9yKVxyXG4gIGNvbnN0IG9uU3VjY2VzcyA9IG1vZGVscyA9PiBkZWxldGVkID0+IHtcclxuICAgIHJldHVybiAoTW9kZWxzLlByZXNlbnRhdGlvbnMgPSB3aXRob3V0KFtkZWxldGVkXSwgTW9kZWxzLlByZXNlbnRhdGlvbnMpKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgYXV0aERlbGV0ZVRhc2sgPSBpZCA9PlxyXG4gICAgd2luZG93LmNvbmZpcm0oXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlP1wiKVxyXG4gICAgICA/IFRhc2sub2YoaWQpXHJcbiAgICAgIDogVGFzay5yZWplY3RlZChpZClcclxuXHJcbiAgY29uc3QgcmVtb3ZlUHJlc1Rhc2sgPSBwSWQgPT5cclxuICAgIGF1dGhEZWxldGVUYXNrKHBJZClcclxuICAgICAgLmNoYWluKGRlbGV0ZVByZXNlbnRhdGlvbnNUYXNrKVxyXG4gICAgICAuZm9yayhvbkVycm9yKFwiZGVsZXRpbmdcIiksIG9uU3VjY2VzcyhNb2RlbHMpKVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgdmlldzogKHsgYXR0cnM6IHsgdGl0bGUsIGlkLCBNb2RlbHMgfSB9KSA9PlxyXG4gICAgICBtKFwiLmNhcmRcIiwgW1xyXG4gICAgICAgIG0oXCJkaXYuY2FyZC1oZWFkZXJcIiwgW1xyXG4gICAgICAgICAgbShcclxuICAgICAgICAgICAgXCIuY2FyZC1idG4uZnVsbC13aWR0aFwiLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgb25jbGljazogKCkgPT4gbS5yb3V0ZS5zZXQoYC9wcmVzZW50YXRpb24vJHtpZH0vc2xpZGVzYCksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRpdGxlXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgbShcImJ1dHRvbi5jYXJkLWRlbGV0ZVwiLCB7XHJcbiAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IHJlbW92ZVByZXNUYXNrKGlkKSxcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgIF0pLFxyXG4gICAgICAgIG0oXCJkaXYuY2FyZC1ib2R5XCIsIFtdKSxcclxuICAgICAgICBtKFwiZGl2LmNhcmQtZm9vdGVyXCIsIFtdKSxcclxuICAgICAgXSksXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQcmVzZW50YXRpb25cclxuIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCdcclxuaW1wb3J0IHsgY2xvbmUgfSBmcm9tICdyYW1kYSdcclxuaW1wb3J0IHtcclxuICBhbmltYXRlRmFkZUluLFxyXG59IGZyb20gJy4uL3NlcnZpY2VzL2FuaW1hdGlvbnMuanMnXHJcbmltcG9ydCBQcmVzZW50YXRpb25Nb2RhbCBmcm9tICcuL3ByZXNlbnRhdGlvbk1vZGFsLmpzJ1xyXG5pbXBvcnQgUHJlc2VudGF0aW9uIGZyb20gJy4vUHJlc2VudGF0aW9uL2NvbXBvbmVudC5qcydcclxuXHJcblxyXG5jb25zdCBQcmVzZW50YXRpb25zID0gKHsgYXR0cnM6IHsgTW9kZWxzIH0gfSkgPT4ge1xyXG4gIGNvbnN0IHN0YXRlID0ge1xyXG4gICAgZXJyb3JzOiBbXSxcclxuICAgIHRpdGxlOiAnJyxcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB2aWV3OiAoeyBhdHRyczogeyBNb2RlbHMgfSB9KSA9PiBbXHJcbiAgICAgIE1vZGVscy50b2dnbGVNb2RhbFxyXG4gICAgICAgID8gbShQcmVzZW50YXRpb25Nb2RhbCwge1xyXG4gICAgICAgICAgICBNb2RlbHMsXHJcbiAgICAgICAgICAgIHN0YXRlLFxyXG4gICAgICAgICAgICB0b2dnbGVNb2RhbDogKCkgPT4gKE1vZGVscy50b2dnbGVNb2RhbCA9ICFNb2RlbHMudG9nZ2xlTW9kYWwpLFxyXG4gICAgICAgICAgICBwcmVzZW50YXRpb25zOiBNb2RlbHMuUHJlc2VudGF0aW9ucyxcclxuICAgICAgICAgICAgcHJlc2VudGF0aW9uTW9kZWw6IGNsb25lKE1vZGVscy5QcmVzZW50YXRpb25Nb2RlbCksXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIDogJycsXHJcblxyXG4gICAgICBtKFxyXG4gICAgICAgICcuY29udGFpbmVyLnByZXNlbnRhdGlvbnMnLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIG9uY3JlYXRlOiAoeyBkb20gfSkgPT4gYW5pbWF0ZUZhZGVJbih7IGRvbSB9KSxcclxuICAgICAgICAgIG9uQmVmb3JlUmVtb3ZlOiAodm5vZGUsIGRvbmUpID0+IHtcclxuICAgICAgICAgICAgdm5vZGUuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIGRvbmUpXHJcbiAgICAgICAgICAgIHZub2RlLmRvbS5zdHlsZS5hbmltYXRpb24gPSAnZmFkZU91dCAxcydcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBbXHJcbiAgICAgICAgICBNb2RlbHMuUHJlc2VudGF0aW9ucyAmJlxyXG4gICAgICAgICAgICBNb2RlbHMuUHJlc2VudGF0aW9ucy5tYXAoKHsgdGl0bGUsIGlkIH0pID0+XHJcbiAgICAgICAgICAgICAgbShQcmVzZW50YXRpb24sIHtcclxuICAgICAgICAgICAgICAgIGtleTogaWQsXHJcbiAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgIHRpdGxlLFxyXG4gICAgICAgICAgICAgICAgTW9kZWxzLFxyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgXVxyXG4gICAgICApLFxyXG4gICAgXSxcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFByZXNlbnRhdGlvbnNcclxuIiwiaW1wb3J0IHsgZ2V0UWxUYXNrIH0gZnJvbSAnLi4vc2VydmljZXMvcmVxdWVzdHMuanMnXHJcbmltcG9ydCB7IHBhdGggfSBmcm9tICdyYW1kYSdcclxuXHJcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4uL3NlcnZpY2VzL2luZGV4LmpzJ1xyXG5jb25zdCB0b1ZpZXdNb2RlbCA9ICh7IGRhdGEsIGVycm9ycyB9KSA9PiB7XHJcbiAgY29uc29sZS5sb2coJ2Vycm9ycycsIGVycm9ycylcclxuICBjb25zb2xlLmxvZygnZGF0YScsIGRhdGEpXHJcbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3JzIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldFByZXNlbnRhdGlvbnMgPSAoKSA9PlxyXG4gIGdldFFsVGFzayhgcXVlcnkge1xyXG4gIHByZXNlbnRhdGlvbnN7IGlkLCB0aXRsZX1cclxufWApLm1hcChwYXRoKFsnZGF0YScsICdwcmVzZW50YXRpb25zJ10pKVxyXG5cclxuZXhwb3J0IGNvbnN0IHNhdmVQcmVzZW50YXRpb25UYXNrID0gc3RhdGUgPT4ge1xyXG4gIGNvbnN0IHEgPSBgbXV0YXRpb24ge1xyXG4gICAgY3JlYXRlUHJlc2VudGF0aW9uKGRhdGE6IHt0aXRsZTogJHtKU09OLnN0cmluZ2lmeShzdGF0ZS50aXRsZSl9fSlcclxuICAgIHsgdGl0bGUgaWR9XHJcbiAgfWBcclxuICByZXR1cm4gZ2V0UWxUYXNrKHEpLm1hcChwYXRoKFsnZGF0YScsICdjcmVhdGVQcmVzZW50YXRpb24nXSkpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBkZWxldGVQcmVzZW50YXRpb25zVGFzayA9IGlkID0+IHtcclxuICBjb25zdCBxID0gYG11dGF0aW9uIHtcclxuICAgIGRlbGV0ZVByZXNlbnRhdGlvbih3aGVyZToge2lkOiAke0pTT04uc3RyaW5naWZ5KGlkKX19KVxyXG4gICAgeyB0aXRsZSBpZH1cclxuICB9YFxyXG4gIHJldHVybiBnZXRRbFRhc2socSkubWFwKHBhdGgoWydkYXRhJywgJ2RlbGV0ZVByZXNlbnRhdGlvbiddKSlcclxufVxyXG4iLCJpbXBvcnQgbSBmcm9tIFwibWl0aHJpbFwiXHJcbmltcG9ydCB7IHNhdmVQcmVzZW50YXRpb25UYXNrIH0gZnJvbSBcIi4vbW9kZWwuanNcIlxyXG5pbXBvcnQgeyBsb2cgfSBmcm9tIFwiLi4vc2VydmljZXMvaW5kZXguanNcIlxyXG5cclxuY29uc3QgUHJlc2VudGF0aW9uTW9kYWwgPSAoeyBhdHRycyB9KSA9PiB7XHJcbiAgY29uc3Qgb25FcnJvciA9IGVycm9ycyA9PiB7XHJcbiAgICBsb2coXCJlcnJvclwiKShlcnJvcnMpXHJcbiAgICBhdHRycy5zdGF0ZS5lcnJvcnMgPSBlcnJvcnNcclxuICAgIGF0dHJzLnRvZ2dsZU1vZGFsKClcclxuICB9XHJcbiAgY29uc3Qgb25TdWNjZXNzID0gcCA9PiB7XHJcbiAgICBhdHRycy5zdGF0ZS50aXRsZSA9IFwiXCJcclxuICAgIGF0dHJzLnN0YXRlLmVycm9ycyA9IFtdXHJcbiAgICBhdHRycy5wcmVzZW50YXRpb25zLnB1c2gocClcclxuICAgIGF0dHJzLnRvZ2dsZU1vZGFsKClcclxuICB9XHJcblxyXG4gIGNvbnN0IHNhdmUgPSBlID0+IHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgc2F2ZVByZXNlbnRhdGlvblRhc2soYXR0cnMuc3RhdGUpLmZvcmsob25FcnJvciwgb25TdWNjZXNzKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHZpZXc6ICgpID0+XHJcbiAgICAgIG0oXCJhcnRpY2xlLm1vZGFsLWNvbnRhaW5lclwiLCBbXHJcbiAgICAgICAgbShcIi5jYXJkXCIsIFtcclxuICAgICAgICAgIG0oXHJcbiAgICAgICAgICAgIFwiLmNhcmQtaGVhZGVyXCIsXHJcbiAgICAgICAgICAgIG0oXCJidXR0b24uY2FyZC1kZWxldGVcIiwge1xyXG4gICAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRycy50b2dnbGVNb2RhbCgpXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogXCJjbG9zZVwiLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIG0oXCIuY2FyZC1ib2R5XCIsIFtcclxuICAgICAgICAgICAgbShcImZpZWxkc2V0XCIsIFtcclxuICAgICAgICAgICAgICBtKFwibGFiZWwubW9kYWwtbGFiZWxcIiwgXCJQcmVzZW50YXRpb24gTmFtZVwiKSxcclxuICAgICAgICAgICAgICBtKFwiaW5wdXQubW9kYWwtaW5wdXRcIiwge1xyXG4gICAgICAgICAgICAgICAgYXV0b2ZvY3VzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXHJcbiAgICAgICAgICAgICAgICBvbmNoYW5nZTogZSA9PiAoYXR0cnMuc3RhdGUudGl0bGUgPSBlLnRhcmdldC52YWx1ZSksXHJcbiAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIF0pLFxyXG4gICAgICAgICAgXSksXHJcbiAgICAgICAgICBtKFxyXG4gICAgICAgICAgICBcIi5jYXJkLWZvb3RlclwiLFxyXG4gICAgICAgICAgICBtKFwiYnV0dG9uLmNhcmQtYnRuXCIsIHsgb25jbGljazogc2F2ZSB9LCBcInNhdmUgcHJlc2VudGF0aW9uXCIpXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgIF0pLFxyXG4gICAgICBdKSxcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFByZXNlbnRhdGlvbk1vZGFsXHJcbiIsImltcG9ydCBtIGZyb20gXCJtaXRocmlsXCJcclxuaW1wb3J0IFRhc2sgZnJvbSBcImRhdGEudGFza1wiXHJcbmltcG9ydCB7IG1ha2VRdWVyeSB9IGZyb20gXCIuL2luZGV4LmpzXCJcclxuaW1wb3J0IHsgb25saW5lVXJsIH0gZnJvbSBcIi4uLy4uL3NlY3JldC5qc1wiXHJcblxyXG5leHBvcnQgY29uc3QgcG9zdFFsID0gcXVlcnkgPT5cclxuICBuZXcgVGFzaygocmVqLCByZXMpID0+XHJcbiAgICBtXHJcbiAgICAgIC5yZXF1ZXN0KHtcclxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICAgIHVybDogYCR7b25saW5lVXJsfWAsXHJcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcclxuICAgICAgICBib2R5OiBtYWtlUXVlcnkocXVlcnkpLFxyXG4gICAgICB9KVxyXG4gICAgICAudGhlbihyZXMsIHJlailcclxuICApXHJcblxyXG5jb25zdCBwb3N0VGFzayA9IHVybCA9PiAoeyBkdG8gfSkgPT5cclxuICBuZXcgVGFzaygocmVqLCByZXMpID0+XHJcbiAgICBtXHJcbiAgICAgIC5yZXF1ZXN0KHtcclxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICAgIHVybDogYCR7b25saW5lVXJsfS8ke3VybH1gLFxyXG4gICAgICAgIGJvZHk6IGR0byxcclxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxyXG4gICAgICB9KVxyXG4gICAgICAudGhlbihyZXMsIHJlailcclxuICApXHJcblxyXG5jb25zdCBwdXRUYXNrID0gdXJsID0+ICh7IGR0byB9KSA9PlxyXG4gIG5ldyBUYXNrKChyZWosIHJlcykgPT5cclxuICAgIG1cclxuICAgICAgLnJlcXVlc3Qoe1xyXG4gICAgICAgIG1ldGhvZDogXCJQVVRcIixcclxuICAgICAgICB1cmw6IGAke29ubGluZVVybH0vJHt1cmx9YCxcclxuICAgICAgICBib2R5OiBkdG8sXHJcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcclxuICAgICAgfSlcclxuICAgICAgLnRoZW4ocmVzLCByZWopXHJcbiAgKVxyXG5cclxuY29uc3QgZ2V0VGFzayA9IHVybCA9PlxyXG4gIG5ldyBUYXNrKChyZWosIHJlcykgPT5cclxuICAgIG1cclxuICAgICAgLnJlcXVlc3Qoe1xyXG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcclxuICAgICAgICB1cmw6IGAke29ubGluZVVybH0vJHt1cmx9YCxcclxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxyXG4gICAgICB9KVxyXG4gICAgICAudGhlbihyZXMsIHJlailcclxuICApXHJcblxyXG5jb25zdCBkZWxldGVUYXNrID0gdXJsID0+IGlkID0+XHJcbiAgbmV3IFRhc2soKHJlaiwgcmVzKSA9PlxyXG4gICAgbVxyXG4gICAgICAucmVxdWVzdCh7XHJcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxyXG4gICAgICAgIHVybDogYCR7b25saW5lVXJsfS8ke3VybH0vJHtpZH1gLFxyXG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXHJcbiAgICAgIH0pXHJcbiAgICAgIC50aGVuKHJlcywgcmVqKVxyXG4gIClcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHsgcG9zdFRhc2ssIHB1dFRhc2ssIGdldFRhc2ssIGRlbGV0ZVRhc2ssIHBvc3RRbCB9XHJcbiIsImltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXHJcblxyXG5leHBvcnQgY29uc3QgYW5pbWF0ZVNsaWRlRW50cmFuY2UgPSAoeyBkb20gfSkgPT4ge1xyXG4gIHJldHVybiBkb20uYW5pbWF0ZShcclxuICAgIFtcclxuICAgICAgeyB0cmFuc2Zvcm06IFwidHJhbnNsYXRlM2QoMjAlLDAsMClcIiwgb3BhY2l0eTogMCB9LFxyXG4gICAgICB7IHRyYW5zZm9ybTogXCJub25lXCIsIG9wYWNpdHk6IDEgfVxyXG4gICAgXSxcclxuICAgIHtcclxuICAgICAgZHVyYXRpb246IDY1MFxyXG4gICAgfVxyXG4gIClcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGFuaW1hdGVFbnRyYW5jZVJpZ2h0ID0gKHsgZG9tIH0pID0+IHtcclxuICByZXR1cm4gZG9tLmFuaW1hdGUoXHJcbiAgICBbXHJcbiAgICAgIHtcclxuICAgICAgICBhbmltYXRpb246IFwiXCIsXHJcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZTNkKDEwMCUsMCwwKVwiLFxyXG4gICAgICAgIHNjYWxlOiAyLFxyXG4gICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGFuaW1hdGlvbjogXCJzdHJldGNoUmlnaHQgMXMgZWFzZS1pbi1vdXQgYm90aFwiLFxyXG4gICAgICAgIHRyYW5zZm9ybTogXCJub25lXCIsXHJcbiAgICAgICAgb3BhY2l0eTogMSxcclxuICAgICAgICBzY2FsZTogMVxyXG4gICAgICB9XHJcbiAgICBdLFxyXG4gICAge1xyXG4gICAgICBkdXJhdGlvbjogMzUwXHJcbiAgICB9XHJcbiAgKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYW5pbWF0ZUNoaWxkRW50cmFuY2UgPSAoeyBkb20gfSkgPT4ge1xyXG4gIGNvbnNvbGUubG9nKFwid3RmXCIsIGRvbSlcclxuICBsZXQgY2hpbGRyZW4gPSBbLi4uZG9tLmNoaWxkcmVuXVxyXG5cclxuICByZXR1cm4gY2hpbGRyZW4ubWFwKChjaGlsZCwgaW5kZXgpID0+IHtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBjaGlsZC5hbmltYXRlKFxyXG4gICAgICAgIFtcclxuICAgICAgICAgIHsgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZTNkKDAsLTEwMCUsMClcIiwgb3BhY2l0eTogMCB9LFxyXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IFwibm9uZVwiLCBvcGFjaXR5OiAxIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGR1cmF0aW9uOiA4NTBcclxuICAgICAgICB9XHJcbiAgICAgIClcclxuICAgIH0sIChpbmRleCArIDEpICogMjAwKVxyXG4gIH0pXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBhbmltYXRlRXhpdCA9IChkb20pID0+IHtcclxuICBsZXQgY2hpbGRyZW4gPSBbLi4uZG9tLmNoaWxkcmVuXVxyXG5cclxuICBsZXQgYW5pbSA9IGFuaW1hdGUoW1xyXG4gICAgeyB0cmFuc2Zvcm06IFwibm9uZVwiLCBvcGFjaXR5OiAxIH0sXHJcbiAgICB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUzZCgyNSUsMTAwJSwwKVwiLCBvcGFjaXR5OiAwIH1cclxuICBdKVxyXG5cclxuICBsZXQgd2FhcGkgPSBjaGlsZHJlbi5tYXAoKGNoaWxkKSA9PlxyXG4gICAgY2hpbGQuYW5pbWF0ZShhbmltLCB7XHJcbiAgICAgIGR1cmF0aW9uOiA4NTBcclxuICAgIH0pXHJcbiAgKVxyXG5cclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgIHdhYXBpLm9uZmluaXNoID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICByZXNvbHZlKClcclxuICAgIH1cclxuICB9KVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYW5pbWF0ZUZhZGVJbiA9ICh7IGRvbSB9KSA9PiB7XHJcbiAgbGV0IGNoaWxkcmVuID0gWy4uLmRvbS5jaGlsZHJlbl1cclxuICBjaGlsZHJlbi5tYXAoKGNoaWxkLCBpbmRleCkgPT4ge1xyXG4gICAgY2hpbGQuc3R5bGUub3BhY2l0eSA9IDBcclxuICAgIGNoaWxkLnN0eWxlLnRyYW5zaXRpb24gPSBcIm9wYWNpdHkgLjRzIGVhc2UtaW4tb3V0XCJcclxuXHJcbiAgICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIGNoaWxkLnN0eWxlLm9wYWNpdHkgPSAxXHJcbiAgICB9LCAoaW5kZXggKyAxKSAqIDIwMClcclxuICB9KVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYW5pbWF0ZUZhZGVPdXQgPSAoeyBkb20gfSkgPT4ge1xyXG4gIGxldCBhbmltID0gW1xyXG4gICAgeyB0cmFuc2l0aW9uOiBcIm9wYWNpdHkgLjRzIGVhc2UtaW4tb3V0XCIgfSxcclxuICAgIHsgdHJhbnNmb3JtOiBcIm5vbmVcIiwgb3BhY2l0eTogMSB9LFxyXG4gICAgeyB0cmFuc2Zvcm06IFwidHJhbnNsYXRlM2QoMjUlLDEwMCUsMClcIiwgb3BhY2l0eTogMCB9XHJcbiAgXVxyXG4gIGxldCB3YWFwaSA9IGRvbS5hbmltYXRlKGFuaW0sIHtcclxuICAgIGR1cmF0aW9uOiA4NTBcclxuICB9KVxyXG5cclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgIHdhYXBpLm9uZmluaXNoID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICByZXNvbHZlKClcclxuICAgIH1cclxuICB9KVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYW5pbWVFbnRyYW5jZSA9ICh7IGRvbSB9KSA9PiB7XHJcbiAgbGV0IGNoaWxkcmVuID0gWy4uLmRvbS5jaGlsZHJlbl1cclxuICBjb25zb2xlLmxvZyhjaGlsZHJlbilcclxuICBjb25zdCByZXMgPSBjaGlsZHJlbi5tYXAoKGVsKSA9PlxyXG4gICAgYW5pbWUoe1xyXG4gICAgICB0YXJnZXQ6IGVsLFxyXG4gICAgICBlYXNpbmc6IFwiZWFzZUluUXVhZFwiLFxyXG4gICAgICB0cmFuc2xhdGVYOiAyNTAsXHJcbiAgICAgIG9mZnNldDogMFxyXG4gICAgfSlcclxuICApXHJcblxyXG4gIGNvbnNvbGUubG9nKFwiYW5pbVwiLCByZXMpXHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYm91bmNlRW50cmFuY2UgPSAoeyBkb20gfSkgPT4ge1xyXG4gIHJldHVybiBkb20uYW5pbWF0ZSh7XHJcbiAgICBhbmltYXRpb246IFwiYW5pbWF0aW9uIDEwMDBtcyBsaW5lYXIgYm90aFwiLFxyXG4gICAga2V5ZnJhbWVzOiB7XHJcbiAgICAgIFwiMCVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTogXCJtYXRyaXgzZCgxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiMy40JVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgxLjMxNiwgMCwgMCwgMCwgMCwgMS40MDcsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCI0LjclXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDEuNDUsIDAsIDAsIDAsIDAsIDEuNTk5LCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiNi44MSVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMS42NTksIDAsIDAsIDAsIDAsIDEuODkzLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiOS40MSVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMS44ODMsIDAsIDAsIDAsIDAsIDIuMTY4LCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiMTAuMjElXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDEuOTQyLCAwLCAwLCAwLCAwLCAyLjIyNiwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIjEzLjYxJVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgyLjEyMywgMCwgMCwgMCwgMCwgMi4zMzIsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCIxNC4xMSVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMi4xNDEsIDAsIDAsIDAsIDAsIDIuMzMxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiMTcuNTIlXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDIuMjA4LCAwLCAwLCAwLCAwLCAyLjIzOSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIjE4LjcyJVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgyLjIxMiwgMCwgMCwgMCwgMCwgMi4xODcsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCIyMS4zMiVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMi4xOTYsIDAsIDAsIDAsIDAsIDIuMDY5LCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiMjQuMzIlXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDIuMTUxLCAwLCAwLCAwLCAwLCAxLjk2LCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiMjUuMjMlXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDIuMTM0LCAwLCAwLCAwLCAwLCAxLjkzOCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIjI5LjAzJVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgyLjA2MywgMCwgMCwgMCwgMCwgMS44OTcsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCIyOS45MyVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMi4wNDgsIDAsIDAsIDAsIDAsIDEuODk5LCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiMzUuNTQlXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDEuOTc5LCAwLCAwLCAwLCAwLCAxLjk2MiwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIjM2Ljc0JVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgxLjk3MiwgMCwgMCwgMCwgMCwgMS45NzksIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCI0MS4wNCVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMS45NjEsIDAsIDAsIDAsIDAsIDIuMDIyLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiNDQuNDQlXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDEuOTY2LCAwLCAwLCAwLCAwLCAyLjAzMiwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIjUyLjE1JVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgxLjk5MSwgMCwgMCwgMCwgMCwgMi4wMDYsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCI1OS44NiVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMi4wMDYsIDAsIDAsIDAsIDAsIDEuOTksIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCI2My4yNiVcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTpcclxuICAgICAgICAgIFwibWF0cml4M2QoMi4wMDcsIDAsIDAsIDAsIDAsIDEuOTkyLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIFwiNzUuMjglXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06XHJcbiAgICAgICAgICBcIm1hdHJpeDNkKDIuMDAxLCAwLCAwLCAwLCAwLCAyLjAwMywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIjg1LjQ5JVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgxLjk5OSwgMCwgMCwgMCwgMCwgMiwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9LFxyXG4gICAgICBcIjkwLjY5JVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOlxyXG4gICAgICAgICAgXCJtYXRyaXgzZCgxLjk5OSwgMCwgMCwgMCwgMCwgMS45OTksIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpXCJcclxuICAgICAgfSxcclxuICAgICAgXCIxMDAlXCI6IHtcclxuICAgICAgICB0cmFuc2Zvcm06IFwibWF0cml4M2QoMiwgMCwgMCwgMCwgMCwgMiwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSlcIlxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSlcclxufVxyXG4iLCJpbXBvcnQgU3RyZWFtIGZyb20gJ21pdGhyaWwtc3RyZWFtJ1xyXG5cclxuY29uc3QgbWFrZVF1ZXJ5ID0gc3RyaW5nID0+IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3RyaW5nKSlcclxuXHJcbmNvbnN0IHJlcGVhdCA9IG4gPT4gZiA9PiB4ID0+IHtcclxuICBsZXQgbSA9IG5cclxuICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgaWYgKG0gPT09IDApIHJldHVybiB4XHJcbiAgICBlbHNlIChtID0gbSAtIDEpLCAoeCA9IGYoeCkpXHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCB3YWl0ID0gbiA9PiBmID0+IHggPT4ge1xyXG4gIGxldCBtID0gblxyXG4gIHdoaWxlICh0cnVlKSB7XHJcbiAgICBpZiAobSA9PT0gMCkgcmV0dXJuIHhcclxuICAgIGVsc2UgKG0gPSBtIC0gMSksICh4ID0gZih4KSlcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGxvZyA9IG0gPT4gdiA9PiB7XHJcbiAgY29uc29sZS5sb2cobSwgdilcclxuICByZXR1cm4gdlxyXG59XHJcblxyXG5jb25zdCB2aWV3TW9kZWxNYXAgPSBzaWduYXR1cmUgPT4ge1xyXG4gIHZhciBfbWFwID0ge31cclxuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICBpZiAoIV9tYXBba2V5XSkge1xyXG4gICAgICBfbWFwW2tleV0gPSB7fVxyXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHNpZ25hdHVyZSkgX21hcFtrZXldW3Byb3BdID0gU3RyZWFtKHNpZ25hdHVyZVtwcm9wXSgpKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9tYXBba2V5XVxyXG4gIH1cclxufVxyXG5leHBvcnQgeyB2aWV3TW9kZWxNYXAsIGxvZywgcmVwZWF0LCB3YWl0LCBtYWtlUXVlcnkgfVxyXG4iLCJpbXBvcnQgaHR0cFRhc2tzIGZyb20gJy4vVGFza3MuanMnXHJcbmltcG9ydCBUYXNrIGZyb20gJ2RhdGEudGFzaydcclxuaW1wb3J0IHsgc2VxdWVuY2UgfSBmcm9tICdyYW1kYSdcclxuXHJcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4vaW5kZXguanMnXHJcblxyXG5leHBvcnQgY29uc3QgZmluZFByZXNlbnRhdGlvbnNUYXNrID0gKCkgPT4gaHR0cFRhc2tzLmdldFRhc2soJ3ByZXNlbnRhdGlvbnMnKVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldFFsVGFzayA9IHF1ZXJ5ID0+IGh0dHBUYXNrcy5wb3N0UWwoeyBxdWVyeSB9KVxyXG5cclxuZXhwb3J0IGNvbnN0IHNhdmVQcmVzZW50YXRpb25UYXNrID0gZHRvID0+XHJcbiAgaHR0cFRhc2tzLnBvc3RUYXNrKGBwcmVzZW50YXRpb25zYCkoe1xyXG4gICAgZHRvLFxyXG4gIH0pXHJcblxyXG5leHBvcnQgY29uc3QgZGVsZXRlUHJlc2VudGF0aW9uc1Rhc2sgPSBpZCA9PlxyXG4gIGh0dHBUYXNrcy5kZWxldGVUYXNrKCdwcmVzZW50YXRpb25zJykoaWQpXHJcblxyXG5leHBvcnQgY29uc3QgZmluZFNsaWRlc1Rhc2sgPSBpZCA9PlxyXG4gIGh0dHBUYXNrcy5nZXRUYXNrKGBwcmVzZW50YXRpb25zLyR7aWR9L3NsaWRlc2ApXHJcblxyXG5leHBvcnQgY29uc3Qgc2F2ZVNsaWRlVGFzayA9IGR0byA9PiBodHRwVGFza3MucG9zdFRhc2soYHNsaWRlc2ApKHsgZHRvIH0pXHJcblxyXG5leHBvcnQgY29uc3QgdXBkYXRlU2xpZGVUYXNrID0gaWQgPT4gZHRvID0+XHJcbiAgaHR0cFRhc2tzLnB1dFRhc2soYHNsaWRlcy8ke2lkfWApKHsgZHRvIH0pXHJcblxyXG5leHBvcnQgY29uc3QgZGVsZXRlU2xpZGVUYXNrID0gaWQgPT4gaHR0cFRhc2tzLmRlbGV0ZVRhc2soJ3NsaWRlcycpKGlkKVxyXG5cclxuZXhwb3J0IGNvbnN0IGxvYWRTbGlkZVRhc2sgPSBpZCA9PiBodHRwVGFza3MuZ2V0VGFzayhgc2xpZGVzLyR7aWR9YClcclxuIiwiaW1wb3J0IG0gZnJvbSBcIm1pdGhyaWxcIlxyXG5pbXBvcnQgeyBjb25jYXQsIGVxUHJvcHMsIGNvbXBvc2UsIGZpbHRlciwgbWFwLCBwcm9wRXEsIGhlYWQgfSBmcm9tIFwicmFtZGFcIlxyXG5pbXBvcnQgeyBsb2cgfSBmcm9tIFwiLi4vLi4vc2VydmljZXMvaW5kZXguanNcIlxyXG5pbXBvcnQgeyBhbmltYXRlRXhpdCwgYW5pbWF0ZUZhZGVJbiB9IGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9hbmltYXRpb25zLmpzXCJcclxuaW1wb3J0IHtcclxuICBmb3JHcmVhdGVyLFxyXG4gIHJlZHVjZU9yZGVyLFxyXG4gIHVwZGF0ZVJlbW92ZVNsaWRlLFxyXG4gIHVwZGF0ZVNsaWRlVGFzayxcclxufSBmcm9tIFwiLi4vbW9kZWwuanNcIlxyXG5pbXBvcnQgcmVtYXJrYWJsZSBmcm9tIFwicmVtYXJrYWJsZVwiXHJcblxyXG5jb25zdCBtZCA9IG5ldyByZW1hcmthYmxlKFwiZnVsbFwiLCB7XHJcbiAgYmFzZVVybDogbnVsbCxcclxuICBicmVha3M6IGZhbHNlLFxyXG4gIGdmbTogdHJ1ZSxcclxuICBoZWFkZXJJZHM6IHRydWUsXHJcbiAgaGVhZGVyUHJlZml4OiBcIlwiLFxyXG4gIGhpZ2hsaWdodDogbnVsbCxcclxuICBsYW5nUHJlZml4OiBcImxhbi1cIixcclxuICBtYW5nbGU6IHRydWUsXHJcbiAgcGVkYW50aWM6IGZhbHNlLFxyXG4gIHNhbml0aXplOiBmYWxzZSxcclxuICBzYW5pdGl6ZXI6IG51bGwsXHJcbiAgc2lsZW50OiB0cnVlLFxyXG4gIHNtYXJ0TGlzdHM6IHRydWUsXHJcbiAgc21hcnR5cGFudHM6IHRydWUsXHJcbiAgdGFibGVzOiB0cnVlLFxyXG4gIHhodG1sOiB0cnVlLFxyXG4gIGh0bWw6IHRydWUsXHJcbiAgbGlua2lmeTogdHJ1ZSxcclxuICBsaW5rVGFyZ2V0OiBcIlwiLFxyXG4gIHR5cG9ncmFwaGVyOiB0cnVlLFxyXG4gIHF1b3RlczogXCLigJzigJ3igJjigJlcIixcclxufSlcclxuXHJcbmNvbnN0IFByZXZpZXcgPSAoeyBhdHRyczogeyBnZXRTbGlkZXMsIE1vZGVscywgcywga2V5LCBzdGF0ZSB9IH0pID0+IHtcclxuICBjb25zdCBvbkVycm9yID0gdGFzayA9PiBlcnJvciA9PiBsb2coYGVycm9yIHdpdGggJHt0YXNrfWApKGVycm9yKVxyXG4gIGNvbnN0IG9uU3VjY2VzcyA9IF8gPT4gZ2V0U2xpZGVzKHsgYXR0cnM6IHsgTW9kZWxzIH0gfSlcclxuXHJcbiAgY29uc3QgdXBkYXRlQW5kU2F2ZVNsaWRlVGFzayA9IHNsaWRlcyA9PiB7XHJcbiAgICByZXR1cm4gdXBkYXRlU2xpZGVUYXNrKE1vZGVscy5DdXJyZW50UHJlc2VudGF0aW9uLmlkKShzbGlkZXMpLmZvcmsoXHJcbiAgICAgIG9uRXJyb3IoXCJ1cGRhdGluZ1wiKSxcclxuICAgICAgb25TdWNjZXNzXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICBjb25zdCByZW1vdmVTbGlkZVRhc2sgPSBzID0+IHtcclxuICAgIGxldCB0YWlsID0gY29tcG9zZShcclxuICAgICAgbWFwKHJlZHVjZU9yZGVyKSxcclxuICAgICAgZmlsdGVyKGZvckdyZWF0ZXIocykpXHJcbiAgICApKHN0YXRlLnJpZ2h0KCkpXHJcbiAgICBsZXQgcmVtb3ZlU2xpZGUgPSB1cGRhdGVSZW1vdmVTbGlkZShzKVxyXG5cclxuICAgIGxldCB1cGRhdGVMaXN0ID0gY29uY2F0KHJlbW92ZVNsaWRlLCB0YWlsKVxyXG5cclxuICAgIHVwZGF0ZUFuZFNhdmVTbGlkZVRhc2sodXBkYXRlTGlzdClcclxuICB9XHJcblxyXG4gIGNvbnN0IGhhbmRsZURyYWdTdGFydCA9IGV2ID0+IHtcclxuICAgIGV2LnRhcmdldC5zdHlsZS5vcGFjaXR5ID0gXCIwLjRcIlxyXG4gICAgZXYuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcIm1vdmVcIlxyXG4gICAgZXYuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIFwicHJldmlld1wiKVxyXG4gICAgc3RhdGUucHJldmlld0RyYWcuZHJhZyA9IGhlYWQoZmlsdGVyKHByb3BFcShcImlkXCIsIHMuaWQpLCBzdGF0ZS5yaWdodCgpKSlcclxuICB9XHJcblxyXG4gIGNvbnN0IGhhbmRsZURyYWdPdmVyID0gZXYgPT4ge1xyXG4gICAgZXYucHJldmVudERlZmF1bHQoKVxyXG5cclxuICAgIGlmIChzdGF0ZS5wcmV2aWV3RHJhZy5kcmFnKSBzdGF0ZS5wcmV2aWV3RHJhZy5kcm9wID0gc1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaGFuZGxlRHJhZ0xlYXZlID0gZXYgPT4ge1xyXG4gICAgZXYucHJldmVudERlZmF1bHQoKVxyXG4gICAgc3RhdGUucHJldmlld0RyYWcuZHJvcCA9IG51bGxcclxuICB9XHJcblxyXG4gIGNvbnN0IGhhbmRsZURyb3AgPSBldiA9PiBldi5wcmV2ZW50RGVmYXVsdCgpXHJcblxyXG4gIGNvbnN0IGhhbmRsZURyYWdFbmQgPSBldiA9PiB7XHJcbiAgICBldi50YXJnZXQuc3R5bGUub3BhY2l0eSA9IFwiMVwiXHJcbiAgICBzdGF0ZS5zbGlkZURyYWcuZHJhZ2dpbmcgPSBmYWxzZVxyXG4gICAgaWYgKHN0YXRlLnByZXZpZXdEcmFnLmRyb3ApIHtcclxuICAgICAgbGV0IHN0YXJ0ID0gc3RhdGUucHJldmlld0RyYWcuZHJhZy5vcmRlclxyXG4gICAgICBsZXQgZW5kID0gc3RhdGUucHJldmlld0RyYWcuZHJvcC5vcmRlclxyXG5cclxuICAgICAgbGV0IGRyYWdnZWQgPSBzdGF0ZS5wcmV2aWV3RHJhZy5kcmFnXHJcbiAgICAgIGxldCBkcm9wcGVkID0gc3RhdGUucHJldmlld0RyYWcuZHJvcFxyXG5cclxuICAgICAgc3RhdGUucHJldmlld0RyYWcuZHJhZyA9IE1vZGVscy5TbGlkZU1vZGVsXHJcbiAgICAgIHN0YXRlLnByZXZpZXdEcmFnLmRyb3AgPSBNb2RlbHMuU2xpZGVNb2RlbFxyXG5cclxuICAgICAgaWYgKCFlcVByb3BzKFwiaWRcIiwgZHJhZ2dlZCwgZHJvcHBlZCkpIHtcclxuICAgICAgICBkcmFnZ2VkLm9yZGVyID0gZW5kXHJcbiAgICAgICAgZHJvcHBlZC5vcmRlciA9IHN0YXJ0XHJcblxyXG4gICAgICAgIHVwZGF0ZUFuZFNhdmVTbGlkZVRhc2soW2RyYWdnZWQsIGRyb3BwZWRdKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgb25jcmVhdGU6ICh7IGRvbSB9KSA9PiBhbmltYXRlRmFkZUluKHsgZG9tIH0pLFxyXG4gICAgdmlldzogKHsgYXR0cnM6IHsgcywgc3RhdGUgfSB9KSA9PlxyXG4gICAgICBtKFxyXG4gICAgICAgIFwiLmNhcmQucHJldmlld1wiLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcclxuICAgICAgICAgIG9uZHJhZ3N0YXJ0OiBoYW5kbGVEcmFnU3RhcnQsXHJcbiAgICAgICAgICBvbmRyYWdlbmQ6IGhhbmRsZURyYWdFbmQsXHJcbiAgICAgICAgICBvbmRyYWdvdmVyOiBoYW5kbGVEcmFnT3ZlcixcclxuICAgICAgICAgIG9uZHJvcDogaGFuZGxlRHJvcCxcclxuICAgICAgICAgIG9uZHJhZ2xlYXZlOiBoYW5kbGVEcmFnTGVhdmUsXHJcbiAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBvcGFjaXR5OlxyXG4gICAgICAgICAgICAgIHN0YXRlLnByZXZpZXdEcmFnLmRyb3AgJiYgc3RhdGUucHJldmlld0RyYWcuZHJvcC5pZCA9PSBzLmlkXHJcbiAgICAgICAgICAgICAgICA/IDAuNFxyXG4gICAgICAgICAgICAgICAgOiAxLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIFtcclxuICAgICAgICAgIG0oXCIuY2FyZC1oZWFkZXJcIiwgW1xyXG4gICAgICAgICAgICBtKFwic3Bhbi5zbGlkZVBvc2l0aW9uXCIsIHMub3JkZXIpLFxyXG4gICAgICAgICAgICBtKFwiYS5wcmV2aWV3LWRlbGV0ZS5jYXJkLWRlbGV0ZVwiLCB7XHJcbiAgICAgICAgICAgICAgb25jbGljazogKCkgPT4gcmVtb3ZlU2xpZGVUYXNrKHMpLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgIF0pLFxyXG4gICAgICAgICAgbShcIi5jYXJkLWJvZHlcIiwgbS50cnVzdChtZC5yZW5kZXIocy5jb250ZW50KSkpLFxyXG4gICAgICAgIF1cclxuICAgICAgKSxcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFByZXZpZXdcclxuIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCdcclxuaW1wb3J0IFRhc2sgZnJvbSAnZGF0YS50YXNrJ1xyXG5pbXBvcnQgeyBsb2csIG1ha2VRdWVyeSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2luZGV4LmpzJ1xyXG5pbXBvcnQgeyB0YWtlLCBwcm9wIH0gZnJvbSAncmFtZGEnXHJcbmltcG9ydCB7XHJcbiAgdXBkYXRlU2xpZGVEcmFnU3RhcnQsXHJcbiAgdXBkYXRlU2xpZGVEcmFnRW5kLFxyXG4gIHVwZGF0ZVN0YXRlRHJhZ0VuZCxcclxuICB1cGRhdGVTbGlkZVRhc2ssXHJcbiAgZGVsZXRlU2xpZGVUYXNrLFxyXG59IGZyb20gJy4uL21vZGVsLmpzJ1xyXG5cclxuY29uc3QgU2xpZGUgPSAoeyBhdHRyczogeyBnZXRTbGlkZXMsIE1vZGVscywgcywga2V5LCBzdGF0ZSB9IH0pID0+IHtcclxuICBjb25zdCBvbkVycm9yID0gdGFzayA9PiBlcnJvciA9PiBsb2coYGVycm9yIHdpdGggJHt0YXNrfWApKGVycm9yKVxyXG4gIGNvbnN0IG9uU3VjY2VzcyA9IF8gPT4gZ2V0U2xpZGVzKHsgYXR0cnM6IHsgTW9kZWxzIH0gfSlcclxuXHJcbiAgY29uc3QgYXV0aERlbGV0ZVRhc2sgPSBpZCA9PlxyXG4gICAgd2luZG93LmNvbmZpcm0oJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGU/JylcclxuICAgICAgPyBUYXNrLm9mKGlkKVxyXG4gICAgICA6IFRhc2sucmVqZWN0ZWQoaWQpXHJcblxyXG4gIGNvbnN0IHJlbW92ZVNsaWRlVGFzayA9IGlkID0+XHJcbiAgICBhdXRoRGVsZXRlVGFzayhpZClcclxuICAgICAgLmNoYWluKGRlbGV0ZVNsaWRlVGFzayhzdGF0ZS5wcmVzZW50YXRpb25JZCkpXHJcbiAgICAgIC5mb3JrKG9uRXJyb3IoJ2RlbGV0aW5nJyksIG9uU3VjY2VzcylcclxuXHJcbiAgY29uc3QgYWRkU2xpZGVUb1Nob3cgPSBzID0+IHtcclxuICAgIHVwZGF0ZVNsaWRlVGFzayhzdGF0ZS5wcmVzZW50YXRpb25JZCkoW3NdKS5mb3JrKG9uRXJyb3IoJ3VwZGF0aW5nJyksIF8gPT4ge1xyXG4gICAgICBzdGF0ZS5zbGlkZURyYWcgPSB7XHJcbiAgICAgICAgZHJhZ0lkOiAnJyxcclxuICAgICAgICBkcmFnZ2luZzogZmFsc2UsXHJcbiAgICAgICAgZHJvcHBhYmxlOiBmYWxzZSxcclxuICAgICAgfVxyXG4gICAgICBvblN1Y2Nlc3MoKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGNvbnN0IGhhbmRsZURyYWdTdGFydCA9IGV2ID0+IHtcclxuICAgIGV2LnRhcmdldC5zdHlsZS5vcGFjaXR5ID0gJzAuNCdcclxuICAgIGV2LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gJ21vdmUnXHJcbiAgICBldi5kYXRhVHJhbnNmZXIuc2V0RGF0YSgndGV4dC9wbGFpbicsICdzbGlkZScpXHJcbiAgICBzdGF0ZS5zbGlkZURyYWcgPSB1cGRhdGVTbGlkZURyYWdTdGFydChzKShzdGF0ZS5zbGlkZURyYWcpXHJcbiAgfVxyXG5cclxuICBjb25zdCBoYW5kbGVEcmFnRW5kID0gZXYgPT4ge1xyXG4gICAgZXYudGFyZ2V0LnN0eWxlLm9wYWNpdHkgPSAnMSdcclxuICAgIGlmIChzdGF0ZS5zbGlkZURyYWcuZHJvcHBhYmxlKSB7XHJcbiAgICAgIGxldCBfc2xpZGUgPSB1cGRhdGVTbGlkZURyYWdFbmQoc3RhdGUucmlnaHQoKS5sZW5ndGgpKHMpXHJcblxyXG4gICAgICB1cGRhdGVTdGF0ZURyYWdFbmQoc3RhdGUuc2xpZGVEcmFnKVxyXG4gICAgICByZXR1cm4gYWRkU2xpZGVUb1Nob3coX3NsaWRlKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHZpZXc6ICh7IGF0dHJzOiB7IHMsIHN0YXRlIH0gfSkgPT5cclxuICAgICAgbShcclxuICAgICAgICAnLmNhcmQnLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGlkOiBzLmlkLFxyXG4gICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgb25kcmFnc3RhcnQ6IGhhbmRsZURyYWdTdGFydCxcclxuICAgICAgICAgIG9uZHJhZ2VuZDogaGFuZGxlRHJhZ0VuZCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIFtcclxuICAgICAgICAgIG0oJ2Rpdi5jYXJkLWhlYWRlcicsIFtcclxuICAgICAgICAgICAgbSggJ2gxLnRpdGxlJywgbSgnc3BhbicsIHRha2UoMTUsIHMudGl0bGUpKSksXHJcbiAgICAgICAgICAgIG0oJ2J1dHRvbi5jYXJkLWRlbGV0ZScsIHtcclxuICAgICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiByZW1vdmVTbGlkZVRhc2socy5pZCksXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgXSksXHJcbiAgICAgICAgICBtKCcuY2FyZC1mb290ZXInLCBtKCdhLmNhcmQtYnRuJyx7XHJcbiAgICAgICAgICAgICAgb25jbGljazogKCkgPT5cclxuICAgICAgICAgICAgICAgIG0ucm91dGUuc2V0KGAvZWRpdC8ke3N0YXRlLnByZXNlbnRhdGlvbklkfS9zbGlkZS8ke3MuaWR9YCksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBtKCdpLmZhcyBmYS1lZGl0JyksXHJcbiAgICAgICAgICAgICAgKSlcclxuICAgICAgICBdXHJcbiAgICAgICksXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTbGlkZVxyXG4iLCJpbXBvcnQgbSBmcm9tIFwibWl0aHJpbFwiXHJcbmltcG9ydCBTdHJlYW0gZnJvbSBcIm1pdGhyaWwtc3RyZWFtXCJcclxuaW1wb3J0IHtcclxuICBjbG9uZSxcclxuICBmaWx0ZXIsXHJcbiAgcHJvcEVxLFxyXG4gIHByb3AsXHJcbiAgd2l0aG91dCxcclxuICBjb25jYXQsXHJcbiAgaGVhZCxcclxuICBzb3J0QnlcclxufSBmcm9tIFwicmFtZGFcIlxyXG5pbXBvcnQgU2xpZGVzTW9kYWwgZnJvbSBcIi4vc2xpZGVzTW9kYWwuanNcIlxyXG5pbXBvcnQgU2xpZGUgZnJvbSBcIi4vU2xpZGUvY29tcG9uZW50LmpzXCJcclxuaW1wb3J0IFByZXZpZXcgZnJvbSBcIi4vUHJldmlldy9jb21wb25lbnQuanNcIlxyXG5pbXBvcnQgeyBsb2FkU2xpZGVzIH0gZnJvbSBcIi4vbW9kZWwuanNcIlxyXG5pbXBvcnQgeyBsb2cgfSBmcm9tIFwiLi4vc2VydmljZXMvaW5kZXguanNcIlxyXG5cclxuY29uc3QgU2xpZGVzID0gKHsgYXR0cnM6IHsgTW9kZWxzIH0gfSkgPT4ge1xyXG4gIGNvbnN0IHN0YXRlID0ge1xyXG4gICAgbGVmdDogU3RyZWFtKFtdKSxcclxuICAgIHJpZ2h0OiBTdHJlYW0oW10pLFxyXG4gICAgc2xpZGVEcmFnOiB7XHJcbiAgICAgIGRyYWdJZDogXCJcIixcclxuICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxyXG4gICAgICBkcm9wcGFibGU6IGZhbHNlXHJcbiAgICB9LFxyXG4gICAgcHJldmlld0RyYWc6IHtcclxuICAgICAgZHJhZzogbnVsbCxcclxuICAgICAgZHJvcDogbnVsbFxyXG4gICAgfSxcclxuICAgIHByZXNlbnRhdGlvbklkOiBcIlwiXHJcbiAgfVxyXG5cclxuICBjb25zdCBvbkVycm9yID0gbG9nKFwiZXJyb3JcIilcclxuXHJcbiAgY29uc3Qgb25TdWNjZXNzID0gKHByZXNlbnRhdGlvbikgPT4ge1xyXG4gICAgbGV0IHNsaWRlcyA9IE1vZGVscy5DdXJyZW50UHJlc2VudGF0aW9uLlNsaWRlc1xyXG5cclxuICAgIHN0YXRlLmxlZnQoZmlsdGVyKHByb3BFcShcIm9yZGVyXCIsIDApLCBzbGlkZXMpKVxyXG5cclxuICAgIHN0YXRlLnJpZ2h0KHNvcnRCeShwcm9wKFwib3JkZXJcIiksIHdpdGhvdXQoc3RhdGUubGVmdCgpLCBzbGlkZXMpKSlcclxuXHJcbiAgICBNb2RlbHMuQ3VycmVudFByZXNlbnRhdGlvbi5zbGlkZVNob3cgPSBTdHJlYW0oc3RhdGUucmlnaHQoKSlcclxuICB9XHJcblxyXG4gIGNvbnN0IGdldFNsaWRlcyA9ICh7IGF0dHJzOiB7IE1vZGVscyB9IH0pID0+IHtcclxuICAgIHN0YXRlLnByZXNlbnRhdGlvbklkID0gbS5yb3V0ZS5wYXJhbShcImlkXCIpXHJcbiAgICByZXR1cm4gbG9hZFNsaWRlcyhzdGF0ZS5wcmVzZW50YXRpb25JZCkoTW9kZWxzKS5mb3JrKG9uRXJyb3IsIG9uU3VjY2VzcylcclxuICB9XHJcblxyXG4gIGNvbnN0IGhhbmRsZURyYWdFbnRlciA9IChldikgPT4ge1xyXG4gICAgZXYucHJldmVudERlZmF1bHQoKVxyXG4gICAgc3RhdGUuYkNvbG9yID0gdHJ1ZVxyXG4gIH1cclxuXHJcbiAgY29uc3QgaGFuZGxlRHJhZ0xlYXZlID0gKGV2KSA9PiB7XHJcbiAgICBldi5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICBzdGF0ZS5zbGlkZURyYWcuZHJhZ2dpbmcgPSBmYWxzZVxyXG4gICAgc3RhdGUuc2xpZGVEcmFnLmRyb3BwYWJsZSA9IGZhbHNlXHJcbiAgICBzdGF0ZS5iQ29sb3IgPSBmYWxzZVxyXG4gIH1cclxuXHJcbiAgY29uc3QgaGFuZGxlRHJvcCA9IChldikgPT4ge1xyXG4gICAgZXYucHJldmVudERlZmF1bHQoKVxyXG4gICAgbGV0IHR5cGUgPSBldi5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHQvcGxhaW5cIilcclxuICAgIGlmIChzdGF0ZS5zbGlkZURyYWcuZHJhZ2dpbmcpIHtcclxuICAgICAgaWYgKHR5cGUgPT0gXCJzbGlkZVwiKSB7XHJcbiAgICAgICAgbGV0IGl0ZW0gPSBoZWFkKFxyXG4gICAgICAgICAgZmlsdGVyKHByb3BFcShcImlkXCIsIHN0YXRlLnNsaWRlRHJhZy5kcmFnSWQpLCBzdGF0ZS5sZWZ0KCkpXHJcbiAgICAgICAgKVxyXG4gICAgICAgIHN0YXRlLnNsaWRlRHJhZy5kcm9wcGFibGUgPSB0cnVlXHJcbiAgICAgICAgaXRlbS5vcmRlciA9IHN0YXRlLnJpZ2h0KCkubGVuZ3RoICsgMVxyXG4gICAgICAgIHN0YXRlLmxlZnQod2l0aG91dChbaXRlbV0sIHN0YXRlLmxlZnQoKSkpXHJcbiAgICAgICAgc3RhdGUucmlnaHQoY29uY2F0KHN0YXRlLnJpZ2h0KCksIFtpdGVtXSkpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGl0ZW0gPSBoZWFkKFxyXG4gICAgICAgICAgZmlsdGVyKHByb3BFcShcImlkXCIsIHN0YXRlLnNsaWRlRHJhZy5kcmFnSWQpLCBzdGF0ZS5yaWdodCgpKVxyXG4gICAgICAgIClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgaGFuZGxlRHJhZ092ZXIgPSAoZXYpID0+IHtcclxuICAgIGV2LnByZXZlbnREZWZhdWx0KClcclxuICAgIGxldCB0eXBlID0gZXYuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpXHJcbiAgICBzdGF0ZS5zbGlkZURyYWcuZHJhZ2dpbmcgPSB0cnVlXHJcbiAgICBldi5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwibW92ZVwiXHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgb25pbml0OiBnZXRTbGlkZXMsXHJcbiAgICB2aWV3OiAoeyBhdHRyczogeyBNb2RlbHMgfSB9KSA9PiBbXHJcbiAgICAgIE1vZGVscy50b2dnbGVNb2RhbFxyXG4gICAgICAgID8gbShTbGlkZXNNb2RhbCwge1xyXG4gICAgICAgICAgICB0b2dnbGVNb2RhbDogKCkgPT4gKE1vZGVscy50b2dnbGVNb2RhbCA9ICFNb2RlbHMudG9nZ2xlTW9kYWwpLFxyXG4gICAgICAgICAgICBsZWZ0OiBzdGF0ZS5sZWZ0LFxyXG4gICAgICAgICAgICBzbGlkZTogY2xvbmUoTW9kZWxzLlNsaWRlTW9kZWwpLFxyXG4gICAgICAgICAgICBnZXRTbGlkZXMsXHJcbiAgICAgICAgICAgIE1vZGVscyxcclxuICAgICAgICAgICAgcElkOiBzdGF0ZS5wcmVzZW50YXRpb25JZFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICA6IFwiXCIsXHJcbiAgICAgIG0oXCIuY29udGFpbmVyLnNsaWRlc1wiLCBbXHJcbiAgICAgICAgbShcclxuICAgICAgICAgIGBhc2lkZS5sZWZ0LWRyYWcgJHtzdGF0ZS5sZWZ0KCkubGVuZ3RoID09IDAgPyBcIi5pc0RyYWdnaW5nXCIgOiBcIlwifWAsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG9uQmVmb3JlUmVtb3ZlOiAodm5vZGUsIGRvbmUpID0+IHtcclxuICAgICAgICAgICAgICB2bm9kZS5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBkb25lKVxyXG4gICAgICAgICAgICAgIHZub2RlLmRvbS5zdHlsZS5hbmltYXRpb24gPSBcImZhZGVPdXQgMXNcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgW1xyXG4gICAgICAgICAgICBzdGF0ZS5sZWZ0KCkubWFwKChzKSA9PlxyXG4gICAgICAgICAgICAgIG0oU2xpZGUsIHtcclxuICAgICAgICAgICAgICAgIGtleTogcy5pZCxcclxuICAgICAgICAgICAgICAgIE1vZGVscyxcclxuICAgICAgICAgICAgICAgIGdldFNsaWRlcyxcclxuICAgICAgICAgICAgICAgIHMsXHJcbiAgICAgICAgICAgICAgICBzdGF0ZVxyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgIF1cclxuICAgICAgICApLFxyXG5cclxuICAgICAgICBtKFxyXG4gICAgICAgICAgYHNlY3Rpb24ucmlnaHQtZHJhZyR7c3RhdGUuc2xpZGVEcmFnLmRyYWdnaW5nID8gXCIuaXNEcmFnZ2luZ1wiIDogXCJcIn1gLFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBvbkJlZm9yZVJlbW92ZTogKHZub2RlLCBkb25lKSA9PiB7XHJcbiAgICAgICAgICAgICAgdm5vZGUuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgZG9uZSlcclxuICAgICAgICAgICAgICB2bm9kZS5kb20uc3R5bGUuYW5pbWF0aW9uID0gXCJmYWRlT3V0IDFzXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25kcmFnbGVhdmU6IGhhbmRsZURyYWdMZWF2ZSxcclxuICAgICAgICAgICAgb25kcm9wOiBoYW5kbGVEcm9wLFxyXG4gICAgICAgICAgICBvbmRyYWdvdmVyOiBoYW5kbGVEcmFnT3ZlcixcclxuICAgICAgICAgICAgb25kcmFnZW50ZXI6IGhhbmRsZURyYWdFbnRlclxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHN0YXRlLnJpZ2h0KCkubWFwKChzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBtKFByZXZpZXcsIHtcclxuICAgICAgICAgICAgICBrZXk6IHMuaWQsXHJcbiAgICAgICAgICAgICAgTW9kZWxzLFxyXG4gICAgICAgICAgICAgIGdldFNsaWRlcyxcclxuICAgICAgICAgICAgICBzLFxyXG4gICAgICAgICAgICAgIHN0YXRlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIClcclxuICAgICAgXSlcclxuICAgIF1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNsaWRlc1xyXG4iLCJpbXBvcnQgeyBnZXRRbFRhc2sgfSBmcm9tICcuLi9zZXJ2aWNlcy9yZXF1ZXN0cy5qcydcclxuaW1wb3J0IHsgY29tcG9zZSwgbHQsIHByb3AsIGd0LCBzZXQsIGxlbnNQcm9wLCBzdWJ0cmFjdCwgcGF0aCB9IGZyb20gJ3JhbWRhJ1xyXG5cclxuY29uc3QgdG9WaWV3TW9kZWwgPSBtb2RlbCA9PiBwcmVzZW50YXRpb25zID0+XHJcbiAgKG1vZGVsLkN1cnJlbnRQcmVzZW50YXRpb24gPSBwcmVzZW50YXRpb25zKVxyXG5cclxuZXhwb3J0IGNvbnN0IHRvU3RydWN0ID0gKGFjYywgaXRlbSkgPT4ge1xyXG4gIGlmIChpdGVtLm9yZGVyID4gMCAmJiAhYWNjLmtleXMuaGFzKGl0ZW0uaWQpKSB7XHJcbiAgICBpdGVtLm9yZGVyID0gYWNjLmtleXMuc2l6ZSArIDFcclxuICAgIGFjYy5rZXlzLmFkZChpdGVtLmlkKVxyXG4gICAgYWNjLnZhbHVlc1tpdGVtLm9yZGVyXSA9IGl0ZW1cclxuICAgIGFjYy5pdGVtcyhPYmplY3Qua2V5cyhhY2MudmFsdWVzKSlcclxuICAgIHJldHVybiBhY2NcclxuICB9XHJcbiAgcmV0dXJuIGFjY1xyXG59XHJcblxyXG5jb25zdCBvcmRlck9mID0gc2xpZGUgPT4gcHJvcCgnb3JkZXInLCBzbGlkZSlcclxuXHJcbmV4cG9ydCBjb25zdCBmb3JHcmVhdGVyID0gcmVtb3ZlU2xpZGUgPT4gY2hlY2tTbGlkZSA9PlxyXG4gIGx0KG9yZGVyT2YocmVtb3ZlU2xpZGUpLCBvcmRlck9mKGNoZWNrU2xpZGUpKVxyXG5cclxuZXhwb3J0IGNvbnN0IGZvckxlc3MgPSByZW1vdmVTbGlkZSA9PiBjaGVja1NsaWRlID0+XHJcbiAgZ3Qob3JkZXJPZihyZW1vdmVTbGlkZSksIG9yZGVyT2YoY2hlY2tTbGlkZSkpXHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlT3JkZXIgPSBzbGlkZSA9PlxyXG4gIHNldChsZW5zUHJvcCgnb3JkZXInLCBzbGlkZSksIHN1YnRyYWN0KG9yZGVyT2Yoc2xpZGUpLCAxKSwgc2xpZGUpXHJcblxyXG5leHBvcnQgY29uc3QgZ2V0SWQgPSBpdGVtID0+IHByb3AoJ2lkJywgaXRlbSlcclxuXHJcbmNvbnN0IHJlc2V0T3JkZXIgPSBzbGlkZSA9PiBzZXQobGVuc1Byb3AoJ29yZGVyJywgc2xpZGUpLCAwLCBzbGlkZSlcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVSZW1vdmVTbGlkZSA9IGNvbXBvc2UoQXJyYXkub2YsIHJlc2V0T3JkZXIpXHJcblxyXG5jb25zdCB1cGRhdGVJZCA9IHNsaWRlID0+IHNsaWRlRHJhZyA9PlxyXG4gIHNldChsZW5zUHJvcCgnZHJhZ0lkJywgc2xpZGVEcmFnKSwgcHJvcCgnaWQnLCBzbGlkZSksIHNsaWRlRHJhZylcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVTbGlkZURyYWdTdGFydCA9IHNsaWRlID0+XHJcbiAgY29tcG9zZSh1cGRhdGVJZChzbGlkZSksIHVwZGF0ZURyYWcpXHJcblxyXG5jb25zdCB1cGRhdGVPcmRlciA9IGxlbmd0aCA9PiBzbGlkZSA9PiBzZXQobGVuc1Byb3AoJ29yZGVyJyksIGxlbmd0aCwgc2xpZGUpXHJcblxyXG5leHBvcnQgY29uc3QgdXBkYXRlU2xpZGVEcmFnRW5kID0gbGVuZ3RoID0+IGNvbXBvc2UodXBkYXRlT3JkZXIobGVuZ3RoKSlcclxuXHJcbmNvbnN0IHVwZGF0ZURyYWcgPSBzdGF0ZSA9PiBzZXQobGVuc1Byb3AoJ2RyYWdnaW5nJywgZmFsc2UsIHN0YXRlKSlcclxuXHJcbmNvbnN0IHVwZGF0ZURyb3AgPSBzdGF0ZSA9PiBzZXQobGVuc1Byb3AoJ2Ryb3BwYWJsZScsIGZhbHNlLCBzdGF0ZSkpXHJcblxyXG5leHBvcnQgY29uc3QgdXBkYXRlU3RhdGVEcmFnRW5kID0gY29tcG9zZSh1cGRhdGVEcm9wLCB1cGRhdGVEcmFnKVxyXG5cclxuZXhwb3J0IGNvbnN0IGxvYWRTbGlkZXMgPSBpZCA9PiBtb2RlbCA9PlxyXG4gIGdldFFsVGFzayhcclxuICAgIGB7IHByZXNlbnRhdGlvbih3aGVyZTp7aWQ6JHtKU09OLnN0cmluZ2lmeShpZCl9fSl7XHJcbiAgICAgIGlkLCB0aXRsZSwgU2xpZGVzIHsgaWQgdGl0bGUgY29udGVudCBvcmRlciB9XHJcbiAgICB9IH1gXHJcbiAgKVxyXG4gICAgLm1hcChwYXRoKFsnZGF0YScsICdwcmVzZW50YXRpb24nXSkpXHJcbiAgICAubWFwKHRvVmlld01vZGVsKG1vZGVsKSlcclxuXHJcbmV4cG9ydCBjb25zdCBzYXZlU2xpZGVUYXNrID0gKHsgdGl0bGUsIG9yZGVyLCBwcmVzZW50YXRpb25faWQgfSkgPT4ge1xyXG4gIGxldCBxID0gYG11dGF0aW9uIHtcclxuICAgICAgICAgICAgdXBkYXRlUHJlc2VudGF0aW9uKFxyXG4gICAgICAgICAgICAgIHdoZXJlOiB7XHJcbiAgICAgICAgICAgICAgICBpZDogJHtKU09OLnN0cmluZ2lmeShwcmVzZW50YXRpb25faWQpfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgIFNsaWRlczp7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICR7SlNPTi5zdHJpbmdpZnkodGl0bGUpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgb3JkZXI6ICR7SlNPTi5zdHJpbmdpZnkob3JkZXIpfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgIH0pe1xyXG4gICAgaWQgdGl0bGUgU2xpZGVzIHsgaWQgdGl0bGUgY29udGVudCBvcmRlciB9XHJcbiAgfSB9YFxyXG5cclxuICByZXR1cm4gZ2V0UWxUYXNrKHEpLm1hcChwYXRoKFsnZGF0YScsICd1cGRhdGVQcmVzZW50YXRpb24nLCAnU2xpZGVzJ10pKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZGVsZXRlU2xpZGVUYXNrID0gcHJlc2VudGF0aW9uX2lkID0+IGlkID0+IHtcclxuICBsZXQgcSA9IGBtdXRhdGlvbiB7XHJcbiAgICAgICAgICAgIHVwZGF0ZVByZXNlbnRhdGlvbihcclxuICAgICAgICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgICAgICAgaWQ6ICR7SlNPTi5zdHJpbmdpZnkocHJlc2VudGF0aW9uX2lkKX1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICBTbGlkZXM6e1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSA6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZDogJHtKU09OLnN0cmluZ2lmeShpZCl9XHJcbiAgICAgICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgIH0pe1xyXG4gICAgaWQgdGl0bGUgU2xpZGVzIHsgaWQgdGl0bGUgY29udGVudCBvcmRlcn1cclxuICB9IH1gXHJcblxyXG4gIHJldHVybiBnZXRRbFRhc2socSkubWFwKHBhdGgoWydkYXRhJywgJ3VwZGF0ZVByZXNlbnRhdGlvbicsICdTbGlkZXMnXSkpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVTbGlkZVRhc2sgPSBwcmVzZW50YXRpb25faWQgPT4gc2xpZGVzID0+IHtcclxuICBsZXQgcWxTbGlkZXMgPSBzbGlkZXMubWFwKFxyXG4gICAgc2xpZGUgPT5cclxuICAgICAgYHtcclxuICAgICAgd2hlcmU6IHtcclxuICAgICAgICBpZDogJHtKU09OLnN0cmluZ2lmeShzbGlkZS5pZCl9XHJcbiAgICAgIH1cclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIG9yZGVyOiAke0pTT04uc3RyaW5naWZ5KHNsaWRlLm9yZGVyKX1cclxuICAgICAgfVxyXG4gICAgfWBcclxuICApXHJcblxyXG4gIGxldCBxID0gYG11dGF0aW9uIHtcclxuICAgICAgICAgICAgdXBkYXRlUHJlc2VudGF0aW9uKFxyXG4gICAgICAgICAgICAgIHdoZXJlOiB7XHJcbiAgICAgICAgICAgICAgICBpZDogJHtKU09OLnN0cmluZ2lmeShwcmVzZW50YXRpb25faWQpfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBTbGlkZXM6e1xyXG4gICAgICAgICAgICAgICAgICB1cGRhdGUgOiBbJHtxbFNsaWRlc31dXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICB7IGlkIHRpdGxlIFNsaWRlcyB7IGlkIHRpdGxlIGNvbnRlbnQgb3JkZXIgfSB9IFxyXG4gICAgICAgIH1gXHJcblxyXG4gIHJldHVybiBnZXRRbFRhc2socSkubWFwKHBhdGgoWydkYXRhJywgJ3VwZGF0ZVByZXNlbnRhdGlvbicsICdTbGlkZXMnXSkpXHJcbn1cclxuIiwiaW1wb3J0IG0gZnJvbSBcIm1pdGhyaWxcIlxyXG5pbXBvcnQgeyBhc3NvYyB9IGZyb20gXCJyYW1kYVwiXHJcbmltcG9ydCB7IHNhdmVTbGlkZVRhc2sgfSBmcm9tIFwiLi9tb2RlbC5qc1wiXHJcblxyXG5jb25zdCBTbGlkZXNNb2RhbCA9ICh7XHJcbiAgYXR0cnM6IHsgbGVmdCwgcElkLCBzbGlkZSwgdG9nZ2xlTW9kYWwsIGdldFNsaWRlcywgTW9kZWxzIH0sXHJcbn0pID0+IHtcclxuICBjb25zdCBzdGF0ZSA9IHtcclxuICAgIGVycm9yczogXCJcIixcclxuICAgIHRpdGxlOiBcIlwiLFxyXG4gIH1cclxuXHJcbiAgY29uc3Qgb25FcnJvciA9IGVycm9ycyA9PiB7XHJcbiAgICBsb2coXCJlcnJvclwiKShlcnJvcnMpXHJcbiAgICBzdGF0ZS5lcnJvcnMgPSBlcnJvcnNcclxuICB9XHJcblxyXG4gIGNvbnN0IG9uU3VjY2VzcyA9IHNsaWRlcyA9PiB7XHJcbiAgICBnZXRTbGlkZXMoeyBhdHRyczogeyBNb2RlbHMgfSB9KVxyXG4gICAgcmV0dXJuIHRvZ2dsZU1vZGFsKClcclxuICB9XHJcblxyXG4gIGNvbnN0IHNhdmUgPSBlID0+IHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgbGV0IGR0byA9IGFzc29jKFwicHJlc2VudGF0aW9uX2lkXCIsIHBJZCwgYXNzb2MoXCJ0aXRsZVwiLCBzdGF0ZS50aXRsZSwgc2xpZGUpKVxyXG4gICAgc2F2ZVNsaWRlVGFzayhkdG8pLmZvcmsob25FcnJvciwgb25TdWNjZXNzKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHZpZXc6ICgpID0+XHJcbiAgICAgIG0oXCJhcnRpY2xlLm1vZGFsLWNvbnRhaW5lclwiLCBbXHJcbiAgICAgICAgbShcIi5jYXJkXCIsIFtcclxuICAgICAgICAgIG0oXHJcbiAgICAgICAgICAgIFwiLmNhcmQtaGVhZGVyXCIsXHJcbiAgICAgICAgICAgIG0oXCJidXR0b24uY2FyZC1kZWxldGVcIiwge1xyXG4gICAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b2dnbGVNb2RhbCgpXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogXCJjbG9zZVwiLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIG0oXCIuY2FyZC1ib2R5XCIsIFtcclxuICAgICAgICAgICAgbShcImZpZWxkc2V0XCIsIFtcclxuICAgICAgICAgICAgICBtKFwibGFiZWwubW9kYWwtbGFiZWxcIiwgXCJTbGlkZSBUaXRsZVwiKSxcclxuICAgICAgICAgICAgICBtKFwiaW5wdXQubW9kYWwtaW5wdXRcIiwge1xyXG4gICAgICAgICAgICAgICAgYXV0b2ZvY3VzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXHJcbiAgICAgICAgICAgICAgICBvbmNoYW5nZTogZSA9PiAoc3RhdGUudGl0bGUgPSBlLnRhcmdldC52YWx1ZSksXHJcbiAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIF0pLFxyXG4gICAgICAgICAgXSksXHJcbiAgICAgICAgICBtKFxyXG4gICAgICAgICAgICBcIi5jYXJkLWZvb3RlclwiLFxyXG4gICAgICAgICAgICBtKFwiYnV0dG9uLmNhcmQtYnRuXCIsIHsgb25jbGljazogc2F2ZSB9LCBcInNhdmUgc2xpZGVcIilcclxuICAgICAgICAgICksXHJcbiAgICAgICAgXSksXHJcbiAgICAgIF0pLFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2xpZGVzTW9kYWxcclxuIiwiaW1wb3J0IG0gZnJvbSBcIm1pdGhyaWxcIlxyXG5pbXBvcnQgeyBwbHVjayB9IGZyb20gXCJyYW1kYVwiXHJcbmltcG9ydCB7IGFuaW1hdGVFbnRyYW5jZVJpZ2h0IH0gZnJvbSBcIi4uL3NlcnZpY2VzL2FuaW1hdGlvbnMuanNcIlxyXG5pbXBvcnQgcmVtYXJrYWJsZSBmcm9tIFwicmVtYXJrYWJsZVwiXHJcblxyXG5jb25zdCBtZCA9IG5ldyByZW1hcmthYmxlKFwiZnVsbFwiLCB7XHJcbiAgYmFzZVVybDogbnVsbCxcclxuICBicmVha3M6IGZhbHNlLFxyXG4gIGdmbTogdHJ1ZSxcclxuICBoZWFkZXJJZHM6IHRydWUsXHJcbiAgaGVhZGVyUHJlZml4OiBcIlwiLFxyXG4gIGhpZ2hsaWdodDogbnVsbCxcclxuICBsYW5nUHJlZml4OiBcImxhbi1cIixcclxuICBtYW5nbGU6IHRydWUsXHJcbiAgcGVkYW50aWM6IGZhbHNlLFxyXG4gIHNhbml0aXplOiBmYWxzZSxcclxuICBzYW5pdGl6ZXI6IG51bGwsXHJcbiAgc2lsZW50OiB0cnVlLFxyXG4gIHNtYXJ0TGlzdHM6IHRydWUsXHJcbiAgc21hcnR5cGFudHM6IHRydWUsXHJcbiAgdGFibGVzOiB0cnVlLFxyXG4gIHhodG1sOiB0cnVlLFxyXG4gIGh0bWw6IHRydWUsXHJcbiAgbGlua2lmeTogdHJ1ZSxcclxuICBsaW5rVGFyZ2V0OiBcIlwiLFxyXG4gIHR5cG9ncmFwaGVyOiB0cnVlLFxyXG4gIHF1b3RlczogXCLigJzigJ3igJjigJlcIixcclxufSlcclxuXHJcbmNvbnN0IFNsaWRlU2hvdyA9ICh7IGF0dHJzOiB7IE1vZGVscyB9IH0pID0+IHtcclxuICBjb25zdCBzdGF0ZSA9IHtcclxuICAgIGN1cnNvcjogMCxcclxuICAgIGlzRnVsbHNjcmVlbldpZHRoOiBcInZoXCIsXHJcbiAgICBpc0Z1bGxzY3JlZW5IZWlnaHQ6IFwiJVwiLFxyXG4gICAgY2xpY2tzOiAwLFxyXG4gICAgc2l6ZTogTW9kZWxzLkN1cnJlbnRQcmVzZW50YXRpb24uc2xpZGVTaG93KCkubGVuZ3RoLFxyXG4gICAgY29udGVudHM6IHBsdWNrKFwiY29udGVudFwiLCBNb2RlbHMuQ3VycmVudFByZXNlbnRhdGlvbi5zbGlkZVNob3coKSksXHJcbiAgfVxyXG5cclxuICBjb25zdCBuZXh0U2xpZGUgPSBkb20gPT4ge1xyXG4gICAgZG9tLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLnNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3VyOiBcInNtb290aFwiIH0pXHJcbiAgICBzdGF0ZS5jdXJzb3IgPT0gc3RhdGUuc2l6ZSAtIDEgPyBzdGF0ZS5jdXJzb3IgOiBzdGF0ZS5jdXJzb3IrK1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcHJldlNsaWRlID0gZG9tID0+IHtcclxuICAgIGRvbS5jaGlsZHJlblswXS5jaGlsZHJlblswXS5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW91cjogXCJzbW9vdGhcIiB9KVxyXG4gICAgc3RhdGUuY3Vyc29yID09IDAgPyBzdGF0ZS5jdXJzb3IgOiBzdGF0ZS5jdXJzb3ItLVxyXG4gIH1cclxuXHJcbiAgY29uc3QgY2hhbmdlU2xpZGUgPSAoa2V5LCB0YXJnZXQpID0+IHtcclxuICAgIHN3aXRjaCAoa2V5KSB7XHJcbiAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcclxuICAgICAgICBwcmV2U2xpZGUodGFyZ2V0KVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XHJcbiAgICAgICAgbmV4dFNsaWRlKHRhcmdldClcclxuICAgICAgICBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG9uaW5pdDogKHN0YXRlLnNsaWRlID0gc3RhdGUuY29udGVudHNbc3RhdGUuY3Vyc29yXSksXHJcbiAgICB2aWV3OiAoeyBhdHRyczogeyBNb2RlbHMgfSB9KSA9PiB7XHJcbiAgICAgIHJldHVybiBtKFxyXG4gICAgICAgIFwiLnNsaWRlc2hvd1wiLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHRhYmluZGV4OiAwLFxyXG4gICAgICAgICAgb25rZXl1cDogKHsga2V5LCB0YXJnZXQgfSkgPT4ge1xyXG4gICAgICAgICAgICBjaGFuZ2VTbGlkZShrZXksIHRhcmdldClcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtKFxyXG4gICAgICAgICAgXCIuc2xpZGVjYXJkXCIsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG9udXBkYXRlOiAoeyBkb20gfSkgPT4gYW5pbWF0ZUVudHJhbmNlUmlnaHQoeyBkb20gfSksXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbS50cnVzdChtZC5yZW5kZXIoc3RhdGUuY29udGVudHNbc3RhdGUuY3Vyc29yXSkgfHwgXCJ+IEZJTiB+XCIpXHJcbiAgICAgICAgKVxyXG4gICAgICApXHJcbiAgICB9LFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2xpZGVTaG93XHJcbiIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy9jc3MtbG9hZGVyLzAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRleC5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy8ucmVnaXN0cnkubnBtanMub3JnL3N0eWxlLWxvYWRlci8wLjIwLjMvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW5kZXguY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzLy5yZWdpc3RyeS5ucG1qcy5vcmcvY3NzLWxvYWRlci8wLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW5kZXguY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==